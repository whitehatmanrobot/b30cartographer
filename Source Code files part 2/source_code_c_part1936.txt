;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}

RM_STATUS class066SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV066_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}

RM_STATUS class066SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class067.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class067.C                                                        *
*   This module implements the NV10_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class067SetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class067SetNotifyCtxDma

RM_STATUS class067SetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067SetNotify

RM_STATUS class067StopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopImage\r\n");

    // class067 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopImage

RM_STATUS class067StopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopLUT\r\n");
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopLUT

RM_STATUS class067StopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopCursorImage

RM_STATUS class067StopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopDAC\r\n");

    // class067 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopDAC

RM_STATUS class067SetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetImageCtxDma

RM_STATUS class067SetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class067SetLUTCtxDma

RM_STATUS class067SetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class067SetCursorCtxDma

RM_STATUS class067SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV067_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetPanOffset

RM_STATUS class067GetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV067_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV067_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV067_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class067ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV067_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV067_SET_IMAGE_OFFSET(0):
        case NV067_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV067_SET_IMAGE_FORMAT(0):
        case NV067_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  when;
            
            buffNum = (Offset == NV067_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;
            
            // when = DRF_VAL(067, _SET_IMAGE, _FORMAT_WHEN, Data);     // XXX win3.1/watcom can't grok this
            when = (Data >> DRF_SHIFT(NV067_SET_IMAGE_FORMAT_WHEN)) & DRF_MASK(NV067_SET_IMAGE_FORMAT_WHEN);
            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) 
            {
                // Change the default flip functionality to end of hsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10);
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);
            }

            // Program the hardware.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                               pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
            {
                pVidLutCurDac->Image[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
            }
            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Do the notify right here.
                class067ImageNotify(pDev, (POBJECT)pVidLutCurDac, 
                                    0 /* param 1*/, buffNum,
                                    NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
            }
            else
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class067ImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class067SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class067ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032      Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV067_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class067SetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV067_SET_LUT_OFFSET(0):
        case NV067_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV067_SET_LUT_FORMAT(0):
        case NV067_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV067_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class067ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class067CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV067_SET_CURSOR_IMAGE_OFFSET(0):
        case NV067_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV067_SET_CURSOR_IMAGE_FORMAT(0):
        case NV067_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032 Head = 0; // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width = 
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =  
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width, 
                                           pVidLutCurDac->CursorImage[buffNum].Height, 
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class067CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    
                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class067SetCursorImageValues

RM_STATUS class067SetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorPoint\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */ 
                                      (Data >> 16));   /* cursorY */
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067SetCursorPoint

RM_STATUS class067SetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV067_SET_DAC_IMAGE_SIZE(0):
        case NV067_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV067_SET_DAC_HORIZONTAL_BLANK(0):
        case NV067_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV067_SET_DAC_HORIZONTAL_SYNC(0):
        case NV067_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical Blank
        //
        case NV067_SET_DAC_VERTICAL_BLANK(0):
        case NV067_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV067_SET_DAC_VERTICAL_SYNC(0):
        case NV067_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV067_SET_DAC_TOTAL_SIZE(0):
        case NV067_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV067_SET_DAC_PIXEL_CLOCK(0):
        case NV067_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV067_SET_DAC_FORMAT(0):
        case NV067_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV067_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV067_SET_DAC_FORMAT_COLOR);

			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.PixelDepth              = pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV067_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid display type ", pVidLutCurDac->DisplayType);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV067_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV067_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV067_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_TEXTURE_FROM_CPU ***************************\
*                                                                           *
* Module: CLASS07B.C                                                        *
*   This module implements the NV10_TEXTURE_FROM_CPU object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class064.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV05_INDEXED_IMAGE_FROM_CPU **************************\
*                                                                           *
* Module: CLASS064.C                                                        *
*   This module implements the NV05_INDEXED_IMAGE_FROM_CPU object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class064Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class064SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        andMask = 0xffffffff;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class064SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV064_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class088.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_DVD_SUBPICTURE ******************************\
*                                                                           *
* Module: CLASS088.C                                                        *
*   This module implements the NV10_DVD_SUBPICTURE object class             *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class089.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV10_SCALED_IMAGE_FROM_MEMORY ************************\
*                                                                           *
* Module: class089.C                                                        *
*   This module implements the NV10_SCALED_IMAGE_FROM_MEMORY object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class065.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV05_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS065.C                                                        *
*   This module implements the NV05_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class065Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class065SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0 );
    
    return (status);
}


RM_STATUS class065SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class065SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV065_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class093.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_CONTEXT_SURFACES_3D ***************************\
*                                                                           *
* Module: CLASS093.C                                                        *
*   This module implements the NV10_CONTEXT_SURFACES_3D object class        *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class094.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_DX5_TEXTURED_TRIANGLE *************************\
*                                                                           *
* Module: CLASS094.C                                                        *
*   This module implements the NV10_DX5_TEXTURED_TRIANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class095.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************** NV10_DX6_MULTI_TEXTURE_TRIANGLE ************************\
*                                                                           *
* Module: CLASS095.C                                                        *
*   This module implements the NV10_DX6_MULTI_TEXTURE_TRIANGLE object class *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07a.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY methods.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#if 0
static RM_STATUS class07AOverlayService(PHWINFO, POBJECT);
#endif

BOOL   HwOwnsBuffer(PHWINFO, U032, POBJECT);
extern VOID NV10_AdjustScalarForTV(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07ASetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;
    
    if (pOverlayObject->CBase.NotifyTrigger)
        return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->CBase.NotifyXlate));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pOverlayObject->CBase.NotifyXlate, 
                              0, 
                              (3 * 0x0010));
    if (status)
    {
        pOverlayObject->CBase.NotifyXlate = NULL;
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class07ASetNotifyCtxDma

RM_STATUS class07ASetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    pOverlayObject->CBase.NotifyAction  = Data;
    pOverlayObject->CBase.NotifyTrigger = TRUE;
    
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07ASetNotify

RM_STATUS class07AStopOverlay
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS                    status;
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;


    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

    return status;
} // end of class07AStopOverlay

RM_STATUS class07ASetOverlayCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    buffNum = (Offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    if (Data == NV01_NULL_OBJECT)
    {
        pOverlayObject->Overlay[buffNum].OverlayCtxDma = NULL;
        pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = NULL;
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->Overlay[buffNum].OverlayCtxDma));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    // The overlay context dma MUST point to the frame buffer.
    if (pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }

    // Give HAL access to context dma.
    pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = &pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo;

    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07ASetOverlayCtxDma

RM_STATUS class07AGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07AGetOffset\r\n");
    
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    if (!pOverlayObject->CBase.NotifyTrigger)
        // nothing to do.
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pOverlayObject->CBase.NotifyXlate) 
    {
        //
        // Give HAL chance to setup offset if necessary.
        //
        (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
        if (status)
            return status;
        status = notifyFillNotifierArray(pDev, pOverlayObject->CBase.NotifyXlate, 
                                         pOverlayObject->HalObject.Overlay[Data].Offset,   // info32
                                         NV07A_NOTIFICATION_INFO16_VALID_OFFSET, // info16
                                         NV07A_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07A_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pOverlayObject->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pOverlayObject, 
                          NV07A_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pOverlayObject->CBase.NotifyAction);
        }
    }

    pOverlayObject->CBase.NotifyTrigger = FALSE; 
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07AGetOffset

RM_STATUS class07ASetOverlayValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayValues\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    // Initialize the overlay description.
    //
    switch (Offset)
    {
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
            return status;
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            RM_STATUS status;
            U032 buffNum;

            buffNum = (Offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            // Check to see if we should awaken and notify 
            if (Data & 0x80000000 ) {
                // if so, set the appropriate action
                //pOverlayObject->Overlay[buffNum].NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
                pOverlayObject->Overlay[buffNum].NotifyAction = 1;
            
            }

            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

            //
            // Ensure class-dependent video service handler is
            // setup properly.
            //
            if (status == RM_OK)
            {
                pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pOverlayObject;
                pDev->pOverlayServiceHandler = videoOverlayService;
            }
            return status;
        }
        default:
            return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07ASetOverlayValues

RM_STATUS class07ASetOverlayPointOutNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayPointOutNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);
    
    return status;
}

RM_STATUS class07ASetOverlayLuminanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayLuminanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}

RM_STATUS class07ASetOverlayChrominanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayChrominanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class076.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_STRETCHED_IMAGE_FROM_CPU *************************\
*                                                                           *
* Module: CLASS076.C                                                        *
*   This module implements the NV4_STRETCHED_IMAGE_FROM_CPU object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class076Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class076SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class076SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class096.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV15_CELSIUS_PRIMITIVE **************************\
*                                                                           *
* Module: CLASS096.C                                                        *
*   This module implements the NV15_CELSIUS_PRIMITIVE object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

extern VOID grGetState(PHWINFO, U032, BOOL);
extern VOID grPutState(PHWINFO, U032, BOOL);
extern VOID grSnapshotPrimAssm(PHWINFO, U032);
extern VOID grReloadPrimAssm(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class072.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV4_CONTEXT_BETA *******************************\
*                                                                           *
* Module: CLASS072.C                                                        *
*   This module implements the NV4_CONTEXT_BETA object class                *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class64.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER methods.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS class64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetDeltaDuDx
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDuDx\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DU_DX(0), Data, &status);

    return (status);
}

RM_STATUS class64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDvDy\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DV_DY(0), Data, &status);

    return (status);
}

RM_STATUS class64SetPoint
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_POINT(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class077.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_SCALED_IMAGE_FROM_MEMORY *************************\
*                                                                           *
* Module: CLASS077.C                                                        *
*   This module implements the NV4_SCALED_IMAGE_FROM_MEMORY object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class077Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class077SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
                
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class65.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <nv32.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetColorFormat
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorFormat\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_FORMAT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_KEY(0), Data, &status);

    return (status);
}

RM_STATUS class65SetPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_POINT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetSize
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetSize\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    //
    // Initialize the color key rectangle.
    //
    // Set the width and height of the color key rectangle.
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
    {
        U032 tempData;

        tempData = (Data & 0x0000FFFF);
        if (tempData > 0x00007FFF)
            tempData = 0x00007FFF;
        Data &= 0xFFFF0000;
        Data |= tempData;
    }

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_SIZE(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07C.C                                                        *
*   This module implements the NV15_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#define IS_2D_BASED_FLIP(pDev, Object)    \
    ((pDev)->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)(Object))

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07CSetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate,
                              0,
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
} // end of class07CSetNotifyCtxDma

RM_STATUS class07CSetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CSetNotify

RM_STATUS class07CStopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopImage\r\n");

    dacDisableImage(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopImage

RM_STATUS class07CStopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopLUT\r\n");
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopLUT

RM_STATUS class07CStopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopCursorImage

RM_STATUS class07CStopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopDAC\r\n");

    // only allow this method if this object was the last one to set a mode on this head
    if (pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)pVidLutCurDac)
    {
        dacDisableDac(pDev, DACGETHEAD(pVidLutCurDac));

        // reset display type
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), 0xffffffff);
    }
    
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
    
} // end of class07CStopDAC

RM_STATUS class07CSetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;

    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetImageCtxDma

RM_STATUS class07CSetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;

    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma,
                              0,
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class07CSetLUTCtxDma

RM_STATUS class07CSetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;

    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma,
                              0,
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class07CSetCursorCtxDma


RM_STATUS class07CSetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV07C_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetPanOffset

RM_STATUS class07CSetSemaphoreCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreCtxDma\r\n");

    //
    // Set the semaphore DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaCtxdma: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Semaphore.SemaphoreCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // There are some rules on alignment of both base/offset.
    // The hardware expects a single page of memory.
    //

    //
    // Validate the dma context.
    // Needs to be one page big at least.
    //
    status = dmaValidateXlate(pVidLutCurDac->Semaphore.SemaphoreCtxDma,
                              0,
                              0x1000);
    if (status)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetSemaphoreCtxDma

RM_STATUS class07CSetSemaphoreOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreOffset: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;


    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaOffset: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    //
    // Alignment check...for the host, 4byte aligned is OK.
    //
    // Note that for nv20 graphics (kelvin) release methods, the
    // alignment must be 16byte to workaround a hw bug.
    //
    if (Data & 0x3)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    pVidLutCurDac->Semaphore.Offset = Data;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetSemaphoreRelease
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 *ReleaseAddr;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreRelease: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: semaphore trigger active!\n");
        DBG_BREAKPOINT();
        return (NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
    }

    status = dmaGetMappedAddress(pDev, pVidLutCurDac->Semaphore.SemaphoreCtxDma, pVidLutCurDac->Semaphore.Offset, 0x0003, (VOID **)&(ReleaseAddr));
    if (status)
        return (status);

    //
    // The actual release will occur after the next flip...
    //
    pVidLutCurDac->Semaphore.ReleaseAddr = ReleaseAddr;
    pVidLutCurDac->Semaphore.ReleaseValue = Data;
    pVidLutCurDac->Semaphore.ReleaseTrigger = TRUE;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetOffsetRange
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         start, stop, polarity;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetOffsetRange\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->Polarity   = Data & 0x80000000;  // top bit is polarity (in/out of range)
    pVidLutCurDac->ScanRegion = Data & 0x7FFFFFFF;  // remaining bits are start/stop offsets

    // Extract the data (polarity indicates if the stall occurs inside or outside the start/stop range)
    start    = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_START)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_START);
    stop     = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_STOP)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_STOP);
    polarity = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_POLARITY)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_POLARITY);

    // Program the hardware
    status = dacProgramScanRegion(pDev, DACGETHEAD(pVidLutCurDac), start, stop, polarity);

    if (status)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    else
        return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class07CSetOffsetRange


RM_STATUS class07CGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CGetOffset\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification.
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                         pVidLutCurDac->Image[Data].Offset,
                                         NV07C_NOTIFICATION_INFO16_VALID_OFFSET,
                                         NV07C_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07C_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_NOTIFY,
                          0 /* Method */,
                          0 /* Data */,
                          status,
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CGetOffset


// This proc writes the notification for an image buffer.
RM_STATUS class07CImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 startAddr;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // assert we're on the expected vblank
    RM_ASSERT(pVidLutCurDac->Image[BuffNum].ImageCallback.VBlankCount ==
              pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter);

    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                Status,
                                NV07C_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }

    // Check if this is a 2D or 3D flip
    if (IS_2D_BASED_FLIP(pDev, Object)) {
        //
        // For 2D panning flips, on a head with an active video overlay, update
        // the window start since DDraw won't see this as windows move event.
        //
        if (pDev->Video.HalInfo.ActiveVideoOverlayObject &&
            (pDev->Video.HalInfo.Head == DACGETHEAD(pVidLutCurDac))) {

            videoUpdateWindowStart(pDev,
                                   pVidLutCurDac->Image[BuffNum].DeltaX,
                                   pVidLutCurDac->Image[BuffNum].DeltaY);
        }
    } else {
        //
        // For 3D flips, if this is a synchronized multihead flip, only
        // the last head that completes their flip will increment READ_3D.
        //
        if (pVidLutCurDac->Image[BuffNum].MultiSync) {
            pDev->Dac.MultiSyncCounter--;
            if (pDev->Dac.MultiSyncCounter == 0) {
                FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
                pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;
            }
        } else {
            FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
        }
    }

    startAddr = (U032)((size_t)(pVidLutCurDac->Image[BuffNum].ImageCtxDma->DescAddr) +
                pVidLutCurDac->Image[BuffNum].Offset);
    // add in the panning offset
    startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

    if (dacProgramVideoStart(pDev, DACGETHEAD(pVidLutCurDac), startAddr, pVidLutCurDac->Image[BuffNum].Pitch))
    {
        pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;
        return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
    }

    //
    // Handle semaphore release.
    //
    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        *pVidLutCurDac->Semaphore.ReleaseAddr = pVidLutCurDac->Semaphore.ReleaseValue;
        pVidLutCurDac->Semaphore.ReleaseTrigger = FALSE;
    }

    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

static
VOID class07CSetScreenDeltaXY
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032 buffNum,
    U032 newOffset
)
{
    S032 pitch, bpp;
    S032 deltaOffset;
    S016 deltaX, deltaY;

    // Get the pitch for the current display width/depth
    nvHalFbGetSurfacePitch(pDev,
                           pDev->Framebuffer.HalInfo.HorizDisplayWidth,
                           pDev->Dac.HalInfo.Depth,
                           (U032 *)&pitch);

    bpp         = (pDev->Dac.HalInfo.Depth + 1) >> 3;    // bytes per pixel
    deltaOffset = (S032)(newOffset - pVidLutCurDac->Image[buffNum].Offset);

    deltaY = (S016)(deltaOffset / pitch);                // delta in screen Y
    deltaX  = (S016)(((deltaOffset) % pitch) / bpp);     // delta in screen X

    pVidLutCurDac->Image[buffNum].DeltaX = deltaX;
    pVidLutCurDac->Image[buffNum].DeltaY = deltaY;
}

RM_STATUS class07CSetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV07C_SET_IMAGE_OFFSET(0):
        case NV07C_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            // For 2D flips, determine the screen delta x,y
            if (IS_2D_BASED_FLIP(pDev, Object)) {
                class07CSetScreenDeltaXY(pDev, pVidLutCurDac, buffNum, Data);
            }

            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;

            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV07C_SET_IMAGE_FORMAT(0):
        case NV07C_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  when, multisync, flags;

            buffNum = (Offset == NV07C_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;

            when = DRF_VAL(07C, _SET_IMAGE_FORMAT, _WHEN, Data);
            multisync = DRF_VAL(07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, Data);
            flags = DRF_VAL(07C, _SET_IMAGE_FORMAT, _FLAGS, Data);

            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;
            pVidLutCurDac->Image[buffNum].MultiSync = multisync;

            if (when == NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Change the default flip functionality to end of hsync.
                DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10, DACGETHEAD(pVidLutCurDac));
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, DACGETHEAD(pVidLutCurDac));
            }

            //
            // Programming the new PCRTC_START occurs during class07CImageNotify,
            // which is called immediately in the case of a flip on hsync or as
            // part of a vblank callback on vsync flips.
            //
            if (when == NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) {

                // This hsync flip happens on the current VBlankCounter
                pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount =
                    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter;

#ifdef  STEREO_SUPPORT
                if (pDev->pStereoParams && pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED)
                {
                    //Shouldn't ever happen because we always force waiting for VSync for stereo.
                    __asm int 3
                } else
#endif  //STEREO_SUPPORT
                    // Do the flip/notify right here.
                    class07CImageNotify(pDev, (POBJECT)pVidLutCurDac,
                                        0 /* param 1*/, buffNum,
                                        NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
            } else {
#ifdef  STEREO_SUPPORT
                U032  startAddr;

                if (pDev->pStereoParams)
                {
                    // TO DO: this is a known truncation for IA64
                    startAddr = (SIZE_PTR)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) +
                                pVidLutCurDac->Image[buffNum].Offset;
                    pDev->pStereoParams->FlipOffsets[3][0] = startAddr;
                }
#endif  //STEREO_SUPPORT

                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class07CImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next   = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1 = 0;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2 = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags = 0;

                if (flags & NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

                // Check if the other buffer is already pending ...
                if (pVidLutCurDac->Image[buffNum ^ 1].NotifyTrigger == FALSE) {
                    // No, program/notify on the next vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 1;
                } else {
                    // Yes, program/notify on the next + 1 vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 2;
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT;
                }

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07CSetImageValues


// This proc is called from VBlank to program the LUT.
RM_STATUS class07CProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032     *startAddr;
    U032      numEntries;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset,
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, DACGETHEAD(pVidLutCurDac), startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                myStatus,
                                NV07C_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          myStatus,
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;
    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class07CSetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV07C_SET_LUT_OFFSET(0):
        case NV07C_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV07C_SET_LUT_FORMAT(0):
        case NV07C_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class07CProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class07CCursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                Status,
                                NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class07CSetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV07C_SET_CURSOR_IMAGE_OFFSET(0):
        case NV07C_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV07C_SET_CURSOR_IMAGE_FORMAT(0):
        case NV07C_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) +
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            
            status = nvHalDacProgramCursorImage(pDev, 
                                           startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width,
                                           pVidLutCurDac->CursorImage[buffNum].Height,
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status)
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, DACGETHEAD(pVidLutCurDac));

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class07CCursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class07CSetCursorImageValues

RM_STATUS class07CSetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, DACGETHEAD(pVidLutCurDac),
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CSetCursorPoint

RM_STATUS class07CSetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV07C_SET_DAC_IMAGE_SIZE(0):
        case NV07C_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048.
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV07C_SET_DAC_HORIZONTAL_BLANK(0):
        case NV07C_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV07C_SET_DAC_HORIZONTAL_SYNC(0):
        case NV07C_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set Vertical Blank
        //
        case NV07C_SET_DAC_VERTICAL_BLANK(0):
        case NV07C_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV07C_SET_DAC_VERTICAL_SYNC(0):
        case NV07C_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set total size.
        //
        case NV07C_SET_DAC_TOTAL_SIZE(0):
        case NV07C_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2.
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        // Set pixel clock.
        case NV07C_SET_DAC_PIXEL_CLOCK(0):
        case NV07C_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV07C_SET_DAC_FORMAT(0):
        case NV07C_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV07C_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_DAC_FORMAT_COLOR);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;

            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;

            // NOTE: the modeset parameters are copied into pDev. This will be changed when we pass the pobject as a parameter to
            // the modeset function.

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;
                        switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
                                case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
                                        pDev->Dac.HalInfo.Depth = 8;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
                                        pDev->Dac.HalInfo.Depth = 15;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
                                        pDev->Dac.HalInfo.Depth = 16;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
                                        pDev->Dac.HalInfo.Depth = 32;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
                                        break;
                        }

            pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;

            //LPL: this is a per-buffer, not per-head property -- are there times it
            // will differ between buffers?  I'm assuming not.
//            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PixelDepth = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            // Get output device...
            pVidLutCurDac->DisplayType            = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid display type ", pVidLutCurDac->DisplayType);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard             = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV07C_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);
            
            if (pVidLutCurDac->CBase.NotifyXlate)
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                                 modeSetStatus,
                                                 NV07C_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                                  NV07C_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */,
                                  0 /* Data */,
                                  modeSetStatus,
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;

            return modeSetStatus;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class08a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS08A.C                                                        *
*   This module implements the NV10_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\classcmn.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Common Class Routines ************************\
*                                                                           *
* Module: classcmn.c                                                        *
*   This module implements the common class routines referenced in the      *
*   classTable in class.c                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"

/*
 * class04D common routines
 */
RM_STATUS Commonclass04DNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageConfig
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageConfig(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageStartLine
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageStartLine(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetVbi(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DSetImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetVbiOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetVbiOffsetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetImageOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetImageOffsetNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class04E common routines
 */
RM_STATUS Commonclass04ENotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ENotify(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04EStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaData(pDev, Object, Method, Offset, Data));
} 
 
RM_STATUS Commonclass04ESetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04EReadData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EReadData(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04EWriteImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EWriteImage(pDev, Object, Method, Offset, Data));
}

/*
 * class04F common routines
 */
RM_STATUS Commonclass04FSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04FNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FNotify(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04FStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FWrite
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FWrite(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FRead
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FRead(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FSetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetInterruptNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class63 common routines
 */
RM_STATUS Commonclass63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63StopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetImageCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63ImageScan
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63ImageScan(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return(class63GetOffsetNotify(pDev, Object, Method, Offset, Data));
}    

/*
 * class64 common routines
 */
RM_STATUS Commonclass64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoInput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDuDx
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDuDx(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDvDy(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetPoint(pDev, Object, Method, Offset, Data));
}  

/*
 * class65 common routines
 */
RM_STATUS Commonclass65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoOutput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoInput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorFormat
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorFormat(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorKey(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetPoint(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetSize
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetSize(pDev, Object, Method, Offset, Data));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c047nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04env10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04EMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV10(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}


#if 0
static VOID GetImageEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV10(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv10.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class63.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class63.C                                                         *
*   This module implements the NV_VIDEO_FROM_MEMORY methods.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

// statics
static RM_STATUS class63XferComplete(PHWINFO, POBJECT, U032, V032, RM_STATUS);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
static RM_STATUS class63WaitVBlank
(
    PHWINFO       pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer,
    U032          waitCount
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBclass63VBlankList[buffer];
    pDev->DBclass63VBlankList[buffer] = VBlankNotify;

    pDev->Video.class63VBlankCount[buffer] = waitCount;

    return (RM_OK);
}

RM_STATUS class63VBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    if (--pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] == 0)
    {
    VBlankNotify = pDev->DBclass63VBlankList[pDev->Framebuffer.Current];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev,
                           VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;

        //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "n");
        
    }
    pDev->DBclass63VBlankList[pDev->Framebuffer.Current] = NULL;
    pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] = 0;
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
RM_STATUS class63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    PVIDEOFROMMEMOBJECT pVidFromMem;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotifyCtxDma\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    if (pVidFromMem->BufferObj.Base.NotifyTrigger)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidFromMem->BufferObj.Base.NotifyXlate));
    if (status)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate, 0, (5 * 0x0010));
    if (status)
    {
        pVidFromMem->BufferObj.Base.NotifyXlate   = NULL;
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    }
    
    //
    // Since NV4 uses the same notify buffer for all buffers, plug them into everywhere
    //
    pVidFromMem->BufferObj.Buffer[0].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    pVidFromMem->BufferObj.Buffer[1].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    
    return (status);
}

RM_STATUS class63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidFromMem->BufferObj.Base.NotifyAction  = Data;
    pVidFromMem->BufferObj.Base.NotifyTrigger = TRUE;
    
    return (RM_OK);
}

RM_STATUS class63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    RM_STATUS           status;
    U032                Head = 0; // single head class
    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    VidLutCurDac.Head = Head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer\r\n");

    //
    // Stop the current data transfer immediately.
    //

    if (pVidFromMem->HalObject.Buffer[0].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
        pVidFromMem->HalObject.Buffer[0].State = OVERLAY_BUFFER_IDLE;
    }
    if (pVidFromMem->HalObject.Buffer[1].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
        pVidFromMem->HalObject.Buffer[1].State = OVERLAY_BUFFER_IDLE;
    }

    //
    // Notify this one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
                    
    //
    // And the other one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
    //
    // Issue stop-immediately call to HAL.
    //
    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_STOP_TRANSFER(0), NVFF8_STOP_TRANSFER_VALUE, &status);
    
    //
    // Transition state of object back to uninitialized.
    //
    pVidFromMem->InitState = 0;

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    // Clear the active overlay object.
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) NULL;

    return status;
}

RM_STATUS class63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032 buffNum;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetImageCtxDma\r\n");

    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    buffNum = (Offset - Method->Low) >> 2;

    //
    // Set the image buffer DMA context.
    //
    status = mthdSetBufferCtxDma(pDev, Object, Method, Offset, Data);

    //
    // Give HAL access to context dma.
    //
    pVidFromMem->HalObject.Buffer[buffNum].bufferCtxDma = &pVidFromMem->BufferObj.Buffer[buffNum].Xlate->HalInfo;

    return status;
}

RM_STATUS class63ImageScan
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT     pVidFromMem;
    PVIDEOFROMMEMHALOBJECT  pVidFromMemHalObj;
    PBUFFEROBJECT           pBuffObject;
    U032                    Buffer;
    RM_STATUS               status;
    U032                    Size;
    U032                    Head = 0; // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63ImageScan\r\n");

    VidLutCurDac.Head = Head;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    pVidFromMemHalObj = &pVidFromMem->HalObject;
    pBuffObject = (PBUFFEROBJECT)Object;
    Buffer = ((Offset - Method->Low) <= 0x10) ? 0 : 1;

    //
    // Initialize the image buffer description.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Offset
        //
        case 0x00:
        case 0x14:
            dmaSetBufferStart(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Start = pBuffObject->Buffer[Buffer].Start;
            break;
        //
        // Set Pitch
        //
        case 0x04:
        case 0x18:
            dmaSetBufferPitch(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Pitch = pBuffObject->Buffer[Buffer].Pitch;
            break;
        //
        // Set Size
        //
        case 0x08:
        case 0x1C:

            //
            // Save away the width separately
            //
            pBuffObject->Buffer[Buffer].Width = (Data & 0xFFFF);
            pVidFromMemHalObj->Buffer[Buffer].Width = (Data & 0xFFFF);

            // Cheat for now to get the length
            Size = (Data & 0xFFFF) * ((Data & 0xFFFF0000)>>16);
            dmaSetBufferLength(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Size);
            pVidFromMemHalObj->Buffer[Buffer].Length = pBuffObject->Buffer[Buffer].Length;
            break;
        //
        // Set Format.
        //
        case 0x0C:
        case 0x20:
			//
			// For now, we must make the assumption that both buffers
			// have the same format.  Makes sense -- but if we want
			// different formats in the future, just move the format
			// field down from the BufferObj into the individual buffers.
			//
            pBuffObject->Sample.Format = Data;
            pVidFromMemHalObj->Format = Data;

            // Q: How do we know that this object is the one pointing to the h/w?
            // If this is a s/w only object then need to disable any writes to h/w!
			
            break;
        //
        // Set Notify
        //
        case 0x10:
        case 0x24:
#ifdef DEBUG_TIMING            
            if ((Offset - Method->Low) == 0x10)
            {    
                //DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_1) - time0hi);
                DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                    
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
            } 
            else
            {    
                //DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_1) - time1hi);
                DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_0) - time1lo);
             
                time1hi = REG_RD32(NV_PTIMER_TIME_1);
                time1lo = REG_RD32(NV_PTIMER_TIME_0);
            }
#endif // DEBUG_TIMING            
            //
            // Verify all required data has been sent
            //  verify rest of imagescan

            //
            // YUV Buffers will be handled normally; RGB buffer will be
            // special cased, since they really aren't double-buffered.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
            {
                U032 when;
                U032 Head = 0;  // this is a single-head class
                //
                // We assume the format, pitch, and length are the same as the 
                // framebuffer.
                //
                // RGB video is not handled as a true double-buffered object,
                // but instead acts as a single-shot transfer with notify.
                // When the app wants a transfer, it sets a notify.  Nothing
                // really moves automatically (unlike back-end Video).
                //

                //
                // !!!!! SIMPLE VALIDATATION NEEDED !!!!!
                //  verify contexts

                //
                // Make sure outstanding notification doesn't exist.
                //
                if (pVidFromMem->VBlankNotify[Buffer].Pending)
                    return (NVFF8_NOTIFICATION_STATUS_IN_PROGRESS);

                //
                // This class does not have support for flipping on HSync.
                // That support is only in class 049 (NV05_VIDEO_LUT_CURSOR_DAC).
                // Simulate it with a registry setting.
                //
                if (IsNV5orBetter(pDev) && pDev->Video.FlipOnHsync == 0x1) 
                {
                    // Flip on HSync instead of VSync.
                    when = NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY; // just use the class 49 define.
                }
                else
                {
                    when = NV049_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER;
                }

                //
                // Validate notification.
                //
                status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate,
                                          0,
                                          0x000F);

                dacProgramVideoStart(pDev, Head,
                                     pBuffObject->Buffer[Buffer].Start,
                                     pBuffObject->Buffer[Buffer].Pitch);

                if (!IsNV10orBetter(pDev) && when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
                {
                    // Change the default flip functionality to end of hsync.
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV5);

                    // Don't wait for VSync for the notify. Just do it right here. The assumption is that
                    // HSync will happen before the driver pays attention to the notification.
                    // Do everything that would have normally been done in VBlank.
                    pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
                    pDev->Framebuffer.FlipTo   = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.Current  ^= 1;

                    class63XferComplete(pDev, Object, Offset, Buffer, RM_OK);
                }
                else
                {
                    //
                    // We want to get a notify when done transferring to Buffer.  The
                    // VBlank notify algorithm works on which buffer you're transferring
                    // from, so we need to flip from the current buffer.  This dictates
                    // that the next vblank will cause this callback.
                    //
                    pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current ^ 1] = pBuffObject->Buffer[Buffer].Start;
                    pDev->Framebuffer.FlipTo = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_FLIP;
                    pVidFromMem->VBlankNotify[Buffer].Object  = Object;
                    pVidFromMem->VBlankNotify[Buffer].Proc    = class63XferComplete;
                    pVidFromMem->VBlankNotify[Buffer].Next    = NULL;
                    pVidFromMem->VBlankNotify[Buffer].Pending = FALSE;
                    pVidFromMem->VBlankNotify[Buffer].Xlate   = pVidFromMem->BufferObj.Base.NotifyXlate;
                    pVidFromMem->VBlankNotify[Buffer].Action  = Data;
                    pVidFromMem->VBlankNotify[Buffer].Param1  = Offset;
                    pVidFromMem->VBlankNotify[Buffer].Param2  = Buffer;

                    status = class63WaitVBlank(pDev, &(pVidFromMem->VBlankNotify[Buffer]), 
                                               pDev->Framebuffer.Current ^ 1, 1);
                }
            } // RGB Video
            else
            {
                //
                // YUV
                //
				// Here is an overview of how hardware overlay works:
                // VideoFroMem, VideoScaler and VideoColorKey objects are setup by DDraw before calling
                // the VideoFromMem->Notify method (which is where we are now).
                // 
                // The Notify method on VideoFromMemory class tells the RM that all the values for one
                // frame are setup and we should program the hardware. The RM then marks the appropriate
                // buffer as BUFFER_BUSY. 
                //
                // class63VideoService is the interrupt handler that handles the "scanout complete"
                // interrupt from the video engine. The video engine is double buffered. So the video
                // engine is constantly toggling the "current buffer". The RM tries to keep feeding
                // the video engine with new values.
                //
                // After handling the notification (if any) of a buffer completion, VideoService tries
                // to kickoff the other buffer. (For example, at the completion of buffer 0, we will try
                // to kickoff buffer 1 if it is in state BUFFER_BUSY). When a buffer is actually kicked off
                // (i.e loaded into the hardware registers), its state is marked BUFFER_NOTIFY_PENDING.
                //
                // If the other buffer is not BUFFER_BUSY at the completion of a buffer, we will restart
                // the same buffer by forcing the hardware to flip to the same buffer again. This is so
                // that we will always get an interrupt even when there are no new values to be loaded.
                // It is necessary to get an interrupt because the interrupt handler is the only place
                // (other than the first time) we actually kickoff a buffer by programming the hardware
                // registers.
                // 
                // State transitions of a buffer:
                // A buffer goes from state BUFFER_IDLE to BUFFER_BUSY when the notify method is invoked.
                // It goes from BUFFER_BUSY to BUFFER_NOTIFY_PENDING when its values are actually programmed
                // into the appropriate hardware registers (in class63InitXfer the very first time and in
                // class63VideoService the rest of the time).
                // It goes from BUFFER_NOTIFY_PENDING to BUFFER_IDLE when the hardware is finished scanning out
                // that buffer and a notification is written for it (in class63VideoService).
                //

                //
                // This will also kick off a call to the bufferXfer proc for this buffer.
                // The very first time the bufferXfer proc is setup to call class63InitXfer.
                //
                if (pBuffObject->Buffer[Buffer].Length) // KJK quick hack so we don't start running immediately!!
                {
                    if (pVidFromMemHalObj->Buffer[Buffer].State != OVERLAY_BUFFER_IDLE)
                    {
                        // Trying to kickoff a busy buffer.
#ifdef DEBUG_TIMING
                        DBG_PRINT_STRING_VALUE(0x10, "******TRYING TO KICKOFF BUSY BUFFER********: ",Buffer);
#endif
                        return NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                    }

                    //
                    // Check for DMA translation instances.
                    //
                    if (!pBuffObject->Buffer[Buffer].Xlate->HalInfo.Instance ||
                        !pBuffObject->Buffer[Buffer].NotifyXlate->HalInfo.Instance)
                        return (RM_ERR_INVALID_XLATE);
                    
                    pBuffObject->Buffer[Buffer].NotifyAction = Data;

                    //
                    // If this is the init stage on this object,
                    // make sure the video overlay hardware is available.
                    //
                    if (pVidFromMem->InitState == 0)
                    {
                        if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject != (POBJECT) NULL)
                        {
                            return NV_OUT_OF_RESOURCES;
                        }

                        //
                        // Validate patch
                        // XXX (scottl): do we need this anymore?!?!?
                        if (!pBuffObject->Valid)
                        {
                            pVidFromMem->CBase.ChID = pBuffObject->Base.ChID;
                            pBuffObject->Valid = TRUE;
                        }
                    }


                    //
                    // Call into HAL to program up any hw.
                    //
                    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_IMAGE_SCAN_NOTIFY(0, Buffer), Data, &status);
                    if (status)
                    {
                        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                                 0, 
                                                 0, 
                                                 status, 
                                                 NVFF8_NOTIFIERS_IMAGE_SCAN(Buffer) );
                    }
                    else
                    {
                        //
                        // If video has just been enabled, then refresh arb settings.
                        //
                        if (pVidFromMem->InitState == 0)
                        {
                            nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);
                            pVidFromMem->InitState = 1;
                        }

                        // Make this the active overlay object.
                        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pVidFromMem;
                        pDev->pOverlayServiceHandler   = videoFromMemService;
                    }
                }
                else
                {
                	// Length is 0. Assume we want to stop the overlay.
                    class63StopTransfer(pDev, (POBJECT)pVidFromMem, 
                                        0 /*Method */, 0 /* Offset */, 0 /* data */);
                }
            }
            break;
    }
    return (RM_OK);
}

RM_STATUS class63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return (RM_OK);
}    

//---------------------------------------------------------------------------
//
//  Buffer transfer routines. 
//
//---------------------------------------------------------------------------

static RM_STATUS class63XferComplete
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63XferComplete\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             Status, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(Data) );
                             
    //KJK dmaEndXfer(pVidFromMem->BBuffer[Data].NotifyXlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (pVidFromMem->BBuffer[Data].NotifyAction)
    {
        osNotifyEvent(pDev, Object, 
                      NVFF8_NOTIFIERS_IMAGE_SCAN(Data),
                      0, 
                      1, 
                      RM_OK, 
                      pVidFromMem->BBuffer[Data].NotifyAction);
                       
    }
    pVidFromMem->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04fnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04FMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV10
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;

            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );

            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV10)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c07anv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV10.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r");
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r");
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // save a softcopy of the POINT_OUT values
            pOverlayHalObj->Overlay[buffNum].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[buffNum].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);

            // save a softcopy of the POINT_OUT values for both buffers
            pOverlayHalObj->Overlay[0].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[0].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            pOverlayHalObj->Overlay[1].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[1].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class09f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV15_IMAGE_BLIT ********************************\
*                                                                           *
* Module: CLASS09F.C                                                        *
*   This module implements the NV15_IMAGE_BLIT object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


#ifdef SHOULD_BE_HW_METHODS

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class09FValidate
(
    PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;

    } else {

        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class09FSetContextColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextClip
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextPattern
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextRop
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta1
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta4
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextSurfaces2d
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS)
    {
        //
        // Set the new value
        //
        andMask = ~DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG);
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}

#endif // SHOULD_BE_HW_METHODS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04dnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV10.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04DMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    PHWREG      nvAddr = pHalHwInfo->nvBaseAddr;
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8_BIT);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16_BIT);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
	// clear the interrupt, in case another shows up!
	REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV10: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c64nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04dnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV20.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04DMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    PHWREG      nvAddr = pHalHwInfo->nvBaseAddr;
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
	// clear the interrupt, in case another shows up!
	REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0

    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV20: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c63nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV10(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV10(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     PVIDEO BUFFER ", REG_RD32(NV_PVIDEO_BUFFER));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV10
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV10(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0, start_buf0=0, start_buf1=0;
    U032 pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV10(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV10;

    status = class63StartXfer_NV10(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv10.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04env20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04EMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV20(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

#if 0
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv20.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c65nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c047nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04fnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04FMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV20
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;
            
            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );
            
            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);
            
            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV20)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c07anv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV20.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r");
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r");
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c65nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c64nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c047nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class047InitXfer_NV04(PHALHWINFO, VOID *, U032);
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class047Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class047StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class047KickoffBuffer_NV04(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047InitXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    RM_STATUS       status = RM_OK;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHWREG          nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047InitXfer_NV04\r\n");

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;

    nvAddr = pHalHwInfo->nvBaseAddr;
        
    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV04_VIDEO_OVERLAY);

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);    
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);    
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class047StartXfer_NV04(pHalHwInfo, pOverlayHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.
        if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
        {
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0);
        }
        else
        {
            // Kickoff buffer 1.
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1);
        }

        //
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing. Making sure to enable the video pipeline
        // from VBLANK (and not doing it here) fixes 19991220-082127.
        //
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;
        
        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pOverlayHalObj->KickOffProc = class047StartXfer_NV04;
    }

    return (status);
}

static VOID class047KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObj,
    U032                        buffNum
)
{
    V032 stateSU;
    PHWREG nvAddr;
    U032 data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047KickoffBuffer");

    nvAddr = pHalHwInfo->nvBaseAddr;

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    }
        
    // this is an NV10 emulator
    // we don't have fractional bobbing abilities
    // we can do 0, -1/4 and -1/2.
    // since we want to keep the bobbing even and can't do -1/4 we'll
    // only use 0 and -1/2.
    // Therefor the system will be to check bit 3 of the 12.4 value
    // if bit 3 is set then we set the bob to -1/2 otherwise 
    if (buffNum == 0) {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 0);
    } else {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 0);
    }

    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);

    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pOverlayHalObj->Overlay[buffNum].WindowStart += NV4_TV_DAC_SHIFT; 
    }
    REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[buffNum].WindowStart);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pOverlayHalObj->Overlay[buffNum].ScaleFactor);
    REG_WR32(NV_PVIDEO_KEY, pOverlayHalObj->Overlay[buffNum].ColorKey);
    if((pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_FLAT_PANEL) &&
        (REG_RD32(NV_PRAMDAC_FP_DEBUG_3) != 0x10001000)) // DFP scaling?
    {
        data32 = pOverlayHalObj->Overlay[buffNum].WindowSize;
        if (data32 != 0) 
            data32 -= 0x00010000;   // subtract 1 from Y
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, data32);
    }
    else
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, pOverlayHalObj->Overlay[buffNum].WindowSize);

    if (pOverlayHalObj->Overlay[buffNum].DisplayWhen == NV047_SET_OVERLAY_FORMAT_DISPLAY_ALWAYS)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);

    if (pOverlayHalObj->Overlay[buffNum].OverlayFormat == NV047_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);

    // Mark buffer as NOTIFY_PENDING.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;
    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

#ifdef DEBUG_TIMING
    vmmOutDebugString("0K");
#endif

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class047StartXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    U032 overlayStartAddr;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047StartXfer_NV04\r\n");

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;

    // Calculate the offset from the begining of frame buffer where the overlay engine should start
    // scanning out.
#if 0
    overlayStartAddr =
        pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase + 
        pOverlayHalObj->Overlay[buffNum].Offset +
        ((pOverlayHalObj->Overlay[buffNum].Pitch * pOverlayObject->Overlay[buffNum].PointIn_t) +
         (pOverlayHalObj->Overlay[buffNum].PointIn_s << 1));
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr - (U032)pHalHwInfo->fbBaseAddr;
#else
    // remember that the point in specs are in 12.4 fixed point... so shift right by 4
    // and remember that's in pixels so 2 bytes per pixel
    
    if ((pOverlayHalObj->Overlay[buffNum].PointIn_t >>4 ) == 0xFFF ) {
        // for when the offset is ACTUALLY zero or just  -1/2
        overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
            (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3);
    } else {
      if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8 ) {
          // there is a negative value in the bob, so add one to
          // the offset here
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
                         ((pOverlayHalObj->Overlay[buffNum].Pitch * ((pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4) + 1)) +
                          (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      } else {
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
              ((pOverlayHalObj->Overlay[buffNum].Pitch * (pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4)) +
               (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      }
    }
    
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr;
#endif

    // Mark the buffer as BUSY. That is all we do here. The hardware registers are
    // programmed in videoService after the current buffer completion.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_BUSY;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
#define OVERLAY_BUFFER_IS_IDLE(obj,buffer) (obj->Overlay[buffer].State == OVERLAY_BUFFER_IDLE)

RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].ColorKey = data;
            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].Offset = data;
            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].SizeIn_width  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_WIDTH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_WIDTH));
            pOverlayHalObj->Overlay[buffNum].SizeIn_height = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT));
            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].PointIn_s  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_S)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_S));
            pOverlayHalObj->Overlay[buffNum].PointIn_t = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_T)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_T));
            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            pOverlayHalObj->Overlay[buffNum].DsDx = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));
            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].DtDy = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            U032 x, y;

            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);

            // Setup the window start. 
            pOverlayHalObj->Overlay[buffNum].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            U032 width, height;

            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            width  = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_WIDTH)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_WIDTH);
            height = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT);

            // Setup the window size.
            pOverlayHalObj->Overlay[buffNum].WindowSize = 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, width) | 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, height);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].Pitch  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_PITCH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_PITCH));
                
            pOverlayHalObj->Overlay[buffNum].OverlayFormat = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_COLOR)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_COLOR));
            
            pOverlayHalObj->Overlay[buffNum].DisplayWhen  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_DISPLAY)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_DISPLAY));


            // call the kickoff proc
			pOverlayHalObj->KickOffProc(pHalHwInfo, pOverlayHalObj, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            U032 x, y;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);
            // Setup the window start in both the overlay buffers. 
            pOverlayHalObj->Overlay[0].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 
            pOverlayHalObj->Overlay[1].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            // Actually write these values to the hardware right away.
            // There will not be a  notify method to kick this off.
            REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[0].WindowStart);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class047 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class047 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class047ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceEventArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceEventArg->events & (1 << 0))
                    pOverlayHalObj->Overlay[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  


                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceEventArg->events & (1 << 1))
                    pOverlayHalObj->Overlay[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceEventArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04fnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: C04FNV04.C                                                        *
*   This module implements the nv4-specific portions of the                 *
*   NV_EXTERNAL_PARALLEL_BUS class (methods, etc.).                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04FMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV04
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, data32;
    S032 saddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
            pPBusHalObj->Write.Data = data;

            //
            // XXX allow for negative addresses to be passed in so we
            // can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Write.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Write.DataSize)
            {
                // 8bit access
                case 0x0001:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data);
                    break;

                    // 16bit access
                case 0x0002:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    break;

                    // 24bit access
                case 0x0003:
                    /* ???
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address)+0x200, pBus->Write.Data & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+1)+0x200, (pBus->Write.Data >> 8) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+2)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       */
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    break;

                    // 32bit access
                case 0x0004:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+3), (pPBusHalObj->Write.Data >> 24) & 0xFF);

                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Write.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Write.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Write.Address)       & 0xFF);
                    
                       REG_WR32(NV_PME_EXTERNAL(0x03)+0x200, (pBus->Write.Data >> 24) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x02)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x01)+0x200, (pBus->Write.Data >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x00)+0x200, (pBus->Write.Data)       & 0xFF);
                       */
                    
                    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ClassNV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY04F Write (index): ", pBus->Write.Address);
                    break;
            }
            
            //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "w");
            
            // Impose a bit of a break
            //tmrDelay(100000);         // 500ns delay    
            break;
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
            pPBusHalObj->Read.Notify = data;

            //
            // XXX allow for negative addresses to be passed in so
            // we can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Read.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Read.DataSize)
            {
                // 8bit access
                case 0x0001:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 16bit access
                case 0x0002:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 24bit access
                case 0x0003:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 32bit access
                case 0x0004:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+3));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    
                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Read.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Read.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Read.Address)       & 0xFF);
                    
                       data32 = REG_RD32(NV_PME_EXTERNAL(0x03)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x02)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x01)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x00)+0x200);
                       */

                    break;
            }

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    intr0 = REG_RD32(NV_PME_INTR_0);

    //
    // If there's a VMI interrupt pending, then we need
    // to let the RM know so it can post notifies.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _VMI, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VMI, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _DISABLED);

    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04env04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04EMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartVidRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif
        
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartVidRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartVidRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
#if 0
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_SYSMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));

        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_SYS, pDecompHalObj->ReadData[0].Offset
                                               + (U032)pDecompHalObj->ReadData[0].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_SYS, pDecompHalObj->ReadData[1].Offset
                                               + (U032)pDecompHalObj->ReadData[1].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 

    }
    else if (pDecompHalObj->ContextDmaData[Buffer]->AddressSpace == ADDR_AGPMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _AGP));
    }
    else
    {
#endif
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
#if 0                                
    }
#endif    
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // we also need to enable Audio in order for Video to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_AUD_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 7);
    
    return(RM_OK);
}

static RM_STATUS class04EStartAudRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartAudRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartAudRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x26); /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _ENABLED);
    
    {
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
                                
    }
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // we also need to enable Video in order for Audio to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_VID_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x27);
    
    return(RM_OK);
}

static RM_STATUS class04EStartWrite
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    U032 stateSU, stateME;
    U032 size;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //
    //
    // Spend some time to validate all data
    //

    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    // For now, assume we are contiguous and in fb memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_FBMEM)
    {
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_IMAGE_BUFF0_START, (U032)(pDecompHalObj->WriteImage[0].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[0].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[0].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecompHalObj->WriteImage[0].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[0].Size & 0xFFFF) * (pDecompHalObj->WriteImage[0].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, size);
        } 
        else
        {
            REG_WR32(NV_PME_IMAGE_BUFF1_START, (U032)(pDecompHalObj->WriteImage[1].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[1].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[1].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecompHalObj->WriteImage[1].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[1].Size & 0xFFFF) * (pDecompHalObj->WriteImage[1].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, size);
        } 

    }
    else 
        ;// NOT SUPPORTED!!!
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    if (Buffer != (stateME >> 24))
        REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _DISABLED);

            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
            REG_WR32(NV_PME_AUD_SU_STATE, 0);
            REG_WR32(NV_PME_AUD_ME_STATE, 0);
            REG_WR32(NV_PME_AUD_RM_STATE, 0);
            REG_WR32(NV_PME_AUD_CURRENT, 0);

            // XXX make sure the MPC's FIFO's are empty
            REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            //
            // Go ahead and write the start address .
            // (write both and aud and vid registers since we
            // don't know which one we'll use yet)
            // 
            if (buffNum == 0) {
                REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
            } 
            else {
                REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
            } 
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            //
            // go ahead and write the length
            // (use audio engine if size < 4K)
            // 
            if (buffNum == 0) {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                }
            } 
            else {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                }
            }
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;

            //
            // KICK IT OFF!!
            //
            if (pDecompHalObj->ReadData[buffNum].Size < 4096) {
                class04EStartAudRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            else {
                class04EStartVidRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // Kick it off
            //
            class04EStartWrite(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateRM = REG_RD32(NV_PME_VID_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

static VOID GetAudioEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetAudioEvents\n");

    return;
}

#ifdef NOTYET
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))
            GetAudioEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    }

#ifdef NOTYET
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }
#endif

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(1):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
#ifdef NOTYET
        case CLASS04E_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04E_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
#endif
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mp.c ===
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include "nvhw.h"

//
// Forwards.
//
V032 mpService(PHWINFO);

//
// mpService
//
// Field MediaPort exceptions by invoking class-dependent handlers.
//
V032 mpService
(
    PHWINFO pDev
)
{
    V032 intrStatus = 0;

    //
    // Decompressor.
    //
    (void) class04EService(pDev);

    //
    // Decoder.
    //
    (void) class04DService(pDev);

    //
    // Parallel bus.
    // This is the interrupt status value we'll return.
    //
    intrStatus = class04FService(pDev);

    return intrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c63nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV04(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO, U032);
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class63Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class63StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class63KickoffBuffer_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63DualSurface_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

static VOID class63ColorKey_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV04(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)
{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, scale, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //
        
    // calculate scaling factors

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;

    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        step_x = ((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1);
        step_y = ((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1);
        scale = ((step_y & 0xfff) << 16) | (step_x & 0xfff);
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START ,vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END   ,vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START ,hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END   ,hbe);    
        
    // Video scalar
    REG_WR32(NV_PVIDEO_STEP_SIZE  ,scale);        // scale factor 1:1
    REG_WR32(NV_PVIDEO_BUFF0_PITCH,pitch0);     // pitch buffer 0
    REG_WR32(NV_PVIDEO_BUFF1_PITCH,pitch1);     // pitch buffer 1
    REG_WR32(NV_PVIDEO_WINDOW_SIZE,hw);         // h (26:16), w (10:0)
}

//
// Program the video scalar to scan out the framebuffer (desktop) to the
// TV encoder.
// Or, turn off the video scalar for TV only or monitor.
//
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff, setup, vbs, vbe, hbs, hbe, scale, start_buf0, start_buf1, pitch0, pitch1, xy_pos, hw, fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;
        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                scale = 0x08000800;     // 1:1
            }            
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // put video scalar in idle state, pointing at buffer 1            
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
#if 0 // we can get stuck if we are in VGA mode; we'll never reach HalInfo.VertDisplayWidth
        // wait end of screen
        reg32 = 0;
        while (reg32 < pHalHwInfo->pFbHalInfo->VertDisplayWidth)
        {
            reg32 = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
        }
#endif
        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    
            
        ////WritePriv32(coeff, NV_PRAMDAC_PLL_COEFF_SELECT);   
        ////WritePriv32(setup, NV_PRAMDAC_TV_SETUP);          
        ////WritePriv32(vbs, NV_PRAMDAC_TV_VBLANK_START);   
        ////WritePriv32(vbe, NV_PRAMDAC_TV_VBLANK_END);    
        ////WritePriv32(hbs, NV_PRAMDAC_TV_HBLANK_START);     
        ////WritePriv32(hbe, NV_PRAMDAC_TV_HBLANK_END);    

        // Video scalar
        REG_WR32(NV_PVIDEO_STEP_SIZE   , scale);        // scale factor 1:1
        REG_WR32(NV_PVIDEO_BUFF0_PITCH , pitch0);     // pitch buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_PITCH , pitch1);     // pitch buffer 1
        REG_WR32(NV_PVIDEO_WINDOW_SIZE , hw);         // h (26:16), w (10:0)
        REG_WR32(NV_PVIDEO_FIFO_THRES  , fifo0);       // fifo fill threshold
        REG_WR32(NV_PVIDEO_FIFO_BURST  , fifo1);       // fifo burst length
        REG_WR32(NV_PVIDEO_WINDOW_START, xy_pos);    // x,y position within buffer (start display here)
        REG_WR32(NV_PVIDEO_BUFF0_START , start_buf0); // start address buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_START , start_buf1); // start address buffer 1
            
        ////WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1
        ////WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0
        ////WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1
        ////WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
        ////WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        ////WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
        ////WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)
        ////WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0
        ////WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1

        // 
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        ////WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE

    }    
    else    // need to set up for either TV only or Monitor only
    {
        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        ////WritePriv32(setup, 0x680700);   // TV SETUP
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }            
}

static VOID class63ColorKey_NV04
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_KEY, color);
                break; 
        }
            
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);
    } 
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
        
    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class63StartXfer_NV04(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.

        if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0);
        }
        else
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1);
        }
        
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing.
        // FLD_WR_DRF_NUM(_PVIDEO, _OVERLAY, _VIDEO, pDev->Video.Enabled);
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;

        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pVidFromMemHalObj->KickOffProc = class63StartXfer_NV04;
    }
    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS       status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv04.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;
#ifdef DEBUG_TIMING
    vmmOutDebugString("\n0B");
#endif

    return (status);
}

static VOID class63KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT      pVidFromMemHalObj,
    U032                        buffNum
)
{
    V032 stateSU;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    }
            
    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);
        
    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pVidFromMemHalObj->Buffer[buffNum].VideoStart += NV4_TV_DAC_SHIFT;
    }

    REG_WR32(NV_PVIDEO_WINDOW_START, pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    REG_WR32(NV_PVIDEO_WINDOW_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoScale);
 
    class63ColorKey_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
        
    // Mark buffer 1 as NOTIFY_PENDING.
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class63 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PHALHWINFO pHalHwInfo;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoService handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class63 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class63ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoServiceArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceArg->events & (1 << 0))
                    pVidFromMemHalObj->Buffer[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceArg->events & (1 << 1))
                    pVidFromMemHalObj->Buffer[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c63nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV20(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV20(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     PVIDEO BUFFER ", REG_RD32(NV_PVIDEO_BUFFER));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV20
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV20(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;


    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0;
    U032 start_buf0=0, start_buf1=0, pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
        videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV20(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV20;

    status = class63StartXfer_NV20(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv20.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04dnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV04.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04DMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
        if (dwRealDivisor >= X_ScaleFactors[dwIndex])
                *dwSpecialIndex = dwIndex;
        dwIndex++;
    }   

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
        {
        *dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
        }

    return (RM_OK);
}
    
static RM_STATUS class04DCalculateScaleIncrement(
    U032 WidthIn,
    U032 HeightIn,
    U032 WidthOut,
    U032 HeightOut,
    U032 *ScaleFactor
)
{
    U032        FittedX, FittedY;
    U032        NearestScaleFactor;
    U032        X_ScaleFactors[]  = { 1,2,3,4,6,8,12,16,24, 0xFFFF };
    U032        X_n0[]            = { 0<<5,1<<5,2<<5,2<<5,3<<5,3<<5,4<<5,4<<5,5<<5, 0xFFFF};
    U032        X_n1[]            = { 0<<8,1<<8,1<<8,2<<8,2<<8,3<<8,3<<8,4<<8,4<<8, 0xFFFF};
    RM_STATUS   status;

    if (WidthOut == 0)
        WidthOut = WidthIn; // if this is too big, should be caught on length boundary

    FittedX = WidthIn / WidthOut;

    if (FittedX > 24)
        FittedX = 24; // max out scale 

    status = class04DFindNearestScaleFactor(FittedX, &NearestScaleFactor);
    if (status)
        return (status);
        
    FittedX = X_ScaleFactors[ NearestScaleFactor ] | X_n0[ NearestScaleFactor ] 
                                | X_n1[ NearestScaleFactor ] ;

    if (HeightOut == 0)
        HeightOut = HeightIn;

    FittedY = ((HeightOut -1 ) << 10) / (HeightIn - 1) ;
                                        
    if (FittedY > 0x400)
        FittedY = 0x400; // check these values (2^11 - 1), bloody small picture!!               

    *ScaleFactor = (FittedY << 16) | FittedX;

    return (RM_OK);
}

        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032 stateSU, stateME;

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old
    // class66 overwrites)
    //
    // only change the bus mode if there isn't a decompressor object
    // using the MPC
    //

    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _2);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);  // also need to enable image (from Joe Yeun)
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_VBI_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_VBI_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_VBI_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_VBI_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VBI_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    }

    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032        stateSU, stateME;
    U032        ScaleFactor;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    status = class04DCalculateScaleIncrement(
                pDecoderHalObj->SetImage[0].WidthIn,
                pDecoderHalObj->SetImage[0].HeightIn,
                pDecoderHalObj->SetImage[0].WidthOut,
                pDecoderHalObj->SetImage[0].HeightOut,
                &ScaleFactor);
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
        return (status);
    }

    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_IMAGE_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF0_SCALE_INCR, ScaleFactor);
    } 
    else
    {
        REG_WR32(NV_PME_IMAGE_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF1_SCALE_INCR, ScaleFactor);
    } 
    
    //
    // Program the global image settings
    //
    REG_WR_DRF_NUM(_PME, _IMAGE_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }
    
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes in
            // IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you can
            // choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _DISABLED);
    
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes
            // in IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you
            // can choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _DISABLED);
         
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware until
            // we actually need it
            //
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
        // clear the interrupt, in case another shows up!
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF0_START );
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF1_START );
            }
        }
    }   

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04D_VBI_EVENT(0):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_VBI_EVENT(1):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c65nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class65
// methods.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mpstate.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/******************************** MP Manager ********************************\
*                                                                           *
* Module: MPSTATE.C                                                         *
*   The MediaPort state is changed in this module.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <modular.h>
#include <mp.h>
#include <os.h>
#include "nvhw.h"

//
// Registry data.
//
extern char strDevNodeRM[];
char strDisableMPC[] = "DisableMPCDetect";

//
// Change MediaPort hardware state.
//
RM_STATUS stateMp
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalMpControl(pDev, MP_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalMpControl(pDev, MP_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalMpControl(pDev, MP_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            U032 data32;

            //
            // Check if MPC Detection has been disabled.
            // It would be nice if this were made into a chip-independent
            // registry setting.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strDisableMPC, &data32) == RM_OK)
            {
                pDev->MediaPort.HalInfo.DetectEnable = 1;
            }
            else
            {
                pDev->MediaPort.HalInfo.DetectEnable = 0;
            }

            //
            // Set initial state to unused.
            //
            pDev->MediaPort.CurrentDecoder = NULL;
            pDev->MediaPort.CurrentDecompressor = NULL;
            pDev->MediaPort.CurrentParallelBusObj = NULL;
            nvHalMpControl(pDev, MP_CONTROL_INIT);
            break;
        }
        case STATE_DESTROY:
            nvHalMpControl(pDev, MP_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mpobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** MP Engine Manager *****************************\
*                                                                           *
* Module: mpobj.c                                                           *
*   Media port engine objects are managed here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include <i2c.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV03_EXTERNAL_VIDEO_DECODER (class04d)
static RM_STATUS mpCreateDecoderObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecoderObj(PHWINFO, POBJECT);

// NV03_EXTERNAL_VIDEO_DECOMPRESSOR (class04e)
static RM_STATUS mpCreateDecompressorObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecompressorObj(PHWINFO, POBJECT);

// NV01_EXTERNAL_PARALLEL_BUS
static RM_STATUS mpCreateParallelBusObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyParallelBusObj(PHWINFO, POBJECT);

//
// Class lock macros (MediaPort class allocations are per-device).
//
#define MPCLASSLOCK_ISSET(pdev,bit)    (pDev->MediaPort.ClassLocks & (1 << bit))
#define MPCLASSLOCK_SET(pdev,bit)      (pDev->MediaPort.ClassLocks |= (1 << bit))
#define MPCLASSLOCK_CLEAR(pdev,bit)    (pDev->MediaPort.ClassLocks &= ~(1 << bit))

//
// mpCreateObj
//
// Top-level create routine for mediaport classes.
//
RM_STATUS mpCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateObj\r\n");

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (MPCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        MPCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpCreateDecoderObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpCreateDecompressorObj(pDev, ClassObject, Name, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpCreateParallelBusObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Create(pDev, ClassObject, Name, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Create(pDev, ClassObject, Name, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            MPCLASSLOCK_CLEAR(pDev, lockBit);
        return (status);
    }

    return (RM_OK);
}

RM_STATUS mpDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(MPCLASSLOCK_ISSET(pDev, lockBit));
        MPCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpDestroyDecoderObj(pDev, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpDestroyDecompressorObj(pDev, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpDestroyParallelBusObj(pDev, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Destroy(pDev, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Destroy(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video decoder create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecoderObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECODEROBJECT         pDecoderObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecoderObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECODEROBJECT));
    if (status)
        return (status);
        
    pDecoderObject = (PVIDEODECODEROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecoderObject;
    for (i = 0; i < sizeof (VIDEODECODEROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, &pDecoderObject->HalObject);
    if (status)
        return (status);

    //
    // Initialize the event processing order.
    // We always start with VBI and buffer number 0. 
    // So assume the last event processed was an image and the
    // last buffer processed was 1.
    //
    pDecoderObject->LastEventProcessed = EVENT_PROCESSED_IMAGE;
    pDecoderObject->LastImageBufferProcessed = 1;
    pDecoderObject->LastVbiBufferProcessed = 1;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecoderObject->CBase, 
                                      pDecoderObject->CBase.ChID, 
                                      pDecoderObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, (VOID *)&pDecoderObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecoder = (VOID_PTR)pDecoderObject;

    return (status);
}

static RM_STATUS mpDestroyDecoderObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECODEROBJECT         pDecoderObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecoderObj\r\n");

    pDecoderObject = (PVIDEODECODEROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, Object->ThisClass->Type, &pDecoderObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecoderObject->CBase, pDecoderObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecoder = NULL;

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video decompressor create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecompressorObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecompressorObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECOMPRESSOROBJECT));
    if (status)
        return (status);
        
    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecompressorObject;
    for (i = 0; i < sizeof (VIDEODECOMPRESSOROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, &pDecompressorObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecompressorObject->CBase, 
                                      pDecompressorObject->CBase.ChID, 
                                      pDecompressorObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, (VOID *)&pDecompressorObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecompressor = (VOID_PTR)pDecompressorObject;

    return (status);
}

static RM_STATUS mpDestroyDecompressorObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecompressorObj\r\n");

    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, Object->ThisClass->Type, &pDecompressorObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecompressorObject->CBase, pDecompressorObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecompressor = NULL;

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Parallel bus create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateParallelBusObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PPARALLELBUSOBJECT          pParallelBusObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateParallelBusObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (PARALLELBUSOBJECT));
    if (status)
        return (status);
        
    pParallelBusObject = (PPARALLELBUSOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pParallelBusObject;
    for (i = 0; i < sizeof (PARALLELBUSOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, &pParallelBusObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pParallelBusObject->CBase, 
                                      pParallelBusObject->CBase.ChID, 
                                      pParallelBusObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, (VOID *)&pParallelBusObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = (VOID_PTR)pParallelBusObject;

    return (status);
}

static RM_STATUS mpDestroyParallelBusObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PPARALLELBUSOBJECT          pParallelBusObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyParallelBusObj\r\n");

    pParallelBusObject = (PPARALLELBUSOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, Object->ThisClass->Type, &pParallelBusObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pParallelBusObject->CBase, pParallelBusObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = NULL;


    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nvkernel.lib:           \
        $(RMLIBDIR)\btree.lib       \
        $(RMLIBDIR)\class.lib       \
        $(RMLIBDIR)\dac.lib         \
        $(RMLIBDIR)\devinit.lib     \
        $(RMLIBDIR)\dma.lib         \
        $(RMLIBDIR)\fb.lib          \
        $(RMLIBDIR)\fifo.lib        \
        $(RMLIBDIR)\gr.lib          \
        $(RMLIBDIR)\hal.lib         \
        $(RMLIBDIR)\heap.lib        \
        $(RMLIBDIR)\mc.lib          \
        $(RMLIBDIR)\modular.lib     \
        $(RMLIBDIR)\mp.lib          \
        $(RMLIBDIR)\state.lib       \
        $(RMLIBDIR)\tmr.lib         \
        $(RMLIBDIR)\vblank.lib      \
        $(RMLIBDIR)\vid.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv4\mpnv04.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV04.C                                                          *
*   The NV04 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include <i2c.h>
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV04(VOID *);
RM_STATUS nvHalMpAlloc_NV04(VOID *);
RM_STATUS nvHalMpFree_NV04(VOID *);
RM_STATUS nvHalMpMethod_NV04(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV04(VOID *);
RM_STATUS nvHalMpServiceEvent_NV04(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV04(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO pMpHalInfo;
    PDACHALINFO pDacHalInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U008 daddr, subaddr, data;
            U008 lock;

            pMpHalInfo->MPCPresent = 0;
            pMpHalInfo->MPCDeviceAddr = 0;

#ifdef IKOS
            return RM_OK;
#endif

            //
            // Allow registry setting to bypass MPC detection.
            //
            if (pMpHalInfo->DetectEnable == 0)
                return RM_OK;

            //
            // Attempt to detect the presence of the external MP ASIC.  If it is not present, don't
            // enable decompressor functionality or attempt to initialize the mediaport
            // registers.  If there's no external clock, we could lock the system.

            // Unlock CRTC extended regs
            CRTC_READ(NV_CIO_SR_LOCK_INDEX, lock);
            CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);
    
            // wayne's MPC detection algorithm
            // (for now only go up to chip addr 0x25, eventhough 0x26/0x27
            // should also be reserved for our use)
            for (daddr = 0x24; daddr <= 0x25; daddr++)
            {
                subaddr = 0x1;
                data = 0x8F;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                subaddr = 0x0;
                data = 0x80;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) != 0xc0)
                    continue;

                subaddr = 0x0;
                data = 0x40;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;

                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) == 0x0)
                {
                    // Found the MediaPort (save addr for use in class51)
                    pMpHalInfo->MPCPresent = 1;
                    pMpHalInfo->MPCDeviceAddr = daddr;
                    break;
                }
            }
    
            //
            // Initialize the mp registers to a known state.  Only do this
            // if we know someone is out there.
            //
            if (pMpHalInfo->MPCPresent)
            {    
    
                //
                // Reset the MPC.
                //
                // MPC Enabled, Video Decoder Disable, TV Encoder Disable
                // Toggle the MPC Reset and DVD Reset low then high
                //
        
                //
                // Internal MPC I2C
                //
                subaddr = 1;    // index
                data = 0xFF;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0x07;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
    
                //
                // Init the mediaport registers
                //
                // Initialize BUS_MODE to be disabled.  It will be initialized by either 
                // class04d (external decoder) or class04e (external decompressor) - JSUN
                //
                REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _VMI));
                REG_WR32(NV_PME_VID_ME_STATE, 0);
                REG_WR32(NV_PME_VID_SU_STATE, 0);
                REG_WR32(NV_PME_VID_RM_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_RM_STATE, 0);
                REG_WR32(NV_PME_VBI_ME_STATE, 0);
                REG_WR32(NV_PME_VBI_SU_STATE, 0);
                REG_WR32(NV_PME_VBI_RM_STATE, 0);
                REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
                REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
                REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
        
                REG_WR_DRF_DEF(_PME, _DEBUG_0, _DET_FIELD_SWITCH, _DISABLED);
                REG_WR32(NV_PME_DEBUG_1, DRF_DEF(_PME, _DEBUG_1, _SEL, _VIPCLK)
                         | DRF_DEF(_PME, _DEBUG_1, _VIPCLK_SEL, _DEFAULT)
                         | DRF_DEF(_PME, _DEBUG_1, _MCLK_SEL, _DEFAULT));
                                       
                //
                // enable MPC display data delivery
                //
                REG_WR32(NV_PME_EXTERNAL(2), 2);
    	
            }                               
            else
            {
                //
                // Default legacy state.  This is currently set manually when the old class66.c
                // is initialized and started.  When that class is retired and replaced with the
                // newer ExternalDecoder class, put this back in.
                //
                //REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _CCIR656));
            }
            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV04(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo =  pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;
            pMpHalPvtInfo = (PMPHALINFO_NV04)pMpAllocArg->pHalHwInfo->pMpHalPvtInfo;
#ifdef COMMENT
            //
            // Disable the MPC if there are no decompressor objects
            // using the MPC.
            //
            if ( pMpHalInfo->CurrentDecompressor == NULL ) {
                if ( pMpHalInfo->MPCPresent ) {
                    subaddr = 1;
                    data = 0x0f;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                    subaddr = 0;
                    data = 0x08;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                }
            }
#endif
            //
            // Make sure to clear the h/w state
            //
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

            //
            // MPC initialization
            //
            REG_WR32(NV_PME_EXTERNAL(3), 0x60);		// set wait states to 3
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
    
            //
            // we also need to make sure Audio is not enabled (NV4 only)
            //
            if (IsNV4_NV04(pMpAllocArg->pHalHwInfo->pMcHalInfo))
            {
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
            }

            pMpHalPvtInfo->CurrentDecompressor = pMpAllocArg->pHalObjInfo;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV04(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PMPHALINFO_NV04 pMpHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pMpHalPvtInfo = (PMPHALINFO_NV04)pMpFreeArg->pHalHwInfo->pMpHalPvtInfo;
    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
#ifdef DISABLE_FOR_NOW
            //
            // disable the MPC 
            //
            subaddr = 1;
            data = 0x0f;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
            subaddr = 0;
            data = 0x08;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
#endif
            pMpHalPvtInfo = 0;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV04(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV04(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV04(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV04(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV04(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV04(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV04(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv\nvkernel.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv10\nv10kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c64nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidScalerHalObj->xStart)
                | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv20\nv20kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv4\nv04kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv10\mpnv10.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV10.C                                                          *
*   The NV10 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV10(VOID *);
RM_STATUS nvHalMpAlloc_NV10(VOID *);
RM_STATUS nvHalMpFree_NV10(VOID *);
RM_STATUS nvHalMpMethod_NV10(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV10(VOID *);
RM_STATUS nvHalMpServiceEvent_NV10(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV10(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV10 pMpHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV10)pHalHwInfo->pMpHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            if (IsNV10orBetter_NV10(pHalHwInfo->pMcHalInfo)) {
                return (RM_OK);
            }
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV10(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV10(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV10(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV10(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV10(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV10(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV10(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV10(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV10(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\tmrinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TMRINIT.C                                                         *
*   Time state is initialized here.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
//  Initialize timer.
//
RM_STATUS  initTmr
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    S032      num;
    S032      den;
    U032      i;

    //
    // Save previous values.
    //
    pDev->Timer.tmrSave[0] = REG_RD32(NV_PTIMER_NUMERATOR);
    pDev->Timer.tmrSave[1] = REG_RD32(NV_PTIMER_DENOMINATOR);
    //
    // Init timer callback list.
    //
    pDev->DBtmrCallbackList = NULL;
    status = osAllocMem((VOID **)&pDev->DBtmrCallbackTable, sizeof(TIMERCALLBACK) * NUM_TIMERCALLBACKS);
    if (status)
        return (status);
    pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackTable;
    for (i = 0; i < NUM_TIMERCALLBACKS - 1; i++)
    {
        pDev->DBtmrCallbackFreeList[i].Next = &(pDev->DBtmrCallbackFreeList[i + 1]);
    }
    pDev->DBtmrCallbackFreeList[i].Next = NULL;
    //
    // Calc numerator and denomenator from DAC NVCLK parameters.
    // From Curtis.
    //
    // num = pDev->Dac.MClk; // The manual says MClk. That is wrong.
    num = pDev->Dac.HalInfo.NVClk;
    den = 31250000;
    while ((num % 2 == 0) && (den % 2 == 0))
    {
        num /= 2;
        den /= 2;
    }
    while ((num % 5 == 0) && (den % 5 == 0))
    {
        num /= 5;
        den /= 5;
    }
    while ((num > 2 * DRF_MASK(NV_PTIMER_NUMERATOR_VALUE))
        || (den > 2 * DRF_MASK(NV_PTIMER_DENOMINATOR_VALUE)))
    {
        num /= 2;
        den /= 2;
    }
    num = (num + 1) / 2;
    den = (den + 1) / 2;
    pDev->Timer.Numerator   = num;
    pDev->Timer.Denominator = den;
    
    REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
    REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
#ifdef RM_STATS
    //
    // Init performance timer to come in every second.
    //
    pDev->Statistics.UpdateLo = 1000000000;
    pDev->Statistics.UpdateHi = 0;
    
    //
    // Zero exception and service counts.
    //
    pDev->Statistics.FifoExceptionCount        = 0;
    pDev->Statistics.FramebufferExceptionCount = 0;
    pDev->Statistics.GraphicsExceptionCount    = 0;
    pDev->Statistics.TotalExceptionCount       = 0;
    pDev->Fifo.ServiceCount                    = 0;
    pDev->Framebuffer.ServiceCount             = 0;
    pDev->Graphics.ServiceCount                = 0;
    pDev->Chip.ServiceCount                    = 0;
    pDev->MediaPort.ServiceCount               = 0;
    pDev->Video.ServiceCount                   = 0;
#endif
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\mp\nv20\mpnv20.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV20.C                                                          *
*   The NV20 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV20(VOID *);
RM_STATUS nvHalMpAlloc_NV20(VOID *);
RM_STATUS nvHalMpFree_NV20(VOID *);
RM_STATUS nvHalMpMethod_NV20(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV20(VOID *);
RM_STATUS nvHalMpServiceEvent_NV20(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV20(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV20 pMpHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV20)pHalHwInfo->pMpHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            return (RM_OK);
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV20(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV20(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV20(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV20(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV20(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV20(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV20(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV20(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV20(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv20\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv20kern.lib:           \
        $(RMLIBDIR)\dacnv20.lib     \
        $(RMLIBDIR)\dmanv20.lib     \
        $(RMLIBDIR)\fbnv20.lib      \
        $(RMLIBDIR)\fifonv20.lib    \
        $(RMLIBDIR)\grnv20.lib      \
        $(RMLIBDIR)\halnv20.lib     \
        $(RMLIBDIR)\mcnv20.lib      \
        $(RMLIBDIR)\modnv20.lib     \
        $(RMLIBDIR)\mpnv20.lib      \
        $(RMLIBDIR)\vidnv20.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv10\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv10kern.lib:           \
        $(RMLIBDIR)\dacnv10.lib     \
        $(RMLIBDIR)\dmanv10.lib     \
        $(RMLIBDIR)\fbnv10.lib      \
        $(RMLIBDIR)\fifonv10.lib    \
        $(RMLIBDIR)\grnv10.lib      \
        $(RMLIBDIR)\halnv10.lib     \
        $(RMLIBDIR)\mcnv10.lib      \
        $(RMLIBDIR)\modnv10.lib     \
        $(RMLIBDIR)\mpnv10.lib      \
        $(RMLIBDIR)\vidnv10.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv4\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv04kern.lib:           \
        $(RMLIBDIR)\dacnv04.lib     \
        $(RMLIBDIR)\dmanv04.lib     \
        $(RMLIBDIR)\fbnv04.lib      \
        $(RMLIBDIR)\fifonv04.lib    \
        $(RMLIBDIR)\grnv04.lib      \
        $(RMLIBDIR)\halnv04.lib     \
        $(RMLIBDIR)\mcnv04.lib      \
        $(RMLIBDIR)\modnv04.lib     \
        $(RMLIBDIR)\mpnv04.lib      \
        $(RMLIBDIR)\vidnv04.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\time.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TIME.C                                                            *
*   Time objects are managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include <nv32.h>
#include <smp.h>
#include "nvhw.h"

//
// Object creation/deletion.
//
RM_STATUS tmrCreateTimer
(
    VOID*      pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *TimeObject,
    VOID*        pCreateParms
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status;
    
    RM_ASSERT(ClassObject->Base.Name == NV1_TIMER);

    status = osAllocMem((VOID **)TimeObject, sizeof(TIMEROBJECT));
    if (status)
        return (status);

//    ((PTIMEROBJECT)*TimeObject)->NotifyXlate  = NULL;
//    ((PTIMEROBJECT)*TimeObject)->NotifyAction = 0;
    ((PTIMEROBJECT)*TimeObject)->State        = BUFFER_IDLE;
    ((PTIMEROBJECT)*TimeObject)->AlarmLo      = 0;
    ((PTIMEROBJECT)*TimeObject)->AlarmHi      = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*TimeObject, ClassObject, UserName);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PTIMEROBJECT)*TimeObject)->CBase, 
                                      ((PTIMEROBJECT)*TimeObject)->CBase.ChID, 
                                      ((PTIMEROBJECT)*TimeObject)->CInstance);
    if (status != RM_OK)
        osFreeMem(*TimeObject);

    return (RM_OK);
}

RM_STATUS tmrDeleteContextTime
(
    POBJECT TimeObject
)
{
    return (osFreeMem(TimeObject));
}

RM_STATUS tmrDeleteTimer
(
	VOID*   pDevHandle,
    POBJECT TimeObject
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;

    //
    // Just in case...
    //
    if (TimeObject == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, TimeObject);
	osExitCriticalCode(pDev);

    //
    // Cancel any outstanding callbacks before deleting object.
    //
    tmrCancelCallback(pDev, TimeObject);
    return (osFreeMem(TimeObject));
}

//
// Methods.
//
RM_STATUS mthdSetTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    U032      TimeCheck;
    U032      TimeLo;
    U032      TimeHi;
    
    status = RM_OK;
    if (Offset == Method->Low)
    {
        ((PTIMEOBJECT)Object)->TimeLo = Data;
    }
    else
    {
        //
        // Treat time values less than 4.29 sec as relative.
        //
        if (!Data)
        {
            do
            {
                TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
                TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
                TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != TimeHi);
            ((PTIMEOBJECT)Object)->TimeLo += TimeLo;
            //
            // Handle carry.
            //
            if (((PTIMEOBJECT)Object)->TimeLo < TimeLo)
                Data = 1;
            Data += TimeHi;    
        }
        ((PTIMEOBJECT)Object)->TimeHi = Data;
        //
        // Reflect new time to all attached objects.
        //
        if (((PTIMEOBJECT)Object)->TimeProc)
            status = ((PTIMEOBJECT)Object)->TimeProc(pDev, ((PTIMEOBJECT)Object)->TimeChange);
    }
    return (status);
}

RM_STATUS mthdSetAlarmNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &((Object)->NotifyXlate));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    //
    // Make sure the context dma is large enough (2 notifiers)
    //    
    status = dmaValidateXlate(Object->NotifyXlate, 0, (2 * 0x0010));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    return (status);
}

RM_STATUS mthdSetAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }
    (Object)->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate((Object)->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(((PTIMEROBJECT)Object)->NotifyXlate, NULL);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Schedule the alarm.
    //
    ((PTIMEROBJECT)Object)->State = BUFFER_BUSY;
    return (tmrScheduleCallbackAbs(pDev,
                                   tmrAlarmNotify,
                                   Object,
                                   ((PTIMEROBJECT)Object)->AlarmHi,
                                   ((PTIMEROBJECT)Object)->AlarmLo));
}

RM_STATUS mthdSetAlarmTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = Data;

    return RM_OK;
}

RM_STATUS mthdSetAlarmTimeRelative
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeLo;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = CurrentTimeLo + Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;

         // if AlarmLo rolled over, increment AlarmHi
         if (((PTIMEROBJECT)Object)->AlarmLo < CurrentTimeLo)
            ((PTIMEROBJECT)Object)->AlarmHi++;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi + Data;

    return RM_OK;
}

//
// Alarm callback.
//
RM_STATUS tmrAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object
)
{
    notifyFillNotifierArray(pDev, (Object)->NotifyXlate, 0, 0, RM_OK,
                            NV004_NOTIFIERS_SET_ALARM_NOTIFY);

    if ((Object)->NotifyAction)
    {
        //
        // Do any OS specified action related to this notification.
        //
        osNotifyEvent(pDev, Object, 
                      1,	  // NV004_NOTIFIERS_SET_ALARM_NOTIFY
                      0, 
                      1, 
                      RM_OK, 
                      (Object)->NotifyAction);
    }

    ((PTIMEROBJECT)Object)->State = BUFFER_IDLE;

    return (RM_OK);
}

RM_STATUS tmrStopTransfer
(
	PHWINFO pDev,
	POBJECT Object, 
	PMETHOD Method, 
	U032    Offset,
	V032	Data
)
{

	return (RM_OK);

}

//
// NV_PTIMER_TIME_0 rolls over approx every 4 secs. For delays
// less than 1/4 of that time just compare against TIME_0
//
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

//
// Timer related functions.
//
RM_STATUS tmrDelay
(
    PHWINFO pDev,
    U032 nsec
)
{
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    U032 IsPllSlowed = 0;  // some compilers think its uninitialized otherwise
    static U032 TimeStart;
    //
    // Check to see if NVCLK is currently being dynamically slowed
    // If so, temporarily disable so we can get a true time delay
    //
    // KJK: I wonder if this should be halified?
    //
    if (IsNV11(pDev))
    {
        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
    }

    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
	TimeStart = REG_RD32(NV_PTIMER_TIME_0);
	while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
	    ;

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

	return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);
    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
	    ;
#if 0
    //
    // There's a potential hang event (or extremely long delay) that can
    // occur here under special circumstances.
    //
    while (TimeLo > (volatile U032)REG_RD32(NV_PTIMER_TIME_0));
#else
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
		       ;
#endif

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    return (RM_OK);
}
RM_STATUS tmrGetCurrentTime
(
	PHWINFO pDev,
    U032 *TimeHi,
    U032 *TimeLo
)
{
    U032 TimeCheck;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        *TimeLo   = REG_RD32(NV_PTIMER_TIME_0);
        *TimeHi   = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != *TimeHi);
    return (RM_OK);
}

RM_STATUS tmrScheduleCallbackRel
(
	PHWINFO pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     RelTimeHi,
    U032     RelTimeLo
)
{
    U032 TimeCheck;
    U032 AbsTimeHi;
    U032 AbsTimeLo;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        AbsTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        AbsTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != AbsTimeHi);

    AbsTimeLo += RelTimeLo;
    if (AbsTimeLo < RelTimeLo)
        AbsTimeHi++;
    AbsTimeHi += RelTimeHi;

    return (tmrScheduleCallbackAbs(pDev, Proc, Object, AbsTimeHi, AbsTimeLo));
}

RM_STATUS tmrScheduleCallbackAbs
(
	PHWINFO  pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     TimeHi,
    U032     TimeLo
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrInsert;
    PTIMERCALLBACK tmrScan;
    
    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if ((TimeHi <  CurrentTimeHi)
    || ((TimeHi == CurrentTimeHi) && (TimeLo <= CurrentTimeLo)))
    {
        //
        // Call immediately if time passed.
        //
        Proc(pDev, Object);
    }
    else
    {
        //
        // Schedule callback at appropriate time.
        //
        tmrInsert = pDev->DBtmrCallbackFreeList;
        if (tmrInsert == NULL)
        {
            //
            // Uh-ho.  Out of callback headers.  Call the proc anyway.
            //
            Proc(pDev, Object);
            return (RM_ERR_OUT_OF_TIMER_CALLBACKS);
        }
        pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackFreeList->Next;
        tmrInsert->Callback = Proc;
        tmrInsert->Object   = Object;
        tmrInsert->TimeLo   = TimeLo;
        tmrInsert->TimeHi   = TimeHi;
        tmrInsert->Next     = NULL;
        if (pDev->DBtmrCallbackList == NULL)
        {
            //
            // Insert this immediatelly.
            //
            pDev->DBtmrCallbackList = tmrInsert;
            REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
        }
        else
        {
            //
            // Scan looking for insert place.
            //
            if ((TimeHi <  pDev->DBtmrCallbackList->TimeHi)
            || ((TimeHi == pDev->DBtmrCallbackList->TimeHi) && (TimeLo <= pDev->DBtmrCallbackList->TimeLo)))
            {
                tmrInsert->Next = pDev->DBtmrCallbackList;
                pDev->DBtmrCallbackList = tmrInsert;
                REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
            }
            else
            {
                tmrScan = pDev->DBtmrCallbackList;
                while (tmrScan->Next)
                {
                    if ((TimeHi <  tmrScan->Next->TimeHi)
                    || ((TimeHi == tmrScan->Next->TimeHi) && (TimeLo <= tmrScan->Next->TimeLo)))
                    {
                        tmrInsert->Next = tmrScan->Next;
                        tmrScan->Next   = tmrInsert;
                        return (RM_OK);
                    }
                    tmrScan = tmrScan->Next;
                }
                tmrScan->Next = tmrInsert;
            }
        }
    }

    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

RM_STATUS tmrCancelCallback
(
	PHWINFO  pDev,
    POBJECT  Object
)
{
    PTIMERCALLBACK tmrDelete;
    PTIMERCALLBACK tmrScan;
    
    if (pDev->DBtmrCallbackList)
    {
        while (pDev->DBtmrCallbackList->Object == Object)
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            if (pDev->DBtmrCallbackList)
                REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            else
                return (RM_OK);
        }
        tmrScan = pDev->DBtmrCallbackList;
        while (tmrScan->Next)
        {
            //
            // Scan list looking for matchs.
            //
            if (tmrScan->Next->Object == Object)
            {
                tmrDelete           = tmrScan->Next;
                tmrScan->Next       = tmrScan->Next->Next;
                tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
                pDev->DBtmrCallbackFreeList = tmrDelete;
            }
            else
            {
                tmrScan = tmrScan->Next;
            }
        }
    }
    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

#ifdef RM_STATS
RM_STATUS tmrStatTimer
(
    PHWINFO pDev,
    POBJECT dummy
)
{
    //
    // Move current service counts to exception counts .
    //
    pDev->Statistics.FifoExceptionCount        = pDev->Fifo.ServiceCount;
    pDev->Statistics.FramebufferExceptionCount = pDev->Framebuffer.ServiceCount;
    pDev->Statistics.GraphicsExceptionCount    = pDev->Graphics.ServiceCount;
    pDev->Statistics.TimerExceptionCount       = pDev->Timer.ServiceCount;
    pDev->Statistics.TotalExceptionCount       = pDev->Chip.ServiceCount;
    pDev->Statistics.ExecTimeLo                = pDev->Chip.ServiceTimeLo;
    pDev->Statistics.ExecTimeHi                = pDev->Chip.ServiceTimeHi;
    pDev->Statistics.IntTimeLo                 = pDev->Chip.ExceptionTimeLo;
    pDev->Statistics.IntTimeHi                 = pDev->Chip.ExceptionTimeHi;
    //
    // Zero service counts.
    //
    pDev->Fifo.ServiceCount        = 0;
    pDev->Framebuffer.ServiceCount = 0;
    pDev->Graphics.ServiceCount    = 0;
    pDev->Timer.ServiceCount       = 0;
    pDev->Video.ServiceCount       = 0;
    pDev->MediaPort.ServiceCount   = 0;
    pDev->Chip.ServiceCount        = 0;
    pDev->Chip.ServiceTimeLo       = 0;
    pDev->Chip.ServiceTimeHi       = 0;
    pDev->Chip.ExceptionTimeLo     = 0;
    pDev->Chip.ExceptionTimeHi     = 0;
    //
    // Schedule next interval.
    //
    tmrScheduleCallbackRel(pDev,
                           tmrStatTimer,
                           (POBJECT)0x69,
                           pDev->Statistics.UpdateHi,
                           pDev->Statistics.UpdateLo);
    return (RM_OK);
}
#endif

//
// Timer alarm service.
//
V032 tmrService
(
    PHWINFO pDev
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrDelete;
    
    REG_WR_DRF_DEF(_PTIMER, _INTR_0, _ALARM, _RESET);
    //
    // Call all callbacks that have expired.
    //
    if (pDev->DBtmrCallbackList)
    {
        do
        {
            TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
            CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
            CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
        } while (TimeCheck != CurrentTimeHi);

        //
        // Check for expired time.
        //
        while ((pDev->DBtmrCallbackList->TimeHi <  CurrentTimeHi)
           || ((pDev->DBtmrCallbackList->TimeHi == CurrentTimeHi) && (pDev->DBtmrCallbackList->TimeLo <= CurrentTimeLo)))
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            //
            // Call callback.  This could insert a new callback into the list.
            //
            tmrDelete->Callback(pDev, tmrDelete->Object);
            if (!pDev->DBtmrCallbackList)
                break;
            REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            do
            {
                TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
                CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
                CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != CurrentTimeHi);
        }
    }    
    return (REG_RD32(NV_PTIMER_INTR_0));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\state\nv\state.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
 
/***************************** HW State Rotuines ***************************\
*                                                                           *
* Module: STATE.C                                                           *
*       Hardware State is managed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vga.h>
#include <os.h>
#include "nvhw.h"
#include "nvcm.h"
#include "nvcmrsvd.h"
#include "dac.h"
#include "edid.h"
#include "mvision.h"

// this is defined in nvarch.h, but I'm not sure its ok to include that here 
// on all platforms
#ifndef RM_SUCCESS
#define RM_SUCCESS(status)  ((status) == RM_OK)
#endif

#define IsAGPCapable(pdev)  (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)

//
// Master state structure.
//
// HWINFO  nvInfo;
//
// State functions. Notice that LOAD/UNLOAD are treated as a pair.
// When an UNLOAD request arrives, the semaphore won't be released
// until a matching LOAD arrives.
//
RM_STATUS stateNv
(
    PHWINFO pDev, // Pointer to an nv device
    U032    msg
)
{
    RM_STATUS status;
//  U032      SemaState;

    status = RM_OK;
    switch (msg)
    {
        case STATE_INIT:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);  // init timer before fb so we can do I2C
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            break;
        case STATE_UPDATE:
            //
            // This is an API routine.  Aquire semaphore.
            //
            //osWaitSemaphore(&SemaState);
        case STATE_LOAD:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            if (msg != STATE_INIT)
            {
                //
                // Don't release semaphore for INIT, wait until
                // LOAD to give up semaphore.
                //
                //osSignalSemaphore(&SemaState);
            }
            break;
        case STATE_UNLOAD:
            //
            // This is an API routine.  Aquire semaphore.
            //
            //osWaitSemaphore(&SemaState);
        case STATE_DESTROY:
            if (!status) status = stateMp(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateMc(pDev, msg);
            if (msg == STATE_DESTROY)
            {
                //
                // Release semaphore for DESTROY, otherwise wait until
                // LOAD to give up semaphore.
                //
                //osSignalSemaphore(&SemaState);
            }
            break;
    }
    return (status);
}

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode_DacClassStyle
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    stateMc(pDev, STATE_UNLOAD);
    stateFb(pDev, STATE_UNLOAD);
    stateVideo(pDev,STATE_UNLOAD);
    stateDac(pDev,STATE_UNLOAD);
    stateTmr(pDev,STATE_UNLOAD);
    stateDma(pDev,STATE_UNLOAD);
    stateGr(pDev, STATE_UNLOAD);
    stateMp(pDev, STATE_UNLOAD);
    
    stateMp(pDev, STATE_LOAD);
    stateGr(pDev, STATE_LOAD);
    stateDma(pDev,STATE_LOAD);
    stateFb(pDev, STATE_LOAD);
    stateTmr(pDev,STATE_LOAD);
    stateDac(pDev,STATE_LOAD);
    stateVideo(pDev,STATE_LOAD);
    stateMc(pDev, STATE_LOAD);

    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    // Unload the current state.
    stateNv(pDev, STATE_UNLOAD);

    // Load the new state.
    stateNv(pDev, STATE_LOAD);

    // tell the driver to load state.
    // We should really be calling the callback function with STATE_LOAD at this time. However,
    // the display driver has worked around this bug. So don't change it till the display
    // driver can deal with us calling it with STATE_LOAD.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetModeMultiHead
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pDac
)
{
    // no state changes are necessary
    dacSetModeMulti(pDev, pDac);

    return RM_OK;
} // end of stateSetMode

//---------------------------------------------------------------------------
//
//  Nv device state information.
//
//---------------------------------------------------------------------------

//
// DDK Entries to get/set system parameters
//
RM_STATUS stateConfigGet(
    PHWINFO pDev,
    U032    index,
    U032*   pValue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result;
   
    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to view
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, 0);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);

        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);
        
        // Relock extended regs
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);

        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // These values actually look at hardware, not NvInfo.
            //
            case NV_CFG_VBLANK_STATUS:
                {
                static U032 VblankDummy;
                U032 Value, monitorType, FlatPanelIsDisabled=1, FlatPanelState;
                //
                // Microsoft requested that we twiddle the state of the returned vblank status
                // because if the monitor is off, some DX apps might lockup, waiting for the
                // vblank status to change.  Instead of changing it in the HAL, they asked
                // us to make the driver handle this case.  So if the monitor is off, we
                // twiddle the vblank status bit. Do this ONLY for Win2k.  For any other OS,
                // just behave as if the monitor is always on, since this only seems
                // to be an issue for Win2k.                   
                //

                Value = 0;                                      // Default monitor to always being on
                
#if (_WIN32_WINNT >= 0x0500)
                // Minor Hack - Call back to the miniport to get the 
                // last DPMS state of the monitor
                Value = GetCurrentDPMSState(pDev->DBmpDeviceExtension);
                Value &= 0xC0;
#endif

                // Check for Flat Panel power state
                monitorType = GETMONITORTYPE(pDev, 0);
                if (monitorType==MONITOR_TYPE_FLAT_PANEL)
                {
                    FlatPanelState= REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _DISPEN);     
                    if (FlatPanelState == NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE)
                        FlatPanelIsDisabled = 1;                // Flat panel is off/disabled
                    else
                        FlatPanelIsDisabled = 0;                // Flat panel is on/active                                           
                }
                
                if ( ((monitorType!=MONITOR_TYPE_FLAT_PANEL) && (Value)) || 
                     ((monitorType==MONITOR_TYPE_FLAT_PANEL) && (FlatPanelIsDisabled)) ) // In power saving mode if either is set
                    Value = (VblankDummy ^= 1);                 // just toggle, so we are sure to get both states
                else
                {
                    Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    if (Value == 0) // make sure we don't have false count. NV3 seems to have glitch during display period.
                    {
                        Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    }

                    if (Value == 0)
                        Value = 1;                              // In VBLANK
                    else
                        { // raster count is nonzero

                        if (Value >= (pDev->Framebuffer.HalInfo.VertDisplayWidth-1))
                            Value = 1;                          // In VBLANK
                        else    
                            Value = 0;                          // NOT in VBLANK
                        }
                

                    } // if in power saving mode            

                result = Value;                                // Return state of vblank

                }
                
                break;

            case NV_CFG_GE_STATUS:
                result = REG_RD32(NV_PGRAPH_STATUS);
                break;

            case NV_CFG_CURRENT_SCANLINE:
                result = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                break;

            case NV_CFG_BIOS_DEFAULT_TV_TYPE:
                {
                  U032 biostvdefault;
                  dacGetBiosDefaultTVType(pDev,&biostvdefault);
                  result = biostvdefault;
                }
                break;

            //
            // Fields in NvInfo.
            //
            case NV_CFG_MANUFACTURER:
                result = pDev->Chip.HalInfo.Manufacturer;
                break;
            case NV_CFG_ARCHITECTURE:
                result = pDev->Chip.HalInfo.Architecture;
                break;
            case NV_CFG_REVISION:
                result = pDev->Chip.HalInfo.MaskRevision;
                break;
            case NV_CFG_BIOS_REVISION:
                result = pDev->Chip.BiosRevision;
                break;
            case NV_CFG_IMPLEMENTATION:
                result = pDev->Chip.HalInfo.Implementation;
                break;
            case NV_CFG_BUS_TYPE:
                result = pDev->Chip.Bus;
                break;
            case NV_CFG_CRYSTAL_FREQ:
                result = pDev->Chip.HalInfo.CrystalFreq;
                break;
            case NV_CFG_BIOS_OEM_REVISION:
                result = pDev->Chip.BiosOEMRevision;
                break;
#ifndef _WIN64
            case NV_CFG_ADDRESS_NVADDR:
                result = (U032) nvAddr;
                break;
#endif
            case NV_CFG_ADDRESS:
                result = pDev->Mapping.PhysAddr;
                break;
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                break;
            case NV_CFG_IO_NEEDED:
                result = pDev->Mapping.doIOToFlushCache;
                break;
            case NV_CFG_DEVICE_INSTANCE:
                result = devInstance;
                break;
#if defined(WIN32) && !defined(NTRM)
            case NV_CFG_DEVICE_HANDLE:
                {   
                    PWIN9XHWINFO    pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                    result = pOsHwInfo->osDeviceHandle;
                }
                break;
#endif
            case NV_CFG_PCI_ID:
                result = pDev->Chip.HalInfo.PCIDeviceID;
                break;            
            case NV_CFG_PCI_SUB_ID:
                result = pDev->Chip.HalInfo.PCISubDeviceID;
                break;            
            case NV_CFG_PROCESSOR_TYPE:
                result = pRmInfo->Processor.Type;
                break;
            case NV_CFG_PROCESSOR_SPEED:
                result = pRmInfo->Processor.Clock;
                break;
            case NV_CFG_GRAPHICS_CAPS:
                result = pDev->Graphics.Capabilities;
                break;
            case NV_CFG_INSTANCE_TOTAL:
                result = pDev->Pram.HalInfo.TotalInstSize;
                break;
            case NV_CFG_INSTANCE_SIZE:
                result = pDev->Pram.FreeInstSize;
                break;
            case NV_CFG_FIFO_COUNT:
                result = pDev->Fifo.HalInfo.Count;
                break;
            case NV_CFG_FIFO_USE_COUNT:
                result = pDev->Fifo.HalInfo.AllocateCount;
                break;
            case NV_CFG_RAM_SIZE_MB:
                result = pDev->Framebuffer.HalInfo.RamSizeMb;
                break;
            case NV_CFG_RAM_SIZE:
                result = pDev->Framebuffer.HalInfo.RamSize;
                break;
            case NV_CFG_RAM_TYPE:
                result = pDev->Framebuffer.HalInfo.RamType;
                break;
            case NV_CFG_AGP_PHYS_BASE:
            {
                if (IsAGPCapable(pDev))        
                    result = pRmInfo->AGP.AGPPhysStart;
                else
                    result = 0;
                break;
            }
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
            {
                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLinearStart;
                else
                    result = 0;
                break;
            }
#endif
            case NV_CFG_AGP_LIMIT:
            {
                // Before returning the AGP limit, update our boot time value
                osUpdateAGPLimit(pDev);

                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLimit;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_HEAP_FREE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPHeapFree;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FW_ENABLE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFWEnable;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FULLSPEED_FW:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFullSpeedFW;
                else
                    result = 0;
                break;
            }
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                break;
            case NV_CFG_PRIMARY_SURFACE_PITCH:
                result = pDev->Dac.DisplayPitch;
                break;
            case NV_CFG_SCREEN_MAX_WIDTH:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1920;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 800;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 800;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxX;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_SCREEN_MAX_HEIGHT:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1200;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 600;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 600;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxY;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_VIDEO_ENCODER_TYPE:
                result = pDev->Dac.EncoderType;
                break;
            case NV_CFG_VIDEO_ENCODER_ID:
                result = pDev->Dac.EncoderID;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_TV_FORMAT:
                result = pDev->Dac.TVStandard;
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                break;
            case NV_CFG_VIDEO_OVERLAY_ALLOWED:
                result = pDev->Video.OverlayAllowed;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_768:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_768;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1280:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1280;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1920:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1920;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                break;
            case NV_CFG_VBLANK_COUNTER:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                break;
            case NV_CFG_PRAM_CURRENT_SIZE:
                result = pDev->Pram.HalInfo.CurrentSize;
                break;
            case NV_CFG_DAC_INPUT_WIDTH:
                result = pDev->Dac.HalInfo.InputWidth;
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.VClk;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                break;
            case NV_CFG_DAC_VPLL_M:
                result = pDev->Dac.HalInfo.VPllM;
                break;
            case NV_CFG_DAC_VPLL_N:
                result = pDev->Dac.HalInfo.VPllN;
                break;
            case NV_CFG_DAC_VPLL_O:
                result = pDev->Dac.HalInfo.VPllO;
                break;
            case NV_CFG_DAC_VPLL_P:
                result = pDev->Dac.HalInfo.VPllP;
                break;
            case NV_CFG_DAC_MPLL_M:
                result = pDev->Dac.HalInfo.MPllM;
                break;
            case NV_CFG_DAC_MPLL_N:
                result = pDev->Dac.HalInfo.MPllN;
                break;
            case NV_CFG_DAC_MPLL_O:
                result = pDev->Dac.HalInfo.MPllO;
                break;
            case NV_CFG_DAC_MPLL_P:
                result = pDev->Dac.HalInfo.MPllP;
                break;
            case NV_CFG_DAC_PCLK_LIMIT_8BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit8bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_16BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit16bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_32BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit32bpp);
                break;            
#ifdef _WIN32
            case NV_CFG_MAPPING_BUSDEVICEFUNC:
                result = (pDev->Mapping.nvBusDeviceFunc << 8) | REG_RD32(NV_PBUS_PCI_NV_0);
                break;
#endif
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                rmStatus = dacReadTVOutFromRegistry(pDev, Head, &result);
                break;
            }
            case NV_CFG_NUMBER_OF_HEADS:
                result = pDev->Dac.HalInfo.NumCrtcs;
                break;

            case NV_CFG_NUMBER_OF_ACTIVE_HEADS:
            {
                U032 i;
                for (i = 0, result = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                    if (pDev->Dac.CrtcInfo[i].pVidLutCurDac)
                        result++;
                break;
            }
            case NV_CFG_INITIAL_BOOT_HEAD:
                result = pDev->Dac.HalInfo.InitialBootHead;
                break;
#ifdef LINUX
            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                *pValue = pDev->Chip.IntrEn0;
                break;
#endif
#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to read current debug
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                break;
            }
#endif

            case NV_CFG_GET_ALL_DEVICES:
                result = pDev->Dac.DevicesBitMap;
                break;

            case NV_CFG_GET_BOOT_DEVICES:
                result = pDev->Dac.BootDevicesBitMap;
                break;

            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    // save the result
    *pValue = result;

    return rmStatus;
}

//
// Returns the original value
//
RM_STATUS stateConfigSet(
    PHWINFO pDev, // Pointer to an nv device
    U032    index,
    U032    newvalue,
    U032*   pOldvalue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to modify
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, 0);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);

        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);

        //
        // Update the new value
        //
        CRTC_WR((index & 0xFF), newvalue, 0);
        
        // Relock extended regs
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);

        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // Fields in NvInfo.
            //
            case NV_CFG_AGP_PHYS_BASE:
                result = pRmInfo->AGP.AGPPhysStart;
                pRmInfo->AGP.AGPPhysStart = newvalue;
                break;
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
                result = pRmInfo->AGP.AGPLinearStart;
                pRmInfo->AGP.AGPLinearStart = newvalue;
                break;
#endif
            case NV_CFG_AGP_LIMIT:
                result = pRmInfo->AGP.AGPLimit;
                pRmInfo->AGP.AGPLimit = newvalue;
                break;
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                pDev->Framebuffer.HalInfo.HorizDisplayWidth = newvalue;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                pDev->Framebuffer.HalInfo.VertDisplayWidth = newvalue;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                pDev->Dac.HalInfo.Depth = newvalue;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                SETDISPLAYTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                SETMONITORTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                pDev->Framebuffer.HalInfo.RefreshRate = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                pDev->Framebuffer.Underscan_x = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                pDev->Framebuffer.Underscan_y = newvalue;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                pDev->Dac.CrtcInfo[0].VBlankToggle = newvalue;
                break;
            case NV_CFG_VBLANK_COUNTER:
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                pDev->Dac.CrtcInfo[0].VBlankCounter = newvalue;
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.PixelClock;
                pDev->Dac.HalInfo.PixelClock = newvalue;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                pDev->Dac.HalInfo.MClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_MPLL;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                pDev->Dac.HalInfo.NVClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_NVPLL;
                break;
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                dacWriteTVOutToRegistry(pDev, Head, newvalue);
                break;
            }
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                pDev->Mapping.IntLine = newvalue; 
                break;
#ifdef  STEREO_SUPPORT
            case NV_CFG_STEREO_CONFIG:
                if (result = (U032)pDev->pStereoParams &&
                    pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
                {
                    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
                    //Stereo was previously activated. We want to make
                    //sure we are flipped to the primary left eye.
                    //pDev->pStereoParams->FlipOffsets[3][0] is supposed
                    //to point us to the primary surface offset.
                    vidLutCurDacHalObj.Head = 0;
                    nvHalDacSetStartAddr(pDev, pDev->pStereoParams->FlipOffsets[3][0], &vidLutCurDacHalObj);
                }
                pDev->pStereoParams = (LPNV_CFG_STEREO_PARAMS)newvalue;
                break;
#endif  //STEREO_SUPPORT

#ifdef LINUX
            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                result = pDev->Chip.IntrEn0;
                pDev->Chip.IntrEn0 = newvalue;
                RmEnableInterrupts(pDev);           // will just slam in IntrEn0
                break;
#endif

#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                pDev->Statistics.UpdateLo = newvalue;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                pDev->Statistics.UpdateHi = newvalue;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                pDev->Statistics.FifoExceptionCount = newvalue;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                pDev->Statistics.FramebufferExceptionCount = newvalue;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                pDev->Statistics.GraphicsExceptionCount = newvalue;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                pDev->Statistics.TimerExceptionCount = newvalue;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                pDev->Statistics.TotalExceptionCount = newvalue;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                pDev->Statistics.MemAlloced = newvalue;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                pDev->Statistics.MemLocked = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                pDev->Statistics.ExecTimeLo = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                pDev->Statistics.ExecTimeHi = newvalue;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                pDev->Statistics.IntTimeLo = newvalue;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                pDev->Statistics.IntTimeHi = newvalue;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to set current debug level
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                cur_debuglevel = newvalue;
                break;
            }
#endif

            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    *pOldvalue = result;

    return rmStatus; 
}

RM_STATUS stateConfigGetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: getEx index ", index);

    switch (index)
    {
        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;  // for legacy compatibility, there is no parameter passed 
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                if (Params->GetDefault)
                {
                    dacGetMonitorDefaultPosition(pDev, 
                                                 Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    status = RM_OK;
                }
                else
                {
                    U032 cbLen;
                    // Get the H & V Blank start and end. These values do not change after
                    // modeset. The H & V retrace start and end may have been changed.
                    // But get the default values first.
                    dacGetMonitorDefaultPosition(pDev,
                                                 Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    // Read the registry to get any updates to the default H & V retrace
                    // start and end.
                    cbLen = 4 * sizeof(U032);
                    status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                                TRUE,  // isMonitor
                                                                (U008 *) &(Params->HRetraceStart),
                                                                &cbLen);
                    // If there is an error, we don't have to do anything. The default values have already been 
                    // saved in Params.
                }
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV:
        {
            U032 Head = 0;
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;
            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                U032 cbLen;
                
                // if default, get position from tables, else get from registry
                if (Params->Default)
                {
                    dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                }
                else
                {
                    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;

                    //
                    // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
                    // params struct format that lives in the registry (currently, you can have a
                    // MULTI or a non-MULTI version, which is a problem).
                    //
                    // Until we remove the non-MULTI versions of these calls, independent of how
                    // we're called we'll read/write the registry with the MULTI version of struct.
                    // Which means (temporarily), we need to perform a cast in the non-MULTI case.

                    // Read the registry to get any updates to the default H & V offset
                    cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
                    status = dacReadTVDesktopPositionFromRegistry(pDev, Head,
                                                            (U008 *) &MultiParams,
                                                            &cbLen);

                    // Make sure data is valid for the current encoder.
                    if (MultiParams.Encoder_ID != pDev->Dac.EncoderType)
                        status = RM_ERROR;                  
                    if (status) // if reg read failed, return defaults
                        dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                    else {
                        // succeeded, convert MULTI to non-MULTI version
                        osMemCopy((U008*)Params, (U008*)&MultiParams.Encoder_ID, paramSize);
                    }

                    status = RM_OK;
                }
            }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO:
        {
            NV_CFGEX_TV_ENCODER_PARAMS *Params;
            Params = (NV_CFGEX_TV_ENCODER_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_TV_ENCODER_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                Params->EncoderType = pDev->Dac.EncoderType;
                Params->EncoderID = pDev->Dac.EncoderID;
                if (dacTVConnectStatus(pDev, 0))
                    Params->TVConnected = TV_CONNECTED;
                else
                    Params->TVConnected = TV_NOT_CONNECTED;
                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *Params;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *)paramStructPtr;
            if(!IsNV5orBetter(pDev))
                    Params->FlatPanelConnected = FALSE;
            else
                if (paramSize < sizeof(NV_CFGEX_GET_FLATPANEL_INFO_PARAMS))
                    // Wrong param size.
                    status = CONFIG_GETEX_BAD_PARAM;
                else
                    status = dacGetFlatPanelInfo(pDev, 0, &Params->FlatPanelMode,
                                             &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                             &Params->FlatPanelConnected,
                                             &Params->FlatPanelNativeSupported,
                                             FALSE /* not from registry */);
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
        	NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
        	Params=(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	if(paramSize!=sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		status=CONFIG_GETEX_BAD_PARAM;
        	}
        	else
        	{
        		status = dacGetFlatPanelBrightness(pDev, Params->Head, &(Params->PercentRelativeBrightness),&(Params->PWMControllerEnable));
        	}
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO:
        {
                NV_CFGEX_GET_MONITOR_INFO_PARAMS *Params;
                Params = (NV_CFGEX_GET_MONITOR_INFO_PARAMS *)paramStructPtr;
                status = dacGetMonitorInfo(pDev, (U032) 0, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_GET_EDID:
        {
#ifndef IKOS
            NV_CFGEX_GET_EDID_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            Params = (NV_CFGEX_GET_EDID_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_EDID_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
                ////OEMEnableExtensions();          // Unlock the registers before DDC
                status = EDIDRead(pDev,0,Params->displayType);
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
                ////OEMDisableExtensions();         // Lock the registers
                if ( status == RM_OK ) {
                    // status = EDIDCopy(pDev, Params->edidBuffer, Params->bufferLength, (U032) 0);
                    if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                        RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                        RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, (U032) 0)) &&
                        RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                        RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                    {
                        // all done 
                    }
                    if (edidBuffer)
                        osFreeMem(edidBuffer);
                }
                else {
                    status = CONFIG_GETEX_BAD_READ;
                }
            }
#else
            // just for IKOS builds return quickly
            status = CONFIG_GETEX_BAD_READ;
#endif
        }
        break;

        case NV_CFGEX_GET_BIOS:
        {
            NV_CFGEX_GET_BIOS_PARAMS *Params;
           	U008  *biosBuffer = (U008 *)NULL;
			U032 bufferLength;
			Params = (NV_CFGEX_GET_BIOS_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_BIOS_PARAMS)) 
            {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else 
            {
                // Get the size we need to recover
                osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032));
                status = osAllocMem((VOID **)&biosBuffer, (U032)bufferLength);
                if (RM_SUCCESS(status))
                {
                    U032 i;
                    // Pull the image byte-by-byte from the ghosted instance copy
                    for (i=0; i<bufferLength;i++)
                        biosBuffer[i] = (U008)BIOS_RD08(i);

                    // Copy the buffers back into the param structures (user buffer)
                    osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032));
                    osCopyOut((U008*) biosBuffer, (U008*) Params->biosBuffer, (U032) bufferLength);
                }

                if (biosBuffer)
                    osFreeMem(biosBuffer);

                if (RM_SUCCESS(status))
                    status = CONFIG_GETEX_OK;
                else
                    status = CONFIG_GETEX_BAD_READ;

            }
        }
        break;

        case NV_CFGEX_GET_SURFACE_PITCH:
        {
            NV_CFGEX_GET_SURFACE_PITCH_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_PITCH_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SURFACE_PITCH_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                nvHalFbGetSurfacePitch(pDev, Params->Width, Params->Depth, &Params->Pitch);
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_SURFACE_DIMENSIONS:
        {
            NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                nvHalFbGetSurfaceDimensions(pDev, Params->Width, Params->Height, Params->Depth,
                                            &Params->Pitch, &Params->Size);
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_SUPPORTED_CLASSES:
        {
            NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *Params;
            Params = (NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                //
                // Return numClasses, if the classBuffer pointer is NULL. Otherwise, fill in
                // the classBuffer if it's big enough to hold all the values.
                //
                if (Params->classBuffer == NULL) {
                    Params->numClasses = pDev->classDB.numClasses;
                    status = CONFIG_GETEX_OK;
                } else {
                    if (Params->numClasses != pDev->classDB.numClasses)
                        status = CONFIG_GETEX_BAD_PARAM;
                    else {
                        U032 i;
                        PCLASS classDB = (PCLASS)pDev->classDB.pClasses;
                        //
                        // Fill in classBuffer with the supported (common/chip specific) classes.
                        //
                        //for (i = 0; i < pDev->numClasses; i++)
                        //    Params->classBuffer[i] = classDB[i].Type;

                        for (i = 0; i < pDev->classDB.numClasses; i++)
                            osCopyOut((U008*) &classDB[i].Type, (U008*) &Params->classBuffer[i], sizeof(U032));

                        status = CONFIG_GETEX_OK;
                    }
                }
            }
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE:
        {
            U032 Head = 0;
            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *)paramStructPtr;
            
            if (paramSize < sizeof(NV_CFGEX_GET_DISPLAY_TYPE_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->Type = GETDISPLAYTYPE(pDev, Head);
                if (Params->Type == DISPLAY_TYPE_TV)
                    Params->TVType = pDev->Dac.TVStandard;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;
            
            if (paramSize < sizeof(NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->Type = GETDISPLAYTYPE(pDev, Params->Head);
                if (Params->Type == DISPLAY_TYPE_TV)
                    Params->TVType = pDev->Dac.TVStandard;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_REFRESH_INFO:
        {
            NV_CFGEX_GET_REFRESH_INFO_PARAMS *Params;
            Params = (NV_CFGEX_GET_REFRESH_INFO_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            } else if (Params->Head > pDev->Dac.HalInfo.NumCrtcs) {
                // Wrong param head.
                status = CONFIG_GETEX_BAD_PARAM;
            } else if (pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac == NULL) {
                Params->ulRefreshRate = 0;
                status = RM_OK;
            } else {
                PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
                pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac;
                Params->ulRefreshRate = pVidLutCurDac->RefreshRate;
                status = RM_OK;
            }

            // Params->ulState = pDev->Framebuffer.RefreshRateType;
        }
        break;

        case NV_CFGEX_GET_AGP_OFFSET:
        {
            NV_CFGEX_GET_AGP_OFFSET_PARAMS *Params;
            Params = (NV_CFGEX_GET_AGP_OFFSET_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_AGP_OFFSET_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->offset = 0xFFFFFFFF;        // init to unsigned -1

                status = osVirtualToPhysicalAddr(Params->linaddr, &Params->physaddr);
                if (status == RM_OK)
                {
                    // check if it's in the AGP aperture, if so, return the offset
                    if (
                        Params->physaddr >= (VOID*)pRmInfo->AGP.AGPPhysStart &&
                        (U008*)Params->physaddr <= (U008*)pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit
                    )
                    {
                        Params->offset = (U032)((U008*)Params->physaddr - (U008*)pRmInfo->AGP.AGPPhysStart);
                        status = RM_OK;
                    }
                    else
                        status = CONFIG_GETEX_BAD_PARAM;        // not an AGP aperture address
                }
            }
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->linaddr = (void *)pRmInfo->AGP.AGPLinearStart;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_ADDRESS_NVADDR:
        {
            NV_CFGEX_ADDRESS_NVADDR_PARAMS *Params;
            Params = (NV_CFGEX_ADDRESS_NVADDR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_ADDRESS_NVADDR_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->nvaddr = nvAddr;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[1]   = {0};
            U032                         Out[1]  = {0};

            // Copy the data in (1 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 1*sizeof(U032));

            // Get the data.
            status = CONFIG_GETEX_BAD_PARAM;
            if (paramSize == sizeof(NV_CFGEX_RESERVED_PROPERTY))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_RD08:
                        Out[0] = REG_RD08(In[0]);
                        break;

                    case PROPERTY_REG_RD16:
                        Out[0] = REG_RD16(In[0]);
                        break;

                    case PROPERTY_REG_RD32:
                        Out[0] = REG_RD32(In[0]);
                        break;

                    case PROPERTY_FB_RD08:
                        Out[0] = FB_RD08(In[0]);
                        break;

                    case PROPERTY_FB_RD16:
                        Out[0] = FB_RD16(In[0]);
                        break;

                    case PROPERTY_FB_RD32:
                        Out[0] = FB_RD32(In[0]);
                        break;

                    default:
                        status = CONFIG_GETEX_BAD_PARAM;
                        break;
                }
            }

            // Copy the data out (1 parameter).
            osCopyOut((U008*)Out, (U008*)pParams->Out, 1*sizeof(U032));
        }
        break;

#if 1 
        case NV_CFGEX_GET_LOGICAL_DEV_EDID:
        {
            U008 lock;        
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *Params;
            U032 Head, edidversion, edidrevision;
            VOID  *edidBuffer = (VOID *) 0;
            //U032 bufferLength, i;
            Params = (NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else 
            {
                status = dacGetDisplayInfo(pDev, Params->displayMap, &Head, 0, 0, 0);
                if (status != RM_OK)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                lock = UnlockCRTC(pDev, Head);
                status = edidReadDevEDID(pDev, Params->displayMap, Params->edidBuffer);
                RestoreLock(pDev, Head, lock);

                if (status != RM_OK)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                status = edidLogicalEDIDIsValid(&Params->edidBuffer, &edidversion, &edidrevision);

                if (status != TRUE)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                if (edidversion == 1)
                {
                    *Params->bufferLength = EDID_V1_SIZE;
                }
                else if (edidversion == 2)
                {
                    *Params->bufferLength = EDID_V2_SIZE;
                }
            }
            break;
        }

        //
        // Multi-Head Info. These take logical Head number as a parameter
        //
        case NV_CFGEX_GET_EDID_MULTI:
        {
            U008 lock;        
            NV_CFGEX_GET_EDID_MULTI_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            Params = (NV_CFGEX_GET_EDID_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_EDID_MULTI_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                if (Params->Head > pDev->Dac.HalInfo.NumCrtcs) {    // Bad Head number will cause our nvInfo to get trashed
                    status = CONFIG_GETEX_BAD_PARAM;
                }
                else {
                    lock = UnlockCRTC(pDev, Params->Head);
                    status = EDIDRead(pDev, Params->Head, Params->displayType);
                    RestoreLock(pDev, Params->Head, lock);
                    if ( status == RM_OK ) {
                        //status = EDIDCopy(pDev, Params->edidBuffer, Params->bufferLength, Params->Head);
                        if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                            RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                            RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, (U032) Params->Head)) &&
                            RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                            RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                        {
                            // all done 
                        }
                        if (edidBuffer)
                            osFreeMem(edidBuffer);
                    }
                    else {
                        status = CONFIG_GETEX_BAD_READ;
                    }
                }
            }
        }
        break;
        
        case NV_CFGEX_VIDEO_ENCODER_TYPE:
        {
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *)paramStructPtr;
            
            Params->EncoderType = pDev->Dac.EncoderType;
        }
        break;
        case NV_CFGEX_VIDEO_ENCODER_ID:
        {
            NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *)paramStructPtr;

            Params->EncoderID = pDev->Dac.EncoderID;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_8BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit8bpp);    
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_16BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit16bpp);   
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_32BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit32bpp);   
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                if (Params->GetDefault)
                {
                    dacGetMonitorDefaultPosition(pDev, 
                                                 Params->Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    status = RM_OK;
                }
                else
                {
                    U032 cbLen;
                    // Get the H & V Blank start and end. These values do not change after
                    // modeset. The H & V retrace start and end may have been changed.
                    // But get the default values first.
                    dacGetMonitorDefaultPosition(pDev,
                                                 Params->Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    // Read the registry to get any updates to the default H & V retrace
                    // start and end.
                    cbLen = 4 * sizeof(U032);
                    status = dacReadDesktopPositionFromRegistry(pDev, Params->Head,
                                                                TRUE,  // isMonitor
                                                                (U008 *) &(Params->HRetraceStart),
                                                                &cbLen);
                    // If there is an error, we don't have to do anything. The default values have already been 
                    // saved in Params.
                }
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                U032 cbLen;
                
                // if default, get position from tables, else get from registry
                if (Params->Default)
                {
                    dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                }
                else
                {
                    // Read the registry to get any updates to the default H & V offset
                    cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
                    status = dacReadTVDesktopPositionFromRegistry(pDev, Params->Head,
                                                            (U008 *) Params,
                                                            &cbLen);
                    // Make sure data is valid for the current encoder.
                    if (Params->Encoder_ID != pDev->Dac.EncoderType)
                        status = RM_ERROR;                  
                    if (status) // if reg read failed, return defaults
                        dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                    status = RM_OK;
                }
            }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO_MULTI:
        {
            NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                Params->EncoderType = pDev->Dac.EncoderType;
                Params->EncoderID = pDev->Dac.EncoderID;
                if (dacTVConnectStatus(pDev, Params->Head))
                    Params->TVConnected = TV_CONNECTED;
                else
                    Params->TVConnected = TV_NOT_CONNECTED;
                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;
            if(!IsNV5orBetter(pDev))
                Params->FlatPanelConnected = FALSE;
            else
                if (paramSize < sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS))
                    // Wrong param size.
                    status = CONFIG_GETEX_BAD_PARAM;
                else
                {
                    //
                    // CONTROL PANEL WORKAROUND FOR MOBILE
                    //
                    // On mobile the control panel will be expecting the DFP to be on the
                    // virtual primary head (0), yet in reality the physical head is always 1.
                    // He might call in asking about head0, so route it to head1.
                    //
                    if (pDev->Power.MobileOperation)
                        Params->Head = 1;
                    status = dacGetFlatPanelInfo(pDev, Params->Head, &Params->FlatPanelMode,
                                         &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                         &Params->FlatPanelConnected,
                                         &Params->FlatPanelNativeSupported,
                                         FALSE /* not from registry */);
                }
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO_MULTI:
        {
            NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *)paramStructPtr;
            status = dacGetMonitorInfo(pDev, Params->Head, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;
            status = dacGetColorSaturationBoost(pDev, Params->Head, &Params->boostValue);
        }
        break;


#endif  // multi-head      

        case NV_CFGEX_CURRENT_SCANLINE_MULTI:
        {
            NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *)paramStructPtr;
            if (Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->RasterPosition = DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, Params->Head);
            else
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SYNC_STATE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                dacGetSyncState(pDev, Params->Head, &Params->Hsync, &Params->Vsync);
                // paper over a bit of ambiguity :-)
                Params->oldHsync = Params->Hsync;
                Params->oldVsync = Params->Vsync;
            }
        }
        break;

        case NV_CFGEX_PRIMARY_INFO:
        {
            NV_CFGEX_PRIMARY_INFO_PARAMS *Params;
            Params = (NV_CFGEX_PRIMARY_INFO_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_PRIMARY_INFO_PARAMS))
            {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            // TODO is there a 'max heads' #define ?
            if (Params->Head > 1)
            {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            
            /// TODO 'primarySurfaceAlloced' should probably be per-head
            //  TODO 'Dac.DisplayPitch'         ""
            if ( ! pDev->Framebuffer.PrimarySurfaceAlloced)
            {
                status = CONFIG_GETEX_BAD_READ;
                break;
            }
                
            Params->Pitch = pDev->Dac.DisplayPitch;
            Params->Offset = pDev->Framebuffer.HalInfo.Start[Params->Head];
        }
        break;

        //Interface for control panel to read pending mobile hotkey (Fn+x) events.
        case NV_CFGEX_GET_HOTKEY_EVENT:
        {
            NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *Params;
            Params = (NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *) paramStructPtr;

            if (paramSize < sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            if (!pDev->Power.MobileOperation) {
                //If there are no hotkeys to support...
                Params->event = NV_HOTKEY_EVENT_NOT_SUPPORTED;
                Params->status = 0;
            } else if (pDev->HotKeys.queueHead == pDev->HotKeys.queueTail) {
                //If no hotkey events are pending...
                Params->event = NV_HOTKEY_EVENT_NONE_PENDING;
                Params->status = 0;
            } else {
                //If there are events in the queue, report the next one...
                Params->event = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].event;
                Params->status = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].status;
                pDev->HotKeys.queueTail = (pDev->HotKeys.queueTail + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;
            }
        }
        break;

        case NV_CFGEX_GET_DEVICE_MAPPINGS:
        {
            NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *Params;

            //
            // This call is for use by the NVDE debugger.
            //
            if (paramSize < sizeof(NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                Params = (NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *) paramStructPtr;
                Params->nvVirtAddr = (void *)pDev->DBnvAddr;
                Params->fbVirtAddr = (void *)pDev->DBfbAddr;
                Params->nvPhysAddr = (void *)pDev->Mapping.PhysAddr;
                Params->fbPhysAddr = (void *)pDev->Mapping.PhysFbAddr;

                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_CHECK_CONNECTED_DEVICES:
        {
            U032        *pDevBitMap = (U032 *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!*pDevBitMap ||
                ((*pDevBitMap ^ pDev->Dac.DevicesBitMap) & *pDevBitMap)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            dacDevicesConnectStatus(pDev, pDevBitMap);

            break;
        }

        case NV_CFGEX_GET_DEVICES_CONFIGURATION:
        {
            NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS   *param;

            param = (NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!param->DevicesConfig ||
                ((param->DevicesConfig ^ pDev->Dac.DevicesBitMap) & param->DevicesConfig)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            if (dacFindDevicesConfiguration(pDev,
                                            param->DevicesConfig,
                                            &param->DevicesAllocationMap,
                                            param->OldDevicesConfig,
                                            param->OldDevicesAllocationMap) != RM_OK)
                status = CONFIG_GETEX_BAD_PARAM;

            break;
        }

        default:
            status = CONFIG_GETEX_BAD_INDEX;
            break;
    } // switch on index

    return status;

} // end of stateConfigGetEx

RM_STATUS stateConfigSetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;
    switch (index)
    {
        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                status = dacSetMonitorPosition(pDev, 
                                               Head,
                                               Params->HRetraceStart, Params->HRetraceEnd,
                                               Params->VRetraceStart, Params->VRetraceEnd);
                if (!status && Params->CommitChanges)
                {
                    // Write the the passed values into the registry.
                    status = dacWriteDesktopPositionToRegistry(pDev,
                                                               Head,
                                                               TRUE, // isMonitor
                                                               (U008 *) &(Params->HRetraceStart),
                                                               4 * sizeof(U032));
                }
            }
        }
        break;

        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                status = dacSetMonitorPosition(pDev, 
                                               Params->Head,
                                               Params->HRetraceStart, Params->HRetraceEnd,
                                               Params->VRetraceStart, Params->VRetraceEnd);
                if (!status && Params->CommitChanges)
                {
                    // Write the the passed values into the registry.
                    status = dacWriteDesktopPositionToRegistry(pDev,
                                                               Params->Head,
                                                               TRUE, // isMonitor
                                                               (U008 *) &(Params->HRetraceStart),
                                                               4 * sizeof(U032));
                }
            }
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;
            U032 Head = 0;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;

                //
                // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
                // params struct format that lives in the registry (currently, you can have a
                // MULTI or a non-MULTI version, which is a problem).
                //
                // Until we remove the non-MULTI versions of these calls, independent of how
                // we're called we'll read/write the registry with the MULTI version of struct.
                // Which means (temporarily), we need to perform a cast in the non-MULTI case.

                MultiParams.Head = Head;
                osMemCopy((U008*)&MultiParams.Encoder_ID, (U008*)Params, paramSize);

                // Write the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Head,
                                                           FALSE, // not Monitor
                                                           (U008 *) &MultiParams,
                                                           sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS));
            }
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                // Write the the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Params->Head,
                                                           FALSE, // not Monitor
                                                           (U008 *) Params,
                                                           sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS));
            }
        }
        break;

        case NV_CFGEX_ENABLE_TETRIS_TILING:
        {
            // Automatic tiling will be enabled at the next modeset.
            // The tiling mode will be selected based on the new mode.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_ENABLE);
        }
        break;

        case NV_CFGEX_DISABLE_TETRIS_TILING:
        {
            // Automatic tiling will be disabled at the next modeset. It will remain disabled till
            // it is enabled by calling ConfigSetEx with NV_CFGEX_ENABLE_TETRIS_TILING.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_DISABLE);
        }
        break;

        case NV_CFGEX_SET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *Params;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_FLATPANEL_INFO_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                RM_ASSERT(pDev->Dac.CrtcInfo[0].pVidLutCurDac);
                status = dacSetFlatPanelMode(pDev, 0,
                                             (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac,
                                             Params->FlatPanelMode, Params->CommitChanges);
            }
        }
        break;

        case NV_CFGEX_SET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                RM_ASSERT(pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac);
                status = dacSetFlatPanelMode(pDev, Params->Head,
                                             (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac,
                                             Params->FlatPanelMode, Params->CommitChanges);
            }
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
        	NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
        	Params=(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	
        	if(paramSize<sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		//wrong parameter size
        		status=CONFIG_SETEX_BAD_PARAM;
        	}
        	else
        	{
        		status=dacSetFlatPanelBrightness(pDev, Params->Head,
        									Params->PercentRelativeBrightness,
                							Params->FlatPanelBrightnessControlFrequency,
                							Params->PercentMaximumPWMDutyCycle,
                							Params->PercentMinimumPWMDutyCycle,
                							Params->PWMControllerEnable);
            }
         }
         break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;
            status = dacSetColorSaturationBoost(pDev, Params->Head, Params->boostValue);
        }
        break;

        //
        // XXXscottl
        //
        // These SET_DISPLAY_TYPE calls need to be removed.
        // All programming of the display/monitor/tv types
        // should be done via the dac classes from now on.
        //

        case NV_CFGEX_SET_DISPLAY_TYPE:
        {
            U032 Head = 0;

            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DISPLAY_TYPE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                SETDISPLAYTYPE(pDev, Head, Params->Type);
                if ((Params->Type == DISPLAY_TYPE_TV) && 
                    (Params->TVType <= KNOWN_TV_FORMATS))
                    pDev->Dac.TVStandard = Params->TVType;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_SET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                SETDISPLAYTYPE(pDev, Params->Head, Params->Type);
                if ((Params->Type == DISPLAY_TYPE_TV) && 
                    (Params->TVType <= KNOWN_TV_FORMATS))
                    pDev->Dac.TVStandard = Params->TVType;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            VOID_PTR oldValue;

            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                oldValue = pRmInfo->AGP.AGPLinearStart;
                pRmInfo->AGP.AGPLinearStart = (VOID_PTR)Params->linaddr;
                Params->linaddr = (void *)oldValue;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SYNC_STATE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                dacGetSyncState(pDev, Params->Head, &Params->oldHsync, &Params->oldVsync);
                dacSetSyncState(pDev, Params->Head, Params->Hsync, Params->Vsync);
            }
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[2]   = {0};

            // Copy the data in (2 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 2*sizeof(U032));

            // Set the data.
            status = CONFIG_SETEX_BAD_PARAM;
            if (paramSize == sizeof(NV_CFGEX_RESERVED_PROPERTY))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_WR08:
                        REG_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR16:
                        REG_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR32:
                        REG_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR08:
                        FB_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR16:
                        FB_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR32:
                        FB_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_SET_GRAPHICS_CLOCK:
                        pDev->Dac.HalInfo.NVClk = In[0];
                        if (dacProgramNVClk(pDev) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_MEMORY_CLOCK:
                        pDev->Dac.HalInfo.MClk = In[0];
                        if (dacProgramMClk(pDev) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_PIXEL_CLOCK:
                    {
                        // dacProgramPClk takes frequency in MHz * 100.
                        U032 Head      = In[0];
                        U032 Frequency = In[1] / 10000;
                        if (dacProgramPClk(pDev, Head, Frequency) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;
                    }

                    default:
                        status = CONFIG_SETEX_BAD_PARAM;
                        break;
                }
            }
        }
        break;

        case NV_CFGEX_SET_MACROVISION_MODE:
        {
            NV_CFGEX_SET_MACROVISION_MODE_PARAMS *Params;
            RM_MACROVISION_CONTROL mvCtrl;

            // extract parameters from the command struct
            Params = (NV_CFGEX_SET_MACROVISION_MODE_PARAMS *) paramStructPtr;
            mvCtrl.mode = Params->mode;
            mvCtrl.resx = Params->resx;
            mvCtrl.resy = Params->resy;

            // extract parameters that the RM maintains
            mvCtrl.devAddr = pDev->Dac.EncoderID;
            mvCtrl.encoderType = pDev->Dac.EncoderType;
            mvCtrl.tvStandard = pDev->Dac.TVStandard;
            mvCtrl.port = pDev->Dac.TVOutPortID;

            if ( SetMacrovisionMode(pDev, Params->head, &mvCtrl) ) {
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                status = RM_OK;
            }
        }
        break;

        default:
            status = CONFIG_SETEX_BAD_INDEX;
            break;
    }

    return status;
} // end of stateConfigSetEx
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\tmrstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Timer Module ********************************\
*                                                                           *
* Module: TMRSTATE.C                                                        *
*   The Timer cntrol state is maintained in this module.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
// Month to days conversion.
//
U032 tmrMonthDays[12] =
{
    31, 28, 31, 30,
    31, 30, 31, 31,
    30, 31, 30, 31
};

//
// Change Master Control hardware state.
//
RM_STATUS stateTmr
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
#if defined(UNIX) || defined(MACOS)
    U032      seconds;
    U032      useconds;
    long long mseconds;			// U064 is a struct, not long long
#else    
    U032      year;
    U032      month;
    U032      day;
    U032      hour;
    U032      min;
    U032      sec;
    U032      msec;
    U032      days;
#endif
    U032      sec5;
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Set timer values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
            REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
            //
            // Get current time from operating system.
            //
            
#if defined(UNIX) || defined(MACOS)
            // On UNIX, we get the time in seconds since 1970.
            // From within the unix kernel it is actually hard to get
            //   real time of day.  We don't really need it anyway.
            osGetCurrentTime(&seconds, &useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Time = ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, seconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " seconds, ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " useconds.\n");
            mseconds = seconds * 1000 + (useconds / 1000);
            sec5 = mseconds / 4295;
#else
            osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Date = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, month);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, day);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, year);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, hour);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, min);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, sec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "\n");

            //
            // Perform a quick error check of the time
            //
            if (month > 12)
                    month = 12;
            if (day > 31)
                    day = 20;
            if (hour > 24)
                    hour = 12;
            if (min > 59)
                    min = 59;
            if (sec > 59)
                    sec = 59;

            //
            // Get days so far.
            //
            if (year > 1990)
                year -= 1990;
            days = year * 365 + (year + 1) / 4;
            //
            // If this is a current leap year, check the month.
            //
            if (!((year + 2) & 3) && (month > 2))
                days++;
            while (--month)
                days += tmrMonthDays[month];
            days += day;
            sec5 = days * 20117 + hour * 838 + (min * 257698 + sec * 4295) / 1000;

            //
            // Add number of 4.295 sec increments between 1970 and 1990 to the 
            // accumulated time.
            //
            sec5 += 146951526;
#endif

            //
            // Since the internal timer is only accurate to about 5 sec/day,
            // that is about the accuracy of the upper 32 bits of the nsec timer.
            // To initialize, just calculate the current time to the nearest 4.295 sec.
            //
            REG_WR32(NV_PTIMER_TIME_0, 0);
            REG_WR32(NV_PTIMER_TIME_1, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TIMER = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ":0x00000000\n");

            if (!pDev->Vga.Enabled) // interrupts wake up from standby on some motherboards
            {
                //
                // Enable Timer interrupt.
                //
                REG_WR32(NV_PTIMER_INTR_0,    0xFFFFFFFF);
                REG_WR32(NV_PTIMER_INTR_EN_0, 0xFFFFFFFF);
            }            
#ifdef RM_STATS
            /*
            For now, no perf timer needed!!
            
            //
            // Schedule performance timer.
            //
            tmrScheduleCallbackRel(tmrStatTimer,
                                   (POBJECT)0x69,
                                   pDev->Statistics.UpdateHi,
                                   pDev->Statistics.UpdateLo);
            */
#endif
            break;
        case STATE_UNLOAD:
            //
            // Disable Timer interrupt.
            //
            REG_WR32(NV_PTIMER_INTR_EN_0, 0);
            //
            // Cancel performance timer.
            //
            tmrCancelCallback(pDev, (POBJECT)0x69);
            break;
        case STATE_INIT:
            status = initTmr(pDev);
            break;
        case STATE_DESTROY:
            //
            // Restore previous values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.tmrSave[0]);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.tmrSave[1]);
            osFreeMem((VOID *)pDev->DBtmrCallbackTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\video\nv\video.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: video.c                                                           *
*   The video engine is managed here.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"

#define DEBUGLEVEL_TRACEINFO_SCOTTL DEBUGLEVEL_ERRORS

//
// Change Video hardware state.
//
RM_STATUS stateVideo
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            extern char strDevNodeRM[];
            U032 data32;

            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FlipOnHsync", &data32) == RM_OK)
                pDev->Video.FlipOnHsync = data32;
            else
                pDev->Video.FlipOnHsync = 0x0;
            nvHalVideoControl(pDev, VIDEO_CONTROL_INIT);
            pDev->Video.HalInfo.Enabled = 0;
            break;
        }
        case STATE_DESTROY:
            nvHalVideoControl(pDev, VIDEO_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}

//
// Top-level video engine service handler.
V032 videoService
(
    PHWINFO pDev
)
{
    //
    // Even when pDev->ActiveVideoOverlayObject is NULL, don't opt out early, still
    // give the underlying chip specific ISR a chance to quiesce the video HW.
    //
    return pDev->pOverlayServiceHandler(pDev, (POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\vblank\nv\vblank.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Interrupt Routine ****************************\
*                                                                           *
* Module: VBLANK.C                                                          *
*   Vertibal blank interrupt servicing is handled here.  This is a true     *
*   interrupt time call so no os services are available.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <vblank.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h


// external interfaces
VOID VBlankAddCallback(PHWINFO, U032, PVBLANKCALLBACK);
VOID VBlankDeleteCallback(PHWINFO, U032, PVBLANKCALLBACK);
U032 VBlankPending(PHWINFO);


RM_STATUS mthdColormapDirtyNotify(PHWINFO, RM_STATUS);

static VOID VBlankProcessCallbacks
(
    PHWINFO pDev,
    U032 Head
)
{
    PVBLANKCALLBACK Callback;
    PVBLANKCALLBACK NextCallback;
    PVBLANKCALLBACK *PrevCallback;
    PDACCRTCINFO pDacCrtcInfo;


    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    Callback     = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;
    PrevCallback = (PVBLANKCALLBACK *)&pDacCrtcInfo->VBlankCallbackList;

    while (Callback) {
        NextCallback   = Callback->Next;
        Callback->Next = NULL;

        // Execute this on a particular VBlankCount?
        if ((Callback->Flags & CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT) &&
            (Callback->VBlankCount != pDacCrtcInfo->VBlankCounter)) {
            PrevCallback = &Callback->Next;     // skip it
        } else {
            // Call the function now
            if (Callback->Proc) {
                Callback->Proc(pDev,
                               Callback->Object,
                               Callback->Param1,
                               Callback->Param2,
                               Callback->Status);
            }
            *PrevCallback = NextCallback;       // unlink it
        }
        Callback = NextCallback;
    }
}


VOID VBlankAddCallback
(
    PHWINFO         pDev, 
    U032            Head,
    PVBLANKCALLBACK Callback
)
{

    RM_ASSERT(Head <= MAX_CRTCS);

    // Make sure VBlank is enabled on this head.
    if ((pDev->Dac.CrtcInfo[Head].StateFlags & DAC_CRTCINFO_VBLANK_ENABLED) == 0)
    {
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, Head);
        pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    }

    Callback->Next = (PVBLANKCALLBACK)pDev->Dac.CrtcInfo[Head].VBlankCallbackList;
    pDev->Dac.CrtcInfo[Head].VBlankCallbackList = (VOID_PTR)Callback;
}


//
// This routine can be called from an API entry point.
//
// For winnt4/win2k the necessary locking is already preventing a conflict
// with the VBlank handler running concurrently. For win9x, make sure the
// interrupt is disable before pulling callbacks off the list.
//
VOID VBlankDeleteCallback
(
    PHWINFO         pDev,
    U032            Head,
    PVBLANKCALLBACK Callback
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 enable;


    RM_ASSERT(Head <= MAX_CRTCS);
    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // Disable VBlank while we scan/process the callback list

    enable = DAC_REG_RD_DRF(_PCRTC, _INTR_EN_0, _VBLANK, Head);
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _DISABLED, Head);

    // Search the list and remove this Callback entry
    if (pDacCrtcInfo->VBlankCallbackList == (VOID_PTR)Callback) {
        //
        // Found it.
        // Should the callback be executed as part of the object destroy
        // (safe to do, since we already hold the necessary lock).
        //
        if (Callback->Proc && 
            (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
            // Force it to appear to be on the correct VBlankCount
            Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
            Callback->Proc(pDev,
                           Callback->Object,
                           Callback->Param1,
                           Callback->Param2,
                           Callback->Status);
        }
        pDacCrtcInfo->VBlankCallbackList = (VOID_PTR)Callback->Next;
    } else {
        PVBLANKCALLBACK PrevCallback = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;

        while (PrevCallback) {
            if (PrevCallback->Next == Callback) {
                //
                // Found it.
                // Should the callback be executed as part of the object destroy
                // (safe to do, since we already hold the necessary lock).
                //
                if (Callback->Proc && 
                    (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
                    // Force it to appear to be on the correct VBlankCount
                    Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
                    Callback->Proc(pDev,
                                   Callback->Object,
                                   Callback->Param1,
                                   Callback->Param2,
                                   Callback->Status);
                }
                PrevCallback->Next = Callback->Next;
                break;
            }
            PrevCallback = PrevCallback->Next;
        }
    }
    Callback->Next = NULL;

    // Restore VBlank enable
    DAC_FLD_WR_DRF_NUM(_PCRTC, _INTR_EN_0, _VBLANK, enable, Head);
}


//
// VBlankUpdateFlip
//
static U032 VBlankUpdateFlip
(
    PHWINFO         pDev,
    U032            Head
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U008 Cr07, Cr25;
    U008 lock;
    U016 DisplayEnd, Scanline;
    U032 rmFinish = FALSE;
#ifdef NTRM
    U008 crtc_color, crtc_index;
#endif

    //
    // Initialize logical head so that the HAL will know which
    // crtc to program up.
    //
    vidLutCurDacHalObj.Head = Head;

#ifdef NTRM
    // XXX temporarily NT only (this needs to be made common)
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);
#endif

    // Unlock CRTC extended regs
    lock = UnlockCRTC(pDev, Head);

	//
    // Update framebuffer address?
    //
	if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_FLIP)
	{
        pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
        pDev->Framebuffer.Current  = pDev->Framebuffer.FlipTo;
        if (!pDev->Vga.Enabled)
        {
            //
            // Make sure we're really in blank
            //
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
                    ;
            else // !? Easy way isn't working with flat panel. Use scanline counter instead.
            {
                // Compare scanline count to display end
                CRTC_RD(NV_CIO_CR_VDE_INDEX, DisplayEnd, Head);
                CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
                CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
                if (Cr07 & 2) DisplayEnd |= 0x100;
                if (Cr07 & 0x40) DisplayEnd |= 0x200;
                if (Cr25 & 2) DisplayEnd |= 0x400;                    

                nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                while (Scanline < DisplayEnd)
                {
                    nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                }
            }

            //
            // Program the new start address; this will latch at the end of blank
            //
#ifdef	STEREO_SUPPORT
            if (!pDev->pStereoParams || !(pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED))
#endif	//STEREO_SUPPORT
                nvHalDacSetStartAddr(pDev, pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current], &vidLutCurDacHalObj);
#ifdef  STEREO_SUPPORT
            else
                __asm int 3
#endif	//STEREO_SUPPORT

        }
        pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_BUFFER_FLIP;       
        pDev->Framebuffer.FinishFlags |=  FINISH_HWINFO_BUFFER_FLIP;
        rmFinish = TRUE;
	}

#ifdef	STEREO_SUPPORT
    if (pDev->pStereoParams &&
        pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED &&
        pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
    {
        unsigned long *pBufferOffset;
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[0][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[0][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[1][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[1][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[2][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[2][0];
        else
        {
            pDev->pStereoParams->FlipOffsets[3][1] = pDev->pStereoParams->FlipOffsets[3][0];
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[3][0];
            //The only explanation that the last flip offset doesn't match one of ours is
            //that it happened upon someone else request. This is most likely a video mode
            //restore taking place when an application ends. The safest strategy here would
            //be to force stereo off.
            pDev->pStereoParams->Flags = 0;
        }
        pDev->pStereoParams->EyeDisplayed ^= 1;
        nvHalDacSetStartAddr(pDev, pBufferOffset[pDev->pStereoParams->EyeDisplayed], &vidLutCurDacHalObj);
		if (pDev->pStereoParams->Flags & STEREOCFG_ELSADDC)
		{
			U008 DDCVal;
			DDCVal = pDev->pStereoParams->EyeDisplayed ? 0x1 : 0x11;
			CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, DDCVal, Head);
		}
    }
#endif  //STEREO_SUPPORT

    // Relock CRTC extended regs
    RestoreLock(pDev, Head, lock);

#ifdef NTRM
    //
	// Restore crtc index register
    //
	if (crtc_color)
		REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
	else
		REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
#endif

    return rmFinish;
}

//
// VBlankUpdatePalette
//
static VOID VBlankUpdatePalette
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 i, j, k;
    U016 Width, Height;
    U016  color;
    U008  test, mask;
    U032  color32;
    U008  color8;
    U008  *lpColorMask;

#define   COLOR_OFFSET    32*4    // offset of XOR mask from start of buffer (= size of and mask)

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
    {
        if (!pDev->Vga.Enabled)
        {
            if (pDev->Dac.HalInfo.Depth == 8)
                dacProgramLUT(pDev, Head, &pDev->Dac.Palette[0], 256);
            else
                dacProgramLUT(pDev, Head, &pDev->Dac.Gamma[0], 256);

            // JJV- Update the cursor to the new DAC values.
            // Read the saved DAC indices from nvinfo ... the cursor
            // indices are saved after each update.
            // Generate a cursor image update to force a restore on
            // the cursor palette. 
            if ( (pDev->Dac.HalInfo.Depth == 8)  && 
                 (pDev->Dac.CursorBitDepth == 8) &&
                 (pDev->Dac.CrtcInfo[Head].CursorType == DAC_CURSOR_FULL_COLOR_XOR) )
            {
                lpColorMask = pDev->Dac.SavedCursor + COLOR_OFFSET;
                Width=Height=32;
                for (i = 0; i < Height; i++)
                {
                    for (j = 0; j < (U032)Width/8; j++)
                    {
                        mask = pDev->Dac.SavedCursor[i * sizeof(U032) + j]; // get 8 AND bits                                
                        test = 0x80;
                        for (k = 0; k < 8; k++, test >>=1)  // get 8 pixels and write 8 words
                        {
                            color8 = lpColorMask[i*32+j*8+k];   // get 8 bits of color
                            color32 = pDev->Dac.Palette[color8];     // look up color (24 bits)
                            // pack 8-8-8 into 5-5-5, using most sig bits 
                            color =  (U016)((color32 >> 9) & 0x7c00);   // red
                            color |= (color32 >> 6) & 0x03e0;           // green
                            color |= (color32 >> 3) & 0x001f;           // blue
                            if (!(test & mask))
                                color |= 0x8000;                            
                            pDev->Dac.CursorColorImage[i][j*8+k] = color;
                        }
                    }
                }    
                pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;
            }
                
            // We have just updated the colormap. Notify the object.
            mthdColormapDirtyNotify(pDev, RM_OK);
            pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
        }
    }
}

//
// VBlankUpdateVideoScaler
//
static U032 VBlankUpdateVideoScaler
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 rmFinish = FALSE;

    //
    // Update the video scaler settings
    //
    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_DUALSURFACE)   // if we are using the scalar for dual surface, don't change it
    {
    	if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)
    	{
            if (pDev->Video.HalInfo.Enabled)
                nvHalVideoControl(pDev, VIDEO_CONTROL_ENABLE);
            else
                nvHalVideoControl(pDev, VIDEO_CONTROL_DISABLE);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
    	}
    } // dualsurface    
    else
    {
    	if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)   // if dual surf, set TV for YUV
    	{
            if (pDev->Video.HalInfo.Enabled)
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _YUV);
            else
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _565);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
        }                
    }

    return rmFinish;
}

//
// VBlankUpdateCursor
//
// Handle win9x cursor updates.
//
static VOID VBlankUpdateCursor
(
    PHWINFO         pDev,
    U032            Head
)
{
    U008 crtc_color, crtc_index;
    PDACCRTCINFO pDacCrtcInfo;
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;

    VidLutCurDac.Head = Head;

    //
    // Save away the current CRTC index values.
    //
    // This should be in VBlank common to all callbacks, but placing it there
    // caused problems at boot time (which are still a mystery). For now, make
    // the save/restore local to the cursor update callback.
    //
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // position cursor?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_POS)
    {
        dacProgramCursorPosition(pDev, Head,
                                 pDacCrtcInfo->CursorPosX,
                                 pDacCrtcInfo->CursorPosY);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_POS;
    }

#ifdef WIN31	// This is the old way of updating the cursor image

    // update glyph?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE)
    {
        U032 i, j;

        // The image was copied into the pDev->structure in the API call.
        // We need to copy into the Instance memory, where the DAC can find it.

        // The 2k image has been formatted by the OS module NVSYS.C, 
        // The buffer is a 32x32 array of words. Each word represents a pixel.
        for (i = 0; i < 32; i++)	
            for (j = 0; j < 32; j+=2)
            {
                U032 data;
                // grab two words at a time and stuff them in instance mem
                data = pDacCrtcInfo->CursorColorImage[i][j+1];
                data = (data << 16) | pDacCrtcInfo->CursorColorImage[i][j];
                INST_WR32(pDacCrtcInfo->CursorImageInstance, i*64+j*2, data);
            }
	}
#else
    // The display driver massages the image and hands us a pointer (to image in framebuffer).
    // This is the new way of manipulating the cursor image. 
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW)
    {
        nvHalDacProgramCursorImage(pDev,
                              pDacCrtcInfo->CursorOffset, 
                              DAC_ASI_FRAMEBUFFER, 
                              pDacCrtcInfo->CursorWidth, pDacCrtcInfo->CursorHeight,
                              pDacCrtcInfo->CursorColorFormat,
                              (VOID*) &VidLutCurDac);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    }
#endif
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_ENABLE)
    {
        // Enable the cursor.
        dacEnableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
    }

    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_DISABLE)
    {
        // Disable the cursor.
        dacDisableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
    }

    //
	// Restore crtc index register
    //
	if (crtc_color)
		REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
	else
		REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
}

//
// VBlankUpdateImageOffsetFormat
//
// Handle win9x panning start address updates. This could be made to be
// a generalized backdoor taking method offsets and data.
//
static VOID VBlankUpdateImageOffsetFormat
(
    PHWINFO         pDev,
    U032            Head
)
{
    PDACCRTCINFO pDacCrtcInfo;
    RM_STATUS status;

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT)
    {
        POBJECT Object;

        // Given the object handle, find the POBJECT pointer
        status = fifoSearchObject(pDev,
                                  pDacCrtcInfo->ObjectHandle,
                                  pDacCrtcInfo->ChID,
                                  &Object);
        if (status != RM_OK) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,
                                   "NVRM: VBlankUpdateImageOffsetFormat: bad object handle ",
                                    pDacCrtcInfo->ObjectHandle);
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#if 0
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_PAN_OFFSET == NV049_SET_PAN_OFFSET) &&
                  (NV049_SET_PAN_OFFSET == NV067_SET_PAN_OFFSET) &&
                  (NV067_SET_PAN_OFFSET == NV07C_SET_PAN_OFFSET));

        // Call the SET_IMAGE_OFFSET method
        status = classSoftwareMethod(pDev, Object,
                                     NV07C_SET_PAN_OFFSET, 
                                     pDacCrtcInfo->ImageOffset);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#else
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_IMAGE_OFFSET(0) == NV049_SET_IMAGE_OFFSET(0)) &&
                  (NV049_SET_IMAGE_OFFSET(0) == NV067_SET_IMAGE_OFFSET(0)) &&
                  (NV067_SET_IMAGE_OFFSET(0) == NV07C_SET_IMAGE_OFFSET(0)));

        // Call the SET_IMAGE_OFFSET method
        status = classSoftwareMethod(pDev, Object,
                                     NV046_SET_IMAGE_OFFSET(0),    
                                     pDacCrtcInfo->ImageOffset);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#endif
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_IMAGE_FORMAT(0) == NV049_SET_IMAGE_FORMAT(0)) &&
                  (NV049_SET_IMAGE_FORMAT(0) == NV067_SET_IMAGE_FORMAT(0)) &&
                  (NV067_SET_IMAGE_FORMAT(0) == NV07C_SET_IMAGE_FORMAT(0)));

        // Call the SET_IMAGE_FORMAT method
        status = classSoftwareMethod(pDev, Object,
                                     NV046_SET_IMAGE_FORMAT(0),    
                                     pDacCrtcInfo->ImageFormat);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }

        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
    }
}


VOID hotkeyAddEvent(PHWINFO pDev, U032 event, U032 status)
{
    U032 temp;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Adding event:", event);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent:       status:", status);

    temp = (pDev->HotKeys.queueHead + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;

    //Don't wrap past tail if there's a backlog.  It may actually
    // be better to keep the newer events rather than the older ones,
    // but that raises queue access coherency issues.  This is a
    // safe way to handle an event that should never happen anyway.
    if (temp == pDev->HotKeys.queueTail) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Queue is full.\n\r");
        return;
    }

    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].event = event;
    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].status = status;
    pDev->HotKeys.queueHead = temp;
}


//Mobile system feature: look for bits in our CR registers that indicate
// a keyboard Fn + key event has occured.  If so, we queue up the event
// so it can be serviced later.
VOID VBlankCheckHotKeys(PHWINFO pDev)
{
    U008 temp, newEvents, stateReg; //, stateChanges;
    U008 lock, head;
    U032 centering;

    //Workaround: loop over both heads.
    for (head = 0; head <= 1; head++) {

    lock = ReadCRTCLock(pDev, head);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, head);    //Unlock CRTC extended regs

    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    newEvents = temp & (NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);    //Only handle events we know about.

    CRTC_RD(NV_CIO_CRE_SCRATCH7__INDEX, stateReg, head);

    //DEBUG
    if (newEvents) {
        //Leave this printf for current debug purposes -- hotkeys are young yet.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Head:", head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4A register is now:", temp);
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4B register is now:", temp);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4C register is now:", stateReg);
        CRTC_RD(0x3B, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B register is now:", temp);
//        CRTC_RD(0x3B, temp, 1);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register is now:", temp);
    }
    //DEBUG

    //Check if anything has changed:
    //Pressing a key may generate more than one event (e.g., disabling one display and enabling another)

    if (newEvents & NV_MOBILE_FLAG_DISPLAY_MASK) {

        temp = 0;
        if (stateReg & NV_MOBILE_DISPLAY_LCD_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
        }
        if (stateReg & NV_MOBILE_DISPLAY_CRT_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
        }
        if (stateReg & NV_MOBILE_DISPLAY_TV_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
        }
        if (stateReg & NV_MOBILE_DISPLAY_DFP_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
        }

//            if (stateChanges & (NV_MOBILE_DISPLAY_LCD_MASK | NV_MOBILE_DISPLAY_CRT_MASK
//                | NV_MOBILE_DISPLAY_TV_MASK | NV_MOBILE_DISPLAY_DFP_MASK )) {
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_ENABLE, temp);
//            }
    }

    if (newEvents & NV_MOBILE_FLAG_SCALE_MASK) {
//            if (stateChanges & NV_MOBILE_DISPLAY_SCALE_MASK) {
            centering = REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _MODE);
            if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE) temp = NV_HOTKEY_STATUS_DISPLAY_SCALED;
            else if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER) temp = NV_HOTKEY_STATUS_DISPLAY_CENTERED;
            else temp = NV_HOTKEY_STATUS_DISPLAY_NATIVE;
//                hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, (stateReg & NV_MOBILE_DISPLAY_SCALE_MASK)?1:0);
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, temp);
//            }
    }

        //Now reset the event flags we've handled.  We do this after we've actually handled
        // the events (not explicitly required at this point, but seems cleanest) and in the
        // smallest possible amount of time between re-reading the register and writing it.
    if (newEvents) {
//            pDev->HotKeys.reg4CShadow = (U032)stateReg;            //Update our shadow register

        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
        temp &= ~newEvents;    //Reset the events we will handle.
            // LPL: possible race here -- another SSF bit gets set during our read-mod-write window,
            // and is cleared by us unintentionally (that's why this window is made intentionally
            // as small as possible by re-reading the register)
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    }

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, head); // Restore lock state

    }   //workaround: loop over both heads

}

//
// Service vertical blank interrupt.
//
VOID VBlank
(
    PHWINFO pDev
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 pmc, pending;
    U032 head;
    U032 rmFinish;
    U032 i;
    U008 CrtcIndex;

#ifdef RM_STATS                    
    pDev->Framebuffer.ServiceCount++;
#endif
    rmFinish = FALSE;

    // Save the CRTC index reg, since we may have interrupted someone doing an access.
    CrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR);
    //
    // We're here because at least one of the PCRTC bits is pending.
    // Read the NV_PMC_INTR_0 register to figure out which one(s).
    //
	pending = 0;
    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    for (head = 0; head < MAX_CRTCS; head++)
    {
        // Move on if this crtc's interrupt isn't pending...
        if ((pending & (1 <<  head)) == 0)
            continue;

        // Scanout address updates...
        //
        // Since class07c's SET_IMAGE_FORMAT queues a VBlank callback (which we'll
        // handle "immediately" in VBlankProcessCallbacks below) and has an ASSERT
        // on the VBlankCounter value, we'll handle this update before the counter
        // is incremented.
        //
        VBlankUpdateImageOffsetFormat(pDev, head);

        // This head needs servicing...
        pDacCrtcInfo = &pDev->Dac.CrtcInfo[head];

        pDacCrtcInfo->VBlankToggle = 0;
        pDacCrtcInfo->VBlankCounter++;
        pDacCrtcInfo->IsVBlank = TRUE;

        //
        // Head 0 still gets unique treatment for things driven
        // by the older NV_VIDE0_FROM_MEMORY class and family.
        //
        if (head == 0)
        {
            rmFinish |= VBlankUpdateFlip(pDev, head);
            class63VBlank(pDev);
            VBlankUpdatePalette(pDev, head);
            rmFinish |= VBlankUpdateVideoScaler(pDev, head);
        }

        // Cursor updates...
        VBlankUpdateCursor(pDev, head);

        // Callback list...
        VBlankProcessCallbacks(pDev, head);

        pDacCrtcInfo->IsVBlank = FALSE;
    }

    if (pDev->Power.MobileOperation && pDev->HotKeys.enabled)
        VBlankCheckHotKeys(pDev);

    //
    // Update service count if no RM processing required (RM will increment this in mcService).
    //
    if (!rmFinish)
    {
#ifdef RM_STATS                    
        pDev->Chip.ServiceCount++;
#endif
        //
        // If RM doesn't need to service VBLANK, clear VBLANK interrupt. It is possible to see more
        // than one VBLANK interrupt before the RM has a chance to service the first one. Make sure
        // to recalc the rmFinish result properly.
        //
        rmFinish = pDev->Framebuffer.FinishFlags;
        if (!rmFinish)
        {
            //
            // On really fast machines, VBlank may not get cleared before returning.
            //

            // Head 0 serviced...
            if (pending & 0x1)
            {
                do
                {
                    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                    i = REG_RD32(NV_PMC_INTR_0);
                } while (i & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)));
            }

            // Head 1 serviced...
            if (pending & 0x2)
            {
                do
                {
                    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 1);
                    i = REG_RD32(NV_PMC_INTR_0);
                } while (i & (DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)));
            }
        }
    }
    REG_WR08(NV_PRMCIO_CRX__COLOR, CrtcIndex);	// restore crtc index
}

//
// Return bitmask representing heads with pending
// vblank interrupts.
//
U032
VBlankPending
(
    PHWINFO pDev
)
{
    U032 pending = 0;

    //
    // TODO: call into HAL to get these.
    //
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)))
        pending |= 0x1;
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
        pending |= 0x2;

    return pending;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\video\nv10\vidnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV10.c                                                         *
*   The NV10 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV10(VOID *);
RM_STATUS nvHalVideoAlloc_NV10(VOID *);
RM_STATUS nvHalVideoFree_NV10(VOID *);
RM_STATUS nvHalVideoMethod_NV10(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV10(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV10(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV10(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV10(S012d020);
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoAdjustScalarForTV_NV10(PHALHWINFO, U032);
VOID videoKickOffOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV10(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV10 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV10(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV10(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PHWREG nvAddr;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            nvAddr = pHalHwInfo->nvBaseAddr;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV10(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV10(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV10(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV10(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV10(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV10(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV10(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV10_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PHWREG nvAddr;
    U032 data;

    nvAddr = pHalHwInfo->nvBaseAddr;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // We can't rely on our PvideoBufferCopy to tell us if the
    // hardware is still using a given buffer because we're getting
    // out of sync (somehow).
    // Go to the hardware directly to make sure we reclaim buffer
    // via stop when we need to.
#if 0
    if ((videoHwOwnsBuffer_NV10(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV10(pHalHwInfo, 1, pOverlayHalObj))) {
#endif
    if (REG_RD32(NV_PVIDEO_BUFFER))
    {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV10 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Adjust the video overlay position if running on TV.
//
//---------------------------------------------------------------------------

//	Because of the way the video scalar syncs with the CRTC, we need to adjust both CRTC timing
//  and make overlay adjustments differently for different devices. NV4 had this problem, NV5
//	was "fixed", and in NV10 the problem is back. NV12 and later device may or may not need
//	special adjustments.
VOID videoAdjustScalarForTV_NV10(PHALHWINFO pHalHwInfo, U032 buffNum)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 data;

    if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_TV)
    {
        data = REG_RD32(NV_PVIDEO_POINT_OUT(buffNum));
        REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data + NV10_VSCALAR_TV_ADJUST);
    }
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV10
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV10
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV10 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\video\nv\videoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: videoobj.c                                                        *
*   Video engine objects are managed here.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV_PATCHCORD_VIDEO (class60)
static RM_STATUS videoCreatePatchcordObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyPatchcordObj(PHWINFO, POBJECT);

// NV_VIDEO_SINK (class61)
static RM_STATUS videoCreateSinkObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroySinkObj(PHWINFO, POBJECT);

// NV_VIDEO_COLORMAP (class62)
static RM_STATUS videoCreateColormapObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColormapObj(PHWINFO, POBJECT);

// NV_VIDEO_FROM_MEMORY (class63)
static RM_STATUS videoCreateFromMemoryObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyFromMemoryObj(PHWINFO, POBJECT);

// NV_VIDEO_SCALER (class64)
static RM_STATUS videoCreateScalerObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyScalerObj(PHWINFO, POBJECT);

// NV_VIDEO_COLOR_KEY (class65)
static RM_STATUS videoCreateColorKeyObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColorKeyObj(PHWINFO, POBJECT);

// NVXX_VIDEO_OVERLAY
static RM_STATUS videoCreateOverlayObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *, VOID *);
static RM_STATUS videoDestroyOverlayObj(PHWINFO, POBJECT);

//
// Class lock macros (video engine allocations are per-device).
//
#define VIDEOCLASSLOCK_ISSET(pdev,bit)  (pDev->Video.ClassLocks & (1 << bit))
#define VIDEOCLASSLOCK_SET(pdev,bit)    (pDev->Video.ClassLocks |= (1 << bit))
#define VIDEOCLASSLOCK_CLEAR(pdev,bit)  (pDev->Video.ClassLocks &= ~(1 << bit))

//
// videoCreateObj
//
// Top-level create routine for video engine classes.
//
RM_STATUS videoCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateObj\r\n");

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (VIDEOCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        VIDEOCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoCreatePatchcordObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoCreateSinkObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoCreateColormapObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoCreateFromMemoryObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoCreateScalerObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoCreateColorKeyObj(pDev, ClassObject, Name, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoCreateOverlayObj(pDev, ClassObject, Name, Object, pCreateParms);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
        return (status); 
    }

    return (RM_OK);
}

RM_STATUS videoDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(VIDEOCLASSLOCK_ISSET(pDev, lockBit));
        VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoDestroyPatchcordObj(pDev, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoDestroySinkObj(pDev, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoDestroyColormapObj(pDev, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoDestroyFromMemoryObj(pDev, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoDestroyScalerObj(pDev, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoDestroyColorKeyObj(pDev, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoDestroyOverlayObj(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video patchcord create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreatePatchcordObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS status;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreatePatchcordObj\r\n");

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOPATCHCORD));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOPATCHCORD)*Object)->FanOut      = 0;
    ((PVIDEOPATCHCORD)*Object)->Source      = NULL;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PVIDEOPATCHCORD)*Object)->Destination[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOPATCHCORD)*Object)->CBase, 
                                      ((PVIDEOPATCHCORD)*Object)->CBase.ChID, 
                                      ((PVIDEOPATCHCORD)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyPatchcordObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyPatchcordObj\r\n");

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video sink create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateSinkObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateSinkObj\r\n");

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSINKOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    for (i = 0; i < MAX_GRPATCH_INPUT; i++)
        ((PVIDEOSINKOBJECT)*Object)->VideoInput[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOSINKOBJECT)*Object)->CBase, 
                                      ((PVIDEOSINKOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOSINKOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroySinkObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroySinkObj\r\n");

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video colormap create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColormapObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateColormapObj\r\n");

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORMAPOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoInput  = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoOutput = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->ColorFormat = INVALID_COLOR_FORMAT;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Xlate       = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Start       = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Length      = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyStart  = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyLength = 0;
    for (i = 0; i < 256; i++)
        ((PVIDEOCOLORMAPOBJECT)*Object)->ColorMap[i] = (i << 16) | (i << 8) | i;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOCOLORMAPOBJECT)*Object)->CBase, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyColormapObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyColormapObj\r\n");

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);
    
    // null out the color map object cached in pDev upon destruction
    if ((POBJECT)pDev->colormapObjectToNotify == Object)
    {
        pDev->colormapObjectToNotify = NULL;
    }

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video from memory create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateFromMemoryObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PCLASS              pClass = ClassObject->Base.ThisClass;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U008                *bytePtr;
    U032                i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateFromMemoryObj\r\n");

    //
    // Create the NV_VIDEO_FROM_MEMORY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOFROMMEMOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidFromMem;
    for (i = 0; i < sizeof (VIDEOFROMMEMOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Setup any specific initialization values.
    //
    pVidFromMem->InitState               = 0;
    pVidFromMem->BBuffer[0].State        = BUFFER_IDLE;
    pVidFromMem->BBuffer[1].State        = BUFFER_IDLE;
    pVidFromMem->VBlankNotify[0].Pending = FALSE;
    pVidFromMem->VBlankNotify[1].Pending = FALSE;

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidFromMem->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, pClass->Type, &pVidFromMem->HalObject);
    if (status)
        return (status);

    //
    // HACK (scottl): There are several places in the RM that assume
    // the struct _def_common_object is at the head of class-specific
    // data structures like struct _def_video_from_memory_object
    // (most notably the call to fifoAddObject after we return from
    // here).  In order to allow these to continue to work, we do
    // the following completely bogus initialization.
    //
    (*Object)->Name          = UserName;
    (*Object)->Class         = ClassObject->Base.ThisClass;
    (*Object)->ThisClass     = ClassObject->Base.ThisClass;
    (*Object)->ChID          = ClassObject->Base.ChID;
    (*Object)->NotifyXlate   = NULL;
    (*Object)->NotifyAction  = 0;
    (*Object)->NotifyTrigger = FALSE;
    (*Object)->NotifyEvent   = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidFromMem->CBase, 
                                      pVidFromMem->CBase.ChID, 
                                      pVidFromMem->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyFromMemoryObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032                i;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyFromMemoryObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_FROM_MEMORY object.
    //

    //
    // Halt transfers.
    //
    class63StopTransfer(pDev, Object, 0, 0, 0);

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, Object->ThisClass->Type, &pVidFromMem->HalObject);

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidFromMem->CBase, pVidFromMem->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video scaler create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateScalerObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS              pClass = ClassObject->Base.ThisClass;
    RM_STATUS           status;
    PVIDEOSCALEROBJECT  pVidScaler;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateScalerObj\r\n");

    //
    // Create the NV_VIDEO_SCALER object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSCALEROBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidScaler->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, pClass->Type, &pVidScaler->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidScaler->CBase, 
                                      pVidScaler->CBase.ChID, 
                                      pVidScaler->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyScalerObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyScalerObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_SCALER object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, Object->ThisClass->Type, &pVidScaler->HalObject);

    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidScaler->CBase, pVidScaler->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video colorkey create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColorKeyObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS                  pClass = ClassObject->Base.ThisClass;
    RM_STATUS               status;
    PVIDEOCOLORKEYOBJECT    pVidColorKey;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateColorKeyObj\r\n");

    //
    // Create the NV_VIDEO_COLOR_KEY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORKEYOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidColorKey->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, pClass->Type, &pVidColorKey->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidColorKey->CBase, 
                                      pVidColorKey->CBase.ChID, 
                                      pVidColorKey->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyColorKeyObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyColorKeyObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_COLOR_KEY object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, Object->ThisClass->Type, &pVidColorKey->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidColorKey->CBase, pVidColorKey->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video overlay create/destroy routines.
//----------------------------------------------------------------------

//
// Return head number specified in alloc request.
//
static U032 videoGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
	RM_STATUS	status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;
        
    switch (pClass->Type)
    {
        case NV10_VIDEO_OVERLAY:
        {
			NV07C_ALLOCATION_PARAMETERS Class07cParams;
			status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
			if (status != RM_OK)
				return 0;

			Head = Class07cParams.logicalHeadId;
            break;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

static RM_STATUS videoCreateOverlayObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object,
    VOID* pCreateParms
)
{
    RM_STATUS                   status;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateOverlayObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_OVERLAY_OBJECT));
    if (status)
        return (status);
        
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)*Object;

    //
    // Associate the head for the Video Scalar
    //
    pDev->Video.HalInfo.Head = videoGetHead(pClass, pCreateParms);
    if (pDev->Video.HalInfo.Head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: videoCreateOverlayObj: invalid logical head number ", pDev->Video.HalInfo.Head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }


    if (IsNV11(pDev)) {
        AssocVideoScalar(pDev, pDev->Video.HalInfo.Head);
    }

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pOverlayObject;
    for (i = 0; i < sizeof (VIDEO_OVERLAY_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, &pOverlayObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pOverlayObject->CBase, 
                                      pOverlayObject->CBase.ChID, 
                                      pOverlayObject->CInstance);
    if (status != RM_OK)
    {
        nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, (VOID *)&pOverlayObject->HalObject);
        osFreeMem(*Object);
    }

    return (status);
}

static RM_STATUS videoDestroyOverlayObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         Head = 0;  // TO DO: add parameter or extract from object

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyOverlayObj\r\n");

    VidLutCurDac.Head = Head;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, Object->ThisClass->Type, &pOverlayObject->HalObject);

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    //
    // Clear active overlay object field is applicable.
    //
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pOverlayObject)
    {
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;
        pDev->Video.HalInfo.Enabled = 0;
    }

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pOverlayObject->CBase, pOverlayObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks if chip requires it.
    //
    if (!IsNV10orBetter(pDev)) {
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[0].OverlayCallback));
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[1].OverlayCallback));
    }

    return (osFreeMem(Object));
}

//-----------------------------------------------------------------------
// Video exception handling.
//-----------------------------------------------------------------------

//
// Service exception on class63 (NV_VIDEO_FROM_MEMORY) object transfer.
//
V032 videoFromMemService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEOFROMMEMOBJECT pVidFromMemObj;
    VOID *pVidHalObj;
    U032 buffsPending;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pVidFromMemObj = (PVIDEOFROMMEMOBJECT)pObject;
    if (pVidFromMemObj)
        pVidHalObj = (VOID *)&pVidFromMemObj->HalObject;
    else
        pVidHalObj = NULL;

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer 0 completed. 
            notifyFillNotifierArray( pDev, pVidFromMemObj->BufferObj.Base.NotifyXlate, 
                                     0, 
                                     0, 
                                     0, 
                                     NVFF8_NOTIFIERS_IMAGE_SCAN(i) );
                    
#ifdef DEBUG_TIMING            
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "Buffer 0 Completed. \n");
            vmmOutDebugString("0N");
#endif // DEBUG_TIMING                
                    
            //
            // Do any OS specified action related to this notification.
            //
            if (pVidFromMemObj->BBuffer[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pVidFromMemObj,
                              NVFF8_NOTIFIERS_IMAGE_SCAN(i),
                              0, 
                              1, 
                              RM_OK, 
                              pVidFromMemObj->BBuffer[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Service exceptions on class0XX (NVXX_VIDEO_OVERLAY) object transfers.
//
V032 videoOverlayService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    VOID *pVidHalObj;
    U032 buffsPending, class;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)pObject;
    if (pOverlayObject)
    {
        class = pObject->ThisClass->Type;
        pVidHalObj = (VOID *)&pOverlayObject->HalObject;
    }
    else
    {
        //
        // If there is no active video object, the class will
        // be ignored anyway.   
        //
        class = 0;
        pVidHalObj = NULL;
    }

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, class, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer completed. 
            notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                    0, // info32
                                    0, // info16
                                    RM_OK, 
                                    NV047_NOTIFIERS_SET_OVERLAY(i));

#ifdef DEBUG_TIMING            
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Buffer Completed. \n");
            vmmOutDebugString("1N");
#endif // DEBUG_TIMING

            //
            // Do any OS specified action related to this notification.
            //
            if (pOverlayObject->Overlay[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pOverlayObject,
                              NV047_NOTIFIERS_SET_OVERLAY(i),
                              0, // Method
                              0, // Data
                              RM_OK, 
                              pOverlayObject->Overlay[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, class, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Update the POINT_OUT on behalf DDraw when panning the desktop
//
VOID videoUpdateWindowStart
(
    PHWINFO pDev,
    S016 deltaX,
    S016 deltaY
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    U016 pointoutX, pointoutY;
    U032 Data;
    RM_STATUS status;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject;

    if (pOverlayObject->CBase.ThisClass->Type != NV10_VIDEO_OVERLAY)
        return;    // only applicable to class07a

    if (!deltaX && !deltaY)
        return;    // no delta to apply

    // We assume buffer0 and buffer1 are using the same POINT_OUT values
    RM_ASSERT(pOverlayObject->HalObject.Overlay[0].PointOut_x == 
              pOverlayObject->HalObject.Overlay[1].PointOut_x);
    RM_ASSERT(pOverlayObject->HalObject.Overlay[0].PointOut_y == 
              pOverlayObject->HalObject.Overlay[1].PointOut_y);

    // Apply delta x,y to class07a's current point out x,y
    pointoutX = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_x + deltaX;
    pointoutY = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_y + deltaY;

    Data = DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _X, pointoutX) |
           DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _Y, pointoutY);
    //
    // This method doesn't wait for the buffer to be released by the HW
    // and updates both POINT_OUT(0) and POINT_OUT(1) to the same value.
    //
    (VOID) nvHalVideoMethod(pDev,
                            NV10_VIDEO_OVERLAY,
                            (VOID *)&pOverlayObject->HalObject,
                            NV07A_SET_OVERLAY_POINT_OUT_A,
                            Data,
                            &status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\video\nv20\vidnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV20.c                                                         *
*   The NV20 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV20(VOID *);
RM_STATUS nvHalVideoAlloc_NV20(VOID *);
RM_STATUS nvHalVideoFree_NV20(VOID *);
RM_STATUS nvHalVideoMethod_NV20(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV20(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV20(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV20(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV20(S012d020);
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoAdjustScalarForTV_NV20(PHALHWINFO, U032);
VOID videoKickOffOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV20(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV20 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV20(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV20(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PHWREG nvAddr;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            nvAddr = pHalHwInfo->nvBaseAddr;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV20(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV20(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV20(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV20(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV20(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV20(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV20(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV20_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PHWREG nvAddr;
    U032 data;

    nvAddr = pHalHwInfo->nvBaseAddr;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = (U032)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if ((videoHwOwnsBuffer_NV20(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV20(pHalHwInfo, 1, pOverlayHalObj))) {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV20 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Adjust the video overlay position if running on TV.
//
//---------------------------------------------------------------------------

//	Because of the way the video scalar syncs with the CRTC, we need to adjust both CRTC timing
//  and make overlay adjustments differently for different devices. NV4 had this problem, NV5
//	was "fixed", and in NV10 the problem is back. NV12 and later device may or may not need
//	special adjustments.
VOID videoAdjustScalarForTV_NV20(PHALHWINFO pHalHwInfo, U032 buffNum)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 data;

    if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_TV)
    {
        data = REG_RD32(NV_PVIDEO_POINT_OUT(buffNum));
        REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data + NV10_VSCALAR_TV_ADJUST);
    }
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV20
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV20 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvmisc.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvmisc.h
 */
#ifndef __NV_MISC_H
#define __NV_MISC_H

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// 
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long	token;
    unsigned long	cmd;
    unsigned long	port;
    unsigned long	flags;
    unsigned long	data;
    unsigned long	status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define	NVRM_I2C_ACCESS_CMD_ACQUIRE     1
#define	NVRM_I2C_ACCESS_CMD_RELEASE     2
#define	NVRM_I2C_ACCESS_CMD_WRITE_BYTE  3
#define	NVRM_I2C_ACCESS_CMD_READ_BYTE   4
#define	NVRM_I2C_ACCESS_CMD_NULL        5
#define	NVRM_I2C_ACCESS_CMD_RESET       6
#define NVRM_I2C_ACCESS_CMD_READ_SDA    7
#define NVRM_I2C_ACCESS_CMD_READ_SCL    8
#define NVRM_I2C_ACCESS_CMD_WRITE_SDA   9
#define NVRM_I2C_ACCESS_CMD_WRITE_SCL   10

// flags
#define NVRM_I2C_ACCESS_FLAG_START	    0x1
#define	NVRM_I2C_ACCESS_FLAG_STOP	    0x2
#define	NVRM_I2C_ACCESS_FLAG_ACK	    0x4

// port
#define	NVRM_I2C_ACCESS_PORT_PRIMARY    1
#define	NVRM_I2C_ACCESS_PORT_SECONDARY  2

// status
#define	NVRM_I2C_ACCESS_STATUS_SUCCESS         0
#define	NVRM_I2C_ACCESS_STATUS_ERROR           1
#define	NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR  2
#define	NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY     3

//
// misc string definitions for registry manipulation
//
#define STR_NVIDIA                  "NVidia"
#define STR_DEV_NODE_RM             "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System"
#define STR_DEV_NODE_DISPLAY        "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display";
#define STR_DEV_NODE_DISPLAY_NUMBER "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
#define STR_RM_CORE_NAME            "RmCoreName"

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // __NV_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\video\nv4\vidnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV04.c                                                         *
*   The NV4 specific HAL VIDEO routines reside in this file.                *
*   Class specific routines are contained in the corresponding modular      *
*   directory file.
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV04(VOID *);
RM_STATUS nvHalVideoAlloc_NV04(VOID *);
RM_STATUS nvHalVideoFree_NV04(VOID *);
RM_STATUS nvHalVideoMethod_NV04(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV04(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV04(VOID *);

// Exports needed by class-dependent files in modular/nv4.
RM_STATUS videoInit_NV04(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV04(S012d020);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV04(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            //
            // For NV4 overlay, we need to be absolutely certain we start the pipeline
            // outside of active display, otherwise we can hang it during the kickoff.
            // Eventhough called from vblank, spin to guarantee we kickoff in blank.
            //
            while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x8)
                // while in vertical blank, wait for active display
                ;
            while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x0)
                // while in active display, wait for vertical blank
                ;

            // Now, we should definitely be in vertical blank
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV04(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;

    //
    // Connect class-dependent kick off routine.
    //
    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoAllocArg->pHalObjInfo;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        }
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV04(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)   // if the desktop is using the scalar, don't shut off
                    REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV04(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV04(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV04(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
    {
        //
        // Ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        //
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        pVideoGetEventStatusArg->intrStatus = 0;
        return RM_OK;
    }

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV04
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV04
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    // Force the hardware to be reset if this routine is called at all.
    // We need to revisit this fix for our modeset problems to see if there is
    // a better solution (JSUN).
    // 

    if (classNum == NV_VIDEO_FROM_MEMORY)
        if (pHalHwInfo->pVideoHalInfo->Enabled)
            return (RM_OK);
        
    REG_WR32(NV_PVIDEO_CONTROL_Y, DRF_DEF(_PVIDEO, _CONTROL_Y, _BLUR, _ON));
    REG_WR32(NV_PVIDEO_CONTROL_X, DRF_DEF(_PVIDEO, _CONTROL_X, _SMOOTHING, _ON)
                                | DRF_DEF(_PVIDEO, _CONTROL_X, _SHARPENING, _ON));

    REG_WR32(NV_PVIDEO_BUFF0_OFFSET, 0);
    REG_WR32(NV_PVIDEO_BUFF1_OFFSET, 0);

    REG_WR32(NV_PVIDEO_OE_STATE, 0);
    REG_WR_DRF_DEF(_PVIDEO, _OE_STATE, _CURRENT_BUFFER, _1);
    REG_WR32(NV_PVIDEO_SU_STATE, DRF_NUM(_PVIDEO, _SU_STATE, _BUFF0_IN_USE, 1)
                               | DRF_NUM(_PVIDEO, _SU_STATE, _BUFF1_IN_USE, 1));
    REG_WR32(NV_PVIDEO_RM_STATE, 0);

    REG_WR_DRF_DEF(_PVIDEO, _INTR_EN_0, _NOTIFY, _ENABLED);

    //
    // Initialize default conversion values
    // These value are per the NV3/4 manual as the default
    // offsets for YUV conversion
    //
    REG_WR32(NV_PVIDEO_CSC_ADJUST, 0x10000);
    REG_WR32(NV_PVIDEO_RED_CSC, 105);
    REG_WR32(NV_PVIDEO_GREEN_CSC, 62);
    REG_WR32(NV_PVIDEO_BLUE_CSC, 137);

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\NvImage.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvImage.h                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/03/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVIMAGE_H_
#define _NVIMAGE_H_

#ifdef  DEFINE_JPEG_TYPES
#include <stdio.h>
#include <string.h>
#include "jpeglib.h"
#else   //~DEFINE_JPEG_TYPES
struct jpeg_decompress_struct {
    DWORD Pan;
};
typedef BYTE JSAMPLE;
#endif  //~DEFINE_JPEG_TYPES

typedef void (__stdcall *SCANLINEPROCESS)(void *, int);

typedef enum _JPEGParameterType_ {
    JPEG_WRITE_QUALITY      = 1,
    JPEG_READ_DEPTH         = 2,
} JPEGPARAMETERTYPE;

#ifdef __cplusplus

typedef class CImageObject
{
    /*
     * methods
     */
public:
    virtual void WINAPI CompressJPEG (void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    virtual void WINAPI GetJPEGInfo (char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    virtual DWORD WINAPI SetJPEGParameters (JPEGPARAMETERTYPE type, DWORD value);
    virtual void WINAPI DecompressJPEG (char * filename, SCANLINEPROCESS ScanlineProcess);
    virtual void WINAPI DecompressJPEG (char * filename);
    virtual void WINAPI GetImageParameters (char *&Start, char *&Current, DWORD &Width, DWORD &Height, DWORD &BPP);
    virtual DWORD WINAPI DestroyImageObject(void);
    CImageObject();
    ~CImageObject();
protected:
    void write_JPEG_file (char * filename, int quality);
    int  get_JPEG_file_info (char * filename, struct jpeg_decompress_struct *pCinfo);
    int  read_JPEG_file (char * filename, SCANLINEPROCESS ScanlineProcess);
    void __stdcall InternalScanlineProcess(LPVOID pBuf, int stride);
protected:
    int       out_quality;          /* Specify quality of the subsequent compression 0-100, 100 being highest. */ 
    JSAMPLE * out_image_buffer;	    /* Points to large array of R,G,B-order data */
    int       out_image_height;	    /* Number of rows in image */
    int       out_image_width;		/* Number of columns in image */
    char     *image_buffer;
    char     *image_ptr;
    DWORD     image_width; 
    DWORD     image_height; 
    DWORD     image_depth;  
} CIMAGEOBJECT, *LPCIMAGEOBJECT;


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT &pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT &pImageOpject);

#else   //__cplusplus==0

typedef struct CImageObject
{
    struct  CImageObjectVtbl FAR *lpVtbl;
} CIMAGEOBJECT, *LPCIMAGEOBJECT;

struct  CImageObjectVtbl {
    void    (WINAPI *CompressJPEG)(LPCIMAGEOBJECT, void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    void    (WINAPI *GetJPEGInfo)(LPCIMAGEOBJECT, char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    DWORD   (WINAPI *SetJPEGParameters)(LPCIMAGEOBJECT, JPEGPARAMETERTYPE type, DWORD value);
    void    (WINAPI *DecompressJPEGCustom)(LPCIMAGEOBJECT, char * filename, SCANLINEPROCESS ScanlineProcess);
    void    (WINAPI *DecompressJPEG)(LPCIMAGEOBJECT, char * filename);
    void    (WINAPI *GetImageParameters)(LPCIMAGEOBJECT, char **Start, char **Current, DWORD *Width, DWORD *Height, DWORD *BPP);
    DWORD   (WINAPI *DestroyImageObject)(LPCIMAGEOBJECT);
};


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT *pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT *pImageOpject);

#endif  //__cplusplus==0

#endif _NVIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\dderror.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

#define NO_ERROR 0L                                                 
#define ERROR_INVALID_FUNCTION           1L    
#define ERROR_NOT_ENOUGH_MEMORY          8L    
#define ERROR_DEV_NOT_EXIST              55L    
#define ERROR_INVALID_PARAMETER          87L    
#define ERROR_INSUFFICIENT_BUFFER        122L    
#define ERROR_INVALID_NAME               123L    
#define ERROR_MORE_DATA                  234L    
#define ERROR_IO_PENDING                 997L    
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    
#define ERROR_CONTINUE                   1246L    
#define ERROR_NO_MORE_DEVICES            1248L    

#endif /* _DDERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nv32.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nv32.h> defines a 32-bit wide naming convention  for the functionality  *|
|*  of NVIDIA's Unified Media Architecture (TM).                             *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NV32_INCLUDED
#define NV32_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>


 /***************************************************************************\
|*                                NV Classes                                 *|
 \***************************************************************************/

/*
 * These structures indicate the offsets of hardware registers corresponding to
 * the methods of each class.  Since the first 256 bytes of each subchannel is
 * the NvControlPio registers, the hexadecimal offsets in comments start at
 * 0x100.
 */

/* class NV01_ROOT */
#define  NV01_ROOT                                                 (0x00000000)
/* NvNotification[] fields and values */
#define NV000_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv000Typedef, Nv01Root;
#define NV000_TYPEDEF                                              Nv01Root
/* obsolete stuff */
#define Nv1Root                                                    Nv01Root
#define nv1Root                                                    Nv01Root
#define nv01Root                                                   Nv01Root


/* class NV01_CLASS */
#define  NV01_CLASS                                                (0x00000001)
/* NvNotification[] fields and values */
#define NV001_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv001Typedef, Nv01Class;
#define NV001_TYPEDEF                                              Nv01Class
/* obsolete stuff */
#define  NV1_CLASS                                                 (0x00000001)
#define Nv1Class                                                   Nv01Class
#define nv1Class                                                   Nv01Class
#define nv01Class                                                  Nv01Class


/* class NV01_CONTEXT_DMA_FROM_MEMORY */
#define  NV01_CONTEXT_DMA_FROM_MEMORY                              (0x00000002)
/* NvNotification[] fields and values */
#define NV002_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv002Typedef, Nv01ContextDmaFromMemory;
#define  NV002_TYPEDEF                                 Nv01ContextDmaFromMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_FROM_MEMORY                               (0x00000002)
#define  NV01_CONTEXT_DMA                                          (0x00000002)
#define  Nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv01ContextDmaFromMemory                      Nv01ContextDmaFromMemory


/* class NV01_CONTEXT_DMA_TO_MEMORY */
#define  NV01_CONTEXT_DMA_TO_MEMORY                                (0x00000003)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv003Typedef, Nv01ContextDmaToMemory;
#define  NV003_TYPEDEF                                   Nv01ContextDmaToMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_TO_MEMORY                                 (0x00000003)
#define  Nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv01ContextDmaToMemory                          Nv01ContextDmaToMemory


/* class NV01_TIMER */
#define  NV01_TIMER                                                (0x00000004)
/* NvNotification[] elements */
#define NV004_NOTIFIERS_NOTIFY                                     (0)
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
/* NvNotification[] fields and values */
#define NV004_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV004_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV004_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV004_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV004_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV004_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;            /* ignored                           0100-0103*/
 NvV32 Notify;                 /* NV004_NOTIFY_*                    0104-0107*/
 NvV32 StopTransfer;           /* NV004_STOP_TRANSFER_VALUE         0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;  /* NV01_CONTEXT_DMA                  0180-0183*/
 NvV32 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  NvU32 nanoseconds[2];        /* nsec since 1970-01-01 0=immediate    0-   7*/
 } SetAlarmTime;               /* end of method                         -0307*/
 struct {                      /* start of method                   0308-    */
  NvU32 nanoseconds[2];        /* nsec relative to current time        8-   f*/
 } SetAlarmTimeRelative;       /* end of method                         -030f*/
 NvV32 Reserved02[0x004];
 NvV32 SetAlarmNotify;         /* NV004_SET_ALARM_NOTIFY_*          0320-0323*/
 NvV32 Reserved03[0x737];
} Nv004Typedef, Nv01Timer;
#define NV004_TYPEDEF                                              Nv01Timer
/* dma method offsets, fields, and values */
#define NV004_SET_OBJECT                                           (0x00000000)
#define NV004_NO_OPERATION                                         (0x00000100)
#define NV004_NOTIFY                                               (0x00000104)
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_STOP_TRANSFER                                        (0x00000108)
#define NV004_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV004_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV004_SET_ALARM_TIME                                       (0x00000300)
#define NV004_SET_ALARM_TIME_RELATIVE                              (0x00000308)
#define NV004_SET_ALARM_NOTIFY                                     (0x00000320)
#define NV004_SET_ALARM_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define Nv1Timer                                                   Nv01Timer
#define nv1Timer                                                   Nv01Timer
#define nv01Timer                                                  Nv01Timer


/* class NV01_EVENT */
#define  NV01_EVENT                                                (0x00000005)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct _Nv005Typedef{
 NvV32 Reserved00[0x7c0];
} Nv005Typedef, Nv01Event;
#define NV005_TYPEDEF                                              Nv01Event
/* obsolete stuff */
#define NV1_TIMER                                                  (0x00000004)
#define Nv1Event                                                   Nv01Event
#define nv1Event                                                   Nv01Event
#define nv01Event                                                  Nv01Event


typedef NvV32 Nv006Typedef;

typedef NvV32 Nv007Typedef;

typedef NvV32 Nv008Typedef;

typedef NvV32 Nv009Typedef;

typedef NvV32 Nv00aTypedef;

typedef NvV32 Nv00bTypedef;

typedef NvV32 Nv00cTypedef;

typedef NvV32 Nv00dTypedef;

typedef NvV32 Nv00eTypedef;

typedef NvV32 Nv00fTypedef;

typedef NvV32 Nv010Typedef;

typedef NvV32 Nv011Typedef;


/* class NV01_CONTEXT_BETA */
#define  NV01_CONTEXT_BETA                                         (0x00000012)
/* NvNotification[] elements */
#define NV012_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV012_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV012_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV012_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV012_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV012_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV012_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV012_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetBeta1d31;             /* S1d31 beta value                 0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv012Typedef, Nv01ContextBeta;
#define NV012_TYPEDEF                                           Nv01ContextBeta
/* dma method offsets, fields, and values */
#define NV012_SET_OBJECT                                           (0x00000000)
#define NV012_NO_OPERATION                                         (0x00000100)
#define NV012_NOTIFY                                               (0x00000104)
#define NV012_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV012_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV012_SET_BETA_1D31                                        (0x00000300)
/* obsolete stuff */
#define NV01_BETA_SOLID                                            (0x00000012)
#define NV1_BETA_SOLID                                             (0x00000012)
#define Nv01BetaSolid                                           Nv01ContextBeta
#define nv01BetaSolid                                           Nv01ContextBeta
#define Nv1BetaSolid                                            Nv01ContextBeta
#define nv1BetaSolid                                            Nv01ContextBeta

typedef NvV32 Nv013Typedef;

typedef NvV32 Nv014Typedef;

typedef NvV32 Nv015Typedef;

typedef NvV32 Nv016Typedef;


/* class NV01_CONTEXT_COLOR_KEY */
#define  NV01_CONTEXT_COLOR_KEY                                    (0x00000017)
/* NvNotification[] elements */
#define NV017_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV017_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV017_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV017_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV017_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV017_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV017_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV017_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV017_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetColor;                /* color key value                  0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv017Typedef, Nv01ContextColorKey;
#define NV017_TYPEDEF                                       Nv01ContextColorKey
/* dma method offsets, fields, and values */
#define NV017_SET_OBJECT                                           (0x00000000)
#define NV017_NO_OPERATION                                         (0x00000100)
#define NV017_NOTIFY                                               (0x00000104)
#define NV017_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV017_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV017_SET_COLOR_FORMAT                                     (0x00000300)
#define NV017_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV017_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV017_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV017_SET_COLOR                                            (0x00000304)
/* obsolete stuff */
#define NV01_IMAGE_SOLID                                           (0x00000017)
#define NV1_IMAGE_SOLID                                            (0x00000017)
#define Nv01ImageSolid                                      Nv01ContextColorKey
#define nv01ImageSolid                                      Nv01ContextColorKey
#define Nv1ImageSolid                                       Nv01ContextColorKey
#define nv1ImageSolid                                       Nv01ContextColorKey
#define nv01ContextColorKey                                 Nv01ContextColorKey


/* class NV01_CONTEXT_PATTERN */
#define  NV01_CONTEXT_PATTERN                                      (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV018_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*     0308-030b*/
 NvV32 Reserved02[0x001];
 NvV32 SetMonochromeColor0;     /* color of 0 pixels                0310-0313*/
 NvV32 SetMonochromeColor1;     /* color of 1 pixels                0314-0317*/
 NvV32 SetMonochromePattern0;   /* first  32 bits of pattern data   0318-031b*/
 NvV32 SetMonochromePattern1;   /* second 32 bits of pattern data   031c-031f*/
 NvV32 Reserved03[0x738];
} Nv018Typedef, Nv01ContextPattern;
#define NV018_TYPEDEF                                        Nv01ContextPattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)
/* obsolete stuff */
#define NV01_IMAGE_PATTERN                                         (0x00000018)
#define NV1_IMAGE_PATTERN                                          (0x00000018)
#define Nv01ImagePattern                                     Nv01ContextPattern
#define nv01ImagePattern                                     Nv01ContextPattern
#define Nv1ImagePattern                                      Nv01ContextPattern
#define nv1ImagePattern                                      Nv01ContextPattern
#define nv01ContextPattern                                   Nv01ContextPattern


/* class NV01_CONTEXT_CLIP_RECTANGLE */
#define  NV01_CONTEXT_CLIP_RECTANGLE                               (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV019_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetPoint;                /* y_x S16_S16                      0300-0303*/
 NvV32 SetSize;                 /* height_width U16_U16             0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv019Typedef, Nv01ContextClipRectangle;
#define NV019_TYPEDEF                                  Nv01ContextClipRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16
/* obsolete stuff */
#define NV01_IMAGE_BLACK_RECTANGLE                                 (0x00000019)
#define NV1_IMAGE_BLACK_RECTANGLE                                  (0x00000019)
#define Nv01ImageBlackRectangle                        Nv01ContextClipRectangle
#define nv01ImageBlackRectangle                        Nv01ContextClipRectangle
#define Nv1ImageBlackRectangle                         Nv01ContextClipRectangle
#define nv1ImageBlackRectangle                         Nv01ContextClipRectangle
#define nv01ContextClipRectangle                       Nv01ContextClipRectangle

typedef NvV32 Nv01aTypedef;

typedef NvV32 Nv01bTypedef;


/* class NV01_RENDER_SOLID_LIN */
#define  NV01_RENDER_SOLID_LIN                                     (0x0000001C)
/* NvNotification[] elements */
#define NV01C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01C_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01C_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01C_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point0;                 /* y_x S16_S16 in pixels               0-   3*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               4-   7*/
 } Lin[16];                     /* end of aliased methods in array      -047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 point0X;                /* in pixels, 0 at left                0-   3*/
  NvS32 point0Y;                /* in pixels, 0 at top                 4-   7*/
  NvS32 point1X;                /* in pixels, 0 at left                8-   b*/
  NvS32 point1Y;                /* in pixels, 0 at top                 c-   f*/
 } Lin32[8];                    /* end of aliased methods in array      -04ff*/
 NvV32 PolyLin[32];             /* y_x S16_S16 in pixels            0500-057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } PolyLin32[16];               /* end of aliased methods in array      -05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorPolyLin[16];            /* end of aliased methods in array      -067f*/
 NvV32 Reserved03[0x660];
} Nv01cTypedef, Nv01RenderSolidLin;
#define NV01C_TYPEDEF                                        Nv01RenderSolidLin
/* dma method offsets, fields, and values */
#define NV01C_SET_OBJECT                                           (0x00000000)
#define NV01C_NO_OPERATION                                         (0x00000100)
#define NV01C_NOTIFY                                               (0x00000104)
#define NV01C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01C_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01C_SET_OPERATION                                        (0x000002FC)
#define NV01C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01C_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01C_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01C_COLOR                                                (0x00000304)
#define NV01C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0_X                                         15:0
#define NV01C_LIN_POINT0_Y                                         31:16
#define NV01C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT1_X                                         15:0
#define NV01C_LIN_POINT1_Y                                         31:16
#define NV01C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV01C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV01C_POLY_LIN_X                                           15:0
#define NV01C_POLY_LIN_Y                                           31:16
#define NV01C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV01C_COLOR_POLY_LIN_POINT_Y                               31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_LIN                                       (0x0000001C)
#define Nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv01RenderSolidLin                                   Nv01RenderSolidLin


/* class NV01_RENDER_SOLID_TRIANGLE */
#define  NV01_RENDER_SOLID_TRIANGLE                                (0x0000001D)
/* NvNotification[] elements */
#define NV01D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01D_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01D_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01D_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x002];
 NvV32 TrianglePoint0;          /* y_x S16_S16 in pixels            0310-0313*/
 NvV32 TrianglePoint1;          /* y_x S16_S16 in pixels            0314-0317*/
 NvV32 TrianglePoint2;          /* y_x S16_S16 in pixels            0318-031b*/
 NvV32 Reserved03[0x001];
 NvS32 Triangle32Point0X;       /* in pixels, 0 at left             0320-0323*/
 NvS32 Triangle32Point0Y;       /* in pixels, 0 at top              0324-0327*/
 NvS32 Triangle32Point1X;       /* in pixels, 0 at left             0328-032b*/
 NvS32 Triangle32Point1Y;       /* in pixels, 0 at top              032c-032f*/
 NvS32 Triangle32Point2X;       /* in pixels, 0 at left             0330-0333*/
 NvS32 Triangle32Point2Y;       /* in pixels, 0 at top              0334-0337*/
 NvV32 Reserved04[0x032];
 NvV32 Trimesh[32];             /* y_x S16_S16 in pixels            0400-047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } Trimesh32[16];               /* end of aliased methods in array      -04ff*/
 struct {                       /* start aliased methods in array   0500-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point0;                 /* y_x S16_S16 in pixels               4-   7*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               8-   b*/
  NvV32 point2;                 /* y_x S16_S16 in pixels               c-   f*/
 } ColorTriangle[8];            /* end of aliased methods in array      -057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorTrimesh[16];            /* end of aliased methods in array      -05ff*/
 NvV32 Reserved05[0x680];
} Nv01dTypedef, Nv01RenderSolidTriangle;
#define NV01D_TYPEDEF                                   Nv01RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV01D_SET_OBJECT                                           (0x00000000)
#define NV01D_NO_OPERATION                                         (0x00000100)
#define NV01D_NOTIFY                                               (0x00000104)
#define NV01D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01D_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01D_SET_OPERATION                                        (0x000002FC)
#define NV01D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01D_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01D_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01D_COLOR                                                (0x00000304)
#define NV01D_TRIANGLE_POINT0                                      (0x00000310)
#define NV01D_TRIANGLE_POINT0_X                                    15:0
#define NV01D_TRIANGLE_POINT0_Y                                    31:16
#define NV01D_TRIANGLE_POINT1                                      (0x00000314)
#define NV01D_TRIANGLE_POINT1_X                                    15:0
#define NV01D_TRIANGLE_POINT1_Y                                    31:16
#define NV01D_TRIANGLE_POINT2                                      (0x00000318)
#define NV01D_TRIANGLE_POINT2_X                                    15:0
#define NV01D_TRIANGLE_POINT2_Y                                    31:16
#define NV01D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV01D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV01D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV01D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV01D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV01D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV01D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV01D_TRIMESH_X                                            15:0
#define NV01D_TRIMESH_Y                                            31:16
#define NV01D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV01D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT_X                                15:0
#define NV01D_COLOR_TRIMESH_POINT_Y                                31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_TRIANGLE                                  (0x0000001D)
#define Nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv01RenderSolidTriangle                         Nv01RenderSolidTriangle


/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                               (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01E_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* y_x S16_S16                         0-   3*/
  NvV32 size;                   /* height_width U16_U16                4-   7*/
 } Rectangle[16];               /* end of method in array in array      -047f*/
 NvV32 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define NV01E_TYPEDEF                                  Nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_RECTANGLE                                 (0x0000001E)
#define Nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv01RenderSolidRectangle                       Nv01RenderSolidRectangle


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                           (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurfaceSource; /* NV03_CONTEXT_SURFACE_2D_SOURCE   0198-019b*/
 NvV32 SetContextSurfaceDestin; /* NV03_CONTEXT_SURFACE_2D_DESTINAT 019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV01F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define NV01F_TYPEDEF                                             Nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION                                        (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16
/* obsolete stuff */
#define NV1_IMAGE_BLIT                                             (0x0000001F)
#define Nv1ImageBlit                                              Nv01ImageBlit
#define nv1ImageBlit                                              Nv01ImageBlit
#define nv01ImageBlit                                             Nv01ImageBlit

typedef NvV32 Nv020Typedef;


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                                       (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV021_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV021_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, in pixels  0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, in pixels  030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[32];               /* packed pixel(s) to add to image  0400-047f*/
 NvV32 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define NV021_TYPEDEF                                          Nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV1_IMAGE_FROM_CPU                                         (0x00000021)
#define Nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv01ImageFromCpu                                       Nv01ImageFromCpu

typedef NvV32 Nv022Typedef;

typedef NvV32 Nv023Typedef;

typedef NvV32 Nv024Typedef;

typedef NvV32 Nv025Typedef;

typedef NvV32 Nv026Typedef;

typedef NvV32 Nv027Typedef;

typedef NvV32 Nv028Typedef;

typedef NvV32 Nv029Typedef;

typedef NvV32 Nv02aTypedef;

typedef NvV32 Nv02bTypedef;

typedef NvV32 Nv02cTypedef;

typedef NvV32 Nv02dTypedef;

typedef NvV32 Nv02eTypedef;

typedef NvV32 Nv02fTypedef;


/* class NV01_NULL */
#define  NV01_NULL                                                 (0x00000030)
/* NvNotification[] fields and values */
#define NV030_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv030Typedef, Nv01Null;
#define NV030_TYPEDEF                                              Nv01Null
/* obsolete stuff */
#define NV1_NULL                                                   (0x00000030)
#define Nv1Null                                                    Nv01Null
#define nv1Null                                                    Nv01Null
#define nv01Null                                                   Nv01Null

typedef NvV32 Nv031Typedef;

typedef NvV32 Nv032Typedef;

typedef NvV32 Nv033Typedef;

typedef NvV32 Nv034Typedef;

typedef NvV32 Nv035Typedef;



/* class NV03_STRETCHED_IMAGE_FROM_CPU */
#define  NV03_STRETCHED_IMAGE_FROM_CPU                             (0x00000036)
/* NvNotification[] elements */
#define NV036_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV036_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV036_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV036_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV036_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV036_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV036_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV036_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV036_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DeltaDxDu;               /* S12d20 ratio dx/du               0308-030b*/
 NvV32 DeltaDyDv;               /* S12d20 ratio dy/dv               030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv036Typedef, Nv03StretchedImageFromCpu;
#define NV036_TYPEDEF                                 Nv03StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV036_SET_OBJECT                                           (0x00000000)
#define NV036_NO_OPERATION                                         (0x00000100)
#define NV036_NOTIFY                                               (0x00000104)
#define NV036_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV036_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV036_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV036_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV036_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV036_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV036_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV036_SET_OPERATION                                        (0x000002FC)
#define NV036_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV036_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV036_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV036_SET_COLOR_FORMAT                                     (0x00000300)
#define NV036_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV036_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV036_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV036_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV036_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV036_SIZE_IN                                              (0x00000304)
#define NV036_SIZE_IN_WIDTH                                        15:0
#define NV036_SIZE_IN_HEIGHT                                       31:16
#define NV036_DELTA_DX_DU                                          (0x00000308)
#define NV036_DELTA_DY_DV                                          (0x0000030C)
#define NV036_CLIP_POINT                                           (0x00000310)
#define NV036_CLIP_POINT_X                                         15:0
#define NV036_CLIP_POINT_Y                                         31:16
#define NV036_CLIP_SIZE                                            (0x00000314)
#define NV036_CLIP_SIZE_WIDTH                                      15:0
#define NV036_CLIP_SIZE_HEIGHT                                     31:16
#define NV036_POINT_12D4                                           (0x00000318)
#define NV036_POINT_12D4_X                                         15:0
#define NV036_POINT_12D4_Y                                         31:16
#define NV036_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV3_STRETCHED_IMAGE_FROM_CPU                               (0x00000036)
#define Nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv03StretchedImageFromCpu                     Nv03StretchedImageFromCpu


/* class NV03_SCALED_IMAGE_FROM_MEMORY */
#define  NV03_SCALED_IMAGE_FROM_MEMORY                             (0x00000037)
/* NvNotification[] elements */
#define NV037_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV037_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV037_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV037_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV037_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV037_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV037_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x05A];
 NvV32 SetColorFormat;          /* NV037_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV037_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DeltaDuDx;               /* S12d20 ratio du/dx               0318-031b*/
 NvV32 DeltaDvDy;               /* S12d20 ratio dv/dy               031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvU32 ImageInPitch;            /* bytes, vertical pixel delta      0404-0407*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv037Typedef, Nv03ScaledImageFromMemory;
#define NV037_TYPEDEF                                 Nv03ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV037_SET_OBJECT                                           (0x00000000)
#define NV037_NO_OPERATION                                         (0x00000100)
#define NV037_NOTIFY                                               (0x00000104)
#define NV037_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV037_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV037_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV037_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV037_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV037_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV037_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV037_SET_COLOR_FORMAT                                     (0x00000300)
#define NV037_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV037_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV037_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV037_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV037_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV037_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV037_SET_OPERATION                                        (0x00000304)
#define NV037_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV037_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV037_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV037_CLIP_POINT                                           (0x00000308)
#define NV037_CLIP_POINT_X                                         15:0
#define NV037_CLIP_POINT_Y                                         31:16
#define NV037_CLIP_SIZE                                            (0x0000030C)
#define NV037_CLIP_SIZE_WIDTH                                      15:0
#define NV037_CLIP_SIZE_HEIGHT                                     31:16
#define NV037_IMAGE_OUT_POINT                                      (0x00000310)
#define NV037_IMAGE_OUT_POINT_X                                    15:0
#define NV037_IMAGE_OUT_POINT_Y                                    31:16
#define NV037_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV037_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV037_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV037_DELTA_DU_DX                                          (0x00000318)
#define NV037_DELTA_DV_DY                                          (0x0000031C)
#define NV037_IMAGE_IN_SIZE                                        (0x00000400)
#define NV037_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV037_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV037_IMAGE_IN_PITCH                                       (0x00000404)
#define NV037_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV037_IMAGE_IN_POINT                                       (0x0000040C)
#define NV037_IMAGE_IN_POINT_U                                     15:0
#define NV037_IMAGE_IN_POINT_V                                     31:16
/* obsolete stuff */
#define NV3_SCALED_IMAGE_FROM_MEMORY                               (0x00000037)
#define Nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv03ScaledImageFromMemory                     Nv03ScaledImageFromMemory


/* class NV04_DVD_SUBPICTURE */
#define  NV04_DVD_SUBPICTURE                                       (0x00000038)
/* NvNotification[] elements */
#define NV038_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV038_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV038_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV038_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV038_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV038_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV038_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV038_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0300-0303*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0304-0307*/
 NvU32 ImageOutFormat;          /* color_pitch V16_U16              0308-030b*/
 NvU32 ImageOutOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 ImageInDeltaDuDx;        /* S12d20 ratio du/dx               0310-0313*/
 NvV32 ImageInDeltaDvDy;        /* S12d20 ratio dv/dy               0314-0317*/
 NvV32 ImageInSize;             /* height_width U16_U16 in texels   0318-031b*/
 NvV32 ImageInFormat;           /* color_pitch V16_U16              031c-031f*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0320-0323*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4 in texels        0324-0317*/
 NvV32 OverlayDeltaDuDx;        /* S12d20 ratio du/dx               0328-032b*/
 NvV32 OverlayDeltaDvDy;        /* S12d20 ratio dv/dy               032c-032f*/
 NvV32 OverlaySize;             /* height_width U16_U16 in texels   0330-0333*/
 NvV32 OverlayFormat;           /* color_pitch V16_U16              0334-0337*/
 NvU32 OverlayOffset;           /* byte offset of top-left texel    0338-033b*/
 NvV32 OverlayPoint;            /* v_u U12d4_U12d4 in texels        033c-033f*/
 NvV32 Reserved02[0x730];
} Nv038Typedef, Nv04DvdSubpicture;
#define NV038_TYPEDEF                                         Nv04DvdSubpicture
/* dma method offsets, fields, and values */
#define NV038_SET_OBJECT                                           (0x00000000)
#define NV038_NO_OPERATION                                         (0x00000100)
#define NV038_NOTIFY                                               (0x00000104)
#define NV038_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV038_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV038_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV038_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV038_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV038_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV038_IMAGE_OUT_POINT                                      (0x00000300)
#define NV038_IMAGE_OUT_POINT_X                                    15:0
#define NV038_IMAGE_OUT_POINT_Y                                    31:16
#define NV038_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV038_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV038_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV038_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV038_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV038_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8                 (0x00000001)
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8                 (0x00000002)
#define NV038_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV038_IMAGE_IN_DELTA_DU_DX                                 (0x00000310)
#define NV038_IMAGE_IN_DELTA_DV_DY                                 (0x00000314)
#define NV038_IMAGE_IN_SIZE                                        (0x00000318)
#define NV038_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV038_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV038_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV038_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV038_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8                  (0x00000001)
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8                  (0x00000002)
#define NV038_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV038_IMAGE_IN_POINT                                       (0x00000324)
#define NV038_IMAGE_IN_POINT_U                                     15:0
#define NV038_IMAGE_IN_POINT_V                                     31:16
#define NV038_OVERLAY_DELTA_DU_DX                                  (0x00000328)
#define NV038_OVERLAY_DELTA_DV_DY                                  (0x0000032C)
#define NV038_OVERLAY_SIZE                                         (0x00000330)
#define NV038_OVERLAY_SIZE_WIDTH                                   15:0
#define NV038_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV038_OVERLAY_FORMAT                                       (0x00000334)
#define NV038_OVERLAY_FORMAT_PITCH                                 15:0
#define NV038_OVERLAY_FORMAT_COLOR                                 31:16
#define NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8                     (0x00000001)
#define NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6               (0x00000002)
#define NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV038_OVERLAY_OFFSET                                       (0x00000338)
#define NV038_OVERLAY_POINT                                        (0x0000033C)
#define NV038_OVERLAY_POINT_U                                      15:0
#define NV038_OVERLAY_POINT_V                                      31:16
/* obsolete stuff */
#define NV4_DVD_SUBPICTURE                                         (0x00000038)
#define Nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv04DvdSubpicture                                     Nv04DvdSubpicture


/* class NV03_MEMORY_TO_MEMORY_FORMAT */
#define  NV03_MEMORY_TO_MEMORY_FORMAT                              (0x00000039)
/* NvNotification[] elements */
#define NV039_NOTIFIERS_NOTIFY                                     (0)
#define NV039_NOTIFIERS_BUFFER_NOTIFY                              (1)
/* NvNotification[] fields and values */
#define NV039_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV039_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV039_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV039_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV039_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV039_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV039_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaBufferIn;   /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaBufferOut;  /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x060];
 NvU32 OffsetIn;                /* src offset in bytes              030c-030f*/
 NvU32 OffsetOut;               /* dst offset in bytes              0310-0313*/
 NvS32 PitchIn;                 /* delta in bytes, vert pixel delta 0314-0317*/
 NvS32 PitchOut;                /* delta in bytes, vert pixel delta 0318-031b*/
 NvU32 LineLengthIn;            /* in bytes                         031c-031f*/
 NvU32 LineCount;               /* in lines                         0320-0323*/
 NvV32 Format;                  /* out_in U24_U8                    0324-0327*/
 NvV32 BufferNotify;            /* NV039_BUFFER_NOTIFY_*            0328-032b*/
 NvV32 Reserved02[0x735];
} Nv039Typedef, Nv03MemoryToMemoryFormat;
#define NV039_TYPEDEF                                  Nv03MemoryToMemoryFormat
/* dma method offsets, fields, and values */
#define NV039_SET_OBJECT                                           (0x00000000)
#define NV039_NO_OPERATION                                         (0x00000100)
#define NV039_NOTIFY                                               (0x00000104)
#define NV039_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV039_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV039_SET_CONTEXT_DMA_BUFFER_IN                            (0x00000184)
#define NV039_SET_CONTEXT_DMA_BUFFER_OUT                           (0x00000188)
#define NV039_OFFSET_IN                                            (0x0000030C)
#define NV039_OFFSET_OUT                                           (0x00000310)
#define NV039_PITCH_IN                                             (0x00000314)
#define NV039_PITCH_OUT                                            (0x00000318)
#define NV039_LINE_LENGTH_IN                                       (0x0000031C)
#define NV039_LINE_COUNT                                           (0x00000320)
#define NV039_FORMAT                                               (0x00000324)
#define NV039_FORMAT_IN                                            7:0
#define NV039_FORMAT_OUT                                           31:8
#define NV039_BUFFER_NOTIFY                                        (0x00000328)
#define NV039_BUFFER_NOTIFY_WRITE_ONLY                             (0x00000000)
#define NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN                      (0x00000001)
/* obsolete stuff */
#define NV3_MEMORY_TO_MEMORY_FORMAT                                (0x00000039)
#define Nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv03MemoryToMemoryFormat                       Nv03MemoryToMemoryFormat

typedef NvV32 Nv03aTypedef;

typedef NvV32 Nv03bTypedef;

typedef NvV32 Nv03cTypedef;

/* class NV01_CONTEXT_DMA_IN_MEMORY */
#define  NV01_CONTEXT_DMA_IN_MEMORY                                (0x0000003D)
/* NvNotification[] fields and values */
#define NV03D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03dTypedef, Nv01ContextDmaInMemory;
#define  NV03D_TYPEDEF                                   Nv01ContextDmaInMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_IN_MEMORY                                 (0x0000003D)
#define  Nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv01ContextDmaInMemory                          Nv01ContextDmaInMemory


#define  NV01_MEMORY_SYSTEM                                        (0x0000003E)
/* obsolete stuff */
/* class NV01_CONTEXT_ERROR_TO_MEMORY */
#define   NV01_CONTEXT_ERROR_TO_MEMORY                             (0x0000003E)
/* NvNotification[] fields and values */
#define NV03E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03eTypedef, Nv01ContextErrorToMemory;
#define  NV03E_TYPEDEF                                 Nv01ContextErrorToMemory
#define  NV1_CONTEXT_ERROR_TO_MEMORY                               (0x0000003E)
#define  Nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv01ContextErrorToMemory                      Nv01ContextErrorToMemory


/* class NV01_MEMORY_LOCAL_PRIVILEGED */
#define  NV01_MEMORY_LOCAL_PRIVILEGED                              (0x0000003F)
/* NvNotification[] fields and values */
#define NV03F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03fTypedef, Nv01MemoryLocalPrivileged;
#define NV03F_TYPEDEF                                 Nv01MemoryLocalPrivileged
/* obsolete stuff */
#define NV01_MEMORY_PRIVILEGED                                     (0x0000003F)
#define NV1_MEMORY_PRIVILEGED                                      (0x0000003F)
#define Nv01MemoryPrivileged                          Nv01MemoryLocalPrivileged
#define nv01MemoryPrivileged                          Nv01MemoryLocalPrivileged
#define Nv1MemoryPrivileged                           Nv01MemoryLocalPrivileged
#define nv1MemoryPrivileged                           Nv01MemoryLocalPrivileged
#define nv01MemoryLocalPrivileged                     Nv01MemoryLocalPrivileged


/* class NV01_MEMORY_LOCAL_USER */

/* Class MEMORY_LOCAL_USER refers to framebuffer heap memory that is local to our device
   and accessable to every client.  This is in contrast to MEMORY_SYSTEM, that is 
   considered local to the system CPU, and MEMORY_LOCAL_PRIVILEGED, that refers to
   local instance memory and the local priveledge register space. - Chuck Moidel*/

/* Please note that RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) 
   do VERY different things.  The older RmAllocMemory(NV01_MEMORY_LOCAL_USER) function does 
   not allocate ANY framebuffer memory.  It only allocates and returns a dumb linear mapping
   to the entire framebuffer. RmAlloc(NV01_MEMORY_LOCAL USER) on the other hand allocates blocks
   from the framebuffer heap.  - Chuck Moidel*/

#define  NV01_MEMORY_LOCAL_USER                                    (0x00000040)
/* NvNotification[] fields and values */
#define NV040_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv040Typedef, Nv01MemoryLocalUser;
#define NV040_TYPEDEF                                       Nv01MemoryLocalUser
/* obsolete stuff */
#define NV01_MEMORY_USER                                           (0x00000040)
#define NV1_MEMORY_USER                                            (0x00000040)
#define Nv01MemoryUser                                      Nv01MemoryLocalUser
#define nv01MemoryUser                                      Nv01MemoryLocalUser
#define Nv1MemoryUser                                       Nv01MemoryLocalUser
#define nv1MemoryUser                                       Nv01MemoryLocalUser
#define nv01MemoryLocalUser                                 Nv01MemoryLocalUser


/* class NV03_VIDEO_LUT_CURSOR_PAL */
#define  NV03_VIDEO_LUT_CURSOR_PAL                                 (0x00000041)
/* NvNotification[] elements */
#define NV041_NOTIFIERS_NOTIFY                                     (0)
#define NV041_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV041_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV041_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV041_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV041_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
#define NV041_NOTIFIERS_SET_ENCODER(b)                             (11+(b))
/* NvNotification[] fields and values */
#define NV041_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV041_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV041_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV041_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV041_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV041_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV041_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV041_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV041_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV041_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV041_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01D];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 SetContextDmaCursor;     /* NV01_CONTEXT_DMA                 0190-0193*/
 NvV32 Reserved01[0x05B];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvU32 size;                   /* height_width U16_U16 in pixels      4-   7*/
  NvV32 format;                 /* pitch_color_field_notify            8-   b*/
 } SetImage[2];                 /* end of methods in array              -0317*/
 NvV32 GetImageOffsetNotify[2]; /* NV041_GET_IMAGE_OFFSET_NOTIFY_*  0318-031f*/
 NvV32 SetLut[2];               /* notify_offset V02_U30            0320-0327*/
 NvV32 SetCursorImage[2];       /* notify_offset V02_U30            0328-032f*/
 NvV32 SetCursorPoint[2];       /* notify_y_x V02_S14_S16           0330-0337*/
 NvV32 SetEncoder[2];           /* see text                         0338-033f*/
 NvV32 Reserved02[0x730];
} Nv041Typedef, Nv03VideoLutCursorPal;
#define NV041_TYPEDEF                                     Nv03VideoLutCursorPal
/* dma method offsets, fields, and values */
#define NV041_SET_OBJECT                                           (0x00000000)
#define NV041_NO_OPERATION                                         (0x00000100)
#define NV041_NOTIFY                                               (0x00000104)
#define NV041_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV041_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV041_STOP_TRANSFER                                        (0x00000108)
#define NV041_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV041_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV041_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV041_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV041_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV041_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_SIZE(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV041_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV041_SET_IMAGE_FORMAT(b)                                  (0x00000308\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV041_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV041_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV041_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV041_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV041_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV041_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV041_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV041_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV041_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV041_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV041_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV041_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_LUT(b)                                           (0x00000320\
                                                                   +(b)*0x0004)
#define NV041_SET_LUT_OFFSET                                       29:0
#define NV041_SET_LUT_NOTIFY                                       31:30
#define NV041_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV041_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV041_SET_CURSOR_IMAGE(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV041_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV041_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV041_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_CURSOR_POINT(b)                                  (0x00000330\
                                                                   +(b)*0x0004)
#define NV041_SET_CURSOR_POINT_X                                   15:0
#define NV041_SET_CURSOR_POINT_Y                                   29:16
#define NV041_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV041_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_ENCODER(b)                                       (0x00000338\
                                                                   +(b)*0x0004)
#define NV041_SET_ENCODER_UNDERSCAN_LEFT                           4:0
#define NV041_SET_ENCODER_UNDERSCAN_RIGHT                          9:5
#define NV041_SET_ENCODER_UNDERSCAN_TOP                            14:10
#define NV041_SET_ENCODER_UNDERSCAN_BOTTOM                         19:15
#define NV041_SET_ENCODER_FILTER_HORIZONTAL                        21:20
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_ZOH                    (0x00000000)
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_FOH                    (0x00000001)
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_SOH                    (0x00000002)
#define NV041_SET_ENCODER_FILTER_VERTICAL                          23:22
#define NV041_SET_ENCODER_FILTER_VERTICAL_ZOH                      (0x00000000)
#define NV041_SET_ENCODER_FILTER_VERTICAL_FOH                      (0x00000001)
#define NV041_SET_ENCODER_FILTER_VERTICAL_SOH                      (0x00000002)
#define NV041_SET_ENCODER_VERTICAL_FRONT_PORCH_ADJUST              29:24
#define NV041_SET_ENCODER_REFRESH                                  30:30
#define NV041_SET_ENCODER_REFRESH_INTERLACED                       (0x00000000)
#define NV041_SET_ENCODER_REFRESH_NONINTERLACED                    (0x00000001)
#define NV041_SET_ENCODER_NOTIFY                                   31:31
#define NV041_SET_ENCODER_NOTIFY_WRITE_ONLY                        (0x00000000)
#define NV041_SET_ENCODER_NOTIFY_WRITE_THEN_AWAKEN                 (0x00000001)


/* class NV04_CONTEXT_SURFACES_2D */
#define  NV04_CONTEXT_SURFACES_2D                                  (0x00000042)
/* NvNotification[] elements */
#define NV042_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV042_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV042_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV042_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV042_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV042_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV042_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV042_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImageSource;/* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05d];
 NvV32 SetColorFormat;          /* NV042_SET_COLOR_FORMAT_*         0300-0303*/
 NvU32 SetPitch;                /* destin_source U16_U16            0304-0307*/
 NvU32 SetOffsetSource;         /* byte offset of top-left pixel    0308-030b*/
 NvU32 SetOffsetDestin;         /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved02[0x73c];
} Nv042Typedef, Nv04ContextSurfaces2d;
#define NV042_TYPEDEF                                     Nv04ContextSurfaces2d
/* dma method offsets, fields, and values */
#define NV042_SET_OBJECT                                           (0x00000000)
#define NV042_NO_OPERATION                                         (0x00000100)
#define NV042_NOTIFY                                               (0x00000104)
#define NV042_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV042_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV042_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV042_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV042_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV042_SET_COLOR_FORMAT                                     (0x00000300)
#define NV042_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV042_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV042_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV042_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV042_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV042_SET_PITCH                                            (0x00000304)
#define NV042_SET_PITCH_SOURCE                                     15:0
#define NV042_SET_PITCH_DESTIN                                     31:16
#define NV042_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV042_SET_OFFSET_DESTIN                                    (0x0000030C)
/* obsolete stuff */
#define NV4_CONTEXT_SURFACES_2D                                    (0x00000042)
#define Nv4ContextSurfaces2d                              Nv04ContextSurfaces2d
#define nv4ContextSurfaces2d                              Nv04ContextSurfaces2d
#define nv4ContextSurfaces2D                              Nv04ContextSurfaces2d
#define nv04ContextSurfaces2d                             Nv04ContextSurfaces2d


/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                          (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV043_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetRop5;                 /* 32-bit ROP5                      0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define NV043_TYPEDEF                                            Nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)
/* obsolete stuff */
#define NV3_CONTEXT_ROP                                            (0x00000043)
#define Nv3ContextRop                                            Nv03ContextRop
#define nv3ContextRop                                            Nv03ContextRop
#define nv03ContextRop                                           Nv03ContextRop


/* class NV04_CONTEXT_PATTERN */
#define  NV04_CONTEXT_PATTERN                                      (0x00000044)
/* NvNotification[] elements */
#define NV044_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV044_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV044_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV044_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV044_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV044_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV044_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV044_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV044_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV044_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 SetMonochromeShape;      /* NV044_SET_MONOCHROME_SHAPE_*     0308-030b*/
 NvV32 SetPatternSelect;        /* NV044_SET_PATTERN_SELECT_*       030c-030f*/
 NvV32 SetMonochromeColor0;     /* color of 0 pixels                0310-0313*/
 NvV32 SetMonochromeColor1;     /* color of 1 pixels                0314-0317*/
 NvV32 SetMonochromePattern0;   /* first  32 bits of pattern data   0318-031b*/
 NvV32 SetMonochromePattern1;   /* second 32 bits of pattern data   031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 SetPatternY8[16];        /* y3_y2_y1_y0 U8_U8_U8_U8          0400-043f*/
 NvV32 Reserved03[0x030];
 NvV32 SetPatternR5G6B5[32];    /* see text                         0500-057f*/
 NvV32 Reserved04[0x020];
 NvV32 SetPatternX1R5G5B5[32];  /* see text                         0600-067f*/
 NvV32 Reserved05[0x020];
 NvV32 SetPatternX8R8G8B8[64];  /* ignore_red_green_blu U8_U8_U8_U8 0700-07ff*/
 NvV32 Reserved06[0x600];
} Nv044Typedef, Nv04ContextPattern;
#define NV044_TYPEDEF                                          Nv04ContextPattern
/* dma method offsets, fields, and values */
#define NV044_SET_OBJECT                                           (0x00000000)
#define NV044_NO_OPERATION                                         (0x00000100)
#define NV044_NOTIFY                                               (0x00000104)
#define NV044_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV044_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV044_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV044_SET_COLOR_FORMAT                                     (0x00000300)
#define NV044_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV044_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV044_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV044_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV044_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV044_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV044_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV044_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV044_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV044_SET_PATTERN_SELECT                                   (0x0000030C)
#define NV044_SET_PATTERN_SELECT_MONOCHROME                        (0x00000001)
#define NV044_SET_PATTERN_SELECT_COLOR                             (0x00000002)
#define NV044_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHORME_PATTERN1                              (0x0000031C)

#define NV044_SET_MONOCHROME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHROME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHROME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHROME_PATTERN1                              (0x0000031C)

#define NV044_SET_PATTERN_Y8(i)                                    (0x00000400\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_Y8_Y0                                    7:0
#define NV044_SET_PATTERN_Y8_Y1                                    15:8
#define NV044_SET_PATTERN_Y8_Y2                                    23:16
#define NV044_SET_PATTERN_Y8_Y3                                    31:24
#define NV044_SET_PATTERN_R5G6B5(i)                                (0x00000500\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_R5G6B5_BLUE0                             4:0
#define NV044_SET_PATTERN_R5G6B5_GREEN0                            10:5
#define NV044_SET_PATTERN_R5G6B5_RED0                              15:11
#define NV044_SET_PATTERN_R5G6B5_BLUE1                             20:16
#define NV044_SET_PATTERN_R5G6B5_GREEN1                            26:21
#define NV044_SET_PATTERN_R5G6B5_RED1                              31:27
#define NV044_SET_PATTERN_X1R5G5B5(i)                              (0x00000600\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X1R5G5B5_BLUE0                           4:0
#define NV044_SET_PATTERN_X1R5G5B5_GREEN0                          9:5
#define NV044_SET_PATTERN_X1R5G5B5_RED0                            14:10
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE0                         15:15
#define NV044_SET_PATTERN_X1R5G5B5_BLUE1                           20:16
#define NV044_SET_PATTERN_X1R5G5B5_GREEN1                          25:21
#define NV044_SET_PATTERN_X1R5G5B5_RED1                            30:26
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE1                         31:31
#define NV044_SET_PATTERN_X8R8G8B8(i)                              (0x00000700\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X8R8G8B8_BLUE                            7:0
#define NV044_SET_PATTERN_X8R8G8B8_GREEN                           15:8
#define NV044_SET_PATTERN_X8R8G8B8_RED                             23:16
#define NV044_SET_PATTERN_X8R8G8B8_IGNORE                          31:24
/* obsolete stuff */
#define NV4_CONTEXT_PATTERN                                        (0x00000044)
#define Nv04ImagePattern                                     Nv04ContextPattern
#define Nv4ImagePattern                                      Nv04ContextPattern
#define nv4ImagePattern                                      Nv04ContextPattern
#define Nv4ContextPattern                                    Nv04ContextPattern
#define nv4ContextPattern                                    Nv04ContextPattern
#define nv04ContextPattern                                   Nv04ContextPattern


/* class NV03_VIDEO_LUT_CURSOR_NTSC */
#define  NV03_VIDEO_LUT_CURSOR_NTSC                                (0x00000045)
/* NvNotification[] elements */
#define NV045_NOTIFIERS_NOTIFY                                     (0)
#define NV045_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV045_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV045_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV045_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV045_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
#define NV045_NOTIFIERS_SET_ENCODER(b)                             (11+(b))
/* NvNotification[] fields and values */
#define NV045_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV045_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV045_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV045_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV045_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV045_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV045_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV045_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV045_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV045_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV045_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01D];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 SetContextDmaCursor;     /* NV01_CONTEXT_DMA                 0190-0193*/
 NvV32 Reserved01[0x05B];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvU32 size;                   /* height_width U16_U16 in pixels      4-   7*/
  NvV32 format;                 /* pitch_color_field_notify            8-   b*/
 } SetImage[2];                 /* end of methods in array              -0317*/
 NvV32 GetImageOffsetNotify[2]; /* NV045_GET_IMAGE_OFFSET_NOTIFY_*  0318-031f*/
 NvV32 SetLut[2];               /* notify_offset V02_U30            0320-0327*/
 NvV32 SetCursorImage[2];       /* notify_offset V02_U30            0328-032f*/
 NvV32 SetCursorPoint[2];       /* notify_y_x V02_S14_S16           0330-0337*/
 NvV32 SetEncoder[2];           /* see text                         0338-033f*/
 NvV32 Reserved02[0x730];
} Nv045Typedef, Nv03VideoLutCursorNtsc;
#define NV045_TYPEDEF                                    Nv03VideoLutCursorNtsc
/* dma method offsets, fields, and values */
#define NV045_SET_OBJECT                                           (0x00000000)
#define NV045_NO_OPERATION                                         (0x00000100)
#define NV045_NOTIFY                                               (0x00000104)
#define NV045_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV045_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV045_STOP_TRANSFER                                        (0x00000108)
#define NV045_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV045_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV045_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV045_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV045_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV045_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_SIZE(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV045_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV045_SET_IMAGE_FORMAT(b)                                  (0x00000308\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV045_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV045_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV045_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV045_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV045_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV045_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV045_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV045_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV045_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV045_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV045_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV045_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_LUT(b)                                           (0x00000320\
                                                                   +(b)*0x0004)
#define NV045_SET_LUT_OFFSET                                       29:0
#define NV045_SET_LUT_NOTIFY                                       31:30
#define NV045_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV045_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV045_SET_CURSOR_IMAGE(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV045_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV045_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV045_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_CURSOR_POINT(b)                                  (0x00000330\
                                                                   +(b)*0x0004)
#define NV045_SET_CURSOR_POINT_X                                   15:0
#define NV045_SET_CURSOR_POINT_Y                                   29:16
#define NV045_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV045_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_ENCODER(b)                                       (0x00000338\
                                                                   +(b)*0x0004)
#define NV045_SET_ENCODER_UNDERSCAN_LEFT                           4:0
#define NV045_SET_ENCODER_UNDERSCAN_RIGHT                          9:5
#define NV045_SET_ENCODER_UNDERSCAN_TOP                            14:10
#define NV045_SET_ENCODER_UNDERSCAN_BOTTOM                         19:15
#define NV045_SET_ENCODER_FILTER_HORIZONTAL                        21:20
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_ZOH                    (0x00000000)
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_FOH                    (0x00000001)
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_SOH                    (0x00000002)
#define NV045_SET_ENCODER_FILTER_VERTICAL                          23:22
#define NV045_SET_ENCODER_VERTICAL_FRONT_PORCH_ADJUST              29:24
#define NV045_SET_ENCODER_FILTER_VERTICAL_ZOH                      (0x00000000)
#define NV045_SET_ENCODER_FILTER_VERTICAL_FOH                      (0x00000001)
#define NV045_SET_ENCODER_FILTER_VERTICAL_SOH                      (0x00000002)
#define NV045_SET_ENCODER_REFRESH                                  30:30
#define NV045_SET_ENCODER_REFRESH_INTERLACED                       (0x00000000)
#define NV045_SET_ENCODER_REFRESH_NONINTERLACED                    (0x00000001)
#define NV045_SET_ENCODER_NOTIFY                                   31:31
#define NV045_SET_ENCODER_NOTIFY_WRITE_ONLY                        (0x00000000)
#define NV045_SET_ENCODER_NOTIFY_WRITE_THEN_AWAKEN                 (0x00000001)


/* class NV04_VIDEO_LUT_CURSOR_DAC */
#define  NV04_VIDEO_LUT_CURSOR_DAC                                 (0x00000046)
/* NvNotification[] elements */
#define NV046_NOTIFIERS_NOTIFY                                     (0)
#define NV046_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV046_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV046_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV046_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV046_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV046_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV046_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV046_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV046_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV046_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV046_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV046_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV046_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV046_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV046_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV046_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_pitch V1_U16_U16             4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv046Typedef, Nv04VideoLutCursorDac;
#define NV046_TYPEDEF                                     Nv04VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV046_SET_OBJECT                                           (0x00000000)
#define NV046_NO_OPERATION                                         (0x00000100)
#define NV046_NOTIFY                                               (0x00000104)
#define NV046_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV046_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV046_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV046_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV046_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV046_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV046_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV046_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV046_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV046_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV046_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV046_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV046_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV046_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV046_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV046_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV046_SET_PAN_OFFSET                                       (0x00000220)
#define NV046_GET_OFFSET                                           (0x000002FC)
#define NV046_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV046_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV046_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV046_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV046_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV046_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV046_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV046_SET_CURSOR_POINT                                     (0x00000330)
#define NV046_SET_CURSOR_POINT_X                                   15:0
#define NV046_SET_CURSOR_POINT_Y                                   31:16
#define NV046_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV046_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV046_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV046_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV046_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV046_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV046_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV046_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV046_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV046_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV046_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV046_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV046_SET_DAC_FORMAT_COLOR                                 19:16
#define NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV046_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV046_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV046_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV046_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV046_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


/* class NV04_VIDEO_OVERLAY */
#define  NV04_VIDEO_OVERLAY                                        (0x00000047)
/* NvNotification[] elements */
#define NV047_NOTIFIERS_NOTIFY                                     (0)
#define NV047_NOTIFIERS_SET_OVERLAY(b)                             (1+(b))
/* NvNotification[] fields and values */
#define NV047_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV047_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV047_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV047_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV047_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV047_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV047_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV047_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 StopOverlay[2];          /* NV047_STOP_OVERLAY_*             0120-0127*/
 NvV32 Reserved01[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved02[0x006];
 NvV32 SetContextDmaOverlay[2]; /* NV01_CONTEXT_DMA                 019c-01a3*/
 NvV32 Reserved03[0x056];
 NvV32 GetOffset;               /* NV047_GET_OFFSET_*               02FC-02FF*/
 NvV32 Reserved04[0x040];
 struct {                       /* start of methods in array        0400-    */
  NvV32 reserved05[0x017];      /* see text                           00-  5b*/
  NvV32 colorKey;               /* see text                           5c-  5f*/
  NvU32 offset;                 /* byte offset of top-left texel      60-  63*/
  NvV32 sizeIn;                 /* height_width U16_U16               64-  67*/
  NvV32 pointIn;                /* t_s U12d4_U12d4                    68-  6b*/
  NvV32 dsDx;                   /* U12d20 ds/dx                       6c-  6f*/
  NvV32 dtDy;                   /* U12d20 dt/dy                       70-  73*/
  NvV32 pointOut;               /* y_x U16_U16                        74-  77*/
  NvV32 sizeOut;                /* height_width U16_U16               78-  7b*/
  NvV32 format;                 /* format_display_color_pitch         7c-  7f*/
 } SetOverlay[2];               /* end of methods in array              -04ff*/
 NvV32 SetOverlayPointOutA;     /* y_x U16_U16                      0500-0503*/
 NvV32 Reserved06[0x6bf];
} Nv047Typedef, Nv04VideoOverlay;
#define NV047_TYPEDEF                                          Nv04VideoOverlay
/* dma method offsets, fields, and values */
#define NV047_SET_OBJECT                                           (0x00000000)
#define NV047_NO_OPERATION                                         (0x00000100)
#define NV047_NOTIFY                                               (0x00000104)
#define NV047_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV047_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV047_STOP_OVERLAY(b)                                      (0x00000120\
                                                                   +(b)*0x0004)
#define NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE                     (0x00000000)
#define NV047_STOP_OVERLAY_BETWEEN_BUFFERS                         (0x00000001)
#define NV047_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV047_SET_CONTEXT_DMA_OVERLAY(b)                           (0x0000019C\
                                                                   +(b)*0x0004)
#define NV047_SET_OVERLAY(b)                                       (0x00000400\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_COLORKEY(b)                              (0x0000045C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_OFFSET(b)                                (0x00000460\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_IN(b)                               (0x00000464\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_IN_WIDTH                            15:0
#define NV047_SET_OVERLAY_SIZE_IN_HEIGHT                           31:16
#define NV047_SET_OVERLAY_POINT_IN(b)                              (0x00000468\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_IN_S                               15:0
#define NV047_SET_OVERLAY_POINT_IN_T                               31:16
#define NV047_SET_OVERLAY_DS_DX(b)                                 (0x0000046C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_DT_DY(b)                                 (0x00000470\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_OUT(b)                             (0x00000474\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_OUT_X                              15:0
#define NV047_SET_OVERLAY_POINT_OUT_Y                              31:16
#define NV047_SET_OVERLAY_SIZE_OUT(b)                              (0x00000478\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_OUT_WIDTH                           15:0
#define NV047_SET_OVERLAY_SIZE_OUT_HEIGHT                          31:16
#define NV047_SET_OVERLAY_FORMAT(b)                                (0x0000047C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_FORMAT_PITCH                             15:0
#define NV047_SET_OVERLAY_FORMAT_COLOR                             19:16
#define NV047_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8             (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8             (0x00000001)
#define NV047_SET_OVERLAY_FORMAT_DISPLAY                           30:20
#define NV047_SET_OVERLAY_FORMAT_DISPLAY_ALWAYS                    (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_DISPLAY_COLOR_KEY_EQUAL           (0x00000001)
#define NV047_SET_OVERLAY_FORMAT_NOTIFY                            31:31
#define NV047_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY                 (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_NOTIFY_WRITE_THEN_AWAKEN          (0x00000001)
#define NV047_SET_OVERLAY_POINT_OUT_A                              (0x00000500)
#define NV047_SET_OVERLAY_POINT_OUT_A_X                            15:0
#define NV047_SET_OVERLAY_POINT_OUT_A_Y                            31:16

/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                                (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV048_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaTexture;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextSurfaceColor;  /* NV03_CONTEXT_SURFACE_3D_COLOR    018c-018f*/
 NvV32 SetContextSurfaceZeta;   /* NV03_CONTEXT_SURFACE_3D_DEPTH    0190-0193*/
 NvV32 Reserved01[0x05c];
 NvU32 TextureOffset;           /* offset in bytes                  0304-0307*/
 NvV32 TextureFormat;           /* see text                         0308-030b*/
 NvV32 TextureFilter;           /* ignre_sizeAdjust_spreadY_spreadX 030c-030f*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0310-0313*/
 NvV32 Control0;                /* see text                         0314-0317*/
 NvV32 Control1;                /* alphafunc_alpharef V24_U8        0318-031b*/
 NvV32 Reserved02[0x339];
 struct {                       /* start of method in array         1000-    */
  NvV32 specular;               /* fog_i5-i0 U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  NvV32 color;                  /* X8R8G8B8 or A8R8G8B8               04-  07*/
  NvF32 sx;                     /* screen x coordinate                08-  0b*/
  NvF32 sy;                     /* screen y coordinate                0c-  0f*/
  NvF32 sz;                     /* screen z coordinate                10-  13*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[128];               /* end of method in array               -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define NV048_TYPEDEF                                   Nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)

#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)
/* obsolete stuff */
#define NV3_DX3_TEXTURED_TRIANGLE                                  (0x00000048)
#define Nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv03Dx3TexturedTriangle                         Nv03Dx3TexturedTriangle

/* class NV05_VIDEO_LUT_CURSOR_DAC */
#define  NV05_VIDEO_LUT_CURSOR_DAC                                 (0x00000049)
#define NV049_NOTIFIERS_NOTIFY                                     (0)
#define NV049_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV049_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV049_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV049_NOTIFIERS_SET_DAC(b)                                 (7+(b))
#define NV049_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV049_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV049_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV049_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV049_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV049_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV049_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV049_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV049_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV049_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV049_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV049_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       4-   7*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels       8-   b*/
  NvV32 totalSize;              /* height_width U16_U16                c-   f*/
  NvV32 pixelClock;             /* in Hertz                           10-  13*/
  NvV32 format;                 /* see text                           14-  17*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x724];
} Nv049Typedef, NV05VideoLutCursorDac;
#define NV049_TYPEDEF                                     NV05VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV049_SET_OBJECT                                           (0x00000000)
#define NV049_NO_OPERATION                                         (0x00000100)
#define NV049_NOTIFY                                               (0x00000104)
#define NV049_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV049_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV049_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV049_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV049_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV049_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV049_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV049_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV049_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV049_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV049_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV049_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV049_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV049_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV049_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV049_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV049_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV049_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV049_SET_PAN_OFFSET                                       (0x00000220)
#define NV049_GET_OFFSET                                           (0x000002FC)
#define NV049_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV049_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV049_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV049_SET_IMAGE_FORMAT_WHEN                                30:20
#define NV049_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)
#define NV049_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV049_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV049_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV049_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV049_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV049_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV049_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV049_SET_CURSOR_POINT                                     (0x00000330)
#define NV049_SET_CURSOR_POINT_X                                   15:0
#define NV049_SET_CURSOR_POINT_Y                                   31:16
#define NV049_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV049_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV049_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000344\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV049_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV049_SET_DAC_VERTICAL_SYNC(b)                             (0x00000348\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV049_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV049_SET_DAC_TOTAL_SIZE(b)                                (0x0000034C\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV049_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV049_SET_DAC_PIXEL_CLOCK(b)                               (0x00000350\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_FORMAT(b)                                    (0x00000354\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV049_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV049_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV049_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV049_SET_DAC_FORMAT_COLOR                                 19:16
#define NV049_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV049_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV049_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV049_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV049_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV049_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV049_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV049_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV049_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


/* class NV04_GDI_RECTANGLE_TEXT */
#define  NV04_GDI_RECTANGLE_TEXT                                   (0x0000004A)
/* NvNotification[] elements */
#define NV04A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* memory data structures */
typedef struct {                /* start of data structure          0000-    */
   NvV32 size;                  /* height_width U16_U16 in pixels      0-   3*/
   NvV32 monochrome[1];         /* 32 monochrome pixels per write      4-   7*/
} Nv04aCharacter8[];            /* end of data structure                -0007*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels      0-   3*/
  NvV32 monochrome[3];          /* 32 monochrome pixels per write      4-   f*/
} Nv04aCharacter16[];           /* end of data structure                -000f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[7];          /* 32 monochrome pixels per write     04-  1f*/
} Nv04aCharacter32[];           /* end of data structure                -001f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[15];         /* 32 monochrome pixels per write     04-  3f*/
} Nv04aCharacter64[];           /* end of data structure                -003f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[31];         /* 32 monochrome pixels per write     04-  7f*/
} Nv04aCharacter128[];          /* end of data structure                -007f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[63];         /* 32 monochrome pixels per write     04-  ff*/
} Nv04aCharacter256[];          /* end of data structure                -00ff*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels    000- 003*/
  NvV32 monochrome[127];        /* 32 monochrome pixels per write    004- 1ff*/
} Nv04aCharacter512[];          /* end of data structure                -01ff*/
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaFonts;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV04A_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV04A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV04A_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 Reserved02[0x03D];
 NvV32 Color1A;                 /* rectangle color                  03fc-03ff*/
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* x_y S16_S16 in pixels               0-   3*/
  NvV32 size;                   /* width_height U16_U16 in pixels      4-   7*/
 } UnclippedRectangle[32];      /* end of aliased methods in array      -04ff*/
 NvV32 Reserved03[0x03D];
 NvV32 ClipPoint0B;             /* top_left S16_S16 in pixels       05f4-05f7*/
 NvV32 ClipPoint1B;             /* bottom_right S16_S16 in pixels   05f8-05fb*/
 NvV32 Color1B;                 /* rectangle color                  05fc-05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 point0;                 /* top_left S16_S16 in pixels          0-   3*/
  NvV32 point1;                 /* bottom_right S16_S16 in pixels      4-   7*/
 } ClippedRectangle[32];        /* end of aliased methods in array      -06ff*/
 NvV32 Reserved04[0x03B];
 NvV32 ClipPoint0C;             /* top_left S16_S16 in pixels       07ec-07ef*/
 NvV32 ClipPoint1C;             /* bottom_right S16_S16 in pixe     07f0-07f3*/
 NvV32 Color1C;                 /* color of 1 pixels                07f4-07f7*/
 NvV32 SizeC;                   /* height_width U16_U16 in pixels   07f8-07fb*/
 NvV32 PointC;                  /* y_x S16_S16 in pixels            07fc-07ff*/
 NvV32 MonochromeColor1C[128];  /* 32 monochrome pixels per write   0800-09ff*/
 NvV32 Reserved05[0x079];
 NvV32 ClipPoint0E;             /* top_left S16_S16 in pixels       0be4-0be7*/
 NvV32 ClipPoint1E;             /* bottom_right S16_S16 in pixels   0be8-0beb*/
 NvV32 Color0E;                 /* color of 0 pixels                0bec-0bef*/
 NvV32 Color1E;                 /* color of 1 pixels                0bf0-0bf3*/
 NvV32 SizeInE;                 /* height_width U16_U16 in pixels   0bf4-0bf7*/
 NvV32 SizeOutE;                /* height_width U16_U16 in pixels   0bf8-0bfb*/
 NvV32 PointE;                  /* y_x S16_S16 in pixels            0bfc-0bff*/
 NvV32 MonochromeColor01E[128]; /* 32 monochrome pixels per write   0c00-0dff*/
 NvV32 Reserved06[0x07C];
 NvV32 FontF;                   /* pitch_offset V4_U28              0ff0-0ff3*/
 NvV32 ClipPoint0F;             /* top_left S16_S16 in pixels       0ff4-0ff7*/
 NvV32 ClipPoint1F;             /* bottom_right S16_S16 in pixels   0ff8-0ffb*/
 NvV32 Color1F;                 /* color of 1 pixels                0ffc-0fff*/
 NvV32 CharacterColor1F[256];   /* y_x_index S12_S12_U8             1000-13ff*/
 NvV32 Reserved07[0x0FC];
 NvV32 FontG;                   /* pitch_offset V4_U28              17f0-17f3*/
 NvV32 ClipPoint0G;             /* top_left S16_S16 in pixels       17f4-17f7*/
 NvV32 ClipPoint1G;             /* bottom_right S16_S16 in pixels   17f8-17fb*/
 NvV32 Color1G;                 /* color of 1 pixels                17fc-17ff*/
 struct {                       /* start aliased methods in array   1800-    */
  NvV32 point;                  /* y_x S16_S16 in pixels               0-   3*/
  NvU32 index;                  /* 0<=index<=65525                     4-   7*/
 } CharacterColor1G[256];       /* end of aliased methods in array      -1fff*/
} Nv04aTypedef, Nv04GdiRectangleText;
#define NV04A_TYPEDEF                                      Nv04GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04A_SET_OBJECT                                           (0x00000000)
#define NV04A_NO_OPERATION                                         (0x00000100)
#define NV04A_NOTIFY                                               (0x00000104)
#define NV04A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04A_SET_CONTEXT_DMA_FONTS                                (0x00000184)
#define NV04A_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV04A_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV04A_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV04A_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV04A_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV04A_SET_OPERATION                                        (0x000002FC)
#define NV04A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV04A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV04A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV04A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04A_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04A_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04A_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04A_COLOR1_A                                             (0x000003FC)
#define NV04A_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT_Y                          15:0
#define NV04A_UNCLIPPED_RECTANGLE_POINT_X                          31:16
#define NV04A_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      15:0
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       31:16
#define NV04A_CLIP_POINT0_B                                        (0x000005F4)
#define NV04A_CLIP_POINT0_B_LEFT                                   15:0
#define NV04A_CLIP_POINT0_B_TOP                                    31:16
#define NV04A_CLIP_POINT1_B                                        (0x000005F8)
#define NV04A_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04A_COLOR1_B                                             (0x000005FC)
#define NV04A_CLIPPED_RECTANGLE(a)                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0(a)                         (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0_LEFT                       15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_0_TOP                        31:16
#define NV04A_CLIPPED_RECTANGLE_POINT_1(a)                         (0x00000604\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_1_RIGHT                      15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM                     31:16
#define NV04A_CLIP_POINT0_C                                        (0x000007EC)
#define NV04A_CLIP_POINT0_C_LEFT                                   15:0
#define NV04A_CLIP_POINT0_C_TOP                                    31:16
#define NV04A_CLIP_POINT1_C                                        (0x000007F0)
#define NV04A_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04A_COLOR1_C                                             (0x000007F4)
#define NV04A_SIZE_C                                               (0x000007F8)
#define NV04A_SIZE_C_WIDTH                                         15:0
#define NV04A_SIZE_C_HEIGHT                                        31:16
#define NV04A_POINT_C                                              (0x000007FC)
#define NV04A_POINT_C_X                                            15:0
#define NV04A_POINT_C_Y                                            31:16
#define NV04A_MONOCHROME_COLOR1_C(a)                               (0x00000800\
                                                                   +(a)*0x0004)
#define NV04A_CLIP_POINT0_E                                        (0x00000BE4)
#define NV04A_CLIP_POINT0_E_LEFT                                   15:0
#define NV04A_CLIP_POINT0_E_TOP                                    31:16
#define NV04A_CLIP_POINT1_E                                        (0x00000BE8)
#define NV04A_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04A_COLOR0_E                                             (0x00000BEC)
#define NV04A_COLOR1_E                                             (0x00000BF0)
#define NV04A_SIZE_IN_E                                            (0x00000BF4)
#define NV04A_SIZE_IN_E_WIDTH                                      15:0
#define NV04A_SIZE_IN_E_HEIGHT                                     31:16
#define NV04A_SIZE_OUT_E                                           (0x00000BF8)
#define NV04A_SIZE_OUT_E_WIDTH                                     15:0
#define NV04A_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04A_POINT_E                                              (0x00000BFC)
#define NV04A_POINT_E_X                                            15:0
#define NV04A_POINT_E_Y                                            31:16
#define NV04A_MONOCHROME_COLOR01_E(a)                              (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04A_FONT_F                                               (0x00000FF0)
#define NV04A_FONT_F_OFFSET                                        27:0
#define NV04A_FONT_F_PITCH                                         31:28
#define NV04A_FONT_F_PITCH_8                                       (0x00000003)
#define NV04A_FONT_F_PITCH_16                                      (0x00000004)
#define NV04A_FONT_F_PITCH_32                                      (0x00000005)
#define NV04A_FONT_F_PITCH_64                                      (0x00000006)
#define NV04A_FONT_F_PITCH_128                                     (0x00000007)
#define NV04A_FONT_F_PITCH_256                                     (0x00000008)
#define NV04A_FONT_F_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_F                                        (0x00000FF4)
#define NV04A_CLIP_POINT0_F_LEFT                                   15:0
#define NV04A_CLIP_POINT0_F_TOP                                    31:16
#define NV04A_CLIP_POINT1_F                                        (0x00000FF8)
#define NV04A_CLIP_POINT1_F_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_F_BOTTOM                                 31:16
#define NV04A_COLOR1_F                                             (0x00000FFC)
#define NV04A_CHARACTER_COLOR1_F(a)                                (0x00001000\
                                                                   +(a)*0x0004)
#define NV04A_CHARACTER_COLOR1_F_INDEX                             7:0
#define NV04A_CHARACTER_COLOR1_F_X                                 19:8
#define NV04A_CHARACTER_COLOR1_F_Y                                 31:20
#define NV04A_FONT_G                                               (0x000017F0)
#define NV04A_FONT_G_OFFSET                                        27:0
#define NV04A_FONT_G_PITCH                                         31:28
#define NV04A_FONT_G_PITCH_8                                       (0x00000003)
#define NV04A_FONT_G_PITCH_16                                      (0x00000004)
#define NV04A_FONT_G_PITCH_32                                      (0x00000005)
#define NV04A_FONT_G_PITCH_64                                      (0x00000006)
#define NV04A_FONT_G_PITCH_128                                     (0x00000007)
#define NV04A_FONT_G_PITCH_256                                     (0x00000008)
#define NV04A_FONT_G_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_G                                        (0x000017F4)
#define NV04A_CLIP_POINT0_G_LEFT                                   15:0
#define NV04A_CLIP_POINT0_G_TOP                                    31:16
#define NV04A_CLIP_POINT1_G                                        (0x000017F8)
#define NV04A_CLIP_POINT1_G_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_G_BOTTOM                                 31:16
#define NV04A_COLOR1_G                                             (0x000017FC)
#define NV04A_CHARACTER_COLOR1_G(a)                                (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT(a)                          (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT_X                           15:0
#define NV04A_CHARACTER_COLOR1_G_POINT_Y                           31:16
#define NV04A_CHARACTER_COLOR1_G_INDEX(a)                          (0x00001804\
                                                                   +(a)*0x0008)
/* obsolete stuff */
#define NV4_GDI_RECTANGLE_TEXT                                     (0x0000004A)
#define Nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv04GdiRectangleText                               Nv04GdiRectangleText


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                                   (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04B_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0184-0187*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0188-018b*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                018c-018f*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0190-0193*/
 NvV32 Reserved01[0x05a];
 NvV32 SetOperation;            /* NV04B_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 Reserved02[0x03d];
 NvV32 Color1A;                 /* rectangle color                  03fc-03ff*/
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* x_y S16_S16 in pixels               0-   3*/
  NvV32 size;                   /* width_height U16_U16 in pixels      4-   7*/
 } UnclippedRectangle[64];      /* end of aliased methods in array      -05ff*/
 NvV32 Reserved03[0x07D];
 NvV32 ClipPoint0B;             /* top_left S16_S16 in pixels       07f4-07f7*/
 NvV32 ClipPoint1B;             /* bottom_right S16_S16 in pixels   07f8-07fb*/
 NvV32 Color1B;                 /* rectangle color                  07fc-07ff*/
 struct {                       /* start aliased methods in array   0800-    */
  NvV32 point0;                 /* top_left S16_S16 in pixels          0-   3*/
  NvV32 point1;                 /* bottom_right S16_S16 in pixels      4-   7*/
 } ClippedRectangle[64];        /* end of aliased methods in array      -09ff*/
 NvV32 Reserved04[0x07B];
 NvV32 ClipPoint0C;             /* top_left S16_S16 in pixels       0bec-0bef*/
 NvV32 ClipPoint1C;             /* bottom_right S16_S16 in pixels   0bf0-0bf3*/
 NvV32 Color1C;                 /* color of 1 pixels                0bf4-0bf7*/
 NvV32 SizeC;                   /* height_width U16_U16 in pixels   0bf8-0bfb*/
 NvV32 PointC;                  /* y_x S16_S16 in pixels            0bfc-0bff*/
 NvV32 MonochromeColor1C[128];  /* 32 monochrome pixels per write   0c00-0dff*/
 NvV32 Reserved05[0x07A];
 NvV32 ClipPoint0D;             /* top_left S16_S16 in pixels       0fe8-0feb*/
 NvV32 ClipPoint1D;             /* bottom_right S16_S16 in pixels   0fec-0fef*/
 NvV32 Color1D;                 /* color of 1 pixels                0ff0-0ff3*/
 NvV32 SizeInD;                 /* height_width U16_U16 in pixels   0ff4-0ff7*/
 NvV32 SizeOutD;                /* height_width U16_U16 in pixels   0ff8-0ffb*/
 NvV32 PointD;                  /* y_x S16_S16 in pixels            0ffc-0fff*/
 NvV32 MonochromeColor1D[128];  /* 32 monochrome pixels per write   1000-11ff*/
 NvV32 Reserved06[0x079];
 NvV32 ClipPoint0E;             /* top_left S16_S16 in pixels       13e4-13e7*/
 NvV32 ClipPoint1E;             /* bottom_right S16_S16 in pixels   13e8-13eb*/
 NvV32 Color0E;                 /* color of 0 pixels                13ec-13ef*/
 NvV32 Color1E;                 /* color of 1 pixels                13f0-13f3*/
 NvV32 SizeInE;                 /* height_width U16_U16 in pixels   13f4-13f7*/
 NvV32 SizeOutE;                /* height_width U16_U16 in pixels   13f8-13fb*/
 NvV32 PointE;                  /* y_x S16_S16 in pixels            13fc-13ff*/
 NvV32 MonochromeColor01E[128]; /* 32 monochrome pixels per write   1400-15ff*/
 NvV32 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define NV04B_TYPEDEF                                      Nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV3_GDI_RECTANGLE_TEXT                                     (0x0000004B)
#define Nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv03GdiRectangleText                               Nv03GdiRectangleText

typedef NvV32 Nv04cTypedef;


/* class NV03_EXTERNAL_VIDEO_DECODER */
#define  NV03_EXTERNAL_VIDEO_DECODER                               (0x0000004D)
/* NvNotification[] elements */
#define NV04D_NOTIFIERS_NOTIFY                                     (0)
#define NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(b)                   (1+(b))
#define NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(b)                   (3+(b))
#define NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(b)                 (5+(b))
#define NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (7+(b))
/* NvNotification[] fields and values */
#define NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED                (0x0000)
#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)
#define NV04D_NOTIFICATION_INFO16_FIELD_DONE                       (0x0002)
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04D_NOTIFY_*                   0104-0107*/
 NvV32 StopTransferVbi;         /* NV04D_STOP_TRANSFER_VBI_VALUE    0108-010b*/
 NvV32 StopTransferImage;       /* NV04D_STOP_TRANSFER_IMAGE_VALUE  010c-010f*/
 NvV32 Reserved00[0x01c];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaVbi[2];     /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x059];
 NvU32 SetImageConfig;          /* data width, task bit, null data  02f8-02fb*/
 NvU32 SetImageStartLine;       /* lines                            02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvV32 size;                   /* height_firstLine U16_U16            0-   3*/
  NvU32 offset;                 /* byte offset of top-left pixel       4-   7*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        8-   b*/
 } SetVbi[2];                   /* end of methods in array              -0317*/
 NvV32 GetVbiOffsetNotify[2];   /* NV04D_GET_VBI_OFFSET_NOTIFY_*    0318-031f*/
 struct {                       /* start of methods in array        0320-    */
  NvV32 sizeIn;                 /* height_width U16_U16 in pixels      0-   3*/
  NvV32 sizeOut;                /* height_width U16_U16 in pixels      4-   7*/
  NvU32 offset;                 /* byte offset of top-left pixel       8-   b*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        c-   f*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 GetImageOffsetNotify[2]; /* NV04D_GET_IMAGE_OFFSET_NOTIFY_*  0340-0347*/
 NvV32 Reserved02[0x72e];
} Nv04dTypedef, Nv03ExternalVideoDecoder;
#define NV04D_TYPEDEF                                  Nv03ExternalVideoDecoder
/* dma method offsets, fields, and values */
#define NV04D_SET_OBJECT                                           (0x00000000)
#define NV04D_NO_OPERATION                                         (0x00000100)
#define NV04D_NOTIFY                                               (0x00000104)
#define NV04D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04D_STOP_TRANSFER_VBI                                    (0x00000108)
#define NV04D_STOP_TRANSFER_VBI_VALUE                              (0x00000000)
#define NV04D_STOP_TRANSFER_IMAGE                                  (0x0000010C)
#define NV04D_STOP_TRANSFER_IMAGE_VALUE                            (0x00000000)
#define NV04D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04D_SET_CONTEXT_DMA_VBI(b)                               (0x00000184\
                                                                   +(b)*0x0004)
#define NV04D_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04D_SET_IMAGE_CONFIG                                     (0x000002f8)
#define NV04D_SET_IMAGE_CONFIG_DATA_WIDTH                          7:0
#define NV04D_SET_IMAGE_CONFIG_TASK                                8:8
#define NV04D_SET_IMAGE_CONFIG_TASK_A                              (0x00000000)
#define NV04D_SET_IMAGE_CONFIG_TASK_B                              (0x00000001)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA                           13:12
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED                  (0x00000000)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED              (0x00000001)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED              (0x00000002)
#define NV04D_SET_IMAGE_CONFIG_NULL_VALUE                          31:16
#define NV04D_SET_IMAGE_START_LINE                                 (0x000002FC)
#define NV04D_SET_VBI(b)                                           (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE(b)                                      (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE_FIRST_LINE                              15:0
#define NV04D_SET_VBI_SIZE_HEIGHT                                  31:16
#define NV04D_SET_VBI_OFFSET(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT(b)                                    (0x00000308\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT_PITCH                                 15:0
#define NV04D_SET_VBI_FORMAT_FIELD                                 23:16
#define NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD                      (0x00000001)
#define NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD                       (0x00000002)
#define NV04D_SET_VBI_FORMAT_NOTIFY                                31:24
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_GET_VBI_OFFSET_NOTIFY(b)                             (0x00000318\
                                                                   +(b)*0x0004)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_SET_IMAGE(b)                                         (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN(b)                                 (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN_WIDTH                              15:0
#define NV04D_SET_IMAGE_SIZE_IN_HEIGHT                             31:16
#define NV04D_SET_IMAGE_SIZE_OUT(b)                                (0x00000324\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_OUT_WIDTH                             15:0
#define NV04D_SET_IMAGE_SIZE_OUT_HEIGHT                            31:16
#define NV04D_SET_IMAGE_OFFSET(b)                                  (0x00000328\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT(b)                                  (0x0000032C\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV04D_SET_IMAGE_FORMAT_FIELD                               23:16
#define NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY                              31:24
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000340\
                                                                   +(b)*0x0004)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecoder                        Nv03ExternalVideoDecoder
#define nv3ExternalVideoDecoder                        Nv03ExternalVideoDecoder
#define nv03ExternalVideoDecoder                       Nv03ExternalVideoDecoder


/* class NV03_EXTERNAL_VIDEO_DECOMPRESSOR */
#define  NV03_EXTERNAL_VIDEO_DECOMPRESSOR                          (0x0000004E)
/* NvNotification[] elements */
#define NV04E_NOTIFIERS_NOTIFY                                     (0)
#define NV04E_NOTIFIERS_SET_DATA_NOTIFY(b)                         (1+(b))
#define NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(b)                        (3+(b))
/* NvNotification[] fields and values */
#define NV04E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04E_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04E_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04E_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaData[2];    /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05b];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* in bytes                            0-   3*/
  NvU32 length;                 /* in bytes                            4-   7*/
  NvV32 notify;                 /* NV04E_SET_DATA_NOTIFY_*             8-   b*/
 } SetData[2];                  /* end of methods in array              -0317*/
 struct {                       /* start of methods in array        0318-    */
  NvV32 formatIn;               /* zero_field V16_V16                 00-  03*/
  NvV32 size;                   /* height_width U16_U16 in pixels     04-  07*/
  NvU32 offsetOut;              /* byte offset of top-left pixel      08-  0b*/
  NvV32 formatOut;              /* ignore_pitch V16_U16               0c-  0f*/
  NvV32 notify;                 /* NV04E_SET_IMAGE_NOTIFY_*           10-  13*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 Reserved02[0x730];
} Nv04eTypedef, Nv03ExternalVideoDecompressor;
#define NV04E_TYPEDEF                             Nv03ExternalVideoDecompressor
/* dma method offsets, fields, and values */
#define NV04E_SET_OBJECT                                           (0x00000000)
#define NV04E_NO_OPERATION                                         (0x00000100)
#define NV04E_NOTIFY                                               (0x00000104)
#define NV04E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04E_STOP_TRANSFER                                        (0x00000108)
#define NV04E_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04E_SET_CONTEXT_DMA_DATA(b)                              (0x00000184\
                                                                   +(b)*0x0004)
#define NV04E_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04E_SET_DATA(b)                                          (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_OFFSET(b)                                   (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_LENGTH(b)                                   (0x00000304\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY(b)                                   (0x00000308\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY_WRITE_ONLY                           (0x00000000)
#define NV04E_SET_DATA_NOTIFY_WRITE_THEN_AWAKEN                    (0x00000001)
#define NV04E_SET_IMAGE(b)                                         (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN(b)                               (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD                            15:0
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_PROGRESSIVE                (0x00000001)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_EVEN_FIELD                 (0x00000002)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_ODD_FIELD                  (0x00000003)
#define NV04E_SET_IMAGE_FORMAT_IN_ZERO                             31:16
#define NV04E_SET_IMAGE_SIZE(b)                                    (0x0000031C\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV04E_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV04E_SET_IMAGE_OFFSET_OUT(b)                              (0x00000320\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT(b)                              (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT_PITCH                           15:0
#define NV04E_SET_IMAGE_FORMAT_OUT_IGNORE                          31:16
#define NV04E_SET_IMAGE_NOTIFY(b)                                  (0x00000328\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv03ExternalVideoDecompressor             Nv03ExternalVideoDecompressor


/* class NV01_EXTERNAL_PARALLEL_BUS */
#define  NV01_EXTERNAL_PARALLEL_BUS                                (0x0000004F)
/* NvNotification[] elements */
#define NV04F_NOTIFIERS_NOTIFY                                     (0)
#define NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV04F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04F_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04F_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04F_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV04F_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV04F_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv04fTypedef, Nv01ExternalParallelBus;
#define NV04F_TYPEDEF                                   Nv01ExternalParallelBus
/* dma method offsets, fields, and values */
#define NV04F_SET_OBJECT                                           (0x00000000)
#define NV04F_NO_OPERATION                                         (0x00000100)
#define NV04F_NOTIFY                                               (0x00000104)
#define NV04F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04F_STOP_TRANSFER                                        (0x00000108)
#define NV04F_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04F_WRITE                                                (0x00000300)
#define NV04F_WRITE_SIZE                                           (0x00000300)
#define NV04F_WRITE_SIZE_DATA                                      15:0
#define NV04F_WRITE_SIZE_ADDRESS                                   31:16
#define NV04F_WRITE_ADDRESS                                        (0x00000304)
#define NV04F_WRITE_DATA                                           (0x00000308)
#define NV04F_READ                                                 (0x0000030C)
#define NV04F_READ_SIZE                                            (0x0000030C)
#define NV04F_READ_SIZE_DATA                                       15:0
#define NV04F_READ_SIZE_ADDRESS                                    31:16
#define NV04F_READ_ADDRESS                                         (0x00000310)
#define NV04F_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV04F_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV1_EXTERNAL_PARALLEL_BUS                                  (0x0000004F)
#define Nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv01ExternalParallelBus                         Nv01ExternalParallelBus


/* class NV03_EXTERNAL_MONITOR_BUS */
#define  NV03_EXTERNAL_MONITOR_BUS                                 (0x00000050)
/* NvNotification[] elements */
#define NV050_NOTIFIERS_NOTIFY                                     (0)
#define NV050_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV050_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV050_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV050_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV050_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV050_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV050_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV050_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV050_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV050_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV050_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV050_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV050_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv050Typedef, Nv03ExternalMonitorBus;
#define NV050_TYPEDEF                                    Nv03ExternalMonitorBus
/* dma method offsets, fields, and values */
#define NV050_SET_OBJECT                                           (0x00000000)
#define NV050_NO_OPERATION                                         (0x00000100)
#define NV050_NOTIFY                                               (0x00000104)
#define NV050_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV050_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV050_STOP_TRANSFER                                        (0x00000108)
#define NV050_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV050_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV050_WRITE                                                (0x00000300)
#define NV050_WRITE_SIZE                                           (0x00000300)
#define NV050_WRITE_SIZE_DATA                                      15:0
#define NV050_WRITE_SIZE_ADDRESS                                   31:16
#define NV050_WRITE_ADDRESS                                        (0x00000304)
#define NV050_WRITE_DATA                                           (0x00000308)
#define NV050_READ                                                 (0x0000030C)
#define NV050_READ_SIZE                                            (0x0000030C)
#define NV050_READ_SIZE_DATA                                       15:0
#define NV050_READ_SIZE_ADDRESS                                    31:16
#define NV050_READ_ADDRESS                                         (0x00000310)
#define NV050_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV050_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_MONITOR_BUS                                   (0x00000050)
#define Nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv03ExternalMonitorBus                           Nv03ExternalMonitorBus


/* class NV04_EXTERNAL_SERIAL_BUS */
#define  NV04_EXTERNAL_SERIAL_BUS                                  (0x00000051)
/* NvNotification[] elements */
#define NV051_NOTIFIERS_NOTIFY                                     (0)
#define NV051_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV051_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV051_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV051_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV051_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV051_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV051_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV051_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV051_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV051_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV051_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV051_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv051Typedef, Nv04ExternalSerialBus;
#define NV051_TYPEDEF                                     Nv04ExternalSerialBus
/* dma method offsets, fields, and values */
#define NV051_SET_OBJECT                                           (0x00000000)
#define NV051_NO_OPERATION                                         (0x00000100)
#define NV051_NOTIFY                                               (0x00000104)
#define NV051_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV051_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV051_STOP_TRANSFER                                        (0x00000108)
#define NV051_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV051_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV051_WRITE                                                (0x00000300)
#define NV051_WRITE_SIZE                                           (0x00000300)
#define NV051_WRITE_SIZE_DATA                                      15:0
#define NV051_WRITE_SIZE_ADDRESS                                   31:16
#define NV051_WRITE_ADDRESS                                        (0x00000304)
#define NV051_WRITE_DATA                                           (0x00000308)
#define NV051_READ                                                 (0x0000030C)
#define NV051_READ_SIZE                                            (0x0000030C)
#define NV051_READ_SIZE_DATA                                       15:0
#define NV051_READ_SIZE_ADDRESS                                    31:16
#define NV051_READ_ADDRESS                                         (0x00000310)
#define NV051_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV051_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV03_EXTERNAL_SERIAL_BUS                                   (0x00000051)
#define NV3_EXTERNAL_SERIAL_BUS                                    (0x00000051)
#define Nv03ExternalSerialBus                             Nv04ExternalSerialBus
#define nv03ExternalSerialBus                             Nv04ExternalSerialBus
#define Nv3ExternalSerialBus                              Nv04ExternalSerialBus
#define nv3ExternalSerialBus                              Nv04ExternalSerialBus
#define nv04ExternalSerialBus                             Nv04ExternalSerialBus


/* class NV04_CONTEXT_SURFACE_SWIZZLED */
#define  NV04_CONTEXT_SURFACE_SWIZZLED                             (0x00000052)
/* NvNotification[] elements */
#define NV052_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV052_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV052_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV052_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV052_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV052_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV052_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV052_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetFormat;               /* height_width_color V8_V8_V16     0300-0303*/
 NvU32 SetOffset;               /* byte offset of top-left pixel    0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv052Typedef, Nv04ContextSurfaceSwizzled;
#define NV052_TYPEDEF                                Nv04ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV052_SET_OBJECT                                           (0x00000000)
#define NV052_NO_OPERATION                                         (0x00000100)
#define NV052_NOTIFY                                               (0x00000104)
#define NV052_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV052_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV052_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV052_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV052_SET_FORMAT                                           (0x00000300)
#define NV052_SET_FORMAT_COLOR                                     15:0
#define NV052_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV052_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV052_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV052_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV052_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV052_SET_FORMAT_WIDTH                                     23:16
#define NV052_SET_FORMAT_WIDTH_1                                   (0x00000000)
#define NV052_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV052_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV052_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV052_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV052_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV052_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV052_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV052_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV052_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV052_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV052_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV052_SET_FORMAT_HEIGHT                                    31:24
#define NV052_SET_FORMAT_HEIGHT_1                                  (0x00000000)
#define NV052_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV052_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV052_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV052_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV052_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV052_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV052_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV052_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV052_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV052_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV052_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV052_SET_OFFSET                                           (0x00000304)
/* obsolete stuff */
#define NV4_CONTEXT_SURFACE_SWIZZLED                               (0x00000052)
#define Nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv04ContextSurfaceSwizzled                   Nv04ContextSurfaceSwizzled


/* class NV04_CONTEXT_SURFACES_3D */
#define  NV04_CONTEXT_SURFACES_3D                                  (0x00000053)
/* NvNotification[] elements */
#define NV053_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV053_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV053_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV053_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV053_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV053_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV053_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV053_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02F8-02FB*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02FC-02FF*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvU32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv053Typedef, Nv04ContextSurfaces3d;
#define NV053_TYPEDEF                                     Nv04ContextSurfaces3d
/* dma method offsets, fields, and values */
#define NV053_SET_OBJECT                                           (0x00000000)
#define NV053_NO_OPERATION                                         (0x00000100)
#define NV053_NOTIFY                                               (0x00000104)
#define NV053_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV053_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV053_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV053_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV053_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV053_SET_FORMAT                                           (0x00000300)
#define NV053_SET_FORMAT_COLOR                                     7:0
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV053_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV053_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV053_SET_FORMAT_TYPE                                      15:8
#define NV053_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV053_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV053_SET_FORMAT_WIDTH                                     23:16
#define NV053_SET_FORMAT_HEIGHT                                    31:24
#define NV053_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV053_SET_CLIP_HORIZONTAL_X                                15:0
#define NV053_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV053_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV053_SET_CLIP_VERTICAL_Y                                  15:0
#define NV053_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV053_SET_CLIP_SIZE                                        (0x00000304)
#define NV053_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV053_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV053_SET_PITCH                                            (0x00000308)
#define NV053_SET_PITCH_COLOR                                      15:0
#define NV053_SET_PITCH_ZETA                                       31:16
#define NV053_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV053_SET_OFFSET_ZETA                                      (0x00000310)
/* obsolete stuff */
#define NV04_CONTEXT_SURFACES_ARGB_ZS                              (0x00000053)
#define NV4_CONTEXT_SURFACES_ARGB_ZS                               (0x00000053)
#define Nv04ContextSurfacesArgbZs                         Nv04ContextSurfaces3d
#define nv04ContextSurfacesArgbZs                         Nv04ContextSurfaces3d
#define Nv4ContextSurfacesArgbZs                          Nv04ContextSurfaces3d
#define nv4ContextSurfacesArgbZs                          Nv04ContextSurfaces3d
#define nv04ContextSurfaces3d                             Nv04ContextSurfaces3d


/* class NV04_DX5_TEXTURED_TRIANGLE */
#define  NV04_DX5_TEXTURED_TRIANGLE                                (0x00000054)
/* NvNotification[] elements */
#define NV054_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV054_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV054_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV054_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV054_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV054_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV054_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV054_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ColorKey;                /* texture color key value          0300-0303*/
 NvU32 Offset;                  /* texture offset in bytes          0304-0307*/
 NvV32 Format;                  /* see text                         0308-030b*/
 NvV32 Filter;                  /* see text                         030c-030f*/
 NvV32 Blend;                   /* see text                         0310-0313*/
 NvV32 Control;                 /* see text                         0314-0317*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0318-031b*/
 NvV32 Reserved02[0x039];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[16];                /* end of methods in array              -05ff*/
 NvV32 DrawPrimitive[64];       /* see text                         0600-06ff*/
 NvV32 Reserved03[0x640];
} Nv054Typedef, Nv04Dx5TexturedTriangle;
#define NV054_TYPEDEF                                   Nv04Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV054_SET_OBJECT                                           (0x00000000)
#define NV054_NO_OPERATION                                         (0x00000100)
#define NV054_NOTIFY                                               (0x00000104)
#define NV054_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV054_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV054_STALL_PIPE                                           (0x00000108)
#define NV054_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV054_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV054_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV054_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV054_COLOR_KEY                                            (0x00000300)
#define NV054_OFFSET                                               (0x00000304)
#define NV054_FORMAT                                               (0x00000308)
#define NV054_FORMAT_CONTEXT_DMA                                   1:0
#define NV054_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV054_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV054_FORMAT_COLORKEYENABLE                                3:2
#define NV054_FORMAT_COLORKEYENABLE_FALSE                          (0x00000000)
#define NV054_FORMAT_COLORKEYENABLE_TRUE                           (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH                                    5:4
#define NV054_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV054_FORMAT_ORIGIN_FOH                                    7:6
#define NV054_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV054_FORMAT_COLOR                                         11:8
#define NV054_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV054_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV054_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV054_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV054_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV054_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV054_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV054_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV054_FORMAT_BASE_SIZE_U                                   19:16
#define NV054_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV054_FORMAT_BASE_SIZE_V                                   23:20
#define NV054_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV054_FORMAT_TEXTUREADDRESSU                               26:24
#define NV054_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPU                                         27:27
#define NV054_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV                               30:28
#define NV054_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPV                                         31:31
#define NV054_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV054_FILTER                                               (0x0000030C)
#define NV054_FILTER_KERNEL_SIZE_X                                 7:0
#define NV054_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV054_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV054_FILTER_MIPMAPLODBIAS                                 23:16
#define NV054_FILTER_TEXTUREMIN                                    26:24
#define NV054_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV054_FILTER_TEXTUREMAG                                    30:28
#define NV054_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV054_BLEND                                                (0x00000310)
#define NV054_BLEND_TEXTUREMAPBLEND                                3:0
#define NV054_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV054_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV054_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV054_BLEND_MASK_BIT                                       5:4
#define NV054_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV054_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV054_BLEND_SHADEMODE                                      7:6
#define NV054_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV054_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV054_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV054_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV054_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV054_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV054_BLEND_SPECULARENABLE                                 15:12
#define NV054_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV054_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV054_BLEND_FOGENABLE                                      19:16
#define NV054_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV054_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV054_BLEND_ALPHABLENDENABLE                               23:20
#define NV054_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV054_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV054_BLEND_SRCBLEND                                       27:24
#define NV054_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV054_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV054_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV054_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV054_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV054_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV054_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV054_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV054_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV054_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV054_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV054_BLEND_DESTBLEND                                      31:28
#define NV054_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV054_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV054_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV054_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV054_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV054_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV054_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV054_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV054_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV054_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV054_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV054_CONTROL                                              (0x00000314)
#define NV054_CONTROL_ALPHAREF                                     7:0
#define NV054_CONTROL_ALPHAFUNC                                    11:8
#define NV054_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV054_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV054_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV054_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV054_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV054_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV054_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV054_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV054_CONTROL_ALPHATESTENABLE                              12:12
#define NV054_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV054_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV054_CONTROL_ORIGIN                                       13:13
#define NV054_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV054_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV054_CONTROL_ZENABLE                                      15:14
#define NV054_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV054_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV054_CONTROL_ZFUNC                                        19:16
#define NV054_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV054_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV054_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV054_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV054_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV054_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV054_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV054_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV054_CONTROL_CULLMODE                                     21:20
#define NV054_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV054_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV054_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV054_CONTROL_DITHERENABLE                                 22:22
#define NV054_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV054_CONTROL_ZWRITEENABLE                                 29:24
#define NV054_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_FORMAT                                     31:30
#define NV054_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV054_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV054_FOG_COLOR                                            (0x00000318)
#define NV054_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR_BLUE                                  7:0
#define NV054_TLVERTEX_COLOR_GREEN                                 15:8
#define NV054_TLVERTEX_COLOR_RED                                   23:16
#define NV054_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV054_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV054_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV054_TLVERTEX_SPECULAR_RED                                23:16
#define NV054_TLVERTEX_SPECULAR_FOG                                31:24
#define NV054_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV054_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV054_DRAW_PRIMITIVE_I0                                    3:0
#define NV054_DRAW_PRIMITIVE_I1                                    7:4
#define NV054_DRAW_PRIMITIVE_I2                                    11:8
#define NV054_DRAW_PRIMITIVE_I3                                    15:12
#define NV054_DRAW_PRIMITIVE_I4                                    19:16
#define NV054_DRAW_PRIMITIVE_I5                                    31:20
/* obsolete stuff */
#define NV4_DX5_TEXTURED_TRIANGLE                                  (0x00000054)
#define Nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv04Dx5TexturedTriangle                         Nv04Dx5TexturedTriangle


/* class NV04_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV04_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000055)
/* NvNotification[] elements */
#define NV055_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV055_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV055_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV055_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV055_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV055_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV055_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV055_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05e];
 NvU32 Offset[2];               /* offset in bytes                  0308-030f*/
 NvV32 Format[2];               /* see text                         0310-0317*/
 NvV32 Filter[2];               /* see text                         0318-031f*/
 NvV32 Combine0Alpha;           /* see text                         0320-0323*/
 NvV32 Combine0Color;           /* see text                         0324-0327*/
 NvV32 Reserved02[0x001];
 NvV32 Combine1Alpha;           /* see text                         032c-032f*/
 NvV32 Combine1Color;           /* see text                         0330-0333*/
 NvV32 CombineFactor;           /* A8R8G8B8                         0334-0337*/
 NvV32 Blend;                   /* see text                         0338-033b*/
 NvV32 Control0;                /* see text                         033c-033f*/
 NvV32 Control1;                /* see text                         0340-0343*/
 NvV32 Control2;                /* see text                         0344-0347*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0348-034b*/
 NvV32 Reserved03[0x02D];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu0;                    /* texture 0 u coordinate             18-  1b*/
  NvF32 tv0;                    /* texture 0 v coordinate             1c-  1f*/
  NvF32 tu1;                    /* texture 1 u coordinate             20-  23*/
  NvF32 tv1;                    /* texture 1 v coordinate             24-  27*/
 } Tlmtvertex[8];               /* end of methods in array              -053f*/
 NvV32 DrawPrimitive[48];       /* see text                         0540-05ff*/
 NvV32 Reserved04[0x680];
} Nv055Typedef, Nv04Dx6MultiTextureTriangle;
#define NV055_TYPEDEF                               Nv04Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV055_SET_OBJECT                                           (0x00000000)
#define NV055_NO_OPERATION                                         (0x00000100)
#define NV055_NOTIFY                                               (0x00000104)
#define NV055_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV055_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV055_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV055_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV055_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV055_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV055_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV055_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV055_FORMAT_CONTEXT_DMA                                   3:0
#define NV055_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV055_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV055_FORMAT_ORIGIN_ZOH                                    5:4
#define NV055_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV055_FORMAT_ORIGIN_FOH                                    7:6
#define NV055_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV055_FORMAT_COLOR                                         11:8
#define NV055_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV055_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV055_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV055_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV055_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV055_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV055_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV055_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV055_FORMAT_BASE_SIZE_U                                   19:16
#define NV055_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV055_FORMAT_BASE_SIZE_V                                   23:20
#define NV055_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV055_FORMAT_TEXTUREADDRESSU                               26:24
#define NV055_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPU                                         27:27
#define NV055_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV                               30:28
#define NV055_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPV                                         31:31
#define NV055_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV055_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV055_FILTER_KERNEL_SIZE_X                                 7:0
#define NV055_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV055_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV055_FILTER_MIPMAPLODBIAS                                 23:16
#define NV055_FILTER_TEXTUREMIN                                    26:24
#define NV055_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV055_FILTER_TEXTUREMAG                                    30:28
#define NV055_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV055_COMBINE_0_ALPHA                                      (0x00000320)
#define NV055_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_0_COLOR                                      (0x00000324)
#define NV055_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_OPERATION                            31:29
#define NV055_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV055_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_COLOR                                      (0x00000330)
#define NV055_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_OPERATION                            31:29
#define NV055_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
/* The following NV055_COMBINE_*** defines can be used without regard to the combiner number */
#define NV055_COMBINE_ALPHA_INVERSE_0                              0:0
#define NV055_COMBINE_ALPHA_INVERSE_0_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_0_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_0                                1:1
#define NV055_COMBINE_ALPHA_ARGUMENT_0                             7:2
#define NV055_COMBINE_ALPHA_ARGUMENT_0_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_1                              8:8
#define NV055_COMBINE_ALPHA_INVERSE_1_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_1_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_1                                9:9
#define NV055_COMBINE_ALPHA_ARGUMENT_1                             15:10
#define NV055_COMBINE_ALPHA_ARGUMENT_1_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_2                              16:16
#define NV055_COMBINE_ALPHA_INVERSE_2_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_2_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_2                                17:17
#define NV055_COMBINE_ALPHA_ARGUMENT_2                             23:18
#define NV055_COMBINE_ALPHA_ARGUMENT_2_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_3                              24:24
#define NV055_COMBINE_ALPHA_INVERSE_3_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_3_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_3                                25:25
#define NV055_COMBINE_ALPHA_ARGUMENT_3                             28:26
#define NV055_COMBINE_ALPHA_ARGUMENT_3_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_OPERATION                              31:29
#define NV055_COMBINE_ALPHA_OPERATION_ADD                          (0x00000001)
#define NV055_COMBINE_ALPHA_OPERATION_ADD2                         (0x00000002)
#define NV055_COMBINE_ALPHA_OPERATION_ADD4                         (0x00000003)
#define NV055_COMBINE_ALPHA_OPERATION_ADDSIGNED                    (0x00000004)
#define NV055_COMBINE_ALPHA_OPERATION_MUX                          (0x00000005)
#define NV055_COMBINE_ALPHA_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV055_COMBINE_ALPHA_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_0                              0:0
#define NV055_COMBINE_COLOR_INVERSE_0_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_0_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_0                                1:1
#define NV055_COMBINE_COLOR_ALPHA_0_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_0_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_0                             7:2
#define NV055_COMBINE_COLOR_ARGUMENT_0_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_0_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_1                              8:8
#define NV055_COMBINE_COLOR_INVERSE_1_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_1_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_1                                9:9
#define NV055_COMBINE_COLOR_ALPHA_1_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_1_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_1                             15:10
#define NV055_COMBINE_COLOR_ARGUMENT_1_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_1_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_2                              16:16
#define NV055_COMBINE_COLOR_INVERSE_2_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_2_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_2                                17:17
#define NV055_COMBINE_COLOR_ALPHA_2_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_2_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_2                             23:18
#define NV055_COMBINE_COLOR_ARGUMENT_2_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_2_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_3                              24:24
#define NV055_COMBINE_COLOR_INVERSE_3_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_3_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_3                                25:25
#define NV055_COMBINE_COLOR_ALPHA_3_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_3_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_3                             28:26
#define NV055_COMBINE_COLOR_ARGUMENT_3_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_3_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_OPERATION                              31:29
#define NV055_COMBINE_COLOR_OPERATION_ADD                          (0x00000001)
#define NV055_COMBINE_COLOR_OPERATION_ADD2                         (0x00000002)
#define NV055_COMBINE_COLOR_OPERATION_ADD4                         (0x00000003)
#define NV055_COMBINE_COLOR_OPERATION_ADDSIGNED                    (0x00000004)
#define NV055_COMBINE_COLOR_OPERATION_MUX                          (0x00000005)
#define NV055_COMBINE_COLOR_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV055_COMBINE_COLOR_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV055_COMBINE_FACTOR                                       (0x00000334)
#define NV055_COMBINE_FACTOR_BLUE                                  7:0
#define NV055_COMBINE_FACTOR_GREEN                                 15:8
#define NV055_COMBINE_FACTOR_RED                                   23:16
#define NV055_COMBINE_FACTOR_ALPHA                                 31:24
#define NV055_BLEND                                                (0x00000338)
#define NV055_BLEND_MASK_BIT                                       5:0
#define NV055_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV055_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV055_BLEND_SHADEMODE                                      7:6
#define NV055_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV055_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV055_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV055_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV055_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV055_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV055_BLEND_SPECULARENABLE                                 15:12
#define NV055_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV055_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV055_BLEND_FOGENABLE                                      19:16
#define NV055_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV055_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV055_BLEND_ALPHABLENDENABLE                               23:20
#define NV055_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV055_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV055_BLEND_SRCBLEND                                       27:24
#define NV055_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV055_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV055_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV055_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV055_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV055_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV055_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV055_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV055_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV055_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV055_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV055_BLEND_DESTBLEND                                      31:28
#define NV055_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV055_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV055_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV055_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV055_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV055_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV055_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV055_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV055_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV055_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV055_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV055_CONTROL0                                             (0x0000033C)
#define NV055_CONTROL0_ALPHAREF                                    7:0
#define NV055_CONTROL0_ALPHAFUNC                                   11:8
#define NV055_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV055_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV055_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV055_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV055_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV055_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV055_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV055_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV055_CONTROL0_ALPHATESTENABLE                             12:12
#define NV055_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV055_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV055_CONTROL0_ORIGIN                                      13:13
#define NV055_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV055_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV055_CONTROL0_ZENABLE                                     15:14
#define NV055_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV055_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV055_CONTROL0_ZFUNC                                       19:16
#define NV055_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV055_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV055_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV055_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV055_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV055_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV055_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV055_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV055_CONTROL0_CULLMODE                                    21:20
#define NV055_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV055_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV055_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV055_CONTROL0_DITHERENABLE                                22:22
#define NV055_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ZWRITEENABLE                                24:24
#define NV055_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV055_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV055_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV055_CONTROL0_Z_FORMAT                                    31:30
#define NV055_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV055_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV055_CONTROL1                                             (0x00000340)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC                                7:4
#define NV055_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV055_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV055_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV055_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV055_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV055_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV055_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV055_CONTROL1_STENCIL_REF                                 15:8
#define NV055_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV055_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV055_CONTROL2                                             (0x00000344)
#define NV055_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV055_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV055_FOG_COLOR                                            (0x00000348)
#define NV055_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV055_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV055_TLMTVERTEX_COLOR_RED                                 23:16
#define NV055_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV055_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV055_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV055_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV055_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV055_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV055_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV055_DRAW_PRIMITIVE_I0                                    3:0
#define NV055_DRAW_PRIMITIVE_I1                                    7:4
#define NV055_DRAW_PRIMITIVE_I2                                    11:8
#define NV055_DRAW_PRIMITIVE_I3                                    15:12
#define NV055_DRAW_PRIMITIVE_I4                                    19:16
#define NV055_DRAW_PRIMITIVE_I5                                    31:20
/* obsolete stuff */
#define NV4_DX6_MULTI_TEXTURE_TRIANGLE                             (0x00000055)
#define Nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv04Dx6MultiTextureTriangle                 Nv04Dx6MultiTextureTriangle


// This typedef really should be the same as Nv10CelsiusPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.


typedef NvV32 Nv056Typedef;


/* class NV10_CELSIUS_PRIMITIVE */
#define  NV10_CELSIUS_PRIMITIVE                                    (0x00000056)
/* NvNotification[] elements */
#define NV056_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV056_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV056_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV056_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV056_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV056_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV056_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved00[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved01[0x2c/4];
    NvV32 PmTrigger;
    NvV32 Reserved02[0x3c/4];
    NvV32 SetContextDmaNotifies;
    NvV32 SetContextDmaA;
    NvV32 SetContextDmaB;
    NvV32 SetContextDmaVertex;
    NvV32 SetContextDmaState;
    NvV32 SetContextDmaColor;
    NvV32 SetContextDmaZeta;
    NvV32 Reserved03[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved04[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved05[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvV32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvV32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvV32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvV32 SetStencilFuncRef;
    NvV32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvV32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvV32 SetMaterialEmission[3];
    NvV32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
        NvV32 S;
        NvV32 T;
        NvV32 R;
        NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvV32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved06[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved07[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved08[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved09[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0b[0xc8/4];
    struct {
        NvF32 AmbientColor[3];
        NvF32 DiffuseColor[3];
        NvF32 SpecularColor[3];
        NvF32 LocalRange;
        NvF32 InfiniteHalfVector[3];
        NvF32 InfiniteDirection[3];
        NvF32 SpotFalloff[3];
        NvF32 SpotDirection[4];
        NvF32 LocalPosition[3];
        NvF32 LocalAttenuation[3];
        NvV32 Reserved0c[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0d[0xc/4];
    NvF32 SetVertex4f[4];
    NvS16 SetVertex4s[4];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0e[0x4/4];
    NvS16 SetNormal3s[3];
    NvV16 Reserved0f[0xa/2];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvV32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvV32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS16 SetTexcoord0_2s[2];
    NvV32 Reserved10[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS16 SetTexcoord0_4s[4];
    NvF32 SetTexcoord1_2f[2];
    NvS16 SetTexcoord1_2s[2];
    NvV32 Reserved11[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS16 SetTexcoord1_4s[4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved12[0x4/4];
    NvV32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 Reserved13[0xbc/4];
    NvV32 SetBeginEnd;
    NvV16 ArrayElement16[256];
    NvV32 Reserved14[0xfc/4];
    NvV32 SetBeginEnd2;
    NvV32 ArrayElement32[64];
    NvV32 Reserved15[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 SetMaterialEmissionSW[3];
    NvV32 Reserved16[0x1c8/4];
    NvV32 SetBeginEnd4;
    NvV32 InlineArray[512];
} Nv10CelsiusPrimitive;


#define NV056_TYPEDEF                                      Nv10CelsiusPrimitive
#define NV056_SET_OBJECT                                           (0x00000000)


#define NV056_DEBUG_INIT(i)                                        (0x00001600+(i)*4)


#define NV056_FLUSH                                                        0x00000728


#define NV056_NO_OPERATION                                                 0x00000100


#define NV056_NOTIFY                                                       0x00000104
#define NV056_NOTIFY_TYPE                                                        23:0
#define NV056_NOTIFY_TYPE_WRITE_ONLY                                       0x00000000
#define NV056_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                0x00000001


#define NV056_SET_WARNING_ENABLE                                           0x00000108
#define NV056_SET_WARNING_ENABLE_V                                               23:0
#define NV056_SET_WARNING_ENABLE_V_FALSE                                   0x00000000
#define NV056_SET_WARNING_ENABLE_V_TRUE                                    0x00000001


#define NV056_GET_STATE                                                    0x0000010c
#define NV056_GET_STATE_GETSTATE                                                 31:0
#define NV056_GET_STATE_GETSTATE_ALL_STATE                                 0x00000001
#define NV056_GET_STATE_PUTSTATE_ALL_STATE                                 0x00000002
#define NV056_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                   0x00000003
#define NV056_GET_STATE_GETSTATE_RENDERING_STATE                           0x00000004
#define NV056_GET_STATE_GETSTATE_GEOMETRY_STATE                            0x00000005
#define NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                        0x00000006
#define NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                          0x00000007

#define NV056_WAIT_FOR_IDLE                                                0x00000110


#define NV056_PM_TRIGGER                                                   0x00000140


#define NV056_SET_CONTEXT_DMA_NOTIFIES                                     0x00000180


#define NV056_SET_CONTEXT_DMA_A                                            0x00000184


#define NV056_SET_CONTEXT_DMA_B                                            0x00000188


#define NV056_SET_CONTEXT_DMA_VERTEX                                       0x0000018c


#define NV056_SET_CONTEXT_DMA_STATE                                        0x00000190


#define NV056_SET_CONTEXT_DMA_COLOR                                        0x00000194


#define NV056_SET_CONTEXT_DMA_ZETA                                         0x00000198


#define NV056_SET_SURFACE_CLIP_HORIZONTAL                                  0x00000200
#define NV056_SET_SURFACE_CLIP_HORIZONTAL_X                                      15:0
#define NV056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                 31:16


#define NV056_SET_SURFACE_CLIP_VERTICAL                                    0x00000204
#define NV056_SET_SURFACE_CLIP_VERTICAL_Y                                        15:0
#define NV056_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                  31:16


#define NV056_SET_SURFACE_FORMAT                                           0x00000208
#define NV056_SET_SURFACE_FORMAT_COLOR                                            7:0
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                0x00000001
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                0x00000002
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                           0x00000003
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                0x00000004
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                0x00000005
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            0x00000006
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            0x00000007
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000008
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_B8                               0x00000009
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8                             0x0000000A
#define NV056_SET_SURFACE_FORMAT_TYPE                                            15:8
#define NV056_SET_SURFACE_FORMAT_TYPE_PITCH                                0x00000001
#define NV056_SET_SURFACE_FORMAT_TYPE_SWIZZLE                              0x00000002
#define NV056_SET_SURFACE_FORMAT_WIDTH                                          23:16
#define NV056_SET_SURFACE_FORMAT_WIDTH_1                                   0x00000000
#define NV056_SET_SURFACE_FORMAT_WIDTH_2                                   0x00000001
#define NV056_SET_SURFACE_FORMAT_WIDTH_4                                   0x00000002
#define NV056_SET_SURFACE_FORMAT_WIDTH_8                                   0x00000003
#define NV056_SET_SURFACE_FORMAT_WIDTH_16                                  0x00000004
#define NV056_SET_SURFACE_FORMAT_WIDTH_32                                  0x00000005
#define NV056_SET_SURFACE_FORMAT_WIDTH_64                                  0x00000006
#define NV056_SET_SURFACE_FORMAT_WIDTH_128                                 0x00000007
#define NV056_SET_SURFACE_FORMAT_WIDTH_256                                 0x00000008
#define NV056_SET_SURFACE_FORMAT_WIDTH_512                                 0x00000009
#define NV056_SET_SURFACE_FORMAT_WIDTH_1024                                0x0000000A
#define NV056_SET_SURFACE_FORMAT_WIDTH_2048                                0x0000000B
#define NV056_SET_SURFACE_FORMAT_HEIGHT                                         31:24
#define NV056_SET_SURFACE_FORMAT_HEIGHT_1                                  0x00000000
#define NV056_SET_SURFACE_FORMAT_HEIGHT_2                                  0x00000001
#define NV056_SET_SURFACE_FORMAT_HEIGHT_4                                  0x00000002
#define NV056_SET_SURFACE_FORMAT_HEIGHT_8                                  0x00000003
#define NV056_SET_SURFACE_FORMAT_HEIGHT_16                                 0x00000004
#define NV056_SET_SURFACE_FORMAT_HEIGHT_32                                 0x00000005
#define NV056_SET_SURFACE_FORMAT_HEIGHT_64                                 0x00000006
#define NV056_SET_SURFACE_FORMAT_HEIGHT_128                                0x00000007
#define NV056_SET_SURFACE_FORMAT_HEIGHT_256                                0x00000008
#define NV056_SET_SURFACE_FORMAT_HEIGHT_512                                0x00000009
#define NV056_SET_SURFACE_FORMAT_HEIGHT_1024                               0x0000000A
#define NV056_SET_SURFACE_FORMAT_HEIGHT_2048                               0x0000000B


#define NV056_SET_SURFACE_PITCH                                            0x0000020c
#define NV056_SET_SURFACE_PITCH_COLOR                                            15:0
#define NV056_SET_SURFACE_PITCH_ZETA                                            31:16


#define NV056_SET_SURFACE_COLOR_OFFSET                                     0x00000210
#define NV056_SET_SURFACE_COLOR_OFFSET_V                                         31:0


#define NV056_SET_SURFACE_ZETA_OFFSET                                      0x00000214
#define NV056_SET_SURFACE_ZETA_OFFSET_V                                          31:0


#define NV056_SET_TEXTURE_OFFSET(i)                                (0x00000218+(i)*4)
#define NV056_SET_TEXTURE_OFFSET_V                                               31:0


#define NV056_SET_TEXTURE_FORMAT(i)                                (0x00000220+(i)*4)
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA                                      1:0
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                   2:2
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                      0x00000000
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                       0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                       4:3
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                         0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH                                       6:5
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                         0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_COLOR                                           11:7
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_Y8                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_AY8                              0x00000001
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                         0x00000003
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                         0x00000004
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                           0x00000005
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000006
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                         0x00000007
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                      0x00000008
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                        0x00000009
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                      0x0000000A
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                      0x0000000B
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                    0x0000000C
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                   0x0000000E
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                   0x0000000F
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                   0x00000010
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                     0x00000011
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                   0x00000012
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                         0x00000013
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                        0x00000014
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                      0x00000015
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                       0x00000016
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                       0x00000017
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                     0x00000018
#define NV056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                  15:12
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U                                    19:16
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                             0x00000000
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                             0x00000003
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                            0x00000004
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                            0x00000005
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                            0x00000006
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                           0x00000007
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                           0x00000008
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                           0x00000009
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                          0x0000000A
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                          0x0000000B
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V                                    23:20
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                             0x00000000
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                             0x00000003
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                            0x00000004
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                            0x00000005
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                            0x00000006
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                           0x00000007
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                           0x00000008
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                           0x00000009
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                          0x0000000A
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                          0x0000000B
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                                26:24
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                      0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                    0x00000002
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                     0x00000003
#define NV056_SET_TEXTURE_FORMAT_WRAPU                                          27:27
#define NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_WRAPU_TRUE                                0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                                30:28
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                      0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                    0x00000002
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                     0x00000003
#define NV056_SET_TEXTURE_FORMAT_WRAPV                                          31:31
#define NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_WRAPV_TRUE                                0x00000001


#define NV056_SET_TEXTURE_CONTROL0(i)                              (0x00000228+(i)*4)
#define NV056_SET_TEXTURE_CONTROL0_ENABLE                                       30:30
#define NV056_SET_TEXTURE_CONTROL0_ENABLE_FALSE                            0x00000000
#define NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE                             0x00000001
#define NV056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                29:18
#define NV056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                 17:6
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                  5:4
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                         0x00000000
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                         0x00000001
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                             3:3
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                0x00000000
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                 0x00000001
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                              2:2
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                 0x00000000
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                  0x00000001
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                            1:0
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE               0x00000000
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA               0x00000001
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                0x00000002
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                0x00000003


#define NV056_SET_TEXTURE_CONTROL1(i)                              (0x00000230+(i)*4)
#define NV056_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                  31:16
#define NV056_SET_TEXTURE_CONTROL1_ZERO                                          15:0


#define NV056_SET_TEXTURE_CONTROL2(i)                              (0x00000238+(i)*4)
#define NV056_SET_TEXTURE_CONTROL2_PERTURB_DU                                    11:0
#define NV056_SET_TEXTURE_CONTROL2_PERTURB_DV                                   23:12
#define NV056_SET_TEXTURE_CONTROL2_IMAGE_LODF                                   31:24


#define NV056_SET_TEXTURE_IMAGE_RECT(i)                            (0x00000240+(i)*4)
#define NV056_SET_TEXTURE_IMAGE_RECT_WIDTH                                      31:16
#define NV056_SET_TEXTURE_IMAGE_RECT_HEIGHT                                      15:0


#define NV056_SET_TEXTURE_FILTER(i)                                (0x00000248+(i)*4)
#define NV056_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                   23:0
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN                                     27:24
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                        0x00000001
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                         0x00000002
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                     0x00000003
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                      0x00000004
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST               0x00000005
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR                0x00000006
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG                                     31:28
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                        0x00000001
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                         0x00000002


#define NV056_SET_TEXTURE_PALETTE(i)                               (0x00000250+(i)*4)
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA                                     5:0
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                            0x00000000
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                            0x00000001
#define NV056_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                 31:6


#define NV056_SET_COMBINER_ALPHA_ICW(i)                            (0x00000260+(i)*4)
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP                                      31:29
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA                                    28:28
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE                                   27:24
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP                                      23:21
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA                                    20:20
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE                                   19:16
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP                                      15:13
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA                                    12:12
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE                                    11:8
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP                                        7:5
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA                                      4:4
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE                                     3:0
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV056_SET_COMBINER_COLOR_ICW(i)                            (0x00000268+(i)*4)
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP                                      31:29
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA                                    28:28
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE                                   27:24
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP                                      23:21
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA                                    20:20
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE                                   19:16
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP                                      15:13
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA                                    12:12
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE                                    11:8
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP                                        7:5
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA                                      4:4
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE                                     3:0
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV056_SET_COMBINE_FACTOR(i)                                (0x00000270+(i)*4)
#define NV056_SET_COMBINE_FACTOR_BLUE                                             7:0
#define NV056_SET_COMBINE_FACTOR_GREEN                                           15:8
#define NV056_SET_COMBINE_FACTOR_RED                                            23:16
#define NV056_SET_COMBINE_FACTOR_ALPHA                                          31:24


#define NV056_SET_COMBINER_ALPHA_OCW(i)                            (0x00000278+(i)*4)
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION                                  31:15
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                     0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                0x00000001
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                0x00000002
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS           0x00000003
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1               0x00000006
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                 14:14
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                      0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                       0x00000001
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST                                     11:8
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST                                       7:4
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                          0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                          0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                          0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                          0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                          0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                          0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                          0x0000000D
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST                                       3:0
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                          0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                          0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                          0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                          0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                          0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                          0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                          0x0000000D


#define NV056_SET_COMBINER0_COLOR_OCW                                      0x00000280
#define NV056_SET_COMBINER0_COLOR_OCW_ZERO                                      31:27
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION                                 26:15
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                                14:14
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST                                    11:8
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST                                      7:4
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST                                      3:0
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV056_SET_COMBINER1_COLOR_OCW                                      0x00000284
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                           31:28
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                  0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                  0x00000002
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT                                27:27
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                       0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                       0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION                                 26:15
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                                14:14
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST                                    11:8
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST                                      7:4
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST                                      3:0
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV056_SET_COMBINER_SPECULAR_FOG_CW0                                0x00000288
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                           31:29
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                             28:28
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                            27:24
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                           23:21
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                             20:20
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                            19:16
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                           15:13
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                             12:12
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                             11:8
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                             7:5
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                               4:4
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                              3:0
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD           0x0000000F


#define NV056_SET_COMBINER_SPECULAR_FOG_CW1                                0x0000028c
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                           31:29
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                             28:28
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                            27:24
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                           23:21
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                             20:20
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                            19:16
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                           15:13
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                             12:12
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                             11:8
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                        7:7
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE           0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE            0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                6:6
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE   0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE    0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12               5:0
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE   0x00000020


#define NV056_SET_CONTROL0                                                 0x00000290
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA                                   31:24
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                        0x00000000
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                         0x00000001
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE                                   23:20
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                        0x00000000
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                         0x00000001
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                 19:16
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                      0x00000000
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                       0x00000001
#define NV056_SET_CONTROL0_Z_FORMAT                                             15:12
#define NV056_SET_CONTROL0_Z_FORMAT_FIXED                                  0x00000000
#define NV056_SET_CONTROL0_Z_FORMAT_FLOAT                                  0x00000001
#define NV056_SET_CONTROL0_WBUFFER_SELECT                                        11:8
#define NV056_SET_CONTROL0_WBUFFER_SELECT_0                                0x00000000
#define NV056_SET_CONTROL0_WBUFFER_SELECT_1                                0x00000001
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE                                   7:0
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                       0x00000001


#define NV056_SET_LIGHT_CONTROL                                            0x00000294
#define NV056_SET_LIGHT_CONTROL_LOCALEYE                                        31:16
#define NV056_SET_LIGHT_CONTROL_LOCALEYE_FALSE                             0x00000000
#define NV056_SET_LIGHT_CONTROL_LOCALEYE_TRUE                              0x00000001
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE                                 15:2
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                    0x00000000
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT                0x00000001
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                              1:1
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                 0x00000000
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                  0x00000001
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                                0:0
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                   0x00000000
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                    0x00000001


#define NV056_SET_COLOR_MATERIAL                                           0x00000298
#define NV056_SET_COLOR_MATERIAL_V                                               31:0
#define NV056_SET_COLOR_MATERIAL_V_DISABLED                                0x00000000
#define NV056_SET_COLOR_MATERIAL_V_EMISSION                                0x00000001
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT                                 0x00000002
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                        0x00000003
#define NV056_SET_COLOR_MATERIAL_V_DIFFUSE                                 0x00000004
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                        0x00000005
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                         0x00000006
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE                0x00000007
#define NV056_SET_COLOR_MATERIAL_V_SPECULAR                                0x00000008
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                       0x00000009
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                        0x0000000A
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR               0x0000000B
#define NV056_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                        0x0000000C
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR               0x0000000D
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR                0x0000000E
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR       0x0000000F


#define NV056_SET_FOG_MODE                                                 0x0000029c
#define NV056_SET_FOG_MODE_FOG_MODE                                              31:0
#define NV056_SET_FOG_MODE_FOG_MODE_LINEAR                                 0x00002601
#define NV056_SET_FOG_MODE_FOG_MODE_EXP                                    0x00000800
#define NV056_SET_FOG_MODE_FOG_MODE_EXP2                                   0x00000801
#define NV056_SET_FOG_MODE_FOG_MODE_EXP_ABS                                0x00000802
#define NV056_SET_FOG_MODE_FOG_MODE_EXP2_ABS                               0x00000803


#define NV056_SET_FOG_GEN_MODE                                             0x000002a0
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE                                      31:0
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                      0x00000000
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                         0x00000001
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                         0x00000002
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                     0x00000003


#define NV056_SET_FOG_ENABLE                                               0x000002a4
#define NV056_SET_FOG_ENABLE_V                                                   31:0
#define NV056_SET_FOG_ENABLE_V_FALSE                                       0x00000000
#define NV056_SET_FOG_ENABLE_V_TRUE                                        0x00000001


#define NV056_SET_FOG_COLOR                                               0x000002a8
#define NV056_SET_FOG_COLOR_FOG_COLOR_RED                                        7:0
#define NV056_SET_FOG_COLOR_FOG_COLOR_GREEN                                     15:8
#define NV056_SET_FOG_COLOR_FOG_COLOR_BLUE                                     23:16
#define NV056_SET_FOG_COLOR_FOG_COLOR_ALPHA                                    31:24


#define NV056_SET_COLOR_KEY_COLOR(i)                               (0x000002ac+(i)*4)
#define NV056_SET_COLOR_KEY_COLOR_V                                              31:0


#define NV056_SET_WINDOW_CLIP_TYPE                                         0x000002b4
#define NV056_SET_WINDOW_CLIP_TYPE_V                                             31:0
#define NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                             0x00000000
#define NV056_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                             0x00000001


#define NV056_SET_WINDOW_CLIP_HORIZONTAL(i)                        (0x000002c0+(i)*4)
#define NV056_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                    15:0
#define NV056_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                   31:16


#define NV056_SET_WINDOW_CLIP_VERTICAL(i)                          (0x000002e0+(i)*4)
#define NV056_SET_WINDOW_CLIP_VERTICAL_YMIN                                      15:0
#define NV056_SET_WINDOW_CLIP_VERTICAL_YMAX                                     31:16


#define NV056_SET_ALPHA_TEST_ENABLE                                        0x00000300
#define NV056_SET_ALPHA_TEST_ENABLE_V                                            31:0
#define NV056_SET_ALPHA_TEST_ENABLE_V_FALSE                                0x00000000
#define NV056_SET_ALPHA_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV056_SET_BLEND_ENABLE                                             0x00000304
#define NV056_SET_BLEND_ENABLE_V                                                 31:0
#define NV056_SET_BLEND_ENABLE_V_FALSE                                     0x00000000
#define NV056_SET_BLEND_ENABLE_V_TRUE                                      0x00000001


#define NV056_SET_CULL_FACE_ENABLE                                         0x00000308
#define NV056_SET_CULL_FACE_ENABLE_V                                             31:0
#define NV056_SET_CULL_FACE_ENABLE_V_FALSE                                 0x00000000
#define NV056_SET_CULL_FACE_ENABLE_V_TRUE                                  0x00000001


#define NV056_SET_DEPTH_TEST_ENABLE                                        0x0000030c
#define NV056_SET_DEPTH_TEST_ENABLE_V                                            31:0
#define NV056_SET_DEPTH_TEST_ENABLE_V_FALSE                                0x00000000
#define NV056_SET_DEPTH_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV056_SET_DITHER_ENABLE                                            0x00000310
#define NV056_SET_DITHER_ENABLE_V                                                31:0
#define NV056_SET_DITHER_ENABLE_V_FALSE                                    0x00000000
#define NV056_SET_DITHER_ENABLE_V_TRUE                                     0x00000001


#define NV056_SET_LIGHTING_ENABLE                                          0x00000314
#define NV056_SET_LIGHTING_ENABLE_V                                              31:0
#define NV056_SET_LIGHTING_ENABLE_V_FALSE                                  0x00000000
#define NV056_SET_LIGHTING_ENABLE_V_TRUE                                   0x00000001


#define NV056_SET_POINT_PARAMS_ENABLE                                      0x00000318
#define NV056_SET_POINT_PARAMS_ENABLE_V                                          31:0
#define NV056_SET_POINT_PARAMS_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_POINT_PARAMS_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_POINT_SMOOTH_ENABLE                                      0x0000031c
#define NV056_SET_POINT_SMOOTH_ENABLE_V                                          31:0
#define NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_POINT_SMOOTH_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_LINE_SMOOTH_ENABLE                                       0x00000320
#define NV056_SET_LINE_SMOOTH_ENABLE_V                                           31:0
#define NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV056_SET_LINE_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV056_SET_POLY_SMOOTH_ENABLE                                       0x00000324
#define NV056_SET_POLY_SMOOTH_ENABLE_V                                           31:0
#define NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV056_SET_POLY_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV056_SET_SKIN_ENABLE                                              0x00000328
#define NV056_SET_SKIN_ENABLE_V                                                  31:0
#define NV056_SET_SKIN_ENABLE_V_FALSE                                      0x00000000
#define NV056_SET_SKIN_ENABLE_V_TRUE                                       0x00000001


#define NV056_SET_STENCIL_TEST_ENABLE                                      0x0000032c
#define NV056_SET_STENCIL_TEST_ENABLE_V                                          31:0
#define NV056_SET_STENCIL_TEST_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_STENCIL_TEST_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_POLY_OFFSET_POINT_ENABLE                                 0x00000330
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V                                     31:0
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                         0x00000000
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                          0x00000001


#define NV056_SET_POLY_OFFSET_LINE_ENABLE                                  0x00000334
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V                                      31:0
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                          0x00000000
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                           0x00000001


#define NV056_SET_POLY_OFFSET_FILL_ENABLE                                  0x00000338
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V                                      31:0
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                          0x00000000
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                           0x00000001


#define NV056_SET_ALPHA_FUNC                                               0x0000033c
#define NV056_SET_ALPHA_FUNC_V                                                   31:0
#define NV056_SET_ALPHA_FUNC_V_NEVER                                       0x00000200
#define NV056_SET_ALPHA_FUNC_V_LESS                                        0x00000201
#define NV056_SET_ALPHA_FUNC_V_EQUAL                                       0x00000202
#define NV056_SET_ALPHA_FUNC_V_LEQUAL                                      0x00000203
#define NV056_SET_ALPHA_FUNC_V_GREATER                                     0x00000204
#define NV056_SET_ALPHA_FUNC_V_NOTEQUAL                                    0x00000205
#define NV056_SET_ALPHA_FUNC_V_GEQUAL                                      0x00000206
#define NV056_SET_ALPHA_FUNC_V_ALWAYS                                      0x00000207


#define NV056_SET_ALPHA_REF                                                0x00000340


#define NV056_SET_BLEND_FUNC_SFACTOR                                       0x00000344
#define NV056_SET_BLEND_FUNC_SFACTOR_V                                           31:0
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ZERO                                0x00000000
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE                                 0x00000001
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                           0x00000300
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                           0x00000302
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV056_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                           0x00000304
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV056_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                           0x00000306
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                  0x00000308
#define NV056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV056_SET_BLEND_FUNC_DFACTOR                                       0x00000348
#define NV056_SET_BLEND_FUNC_DFACTOR_V                                           31:0
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO                                0x00000000
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE                                 0x00000001
#define NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                           0x00000300
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                           0x00000302
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV056_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                           0x00000304
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV056_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                           0x00000306
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV056_SET_BLEND_COLOR                                              0x0000034c
#define NV056_SET_BLEND_COLOR_V                                                  31:0


#define NV056_SET_BLEND_EQUATION                                           0x00000350
#define NV056_SET_BLEND_EQUATION_V                                               31:0
#define NV056_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                           0x0000800A
#define NV056_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                   0x0000800B
#define NV056_SET_BLEND_EQUATION_V_FUNC_ADD                                0x00008006
#define NV056_SET_BLEND_EQUATION_V_MIN                                     0x00008007
#define NV056_SET_BLEND_EQUATION_V_MAX                                     0x00008008


#define NV056_SET_DEPTH_FUNC                                               0x00000354
#define NV056_SET_DEPTH_FUNC_V                                                   31:0
#define NV056_SET_DEPTH_FUNC_V_NEVER                                       0x00000200
#define NV056_SET_DEPTH_FUNC_V_LESS                                        0x00000201
#define NV056_SET_DEPTH_FUNC_V_EQUAL                                       0x00000202
#define NV056_SET_DEPTH_FUNC_V_LEQUAL                                      0x00000203
#define NV056_SET_DEPTH_FUNC_V_GREATER                                     0x00000204
#define NV056_SET_DEPTH_FUNC_V_NOTEQUAL                                    0x00000205
#define NV056_SET_DEPTH_FUNC_V_GEQUAL                                      0x00000206
#define NV056_SET_DEPTH_FUNC_V_ALWAYS                                      0x00000207


#define NV056_SET_COLOR_MASK                                               0x00000358
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                 31:24
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                       0x00000001
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE                                   23:16
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                        0x00000000
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                         0x00000001
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                  15:8
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                       0x00000001
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                    7:0
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                       0x00000000
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                        0x00000001


#define NV056_SET_DEPTH_MASK                                               0x0000035c
#define NV056_SET_DEPTH_MASK_V                                                   31:0
#define NV056_SET_DEPTH_MASK_V_FALSE                                       0x00000000
#define NV056_SET_DEPTH_MASK_V_TRUE                                        0x00000001


#define NV056_SET_STENCIL_MASK                                             0x00000360
#define NV056_SET_STENCIL_MASK_V                                                 31:0


#define NV056_SET_STENCIL_FUNC                                             0x00000364
#define NV056_SET_STENCIL_FUNC_V                                                 31:0
#define NV056_SET_STENCIL_FUNC_V_NEVER                                     0x00000200
#define NV056_SET_STENCIL_FUNC_V_LESS                                      0x00000201
#define NV056_SET_STENCIL_FUNC_V_EQUAL                                     0x00000202
#define NV056_SET_STENCIL_FUNC_V_LEQUAL                                    0x00000203
#define NV056_SET_STENCIL_FUNC_V_GREATER                                   0x00000204
#define NV056_SET_STENCIL_FUNC_V_NOTEQUAL                                  0x00000205
#define NV056_SET_STENCIL_FUNC_V_GEQUAL                                    0x00000206
#define NV056_SET_STENCIL_FUNC_V_ALWAYS                                    0x00000207


#define NV056_SET_STENCIL_FUNC_REF                                         0x00000368
#define NV056_SET_STENCIL_FUNC_REF_V                                             31:0


#define NV056_SET_STENCIL_FUNC_MASK                                        0x0000036c
#define NV056_SET_STENCIL_FUNC_MASK_V                                            31:0


#define NV056_SET_STENCIL_OP_FAIL                                          0x00000370
#define NV056_SET_STENCIL_OP_FAIL_V                                              31:0
#define NV056_SET_STENCIL_OP_FAIL_V_KEEP                                   0x00001E00
#define NV056_SET_STENCIL_OP_FAIL_V_ZERO                                   0x00000000
#define NV056_SET_STENCIL_OP_FAIL_V_REPLACE                                0x00001E01
#define NV056_SET_STENCIL_OP_FAIL_V_INCRSAT                                0x00001E02
#define NV056_SET_STENCIL_OP_FAIL_V_DECRSAT                                0x00001E03
#define NV056_SET_STENCIL_OP_FAIL_V_INVERT                                 0x0000150A
#define NV056_SET_STENCIL_OP_FAIL_V_INCR                                   0x00008507
#define NV056_SET_STENCIL_OP_FAIL_V_DECR                                   0x00008508


#define NV056_SET_STENCIL_OP_ZFAIL                                         0x00000374
#define NV056_SET_STENCIL_OP_ZFAIL_V                                             31:0
#define NV056_SET_STENCIL_OP_ZFAIL_V_KEEP                                  0x00001E00
#define NV056_SET_STENCIL_OP_ZFAIL_V_ZERO                                  0x00000000
#define NV056_SET_STENCIL_OP_ZFAIL_V_REPLACE                               0x00001E01
#define NV056_SET_STENCIL_OP_ZFAIL_V_INCRSAT                               0x00001E02
#define NV056_SET_STENCIL_OP_ZFAIL_V_DECRSAT                               0x00001E03
#define NV056_SET_STENCIL_OP_ZFAIL_V_INVERT                                0x0000150A
#define NV056_SET_STENCIL_OP_ZFAIL_V_INCR                                  0x00008507
#define NV056_SET_STENCIL_OP_ZFAIL_V_DECR                                  0x00008508


#define NV056_SET_STENCIL_OP_ZPASS                                         0x00000378
#define NV056_SET_STENCIL_OP_ZPASS_V                                             31:0
#define NV056_SET_STENCIL_OP_ZPASS_V_KEEP                                  0x00001E00
#define NV056_SET_STENCIL_OP_ZPASS_V_ZERO                                  0x00000000
#define NV056_SET_STENCIL_OP_ZPASS_V_REPLACE                               0x00001E01
#define NV056_SET_STENCIL_OP_ZPASS_V_INCRSAT                               0x00001E02
#define NV056_SET_STENCIL_OP_ZPASS_V_DECRSAT                               0x00001E03
#define NV056_SET_STENCIL_OP_ZPASS_V_INVERT                                0x0000150A
#define NV056_SET_STENCIL_OP_ZPASS_V_INCR                                  0x00008507
#define NV056_SET_STENCIL_OP_ZPASS_V_DECR                                  0x00008508


#define NV056_SET_SHADE_MODE                                               0x0000037c
#define NV056_SET_SHADE_MODE_V                                                   31:0
#define NV056_SET_SHADE_MODE_V_FLAT                                        0x00001D00
#define NV056_SET_SHADE_MODE_V_SMOOTH                                      0x00001D01


#define NV056_SET_LINE_WIDTH                                               0x00000380
#define NV056_SET_LINE_WIDTH_V                                                   31:0


#define NV056_SET_POLYGON_OFFSET_SCALE_FACTOR                              0x00000384
#define NV056_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                  31:0


#define NV056_SET_POLYGON_OFFSET_BIAS                                      0x00000388
#define NV056_SET_POLYGON_OFFSET_BIAS_V                                          31:0


#define NV056_SET_FRONT_POLYGON_MODE                                       0x0000038c
#define NV056_SET_FRONT_POLYGON_MODE_V                                           31:0
#define NV056_SET_FRONT_POLYGON_MODE_V_POINT                               0x00001B00
#define NV056_SET_FRONT_POLYGON_MODE_V_LINE                                0x00001B01
#define NV056_SET_FRONT_POLYGON_MODE_V_FILL                                0x00001B02


#define NV056_SET_BACK_POLYGON_MODE                                        0x00000390
#define NV056_SET_BACK_POLYGON_MODE_V                                            31:0
#define NV056_SET_BACK_POLYGON_MODE_V_POINT                                0x00001B00
#define NV056_SET_BACK_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV056_SET_BACK_POLYGON_MODE_V_FILL                                 0x00001B02


#define NV056_SET_CLIP_MIN                                                 0x00000394
#define NV056_SET_CLIP_MIN_V                                                     31:0


#define NV056_SET_CLIP_MAX                                                 0x00000398
#define NV056_SET_CLIP_MAX_V                                                     31:0


#define NV056_SET_CULL_FACE                                                0x0000039c
#define NV056_SET_CULL_FACE_V                                                    31:0
#define NV056_SET_CULL_FACE_V_FRONT                                        0x00000404
#define NV056_SET_CULL_FACE_V_BACK                                         0x00000405
#define NV056_SET_CULL_FACE_V_FRONT_AND_BACK                               0x00000408


#define NV056_SET_FRONT_FACE                                               0x000003a0
#define NV056_SET_FRONT_FACE_V                                                   31:0
#define NV056_SET_FRONT_FACE_V_CW                                          0x00000900
#define NV056_SET_FRONT_FACE_V_CCW                                         0x00000901


#define NV056_SET_NORMALIZATION_ENABLE                                     0x000003a4
#define NV056_SET_NORMALIZATION_ENABLE_V                                         31:0
#define NV056_SET_NORMALIZATION_ENABLE_V_FALSE                             0x00000000
#define NV056_SET_NORMALIZATION_ENABLE_V_TRUE                              0x00000001


#define NV056_SET_MATERIAL_EMISSION(i)                             (0x000003a8+(i)*4)


#define NV056_SET_MATERIAL_ALPHA                                           0x000003b4


#define NV056_SET_SPECULAR_ENABLE                                          0x000003b8
#define NV056_SET_SPECULAR_ENABLE_V                                              31:0
#define NV056_SET_SPECULAR_ENABLE_V_FALSE                                  0x00000000
#define NV056_SET_SPECULAR_ENABLE_V_TRUE                                   0x00000001


#define NV056_SET_LIGHT_ENABLE_MASK                                        0x000003bc
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0                                        1:0
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1                                        3:2
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2                                        5:4
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3                                        7:6
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4                                        9:8
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5                                      11:10
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6                                      13:12
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7                                      15:14
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                            0x00000003


#define NV056_SET_TEXGEN_S(i)                                     (0x000003c0+(i)*16)
#define NV056_SET_TEXGEN_S_V                                                     31:0
#define NV056_SET_TEXGEN_S_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_S_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_S_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_S_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_S_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_S_V_SPHERE_MAP                                    0x00002402
#define NV056_SET_TEXGEN_S_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_T(i)                                     (0x000003c4+(i)*16)
#define NV056_SET_TEXGEN_T_V                                                     31:0
#define NV056_SET_TEXGEN_T_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_T_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_T_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_T_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_T_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_T_V_SPHERE_MAP                                    0x00002402
#define NV056_SET_TEXGEN_T_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_R(i)                                     (0x000003c8+(i)*16)
#define NV056_SET_TEXGEN_R_V                                                     31:0
#define NV056_SET_TEXGEN_R_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_R_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_R_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_R_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_R_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_R_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_Q(i)                                     (0x000003cc+(i)*16)
#define NV056_SET_TEXGEN_Q_V                                                     31:0
#define NV056_SET_TEXGEN_Q_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_Q_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_Q_V_OBJECT_LINEAR                                 0x00002401


#define NV056_SET_TEXTURE_MATRIX0_ENABLE                                   0x000003e0
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V                                       31:0
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                           0x00000000
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                            0x00000001


#define NV056_SET_TEXTURE_MATRIX1_ENABLE                                   0x000003e4
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V                                       31:0
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                           0x00000000
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                            0x00000001


#define NV056_SET_TLMODE                                                   0x000003e8
#define NV056_SET_TLMODE_PASSTHROUGH                                              0:0
#define NV056_SET_TLMODE_PASSTHROUGH_TRUE                                  0x00000001
#define NV056_SET_TLMODE_PASSTHROUGH_FALSE                                 0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_0                                               1:1
#define NV056_SET_TLMODE_W_DIVIDE_0_DISABLE                                0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_0_ENABLE                                 0x00000001
#define NV056_SET_TLMODE_W_DIVIDE_1                                               2:2
#define NV056_SET_TLMODE_W_DIVIDE_1_DISABLE                                0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_1_ENABLE                                 0x00000001


#define NV056_SET_POINT_SIZE                                               0x000003ec
#define NV056_SET_POINT_SIZE_V                                                   31:0


#define NV056_SET_SWATH_WIDTH                                              0x000003f0
#define NV056_SET_SWATH_WIDTH_V                                                  31:0
#define NV056_SET_SWATH_WIDTH_V_8                                          0x00000000
#define NV056_SET_SWATH_WIDTH_V_16                                         0x00000001
#define NV056_SET_SWATH_WIDTH_V_32                                         0x00000002
#define NV056_SET_SWATH_WIDTH_V_64                                         0x00000003


#define NV056_SET_FLAT_SHADE_OP                                            0x000003f4
#define NV056_SET_FLAT_SHADE_OP_V                                                31:0
#define NV056_SET_FLAT_SHADE_OP_V_LAST_VTX                                 0x00000000
#define NV056_SET_FLAT_SHADE_OP_V_FIRST_VTX                                0x00000001


#define NV056_SET_MODEL_VIEW_MATRIX0(i)                            (0x00000400+(i)*4)


#define NV056_SET_MODEL_VIEW_MATRIX1(i)                            (0x00000440+(i)*4)


#define NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                    (0x00000480+(i)*4)


#define NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                    (0x000004c0+(i)*4)


#define NV056_SET_COMPOSITE_MATRIX(i)                              (0x00000500+(i)*4)


#define NV056_SET_TEXTURE_MATRIX0(i)                               (0x00000540+(i)*4)


#define NV056_SET_TEXTURE_MATRIX1(i)                               (0x00000580+(i)*4)


#define NV056_SET_TEXGEN_SPLANE0(i)                                (0x00000600+(i)*4)


#define NV056_SET_TEXGEN_TPLANE0(i)                                (0x00000610+(i)*4)


#define NV056_SET_TEXGEN_RPLANE0(i)                                (0x00000620+(i)*4)


#define NV056_SET_TEXGEN_QPLANE0(i)                                (0x00000630+(i)*4)


#define NV056_SET_TEXGEN_SPLANE1(i)                                (0x00000640+(i)*4)


#define NV056_SET_TEXGEN_TPLANE1(i)                                (0x00000650+(i)*4)


#define NV056_SET_TEXGEN_RPLANE1(i)                                (0x00000660+(i)*4)


#define NV056_SET_TEXGEN_QPLANE1(i)                                (0x00000670+(i)*4)


#define NV056_SET_FOG_PARAMS(i)                                    (0x00000680+(i)*4)


#define NV056_SET_FOG_PLANE(i)                                     (0x0000068c+(i)*4)


#define NV056_SET_SPECULAR_PARAMS(i)                               (0x000006a0+(i)*4)


#define NV056_SET_SCENE_AMBIENT_COLOR(i)                           (0x000006c4+(i)*4)


#define NV056_SET_VIEWPORT_OFFSET(i)                               (0x000006e8+(i)*4)


#define NV056_SET_POINT_PARAMS(i)                                  (0x000006f8+(i)*4)


#define NV056_SET_EYE_POSITION(i)                                  (0x00000718+(i)*4)

#define NV056_SET_EYE_DIRECTION_SW(i)                              (0x0000072c+(i)*4)


#define NV056_SET_LIGHT_AMBIENT_COLOR(i,j)                 (0x00000800+(i)*128+(j)*4)


#define NV056_SET_LIGHT_DIFFUSE_COLOR(i,j)                 (0x0000080c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPECULAR_COLOR(i,j)                (0x00000818+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_RANGE(i)                           (0x00000824+(i)*128)


#define NV056_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)          (0x00000828+(i)*128+(j)*4)


#define NV056_SET_LIGHT_INFINITE_DIRECTION(i,j)            (0x00000834+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPOT_FALLOFF(i,j)                  (0x00000840+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPOT_DIRECTION(i,j)                (0x0000084c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_POSITION(i,j)                (0x0000085c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_ATTENUATION(i,j)             (0x00000868+(i)*128+(j)*4)


#define NV056_SET_VERTEX3F(i)                                      (0x00000c00+(i)*4)


#define NV056_SET_VERTEX4F(i)                                      (0x00000c18+(i)*4)


#define NV056_SET_VERTEX4S(i)                                      (0x00000c28+(i)*4)


#define NV056_SET_NORMAL3F(i)                                      (0x00000c30+(i)*4)


#define NV056_SET_NORMAL3S(i)                                      (0x00000c40+(i)*2)


#define NV056_SET_DIFFUSE_COLOR4F(i)                               (0x00000c50+(i)*4)


#define NV056_SET_DIFFUSE_COLOR3F(i)                               (0x00000c60+(i)*4)


#define NV056_SET_DIFFUSE_COLOR4UB                                         0x00000c6c


#define NV056_SET_SPECULAR_COLOR4F(i)                              (0x00000c70+(i)*4)


#define NV056_SET_SPECULAR_COLOR3F(i)                              (0x00000c80+(i)*4)


#define NV056_SET_SPECULAR_COLOR4UB                                        0x00000c8c


#define NV056_SET_TEXCOORD0_2F(i)                                  (0x00000c90+(i)*4)


#define NV056_SET_TEXCOORD0_2S(i)                                  (0x00000c98+(i)*2)


#define NV056_SET_TEXCOORD0_4F(i)                                  (0x00000ca0+(i)*4)


#define NV056_SET_TEXCOORD0_4S(i)                                  (0x00000cb0+(i)*2)


#define NV056_SET_TEXCOORD1_2F(i)                                  (0x00000cb8+(i)*4)


#define NV056_SET_TEXCOORD1_2S(i)                                  (0x00000cc0+(i)*2)


#define NV056_SET_TEXCOORD1_4F(i)                                  (0x00000cc8+(i)*4)


#define NV056_SET_TEXCOORD1_4S(i)                                  (0x00000cd8+(i)*2)


#define NV056_SET_FOG1F                                                    0x00000ce0


#define NV056_SET_WEIGHT1F                                                 0x00000ce4


#define NV056_SET_EDGE_FLAG                                                0x00000cec


#define NV056_INVALIDATE_VERTEX_CACHE_FILE                                 0x00000cf0


#define NV056_INVALIDATE_VERTEX_FILE                                       0x00000cf4


#define NV056_TL_NOP                                                       0x00000cf8


#define NV056_TL_SYNC                                                      0x00000cfc


#define NV056_SET_VERTEX_ARRAY_OFFSET                                      0x00000d00
#define NV056_SET_VERTEX_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_VERTEX_ARRAY_FORMAT                                      0x00000d04
#define NV056_SET_VERTEX_ARRAY_FORMAT_W                                         31:24
#define NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE                               0x00000000
#define NV056_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                            0x00000001
#define NV056_SET_VERTEX_ARRAY_FORMAT_STRIDE                                     23:8
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2                               0x00000002
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_4                               0x00000004
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_DIFFUSE_ARRAY_OFFSET                                     0x00000d08
#define NV056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                    27:0


#define NV056_SET_DIFFUSE_ARRAY_FORMAT                                     0x00000d0c
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                    31:8
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                       7:4
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                       3:0
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA             0x00000000
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA             0x00000004


#define NV056_SET_SPECULAR_ARRAY_OFFSET                                    0x00000d10
#define NV056_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                   27:0


#define NV056_SET_SPECULAR_ARRAY_FORMAT                                    0x00000d14
#define NV056_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                   31:8
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE                                      7:4
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE                                      3:0
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004


#define NV056_SET_TEX_COORD0_ARRAY_OFFSET                                  0x00000d18
#define NV056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                 27:0


#define NV056_SET_TEX_COORD0_ARRAY_FORMAT                                  0x00000d1c
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                 31:8
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                    7:4
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                    3:0
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV056_SET_TEX_COORD1_ARRAY_OFFSET                                  0x00000d20
#define NV056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                 27:0


#define NV056_SET_TEX_COORD1_ARRAY_FORMAT                                  0x00000d24
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                 31:8
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                    7:4
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                    3:0
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV056_SET_NORMAL_ARRAY_OFFSET                                      0x00000d28
#define NV056_SET_NORMAL_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_NORMAL_ARRAY_FORMAT                                      0x00000d2c
#define NV056_SET_NORMAL_ARRAY_FORMAT_STRIDE                                     31:8
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_WEIGHT_ARRAY_OFFSET                                      0x00000d30
#define NV056_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_WEIGHT_ARRAY_FORMAT                                      0x00000d34
#define NV056_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                     31:8
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                               0x00000001
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_FOG_ARRAY_OFFSET                                         0x00000d38
#define NV056_SET_FOG_ARRAY_OFFSET_OFFSET                                        27:0


#define NV056_SET_FOG_ARRAY_FORMAT                                         0x00000d3c
#define NV056_SET_FOG_ARRAY_FORMAT_STRIDE                                        31:8
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE                                           7:4
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE_0                                  0x00000000
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE_1                                  0x00000001
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE                                           3:0
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                              0x00000001
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                              0x00000002


#define NV056_SET_BEGIN_END                                                0x00000dfc
#define NV056_SET_BEGIN_END_OP                                                   31:0
#define NV056_SET_BEGIN_END_OP_END                                         0x00000000
#define NV056_SET_BEGIN_END_OP_POINTS                                      0x00000001
#define NV056_SET_BEGIN_END_OP_LINES                                       0x00000002
#define NV056_SET_BEGIN_END_OP_LINE_LOOP                                   0x00000003
#define NV056_SET_BEGIN_END_OP_LINE_STRIP                                  0x00000004
#define NV056_SET_BEGIN_END_OP_TRIANGLES                                   0x00000005
#define NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP                              0x00000006
#define NV056_SET_BEGIN_END_OP_TRIANGLE_FAN                                0x00000007
#define NV056_SET_BEGIN_END_OP_QUADS                                       0x00000008
#define NV056_SET_BEGIN_END_OP_QUAD_STRIP                                  0x00000009
#define NV056_SET_BEGIN_END_OP_POLYGON                                     0x0000000A


#define NV056_ARRAY_ELEMENT16(i)                                   (0x00000e00+(i)*2)


#define NV056_SET_BEGIN_END2                                               0x000010fc
#define NV056_SET_BEGIN_END2_OP                                                  31:0
#define NV056_SET_BEGIN_END2_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END2_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END2_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END2_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END2_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END2_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END2_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END2_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END2_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END2_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END2_OP_POLYGON                                    0x0000000A


#define NV056_ARRAY_ELEMENT32(i)                                   (0x00001100+(i)*4)


#define NV056_SET_BEGIN_END3                                               0x000013fc
#define NV056_SET_BEGIN_END3_OP                                                  31:0
#define NV056_SET_BEGIN_END3_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END3_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END3_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END3_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END3_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END3_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END3_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END3_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END3_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END3_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END3_OP_POLYGON                                    0x0000000A


#define NV056_DRAW_ARRAYS(i)                                       (0x00001400+(i)*4)
#define NV056_DRAW_ARRAYS_COUNT                                                 31:24
#define NV056_DRAW_ARRAYS_START_INDEX                                            23:0


#define NV056_SET_MATERIAL_EMISSION_SW(i)                          (0x00001628+(i)*4)

#define NV056_SET_BEGIN_END4                                               0x000017fc
#define NV056_SET_BEGIN_END4_OP                                                  31:0
#define NV056_SET_BEGIN_END4_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END4_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END4_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END4_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END4_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END4_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END4_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END4_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END4_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END4_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END4_OP_POLYGON                                    0x0000000A


#define NV056_INLINE_ARRAY(i)                                      (0x00001800+(i)*4)


/* class NV04_CONTEXT_COLOR_KEY */
#define  NV04_CONTEXT_COLOR_KEY                                    (0x00000057)
/* NvNotification[] elements */
#define NV057_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV057_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV057_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV057_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV057_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV057_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV057_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV057_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV057_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetColor;                /* color key value                  0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv057Typedef, Nv04ContextColorKey;
#define NV057_TYPEDEF                                       Nv04ContextColorKey
/* dma method offsets, fields, and values */
#define NV057_SET_OBJECT                                           (0x00000000)
#define NV057_NO_OPERATION                                         (0x00000100)
#define NV057_NOTIFY                                               (0x00000104)
#define NV057_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV057_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV057_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV057_SET_COLOR_FORMAT                                     (0x00000300)
#define NV057_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV057_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV057_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV057_SET_COLOR                                            (0x00000304)
/* obsolete stuff */
#define NV4_CONTEXT_COLOR_KEY                                      (0x00000057)
#define Nv4ContextColorKey                                  Nv04ContextColorKey
#define nv4ContextColorKey                                  Nv04ContextColorKey
#define nv04ContextColorKey                                 Nv04ContextColorKey


/* class NV03_CONTEXT_SURFACE_2D_DESTINATION */
#define  NV03_CONTEXT_SURFACE_2D_DESTINATION                       (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV058_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface2dDestination;
#define NV058_TYPEDEF                           Nv03ContextSurface2dDestination
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_0                                     (0x00000058)
#define NV3_CONTEXT_SURFACE_0                                      (0x00000058)
#define Nv03ContextSurface0                     Nv03ContextSurface2dDestination
#define nv03ContextSurface0                     Nv03ContextSurface2dDestination
#define Nv3ContextSurface0                      Nv03ContextSurface2dDestination
#define nv3ContextSurface0                      Nv03ContextSurface2dDestination
#define nv03ContextSurface2dDestination         Nv03ContextSurface2dDestination


/* class NV03_CONTEXT_SURFACE_2D_SOURCE */
#define  NV03_CONTEXT_SURFACE_2D_SOURCE                            (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV059_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface2dSource;
#define NV059_TYPEDEF                                Nv03ContextSurface2dSource
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_1                                     (0x00000059)
#define NV3_CONTEXT_SURFACE_1                                      (0x00000059)
#define Nv03ContextSurface1                          Nv03ContextSurface2dSource
#define nv03ContextSurface1                          Nv03ContextSurface2dSource
#define Nv3ContextSurface1                           Nv03ContextSurface2dSource
#define nv3ContextSurface1                           Nv03ContextSurface2dSource
#define nv03ContextSurface2dSource                   Nv03ContextSurface2dSource


/* class NV03_CONTEXT_SURFACE_3D_COLOR */
#define  NV03_CONTEXT_SURFACE_3D_COLOR                             (0x0000005A)
/* NvNotification[] elements */
#define NV05A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV05A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv05aTypedef, Nv03ContextSurface3dColor;
#define NV05A_TYPEDEF                                 Nv03ContextSurface3dColor
/* dma method offsets, fields, and values */
#define NV05A_SET_OBJECT                                           (0x00000000)
#define NV05A_NO_OPERATION                                         (0x00000100)
#define NV05A_NOTIFY                                               (0x00000104)
#define NV05A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05A_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05A_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_1              (0x01010001)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_2              (0x01000000)
#define NV05A_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05A_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05A_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_2                                     (0x0000005A)
#define NV3_CONTEXT_SURFACE_2                                      (0x0000005A)
#define Nv03ContextSurface2                           Nv03ContextSurface3dColor
#define nv03ContextSurface2                           Nv03ContextSurface3dColor
#define Nv3ContextSurface2                            Nv03ContextSurface3dColor
#define nv3ContextSurface2                            Nv03ContextSurface3dColor
#define nv03ContextSurface3dColor                     Nv03ContextSurface3dColor


/* class NV03_CONTEXT_SURFACE_3D_DEPTH */
#define  NV03_CONTEXT_SURFACE_3D_DEPTH                             (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05B_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 NvDummy;                   /* ignored                          0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3dDepth;
#define NV05B_TYPEDEF                                 Nv03ContextSurface3dDepth
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_LE_W16_0                            (0x01010000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_1                            (0x01010001)
#define NV05B_SET_COLOR_FORMAT_LE_W16_2                            (0x01000000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_3                            (0x00000001)
#define NV05B_DUMMY                                                (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_3                                     (0x0000005B)
#define NV3_CONTEXT_SURFACE_3                                      (0x0000005B)
#define Nv03ContextSurface3                           Nv03ContextSurface3dDepth
#define nv03ContextSurface3                           Nv03ContextSurface3dDepth
#define Nv3ContextSurface3                            Nv03ContextSurface3dDepth
#define nv3ContextSurface3                            Nv03ContextSurface3dDepth
#define nv03ContextSurface3dDepth                     Nv03ContextSurface3dDepth


/* class NV04_RENDER_SOLID_LIN */
#define  NV04_RENDER_SOLID_LIN                                     (0x0000005C)
/* NvNotification[] elements */
#define NV05C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05C_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05C_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05C_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point0;                 /* y_x S16_S16 in pixels            0400-0403*/
  NvV32 point1;                 /* y_x S16_S16 in pixels            0404-0407*/
 } Lin[16];                     /* end of aliased methods in array      -047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 point0X;                /* in pixels, 0 at left                0-   3*/
  NvS32 point0Y;                /* in pixels, 0 at top                 4-   7*/
  NvS32 point1X;                /* in pixels, 0 at left                8-   b*/
  NvS32 point1Y;                /* in pixels, 0 at top                 c-   f*/
 } Lin32[8];                    /* end of aliased methods in array      -04ff*/
 NvV32 PolyLin[32];             /* y_x S16_S16 in pixels            0500-057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } PolyLin32[16];               /* end of aliased methods in array      -05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorPolyLin[16];            /* end of aliased methods in array      -067f*/
 NvV32 Reserved03[0x660];
} Nv05cTypedef, Nv04RenderSolidLin;
#define NV05C_TYPEDEF                                        Nv04RenderSolidLin
/* dma method offsets, fields, and values */
#define NV05C_SET_OBJECT                                           (0x00000000)
#define NV05C_NO_OPERATION                                         (0x00000100)
#define NV05C_NOTIFY                                               (0x00000104)
#define NV05C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05C_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05C_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05C_SET_OPERATION                                        (0x000002FC)
#define NV05C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05C_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05C_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05C_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05C_COLOR                                                (0x00000304)
#define NV05C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0_X                                         15:0
#define NV05C_LIN_POINT0_Y                                         31:16
#define NV05C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT1_X                                         15:0
#define NV05C_LIN_POINT1_Y                                         31:16
#define NV05C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV05C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV05C_POLY_LIN_X                                           15:0
#define NV05C_POLY_LIN_Y                                           31:16
#define NV05C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV05C_COLOR_POLY_LIN_POINT_Y                               31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_LIN                                       (0x0000005C)
#define Nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv04RenderSolidLin                                   Nv04RenderSolidLin


/* class NV04_RENDER_SOLID_TRIANGLE */
#define  NV04_RENDER_SOLID_TRIANGLE                                (0x0000005D)
/* NvNotification[] elements */
#define NV05D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05D_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05D_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05D_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x002];
 NvV32 TrianglePoint0;          /* y_x S16_S16 in pixels            0310-0313*/
 NvV32 TrianglePoint1;          /* y_x S16_S16 in pixels            0314-0317*/
 NvV32 TrianglePoint2;          /* y_x S16_S16 in pixels            0318-031b*/
 NvV32 Reserved03[0x001];
 NvS32 Triangle32Point0X;       /* in pixels, 0 at left             0320-0323*/
 NvS32 Triangle32Point0Y;       /* in pixels, 0 at top              0324-0327*/
 NvS32 Triangle32Point1X;       /* in pixels, 0 at left             0328-032b*/
 NvS32 Triangle32Point1Y;       /* in pixels, 0 at top              032c-032f*/
 NvS32 Triangle32Point2X;       /* in pixels, 0 at left             0330-0333*/
 NvS32 Triangle32Point2Y;       /* in pixels, 0 at top              0334-0337*/
 NvV32 Reserved04[0x032];
 NvV32 Trimesh[32];             /* y_x S16_S16 in pixels            0400-047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } Trimesh32[16];               /* end of aliased methods in array      -04ff*/
 struct {                       /* start aliased methods in array   0500-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point0;                 /* y_x S16_S16 in pixels               4-   7*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               8-   b*/
  NvV32 point2;                 /* y_x S16_S16 in pixels               c-   f*/
 } ColorTriangle[8];            /* end of aliased methods in array      -057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorTrimesh[16];            /* end of aliased methods in array      -05ff*/
 NvV32 Reserved05[0x680];
} Nv05dTypedef, Nv04RenderSolidTriangle;
#define NV05D_TYPEDEF                                   Nv04RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV05D_SET_OBJECT                                           (0x00000000)
#define NV05D_NO_OPERATION                                         (0x00000100)
#define NV05D_NOTIFY                                               (0x00000104)
#define NV05D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05D_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05D_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05D_SET_OPERATION                                        (0x000002FC)
#define NV05D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05D_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05D_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05D_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05D_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05D_COLOR                                                (0x00000304)
#define NV05D_TRIANGLE                                             (0x00000310)
#define NV05D_TRIANGLE_POINT0                                      (0x00000310)
#define NV05D_TRIANGLE_POINT0_X                                    15:0
#define NV05D_TRIANGLE_POINT0_Y                                    31:16
#define NV05D_TRIANGLE_POINT1                                      (0x00000314)
#define NV05D_TRIANGLE_POINT1_X                                    15:0
#define NV05D_TRIANGLE_POINT1_Y                                    31:16
#define NV05D_TRIANGLE_POINT2                                      (0x00000318)
#define NV05D_TRIANGLE_POINT2_X                                    15:0
#define NV05D_TRIANGLE_POINT2_Y                                    31:16
#define NV05D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV05D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV05D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV05D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV05D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV05D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV05D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV05D_TRIMESH_X                                            15:0
#define NV05D_TRIMESH_Y                                            31:16
#define NV05D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV05D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT_X                                15:0
#define NV05D_COLOR_TRIMESH_POINT_Y                                31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_TRIANGLE                                  (0x0000005D)
#define Nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv04RenderSolidTriangle                         Nv04RenderSolidTriangle


/* class NV04_RENDER_SOLID_RECTANGLE */
#define  NV04_RENDER_SOLID_RECTANGLE                               (0x0000005E)
/* NvNotification[] elements */
#define NV05E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05E_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05E_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* y_x S16_S16                         0-   3*/
  NvV32 size;                   /* height_width U16_U16                4-   7*/
 } Rectangle[16];               /* end of aliased methods in array      -047f*/
 NvV32 Reserved03[0x6e0];
} Nv05eTypedef, Nv04RenderSolidRectangle;
#define NV05E_TYPEDEF                                  Nv04RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV05E_SET_OBJECT                                           (0x00000000)
#define NV05E_NO_OPERATION                                         (0x00000100)
#define NV05E_NOTIFY                                               (0x00000104)
#define NV05E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05E_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05E_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05E_SET_OPERATION                                        (0x000002FC)
#define NV05E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05E_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05E_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05E_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05E_COLOR                                                (0x00000304)
#define NV05E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT_X                                    15:0
#define NV05E_RECTANGLE_POINT_Y                                    31:16
#define NV05E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV05E_RECTANGLE_SIZE_HEIGHT                                31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_RECTANGLE                                 (0x0000005E)
#define Nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv04RenderSolidRectangle                       Nv04RenderSolidRectangle


/* class NV04_IMAGE_BLIT */
#define  NV04_IMAGE_BLIT                                           (0x0000005F)
/* NvNotification[] elements */
#define NV05F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV05F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved02[0x73d];
} Nv05fTypedef, Nv04ImageBlit;
#define NV05F_TYPEDEF                                             Nv04ImageBlit
/* dma method offsets, fields, and values */
#define NV05F_SET_OBJECT                                           (0x00000000)
#define NV05F_NO_OPERATION                                         (0x00000100)
#define NV05F_NOTIFY                                               (0x00000104)
#define NV05F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV05F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV05F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV05F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV05F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV05F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV05F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV05F_SET_OPERATION                                        (0x000002FC)
#define NV05F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05F_CONTROL_POINT_IN                                     (0x00000300)
#define NV05F_CONTROL_POINT_IN_X                                   15:0
#define NV05F_CONTROL_POINT_IN_Y                                   31:16
#define NV05F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV05F_CONTROL_POINT_OUT_X                                  15:0
#define NV05F_CONTROL_POINT_OUT_Y                                  31:16
#define NV05F_SIZE                                                 (0x00000308)
#define NV05F_SIZE_WIDTH                                           15:0
#define NV05F_SIZE_HEIGHT                                          31:16
/* obsolete stuff */
#define NV4_IMAGE_BLIT                                             (0x0000005F)
#define Nv4ImageBlit                                              Nv04ImageBlit
#define nv4ImageBlit                                              Nv04ImageBlit
#define nv04ImageBlit                                             Nv04ImageBlit


/* class NV04_INDEXED_IMAGE_FROM_CPU */
#define  NV04_INDEXED_IMAGE_FROM_CPU                               (0x00000060)
/* NvNotification[] elements */
#define NV060_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV060_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV060_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV060_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV060_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV060_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV060_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08F];
 NvV32 SetColorConversion;      /* NV060_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV060_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV060_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV060_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv060Typedef, Nv04IndexedImageFromCpu;
#define NV060_TYPEDEF                                   Nv04IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV060_SET_OBJECT                                           (0x00000000)
#define NV060_NO_OPERATION                                         (0x00000100)
#define NV060_NOTIFY                                               (0x00000104)
#define NV060_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV060_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV060_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV060_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV060_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV060_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV060_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV060_SET_CONTEXT_ROP                                      (0x00000194)
#define NV060_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV060_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV060_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV060_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV060_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV060_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV060_SET_OPERATION                                        (0x000003E4)
#define NV060_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV060_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV060_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV060_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV060_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV060_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV060_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV060_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV060_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV060_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV060_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV060_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV060_INDEX_FORMAT                                         (0x000003EC)
#define NV060_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV060_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV060_LUT_OFFSET                                           (0x000003F0)
#define NV060_POINT                                                (0x000003F4)
#define NV060_POINT_X                                              15:0
#define NV060_POINT_Y                                              31:16
#define NV060_SIZE_OUT                                             (0x000003F8)
#define NV060_SIZE_OUT_WIDTH                                       15:0
#define NV060_SIZE_OUT_HEIGHT                                      31:16
#define NV060_SIZE_IN                                              (0x000003FC)
#define NV060_SIZE_IN_WIDTH                                        15:0
#define NV060_SIZE_IN_HEIGHT                                       31:16
#define NV060_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_INDEXED_IMAGE_FROM_CPU                                 (0x00000060)
#define Nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv04IndexedImageFromCpu                         Nv04IndexedImageFromCpu


/* class NV04_IMAGE_FROM_CPU */
#define  NV04_IMAGE_FROM_CPU                                       (0x00000061)
/* NvNotification[] elements */
#define NV061_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV061_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV061_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV061_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV061_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV061_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV061_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV061_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV061_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv061Typedef, Nv04ImageFromCpu;
#define NV061_TYPEDEF                                          Nv04ImageFromCpu
/* dma method offsets, fields, and values */
#define NV061_SET_OBJECT                                           (0x00000000)
#define NV061_NO_OPERATION                                         (0x00000100)
#define NV061_NOTIFY                                               (0x00000104)
#define NV061_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV061_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV061_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV061_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV061_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV061_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV061_SET_CONTEXT_ROP                                      (0x00000190)
#define NV061_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV061_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV061_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV061_SET_OPERATION                                        (0x000002FC)
#define NV061_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV061_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV061_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV061_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV061_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV061_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV061_SET_COLOR_FORMAT                                     (0x00000300)
#define NV061_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV061_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV061_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV061_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV061_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV061_POINT                                                (0x00000304)
#define NV061_POINT_X                                              15:0
#define NV061_POINT_Y                                              31:16
#define NV061_SIZE_OUT                                             (0x00000308)
#define NV061_SIZE_OUT_WIDTH                                       15:0
#define NV061_SIZE_OUT_HEIGHT                                      31:16
#define NV061_SIZE_IN                                              (0x0000030C)
#define NV061_SIZE_IN_WIDTH                                        15:0
#define NV061_SIZE_IN_HEIGHT                                       31:16
#define NV061_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_IMAGE_FROM_CPU                                         (0x00000061)
#define Nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv04ImageFromCpu                                       Nv04ImageFromCpu


/* class NV10_CONTEXT_SURFACES_2D */
#define  NV10_CONTEXT_SURFACES_2D                                  (0x00000062)
/* NvNotification[] elements */
#define NV062_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV062_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV062_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV062_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV062_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV062_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV062_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV062_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImageSource;/* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05d];
 NvV32 SetColorFormat;          /* NV062_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetPitch;                /* destin_source U16_U16            0304-0307*/
 NvU32 SetOffsetSource;         /* byte offset of top-left pixel    0308-030b*/
 NvU32 SetOffsetDestin;         /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved02[0x73c];
} Nv062Typedef, Nv10ContextSurfaces2d;
#define NV062_TYPEDEF                                     Nv10ContextSurfaces2d
/* dma method offsets, fields, and values */
#define NV062_SET_OBJECT                                           (0x00000000)
#define NV062_NO_OPERATION                                         (0x00000100)
#define NV062_NOTIFY                                               (0x00000104)
#define NV062_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV062_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV062_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV062_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV062_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV062_SET_COLOR_FORMAT                                     (0x00000300)
#define NV062_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV062_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV062_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV062_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV062_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV062_SET_PITCH                                            (0x00000304)
#define NV062_SET_PITCH_SOURCE                                     15:0
#define NV062_SET_PITCH_DESTIN                                     31:16
#define NV062_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV062_SET_OFFSET_DESTIN                                    (0x0000030C)


/* class NV05_SCALED_IMAGE_FROM_MEMORY */
#define  NV05_SCALED_IMAGE_FROM_MEMORY                             (0x00000063)
/* NvNotification[] elements */
#define NV063_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV063_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV063_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV063_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV063_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV063_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV063_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV063_SET_COLOR_CONVERSION_*     02fc-02ff*/
 NvV32 SetColorFormat;          /* NV063_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV063_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv063Typedef, Nv05ScaledImageFromMemory;
#define NV063_TYPEDEF                                 Nv05ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV063_SET_OBJECT                                           (0x00000000)
#define NV063_NO_OPERATION                                         (0x00000100)
#define NV063_NOTIFY                                               (0x00000104)
#define NV063_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV063_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV063_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV063_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV063_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV063_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV063_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV063_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV063_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV063_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV063_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV063_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV063_SET_COLOR_FORMAT                                     (0x00000300)
#define NV063_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV063_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV063_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV063_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV063_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV063_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV063_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV063_SET_OPERATION                                        (0x00000304)
#define NV063_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV063_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV063_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV063_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV063_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV063_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV063_CLIP_POINT                                           (0x00000308)
#define NV063_CLIP_POINT_X                                         15:0
#define NV063_CLIP_POINT_Y                                         31:16
#define NV063_CLIP_SIZE                                            (0x0000030C)
#define NV063_CLIP_SIZE_WIDTH                                      15:0
#define NV063_CLIP_SIZE_HEIGHT                                     31:16
#define NV063_IMAGE_OUT_POINT                                      (0x00000310)
#define NV063_IMAGE_OUT_POINT_X                                    15:0
#define NV063_IMAGE_OUT_POINT_Y                                    31:16
#define NV063_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV063_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV063_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV063_DS_DX                                                (0x00000318)
#define NV063_DT_DY                                                (0x0000031C)
#define NV063_IMAGE_IN_SIZE                                        (0x00000400)
#define NV063_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV063_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV063_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV063_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV063_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV063_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV063_IMAGE_IN                                             (0x0000040C)
#define NV063_IMAGE_IN_POINT_U                                     15:0
#define NV063_IMAGE_IN_POINT_V                                     31:16


/* class NV05_INDEXED_IMAGE_FROM_CPU */
#define  NV05_INDEXED_IMAGE_FROM_CPU                               (0x00000064)
/* NvNotification[] elements */
#define NV064_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV064_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV064_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV064_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV064_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV064_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV064_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08f];
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV064_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV064_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV064_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv064Typedef, Nv05IndexedImageFromCpu;
#define NV064_TYPEDEF                                   Nv05IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV064_SET_OBJECT                                           (0x00000000)
#define NV064_NO_OPERATION                                         (0x00000100)
#define NV064_NOTIFY                                               (0x00000104)
#define NV064_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV064_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV064_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV064_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV064_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV064_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV064_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV064_SET_CONTEXT_ROP                                      (0x00000194)
#define NV064_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV064_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV064_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV064_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV064_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV064_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV064_SET_OPERATION                                        (0x000003E4)
#define NV064_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV064_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV064_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV064_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV064_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV064_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV064_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV064_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV064_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV064_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV064_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV064_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV064_INDEX_FORMAT                                         (0x000003EC)
#define NV064_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV064_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV064_LUT_OFFSET                                           (0x000003F0)
#define NV064_POINT                                                (0x000003F4)
#define NV064_POINT_X                                              15:0
#define NV064_POINT_Y                                              31:16
#define NV064_SIZE_OUT                                             (0x000003F8)
#define NV064_SIZE_OUT_WIDTH                                       15:0
#define NV064_SIZE_OUT_HEIGHT                                      31:16
#define NV064_SIZE_IN                                              (0x000003FC)
#define NV064_SIZE_IN_WIDTH                                        15:0
#define NV064_SIZE_IN_HEIGHT                                       31:16
#define NV064_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)


/* class NV05_IMAGE_FROM_CPU */
#define  NV05_IMAGE_FROM_CPU                                       (0x00000065)
/* NvNotification[] elements */
#define NV065_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV065_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV065_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV065_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV065_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV065_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV065_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV065_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV065_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV065_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv065Typedef, Nv05ImageFromCpu;
#define NV065_TYPEDEF                                          Nv05ImageFromCpu
/* dma method offsets, fields, and values */
#define NV065_SET_OBJECT                                           (0x00000000)
#define NV065_NO_OPERATION                                         (0x00000100)
#define NV065_NOTIFY                                               (0x00000104)
#define NV065_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV065_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV065_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV065_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV065_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV065_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV065_SET_CONTEXT_ROP                                      (0x00000190)
#define NV065_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV065_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV065_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV065_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV065_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV065_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV065_SET_OPERATION                                        (0x000002FC)
#define NV065_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV065_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV065_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV065_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV065_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV065_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV065_SET_COLOR_FORMAT                                     (0x00000300)
#define NV065_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV065_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV065_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV065_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV065_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV065_POINT                                                (0x00000304)
#define NV065_POINT_X                                              15:0
#define NV065_POINT_Y                                              31:16
#define NV065_SIZE_OUT                                             (0x00000308)
#define NV065_SIZE_OUT_WIDTH                                       15:0
#define NV065_SIZE_OUT_HEIGHT                                      31:16
#define NV065_SIZE_IN                                              (0x0000030C)
#define NV065_SIZE_IN_WIDTH                                        15:0
#define NV065_SIZE_IN_HEIGHT                                       31:16
#define NV065_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


 /* class NV05_STRETCHED_IMAGE_FROM_CPU */
#define  NV05_STRETCHED_IMAGE_FROM_CPU                             (0x00000066)
/* NvNotification[] elements */
#define NV066_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV066_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV066_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV066_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV066_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV066_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct _Nv066Typedef{
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV066_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetColorConversion;      /* NV066_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV066_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV066_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DxDs;                    /* S12d20 dx/ds                     0308-030b*/
 NvV32 DyDt;                    /* S12d20 dy/dt                     030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv066Typedef, Nv05StretchedImageFromCpu;
#define NV066_TYPEDEF                                 Nv05StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV066_SET_OBJECT                                           (0x00000000)
#define NV066_NO_OPERATION                                         (0x00000100)
#define NV066_NOTIFY                                               (0x00000104)
#define NV066_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV066_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV066_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV066_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV066_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV066_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV066_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV066_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV066_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV066_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV066_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV066_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV066_SET_OPERATION                                        (0x000002FC)
#define NV066_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV066_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV066_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV066_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV066_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV066_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV066_SET_COLOR_FORMAT                                     (0x00000300)
#define NV066_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV066_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV066_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV066_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV066_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV066_SIZE_IN                                              (0x00000304)
#define NV066_SIZE_IN_WIDTH                                        15:0
#define NV066_SIZE_IN_HEIGHT                                       31:16
#define NV066_DX_DS                                                (0x00000308)
#define NV066_DY_DT                                                (0x0000030C)
#define NV066_CLIP_POINT                                           (0x00000310)
#define NV066_CLIP_POINT_X                                         15:0
#define NV066_CLIP_POINT_Y                                         31:16
#define NV066_CLIP_SIZE                                            (0x00000314)
#define NV066_CLIP_SIZE_WIDTH                                      15:0
#define NV066_CLIP_SIZE_HEIGHT                                     31:16
#define NV066_POINT_12D4                                           (0x00000318)
#define NV066_POINT_12D4_X                                         15:0
#define NV066_POINT_12D4_Y                                         31:16
#define NV066_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV10_VIDEO_LUT_CURSOR_DAC */
#define  NV10_VIDEO_LUT_CURSOR_DAC                                 (0x00000067)
/* NvNotification[] elements */
#define NV067_NOTIFIERS_NOTIFY                                     (0)
#define NV067_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV067_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV067_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV067_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV067_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV067_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV067_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV067_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV067_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV067_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV067_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV067_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV067_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV067_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV067_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV067_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_color_height_width           4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv067Typedef, Nv10VideoLutCursorDac;
#define NV067_TYPEDEF                                     Nv10VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV067_SET_OBJECT                                           (0x00000000)
#define NV067_NO_OPERATION                                         (0x00000100)
#define NV067_NOTIFY                                               (0x00000104)
#define NV067_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV067_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV067_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV067_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV067_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV067_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV067_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV067_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV067_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV067_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV067_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV067_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV067_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV067_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV067_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV067_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV067_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV067_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV067_SET_PAN_OFFSET                                       (0x00000220)
#define NV067_GET_OFFSET                                           (0x000002FC)
#define NV067_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV067_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV067_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV067_SET_IMAGE_FORMAT_WHEN                                30:20
#define NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)
#define NV067_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV067_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV067_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV067_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH                        7:0
#define NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT                       15:8
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR                        30:16
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5          (0x00000000)
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5            (0x00000001)
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8            (0x00000002)
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY                       31:31
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV067_SET_CURSOR_POINT                                     (0x00000330)
#define NV067_SET_CURSOR_POINT_X                                   15:0
#define NV067_SET_CURSOR_POINT_Y                                   31:16
#define NV067_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV067_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV067_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV067_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV067_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV067_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV067_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV067_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV067_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV067_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV067_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV067_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV067_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV067_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV067_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV067_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV067_SET_DAC_FORMAT_COLOR                                 19:16
#define NV067_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV067_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV067_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV067_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV067_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV067_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV067_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV067_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV067_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)

// Added by Chuck Moidel
/* class NV04_HEAP_OWNER */
#define NV04_HEAP_OWNER                                            (0x0000006F)
/* NvNotification[] fields and values */
#define NV06F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06fTypedef, Nv04HeapOwner;
#define NV06F_TYPEDEF                                              Nv04HeapOwner
#define Nv06FTypedef                                               Nv04HeapOwner

typedef NvV32 Nv070Typedef;

typedef NvV32 Nv071Typedef;


/* class NV04_CONTEXT_BETA */
#define  NV04_CONTEXT_BETA                                         (0x00000072)
/* NvNotification[] elements */
#define NV072_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV072_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV072_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV072_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV072_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV072_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV072_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV072_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetBetaFactor;           /* A8R8G8B8 beta values             0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv072Typedef, Nv04ContextBeta;
#define NV072_TYPEDEF                                           Nv04ContextBeta
/* dma method offsets, fields, and values */
#define NV072_SET_OBJECT                                           (0x00000000)
#define NV072_NO_OPERATION                                         (0x00000100)
#define NV072_NOTIFY                                               (0x00000104)
#define NV072_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV072_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV072_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV072_SET_BETA_FACTOR                                      (0x00000300)
#define NV072_SET_BETA_FACTOR_BLUE                                 7:0
#define NV072_SET_BETA_FACTOR_GREEN                                15:8
#define NV072_SET_BETA_FACTOR_RED                                  23:16
#define NV072_SET_BETA_FACTOR_ALPHA                                31:24
/* obsolete stuff */
#define NV4_CONTEXT_BETA                                           (0x00000072)
#define Nv4ContextBeta                                          Nv04ContextBeta
#define nv4ContextBeta                                          Nv04ContextBeta
#define nv04ContextBeta                                         Nv04ContextBeta

typedef NvV32 Nv073Typedef;

typedef NvV32 Nv074Typedef;

typedef NvV32 Nv075Typedef;


/* class NV04_STRETCHED_IMAGE_FROM_CPU */
#define  NV04_STRETCHED_IMAGE_FROM_CPU                             (0x00000076)
/* NvNotification[] elements */
#define NV076_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV076_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV076_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV076_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV076_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV076_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV076_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV076_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV076_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DeltaDxDu;               /* S12d20 ratio dx/du               0308-030b*/
 NvV32 DeltaDyDv;               /* S12d20 ratio dy/dv               030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv076Typedef, Nv04StretchedImageFromCpu;
#define NV076_TYPEDEF                                 Nv04StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV076_SET_OBJECT                                           (0x00000000)
#define NV076_NO_OPERATION                                         (0x00000100)
#define NV076_NOTIFY                                               (0x00000104)
#define NV076_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV076_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV076_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV076_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV076_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV076_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV076_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV076_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV076_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV076_SET_OPERATION                                        (0x000002FC)
#define NV076_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV076_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV076_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV076_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV076_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV076_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV076_SET_COLOR_FORMAT                                     (0x00000300)
#define NV076_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV076_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV076_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV076_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV076_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV076_SIZE_IN                                              (0x00000304)
#define NV076_SIZE_IN_WIDTH                                        15:0
#define NV076_SIZE_IN_HEIGHT                                       31:16
#define NV076_DELTA_DX_DU                                          (0x00000308)
#define NV076_DELTA_DY_DV                                          (0x0000030C)
#define NV076_CLIP_POINT                                           (0x00000310)
#define NV076_CLIP_POINT_X                                         15:0
#define NV076_CLIP_POINT_Y                                         31:16
#define NV076_CLIP_SIZE                                            (0x00000314)
#define NV076_CLIP_SIZE_WIDTH                                      15:0
#define NV076_CLIP_SIZE_HEIGHT                                     31:16
#define NV076_POINT_12D4                                           (0x00000318)
#define NV076_POINT_12D4_X                                         15:0
#define NV076_POINT_12D4_Y                                         31:16
#define NV076_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_STRETCHED_IMAGE_FROM_CPU                               (0x00000076)
#define Nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv04StretchedImageFromCpu                     Nv04StretchedImageFromCpu


/* class NV04_SCALED_IMAGE_FROM_MEMORY */
#define  NV04_SCALED_IMAGE_FROM_MEMORY                             (0x00000077)
/* NvNotification[] elements */
#define NV077_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV077_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV077_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV077_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV077_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV077_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV077_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x059];
 NvV32 SetColorFormat;          /* NV077_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV077_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DeltaDuDx;               /* S12d20 ratio du/dx               0318-031b*/
 NvV32 DeltaDvDy;               /* S12d20 ratio dv/dy               031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvU32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv077Typedef, Nv04ScaledImageFromMemory;
#define NV077_TYPEDEF                                 Nv04ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV077_SET_OBJECT                                           (0x00000000)
#define NV077_NO_OPERATION                                         (0x00000100)
#define NV077_NOTIFY                                               (0x00000104)
#define NV077_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV077_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV077_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV077_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV077_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV077_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV077_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV077_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV077_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV077_SET_COLOR_FORMAT                                     (0x00000300)
#define NV077_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV077_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV077_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV077_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV077_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV077_SET_OPERATION                                        (0x00000304)
#define NV077_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV077_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV077_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV077_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV077_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV077_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV077_CLIP_POINT                                           (0x00000308)
#define NV077_CLIP_POINT_X                                         15:0
#define NV077_CLIP_POINT_Y                                         31:16
#define NV077_CLIP_SIZE                                            (0x0000030C)
#define NV077_CLIP_SIZE_WIDTH                                      15:0
#define NV077_CLIP_SIZE_HEIGHT                                     31:16
#define NV077_IMAGE_OUT_POINT                                      (0x00000310)
#define NV077_IMAGE_OUT_POINT_X                                    15:0
#define NV077_IMAGE_OUT_POINT_Y                                    31:16
#define NV077_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV077_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV077_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV077_DELTA_DU_DX                                          (0x00000318)
#define NV077_DELTA_DV_DY                                          (0x0000031C)
#define NV077_IMAGE_IN_SIZE                                        (0x00000400)
#define NV077_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV077_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV077_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV077_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV077_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV077_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV077_IMAGE_IN                                             (0x0000040C)
#define NV077_IMAGE_IN_POINT_U                                     15:0
#define NV077_IMAGE_IN_POINT_V                                     31:16
/* obsolete stuff */
#define NV4_SCALED_IMAGE_FROM_MEMORY                               (0x00000077)
#define Nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv04ScaledImageFromMemory                     Nv04ScaledImageFromMemory

typedef NvV32 Nv078Typedef;

typedef NvV32 Nv079Typedef;

/* class NV10_VIDEO_OVERLAY */
#define  NV10_VIDEO_OVERLAY                                        (0x0000007A)
/* NvNotification[] elements */
#define NV07A_NOTIFIERS_NOTIFY                                     (0)
#define NV07A_NOTIFIERS_SET_OVERLAY(b)                             (1+(b))
/* NvNotification[] fields and values */
#define NV07A_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV07A_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV07A_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV07A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV07A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 StopOverlay[2];          /* NV07A_STOP_OVERLAY_*             0120-0127*/
 NvV32 Reserved01[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved02[0x006];
 NvV32 SetContextDmaOverlay[2]; /* NV01_CONTEXT_DMA                 019c-01a3*/
 NvV32 Reserved03[0x097];
 struct {                       /* start of methods in array        0400-    */
  NvV32 reserved05[0x015];      /* see text                           00-  53*/
  NvV32 luminance;              /* brightness_contrast S16_U8d8       54-  57*/
  NvV32 chrominance;            /* saturationSine_saturationCosine    58-  5b*/
  NvV32 colorKey;               /* see text                           5c-  5f*/
  NvU32 offset;                 /* byte offset of top-left texel      60-  63*/
  NvV32 sizeIn;                 /* height_width U16_U16               64-  67*/
  NvV32 pointIn;                /* t_s U12d4_U12d4                    68-  6b*/
  NvV32 duDx;                   /* U12d20 du/dx                       6c-  6f*/
  NvV32 dvDy;                   /* U12d20 dv/dy                       70-  73*/
  NvV32 pointOut;               /* y_x U16_U16                        74-  77*/
  NvV32 sizeOut;                /* height_width U16_U16               78-  7b*/
  NvV32 format;                 /* see text                           7c-  7f*/
 } SetOverlay[2];               /* end of methods in array              -04ff*/
 NvV32 SetOverlayPointOutA;     /* y_x U16_U16                      0500-0503*/
 NvV32 SetOverlayLuminanceA;    /* brightness_contrast S16_U8d8     0504-0507*/
 NvV32 SetOverlayChrominanceA;  /* saturationSine_saturationCosine  0508-050b*/
 NvV32 Reserved04[0x6bd];
} Nv07aTypedef, Nv10VideoOverlay;
#define NV07A_TYPEDEF                                          Nv10VideoOverlay
/* dma method offsets, fields, and values */
#define NV07A_SET_OBJECT                                           (0x00000000)
#define NV07A_NO_OPERATION                                         (0x00000100)
#define NV07A_NOTIFY                                               (0x00000104)
#define NV07A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07A_STOP_OVERLAY(b)                                      (0x00000120\
                                                                   +(b)*0x0004)
#define NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE                     (0x00000000)
#define NV07A_STOP_OVERLAY_BETWEEN_BUFFERS                         (0x00000001)
#define NV07A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07A_SET_CONTEXT_DMA_OVERLAY(b)                           (0x0000019C\
                                                                   +(b)*0x0004)
#define NV07A_SET_OVERLAY(b)                                       (0x00000400\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_LUMINANCE(b)                             (0x00000454\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_LUMINANCE_CONTRAST                       15:0
#define NV07A_SET_OVERLAY_LUMINANCE_BRIGHTNESS                     31:16
#define NV07A_SET_OVERLAY_CHROMINANCE(b)                           (0x00000458\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_CHROMINANCE_SATURATION_COSINE            15:0
#define NV07A_SET_OVERLAY_CHROMINANCE_SATURATION_SINE              31:16
#define NV07A_SET_OVERLAY_COLORKEY(b)                              (0x0000045C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_OFFSET(b)                                (0x00000460\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_IN(b)                               (0x00000464\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_IN_WIDTH                            15:0
#define NV07A_SET_OVERLAY_SIZE_IN_HEIGHT                           31:16
#define NV07A_SET_OVERLAY_POINT_IN(b)                              (0x00000468\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_IN_S                               15:0
#define NV07A_SET_OVERLAY_POINT_IN_T                               31:16
#define NV07A_SET_OVERLAY_DU_DX(b)                                 (0x0000046C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_DV_DY(b)                                 (0x00000470\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_OUT(b)                             (0x00000474\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_OUT_X                              15:0
#define NV07A_SET_OVERLAY_POINT_OUT_Y                              31:16
#define NV07A_SET_OVERLAY_SIZE_OUT(b)                              (0x00000478\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_OUT_WIDTH                           15:0
#define NV07A_SET_OVERLAY_SIZE_OUT_HEIGHT                          31:16
#define NV07A_SET_OVERLAY_FORMAT(b)                                (0x0000047C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_FORMAT_PITCH                             15:0
#define NV07A_SET_OVERLAY_FORMAT_COLOR                             19:16
#define NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8             (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8             (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH                23:20
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY   (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE     (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_MATRIX                            30:24
#define NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601                  (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709                  (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY                            31:31
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY                 (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_THEN_AWAKEN          (0x00000001)
#define NV07A_SET_OVERLAY_POINT_OUT_A                              (0x00000500)
#define NV07A_SET_OVERLAY_POINT_OUT_A_X                            15:0
#define NV07A_SET_OVERLAY_POINT_OUT_A_Y                            31:16
#define NV07A_SET_OVERLAY_LUMINANCE_A                              (0x00000504)
#define NV07A_SET_OVERLAY_LUMINANCE_A_CONTRAST                     15:0
#define NV07A_SET_OVERLAY_LUMINANCE_A_BRIGHTNESS                   31:16
#define NV07A_SET_OVERLAY_CHROMINANCE_A                            (0x00000508)
#define NV07A_SET_OVERLAY_CHROMINANCE_A_SATURATION_COSINE          15:0
#define NV07A_SET_OVERLAY_CHROMINANCE_A_SATURATION_SIZE            31:16

/* class NV10_TEXTURE_FROM_CPU */
#define  NV10_TEXTURE_FROM_CPU                                     (0x0000007B)
/* NvNotification[] elements */
#define NV07B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV07B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV089_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV07B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 Size;                    /* height_width U16_U16, pixels     0308-030b*/
 NvV32 ClipHorizontal;          /* width_x U16_U16                  030c-030f*/
 NvV32 ClipVertical;            /* height_y U16_U16                 0310-0313*/
 NvV32 Reserved02[0x03b];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 a;                      /* source colors (packed texels)       0-   3*/
  NvV32 b;                      /* source colors (packed texels)       4-   7*/
 } Color[896];                  /* end of aliased methods in array      -1fff*/
} Nv07bTypedef, Nv10TextureFromCpu;
#define NV07B_TYPEDEF                                        Nv10TextureFromCpu
/* dma method offsets, fields, and values */
#define NV07B_SET_OBJECT                                           (0x00000000)
#define NV07B_NO_OPERATION                                         (0x00000100)
#define NV07B_NOTIFY                                               (0x00000104)
#define NV07B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07B_SET_CONTEXT_SURFACE                                  (0x00000184)
#define NV07B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV07B_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV07B_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV07B_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV07B_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV07B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV07B_POINT                                                (0x00000304)
#define NV07B_POINT_X                                              15:0
#define NV07B_POINT_Y                                              31:16
#define NV07B_SIZE                                                 (0x00000308)
#define NV07B_SIZE_WIDTH                                           15:0
#define NV07B_SIZE_HEIGHT                                          31:16
#define NV07B_CLIP_HORIZONTAL                                      (0x0000030C)
#define NV07B_CLIP_HORIZONTAL_X                                    15:0
#define NV07B_CLIP_HORIZONTAL_WIDTH                                31:16
#define NV07B_CLIP_VERTICAL                                        (0x00000310)
#define NV07B_CLIP_VERTICAL_Y                                      15:0
#define NV07B_CLIP_VERTICAL_HEIGHT                                 31:16
#define NV07B_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0008)
#define NV07B_COLOR_A(a)                                           (0x00000400\
                                                                   +(a)*0x0008)
#define NV07B_COLOR_B(a)                                           (0x00000404\
                                                                   +(a)*0x0008)
#define NV07B_COLOR__SIZE_1                                        896

/* class NV15_VIDEO_LUT_CURSOR_DAC */
#define  NV15_VIDEO_LUT_CURSOR_DAC                                 (0x0000007C)
/* NvNotification[] elements */
#define NV07C_NOTIFIERS_NOTIFY                                     (0)
#define NV07C_NOTIFIERS_GET_OFFSET                                 (0)
#define NV07C_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV07C_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV07C_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV07C_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV07C_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV07C_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV07C_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV07C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV07C_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV07C_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV07C_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV07C_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV07C_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 SetContextDmaSemaphore;  /* NV01_CONTEXT_DMA                 019c-019f*/
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 Reserved01[0x053];
 NvU32 SetSemaphoreOffset;      /* set semaphore offset             02f0-02f3*/
 NvU32 SetSemaphoreRelease;     /* set semaphore release value      02f4-02f7*/
 NvV32 SetOffsetRange;          /* NV07C_SET_OFFSET_RANGE_*         02f8-02fb*/
 NvV32 GetOffset;               /* NV07C_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_color_height_width           4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv07cTypedef, Nv12VideoLutCursorDac;
#define NV07C_TYPEDEF                                     Nv12VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV07C_SET_OBJECT                                           (0x00000000)
#define NV07C_NO_OPERATION                                         (0x00000100)
#define NV07C_NOTIFY                                               (0x00000104)
#define NV07C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07C_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV07C_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV07C_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV07C_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV07C_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV07C_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV07C_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV07C_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV07C_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV07C_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV07C_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV07C_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV07C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07C_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_SEMAPHORE                            (0x0000019c)

#define NV07C_SET_PAN_OFFSET                                       (0x00000220)

#define NV07C_SET_SEMAPHORE_OFFSET                                 (0x000002f0)
#define NV07C_SET_SEMAPHORE_OFFSET_V                               31:0
#define NV07C_SET_SEMAPHORE_RELEASE                                (0x000002f4)
#define NV07C_SET_SEMAPHORE_RELEASE_V                              31:0

#define NV07C_SET_OFFSET_RANGE                                     (0x000002F8)
#define NV07C_SET_OFFSET_RANGE_START                               14:0
#define NV07C_SET_OFFSET_RANGE_STOP                                30:16
#define NV07C_SET_OFFSET_RANGE_POLARITY                            31:31
#define NV07C_SET_OFFSET_RANGE_POLARITY_IN_RANGE                   (0x00000000)
#define NV07C_SET_OFFSET_RANGE_POLARITY_OUT_RANGE                  (0x00000001)
#define NV07C_GET_OFFSET                                           (0x000002FC)
#define NV07C_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV07C_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV07C_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV07C_SET_IMAGE_FORMAT_WHEN                                23:20
#define NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)

#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC                      24:24
#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED             (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED              (0x00000001)
#define NV07C_SET_IMAGE_FORMAT_FLAGS                               27:25
#define NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP    (0x00000001)
#define NV07C_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV07C_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV07C_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV07C_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH                        7:0
#define NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT                       15:8
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR                        30:16
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5          (0x00000000)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5            (0x00000001)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8            (0x00000002)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8         (0x00000003)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY                       31:31
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV07C_SET_CURSOR_POINT                                     (0x00000330)
#define NV07C_SET_CURSOR_POINT_X                                   15:0
#define NV07C_SET_CURSOR_POINT_Y                                   31:16
#define NV07C_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV07C_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV07C_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV07C_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV07C_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV07C_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV07C_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV07C_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV07C_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV07C_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV07C_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV07C_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV07C_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV07C_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV07C_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV07C_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV07C_SET_DAC_FORMAT_COLOR                                 19:16
#define NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV07C_SET_DAC_FORMAT_HEAD                                  27:26
#define NV07C_SET_DAC_FORMAT_HEAD_0                                (0x00000000)
#define NV07C_SET_DAC_FORMAT_HEAD_1                                (0x00000001)
#define NV07C_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV07C_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV07C_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


typedef NvV32 Nv07dTypedef;

typedef NvV32 Nv07eTypedef;

typedef NvV32 Nv07fTypedef;


/* class NV01_DEVICE_0 */
#define  NV01_DEVICE_0                                             (0x00000080)
/* NvNotification[] fields and values */
#define NV080_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv080Typedef, Nv01Device0;
#define  NV080_TYPEDEF                                             Nv01Device0


/* class NV01_DEVICE_1 */
#define  NV01_DEVICE_1                                             (0x00000081)
/* NvNotification[] fields and values */
#define NV081_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv081Typedef, Nv01Device1;
#define  NV081_TYPEDEF                                             Nv01Device1


/* class NV01_DEVICE_2 */
#define  NV01_DEVICE_2                                             (0x00000082)
/* NvNotification[] fields and values */
#define NV082_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv082Typedef, Nv01Device2;
#define  NV082_TYPEDEF                                             Nv01Device2


/* class NV01_DEVICE_3 */
#define  NV01_DEVICE_3                                             (0x00000083)
/* NvNotification[] fields and values */
#define NV083_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv083Typedef, Nv01Device3;
#define  NV083_TYPEDEF                                             Nv01Device3


/* class NV01_DEVICE_4 */
#define  NV01_DEVICE_4                                             (0x00000084)
/* NvNotification[] fields and values */
#define NV084_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv084Typedef, Nv01Device4;
#define  NV084_TYPEDEF                                             Nv01Device4


/* class NV01_DEVICE_5 */
#define  NV01_DEVICE_5                                             (0x00000085)
/* NvNotification[] fields and values */
#define NV085_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv085Typedef, Nv01Device5;
#define  NV085_TYPEDEF                                             Nv01Device5


/* class NV01_DEVICE_6 */
#define  NV01_DEVICE_6                                             (0x00000086)
/* NvNotification[] fields and values */
#define NV086_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv086Typedef, Nv01Device6;
#define  NV086_TYPEDEF                                             Nv01Device6


/* class NV01_DEVICE_7 */
#define  NV01_DEVICE_7                                             (0x00000087)
/* NvNotification[] fields and values */
#define NV087_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv087Typedef, Nv01Device7;
#define  NV087_TYPEDEF                                             Nv01Device7


/* class NV10_DVD_SUBPICTURE */
#define  NV10_DVD_SUBPICTURE                                       (0x00000088)
/* NvNotification[] elements */
#define NV088_NOTIFIERS_SET_NOTIFY                                 (0)
/* NvNotification[] fields and values */
#define NV088_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV088_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV088_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV088_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV088_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV088_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV088_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0300-0303*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0304-0307*/
 NvU32 ImageOutFormat;          /* color_pitch V16_U16              0308-030b*/
 NvU32 ImageOutOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 ImageInDsDx;             /* S12d20 ds/dx                     0310-0313*/
 NvV32 ImageInDtDy;             /* S12d20 dt/dy                     0314-0317*/
 NvV32 ImageInSize;             /* height_width U16_U16 in texels   0318-031b*/
 NvV32 ImageInFormat;           /* color_pitch V16_U16              031c-031f*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0320-0323*/
 NvV32 ImageInPoint;            /* t_s U12d4_U12d4 in texels        0324-0317*/
 NvV32 OverlayDsDx;             /* S12d20 ds/dx                     0328-032b*/
 NvV32 OverlayDtDy;             /* S12d20 dt/dy                     032c-032f*/
 NvV32 OverlaySize;             /* height_width U16_U16 in texels   0330-0333*/
 NvV32 OverlayFormat;           /* color_pitch V16_U16              0334-0337*/
 NvU32 OverlayOffset;           /* byte offset of top-left texel    0338-033b*/
 NvV32 OverlayPoint;            /* t_s U12d4_U12d4 in texels        033c-033f*/
 NvV32 Reserved02[0x730];
} Nv088Typedef, Nv10DvdSubpicture;
#define NV088_TYPEDEF                                         Nv10DvdSubpicture
/* dma method offsets, fields, and values */
#define NV088_SET_OBJECT                                           (0x00000000)
#define NV088_NO_OPERATION                                         (0x00000100)
#define NV088_NOTIFY                                               (0x00000104)
#define NV088_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV088_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV088_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV088_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV088_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV088_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV088_IMAGE_OUT_POINT                                      (0x00000300)
#define NV088_IMAGE_OUT_POINT_X                                    15:0
#define NV088_IMAGE_OUT_POINT_Y                                    31:16
#define NV088_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV088_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV088_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV088_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV088_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV088_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8               (0x00000001)
#define NV088_IMAGE_OUT_FORMAT_COLOR_LE_YB8CR8YA8CB8               (0x00000002)
#define NV088_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV088_IMAGE_IN_DS_DX                                       (0x00000310)
#define NV088_IMAGE_IN_DT_DY                                       (0x00000314)
#define NV088_IMAGE_IN_SIZE                                        (0x00000318)
#define NV088_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV088_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV088_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV088_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV088_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8                (0x00000001)
#define NV088_IMAGE_IN_FORMAT_COLOR_LE_YB8CR8YA8CB8                (0x00000002)
#define NV088_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV088_IMAGE_IN_POINT                                       (0x00000324)
#define NV088_IMAGE_IN_POINT_S                                     15:0
#define NV088_IMAGE_IN_POINT_T                                     31:16
#define NV088_OVERLAY_DS_DX                                        (0x00000328)
#define NV088_OVERLAY_DT_DY                                        (0x0000032C)
#define NV088_OVERLAY_SIZE                                         (0x00000330)
#define NV088_OVERLAY_SIZE_WIDTH                                   15:0
#define NV088_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV088_OVERLAY_FORMAT                                       (0x00000334)
#define NV088_OVERLAY_FORMAT_PITCH                                 15:0
#define NV088_OVERLAY_FORMAT_COLOR                                 31:16
#define NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8                   (0x00000001)
#define NV088_OVERLAY_FORMAT_COLOR_LE_A4CR6YB6A4CB6YA6             (0x00000002)
#define NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV088_OVERLAY_OFFSET                                       (0x00000338)
#define NV088_OVERLAY_POINT                                        (0x0000033C)
#define NV088_OVERLAY_POINT_S                                      15:0
#define NV088_OVERLAY_POINT_T                                      31:16


/* class NV10_SCALED_IMAGE_FROM_MEMORY */
#define  NV10_SCALED_IMAGE_FROM_MEMORY                             (0x00000089)
/* NvNotification[] elements */
#define NV089_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV089_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV089_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV089_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV089_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV089_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV089_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV089_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV089_SET_COLOR_CONVERSION_*     02fc-02ff*/
 NvV32 SetColorFormat;          /* NV089_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV089_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv089Typedef, Nv10ScaledImageFromMemory;
#define NV089_TYPEDEF                                 Nv10ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV089_SET_OBJECT                                           (0x00000000)
#define NV089_NO_OPERATION                                         (0x00000100)
#define NV089_NOTIFY                                               (0x00000104)
#define NV089_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV089_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV089_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV089_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV089_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV089_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV089_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV089_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV089_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV089_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV089_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV089_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV089_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV089_SET_COLOR_FORMAT                                     (0x00000300)
#define NV089_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV089_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV089_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV089_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV089_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV089_SET_COLOR_FORMAT_LE_Y8                               (0x00000008)
#define NV089_SET_COLOR_FORMAT_LE_AY8                              (0x00000009)
#define NV089_SET_OPERATION                                        (0x00000304)
#define NV089_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV089_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV089_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV089_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV089_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV089_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV089_CLIP_POINT                                           (0x00000308)
#define NV089_CLIP_POINT_X                                         15:0
#define NV089_CLIP_POINT_Y                                         31:16
#define NV089_CLIP_SIZE                                            (0x0000030C)
#define NV089_CLIP_SIZE_WIDTH                                      15:0
#define NV089_CLIP_SIZE_HEIGHT                                     31:16
#define NV089_IMAGE_OUT_POINT                                      (0x00000310)
#define NV089_IMAGE_OUT_POINT_X                                    15:0
#define NV089_IMAGE_OUT_POINT_Y                                    31:16
#define NV089_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV089_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV089_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV089_DS_DX                                                (0x00000318)
#define NV089_DT_DY                                                (0x0000031C)
#define NV089_IMAGE_IN_SIZE                                        (0x00000400)
#define NV089_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV089_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV089_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV089_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV089_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV089_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV089_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV089_IMAGE_IN                                             (0x0000040C)
#define NV089_IMAGE_IN_POINT_U                                     15:0
#define NV089_IMAGE_IN_POINT_V                                     31:16


/* class NV11_SCALED_IMAGE_FROM_MEMORY */
#define  NV11_SCALED_IMAGE_FROM_MEMORY                             (0x00001189)
/* NvNotification[] elements */
#define NV1189_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV1189_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV1189_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV1189_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV1189_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV1189_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV1189_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV1189_NOTIFY_*                  0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV1189_SET_COLOR_CONVERSION_*    02fc-02ff*/
 NvV32 SetColorFormat;          /* NV1189_SET_COLOR_FORMAT_*        0300-0303*/
 NvV32 SetOperation;            /* NV1189_SET_OPERATION_*           0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv1189Typedef, Nv11ScaledImageFromMemory;
#define NV1189_TYPEDEF                                 Nv11ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV1189_SET_OBJECT                                           (0x00000000)
#define NV1189_NO_OPERATION                                         (0x00000100)
#define NV1189_NOTIFY                                               (0x00000104)
#define NV1189_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV1189_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV1189_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV1189_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV1189_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV1189_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV1189_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV1189_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV1189_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV1189_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV1189_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV1189_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV1189_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV1189_SET_COLOR_FORMAT                                     (0x00000300)
#define NV1189_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV1189_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV1189_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV1189_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV1189_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV1189_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV1189_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV1189_SET_COLOR_FORMAT_LE_Y8                               (0x00000008)
#define NV1189_SET_COLOR_FORMAT_LE_AY8                              (0x00000009)
#define NV1189_SET_OPERATION                                        (0x00000304)
#define NV1189_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV1189_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV1189_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV1189_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV1189_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV1189_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV1189_CLIP_POINT                                           (0x00000308)
#define NV1189_CLIP_POINT_X                                         15:0
#define NV1189_CLIP_POINT_Y                                         31:16
#define NV1189_CLIP_SIZE                                            (0x0000030C)
#define NV1189_CLIP_SIZE_WIDTH                                      15:0
#define NV1189_CLIP_SIZE_HEIGHT                                     31:16
#define NV1189_IMAGE_OUT_POINT                                      (0x00000310)
#define NV1189_IMAGE_OUT_POINT_X                                    15:0
#define NV1189_IMAGE_OUT_POINT_Y                                    31:16
#define NV1189_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV1189_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV1189_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV1189_DS_DX                                                (0x00000318)
#define NV1189_DT_DY                                                (0x0000031C)
#define NV1189_IMAGE_IN_SIZE                                        (0x00000400)
#define NV1189_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV1189_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV1189_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV1189_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV1189_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV1189_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV1189_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV1189_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV1189_IMAGE_IN                                             (0x0000040C)
#define NV1189_IMAGE_IN_POINT_U                                     15:0
#define NV1189_IMAGE_IN_POINT_V                                     31:16


/* class NV10_IMAGE_FROM_CPU */
#define  NV10_IMAGE_FROM_CPU                                       (0x0000008A)
#define NV08A_NOTIFIERS_NOTIFY                                     (0)
#define NV08A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV08A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV08A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV08A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV08A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV08A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV08A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV08A_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV08A_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV08A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 a;                      /* source colors (packed texels)       0-   3*/
  NvV32 b;                      /* source colors (packed texels)       4-   7*/
 } Color[896];                  /* end of aliased methods in array      -1fff*/
} Nv08ATypedef, NV10ImageFromCpu;
#define NV08A_TYPEDEF                                          NV10ImageFromCpu
/* dma method offsets, fields, and values */
#define NV08A_SET_OBJECT                                           (0x00000000)
#define NV08A_NO_OPERATION                                         (0x00000100)
#define NV08A_NOTIFY                                               (0x00000104)
#define NV08A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV08A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV08A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV08A_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV08A_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV08A_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV08A_SET_CONTEXT_ROP                                      (0x00000190)
#define NV08A_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV08A_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV08A_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV08A_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV08A_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV08A_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV08A_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV08A_SET_OPERATION                                        (0x000002FC)
#define NV08A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV08A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV08A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV08A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV08A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV08A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV08A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV08A_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV08A_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV08A_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV08A_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV08A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV08A_POINT                                                (0x00000304)
#define NV08A_POINT_X                                              15:0
#define NV08A_POINT_Y                                              31:16
#define NV08A_SIZE_OUT                                             (0x00000308)
#define NV08A_SIZE_OUT_WIDTH                                       15:0
#define NV08A_SIZE_OUT_HEIGHT                                      31:16
#define NV08A_SIZE_IN                                              (0x0000030C)
#define NV08A_SIZE_IN_WIDTH                                        15:0
#define NV08A_SIZE_IN_HEIGHT                                       31:16
#define NV08A_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV10_CONTEXT_SURFACES_3D */
#define  NV10_CONTEXT_SURFACES_3D                                  (0x00000093)
/* NvNotification[] elements */
#define NV093_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV093_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV093_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV093_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV093_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV093_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV093_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV093_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02f8-02fb*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02fc-02ff*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvV32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv093Typedef, Nv10ContextSurfaces3d;
#define NV093_TYPEDEF                                     Nv10ContextSurfaces3d
/* dma method offsets, fields, and values */
#define NV093_SET_OBJECT                                           (0x00000000)
#define NV093_NO_OPERATION                                         (0x00000100)
#define NV093_NOTIFY                                               (0x00000104)
#define NV093_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV093_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV093_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV093_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV093_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV093_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV093_SET_CLIP_HORIZONTAL_X                                15:0
#define NV093_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV093_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV093_SET_CLIP_VERTICAL_Y                                  15:0
#define NV093_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV093_SET_FORMAT                                           (0x00000300)
#define NV093_SET_FORMAT_COLOR                                     7:0
#define NV093_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV093_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV093_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV093_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV093_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV093_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV093_SET_FORMAT_TYPE                                      15:8
#define NV093_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV093_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV093_SET_FORMAT_WIDTH                                     23:16
#define NV093_SET_FORMAT_HEIGHT                                    31:24
#define NV093_SET_CLIP_SIZE                                        (0x00000304)
#define NV093_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV093_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV093_SET_PITCH                                            (0x00000308)
#define NV093_SET_PITCH_COLOR                                      15:0
#define NV093_SET_PITCH_ZETA                                       31:16
#define NV093_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV093_SET_OFFSET_ZETA                                      (0x00000310)



/* class NV10_DX5_TEXTURED_TRIANGLE */
#define  NV10_DX5_TEXTURED_TRIANGLE                                (0x00000094)
/* NvNotification[] elements */
#define NV094_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV094_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV094_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV094_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV094_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV094_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV094_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV094_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ColorKeyValue;           /* see text                         0300-0303*/
 NvU32 Offset;                  /* texture offset in bytes          0304-0307*/
 NvV32 Format;                  /* see text                         0308-030b*/
 NvV32 Filter;                  /* see text                         030c-030f*/
 NvV32 Blend;                   /* see text                         0310-0313*/
 NvV32 Control;                 /* see text                         0314-0317*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0318-031b*/
 NvV32 Reserved02[0x039];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[16];                /* end of methods in array              -05ff*/
 NvV32 DrawPrimitive[64];       /* see text                         0600-06ff*/
 NvV32 Reserved03[0x640];
} Nv094Typedef, Nv10Dx5TexturedTriangle;
#define NV094_TYPEDEF                                   Nv10Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV094_SET_OBJECT                                           (0x00000000)
#define NV094_NO_OPERATION                                         (0x00000100)
#define NV094_NOTIFY                                               (0x00000104)
#define NV094_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV094_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV094_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV094_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV094_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV094_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV094_COLOR_KEY_VALUE                                      (0x00000300)
#define NV094_OFFSET                                               (0x00000304)
#define NV094_FORMAT                                               (0x00000308)
#define NV094_FORMAT_CONTEXT_DMA                                   1:0
#define NV094_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV094_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV094_FORMAT_COLOR_KEY_MATCH                               3:2
#define NV094_FORMAT_COLOR_KEY_MATCH_SRCCOPY                       (0x00000000)
#define NV094_FORMAT_COLOR_KEY_MATCH_ZERO_ALPHA                    (0x00000001)
#define NV094_FORMAT_ORIGIN_ZOH                                    5:4
#define NV094_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV094_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV094_FORMAT_ORIGIN_FOH                                    7:6
#define NV094_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV094_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV094_FORMAT_COLOR                                         11:8
#define NV094_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV094_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV094_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV094_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV094_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV094_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV094_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV094_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV094_FORMAT_BASE_SIZE_U                                   19:16
#define NV094_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV094_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV094_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV094_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV094_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV094_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV094_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV094_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV094_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV094_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV094_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV094_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV094_FORMAT_BASE_SIZE_V                                   23:20
#define NV094_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV094_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV094_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV094_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV094_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV094_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV094_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV094_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV094_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV094_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV094_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV094_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV094_FORMAT_TEXTUREADDRESSU                               26:24
#define NV094_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV094_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV094_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV094_FORMAT_WRAPU                                         27:27
#define NV094_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV094_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSV                               30:28
#define NV094_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV094_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV094_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV094_FORMAT_WRAPV                                         31:31
#define NV094_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV094_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV094_FILTER                                               (0x0000030C)
#define NV094_FILTER_IGNORE0                                       4:0
#define NV094_FILTER_ZERO0                                         7:5
#define NV094_FILTER_IGNORE1                                       12:8
#define NV094_FILTER_ZERO1                                         14:13
#define NV094_FILTER_IGNORE2                                       15:15
#define NV094_FILTER_MIPMAPLODBIAS                                 23:16
#define NV094_FILTER_TEXTUREMIN                                    26:24
#define NV094_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV094_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV094_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV094_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV094_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV094_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV094_FILTER_IGNORE3                                       27:27
#define NV094_FILTER_TEXTUREMAG                                    30:28
#define NV094_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV094_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV094_FILTER_IGNORE4                                       31:31
#define NV094_BLEND                                                (0x00000310)
#define NV094_BLEND_TEXTUREMAPBLEND                                3:0
#define NV094_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV094_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV094_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV094_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV094_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV094_BLEND_MASK_BIT                                       5:4
#define NV094_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV094_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV094_BLEND_SHADEMODE                                      7:6
#define NV094_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV094_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV094_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV094_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV094_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV094_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV094_BLEND_SPECULARENABLE                                 15:12
#define NV094_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV094_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV094_BLEND_FOGENABLE                                      19:16
#define NV094_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV094_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV094_BLEND_ALPHABLENDENABLE                               23:20
#define NV094_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV094_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV094_BLEND_SRCBLEND                                       27:24
#define NV094_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV094_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV094_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV094_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV094_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV094_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV094_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV094_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV094_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV094_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV094_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV094_BLEND_DESTBLEND                                      31:28
#define NV094_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV094_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV094_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV094_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV094_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV094_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV094_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV094_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV094_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV094_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV094_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV094_CONTROL                                              (0x00000314)
#define NV094_CONTROL_ALPHAREF                                     7:0
#define NV094_CONTROL_ALPHAFUNC                                    11:8
#define NV094_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV094_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV094_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV094_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV094_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV094_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV094_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV094_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV094_CONTROL_ALPHATESTENABLE                              12:12
#define NV094_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV094_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV094_CONTROL_ORIGIN                                       13:13
#define NV094_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV094_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV094_CONTROL_ZENABLE                                      15:14
#define NV094_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV094_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV094_CONTROL_ZFUNC                                        19:16
#define NV094_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV094_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV094_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV094_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV094_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV094_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV094_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV094_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV094_CONTROL_CULLMODE                                     21:20
#define NV094_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV094_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV094_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV094_CONTROL_DITHERENABLE                                 22:22
#define NV094_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV094_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV094_CONTROL_ZWRITEENABLE                                 29:24
#define NV094_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV094_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV094_CONTROL_Z_FORMAT                                     31:30
#define NV094_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV094_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV094_FOG_COLOR                                            (0x00000318)
#define NV094_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_COLOR_BLUE                                  7:0
#define NV094_TLVERTEX_COLOR_GREEN                                 15:8
#define NV094_TLVERTEX_COLOR_RED                                   23:16
#define NV094_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV094_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV094_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV094_TLVERTEX_SPECULAR_RED                                23:16
#define NV094_TLVERTEX_SPECULAR_FOG                                31:24
#define NV094_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV094_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV094_DRAW_PRIMITIVE_I0                                    3:0
#define NV094_DRAW_PRIMITIVE_I1                                    7:4
#define NV094_DRAW_PRIMITIVE_I2                                    11:8
#define NV094_DRAW_PRIMITIVE_I3                                    15:12
#define NV094_DRAW_PRIMITIVE_I4                                    19:16
#define NV094_DRAW_PRIMITIVE_I5                                    31:20



/* class NV10_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV10_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000095)
/* NvNotification[] elements */
#define NV095_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV095_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV095_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV095_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV095_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV095_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV095_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV095_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05e];
 NvU32 Offset[2];               /* offset in bytes                  0308-030f*/
 NvV32 Format[2];               /* see text                         0310-0317*/
 NvV32 Filter[2];               /* see text                         0318-031f*/
 NvV32 Combine0Alpha;           /* see text                         0320-0323*/
 NvV32 Combine0Color;           /* see text                         0324-0327*/
 NvV32 Reserved02;
 NvV32 Combine1Alpha;           /* see text                         032c-032f*/
 NvV32 Combine1Color;           /* see text                         0330-0333*/
 NvV32 CombineFactor;           /* A8R8G8B8                         0334-0337*/
 NvV32 Blend;                   /* see text                         0338-033b*/
 NvV32 Control0;                /* see text                         033c-033f*/
 NvV32 Control1;                /* see text                         0340-0343*/
 NvV32 Control2;                /* see text                         0344-0347*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0348-034b*/
 NvV32 Reserved03[0x02D];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu0;                    /* texture 0 u coordinate             18-  1b*/
  NvF32 tv0;                    /* texture 0 v coordinate             1c-  1f*/
  NvF32 tu1;                    /* texture 1 u coordinate             20-  23*/
  NvF32 tv1;                    /* texture 1 v coordinate             24-  27*/
 } Tlmtvertex[8];               /* end of methods in array              -053f*/
 NvV32 DrawPrimitive[48];       /* see text                         0540-05ff*/
 NvV32 Reserved04[0x680];
} Nv095Typedef, Nv10Dx6MultiTextureTriangle;
#define NV095_TYPEDEF                               Nv10Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV095_SET_OBJECT                                           (0x00000000)
#define NV095_NO_OPERATION                                         (0x00000100)
#define NV095_NOTIFY                                               (0x00000104)
#define NV095_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV095_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV095_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV095_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV095_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV095_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV095_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV095_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV095_FORMAT_CONTEXT_DMA                                   3:0
#define NV095_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV095_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV095_FORMAT_ORIGIN_ZOH                                    5:4
#define NV095_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV095_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV095_FORMAT_ORIGIN_FOH                                    7:6
#define NV095_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV095_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV095_FORMAT_COLOR                                         11:8
#define NV095_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV095_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV095_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV095_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV095_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV095_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV095_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV095_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV095_FORMAT_BASE_SIZE_U                                   19:16
#define NV095_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV095_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV095_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV095_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV095_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV095_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV095_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV095_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV095_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV095_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV095_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV095_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV095_FORMAT_BASE_SIZE_V                                   23:20
#define NV095_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV095_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV095_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV095_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV095_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV095_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV095_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV095_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV095_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV095_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV095_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV095_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV095_FORMAT_TEXTUREADDRESSU                               26:24
#define NV095_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV095_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV095_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV095_FORMAT_WRAPU                                         27:27
#define NV095_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV095_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSV                               30:28
#define NV095_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV095_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV095_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV095_FORMAT_WRAPV                                         31:31
#define NV095_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV095_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV095_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV095_FILTER_IGNORE0                                       4:0
#define NV095_FILTER_ZERO0                                         7:5
#define NV095_FILTER_IGNORE1                                       12:8
#define NV095_FILTER_ZERO1                                         14:13
#define NV095_FILTER_IGNORE2                                       15:15
#define NV095_FILTER_MIPMAPLODBIAS                                 23:16
#define NV095_FILTER_TEXTUREMIN                                    26:24
#define NV095_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV095_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV095_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV095_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV095_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV095_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV095_FILTER_IGNORE3                                       27:27
#define NV095_FILTER_TEXTUREMAG                                    30:28
#define NV095_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV095_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV095_FILTER_IGNORE4                                       31:31
#define NV095_COMBINE_0_ALPHA                                      (0x00000320)
#define NV095_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV095_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV095_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV095_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV095_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_0_COLOR                                      (0x00000324)
#define NV095_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV095_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV095_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV095_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV095_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV095_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV095_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV095_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV095_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_OPERATION                            31:29
#define NV095_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV095_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV095_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV095_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV095_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV095_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_1_COLOR                                      (0x00000330)
#define NV095_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV095_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV095_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV095_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV095_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV095_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV095_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV095_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV095_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_OPERATION                            31:29
#define NV095_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
/* The following NV095_COMBINE_*** defines can be used without regard to the combiner number */
#define NV095_COMBINE_ALPHA_INVERSE_0                              0:0
#define NV095_COMBINE_ALPHA_INVERSE_0_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_0_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_0                                1:1
#define NV095_COMBINE_ALPHA_ARGUMENT_0                             7:2
#define NV095_COMBINE_ALPHA_ARGUMENT_0_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_1                              8:8
#define NV095_COMBINE_ALPHA_INVERSE_1_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_1_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_1                                9:9
#define NV095_COMBINE_ALPHA_ARGUMENT_1                             15:10
#define NV095_COMBINE_ALPHA_ARGUMENT_1_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_2                              16:16
#define NV095_COMBINE_ALPHA_INVERSE_2_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_2_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_2                                17:17
#define NV095_COMBINE_ALPHA_ARGUMENT_2                             23:18
#define NV095_COMBINE_ALPHA_ARGUMENT_2_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_3                              24:24
#define NV095_COMBINE_ALPHA_INVERSE_3_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_3_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_3                                25:25
#define NV095_COMBINE_ALPHA_ARGUMENT_3                             28:26
#define NV095_COMBINE_ALPHA_ARGUMENT_3_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_OPERATION                              31:29
#define NV095_COMBINE_ALPHA_OPERATION_ADD                          (0x00000001)
#define NV095_COMBINE_ALPHA_OPERATION_ADD2                         (0x00000002)
#define NV095_COMBINE_ALPHA_OPERATION_ADD4                         (0x00000003)
#define NV095_COMBINE_ALPHA_OPERATION_ADDSIGNED                    (0x00000004)
#define NV095_COMBINE_ALPHA_OPERATION_MUX                          (0x00000005)
#define NV095_COMBINE_ALPHA_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV095_COMBINE_ALPHA_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_0                              0:0
#define NV095_COMBINE_COLOR_INVERSE_0_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_0_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_0                                1:1
#define NV095_COMBINE_COLOR_ALPHA_0_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_0_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_0                             7:2
#define NV095_COMBINE_COLOR_ARGUMENT_0_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_0_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_1                              8:8
#define NV095_COMBINE_COLOR_INVERSE_1_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_1_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_1                                9:9
#define NV095_COMBINE_COLOR_ALPHA_1_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_1_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_1                             15:10
#define NV095_COMBINE_COLOR_ARGUMENT_1_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_1_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_2                              16:16
#define NV095_COMBINE_COLOR_INVERSE_2_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_2_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_2                                17:17
#define NV095_COMBINE_COLOR_ALPHA_2_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_2_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_2                             23:18
#define NV095_COMBINE_COLOR_ARGUMENT_2_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_2_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_3                              24:24
#define NV095_COMBINE_COLOR_INVERSE_3_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_3_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_3                                25:25
#define NV095_COMBINE_COLOR_ALPHA_3_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_3_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_3                             28:26
#define NV095_COMBINE_COLOR_ARGUMENT_3_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_3_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_OPERATION                              31:29
#define NV095_COMBINE_COLOR_OPERATION_ADD                          (0x00000001)
#define NV095_COMBINE_COLOR_OPERATION_ADD2                         (0x00000002)
#define NV095_COMBINE_COLOR_OPERATION_ADD4                         (0x00000003)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED                    (0x00000004)
#define NV095_COMBINE_COLOR_OPERATION_MUX                          (0x00000005)
#define NV095_COMBINE_COLOR_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV095_COMBINE_FACTOR                                       (0x00000334)
#define NV095_COMBINE_FACTOR_BLUE                                  7:0
#define NV095_COMBINE_FACTOR_GREEN                                 15:8
#define NV095_COMBINE_FACTOR_RED                                   23:16
#define NV095_COMBINE_FACTOR_ALPHA                                 31:24
#define NV095_BLEND                                                (0x00000338)
#define NV095_BLEND_MASK_BIT                                       5:0
#define NV095_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV095_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV095_BLEND_SHADEMODE                                      7:6
#define NV095_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV095_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV095_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV095_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV095_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV095_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV095_BLEND_SPECULARENABLE                                 15:12
#define NV095_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV095_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV095_BLEND_FOGENABLE                                      19:16
#define NV095_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV095_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV095_BLEND_ALPHABLENDENABLE                               23:20
#define NV095_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV095_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV095_BLEND_SRCBLEND                                       27:24
#define NV095_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV095_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV095_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV095_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV095_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV095_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV095_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV095_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV095_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV095_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV095_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV095_BLEND_DESTBLEND                                      31:28
#define NV095_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV095_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV095_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV095_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV095_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV095_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV095_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV095_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV095_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV095_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV095_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV095_CONTROL0                                             (0x0000033C)
#define NV095_CONTROL0_ALPHAREF                                    7:0
#define NV095_CONTROL0_ALPHAFUNC                                   11:8
#define NV095_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV095_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV095_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV095_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV095_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV095_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV095_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV095_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV095_CONTROL0_ALPHATESTENABLE                             12:12
#define NV095_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV095_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV095_CONTROL0_ORIGIN                                      13:13
#define NV095_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV095_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV095_CONTROL0_ZENABLE                                     15:14
#define NV095_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV095_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV095_CONTROL0_ZFUNC                                       19:16
#define NV095_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV095_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV095_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV095_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV095_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV095_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV095_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV095_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV095_CONTROL0_CULLMODE                                    21:20
#define NV095_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV095_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV095_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV095_CONTROL0_DITHERENABLE                                22:22
#define NV095_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ZWRITEENABLE                                24:24
#define NV095_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV095_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV095_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV095_CONTROL0_Z_FORMAT                                    31:30
#define NV095_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV095_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV095_CONTROL1                                             (0x00000340)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC                                7:4
#define NV095_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV095_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV095_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV095_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV095_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV095_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV095_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV095_CONTROL1_STENCIL_REF                                 15:8
#define NV095_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV095_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV095_CONTROL2                                             (0x00000344)
#define NV095_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV095_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV095_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV095_FOG_COLOR                                            (0x00000348)
#define NV095_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV095_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV095_TLMTVERTEX_COLOR_RED                                 23:16
#define NV095_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV095_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV095_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV095_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV095_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV095_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV095_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV095_DRAW_PRIMITIVE_I0                                    3:0
#define NV095_DRAW_PRIMITIVE_I1                                    7:4
#define NV095_DRAW_PRIMITIVE_I2                                    11:8
#define NV095_DRAW_PRIMITIVE_I3                                    15:12
#define NV095_DRAW_PRIMITIVE_I4                                    19:16
#define NV095_DRAW_PRIMITIVE_I5                                    31:20

// This typedef really should be the same as Nv12CelsiusPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.


typedef NvV32 Nv096Typedef;


/* class NV15_CELSIUS_PRIMITIVE */
#define  NV15_CELSIUS_PRIMITIVE                                    (0x00000096)
/* NvNotification[] elements */
#define NV096_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV096_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV096_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV096_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV096_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV096_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV096_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved00[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved01[0xc/4];
    NvV32 SyncSetRead;
    NvV32 SyncSetWrite;
    NvV32 SyncSetModulo;
    NvV32 SyncIncrementWrite;
    NvV32 SyncStall;
    NvV32 Reserved17[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved02[0x3c/4];
    NvV32 SetContextDmaNotifies;
    NvV32 SetContextDmaA;
    NvV32 SetContextDmaB;
    NvV32 SetContextDmaVertex;
    NvV32 SetContextDmaState;
    NvV32 SetContextDmaColor;
    NvV32 SetContextDmaZeta;
    NvV32 Reserved03[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved04[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved05[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvV32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvV32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvV32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvV32 SetStencilFuncRef;
    NvV32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvV32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvV32 SetMaterialEmission[3];
    NvV32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
        NvV32 S;
        NvV32 T;
        NvV32 R;
        NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvV32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved06[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved07[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved08[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved09[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0b[0xc8/4];
    struct {
        NvF32 AmbientColor[3];
        NvF32 DiffuseColor[3];
        NvF32 SpecularColor[3];
        NvF32 LocalRange;
        NvF32 InfiniteHalfVector[3];
        NvF32 InfiniteDirection[3];
        NvF32 SpotFalloff[3];
        NvF32 SpotDirection[4];
        NvF32 LocalPosition[3];
        NvF32 LocalAttenuation[3];
        NvV32 Reserved0c[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0d[0xc/4];
    NvF32 SetVertex4f[4];
    NvS16 SetVertex4s[4];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0e[0x4/4];
    NvS16 SetNormal3s[3];
    NvV16 Reserved0f[0xa/2];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvV32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvV32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS16 SetTexcoord0_2s[2];
    NvV32 Reserved10[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS16 SetTexcoord0_4s[4];
    NvF32 SetTexcoord1_2f[2];
    NvS16 SetTexcoord1_2s[2];
    NvV32 Reserved11[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS16 SetTexcoord1_4s[4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved12[0x4/4];
    NvV32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 Reserved13[0xbc/4];
    NvV32 SetBeginEnd;
    NvV16 ArrayElement16[256];
    NvV32 Reserved14[0xfc/4];
    NvV32 SetBeginEnd2;
    NvV32 ArrayElement32[64];
    NvV32 Reserved15[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 Reserved1628[0x1d4/4];
    NvV32 SetBeginEnd4;
    NvV32 InlineArray[512];
} Nv12CelsiusPrimitive;


#define NV096_TYPEDEF                                      Nv12CelsiusPrimitive
#define NV096_SET_OBJECT                                           (0x00000000)


#define NV096_DEBUG_INIT(i)                                        (0x00001600+(i)*4)


#define NV096_FLUSH                                                        0x00000728


#define NV096_NO_OPERATION                                                 0x00000100


#define NV096_NOTIFY                                                       0x00000104
#define NV096_NOTIFY_TYPE                                                        23:0
#define NV096_NOTIFY_TYPE_WRITE_ONLY                                       0x00000000
#define NV096_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                0x00000001


#define NV096_SET_WARNING_ENABLE                                           0x00000108
#define NV096_SET_WARNING_ENABLE_V                                               23:0
#define NV096_SET_WARNING_ENABLE_V_FALSE                                   0x00000000
#define NV096_SET_WARNING_ENABLE_V_TRUE                                    0x00000001


#define NV096_GET_STATE                                                    0x0000010c
#define NV096_GET_STATE_GETSTATE                                                 31:0
#define NV096_GET_STATE_GETSTATE_ALL_STATE                                 0x00000001
#define NV096_GET_STATE_PUTSTATE_ALL_STATE                                 0x00000002
#define NV096_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                   0x00000003
#define NV096_GET_STATE_GETSTATE_RENDERING_STATE                           0x00000004
#define NV096_GET_STATE_GETSTATE_GEOMETRY_STATE                            0x00000005
#define NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                        0x00000006
#define NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                          0x00000007

#define NV096_WAIT_FOR_IDLE                                                0x00000110

#define NV096_SYNC_SET_READ                                                0x00000120
#define NV096_SYNC_SET_WRITE                                               0x00000124
#define NV096_SYNC_SET_MODULO                                              0x00000128
#define NV096_SYNC_INCREMENT_WRITE                                         0x0000012c
#define NV096_SYNC_STALL                                                   0x00000130

#define NV096_PM_TRIGGER                                                   0x00000140


#define NV096_SET_CONTEXT_DMA_NOTIFIES                                     0x00000180


#define NV096_SET_CONTEXT_DMA_A                                            0x00000184


#define NV096_SET_CONTEXT_DMA_B                                            0x00000188


#define NV096_SET_CONTEXT_DMA_VERTEX                                       0x0000018c


#define NV096_SET_CONTEXT_DMA_STATE                                        0x00000190


#define NV096_SET_CONTEXT_DMA_COLOR                                        0x00000194


#define NV096_SET_CONTEXT_DMA_ZETA                                         0x00000198


#define NV096_SET_SURFACE_CLIP_HORIZONTAL                                  0x00000200
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_X                                      15:0
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                 31:16


#define NV096_SET_SURFACE_CLIP_VERTICAL                                    0x00000204
#define NV096_SET_SURFACE_CLIP_VERTICAL_Y                                        15:0
#define NV096_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                  31:16


#define NV096_SET_SURFACE_FORMAT                                           0x00000208
#define NV096_SET_SURFACE_FORMAT_COLOR                                            7:0
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                0x00000001
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                0x00000002
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                           0x00000003
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                0x00000004
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                0x00000005
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            0x00000006
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            0x00000007
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000008
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_B8                               0x00000009
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_G8B8                             0x0000000A
#define NV096_SET_SURFACE_FORMAT_TYPE                                            15:8
#define NV096_SET_SURFACE_FORMAT_TYPE_PITCH                                0x00000001
#define NV096_SET_SURFACE_FORMAT_TYPE_SWIZZLE                              0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH                                          23:16
#define NV096_SET_SURFACE_FORMAT_WIDTH_1                                   0x00000000
#define NV096_SET_SURFACE_FORMAT_WIDTH_2                                   0x00000001
#define NV096_SET_SURFACE_FORMAT_WIDTH_4                                   0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH_8                                   0x00000003
#define NV096_SET_SURFACE_FORMAT_WIDTH_16                                  0x00000004
#define NV096_SET_SURFACE_FORMAT_WIDTH_32                                  0x00000005
#define NV096_SET_SURFACE_FORMAT_WIDTH_64                                  0x00000006
#define NV096_SET_SURFACE_FORMAT_WIDTH_128                                 0x00000007
#define NV096_SET_SURFACE_FORMAT_WIDTH_256                                 0x00000008
#define NV096_SET_SURFACE_FORMAT_WIDTH_512                                 0x00000009
#define NV096_SET_SURFACE_FORMAT_WIDTH_1024                                0x0000000A
#define NV096_SET_SURFACE_FORMAT_WIDTH_2048                                0x0000000B
#define NV096_SET_SURFACE_FORMAT_HEIGHT                                         31:24
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1                                  0x00000000
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2                                  0x00000001
#define NV096_SET_SURFACE_FORMAT_HEIGHT_4                                  0x00000002
#define NV096_SET_SURFACE_FORMAT_HEIGHT_8                                  0x00000003
#define NV096_SET_SURFACE_FORMAT_HEIGHT_16                                 0x00000004
#define NV096_SET_SURFACE_FORMAT_HEIGHT_32                                 0x00000005
#define NV096_SET_SURFACE_FORMAT_HEIGHT_64                                 0x00000006
#define NV096_SET_SURFACE_FORMAT_HEIGHT_128                                0x00000007
#define NV096_SET_SURFACE_FORMAT_HEIGHT_256                                0x00000008
#define NV096_SET_SURFACE_FORMAT_HEIGHT_512                                0x00000009
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1024                               0x0000000A
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2048                               0x0000000B


#define NV096_SET_SURFACE_PITCH                                            0x0000020c
#define NV096_SET_SURFACE_PITCH_COLOR                                            15:0
#define NV096_SET_SURFACE_PITCH_ZETA                                            31:16


#define NV096_SET_SURFACE_COLOR_OFFSET                                     0x00000210
#define NV096_SET_SURFACE_COLOR_OFFSET_V                                         31:0


#define NV096_SET_SURFACE_ZETA_OFFSET                                      0x00000214
#define NV096_SET_SURFACE_ZETA_OFFSET_V                                          31:0


#define NV096_SET_TEXTURE_OFFSET(i)                                (0x00000218+(i)*4)
#define NV096_SET_TEXTURE_OFFSET_V                                               31:0


#define NV096_SET_TEXTURE_FORMAT(i)                                (0x00000220+(i)*4)
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA                                      1:0
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                   2:2
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                      0x00000000
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                       0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                       4:3
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH                                       6:5
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR                                           11:7
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_Y8                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_AY8                              0x00000001
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                         0x00000003
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                         0x00000004
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                           0x00000005
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000006
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                         0x00000007
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                      0x00000008
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                        0x00000009
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                      0x0000000A
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                      0x0000000B
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                    0x0000000C
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                   0x0000000E
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                   0x0000000F
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                   0x00000010
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                     0x00000011
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                   0x00000012
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                         0x00000013
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                        0x00000014
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                      0x00000015
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                       0x00000016
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                       0x00000017
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                     0x00000018
#define NV096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                  15:12
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U                                    19:16
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V                                    23:20
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                                26:24
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPU                                          27:27
#define NV096_SET_TEXTURE_FORMAT_WRAPU_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPU_TRUE                                0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                                30:28
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPV                                          31:31
#define NV096_SET_TEXTURE_FORMAT_WRAPV_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPV_TRUE                                0x00000001


#define NV096_SET_TEXTURE_CONTROL0(i)                              (0x00000228+(i)*4)
#define NV096_SET_TEXTURE_CONTROL0_ENABLE                                       30:30
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_FALSE                            0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_TRUE                             0x00000001
#define NV096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                29:18
#define NV096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                 17:6
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                  5:4
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                         0x00000000
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                         0x00000001
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                             3:3
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                0x00000000
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                 0x00000001
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                              2:2
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                 0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                  0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                            1:0
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE               0x00000000
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA               0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                0x00000002
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                0x00000003


#define NV096_SET_TEXTURE_CONTROL1(i)                              (0x00000230+(i)*4)
#define NV096_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                  31:16
#define NV096_SET_TEXTURE_CONTROL1_ZERO                                          15:0


#define NV096_SET_TEXTURE_CONTROL2(i)                              (0x00000238+(i)*4)
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DU                                    11:0
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DV                                   23:12
#define NV096_SET_TEXTURE_CONTROL2_IMAGE_LODF                                   31:24


#define NV096_SET_TEXTURE_IMAGE_RECT(i)                            (0x00000240+(i)*4)
#define NV096_SET_TEXTURE_IMAGE_RECT_WIDTH                                      31:16
#define NV096_SET_TEXTURE_IMAGE_RECT_HEIGHT                                      15:0


#define NV096_SET_TEXTURE_FILTER(i)                                (0x00000248+(i)*4)
#define NV096_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                   23:0
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN                                     27:24
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                         0x00000002
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                     0x00000003
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                      0x00000004
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST               0x00000005
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR                0x00000006
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG                                     31:28
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                         0x00000002


#define NV096_SET_TEXTURE_PALETTE(i)                               (0x00000250+(i)*4)
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA                                     5:0
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                            0x00000000
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                            0x00000001
#define NV096_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                 31:6


#define NV096_SET_COMBINER_ALPHA_ICW(i)                            (0x00000260+(i)*4)
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINER_COLOR_ICW(i)                            (0x00000268+(i)*4)
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINE_FACTOR(i)                                (0x00000270+(i)*4)
#define NV096_SET_COMBINE_FACTOR_BLUE                                             7:0
#define NV096_SET_COMBINE_FACTOR_GREEN                                           15:8
#define NV096_SET_COMBINE_FACTOR_RED                                            23:16
#define NV096_SET_COMBINE_FACTOR_ALPHA                                          31:24


#define NV096_SET_COMBINER_ALPHA_OCW(i)                            (0x00000278+(i)*4)
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION                                  31:15
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                     0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                0x00000002
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS           0x00000003
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1               0x00000006
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                 14:14
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                      0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                       0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST                                     11:8
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST                                       7:4
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                          0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST                                       3:0
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                          0x0000000D


#define NV096_SET_COMBINER0_COLOR_OCW                                      0x00000280
#define NV096_SET_COMBINER0_COLOR_OCW_ZERO                                      31:27
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER1_COLOR_OCW                                      0x00000284
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                           31:28
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                  0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                  0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT                                27:27
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                       0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                       0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER_SPECULAR_FOG_CW0                                0x00000288
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                             7:5
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                               4:4
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                              3:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD           0x0000000F


#define NV096_SET_COMBINER_SPECULAR_FOG_CW1                                0x0000028c
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                        7:7
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE           0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE            0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                6:6
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE   0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE    0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12               5:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE   0x00000020


#define NV096_SET_CONTROL0                                                 0x00000290
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA                                   31:24
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                        0x00000000
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                         0x00000001
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE                                   23:20
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                        0x00000000
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                         0x00000001
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                 19:16
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                       0x00000001
#define NV096_SET_CONTROL0_Z_FORMAT                                             15:12
#define NV096_SET_CONTROL0_Z_FORMAT_FIXED                                  0x00000000
#define NV096_SET_CONTROL0_Z_FORMAT_FLOAT                                  0x00000001
#define NV096_SET_CONTROL0_WBUFFER_SELECT                                        11:8
#define NV096_SET_CONTROL0_WBUFFER_SELECT_0                                0x00000000
#define NV096_SET_CONTROL0_WBUFFER_SELECT_1                                0x00000001
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE                                   7:0
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                       0x00000001


#define NV096_SET_LIGHT_CONTROL                                            0x00000294
#define NV096_SET_LIGHT_CONTROL_LOCALEYE                                        31:16
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_FALSE                             0x00000000
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_TRUE                              0x00000001
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE                                 15:2
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                    0x00000000
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT                0x00000001
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                              1:1
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                 0x00000000
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                  0x00000001
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                                0:0
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                   0x00000000
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                    0x00000001


#define NV096_SET_COLOR_MATERIAL                                           0x00000298
#define NV096_SET_COLOR_MATERIAL_V                                               31:0
#define NV096_SET_COLOR_MATERIAL_V_DISABLED                                0x00000000
#define NV096_SET_COLOR_MATERIAL_V_EMISSION                                0x00000001
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT                                 0x00000002
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                        0x00000003
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE                                 0x00000004
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                        0x00000005
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                         0x00000006
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE                0x00000007
#define NV096_SET_COLOR_MATERIAL_V_SPECULAR                                0x00000008
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                       0x00000009
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                        0x0000000A
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR               0x0000000B
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                        0x0000000C
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR               0x0000000D
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR                0x0000000E
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR       0x0000000F


#define NV096_SET_FOG_MODE                                                 0x0000029c
#define NV096_SET_FOG_MODE_FOG_MODE                                              31:0
#define NV096_SET_FOG_MODE_FOG_MODE_LINEAR                                 0x00002601
#define NV096_SET_FOG_MODE_FOG_MODE_EXP                                    0x00000800
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2                                   0x00000801
#define NV096_SET_FOG_MODE_FOG_MODE_EXP_ABS                                0x00000802
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2_ABS                               0x00000803


#define NV096_SET_FOG_GEN_MODE                                             0x000002a0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE                                      31:0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                      0x00000000
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                         0x00000001
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                         0x00000002
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                     0x00000003


#define NV096_SET_FOG_ENABLE                                               0x000002a4
#define NV096_SET_FOG_ENABLE_V                                                   31:0
#define NV096_SET_FOG_ENABLE_V_FALSE                                       0x00000000
#define NV096_SET_FOG_ENABLE_V_TRUE                                        0x00000001


#define NV096_SET_FOG_COLOR                                               0x000002a8
#define NV096_SET_FOG_COLOR_FOG_COLOR_RED                                        7:0
#define NV096_SET_FOG_COLOR_FOG_COLOR_GREEN                                     15:8
#define NV096_SET_FOG_COLOR_FOG_COLOR_BLUE                                     23:16
#define NV096_SET_FOG_COLOR_FOG_COLOR_ALPHA                                    31:24


#define NV096_SET_COLOR_KEY_COLOR(i)                               (0x000002ac+(i)*4)
#define NV096_SET_COLOR_KEY_COLOR_V                                              31:0


#define NV096_SET_WINDOW_CLIP_TYPE                                         0x000002b4
#define NV096_SET_WINDOW_CLIP_TYPE_V                                             31:0
#define NV096_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                             0x00000000
#define NV096_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                             0x00000001


#define NV096_SET_WINDOW_CLIP_HORIZONTAL(i)                        (0x000002c0+(i)*4)
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                    15:0
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                   31:16


#define NV096_SET_WINDOW_CLIP_VERTICAL(i)                          (0x000002e0+(i)*4)
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMIN                                      15:0
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMAX                                     31:16


#define NV096_SET_ALPHA_TEST_ENABLE                                        0x00000300
#define NV096_SET_ALPHA_TEST_ENABLE_V                                            31:0
#define NV096_SET_ALPHA_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_ALPHA_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_BLEND_ENABLE                                             0x00000304
#define NV096_SET_BLEND_ENABLE_V                                                 31:0
#define NV096_SET_BLEND_ENABLE_V_FALSE                                     0x00000000
#define NV096_SET_BLEND_ENABLE_V_TRUE                                      0x00000001


#define NV096_SET_CULL_FACE_ENABLE                                         0x00000308
#define NV096_SET_CULL_FACE_ENABLE_V                                             31:0
#define NV096_SET_CULL_FACE_ENABLE_V_FALSE                                 0x00000000
#define NV096_SET_CULL_FACE_ENABLE_V_TRUE                                  0x00000001


#define NV096_SET_DEPTH_TEST_ENABLE                                        0x0000030c
#define NV096_SET_DEPTH_TEST_ENABLE_V                                            31:0
#define NV096_SET_DEPTH_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_DEPTH_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_DITHER_ENABLE                                            0x00000310
#define NV096_SET_DITHER_ENABLE_V                                                31:0
#define NV096_SET_DITHER_ENABLE_V_FALSE                                    0x00000000
#define NV096_SET_DITHER_ENABLE_V_TRUE                                     0x00000001


#define NV096_SET_LIGHTING_ENABLE                                          0x00000314
#define NV096_SET_LIGHTING_ENABLE_V                                              31:0
#define NV096_SET_LIGHTING_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LIGHTING_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_POINT_PARAMS_ENABLE                                      0x00000318
#define NV096_SET_POINT_PARAMS_ENABLE_V                                          31:0
#define NV096_SET_POINT_PARAMS_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_PARAMS_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POINT_SMOOTH_ENABLE                                      0x0000031c
#define NV096_SET_POINT_SMOOTH_ENABLE_V                                          31:0
#define NV096_SET_POINT_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_SMOOTH_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_LINE_SMOOTH_ENABLE                                       0x00000320
#define NV096_SET_LINE_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_LINE_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_LINE_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_POLY_SMOOTH_ENABLE                                       0x00000324
#define NV096_SET_POLY_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_POLY_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_POLY_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_SKIN_ENABLE                                              0x00000328
#define NV096_SET_SKIN_ENABLE_V                                                  31:0
#define NV096_SET_SKIN_ENABLE_V_FALSE                                      0x00000000
#define NV096_SET_SKIN_ENABLE_V_TRUE                                       0x00000001


#define NV096_SET_STENCIL_TEST_ENABLE                                      0x0000032c
#define NV096_SET_STENCIL_TEST_ENABLE_V                                          31:0
#define NV096_SET_STENCIL_TEST_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_STENCIL_TEST_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POLY_OFFSET_POINT_ENABLE                                 0x00000330
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V                                     31:0
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                         0x00000000
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                          0x00000001


#define NV096_SET_POLY_OFFSET_LINE_ENABLE                                  0x00000334
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_POLY_OFFSET_FILL_ENABLE                                  0x00000338
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_ALPHA_FUNC                                               0x0000033c
#define NV096_SET_ALPHA_FUNC_V                                                   31:0
#define NV096_SET_ALPHA_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_ALPHA_FUNC_V_LESS                                        0x00000201
#define NV096_SET_ALPHA_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_ALPHA_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_ALPHA_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_ALPHA_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_ALPHA_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_ALPHA_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_ALPHA_REF                                                0x00000340


#define NV096_SET_BLEND_FUNC_SFACTOR                                       0x00000344
#define NV096_SET_BLEND_FUNC_SFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                  0x00000308
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_FUNC_DFACTOR                                       0x00000348
#define NV096_SET_BLEND_FUNC_DFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_COLOR                                              0x0000034c
#define NV096_SET_BLEND_COLOR_V                                                  31:0


#define NV096_SET_BLEND_EQUATION                                           0x00000350
#define NV096_SET_BLEND_EQUATION_V                                               31:0
#define NV096_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                           0x0000800A
#define NV096_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                   0x0000800B
#define NV096_SET_BLEND_EQUATION_V_FUNC_ADD                                0x00008006
#define NV096_SET_BLEND_EQUATION_V_MIN                                     0x00008007
#define NV096_SET_BLEND_EQUATION_V_MAX                                     0x00008008


#define NV096_SET_DEPTH_FUNC                                               0x00000354
#define NV096_SET_DEPTH_FUNC_V                                                   31:0
#define NV096_SET_DEPTH_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_DEPTH_FUNC_V_LESS                                        0x00000201
#define NV096_SET_DEPTH_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_DEPTH_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_DEPTH_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_DEPTH_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_DEPTH_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_DEPTH_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_COLOR_MASK                                               0x00000358
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                 31:24
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE                                   23:16
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                        0x00000000
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                         0x00000001
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                  15:8
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                    7:0
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                       0x00000000
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                        0x00000001


#define NV096_SET_DEPTH_MASK                                               0x0000035c
#define NV096_SET_DEPTH_MASK_V                                                   31:0
#define NV096_SET_DEPTH_MASK_V_FALSE                                       0x00000000
#define NV096_SET_DEPTH_MASK_V_TRUE                                        0x00000001


#define NV096_SET_STENCIL_MASK                                             0x00000360
#define NV096_SET_STENCIL_MASK_V                                                 31:0


#define NV096_SET_STENCIL_FUNC                                             0x00000364
#define NV096_SET_STENCIL_FUNC_V                                                 31:0
#define NV096_SET_STENCIL_FUNC_V_NEVER                                     0x00000200
#define NV096_SET_STENCIL_FUNC_V_LESS                                      0x00000201
#define NV096_SET_STENCIL_FUNC_V_EQUAL                                     0x00000202
#define NV096_SET_STENCIL_FUNC_V_LEQUAL                                    0x00000203
#define NV096_SET_STENCIL_FUNC_V_GREATER                                   0x00000204
#define NV096_SET_STENCIL_FUNC_V_NOTEQUAL                                  0x00000205
#define NV096_SET_STENCIL_FUNC_V_GEQUAL                                    0x00000206
#define NV096_SET_STENCIL_FUNC_V_ALWAYS                                    0x00000207


#define NV096_SET_STENCIL_FUNC_REF                                         0x00000368
#define NV096_SET_STENCIL_FUNC_REF_V                                             31:0


#define NV096_SET_STENCIL_FUNC_MASK                                        0x0000036c
#define NV096_SET_STENCIL_FUNC_MASK_V                                            31:0


#define NV096_SET_STENCIL_OP_FAIL                                          0x00000370
#define NV096_SET_STENCIL_OP_FAIL_V                                              31:0
#define NV096_SET_STENCIL_OP_FAIL_V_KEEP                                   0x00001E00
#define NV096_SET_STENCIL_OP_FAIL_V_ZERO                                   0x00000000
#define NV096_SET_STENCIL_OP_FAIL_V_REPLACE                                0x00001E01
#define NV096_SET_STENCIL_OP_FAIL_V_INCRSAT                                0x00001E02
#define NV096_SET_STENCIL_OP_FAIL_V_DECRSAT                                0x00001E03
#define NV096_SET_STENCIL_OP_FAIL_V_INVERT                                 0x0000150A
#define NV096_SET_STENCIL_OP_FAIL_V_INCR                                   0x00008507
#define NV096_SET_STENCIL_OP_FAIL_V_DECR                                   0x00008508


#define NV096_SET_STENCIL_OP_ZFAIL                                         0x00000374
#define NV096_SET_STENCIL_OP_ZFAIL_V                                             31:0
#define NV096_SET_STENCIL_OP_ZFAIL_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZFAIL_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZFAIL_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZFAIL_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECR                                  0x00008508


#define NV096_SET_STENCIL_OP_ZPASS                                         0x00000378
#define NV096_SET_STENCIL_OP_ZPASS_V                                             31:0
#define NV096_SET_STENCIL_OP_ZPASS_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZPASS_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZPASS_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZPASS_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZPASS_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZPASS_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZPASS_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZPASS_V_DECR                                  0x00008508


#define NV096_SET_SHADE_MODE                                               0x0000037c
#define NV096_SET_SHADE_MODE_V                                                   31:0
#define NV096_SET_SHADE_MODE_V_FLAT                                        0x00001D00
#define NV096_SET_SHADE_MODE_V_SMOOTH                                      0x00001D01


#define NV096_SET_LINE_WIDTH                                               0x00000380
#define NV096_SET_LINE_WIDTH_V                                                   31:0


#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR                              0x00000384
#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                  31:0


#define NV096_SET_POLYGON_OFFSET_BIAS                                      0x00000388
#define NV096_SET_POLYGON_OFFSET_BIAS_V                                          31:0


#define NV096_SET_FRONT_POLYGON_MODE                                       0x0000038c
#define NV096_SET_FRONT_POLYGON_MODE_V                                           31:0
#define NV096_SET_FRONT_POLYGON_MODE_V_POINT                               0x00001B00
#define NV096_SET_FRONT_POLYGON_MODE_V_LINE                                0x00001B01
#define NV096_SET_FRONT_POLYGON_MODE_V_FILL                                0x00001B02


#define NV096_SET_BACK_POLYGON_MODE                                        0x00000390
#define NV096_SET_BACK_POLYGON_MODE_V                                            31:0
#define NV096_SET_BACK_POLYGON_MODE_V_POINT                                0x00001B00
#define NV096_SET_BACK_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV096_SET_BACK_POLYGON_MODE_V_FILL                                 0x00001B02


#define NV096_SET_CLIP_MIN                                                 0x00000394
#define NV096_SET_CLIP_MIN_V                                                     31:0


#define NV096_SET_CLIP_MAX                                                 0x00000398
#define NV096_SET_CLIP_MAX_V                                                     31:0


#define NV096_SET_CULL_FACE                                                0x0000039c
#define NV096_SET_CULL_FACE_V                                                    31:0
#define NV096_SET_CULL_FACE_V_FRONT                                        0x00000404
#define NV096_SET_CULL_FACE_V_BACK                                         0x00000405
#define NV096_SET_CULL_FACE_V_FRONT_AND_BACK                               0x00000408


#define NV096_SET_FRONT_FACE                                               0x000003a0
#define NV096_SET_FRONT_FACE_V                                                   31:0
#define NV096_SET_FRONT_FACE_V_CW                                          0x00000900
#define NV096_SET_FRONT_FACE_V_CCW                                         0x00000901


#define NV096_SET_NORMALIZATION_ENABLE                                     0x000003a4
#define NV096_SET_NORMALIZATION_ENABLE_V                                         31:0
#define NV096_SET_NORMALIZATION_ENABLE_V_FALSE                             0x00000000
#define NV096_SET_NORMALIZATION_ENABLE_V_TRUE                              0x00000001


#define NV096_SET_MATERIAL_EMISSION(i)                             (0x000003a8+(i)*4)


#define NV096_SET_MATERIAL_ALPHA                                           0x000003b4


#define NV096_SET_SPECULAR_ENABLE                                          0x000003b8
#define NV096_SET_SPECULAR_ENABLE_V                                              31:0
#define NV096_SET_SPECULAR_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_SPECULAR_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_LIGHT_ENABLE_MASK                                        0x000003bc
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0                                        1:0
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1                                        3:2
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2                                        5:4
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3                                        7:6
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4                                        9:8
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5                                      11:10
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6                                      13:12
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7                                      15:14
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                            0x00000003


#define NV096_SET_TEXGEN_S(i)                                     (0x000003c0+(i)*16)
#define NV096_SET_TEXGEN_S_V                                                     31:0
#define NV096_SET_TEXGEN_S_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_S_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_S_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_S_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_S_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_S_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_S_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_T(i)                                     (0x000003c4+(i)*16)
#define NV096_SET_TEXGEN_T_V                                                     31:0
#define NV096_SET_TEXGEN_T_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_T_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_T_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_T_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_T_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_T_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_T_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_R(i)                                     (0x000003c8+(i)*16)
#define NV096_SET_TEXGEN_R_V                                                     31:0
#define NV096_SET_TEXGEN_R_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_R_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_R_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_R_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_R_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_R_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_Q(i)                                     (0x000003cc+(i)*16)
#define NV096_SET_TEXGEN_Q_V                                                     31:0
#define NV096_SET_TEXGEN_Q_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_Q_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_Q_V_OBJECT_LINEAR                                 0x00002401


#define NV096_SET_TEXTURE_MATRIX0_ENABLE                                   0x000003e0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TEXTURE_MATRIX1_ENABLE                                   0x000003e4
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TLMODE                                                   0x000003e8
#define NV096_SET_TLMODE_PASSTHROUGH                                              0:0
#define NV096_SET_TLMODE_PASSTHROUGH_TRUE                                  0x00000001
#define NV096_SET_TLMODE_PASSTHROUGH_FALSE                                 0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0                                               1:1
#define NV096_SET_TLMODE_W_DIVIDE_0_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0_ENABLE                                 0x00000001
#define NV096_SET_TLMODE_W_DIVIDE_1                                               2:2
#define NV096_SET_TLMODE_W_DIVIDE_1_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_1_ENABLE                                 0x00000001


#define NV096_SET_POINT_SIZE                                               0x000003ec
#define NV096_SET_POINT_SIZE_V                                                   31:0


#define NV096_SET_SWATH_WIDTH                                              0x000003f0
#define NV096_SET_SWATH_WIDTH_V                                                  31:0
#define NV096_SET_SWATH_WIDTH_V_8                                          0x00000000
#define NV096_SET_SWATH_WIDTH_V_16                                         0x00000001
#define NV096_SET_SWATH_WIDTH_V_32                                         0x00000002
#define NV096_SET_SWATH_WIDTH_V_64                                         0x00000003


#define NV096_SET_FLAT_SHADE_OP                                            0x000003f4
#define NV096_SET_FLAT_SHADE_OP_V                                                31:0
#define NV096_SET_FLAT_SHADE_OP_V_LAST_VTX                                 0x00000000
#define NV096_SET_FLAT_SHADE_OP_V_FIRST_VTX                                0x00000001


#define NV096_SET_MODEL_VIEW_MATRIX0(i)                            (0x00000400+(i)*4)


#define NV096_SET_MODEL_VIEW_MATRIX1(i)                            (0x00000440+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                    (0x00000480+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                    (0x000004c0+(i)*4)


#define NV096_SET_COMPOSITE_MATRIX(i)                              (0x00000500+(i)*4)


#define NV096_SET_TEXTURE_MATRIX0(i)                               (0x00000540+(i)*4)


#define NV096_SET_TEXTURE_MATRIX1(i)                               (0x00000580+(i)*4)


#define NV096_SET_TEXGEN_SPLANE0(i)                                (0x00000600+(i)*4)


#define NV096_SET_TEXGEN_TPLANE0(i)                                (0x00000610+(i)*4)


#define NV096_SET_TEXGEN_RPLANE0(i)                                (0x00000620+(i)*4)


#define NV096_SET_TEXGEN_QPLANE0(i)                                (0x00000630+(i)*4)


#define NV096_SET_TEXGEN_SPLANE1(i)                                (0x00000640+(i)*4)


#define NV096_SET_TEXGEN_TPLANE1(i)                                (0x00000650+(i)*4)


#define NV096_SET_TEXGEN_RPLANE1(i)                                (0x00000660+(i)*4)


#define NV096_SET_TEXGEN_QPLANE1(i)                                (0x00000670+(i)*4)


#define NV096_SET_FOG_PARAMS(i)                                    (0x00000680+(i)*4)


#define NV096_SET_FOG_PLANE(i)                                     (0x0000068c+(i)*4)


#define NV096_SET_SPECULAR_PARAMS(i)                               (0x000006a0+(i)*4)


#define NV096_SET_SCENE_AMBIENT_COLOR(i)                           (0x000006c4+(i)*4)


#define NV096_SET_VIEWPORT_OFFSET(i)                               (0x000006e8+(i)*4)


#define NV096_SET_POINT_PARAMS(i)                                  (0x000006f8+(i)*4)


#define NV096_SET_EYE_POSITION(i)                                  (0x00000718+(i)*4)

#define NV096_SET_EYE_DIRECTION_SW(i)                              (0x0000072c+(i)*4)


#define NV096_SET_LIGHT_AMBIENT_COLOR(i,j)                 (0x00000800+(i)*128+(j)*4)


#define NV096_SET_LIGHT_DIFFUSE_COLOR(i,j)                 (0x0000080c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPECULAR_COLOR(i,j)                (0x00000818+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_RANGE(i)                           (0x00000824+(i)*128)


#define NV096_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)          (0x00000828+(i)*128+(j)*4)


#define NV096_SET_LIGHT_INFINITE_DIRECTION(i,j)            (0x00000834+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_FALLOFF(i,j)                  (0x00000840+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_DIRECTION(i,j)                (0x0000084c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_POSITION(i,j)                (0x0000085c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_ATTENUATION(i,j)             (0x00000868+(i)*128+(j)*4)


#define NV096_SET_VERTEX3F(i)                                      (0x00000c00+(i)*4)


#define NV096_SET_VERTEX4F(i)                                      (0x00000c18+(i)*4)


#define NV096_SET_VERTEX4S(i)                                      (0x00000c28+(i)*4)


#define NV096_SET_NORMAL3F(i)                                      (0x00000c30+(i)*4)


#define NV096_SET_NORMAL3S(i)                                      (0x00000c40+(i)*2)


#define NV096_SET_DIFFUSE_COLOR4F(i)                               (0x00000c50+(i)*4)


#define NV096_SET_DIFFUSE_COLOR3F(i)                               (0x00000c60+(i)*4)


#define NV096_SET_DIFFUSE_COLOR4UB                                         0x00000c6c


#define NV096_SET_SPECULAR_COLOR4F(i)                              (0x00000c70+(i)*4)


#define NV096_SET_SPECULAR_COLOR3F(i)                              (0x00000c80+(i)*4)


#define NV096_SET_SPECULAR_COLOR4UB                                        0x00000c8c


#define NV096_SET_TEXCOORD0_2F(i)                                  (0x00000c90+(i)*4)


#define NV096_SET_TEXCOORD0_2S(i)                                  (0x00000c98+(i)*2)


#define NV096_SET_TEXCOORD0_4F(i)                                  (0x00000ca0+(i)*4)


#define NV096_SET_TEXCOORD0_4S(i)                                  (0x00000cb0+(i)*2)


#define NV096_SET_TEXCOORD1_2F(i)                                  (0x00000cb8+(i)*4)


#define NV096_SET_TEXCOORD1_2S(i)                                  (0x00000cc0+(i)*2)


#define NV096_SET_TEXCOORD1_4F(i)                                  (0x00000cc8+(i)*4)


#define NV096_SET_TEXCOORD1_4S(i)                                  (0x00000cd8+(i)*2)


#define NV096_SET_FOG1F                                                    0x00000ce0


#define NV096_SET_WEIGHT1F                                                 0x00000ce4


#define NV096_SET_EDGE_FLAG                                                0x00000cec


#define NV096_INVALIDATE_VERTEX_CACHE_FILE                                 0x00000cf0


#define NV096_INVALIDATE_VERTEX_FILE                                       0x00000cf4


#define NV096_TL_NOP                                                       0x00000cf8


#define NV096_TL_SYNC                                                      0x00000cfc


#define NV096_SET_VERTEX_ARRAY_OFFSET                                      0x00000d00
#define NV096_SET_VERTEX_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_VERTEX_ARRAY_FORMAT                                      0x00000d04
#define NV096_SET_VERTEX_ARRAY_FORMAT_W                                         31:24
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_NONE                               0x00000000
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                            0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_STRIDE                                     23:8
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_2                               0x00000002
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_4                               0x00000004
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_DIFFUSE_ARRAY_OFFSET                                     0x00000d08
#define NV096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                    27:0


#define NV096_SET_DIFFUSE_ARRAY_FORMAT                                     0x00000d0c
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                    31:8
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                       7:4
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                       3:0
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA             0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA             0x00000004


#define NV096_SET_SPECULAR_ARRAY_OFFSET                                    0x00000d10
#define NV096_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                   27:0


#define NV096_SET_SPECULAR_ARRAY_FORMAT                                    0x00000d14
#define NV096_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                   31:8
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE                                      7:4
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE                                      3:0
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004


#define NV096_SET_TEX_COORD0_ARRAY_OFFSET                                  0x00000d18
#define NV096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD0_ARRAY_FORMAT                                  0x00000d1c
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_TEX_COORD1_ARRAY_OFFSET                                  0x00000d20
#define NV096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD1_ARRAY_FORMAT                                  0x00000d24
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_NORMAL_ARRAY_OFFSET                                      0x00000d28
#define NV096_SET_NORMAL_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_NORMAL_ARRAY_FORMAT                                      0x00000d2c
#define NV096_SET_NORMAL_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_WEIGHT_ARRAY_OFFSET                                      0x00000d30
#define NV096_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_WEIGHT_ARRAY_FORMAT                                      0x00000d34
#define NV096_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                               0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_FOG_ARRAY_OFFSET                                         0x00000d38
#define NV096_SET_FOG_ARRAY_OFFSET_OFFSET                                        27:0


#define NV096_SET_FOG_ARRAY_FORMAT                                         0x00000d3c
#define NV096_SET_FOG_ARRAY_FORMAT_STRIDE                                        31:8
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE                                           7:4
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_0                                  0x00000000
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_1                                  0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE                                           3:0
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                              0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                              0x00000002

#define NV096_SET_LOGIC_OP_ENABLE                                          0x00000d40
#define NV096_SET_LOGIC_OP_ENABLE_V                                              31:0
#define NV096_SET_LOGIC_OP_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LOGIC_OP_ENABLE_V_TRUE                                   0x00000001

#define NV096_SET_LOGIC_OP                                                 0x00000d44
#define NV096_SET_LOGIC_OP_V                                                     31:0
#define NV096_SET_LOGIC_OP_V_CLEAR                                         0x00001500
#define NV096_SET_LOGIC_OP_V_AND                                           0x00001501
#define NV096_SET_LOGIC_OP_V_AND_REVERSE                                   0x00001502
#define NV096_SET_LOGIC_OP_V_COPY                                          0x00001503
#define NV096_SET_LOGIC_OP_V_AND_INVERTED                                  0x00001504
#define NV096_SET_LOGIC_OP_V_NOOP                                          0x00001505
#define NV096_SET_LOGIC_OP_V_XOR                                           0x00001506
#define NV096_SET_LOGIC_OP_V_OR                                            0x00001507
#define NV096_SET_LOGIC_OP_V_NOR                                           0x00001508
#define NV096_SET_LOGIC_OP_V_EQUIV                                         0x00001509
#define NV096_SET_LOGIC_OP_V_INVERT                                        0x0000150a
#define NV096_SET_LOGIC_OP_V_OR_REVERSE                                    0x0000150b
#define NV096_SET_LOGIC_OP_V_COPY_INVERTED                                 0x0000150c
#define NV096_SET_LOGIC_OP_V_OR_INVERTED                                   0x0000150d
#define NV096_SET_LOGIC_OP_V_NAND                                          0x0000150e
#define NV096_SET_LOGIC_OP_V_SET                                           0x0000150f

#define NV096_SET_BEGIN_END                                                0x00000dfc
#define NV096_SET_BEGIN_END_OP                                                   31:0
#define NV096_SET_BEGIN_END_OP_END                                         0x00000000
#define NV096_SET_BEGIN_END_OP_POINTS                                      0x00000001
#define NV096_SET_BEGIN_END_OP_LINES                                       0x00000002
#define NV096_SET_BEGIN_END_OP_LINE_LOOP                                   0x00000003
#define NV096_SET_BEGIN_END_OP_LINE_STRIP                                  0x00000004
#define NV096_SET_BEGIN_END_OP_TRIANGLES                                   0x00000005
#define NV096_SET_BEGIN_END_OP_TRIANGLE_STRIP                              0x00000006
#define NV096_SET_BEGIN_END_OP_TRIANGLE_FAN                                0x00000007
#define NV096_SET_BEGIN_END_OP_QUADS                                       0x00000008
#define NV096_SET_BEGIN_END_OP_QUAD_STRIP                                  0x00000009
#define NV096_SET_BEGIN_END_OP_POLYGON                                     0x0000000A


#define NV096_ARRAY_ELEMENT16(i)                                   (0x00000e00+(i)*2)


#define NV096_SET_BEGIN_END2                                               0x000010fc
#define NV096_SET_BEGIN_END2_OP                                                  31:0
#define NV096_SET_BEGIN_END2_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END2_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END2_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END2_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END2_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END2_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END2_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END2_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END2_OP_POLYGON                                    0x0000000A


#define NV096_ARRAY_ELEMENT32(i)                                   (0x00001100+(i)*4)


#define NV096_SET_BEGIN_END3                                               0x000013fc
#define NV096_SET_BEGIN_END3_OP                                                  31:0
#define NV096_SET_BEGIN_END3_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END3_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END3_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END3_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END3_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END3_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END3_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END3_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END3_OP_POLYGON                                    0x0000000A


#define NV096_DRAW_ARRAYS(i)                                       (0x00001400+(i)*4)
#define NV096_DRAW_ARRAYS_COUNT                                                 31:24
#define NV096_DRAW_ARRAYS_START_INDEX                                            23:0

#define NV096_SET_BEGIN_END4                                               0x000017fc
#define NV096_SET_BEGIN_END4_OP                                                  31:0
#define NV096_SET_BEGIN_END4_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END4_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END4_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END4_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END4_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END4_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END4_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END4_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END4_OP_POLYGON                                    0x0000000A


#define NV096_INLINE_ARRAY(i)                                      (0x00001800+(i)*4)



typedef NvV32 Nv1196Typedef;


/* class NV11_CELSIUS_PRIMITIVE */
#define  NV11_CELSIUS_PRIMITIVE                                    (0x00001196)
/* NvNotification[] elements */
#define NV1196_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV1196_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV1196_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV1196_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV1196_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV1196_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV1196_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvV32 SetFlipRead;
    NvV32 SetFlipWrite;
    NvV32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvU32 SetContextDmaVertex;
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvV32 Reserved019c[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved0258[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvU32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvU32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved03f8[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved05c0[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved069c[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved06b8[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved06d0[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0738[0xc8/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved0874[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0c0c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0c3c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved0c48[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved0c9c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved0cc4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved0ce8[0x4/4];
    NvU32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 Reserved0d48[0xb4/4];
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16[128];
    NvV32 Reserved1000[0xfc/4];
    NvV32 SetBeginEnd2;
    NvU32 ArrayElement32[64];
    NvV32 Reserved1200[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 Reserved1628[0x1d4/4];
    NvV32 SetBeginEnd4;
    NvU32 InlineArray[512];
} Nv11CelsiusPrimitive;

#define NV1196_TYPEDEF                                      Nv11CelsiusPrimitive
#define NV1196_SET_OBJECT                                          (0x00000000)

#define NV1196_NO_OPERATION                                                0x00000100
#define NV1196_NO_OPERATION_V                                                    31:0

#define NV1196_FLUSH                                                       0x00000728
#define NV1196_FLUSH_V                                                           31:0

#define NV1196_NOTIFY                                                      0x00000104
#define NV1196_NOTIFY_TYPE                                                       31:0
#define NV1196_NOTIFY_TYPE_WRITE_ONLY                                      0x00000000
#define NV1196_NOTIFY_TYPE_WRITE_THEN_AWAKEN                               0x00000001

#define NV1196_SET_WARNING_ENABLE                                          0x00000108
#define NV1196_SET_WARNING_ENABLE_V                                              31:0
#define NV1196_SET_WARNING_ENABLE_V_STOP                                   0x00000000
#define NV1196_SET_WARNING_ENABLE_V_WRITE_ONLY                             0x00000001
#define NV1196_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                      0x00000002

#define NV1196_GET_STATE                                                   0x0000010c
#define NV1196_GET_STATE_GETSTATE                                                31:0
#define NV1196_GET_STATE_GETSTATE_ALL_STATE                                0x00000001
#define NV1196_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                  0x00000002
#define NV1196_GET_STATE_GETSTATE_RENDERING_STATE                          0x00000003
#define NV1196_GET_STATE_GETSTATE_GEOMETRY_STATE                           0x00000004

#define NV1196_WAIT_FOR_IDLE                                               0x00000110
#define NV1196_WAIT_FOR_IDLE_V                                                   31:0

#define NV1196_PM_TRIGGER                                                  0x00000140
#define NV1196_PM_TRIGGER_V                                                      31:0
#define NV1196_PM_TRIGGER_V_NOP                                            0x00000000
#define NV1196_PM_TRIGGER_V_TRIGGER                                        0x00000001

#define NV1196_SET_FLIP_READ                                               0x00000120
#define NV1196_SET_FLIP_WRITE                                              0x00000124
#define NV1196_SET_FLIP_MODULO                                             0x00000128
#define NV1196_FLIP_INCREMENT_WRITE                                        0x0000012c
#define NV1196_FLIP_STALL                                                  0x00000130

#define NV1196_SET_CONTEXT_DMA_NOTIFIES                                    0x00000180
#define NV1196_SET_CONTEXT_DMA_NOTIFIES_V                                        31:0

#define NV1196_SET_CONTEXT_DMA_A                                           0x00000184
#define NV1196_SET_CONTEXT_DMA_A_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_B                                           0x00000188
#define NV1196_SET_CONTEXT_DMA_B_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_VERTEX                                      0x0000018c
#define NV1196_SET_CONTEXT_DMA_VERTEX_V                                          31:0

#define NV1196_SET_CONTEXT_DMA_STATE                                       0x00000190
#define NV1196_SET_CONTEXT_DMA_STATE_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_COLOR                                       0x00000194
#define NV1196_SET_CONTEXT_DMA_COLOR_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_ZETA                                        0x00000198
#define NV1196_SET_CONTEXT_DMA_ZETA_V                                            31:0

#define NV1196_SET_SURFACE_CLIP_HORIZONTAL                                 0x00000200
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_X                                     15:0
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                31:16

#define NV1196_SET_SURFACE_CLIP_VERTICAL                                   0x00000204
#define NV1196_SET_SURFACE_CLIP_VERTICAL_Y                                       15:0
#define NV1196_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                 31:16

#define NV1196_SET_SURFACE_FORMAT                                          0x00000208
#define NV1196_SET_SURFACE_FORMAT_COLOR                                           7:0
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5               0x00000001
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5               0x00000002
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                          0x00000003
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8               0x00000004
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8               0x00000005
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8           0x00000006
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8           0x00000007
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000008
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_B8                              0x00000009
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_G8B8                            0x0000000A
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_Z1R5G5B5           0x00000011
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_O1R5G5B5           0x00000012
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_R5G6B5                      0x00000013
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_Z8R8G8B8           0x00000014
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_O8R8G8B8           0x00000015
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_Z1A7R8G8B8       0x00000016
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_O1A7R8G8B8       0x00000017
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_A8R8G8B8                    0x00000018
#define NV1196_SET_SURFACE_FORMAT_TYPE                                           15:8
#define NV1196_SET_SURFACE_FORMAT_TYPE_PITCH                               0x00000001
#define NV1196_SET_SURFACE_FORMAT_TYPE_SWIZZLE                             0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH                                         23:16
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1                                  0x00000000
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2                                  0x00000001
#define NV1196_SET_SURFACE_FORMAT_WIDTH_4                                  0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH_8                                  0x00000003
#define NV1196_SET_SURFACE_FORMAT_WIDTH_16                                 0x00000004
#define NV1196_SET_SURFACE_FORMAT_WIDTH_32                                 0x00000005
#define NV1196_SET_SURFACE_FORMAT_WIDTH_64                                 0x00000006
#define NV1196_SET_SURFACE_FORMAT_WIDTH_128                                0x00000007
#define NV1196_SET_SURFACE_FORMAT_WIDTH_256                                0x00000008
#define NV1196_SET_SURFACE_FORMAT_WIDTH_512                                0x00000009
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1024                               0x0000000A
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2048                               0x0000000B
#define NV1196_SET_SURFACE_FORMAT_HEIGHT                                        31:24
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1                                 0x00000000
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2                                 0x00000001
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_4                                 0x00000002
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_8                                 0x00000003
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_16                                0x00000004
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_32                                0x00000005
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_64                                0x00000006
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_128                               0x00000007
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_256                               0x00000008
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_512                               0x00000009
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1024                              0x0000000A
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2048                              0x0000000B

#define NV1196_SET_SURFACE_PITCH                                           0x0000020c
#define NV1196_SET_SURFACE_PITCH_COLOR                                           15:0
#define NV1196_SET_SURFACE_PITCH_ZETA                                           31:16

#define NV1196_SET_SURFACE_COLOR_OFFSET                                    0x00000210
#define NV1196_SET_SURFACE_COLOR_OFFSET_V                                        31:0

#define NV1196_SET_SURFACE_ZETA_OFFSET                                     0x00000214
#define NV1196_SET_SURFACE_ZETA_OFFSET_V                                         31:0

#define NV1196_SET_TEXTURE_OFFSET(i)                               (0x00000218+(i)*4)
#define NV1196_SET_TEXTURE_OFFSET_V                                              31:0

#define NV1196_SET_TEXTURE_FORMAT(i)                               (0x00000220+(i)*4)
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA                                     1:0
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                  2:2
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                     0x00000000
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                      0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                      4:3
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH                                      6:5
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR                                          11:7
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_Y8                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_AY8                             0x00000001
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                        0x00000003
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                        0x00000004
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                          0x00000005
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000006
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                        0x00000007
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                     0x00000008
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                       0x00000009
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                     0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                     0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                   0x0000000C
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                  0x0000000E
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                  0x0000000F
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                  0x00000010
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                    0x00000011
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                  0x00000012
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                        0x00000013
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                       0x00000014
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                     0x00000015
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                      0x00000016
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                      0x00000017
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                    0x00000018
#define NV1196_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U                                   19:16
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V                                   23:20
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                               26:24
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPU                                         27:27
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_TRUE                               0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                               30:28
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPV                                         31:31
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_TRUE                               0x00000001

#define NV1196_SET_TEXTURE_CONTROL0(i)                             (0x00000228+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE                                      31:30
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_FALSE                           0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_TRUE                            0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                               29:18
#define NV1196_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                17:6
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                 5:4
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                        0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                        0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                            3:3
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE               0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                             2:2
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                 0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                           1:0
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE              0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA              0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA               0x00000002
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL               0x00000003

#define NV1196_SET_TEXTURE_CONTROL1(i)                             (0x00000230+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                 31:16

#define NV1196_SET_TEXTURE_CONTROL2(i)                             (0x00000238+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DU                                   11:0
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DV                                  23:12
#define NV1196_SET_TEXTURE_CONTROL2_IMAGE_LODF                                  31:24

#define NV1196_SET_TEXTURE_IMAGE_RECT(i)                           (0x00000240+(i)*4)
#define NV1196_SET_TEXTURE_IMAGE_RECT_WIDTH                                     31:16
#define NV1196_SET_TEXTURE_IMAGE_RECT_HEIGHT                                     15:0

#define NV1196_SET_TEXTURE_FILTER(i)                               (0x00000248+(i)*4)
#define NV1196_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                  12:0
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN                                    27:24
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                        0x00000002
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                    0x00000003
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                     0x00000004
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST              0x00000005
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR               0x00000006
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG                                    31:28
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                        0x00000002

#define NV1196_SET_TEXTURE_PALETTE(i)                              (0x00000250+(i)*4)
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA                                    5:0
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                           0x00000000
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                           0x00000001
#define NV1196_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                31:6

#define NV1196_SET_COMBINER_ALPHA_ICW(i)                           (0x00000260+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3        