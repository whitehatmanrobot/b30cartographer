709B, 0x2449F611, 0x00000000
data4    0xACCF8435, 0x3FED58F4, 0x23616A7E, 0x00000000
data4    0x97635082, 0x3FEE480F, 0x24C2FEAE, 0x00000000
data4    0xF0ACC544, 0x3FEF3E57, 0x242CE964, 0x00000000
data4    0xF7E06E4B, 0x3FF01E20, 0x2480D3EE, 0x00000000
data4    0x8A798A69, 0x3FF0A125, 0x24DB8967, 0x00000000
//
//  Entries C_hi   double-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//  Entries C_lo  single-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0xE63EFBD0, 0x400ED3E2, 0x259D94D4, 0x00000000
data4    0xC515DAB5, 0x400DDDB4, 0x245F0537, 0x00000000
data4    0xBE19A79F, 0x400CF57A, 0x25D4EA9F, 0x00000000
data4    0xD15298ED, 0x400C1A06, 0x24AE40A0, 0x00000000
data4    0x164B2708, 0x400B4A4C, 0x25A5AAB6, 0x00000000
data4    0x5285B068, 0x400A855A, 0x25524F18, 0x00000000
data4    0x3FFA549F, 0x4009CA5A, 0x24C999C0, 0x00000000
data4    0x646AF623, 0x4009188A, 0x254FD801, 0x00000000
data4    0x6084D0E7, 0x40086F3C, 0x2560F5FD, 0x00000000
data4    0xA29A76EE, 0x4007CDD2, 0x255B9D19, 0x00000000
data4    0x6C8ECA95, 0x400733BE, 0x25CB021B, 0x00000000
data4    0x1F8DDC52, 0x4006A07E, 0x24AB4722, 0x00000000
data4    0xC298AD58, 0x4006139B, 0x252764E2, 0x00000000
data4    0xBAD7164B, 0x40058CAB, 0x24DAF5DB, 0x00000000
data4    0xAE31A5D3, 0x40050B4B, 0x25EA20F4, 0x00000000
data4    0x89F85A8A, 0x40048F21, 0x2583A3E8, 0x00000000
data4    0xA862380D, 0x400417DA, 0x25DCC4CC, 0x00000000
data4    0x1088FCFE, 0x4003A52B, 0x2430A492, 0x00000000
data4    0xCD3527D5, 0x400336CC, 0x255F77CF, 0x00000000
data4    0x5760766D, 0x4002CC7F, 0x25DA0BDA, 0x00000000
data4    0x11CE02E3, 0x40026607, 0x256FF4A2, 0x00000000
data4    0xD37BBE04, 0x4002032C, 0x25208AED, 0x00000000
data4    0x7F050775, 0x4001A3BD, 0x24B72DD6, 0x00000000
data4    0xA554848A, 0x40014789, 0x24AB4DAA, 0x00000000
data4    0x323E81B7, 0x4000EE65, 0x2584C440, 0x00000000
data4    0x21CF1293, 0x40009827, 0x25C9428D, 0x00000000
data4    0x3D415EEB, 0x400044A9, 0x25DC8482, 0x00000000
data4    0xBD72C577, 0x3FFFE78F, 0x257F5070, 0x00000000
data4    0x75EFD28E, 0x3FFF4AC3, 0x23EBBF7A, 0x00000000
data4    0x60B52DDE, 0x3FFEB2AF, 0x22EECA07, 0x00000000
data4    0x35204180, 0x3FFE1F19, 0x24191079, 0x00000000
data4    0x54F7E60A, 0x3FFD8FCA, 0x248D3058, 0x00000000
//
//  Entries C_hi   double-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//  Entries C_lo  single-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0x79F6FADE, 0x3FFCC06A, 0x239C7886, 0x00000000
data4    0x891662A6, 0x3FFBB91F, 0x250BD191, 0x00000000
data4    0x529F155D, 0x3FFABFB6, 0x256CC3E6, 0x00000000
data4    0x2E964AE9, 0x3FF9D300, 0x250843E3, 0x00000000
data4    0x89DCB383, 0x3FF8F1EF, 0x2277C87E, 0x00000000
data4    0x7C87DBD6, 0x3FF81B93, 0x256DA6CF, 0x00000000
data4    0x1042EDE4, 0x3FF74F14, 0x2573D28A, 0x00000000
data4    0x1784B360, 0x3FF68BAF, 0x242E489A, 0x00000000
data4    0x7C923C4C, 0x3FF5D0B5, 0x2532D940, 0x00000000
data4    0xF418EF20, 0x3FF51D88, 0x253C7DD6, 0x00000000
data4    0x02F88DAE, 0x3FF4719A, 0x23DB59BF, 0x00000000
data4    0x49DA0788, 0x3FF3CC66, 0x252B4756, 0x00000000
data4    0x0B980DB8, 0x3FF32D77, 0x23FE585F, 0x00000000
data4    0xE56C987A, 0x3FF2945F, 0x25378A63, 0x00000000
data4    0xB16523F6, 0x3FF200BD, 0x247BB2E0, 0x00000000
data4    0x8CE27778, 0x3FF17235, 0x24446538, 0x00000000
data4    0xFDEFE692, 0x3FF0E873, 0x2514638F, 0x00000000
data4    0x33154062, 0x3FF0632C, 0x24A7FC27, 0x00000000
data4    0xB3EF115F, 0x3FEFC42E, 0x248FD0FE, 0x00000000
data4    0x135D26F6, 0x3FEEC9E8, 0x2385C719, 0x00000000
//
//  Entries SC_inv in Swapped IEEE format (extended)
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0x1BF30C9E, 0x839D6D4A, 0x00004001, 0x00000000
data4    0x554B0EB0, 0x80092804, 0x00004001, 0x00000000
data4    0xA1CF0DE9, 0xF959F94C, 0x00004000, 0x00000000
data4    0x77378677, 0xF3086BA0, 0x00004000, 0x00000000
data4    0xCCD4723C, 0xED154515, 0x00004000, 0x00000000
data4    0x1C27CF25, 0xE7790944, 0x00004000, 0x00000000
data4    0x8DDACB88, 0xE22D037D, 0x00004000, 0x00000000
data4    0x89C73522, 0xDD2B2D8A, 0x00004000, 0x00000000
data4    0xBB2C1171, 0xD86E1A23, 0x00004000, 0x00000000
data4    0xDFF5E0F9, 0xD3F0E288, 0x00004000, 0x00000000
data4    0x283BEBD5, 0xCFAF16B1, 0x00004000, 0x00000000
data4    0x0D88DD53, 0xCBA4AFAA, 0x00004000, 0x00000000
data4    0xCA67C43D, 0xC7CE03CC, 0x00004000, 0x00000000
data4    0x0CA0DDB0, 0xC427BC82, 0x00004000, 0x00000000
data4    0xF13D8CAB, 0xC0AECD57, 0x00004000, 0x00000000
data4    0x71ECE6B1, 0xBD606C38, 0x00004000, 0x00000000
data4    0xA44C4929, 0xBA3A0A96, 0x00004000, 0x00000000
data4    0xE5CCCEC1, 0xB7394F6F, 0x00004000, 0x00000000
data4    0x9637D8BC, 0xB45C1203, 0x00004000, 0x00000000
data4    0x92CB051B, 0xB1A05528, 0x00004000, 0x00000000
data4    0x6BA2FFD0, 0xAF04432B, 0x00004000, 0x00000000
data4    0x7221235F, 0xAC862A23, 0x00004000, 0x00000000
data4    0x5F00A9D1, 0xAA2478AF, 0x00004000, 0x00000000
data4    0x81E082BF, 0xA7DDBB0C, 0x00004000, 0x00000000
data4    0x45684FEE, 0xA5B0987D, 0x00004000, 0x00000000
data4    0x627A8F53, 0xA39BD0F5, 0x00004000, 0x00000000
data4    0x6EC5C8B0, 0xA19E3B03, 0x00004000, 0x00000000
data4    0x91CD7C66, 0x9FB6C1F0, 0x00004000, 0x00000000
data4    0x1FA3DF8A, 0x9DE46410, 0x00004000, 0x00000000
data4    0xA8F6B888, 0x9C263139, 0x00004000, 0x00000000
data4    0xC27B0450, 0x9A7B4968, 0x00004000, 0x00000000
data4    0x5EE614EE, 0x98E2DB7E, 0x00004000, 0x00000000
//
//  Entries SC_inv in Swapped IEEE format (extended)
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0x13B2B5BA, 0x969F335C, 0x00004000, 0x00000000
data4    0xD4C0F548, 0x93D446D9, 0x00004000, 0x00000000
data4    0x61B798AF, 0x9147094F, 0x00004000, 0x00000000
data4    0x758787AC, 0x8EF317CC, 0x00004000, 0x00000000
data4    0xB99EEFDB, 0x8CD498B3, 0x00004000, 0x00000000
data4    0xDFF8BC37, 0x8AE82A7D, 0x00004000, 0x00000000
data4    0xE3C55D42, 0x892AD546, 0x00004000, 0x00000000
data4    0xD15573C1, 0x8799FEA9, 0x00004000, 0x00000000
data4    0x435A4B4C, 0x86335F88, 0x00004000, 0x00000000
data4    0x3E93A87B, 0x84F4FB6E, 0x00004000, 0x00000000
data4    0x80A382FB, 0x83DD1952, 0x00004000, 0x00000000
data4    0xA4CB8C9E, 0x82EA3D7F, 0x00004000, 0x00000000
data4    0x6861D0A8, 0x821B247C, 0x00004000, 0x00000000
data4    0x63E8D244, 0x816EBED1, 0x00004000, 0x00000000
data4    0x27E4CFC6, 0x80E42D91, 0x00004000, 0x00000000
data4    0x28E64AFD, 0x807ABF8D, 0x00004000, 0x00000000
data4    0x863B4FD8, 0x8031EF26, 0x00004000, 0x00000000
data4    0xAE8C11FD, 0x800960AD, 0x00004000, 0x00000000
data4    0x5FDBEC21, 0x8000E147, 0x00004000, 0x00000000
data4    0xA07791FA, 0x80186650, 0x00004000, 0x00000000

Arg                 = f8   
Result              = f8
U_2                 = f10
rsq                =  f11
C_hi                = f12
C_lo                = f13
T_hi                = f14
T_lo                = f15

N_0                 = f32
d_1                 = f33
MPI_BY_4            = f34
tail                = f35
tanx                = f36
Cx                  = f37
Sx                  = f38
sgn_r               = f39
CORR                = f40
P                   = f41
D                   = f42
ArgPrime            = f43
P_0                 = f44

P2_1                = f45
P2_2                = f46
P2_3                = f47

P1_1                = f45
P1_2                = f46
P1_3                = f47

P1_4                = f48
P1_5                = f49
P1_6                = f50
P1_7                = f51
P1_8                = f52
P1_9                = f53

TWO_TO_63           = f54
NEGTWO_TO_63        = f55
x                   = f56
xsq                 = f57
Tx                  = f58
Tx1                 = f59
Set                 = f60
poly1               = f61
poly2               = f62
Poly                = f63
Poly1               = f64
Poly2               = f65
r_to_the_8          = f66
B                   = f67
SC_inv              = f68
Pos_r               = f69
N_0_fix             = f70
PI_BY_4             = f71
NEGTWO_TO_NEG2      = f72
TWO_TO_24           = f73
TWO_TO_NEG14        = f74
TWO_TO_NEG33        = f75
NEGTWO_TO_24        = f76
NEGTWO_TO_NEG14     = f76
NEGTWO_TO_NEG33     = f77
two_by_PI           = f78
N                   = f79
N_fix               = f80
P_1                 = f81
P_2                 = f82
P_3                 = f83
s_val               = f84
w                   = f85
c                   = f86
r                   = f87
Z                   = f88
A                   = f89
a                   = f90
t                   = f91
U_1                 = f92
d_2                 = f98
TWO_TO_NEG2         = f94
Q1_1                = f95
Q1_2                = f96
Q1_3                = f97
Q1_4                = f98
Q1_5                = f99
Q1_6                = f100
Q1_7                = f101
Q1_8                = f102
S_hi                = f103
S_lo                = f104
V_hi                = f105
V_lo                = f106
U_hi                = f107
U_lo                = f108
U_hiabs             = f109
V_hiabs             = f110
V                   = f111
Inv_P_0             = f112

GR_SAVE_B0     = r33
GR_SAVE_GP     = r34
GR_SAVE_PFS    = r35

delta1         = r36
table_ptr1     = r37
table_ptr2     = r38
i_0            = r39
i_1            = r40 
N_fix_gr       = r41 
N_inc          = r42 
exp_Arg        = r43 
exp_r          = r44 
sig_r          = r45 
lookup         = r46   
table_offset   = r47 
Create_B       = r48 

GR_Parameter_X = r49
GR_Parameter_r = r50



.global __libm_tan
.section .text
.proc __libm_tan


__libm_tan: 

{ .mfi
alloc r32 = ar.pfs, 0,17,2,0
(p0)   fclass.m.unc  p6,p0 = Arg, 0x1E7
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p0)   fclass.nm.unc  p7,p0 = Arg, 0x1FF
       nop.i 999
}
;;

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
       nop.f 999
       nop.i 999
}
;;

{ .mmi
      ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

//
//     Check for NatVals, Infs , NaNs, and Zeros 
//     Check for everything - if false, then must be pseudo-zero
//     or pseudo-nan.
//     Local table pointer
//

{ .mbb
(p0)   add table_ptr2 = 96, table_ptr1
(p6)   br.cond.spnt __libm_TAN_SPECIAL 
(p7)   br.cond.spnt __libm_TAN_SPECIAL ;;
}
//
//     Point to Inv_P_0
//     Branch out to deal with unsupporteds and special values. 
//

{ .mmf
(p0)   ldfs TWO_TO_24 = [table_ptr1],4
(p0)   ldfs TWO_TO_63 = [table_ptr2],4
//
//     Load -2**24, load -2**63.
//
(p0)   fcmp.eq.s0 p0, p6 = Arg, f1 ;;
}

{ .mfi
(p0)   ldfs NEGTWO_TO_63 = [table_ptr2],12
(p0)   fnorm.s1     Arg = Arg
	nop.i 999
}
//
//     Load 2**24, Load 2**63.
//

{ .mmi
(p0)   ldfs NEGTWO_TO_24 = [table_ptr1],12 ;;
//
//     Do fcmp to generate Denormal exception 
//     - can't do FNORM (will generate Underflow when U is unmasked!)
//     Normalize input argument.
//
(p0)   ldfe two_by_PI = [table_ptr1],16
	nop.i 999
}

{ .mmi
(p0)   ldfe Inv_P_0 = [table_ptr2],16 ;;
(p0)   ldfe d_1 = [table_ptr2],16
	nop.i 999
}
//
//     Decide about the paths to take:
//     PR_1 and PR_3 set if -2**24 < Arg < 2**24 - CASE 1 OR 2
//     OTHERWISE - CASE 3 OR 4
//     Load inverse of P_0 .
//     Set PR_6 if Arg <= -2**63
//     Are there any Infs, NaNs, or zeros?
//

{ .mmi
(p0)   ldfe P_0 = [table_ptr1],16 ;;
(p0)   ldfe d_2 = [table_ptr2],16
	nop.i 999
}
//
//     Set PR_8 if Arg <= -2**24
//     Set PR_6 if Arg >=  2**63
//

{ .mmi
(p0)   ldfe P_1 = [table_ptr1],16 ;;
(p0)   ldfe PI_BY_4 = [table_ptr2],16
	nop.i 999
}
//
//     Set PR_8 if Arg >= 2**24
//

{ .mmi
(p0)   ldfe P_2 = [table_ptr1],16 ;;
(p0)   ldfe   MPI_BY_4 = [table_ptr2],16
	nop.i 999
}
//
//     Load  P_2 and PI_BY_4
//

{ .mfi
(p0)   ldfe   P_3 = [table_ptr1],16
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)   fcmp.le.unc.s1 p6,p7 = Arg,NEGTWO_TO_63
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)   fcmp.le.unc.s1 p8,p9 = Arg,NEGTWO_TO_24
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p7)   fcmp.ge.s1 p6,p0 = Arg,TWO_TO_63
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fcmp.ge.s1 p8,p0 = Arg,TWO_TO_24
	nop.i 999 ;;
}

{ .mib
	nop.m 999
	nop.i 999
//
//     Load  P_3 and -PI_BY_4
//
(p6)   br.cond.spnt TAN_ARG_TOO_LARGE ;;
}

{ .mib
	nop.m 999
	nop.i 999
//
//     Load 2**(-2).
//     Load -2**(-2).
//     Branch out if we have a special argument.
//     Branch out if the magnitude of the input argument is too large
//     - do this branch before the next.
//
(p8)   br.cond.spnt TAN_LARGER_ARG ;;
}
//
//     Branch to Cases 3 or 4 if Arg <= -2**24 or Arg >= 2**24
//

{ .mfi
(p0)   ldfs TWO_TO_NEG2 = [table_ptr2],4
//     ARGUMENT REDUCTION CODE - CASE 1 and 2
//     Load 2**(-2).
//     Load -2**(-2).
(p0)   fmpy.s1 N = Arg,two_by_PI
	nop.i 999 ;;
}

{ .mfi
(p0)   ldfs NEGTWO_TO_NEG2 = [table_ptr2],12
//
//     N = Arg * 2/pi
//
(p0)   fcmp.lt.unc.s1 p8,p9= Arg,PI_BY_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     if Arg < pi/4,  set PR_8.
//
(p8)   fcmp.gt.s1 p8,p9= Arg,MPI_BY_4
	nop.i 999 ;;
}
//
//     Case 1: Is |r| < 2**(-2).
//     Arg is the same as r in this case.
//     r = Arg
//     c = 0
//

{ .mfi
(p8)   mov N_fix_gr = r0
//
//     if Arg > -pi/4, reset PR_8.
//     Select the case when |Arg| < pi/4 - set PR[8] = true.
//     Else Select the case when |Arg| >= pi/4 - set PR[9] = true.
//
(p0)   fcvt.fx.s1 N_fix = N
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Grab the integer part of N .
//
(p8)   mov r = Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p8)   mov c = f0
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p8)   fcmp.lt.unc.s1 p10, p11 = Arg, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p10)  fcmp.gt.s1 p10,p0 = Arg, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: Place integer part of N in GP register.
//
(p9)   fcvt.xf N = N_fix
	nop.i 999 ;;
}

{ .mib
(p9)   getf.sig N_fix_gr = N_fix
	nop.i 999
//
//     Case 2: Convert integer N_fix back to normalized floating-point value.
//
(p10)  br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p8)   br.cond.sptk TAN_NORMAL_R ;;
}
//
//     Case 1: PR_3 is only affected  when PR_1 is set.
//

{ .mmi
(p9)   ldfs TWO_TO_NEG33 = [table_ptr2], 4 ;;
//
//     Case 2: Load 2**(-33).
//
(p9)   ldfs NEGTWO_TO_NEG33 = [table_ptr2], 4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: Load -2**(-33).
//
(p9)   fnma.s1 s_val = N, P_1, Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fmpy.s1 w = N, P_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: w = N * P_2
//     Case 2: s_val = -N * P_1  + Arg
//
(p0)   fcmp.lt.unc.s1 p9,p8 = s_val, TWO_TO_NEG33
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Decide between case_1 and case_2 reduce:
//
(p9)   fcmp.gt.s1 p9, p8 = s_val, NEGTWO_TO_NEG33
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce:  s <= -2**(-33) or s >= 2**(-33)
//     Case 2_reduce: -2**(-33) < s < 2**(-33)
//
(p8)   fsub.s1 r = s_val, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fma.s1  U_1 = N, P_2, w
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: Is |r| < 2**(-2), if so set PR_10
//     else set PR_11.
//
(p8)   fsub.s1 c = s_val, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: r = s + w (change sign)
//     Case 2_reduce: w = N * P_3 (change sign)
//
(p8)   fcmp.lt.unc.s1 p10, p11 = r, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p10)  fcmp.gt.s1 p10, p11 = r, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fsub.s1 r = s_val, U_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: c is complete here.
//     c = c + w (w has not been negated.)
//     Case 2_reduce: r is complete here - continue to calculate c .
//     r = s - U_1
//
(p9)   fms.s1 U_2 = N, P_2, U_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: c = s - r
//     Case 2_reduce: U_1 = N * P_2 + w
//
(p8)   fsub.s1 c = c, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fsub.s1 s_val = s_val, r
	nop.i 999
}

{ .mfb
	nop.m 999
//
//     Case 2_reduce:
//     U_2 = N * P_2 - U_1
//     Not needed until later.
//
(p9)   fadd.s1 U_2 = U_2, w
//
//     Case 2_reduce:
//     s = s - r
//     U_2 = U_2 + w
//
(p10)  br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p11)  br.cond.sptk TAN_NORMAL_R ;;
}

{ .mii
	nop.m 999
//
//     Case 2_reduce:
//     c = c - U_2
//     c is complete here
//     Argument reduction ends here.
//
(p9)   extr.u i_1 = N_fix_gr, 0, 1 ;;
(p9)   cmp.eq.unc p11, p12 = 0x0000,i_1 ;;
}

{ .mfi
	nop.m 999
//
//     Is i_1  even or odd?
//     if i_1 == 0, set p11, else set p12.
//
(p11)  fmpy.s1 rsq = r, Z
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  frcpa.s1 S_hi,p0 = f1, r
	nop.i 999
}

//
//     Case 1: Branch to SMALL_R or NORMAL_R.
//     Case 1 is done now.
//

{ .mfi
(p9)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
(p9)   fsub.s1 c = s_val, U_1
	nop.i 999 ;;
}
;;

{ .mmi
(p9)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

{ .mmi
(p9)   add table_ptr1 = 224, table_ptr1 ;;
(p9)   ldfe P1_1 = [table_ptr1],144
	nop.i 999 ;;
}
//
//     Get [i_1] -  lsb of N_fix_gr .
//     Load P1_1 and point to Q1_1 .
//

{ .mfi
(p9)   ldfe Q1_1 = [table_ptr1] , 0
//
//     N even: rsq = r * Z
//     N odd:  S_hi = frcpa(r)
//
(p12)  fmerge.ns S_hi = S_hi, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 2_reduce:
//     c = s - U_1
//
(p9)   fsub.s1 c = c, U_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1  poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  Change sign of S_hi
//
(p11)  fmpy.s1 rsq = rsq, P1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: rsq = rsq * P1_1
//     N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
//
(p11)  fma.s1 Result = r, rsq, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result = c  + r * rsq
//     N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result = Result + r
//     N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
//
(p11)  fadd.s0 Result = r, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1  S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result1 = Result + r
//     N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * poly + 1.0    64 bits
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * r + 1.0
//
(p12)  fma.s1 poly1 = S_hi, c, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * c + poly1
//
(p12)  fmpy.s1 S_lo = S_hi, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  S_lo  =  S_hi *  poly1
//
(p12)  fma.s1 S_lo = Q1_1, r, S_lo
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     N odd:  Result =  S_hi + S_lo
//
(p0)   fmpy.s0 Q1_1 = Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//     N odd:  S_lo  =  S_lo + Q1_1 * r
//
(p12)  fadd.s0 Result = S_hi, S_lo
//
//     Do a dummy multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_LARGER_ARG: 

{ .mmf
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
      nop.m 999
(p0)  fmpy.s1 N_0 = Arg, Inv_P_0 
}
;;

//
// ARGUMENT REDUCTION CODE - CASE 3 and 4
//
//
//    Adjust table_ptr1 to beginning of table.
//    N_0 = Arg * Inv_P_0
//


{ .mmi
(p0)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;


{ .mmi
(p0)  add table_ptr1 = 8, table_ptr1 ;;
//
//    Point to  2*-14
//
(p0)  ldfs TWO_TO_NEG14 = [table_ptr1], 4
	nop.i 999 ;;
}
//
//    Load 2**(-14).
//

{ .mmi
(p0)  ldfs NEGTWO_TO_NEG14 = [table_ptr1], 180 ;;
//
//    N_0_fix  = integer part of N_0 .
//    Adjust table_ptr1 to beginning of table.
//
(p0)  ldfs TWO_TO_NEG2 = [table_ptr1], 4
	nop.i 999 ;;
}
//
//    Make N_0 the integer part.
//

{ .mfi
(p0)  ldfs NEGTWO_TO_NEG2 = [table_ptr1]
//
//    Load -2**(-14).
//
(p0)  fcvt.fx.s1 N_0_fix = N_0
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fcvt.xf N_0 = N_0_fix
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fnma.s1 ArgPrime = N_0, P_0, Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 w = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    ArgPrime = -N_0 * P_0 + Arg
//    w  = N_0 * d_1
//
(p0)  fmpy.s1 N = ArgPrime, two_by_PI
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N = ArgPrime * 2/pi
//
(p0)  fcvt.fx.s1 N_fix = N
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N_fix is the integer part.
//
(p0)  fcvt.xf N = N_fix
	nop.i 999 ;;
}

{ .mfi
(p0)  getf.sig N_fix_gr = N_fix
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N is the integer part of the reduced-reduced argument.
//    Put the integer in a GP register.
//
(p0)  fnma.s1 s_val = N, P_1, ArgPrime
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fnma.s1 w = N, P_2, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    s_val = -N*P_1 + ArgPrime
//    w = -N*P_2 + w
//
(p0)  fcmp.lt.unc.s1 p11, p10 = s_val, TWO_TO_NEG14
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fcmp.gt.s1 p11, p10 = s_val, NEGTWO_TO_NEG14
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: r = s_val + w (Z complete)
//    Case 4: U_hi = N_0 * d_1
//
(p10) fmpy.s1 V_hi = N, P_2
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 U_hi = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: r = s_val + w (Z complete)
//    Case 4: U_hi = N_0 * d_1
//
(p11) fmpy.s1 V_hi = N, P_2
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 U_hi = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Decide between case 3 and 4:
//    Case 3:  s <= -2**(-14) or s >= 2**(-14)
//    Case 4: -2**(-14) < s < 2**(-14)
//
(p10) fadd.s1 r = s_val, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: We need abs of both U_hi and V_hi - dont
//    worry about switched sign of V_hi .
//
(p11) fsub.s1 A = U_hi, V_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: A =  U_hi + V_hi
//    Note: Worry about switched sign of V_hi, so subtract instead of add.
//
(p11) fnma.s1 V_lo = N, P_2, V_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fms.s1 U_lo = N_0, d_1, U_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fabs V_hiabs = V_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: V_hi = N * P_2
//            w = N * P_3
//    Note the product does not include the (-) as in the writeup
//    so (-) missing for V_hi and w .
(p10) fadd.s1 r = s_val, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: c = s_val - r
//    Case 4: U_lo = N_0 * d_1 - U_hi
//
(p11) fabs U_hiabs = U_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: Set P_12 if U_hiabs >= V_hiabs
//
(p11) fadd.s1 C_hi = s_val, A
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_hi = s_val + A
//
(p11) fadd.s1 t = U_lo, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: Is |r| < 2**(-2), if so set PR_7
//    else set PR_8.
//    Case 3: If PR_7 is set, prepare to branch to Small_R.
//    Case 3: If PR_8 is set, prepare to branch to Normal_R.
//
(p10) fsub.s1 c = s_val, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: c = (s - r) + w (c complete)
//
(p11) fcmp.ge.unc.s1 p12, p13 = U_hiabs, V_hiabs
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fms.s1 w = N_0, d_2, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: V_hi = N * P_2
//            w = N * P_3
//    Note the product does not include the (-) as in the writeup
//    so (-) missing for V_hi and w .
//
(p10) fcmp.lt.unc.s1 p14, p15 = r, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p14) fcmp.gt.s1 p14, p15 = r, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    Case 4: V_lo = -N * P_2 - V_hi (U_hi is in place of V_hi in writeup)
//    Note: the (-) is still missing for V_hi .
//    Case 4: w = w + N_0 * d_2
//    Note: the (-) is now incorporated in w .
//
(p10) fadd.s1 c = c, w
//
//    Case 4: t = U_lo + V_lo
//    Note: remember V_lo should be (-), subtract instead of add. NO
//
(p14) br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p15) br.cond.spnt TAN_NORMAL_R ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: Vector off when |r| < 2**(-2).  Recall that PR_3 will be true.
//    The remaining stuff is for Case 4.
//
(p12) fsub.s1 a = U_hi, A
(p11) extr.u i_1 = N_fix_gr, 0, 1 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_lo = s_val - C_hi
//
(p11) fadd.s1 t = t, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p13) fadd.s1 a = V_hi, A
	nop.i 999 ;;
}

//
//    Case 4: a = U_hi - A
//            a = V_hi - A (do an add to account for missing (-) on V_hi
//

{ .mfi
(p11)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
(p11) fsub.s1 C_lo = s_val, C_hi
	nop.i 999
}
;;

{ .mmi
(p11) ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

//
//    Case 4: a = (U_hi - A)  + V_hi
//            a = (V_hi - A)  + U_hi
//    In each case account for negative missing form V_hi .
//
//
//    Case 4: C_lo = (s_val - C_hi) + A
//

{ .mmi
(p11) add table_ptr1 = 224, table_ptr1 ;;
(p11) ldfe P1_1 = [table_ptr1], 16
	nop.i 999 ;;
}

{ .mfi
(p11) ldfe P1_2 = [table_ptr1], 128
//
//    Case 4: w = U_lo + V_lo  + w
//
(p12) fsub.s1 a = a, V_hi
	nop.i 999 ;;
}
//
//    Case 4: r = C_hi + C_lo
//

{ .mfi
(p11) ldfe Q1_1 = [table_ptr1], 16
(p11) fadd.s1 C_lo = C_lo, A
	nop.i 999 ;;
}
//
//    Case 4: c = C_hi - r
//    Get [i_1] - lsb of N_fix_gr.
//

{ .mfi
(p11) ldfe Q1_2 = [table_ptr1], 16
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p13) fsub.s1 a = U_hi, a
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fadd.s1 t = t, a
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: t = t + a
//
(p11) fadd.s1 C_lo = C_lo, t
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_lo = C_lo + t
//
(p11) fadd.s1 r = C_hi, C_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fsub.s1 c = C_hi, r
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: c = c + C_lo  finished.
//    Is i_1  even or odd?
//    if i_1 == 0, set PR_4, else set PR_5.
//
// r and c have been computed.
// We known whether this is the sine or cosine routine.
// Make sure ftz mode is set - should be automatic when using wre
(p0)  fmpy.s1 rsq = r, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fadd.s1 c = c , C_lo
(p11) cmp.eq.unc p11, p12 =  0x0000, i_1 ;;
}

{ .mfi
	nop.m 999
(p12) frcpa.s1 S_hi, p0 = f1, r
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd: Change sign of S_hi
//
(p11) fma.s1 Result = rsq, P1_2, P1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 P = rsq, Q1_2, Q1_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:  Result  =  S_hi + S_lo      (User supplied rounding mode for C1)
//
(p0)  fmpy.s0 Q1_1 =  Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: rsq = r * r
//    N odd:  S_hi = frcpa(r)
//
(p12) fmerge.ns S_hi = S_hi, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even: rsq = rsq * P1_2 + P1_1
//    N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
//
(p11) fmpy.s1 Result = rsq, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r,f1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even: Result =  Result * rsq
//    N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
//
(p11) fma.s1 Result = r, Result, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
//
(p11) fadd.s0 Result= r, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 =  S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result = Result * r + c
//    N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
//
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result1 = Result + r  (Rounding mode S0)
//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * poly + S_hi    64 bits
//
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * r + 1.0
//
(p12) fma.s1 poly1 = S_hi, c, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * c + poly1
//
(p12) fmpy.s1 S_lo = S_hi, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  S_hi *  poly1
//
(p12) fma.s1 S_lo = P, r, S_lo
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    N odd:  S_lo  =  S_lo + r * P
//
(p12) fadd.s0 Result = S_hi, S_lo
//
//    Do dummy multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_SMALL_R: 

{ .mii
	nop.m 999
(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 rsq = r, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) frcpa.s1 S_hi, p0 = f1, r
	nop.i 999
}

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
        nop.f 999
        nop.i 999
}
;;

{ .mmi
(p0)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

// *****************************************************************
// *****************************************************************
// *****************************************************************

{ .mmi
(p0)  add table_ptr1 = 224, table_ptr1 ;;
(p0)  ldfe P1_1 = [table_ptr1], 16
	nop.i 999 ;;
}
//    r and c have been computed.
//    We known whether this is the sine or cosine routine.
//    Make sure ftz mode is set - should be automatic when using wre
//    |r| < 2**(-2)

{ .mfi
(p0)  ldfe P1_2 = [table_ptr1], 16
(p11) fmpy.s1 r_to_the_8 = rsq, rsq
	nop.i 999 ;;
}
//
//    Set table_ptr1 to beginning of constant table.
//    Get [i_1] - lsb of N_fix_gr.
//

{ .mfi
(p0)  ldfe P1_3 = [table_ptr1], 96
//
//    N even: rsq = r * r
//    N odd:  S_hi = frcpa(r)
//
(p12) fmerge.ns S_hi = S_hi, S_hi
	nop.i 999 ;;
}
//
//    Is i_1  even or odd?
//    if i_1 == 0, set PR_11.
//    if i_1 != 0, set PR_12.
//

{ .mfi
(p11) ldfe P1_9 = [table_ptr1], -16
//
//    N even: Poly2 = P1_7 + Poly2 * rsq
//    N odd:  poly2 = Q1_5 + poly2 * rsq
//
(p11) fadd.s1 CORR = rsq, f1
	nop.i 999 ;;
}

{ .mmi
(p11) ldfe P1_8 = [table_ptr1], -16 ;;
//
//    N even: Poly1 = P1_2 + P1_3 * rsq
//    N odd:  poly1 =  1.0 +  S_hi * r     
//    16 bits partial  account for necessary (-1)
//
(p11) ldfe P1_7 = [table_ptr1], -16
	nop.i 999 ;;
}
//
//    N even: Poly1 = P1_1 + Poly1 * rsq
//    N odd:  S_hi  =  S_hi + S_hi * poly1)     16 bits account for necessary
//

{ .mfi
(p11) ldfe P1_6 = [table_ptr1], -16
//
//    N even: Poly2 = P1_5 + Poly2 * rsq
//    N odd:  poly2 = Q1_3 + poly2 * rsq
//
(p11) fmpy.s1 r_to_the_8 = r_to_the_8, r_to_the_8
	nop.i 999 ;;
}
//
//    N even: Poly1 =  Poly1 * rsq
//    N odd:  poly1  = 1.0 + S_hi * r         32 bits partial
//

{ .mfi
(p11) ldfe P1_5 = [table_ptr1], -16
(p12) fma.s1 poly1 =  S_hi, r, f1
	nop.i 999 ;;
}
//
//    N even: CORR =  CORR * c
//    N odd:  S_hi  =  S_hi * poly1 + S_hi    32 bits
//

//
//    N even: Poly2 = P1_6 + Poly2 * rsq
//    N odd:  poly2 = Q1_4 + poly2 * rsq
//
{ .mmf
(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
(p11) ldfe P1_4 = [table_ptr1], -16
(p11) fmpy.s1 CORR =  CORR, c
}
;;


{ .mmi
(p0)  ld8 table_ptr2 = [table_ptr2]
      nop.m 999
      nop.i 999
}
;;


{ .mii
(p0)  add table_ptr2 = 464, table_ptr2
	nop.i 999 ;;
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly1 = P1_3, rsq, P1_2
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfe Q1_7 = [table_ptr2], -16
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfe Q1_6 = [table_ptr2], -16
(p11) fma.s1 Poly2 = P1_9, rsq, P1_8
	nop.i 999 ;;
}

{ .mmi
(p0)  ldfe Q1_5 = [table_ptr2], -16 ;;
(p12) ldfe Q1_4 = [table_ptr2], -16
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_3 = [table_ptr2], -16
//
//    N even: Poly2 = P1_8 + P1_9 * rsq
//    N odd:  poly2 = Q1_6 + Q1_7 * rsq
//
(p11) fma.s1 Poly1 = Poly1, rsq, P1_1
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_2 = [table_ptr2], -16
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_1 = [table_ptr2], -16
(p11) fma.s1 Poly2 = Poly2, rsq, P1_7
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: CORR =  rsq + 1
//    N even: r_to_the_8 =  rsq * rsq
//
(p11) fmpy.s1 Poly1 = Poly1, rsq
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = Q1_7, rsq, Q1_6
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly2 = Poly2, rsq, P1_6
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_5
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly2= Poly2, rsq, P1_5
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi =  S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: r_to_the_8 = r_to_the_8 * r_to_the_8
//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p11) fma.s1 Poly2 = Poly2, rsq, P1_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result = CORR + Poly * r
//    N odd:  P = Q1_1 + poly2 * rsq
//
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Poly2 = P1_4 + Poly2 * rsq
//    N odd:  poly2 = Q1_2 + poly2 * rsq
//
(p11) fma.s1 Poly = Poly2, r_to_the_8, Poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, c, poly1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Poly = Poly1 + Poly2 * r_to_the_8
//    N odd:  S_hi =  S_hi * poly1 + S_hi    64 bits
//
(p11) fma.s1 Result = Poly, r, CORR
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result =  r + Result  (User supplied rounding mode)
//    N odd:  poly1  =  S_hi * c + poly1
//
(p12) fmpy.s1 S_lo = S_hi, poly1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 P = poly2, rsq, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * r + 1.0
//
(p11) fadd.s0 Result = Result, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  S_hi *  poly1
//
(p12) fma.s1 S_lo = Q1_1, c, S_lo
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:  Result = Result + S_hi  (user supplied rounding mode)
//
(p0)  fmpy.s0 Q1_1 = Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  Q1_1 * c + S_lo
//
(p12) fma.s1 Result = P, r, S_lo
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    N odd:  Result =  S_lo + r * P
//
(p12) fadd.s0 Result = Result, S_hi
//
//    Do multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_NORMAL_R: 

{ .mfi
(p0)  getf.sig sig_r = r
// *******************************************************************
// *******************************************************************
// *******************************************************************
//
//    r and c have been computed.
//    Make sure ftz mode is set - should be automatic when using wre
//
//
//    Get [i_1] -  lsb of N_fix_gr alone.
//
(p0)  fmerge.s  Pos_r = f1, r
(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
}

{ .mfi
	nop.m 999
(p0)  fmerge.s  sgn_r =  r, f1
(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1 ;;
}

{ .mfi
	nop.m 999
	nop.f 999
(p0)  extr.u lookup = sig_r, 58, 5
}

{ .mlx
	nop.m 999
(p0)  movl Create_B = 0x8200000000000000 ;;
}

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
	nop.f 999
(p0)  dep Create_B = lookup, Create_B, 58, 5
}
;;

//
//    Get [i_1] -  lsb of N_fix_gr alone.
//    Pos_r = abs (r)
//


{ .mmi
      ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;


{ .mmi
	nop.m 999
(p0)  setf.sig B = Create_B
//
//    Set table_ptr1 and table_ptr2 to base address of
//    constant table.
//
(p0)  add table_ptr1 = 480, table_ptr1 ;;
}

{ .mmb
	nop.m 999
//
//    Is i_1 or i_0  == 0 ?
//    Create the constant  1 00000 1000000000000000000000...
//
(p0)  ldfe P2_1 = [table_ptr1], 16
	nop.b 999
}

{ .mmi
	nop.m 999 ;;
(p0)  getf.exp exp_r = Pos_r
	nop.i 999
}
//
//    Get r's exponent
//    Get r's significand
//

{ .mmi
(p0)  ldfe P2_2 = [table_ptr1], 16 ;;
//
//    Get the 5 bits or r for the lookup.   1.xxxxx ....
//    from sig_r.
//    Grab  lsb of exp of B
//
(p0)  ldfe P2_3 = [table_ptr1], 16
	nop.i 999 ;;
}

{ .mii
	nop.m 999
(p0)  andcm table_offset = 0x0001, exp_r ;;
(p0)  shl table_offset = table_offset, 9 ;;
}

{ .mii
	nop.m 999
//
//    Deposit   0 00000 1000000000000000000000... on
//              1 xxxxx yyyyyyyyyyyyyyyyyyyyyy...,
//    getting rid of the ys.
//    Is  B = 2** -2 or  B= 2** -1? If 2**-1, then
//    we want an offset of 512 for table addressing.
//
(p0)  shladd table_offset = lookup, 4, table_offset ;;
//
//    B =  ........ 1xxxxx 1000000000000000000...
//
(p0)  add table_ptr1 = table_ptr1, table_offset ;;
}

{ .mmb
	nop.m 999
//
//   B =  ........ 1xxxxx 1000000000000000000...
//   Convert B so it has the same exponent as Pos_r
//
(p0)  ldfd T_hi = [table_ptr1], 8
	nop.b 999 ;;
}

//
//    x = |r| - B
//    Load T_hi.
//    Load C_hi.
//

{ .mmf
(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
(p0)  ldfs T_lo = [table_ptr1]
(p0)  fmerge.se B = Pos_r, B
}
;;

{ .mmi
      ld8 table_ptr2 = [table_ptr2]
      nop.m 999
      nop.i 999
}
;;

{ .mii
(p0)  add table_ptr2 = 1360, table_ptr2
	nop.i 999 ;;
(p0)  add table_ptr2 = table_ptr2, table_offset ;;
}

{ .mfi
(p0)  ldfd C_hi = [table_ptr2], 8
(p0)  fsub.s1 x = Pos_r, B
	nop.i 999 ;;
}

{ .mii
(p0)  ldfs C_lo = [table_ptr2],255
	nop.i 999 ;;
//
//    xsq = x * x
//    N even: Tx = T_hi * x
//    Load T_lo.
//    Load C_lo - increment pointer to get SC_inv 
//    - cant get all the way, do an add later.
//
(p0)  add table_ptr2 = 569, table_ptr2 ;;
}
//
//    N even: Tx1 = Tx + 1
//    N odd:  Cx1 = 1 - Cx
//

{ .mfi
(p0)  ldfe SC_inv = [table_ptr2], 0
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 xsq = x, x
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 Tx = T_hi, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 Cx = C_hi, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd: Cx = C_hi * x
//
(p0)  fma.s1 P = P2_3, xsq, P2_2
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P2_3 + P2_2 * xsq
//
(p11) fadd.s1 Tx1 = Tx, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: D = C_hi - tanx
//    N odd: D = T_hi + tanx
//
(p11) fmpy.s1 CORR = SC_inv, T_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 Sx = SC_inv, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 CORR = SC_inv, C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fsub.s1 V_hi = f1, Cx
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fma.s1 P = P, xsq, P2_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P2_1 + P * xsq
//
(p11) fma.s1 V_hi = Tx, Tx1, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result  = sgn_r * tail + T_hi (user rounding mode for C1)
//    N odd:  Result  = sgn_r * tail + C_hi (user rounding mode for C1)
//
(p0)  fmpy.s0 P2_1 = P2_1, P2_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 CORR = CORR, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_hi = Cx,V_hi,f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_hi = Tx * Tx1 + 1
//    N odd: Cx1 = 1 - Cx * Cx1
//
(p0)  fmpy.s1 P = P, xsq
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P * xsq
//
(p11) fmpy.s1 V_hi = V_hi, T_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = P * tail + V_lo
//
(p11) fmpy.s1 T_hi = sgn_r, T_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 CORR = CORR, sgn_r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 V_hi = V_hi,C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_hi = T_hi * V_hi
//    N odd: V_hi  = C_hi * V_hi
//
(p0)  fma.s1 tanx = P, x, x
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnmpy.s1 C_hi = sgn_r, C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_lo = 1 - V_hi + C_hi
//    N odd: V_lo = 1 - V_hi + T_hi
//
(p11) fadd.s1 CORR = CORR, T_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fsub.s1 CORR = CORR, C_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tanx = x + x * P
//    N even and odd: Sx = SC_inv * x
//
(p11) fsub.s1 D = C_hi, tanx
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fadd.s1 D = T_hi, tanx
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd: CORR = SC_inv * C_hi
//    N even: CORR = SC_inv * T_hi
//
(p0)  fnma.s1 D = V_hi, D, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: D = 1 - V_hi * D
//    N even and odd: CORR = CORR * c
//
(p0)  fma.s1 V_hi = V_hi, D, V_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: V_hi = V_hi + V_hi * D
//    N even and odd: CORR = sgn_r * CORR
//
(p11) fnma.s1 V_lo = V_hi, C_hi, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = V_hi, T_hi, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: CORR = COOR + T_lo
//    N odd: CORR = CORR - C_lo
//
(p11) fma.s1 V_lo = tanx, V_hi, V_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = tanx, V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_lo = V_lo + V_hi * tanx
//    N odd: V_lo = V_lo - V_hi * tanx
//
(p11) fnma.s1 V_lo = C_lo, V_hi, V_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = T_lo, V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N  even: V_lo = V_lo - V_hi * C_lo
//    N  odd: V_lo = V_lo - V_hi * T_lo
//
(p0)  fmpy.s1 V_lo = V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: V_lo = V_lo * V_hi
//
(p0)  fadd.s1 tail = V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = V_hi + V_lo
//
(p0)  fma.s1 tail = tail, P, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: T_hi = sgn_r * T_hi
//    N odd : C_hi = -sgn_r * C_hi
//
(p0)  fma.s1 tail = tail, Sx, CORR
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = Sx * tail + CORR
//
(p0)  fma.s1 tail = V_hi, Sx, tail
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even an odd: tail = Sx * V_hi + tail
//
(p11) fma.s0 Result = sgn_r, tail, T_hi
	nop.i 999
}

{ .mfb
	nop.m 999
(p12) fma.s0 Result = sgn_r, tail, C_hi
//
//    Do a multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}

.endp __libm_tan



// *******************************************************************
// *******************************************************************
// *******************************************************************
//
//     Special Code to handle very large argument case.
//     Call int pi_by_2_reduce(&x,&r)
//     for |arguments| >= 2**63
//     (Arg or x) is in f8
//     Address to save r and c as double

//                 (1)                    (2)                 (3) (call)         (4)
//            sp -> +               psp -> +            psp -> +           sp ->  +
//                  |                      |                   |                  |
//                  |                r50 ->| <- r50      f0  ->|           r50 -> | -> c
//                  |                      |                   |                  |
//         sp-32 -> | <- r50          f0 ->|             f0  ->| <- r50    r49 -> | -> r
//                  |                      |                   |                  |
//                  |               r49  ->| <- r49     Arg  ->| <- r49           | -> x
//                  |                      |                   |                  |
//         sp -64 ->|             sp -64 ->|          sp -64 ->|                  |
//
//            save pfs           save b0                                     restore gp
//            save gp                                                        restore b0
//                                                                           restore pfs



.proc __libm_callout
__libm_callout:
TAN_ARG_TOO_LARGE: 
.prologue
// (1)
{ .mfi
        add   GR_Parameter_r =-32,sp                        // Parameter: r address
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;

// (2)
{ .mmi
        stfe [GR_Parameter_r ] = f0,16                      // Clear Parameter r on stack
        add  GR_Parameter_X = 16,sp                        // Parameter x address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

// (3)
.body
{ .mib
        stfe [GR_Parameter_r ] = f0,-16                     // Clear Parameter c on stack
        nop.i 0
        nop.b 0
}
{ .mib
        stfe [GR_Parameter_X] = Arg                        // Store Parameter x on stack
        nop.i 0
(p0)    br.call.sptk b0=__libm_pi_by_2_reduce#
}
;;


// (4)
{ .mmi
        mov   gp = GR_SAVE_GP                  // Restore gp
(p0)    mov   N_fix_gr = r8 
        nop.i 999
}
;;

{ .mmi
(p0)    ldfe  Arg        =[GR_Parameter_X],16
(p0)    ldfs  TWO_TO_NEG2 = [table_ptr2],4
        nop.i 999
}
;;


{ .mmb
(p0)    ldfe  r =[GR_Parameter_r ],16
(p0)    ldfs  NEGTWO_TO_NEG2 = [table_ptr2],4
        nop.b 999 ;;
}

{ .mfi
(p0)    ldfe  c =[GR_Parameter_r ]
        nop.f 999
        nop.i 999 ;;
}

{ .mfi
        nop.m 999
//
//     Is |r| < 2**(-2)
//
(p0)   fcmp.lt.unc.s1  p6, p0 = r, TWO_TO_NEG2
        mov   b0 = GR_SAVE_B0                  // Restore return address
}
;;

{ .mfi
       nop.m 999
(p6)   fcmp.gt.unc.s1  p6, p0 = r, NEGTWO_TO_NEG2
       mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
}
;;

{ .mbb
.restore
        add   sp = 64,sp                       // Restore stack pointer
(p6)   br.cond.spnt TAN_SMALL_R
(p0)   br.cond.sptk TAN_NORMAL_R 
}
;;
.endp __libm_callout


.proc __libm_TAN_SPECIAL
__libm_TAN_SPECIAL:

//
//     Code for NaNs, Unsupporteds, Infs, or +/- zero ?
//     Invalid raised for Infs and SNaNs.
//

{ .mfb
	nop.m 999
(p0)   fmpy.s0 Arg = Arg, f0
(p0)   br.ret.sptk b0 
}
.endp __libm_TAN_SPECIAL


.type __libm_pi_by_2_reduce#,@function
.global __libm_pi_by_2_reduce#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\powf.s ===
.file "powf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/03/00  Added p12 to definite over/under path. With odd power we did not
//          maintain the sign of x in this path.
// 4/04/00  Unwind support added
// 4/19/00  pow(+-1,inf) now returns NaN
//          pow(+-val, +-inf) returns 0 or inf, but now does not call error support
//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 9/07/00  Improved performance by eliminating bank conflicts and other stalls,
//          and tweaking the critical path
// 9/08/00  Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
// 9/28/00  Updated NaN**0 path
//
// API
//==============================================================
// double pow(double)
// float  powf(float)
//
// Overview of operation
//==============================================================
//
// Three steps...
// 1. Log(x)
// 2. y Log(x)
// 3. exp(y log(x))
// 
// This means we work with the absolute value of x and merge in the sign later.
//      Log(x) = G + delta + r -rsq/2 + p
// G,delta depend on the exponent of x and table entries. The table entries are
// indexed by the exponent of x, called K.
// 
// The G and delta come out of the reduction; r is the reduced x.
// 
// B = frcpa(x)
// xB-1 is small means that B is the approximate inverse of x.
// 
//      Log(x) = Log( (1/B)(Bx) )
//             = Log(1/B) + Log(Bx)
//             = Log(1/B) + Log( 1 + (Bx-1))
// 
//      x  = 2^K 1.x_1x_2.....x_52
//      B= frcpa(x) = 2^-k Cm 
//      Log(1/B) = Log(1/(2^-K Cm))
//      Log(1/B) = Log((2^K/ Cm))
//      Log(1/B) = K Log(2) + Log(1/Cm)
// 
//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
// 
// If you take the significand of x, set the exponent to true 0, then Cm is
// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
// m = x_1x_2...x_8 is an 8-bit index.
// 
//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
// 
// We tabluate as two doubles, T and t, where T +t is the value itself.
// 
//      Log(x)   = (K Log(2)_hi + T) + (Log(2)_hi + t) + Log( 1 + (Bx-1))
//      Log(x)   =  G + delta           + Log( 1 + (Bx-1))
// 
// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
// 
//      Log( 1 + (Bx-1)) = r - rsq/2 + p
// 
// Then,
//    
//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
//      yLog(x) = Z1 + e3      + Z2         + Z3 + (e2 + e3)
// 
// 
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//
//
//       exp(Z3) is another series.
//       exp(e1 + e2 + e3) is approximated as f3 = 1 + (e1 + e2 + e3)
//
//       Z1 (128/log2) = number of log2/128 in Z1 is N1
//       Z2 (128/log2) = number of log2/128 in Z2 is N2
//
//       s1 = Z1 - N1 log2/128
//       s2 = Z2 - N2 log2/128
//
//       s = s1 + s2
//       N = N1 + N2
//
//       exp(Z1 + Z2) = exp(Z)
//       exp(Z)       = exp(s) exp(N log2/128)
//
//       exp(r)       = exp(Z - N log2/128)
//
//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
//                =  Z - N (log2/128) 
//
//      Z         = s+d +N (log2/128)
//
//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
//
//      N = M 128 + n
//
//      N log2/128 = M log2 + n log2/128
//
//      n is 8 binary digits = n_7n_6...n_1
//
//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
//      n log2/128 = I2 log2/8 + I1 log2/128
//
//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128 
//
//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
//      exp(Z)    = exp(s) (1+d1) (1+d2)(2^M) 2^I2/8 2^I1/128
//      exp(Z)    = exp(s) f1 f2 (2^M) 2^I2/8 2^I1/128
//
// I1, I2 are table indices. Use a series for exp(s).
// Then get exp(Z) 
//
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//     exp(yLog(x)) = exp(Z) exp(Z3) f3 
//     exp(yLog(x)) = exp(Z)f3 exp(Z3)  
//     exp(yLog(x)) = A exp(Z3)  
//
// We actually calculate exp(Z3) -1.
// Then, 
//     exp(yLog(x)) = A + A( exp(Z3)   -1)
//

// Table Generation
//==============================================================

// The log values
// ==============
// The operation (K*log2_hi) must be exact. K is the true exponent of x.
// If we allow gradual underflow (denormals), K can be represented in 12 bits
// (as a two's complement number). We assume 13 bits as an engineering precaution.
// 
//           +------------+----------------+-+
//           |  13 bits   | 50 bits        | |
//           +------------+----------------+-+
//           0            1                66
//                        2                34
// 
// So we want the lsb(log2_hi) to be 2^-50
// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
// 
//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
// 
// Consider numbering the bits left to right, starting at 0 thru 127.
// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
// 
//  ...79ab
//     0111 1001 1010 1011
//     44
//     89
// 
// So if we shift off the rightmost 14 bits, then (shift back only 
// the top half) we get
// 
//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
// 
// Put the right 64-bit signficand in an FR register, convert to double;
// it is exact. Put the next 128 bits into a quad register and round to double.
// The true exponent of the low part is -51.
// 
// hi is 0 fffe b17217f7d1cf4000
// lo is 0 ffcc e6af278ece601000
// 
// Convert to double memory format and get
// 
// hi is 0x3fe62e42fefa39e8
// lo is 0x3cccd5e4f1d9cc02 
// 
// log2_hi + log2_lo is an accurate value for log2.
// 
// 
// The T and t values
// ==================
// A similar method is used to generate the T and t values.
// 
// K * log2_hi + T  must be exact.
// 
// Smallest T,t
// ----------
// The smallest T,t is 
//       T                   t
// data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
// 
// The exponent is 0x3f6 (biased)  or -9 (true).
// For the smallest T value, what we want is to clip the significand such that
// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the specific 
// for the first entry. In general, it is 0xffff - (biased 15-bit exponent).

// Independently, what we have calculated is the table value as a quad precision number.
// Table entry 1 is
// 0 fff6 80200aaeac44ef38 338f77605fdf8000
// 
// We store this quad precision number in a data structure that is
//    sign:           1 
//    exponent:      15
//    signficand_hi: 64 (includes explicit bit)
//    signficand_lo: 49
// Because the explicit bit is included, the significand is 113 bits.
// 
// Consider significand_hi for table entry 1.
// 
// 
// +-+--- ... -------+--------------------+
// | |
// +-+--- ... -------+--------------------+
// 0 1               4444444455555555556666
//                   2345678901234567890123
// 
// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
// bit 42 goes in 51.
// 
// So what we want to do is shift bits 43 thru 63 into significand_lo.
// This is shifting bit 42 into bit 63, taking care to retain the shifted-off bits.
// Then shifting (just with signficaand_hi) back into bit 42. 
//  
// The shift_value is 63-42 = 21. In general, this is 
//      63 - (51 -(0xffff - 0xfff6))
// For this example, it is
//      63 - (51 - 9) = 63 - 42  = 21
// 
// This means we are shifting 21 bits into significand_lo.  We must maintain more
// that a 128-bit signficand not to lose bits. So before the shift we put the 128-bit 
// significand into a 256-bit signficand and then shift.
// The 256-bit significand has four parts: hh, hl, lh, and ll.
// 
// Start off with
//      hh         hl         lh         ll
//      <64>       <49><15_0> <64_0>     <64_0>
// 
// After shift by 21 (then return for significand_hi),
//      <43><21_0> <21><43>   <6><58_0>  <64_0>
// 
// Take the hh part and convert to a double. There is no rounding here.
// The conversion is exact. The true exponent of the high part is the same as the
// true exponent of the input quad.
// 
// We have some 64 plus significand bits for the low part. In this example, we have
// 70 bits. We want to round this to a double. Put them in a quad and then do a quad fnorm.
// For this example the true exponent of the low part is 
//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
// In general, this is 
//      true_exponent_of_high - (64 - shift_value)  
// 
// 
// Largest T,t
// ----------
// The largest T,t is
// data8 0x3fe62643fecf9742, 0x3c9e3147684bd37d    log(1/frcpa(1+255/256))=  +6.92171e-001
// 
// Table entry 256 is
// 0 fffe b1321ff67cba178c 51da12f4df5a0000
// 
// The shift value is 
//      63 - (51 -(0xffff - 0xfffe)) = 13
// 
// The true exponent of the low part is 
//      true_exponent_of_high - (64 - shift_value)
//      -1 - (64-13) = -52
// Biased as a double, this is 0x3cb
// 
// 
// 
// So then lsb(T) must be >= 2^-51
// msb(Klog2_hi) <= 2^12
// 
//              +--------+---------+
//              |       51 bits    | <== largest T
//              +--------+---------+
//              | 9 bits | 42 bits | <== smallest T
// +------------+----------------+-+
// |  13 bits   | 50 bits        | |
// +------------+----------------+-+



// Special Cases
//==============================================================

//                                   double     float
// overflow                          error 24   30

// underflow                         error 25   31

// X zero  Y zero
//  +0     +0                 +1     error 26   32
//  -0     +0                 +1     error 26   32
//  +0     -0                 +1     error 26   32
//  -0     -0                 +1     error 26   32

// X zero  Y negative
//  +0     -odd integer       +inf   error 27   33  divide-by-zero
//  -0     -odd integer       -inf   error 27   33  divide-by-zero
//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
//  +0     -inf               +inf   error 27   33  divide-by-zero
//  -0     -inf               +inf   error 27   33  divide-by-zero

// X zero  Y positve
//  +0     +odd integer       +0
//  -0     +odd integer       -0
//  +0     !+odd integer      +0
//  -0     !+odd integer      +0
//  +0     +inf               +0
//  -0     +inf               +0

// X one
//  -1     Y inf              +1
//  -1     Y NaN              quiet Y               invalid if Y SNaN
//  +1     Y any              +1

// X -     Y not integer      QNAN   error 28   34  invalid

// X NaN   Y 0                +1     error 29   35
// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
// X NaN   Y any else         quiet X               invalid if X SNaN
// X !+1   Y NaN              quiet Y               invalid if Y SNaN


// X +inf  Y >0               +inf
// X -inf  Y >0, !odd integer +inf
// X -inf  Y >0, odd integer  -inf

// X +inf  Y <0               +0
// X -inf  Y <0, !odd integer +0
// X -inf  Y <0, odd integer  -0

// X +inf  Y =0               +0
// X -inf  Y =0               +0

// Assembly macros
//==============================================================

// integer registers used

pow_AD_Tt                 = r33
pow_GR_FFF7               = r34
pow_GR_exp_Y              = r34 // duplicate
pow_GR_17ones             = r35

pow_AD_P                  = r36
pow_AD_Q                  = r37
pow_AD_tbl1               = r38
pow_AD_tbl2               = r39
pow_GR_exp_X              = r40
pow_GR_true_exp_X         = r40 // duplicate

pow_GR_offset             = r41
pow_GR_exp_Xm1            = r42
pow_GR_sig_X              = r43
pow_GR_signexp_X          = r44

pow_GR_signexp_Xm1        = r46
pow_GR_int_W1             = r47
pow_GR_int_W2             = r48
pow_GR_int_N              = r49
pow_GR_index1             = r50

pow_GR_index2             = r51
pow_AD_T1                 = r52
pow_AD_T2                 = r53
pow_GR_gt_ln              = r53 // duplicate
pow_int_GR_M              = r54
pow_GR_FFFE               = r55
pow_GR_10033              = r55

pow_GR_16ones             = r56
pow_GR_sig_int_Y          = r57
pow_GR_sign_Y_Gpr         = r58
pow_GR_17ones_m1          = r59
pow_GR_one                = r60
pow_GR_sign_Y             = r60 

pow_GR_signexp_Y_Gpr      = r61 
pow_GR_exp_Y_Gpr          = r62 
pow_GR_true_exp_Y_Gpr     = r63 
pow_GR_signexp_Y          = r64 

GR_SAVE_B0                = r65
GR_SAVE_GP                = r66
GR_SAVE_PFS               = r67

GR_Parameter_X            = r68
GR_Parameter_Y            = r69
GR_Parameter_RESULT       = r70
pow_GR_tag                = r71


// floating point registers used

POW_B                     = f32
POW_NORM_X                = f33
POW_Xm1                   = f34
POW_r1                    = f34
POW_P4                    = f35

POW_P5                    = f36
POW_NORM_Y                = f37
POW_Q2                    = f38
POW_Q3                    = f39
POW_P2                    = f40

POW_P3                    = f41
POW_P0                    = f42
POW_log2_lo               = f43
POW_r                     = f44
POW_Q0                    = f45

POW_Q1                    = f46  
POW_v21                   = f47
POW_log2_hi               = f48
POW_Q4                    = f49
POW_P1                    = f50

POW_log2_by_128_hi        = f51
POW_inv_log2_by_128       = f52
POW_rsq                   = f53
POW_r1sq                  = f54
POW_log2_by_128_lo        = f55

POW_v6                    = f56
POW_v61                   = f57
POW_v4                    = f58
POW_v2                    = f59
POW_T                     = f60

POW_Tt                    = f61
POW_r1sq_by_2             = f62
POW_rsq_by_2              = f63
POW_r1cub                 = f64
POW_rcub                  = f65

POW_U                     = f66
POW_G                     = f67
POW_delta                 = f68
POW_v3                    = f69
POW_V                     = f70

POW_p                     = f71
POW_Z1                    = f72
POW_e3                    = f73
POW_e2                    = f74
POW_Z2                    = f75

POW_e1                    = f76
POW_W1                    = f77
POW_UmZ2                  = f78
POW_W2                    = f79
POW_Z3                    = f80

POW_int_W1                = f81
POW_e12                   = f82
POW_int_W2                = f83
POW_UmZ2pV                = f84
POW_Z3sq                  = f85

POW_e123                  = f86
POW_N1float               = f87
POW_N2float               = f88
POW_f3                    = f89
POW_q                     = f90

POW_s1                    = f91
POW_Nfloat                = f92
POW_s2                    = f93
POW_f2                    = f94
POW_f1                    = f95

POW_T1                    = f96
POW_T2                    = f97
POW_2M                    = f98
POW_s                     = f99
POW_f12                   = f100

POW_ssq                   = f101
POW_T1T2                  = f102
POW_1ps                   = f103
POW_A                     = f104
POW_es                    = f105

POW_half                  = f106
POW_int_K                 = f107
POW_K                     = f108
POW_f123                  = f109
POW_Gpr                   = f110

POW_Y_Gpr                 = f111 
POW_int_Y                 = f112
POW_v61                   = f113
POW_v41                   = f114
POW_abs_f8                = f115

POW_float_int_Y           = f116
POW_ftz_urm_f8            = f117
POW_wre_urm_f8            = f118
POW_abs_A                 = f119
POW_gt_pln                = f120

POW_ABS_NORM_X            = f121

// Data tables
//==============================================================

.data

.align 16

pow_table_P:
data8 0x9249FE7F0DC423CF, 0x00003FFC  // P_4
data8 0x8000F7B249FF332D, 0x0000BFFC  // P_5
data8 0xAAAAAAA9E7902C7F, 0x0000BFFC  // P_3
data8 0x80000000000018E5, 0x0000BFFD  // P_1
data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128
data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo


data8 0x3FA5555555554A9E // Q_2
data8 0x3F8111124F4DD9F9 // Q_3
data8 0x3FE0000000000000 // Q_0
data8 0x3FC5555555554733 // Q_1
data8 0x3F56C16D9360FFA0 // Q_4
data8 0x0000000000000000 // pad
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q

pow_Tt:
data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81 // log(1/frcpa(1+0/256))=  +1.95503e-003
data8 0x3f78121214586a00, 0x3cb540e0a5cfc9bc // log(1/frcpa(1+1/256))=  +5.87661e-003
data8 0x3f841929f9683200, 0x3cbdf1d57404da1f // log(1/frcpa(1+2/256))=  +9.81362e-003
data8 0x3f8c317384c75f00, 0x3c69806208c04c22 // log(1/frcpa(1+3/256))=  +1.37662e-002
data8 0x3f91a6b91ac73380, 0x3c7874daa716eb32 // log(1/frcpa(1+4/256))=  +1.72376e-002
data8 0x3f95ba9a5d9ac000, 0x3cacbb84e08d78ac // log(1/frcpa(1+5/256))=  +2.12196e-002
data8 0x3f99d2a807432580, 0x3cbcf80538b441e1 // log(1/frcpa(1+6/256))=  +2.52177e-002
data8 0x3f9d6b2725979800, 0x3c6095e5c8f8f359 // log(1/frcpa(1+7/256))=  +2.87291e-002
data8 0x3fa0c58fa19dfa80, 0x3cb4c5d4e9d0dda2 // log(1/frcpa(1+8/256))=  +3.27573e-002
data8 0x3fa2954c78cbce00, 0x3caa932b860ab8d6 // log(1/frcpa(1+9/256))=  +3.62953e-002
data8 0x3fa4a94d2da96c40, 0x3ca670452b76bbd5 // log(1/frcpa(1+10/256))=  +4.03542e-002
data8 0x3fa67c94f2d4bb40, 0x3ca84104f9941798 // log(1/frcpa(1+11/256))=  +4.39192e-002
data8 0x3fa85188b630f040, 0x3cb40a882cbf0153 // log(1/frcpa(1+12/256))=  +4.74971e-002
data8 0x3faa6b8abe73af40, 0x3c988d46e25c9059 // log(1/frcpa(1+13/256))=  +5.16017e-002
data8 0x3fac441e06f72a80, 0x3cae3e930a1a2a96 // log(1/frcpa(1+14/256))=  +5.52072e-002
data8 0x3fae1e6713606d00, 0x3c8a796f6283b580 // log(1/frcpa(1+15/256))=  +5.88257e-002
data8 0x3faffa6911ab9300, 0x3c5193070351e88a // log(1/frcpa(1+16/256))=  +6.24574e-002
data8 0x3fb0ec139c5da600, 0x3c623f2a75eb992d // log(1/frcpa(1+17/256))=  +6.61022e-002
data8 0x3fb1dbd2643d1900, 0x3ca649b2ef8927f0 // log(1/frcpa(1+18/256))=  +6.97605e-002
data8 0x3fb2cc7284fe5f00, 0x3cbc5e86599513e2 // log(1/frcpa(1+19/256))=  +7.34321e-002
data8 0x3fb3bdf5a7d1ee60, 0x3c90bd4bb69dada3 // log(1/frcpa(1+20/256))=  +7.71173e-002
data8 0x3fb4b05d7aa012e0, 0x3c54e377c9b8a54f // log(1/frcpa(1+21/256))=  +8.08161e-002
data8 0x3fb580db7ceb5700, 0x3c7fdb2f98354cde // log(1/frcpa(1+22/256))=  +8.39975e-002
data8 0x3fb674f089365a60, 0x3cb9994c9d3301c1 // log(1/frcpa(1+23/256))=  +8.77219e-002
data8 0x3fb769ef2c6b5680, 0x3caaec639db52a79 // log(1/frcpa(1+24/256))=  +9.14602e-002
data8 0x3fb85fd927506a40, 0x3c9f9f99a3cf8e25 // log(1/frcpa(1+25/256))=  +9.52125e-002
data8 0x3fb9335e5d594980, 0x3ca15c3abd47d99a // log(1/frcpa(1+26/256))=  +9.84401e-002
data8 0x3fba2b0220c8e5e0, 0x3cb4ca639adf6fc3 // log(1/frcpa(1+27/256))=  +1.02219e-001
data8 0x3fbb0004ac1a86a0, 0x3ca7cb81bf959a59 // log(1/frcpa(1+28/256))=  +1.05469e-001
data8 0x3fbbf968769fca00, 0x3cb0c646c121418e // log(1/frcpa(1+29/256))=  +1.09274e-001
data8 0x3fbccfedbfee13a0, 0x3ca0465fce24ab4b // log(1/frcpa(1+30/256))=  +1.12548e-001
data8 0x3fbda727638446a0, 0x3c82803f4e2e6603 // log(1/frcpa(1+31/256))=  +1.15832e-001
data8 0x3fbea3257fe10f60, 0x3cb986a3f2313d1a // log(1/frcpa(1+32/256))=  +1.19677e-001
data8 0x3fbf7be9fedbfde0, 0x3c97d16a6a621cf4 // log(1/frcpa(1+33/256))=  +1.22985e-001
data8 0x3fc02ab352ff25f0, 0x3c9cc6baad365600 // log(1/frcpa(1+34/256))=  +1.26303e-001
data8 0x3fc097ce579d2040, 0x3cb9ba16d329440b // log(1/frcpa(1+35/256))=  +1.29633e-001
data8 0x3fc1178e8227e470, 0x3cb7bc671683f8e6 // log(1/frcpa(1+36/256))=  +1.33531e-001
data8 0x3fc185747dbecf30, 0x3c9d1116f66d2345 // log(1/frcpa(1+37/256))=  +1.36885e-001
data8 0x3fc1f3b925f25d40, 0x3c8162c9ef939ac6 // log(1/frcpa(1+38/256))=  +1.40250e-001
data8 0x3fc2625d1e6ddf50, 0x3caad3a1ec384fc3 // log(1/frcpa(1+39/256))=  +1.43627e-001
data8 0x3fc2d1610c868130, 0x3cb3ad997036941b // log(1/frcpa(1+40/256))=  +1.47015e-001
data8 0x3fc340c597411420, 0x3cbc2308262c7998 // log(1/frcpa(1+41/256))=  +1.50414e-001
data8 0x3fc3b08b6757f2a0, 0x3cb2170d6cdf0526 // log(1/frcpa(1+42/256))=  +1.53825e-001
data8 0x3fc40dfb08378000, 0x3c9bb453c4f7b685 // log(1/frcpa(1+43/256))=  +1.56677e-001
data8 0x3fc47e74e8ca5f70, 0x3cb836a48fdfce9d // log(1/frcpa(1+44/256))=  +1.60109e-001
data8 0x3fc4ef51f6466de0, 0x3ca07a43919aa64b // log(1/frcpa(1+45/256))=  +1.63553e-001
data8 0x3fc56092e02ba510, 0x3ca85006899d97b0 // log(1/frcpa(1+46/256))=  +1.67010e-001
data8 0x3fc5d23857cd74d0, 0x3ca30a5ba6e7abbe // log(1/frcpa(1+47/256))=  +1.70478e-001
data8 0x3fc6313a37335d70, 0x3ca905586f0ac97e // log(1/frcpa(1+48/256))=  +1.73377e-001
data8 0x3fc6a399dabbd380, 0x3c9b2c6657a96684 // log(1/frcpa(1+49/256))=  +1.76868e-001
data8 0x3fc70337dd3ce410, 0x3cb50bc52f55cdd8 // log(1/frcpa(1+50/256))=  +1.79786e-001
data8 0x3fc77654128f6120, 0x3cad2eb7c9a39efe // log(1/frcpa(1+51/256))=  +1.83299e-001
data8 0x3fc7e9d82a0b0220, 0x3cba127e90393c01 // log(1/frcpa(1+52/256))=  +1.86824e-001
data8 0x3fc84a6b759f5120, 0x3cbd7fd52079f706 // log(1/frcpa(1+53/256))=  +1.89771e-001
data8 0x3fc8ab47d5f5a300, 0x3cbfae141751a3de // log(1/frcpa(1+54/256))=  +1.92727e-001
data8 0x3fc91fe490965810, 0x3cb69cf30a1c319e // log(1/frcpa(1+55/256))=  +1.96286e-001
data8 0x3fc981634011aa70, 0x3ca5bb3d208bc42a // log(1/frcpa(1+56/256))=  +1.99261e-001
data8 0x3fc9f6c407089660, 0x3ca04d68658179a0 // log(1/frcpa(1+57/256))=  +2.02843e-001
data8 0x3fca58e729348f40, 0x3c99f5411546c286 // log(1/frcpa(1+58/256))=  +2.05838e-001
data8 0x3fcabb55c31693a0, 0x3cb9a5350eb327d5 // log(1/frcpa(1+59/256))=  +2.08842e-001
data8 0x3fcb1e104919efd0, 0x3c18965fcce7c406 // log(1/frcpa(1+60/256))=  +2.11855e-001
data8 0x3fcb94ee93e367c0, 0x3cb503716da45184 // log(1/frcpa(1+61/256))=  +2.15483e-001
data8 0x3fcbf851c0675550, 0x3cbdf1b3f7ab5378 // log(1/frcpa(1+62/256))=  +2.18516e-001
data8 0x3fcc5c0254bf23a0, 0x3ca7aab9ed0b1d7b // log(1/frcpa(1+63/256))=  +2.21558e-001
data8 0x3fccc000c9db3c50, 0x3c92a7a2a850072a // log(1/frcpa(1+64/256))=  +2.24609e-001
data8 0x3fcd244d99c85670, 0x3c9f6019120edf4c // log(1/frcpa(1+65/256))=  +2.27670e-001
data8 0x3fcd88e93fb2f450, 0x3c6affb96815e081 // log(1/frcpa(1+66/256))=  +2.30741e-001
data8 0x3fcdedd437eaef00, 0x3c72553595897976 // log(1/frcpa(1+67/256))=  +2.33820e-001
data8 0x3fce530effe71010, 0x3c90913b020fa182 // log(1/frcpa(1+68/256))=  +2.36910e-001
data8 0x3fceb89a1648b970, 0x3c837ba4045bfd25 // log(1/frcpa(1+69/256))=  +2.40009e-001
data8 0x3fcf1e75fadf9bd0, 0x3cbcea6d13e0498d // log(1/frcpa(1+70/256))=  +2.43117e-001
data8 0x3fcf84a32ead7c30, 0x3ca5e3a67b3c6d77 // log(1/frcpa(1+71/256))=  +2.46235e-001
data8 0x3fcfeb2233ea07c0, 0x3cba0c6f0049c5a6 // log(1/frcpa(1+72/256))=  +2.49363e-001
data8 0x3fd028f9c7035c18, 0x3cb0a30b06677ff6 // log(1/frcpa(1+73/256))=  +2.52501e-001
data8 0x3fd05c8be0d96358, 0x3ca0f1c77ccb5865 // log(1/frcpa(1+74/256))=  +2.55649e-001
data8 0x3fd085eb8f8ae790, 0x3cbd513f45fe7a97 // log(1/frcpa(1+75/256))=  +2.58174e-001
data8 0x3fd0b9c8e32d1910, 0x3c927449047ca006 // log(1/frcpa(1+76/256))=  +2.61339e-001
data8 0x3fd0edd060b78080, 0x3c89b52d8435f53e // log(1/frcpa(1+77/256))=  +2.64515e-001
data8 0x3fd122024cf00638, 0x3cbdd976fabda4bd // log(1/frcpa(1+78/256))=  +2.67701e-001
data8 0x3fd14be2927aecd0, 0x3cb02f90ad0bc471 // log(1/frcpa(1+79/256))=  +2.70257e-001
data8 0x3fd180618ef18ad8, 0x3cbd003792c71a98 // log(1/frcpa(1+80/256))=  +2.73461e-001
data8 0x3fd1b50bbe2fc638, 0x3ca9ae64c6403ead // log(1/frcpa(1+81/256))=  +2.76675e-001
data8 0x3fd1df4cc7cf2428, 0x3cb43f0455f7e395 // log(1/frcpa(1+82/256))=  +2.79254e-001
data8 0x3fd214456d0eb8d0, 0x3cb0fbd748d75d30 // log(1/frcpa(1+83/256))=  +2.82487e-001
data8 0x3fd23ec5991eba48, 0x3c906edd746b77e2 // log(1/frcpa(1+84/256))=  +2.85081e-001
data8 0x3fd2740d9f870af8, 0x3ca9802e6a00a670 // log(1/frcpa(1+85/256))=  +2.88333e-001
data8 0x3fd29ecdabcdfa00, 0x3cacecef70890cfa // log(1/frcpa(1+86/256))=  +2.90943e-001
data8 0x3fd2d46602adcce8, 0x3cb97911955f3521 // log(1/frcpa(1+87/256))=  +2.94214e-001
data8 0x3fd2ff66b04ea9d0, 0x3cb12dabe191d1c9 // log(1/frcpa(1+88/256))=  +2.96838e-001
data8 0x3fd335504b355a30, 0x3cbdf9139df924ec // log(1/frcpa(1+89/256))=  +3.00129e-001
data8 0x3fd360925ec44f58, 0x3cb253e68977a1e3 // log(1/frcpa(1+90/256))=  +3.02769e-001
data8 0x3fd38bf1c3337e70, 0x3cb3d283d2a2da21 // log(1/frcpa(1+91/256))=  +3.05417e-001
data8 0x3fd3c25277333180, 0x3cadaa5b035eae27 // log(1/frcpa(1+92/256))=  +3.08735e-001
data8 0x3fd3edf463c16838, 0x3cb983d680d3c108 // log(1/frcpa(1+93/256))=  +3.11399e-001
data8 0x3fd419b423d5e8c0, 0x3cbc86dd921c139d // log(1/frcpa(1+94/256))=  +3.14069e-001
data8 0x3fd44591e0539f48, 0x3c86a76d6dc2782e // log(1/frcpa(1+95/256))=  +3.16746e-001
data8 0x3fd47c9175b6f0a8, 0x3cb59a2e013c6b5f // log(1/frcpa(1+96/256))=  +3.20103e-001
data8 0x3fd4a8b341552b08, 0x3c93f1e86e468694 // log(1/frcpa(1+97/256))=  +3.22797e-001
data8 0x3fd4d4f390890198, 0x3cbf5e4ea7c5105a // log(1/frcpa(1+98/256))=  +3.25498e-001
data8 0x3fd501528da1f960, 0x3cbf58da53e9ad10 // log(1/frcpa(1+99/256))=  +3.28206e-001
data8 0x3fd52dd06347d4f0, 0x3cb98a28cebf6eef // log(1/frcpa(1+100/256))=  +3.30921e-001
data8 0x3fd55a6d3c7b8a88, 0x3c9c76b67c2d1fd4 // log(1/frcpa(1+101/256))=  +3.33644e-001
data8 0x3fd5925d2b112a58, 0x3c9029616a4331b8 // log(1/frcpa(1+102/256))=  +3.37058e-001
data8 0x3fd5bf406b543db0, 0x3c9fb8292ecfc820 // log(1/frcpa(1+103/256))=  +3.39798e-001
data8 0x3fd5ec433d5c35a8, 0x3cb71a1229d17eec // log(1/frcpa(1+104/256))=  +3.42545e-001
data8 0x3fd61965cdb02c18, 0x3cbba94fe1dbb8d2 // log(1/frcpa(1+105/256))=  +3.45300e-001
data8 0x3fd646a84935b2a0, 0x3c9ee496d2c9ae57 // log(1/frcpa(1+106/256))=  +3.48063e-001
data8 0x3fd6740add31de90, 0x3cb1da3a6c7a9dfd // log(1/frcpa(1+107/256))=  +3.50833e-001
data8 0x3fd6a18db74a58c0, 0x3cb494c257add8dc // log(1/frcpa(1+108/256))=  +3.53610e-001
data8 0x3fd6cf31058670e8, 0x3cb0b244a70a8da9 // log(1/frcpa(1+109/256))=  +3.56396e-001
data8 0x3fd6f180e852f0b8, 0x3c9db7aefa866720 // log(1/frcpa(1+110/256))=  +3.58490e-001
data8 0x3fd71f5d71b894e8, 0x3cbe91c4bf324957 // log(1/frcpa(1+111/256))=  +3.61289e-001
data8 0x3fd74d5aefd66d58, 0x3cb06b3d9bfac023 // log(1/frcpa(1+112/256))=  +3.64096e-001
data8 0x3fd77b79922bd378, 0x3cb727d8804491f4 // log(1/frcpa(1+113/256))=  +3.66911e-001
data8 0x3fd7a9b9889f19e0, 0x3ca2ef22df5bc543 // log(1/frcpa(1+114/256))=  +3.69734e-001
data8 0x3fd7d81b037eb6a0, 0x3cb8fd3ba07a7ece // log(1/frcpa(1+115/256))=  +3.72565e-001
data8 0x3fd8069e33827230, 0x3c8bd1e25866e61a // log(1/frcpa(1+116/256))=  +3.75404e-001
data8 0x3fd82996d3ef8bc8, 0x3ca5aab9f5928928 // log(1/frcpa(1+117/256))=  +3.77538e-001
data8 0x3fd85855776dcbf8, 0x3ca56f33337789d6 // log(1/frcpa(1+118/256))=  +3.80391e-001
data8 0x3fd8873658327cc8, 0x3cbb8ef0401db49d // log(1/frcpa(1+119/256))=  +3.83253e-001
data8 0x3fd8aa75973ab8c8, 0x3cbb9961f509a680 // log(1/frcpa(1+120/256))=  +3.85404e-001
data8 0x3fd8d992dc8824e0, 0x3cb220512a53732d // log(1/frcpa(1+121/256))=  +3.88280e-001
data8 0x3fd908d2ea7d9510, 0x3c985f0e513bfb5c // log(1/frcpa(1+122/256))=  +3.91164e-001
data8 0x3fd92c59e79c0e50, 0x3cb82e073fd30d63 // log(1/frcpa(1+123/256))=  +3.93332e-001
data8 0x3fd95bd750ee3ed0, 0x3ca4aa7cdb6dd8a8 // log(1/frcpa(1+124/256))=  +3.96231e-001
data8 0x3fd98b7811a3ee58, 0x3caa93a5b660893e // log(1/frcpa(1+125/256))=  +3.99138e-001
data8 0x3fd9af47f33d4068, 0x3cac294b3b3190ba // log(1/frcpa(1+126/256))=  +4.01323e-001
data8 0x3fd9df270c1914a0, 0x3cbe1a58fd0cd67e // log(1/frcpa(1+127/256))=  +4.04245e-001
data8 0x3fda0325ed14fda0, 0x3cb1efa7950fb57e // log(1/frcpa(1+128/256))=  +4.06442e-001
data8 0x3fda33440224fa78, 0x3c8915fe75e7d477 // log(1/frcpa(1+129/256))=  +4.09379e-001
data8 0x3fda57725e80c380, 0x3ca72bd1062b1b7f // log(1/frcpa(1+130/256))=  +4.11587e-001
data8 0x3fda87d0165dd198, 0x3c91f7845f58dbad // log(1/frcpa(1+131/256))=  +4.14539e-001
data8 0x3fdaac2e6c03f890, 0x3cb6f237a911c509 // log(1/frcpa(1+132/256))=  +4.16759e-001
data8 0x3fdadccc6fdf6a80, 0x3c90ddc4b7687169 // log(1/frcpa(1+133/256))=  +4.19726e-001
data8 0x3fdb015b3eb1e790, 0x3c692dd7d90e1e8e // log(1/frcpa(1+134/256))=  +4.21958e-001
data8 0x3fdb323a3a635948, 0x3c6f85655cbe14de // log(1/frcpa(1+135/256))=  +4.24941e-001
data8 0x3fdb56fa04462908, 0x3c95252d841994de // log(1/frcpa(1+136/256))=  +4.27184e-001
data8 0x3fdb881aa659bc90, 0x3caa53a745a3642f // log(1/frcpa(1+137/256))=  +4.30182e-001
data8 0x3fdbad0bef3db160, 0x3cb32f2540dcc16a // log(1/frcpa(1+138/256))=  +4.32437e-001
data8 0x3fdbd21297781c28, 0x3cbd8e891e106f1d // log(1/frcpa(1+139/256))=  +4.34697e-001
data8 0x3fdc039236f08818, 0x3c809435af522ba7 // log(1/frcpa(1+140/256))=  +4.37718e-001
data8 0x3fdc28cb1e4d32f8, 0x3cb3944752fbd81e // log(1/frcpa(1+141/256))=  +4.39990e-001
data8 0x3fdc4e19b84723c0, 0x3c9a465260cd3fe5 // log(1/frcpa(1+142/256))=  +4.42267e-001
data8 0x3fdc7ff9c74554c8, 0x3c92447d5b6ca369 // log(1/frcpa(1+143/256))=  +4.45311e-001
data8 0x3fdca57b64e9db00, 0x3cb44344a8a00c82 // log(1/frcpa(1+144/256))=  +4.47600e-001
data8 0x3fdccb130a5ceba8, 0x3cbefaddfb97b73f // log(1/frcpa(1+145/256))=  +4.49895e-001
data8 0x3fdcf0c0d18f3268, 0x3cbd3e7bfee57898 // log(1/frcpa(1+146/256))=  +4.52194e-001
data8 0x3fdd232075b5a200, 0x3c9222599987447c // log(1/frcpa(1+147/256))=  +4.55269e-001
data8 0x3fdd490246defa68, 0x3cabafe9a767a80d // log(1/frcpa(1+148/256))=  +4.57581e-001
data8 0x3fdd6efa918d25c8, 0x3cb58a2624e1c6fd // log(1/frcpa(1+149/256))=  +4.59899e-001
data8 0x3fdd9509707ae528, 0x3cbdc3babce578e7 // log(1/frcpa(1+150/256))=  +4.62221e-001
data8 0x3fddbb2efe92c550, 0x3cb0ac0943c434a4 // log(1/frcpa(1+151/256))=  +4.64550e-001
data8 0x3fddee2f3445e4a8, 0x3cbba9d07ce820e8 // log(1/frcpa(1+152/256))=  +4.67663e-001
data8 0x3fde148a1a2726c8, 0x3cb6537e3375b205 // log(1/frcpa(1+153/256))=  +4.70004e-001
data8 0x3fde3afc0a49ff38, 0x3cbfed5518dbc20e // log(1/frcpa(1+154/256))=  +4.72350e-001
data8 0x3fde6185206d5168, 0x3cb6572601f73d5c // log(1/frcpa(1+155/256))=  +4.74702e-001
data8 0x3fde882578823d50, 0x3c9b24abd4584d1a // log(1/frcpa(1+156/256))=  +4.77060e-001
data8 0x3fdeaedd2eac9908, 0x3cb0ceb5e4d2c8f7 // log(1/frcpa(1+157/256))=  +4.79423e-001
data8 0x3fded5ac5f436be0, 0x3ca72f21f1f5238e // log(1/frcpa(1+158/256))=  +4.81792e-001
data8 0x3fdefc9326d16ab8, 0x3c85081a1639a45c // log(1/frcpa(1+159/256))=  +4.84166e-001
data8 0x3fdf2391a21575f8, 0x3cbf11015bdd297a // log(1/frcpa(1+160/256))=  +4.86546e-001
data8 0x3fdf4aa7ee031928, 0x3cb3795bc052a2d1 // log(1/frcpa(1+161/256))=  +4.88932e-001
data8 0x3fdf71d627c30bb0, 0x3c35c61f0f5a88f3 // log(1/frcpa(1+162/256))=  +4.91323e-001
data8 0x3fdf991c6cb3b378, 0x3c97d99419be6028 // log(1/frcpa(1+163/256))=  +4.93720e-001
data8 0x3fdfc07ada69a908, 0x3cbfe9341ded70b1 // log(1/frcpa(1+164/256))=  +4.96123e-001
data8 0x3fdfe7f18eb03d38, 0x3cb85718a640c33f // log(1/frcpa(1+165/256))=  +4.98532e-001
data8 0x3fe007c053c5002c, 0x3cb3addc9c065f09 // log(1/frcpa(1+166/256))=  +5.00946e-001
data8 0x3fe01b942198a5a0, 0x3c9d5aa4c77da6ac // log(1/frcpa(1+167/256))=  +5.03367e-001
data8 0x3fe02f74400c64e8, 0x3cb5a0ee4450ef52 // log(1/frcpa(1+168/256))=  +5.05793e-001
data8 0x3fe04360be7603ac, 0x3c9dd00c35630fe0 // log(1/frcpa(1+169/256))=  +5.08225e-001
data8 0x3fe05759ac47fe30, 0x3cbd063e1f0bd82c // log(1/frcpa(1+170/256))=  +5.10663e-001
data8 0x3fe06b5f1911cf50, 0x3cae8da674af5289 // log(1/frcpa(1+171/256))=  +5.13107e-001
data8 0x3fe078bf0533c568, 0x3c62241edf5fd1f7 // log(1/frcpa(1+172/256))=  +5.14740e-001
data8 0x3fe08cd9687e7b0c, 0x3cb3007febcca227 // log(1/frcpa(1+173/256))=  +5.17194e-001
data8 0x3fe0a10074cf9018, 0x3ca496e84603816b // log(1/frcpa(1+174/256))=  +5.19654e-001
data8 0x3fe0b5343a234474, 0x3cb46098d14fc90a // log(1/frcpa(1+175/256))=  +5.22120e-001
data8 0x3fe0c974c89431cc, 0x3cac0a7cdcbb86c6 // log(1/frcpa(1+176/256))=  +5.24592e-001
data8 0x3fe0ddc2305b9884, 0x3cb2f753210410ff // log(1/frcpa(1+177/256))=  +5.27070e-001
data8 0x3fe0eb524bafc918, 0x3c88affd6682229e // log(1/frcpa(1+178/256))=  +5.28726e-001
data8 0x3fe0ffb54213a474, 0x3cadeefbab9af993 // log(1/frcpa(1+179/256))=  +5.31214e-001
data8 0x3fe114253da97d9c, 0x3cbaf1c2b8bc160a // log(1/frcpa(1+180/256))=  +5.33709e-001
data8 0x3fe128a24f1d9afc, 0x3cb9cf4df375e650 // log(1/frcpa(1+181/256))=  +5.36210e-001
data8 0x3fe1365252bf0864, 0x3c985a621d4be111 // log(1/frcpa(1+182/256))=  +5.37881e-001
data8 0x3fe14ae558b4a92c, 0x3ca104c4aa8977d1 // log(1/frcpa(1+183/256))=  +5.40393e-001
data8 0x3fe15f85a19c7658, 0x3cbadf26e540f375 // log(1/frcpa(1+184/256))=  +5.42910e-001
data8 0x3fe16d4d38c119f8, 0x3cb3aea11caec416 // log(1/frcpa(1+185/256))=  +5.44592e-001
data8 0x3fe18203c20dd130, 0x3cba82d1211d1d6d // log(1/frcpa(1+186/256))=  +5.47121e-001
data8 0x3fe196c7bc4b1f38, 0x3cb6267acc4f4f4a // log(1/frcpa(1+187/256))=  +5.49656e-001
data8 0x3fe1a4a738b7a33c, 0x3c858930213c987d // log(1/frcpa(1+188/256))=  +5.51349e-001
data8 0x3fe1b981c0c9653c, 0x3c9bc2a4a30f697b // log(1/frcpa(1+189/256))=  +5.53895e-001
data8 0x3fe1ce69e8bb1068, 0x3cb7ae6199cf2a00 // log(1/frcpa(1+190/256))=  +5.56447e-001
data8 0x3fe1dc619de06944, 0x3c6b50bb38388177 // log(1/frcpa(1+191/256))=  +5.58152e-001
data8 0x3fe1f160a2ad0da0, 0x3cbd05b2778a5e1d // log(1/frcpa(1+192/256))=  +5.60715e-001
data8 0x3fe2066d7740737c, 0x3cb32e828f9c6bd6 // log(1/frcpa(1+193/256))=  +5.63285e-001
data8 0x3fe2147dba47a390, 0x3cbd579851b8b672 // log(1/frcpa(1+194/256))=  +5.65001e-001
data8 0x3fe229a1bc5ebac0, 0x3cbb321be5237ce8 // log(1/frcpa(1+195/256))=  +5.67582e-001
data8 0x3fe237c1841a502c, 0x3cb3b56e0915ea64 // log(1/frcpa(1+196/256))=  +5.69306e-001
data8 0x3fe24cfce6f80d98, 0x3cb34a4d1a422919 // log(1/frcpa(1+197/256))=  +5.71898e-001
data8 0x3fe25b2c55cd5760, 0x3cb237401ea5015e // log(1/frcpa(1+198/256))=  +5.73630e-001
data8 0x3fe2707f4d5f7c40, 0x3c9d30f20acc8341 // log(1/frcpa(1+199/256))=  +5.76233e-001
data8 0x3fe285e0842ca380, 0x3cbc4d866d5f21c0 // log(1/frcpa(1+200/256))=  +5.78842e-001
data8 0x3fe294294708b770, 0x3cb85e14d5dc54fa // log(1/frcpa(1+201/256))=  +5.80586e-001
data8 0x3fe2a9a2670aff0c, 0x3c7e6f8f468bbf91 // log(1/frcpa(1+202/256))=  +5.83207e-001
data8 0x3fe2b7fb2c8d1cc0, 0x3c930ffcf63c8b65 // log(1/frcpa(1+203/256))=  +5.84959e-001
data8 0x3fe2c65a6395f5f4, 0x3ca0afe20b53d2d2 // log(1/frcpa(1+204/256))=  +5.86713e-001
data8 0x3fe2dbf557b0df40, 0x3cb646be1188fbc9 // log(1/frcpa(1+205/256))=  +5.89350e-001
data8 0x3fe2ea64c3f97654, 0x3c96516fa8df33b2 // log(1/frcpa(1+206/256))=  +5.91113e-001
data8 0x3fe3001823684d70, 0x3cb96d64e16d1360 // log(1/frcpa(1+207/256))=  +5.93762e-001
data8 0x3fe30e97e9a8b5cc, 0x3c98ef96bc97cca0 // log(1/frcpa(1+208/256))=  +5.95531e-001
data8 0x3fe32463ebdd34e8, 0x3caef1dc9a56c1bf // log(1/frcpa(1+209/256))=  +5.98192e-001
data8 0x3fe332f4314ad794, 0x3caa4f0ac5d5fa11 // log(1/frcpa(1+210/256))=  +5.99970e-001
data8 0x3fe348d90e7464cc, 0x3cbe7889f0516acd // log(1/frcpa(1+211/256))=  +6.02643e-001
data8 0x3fe35779f8c43d6c, 0x3ca96bbab7245411 // log(1/frcpa(1+212/256))=  +6.04428e-001
data8 0x3fe36621961a6a98, 0x3ca31f32262db9fb // log(1/frcpa(1+213/256))=  +6.06217e-001
data8 0x3fe37c299f3c3668, 0x3cb15c72c107ee29 // log(1/frcpa(1+214/256))=  +6.08907e-001
data8 0x3fe38ae2171976e4, 0x3cba42a2554b2dd4 // log(1/frcpa(1+215/256))=  +6.10704e-001
data8 0x3fe399a157a603e4, 0x3cb99c62286d8919 // log(1/frcpa(1+216/256))=  +6.12504e-001
data8 0x3fe3afccfe77b9d0, 0x3ca11048f96a43bd // log(1/frcpa(1+217/256))=  +6.15210e-001
data8 0x3fe3be9d503533b4, 0x3ca4022f47588c3e // log(1/frcpa(1+218/256))=  +6.17018e-001
data8 0x3fe3cd7480b4a8a0, 0x3cb4ba7afc2dc56a // log(1/frcpa(1+219/256))=  +6.18830e-001
data8 0x3fe3e3c43918f76c, 0x3c859673d064b8ba // log(1/frcpa(1+220/256))=  +6.21554e-001
data8 0x3fe3f2acb27ed6c4, 0x3cb55c6b452a16a8 // log(1/frcpa(1+221/256))=  +6.23373e-001
data8 0x3fe4019c2125ca90, 0x3cb8c367879c5a31 // log(1/frcpa(1+222/256))=  +6.25197e-001
data8 0x3fe4181061389720, 0x3cb2c17a79c5cc6c // log(1/frcpa(1+223/256))=  +6.27937e-001
data8 0x3fe42711518df544, 0x3ca5f38d47012fc5 // log(1/frcpa(1+224/256))=  +6.29769e-001
data8 0x3fe436194e12b6bc, 0x3cb9854d65a9b426 // log(1/frcpa(1+225/256))=  +6.31604e-001
data8 0x3fe445285d68ea68, 0x3ca3ff9b3a81cd81 // log(1/frcpa(1+226/256))=  +6.33442e-001
data8 0x3fe45bcc464c8938, 0x3cb0a2d8011a6c05 // log(1/frcpa(1+227/256))=  +6.36206e-001
data8 0x3fe46aed21f117fc, 0x3c8a2be41f8e9f3d // log(1/frcpa(1+228/256))=  +6.38053e-001
data8 0x3fe47a1527e8a2d0, 0x3cba4a83594fab09 // log(1/frcpa(1+229/256))=  +6.39903e-001
data8 0x3fe489445efffcc8, 0x3cbf306a23dcbcde // log(1/frcpa(1+230/256))=  +6.41756e-001
data8 0x3fe4a018bcb69834, 0x3ca46c9285029fd1 // log(1/frcpa(1+231/256))=  +6.44543e-001
data8 0x3fe4af5a0c9d65d4, 0x3cbbc1db897580e3 // log(1/frcpa(1+232/256))=  +6.46405e-001
data8 0x3fe4bea2a5bdbe84, 0x3cb84d880d7ef775 // log(1/frcpa(1+233/256))=  +6.48271e-001
data8 0x3fe4cdf28f10ac44, 0x3cb3ec4b7893ce1f // log(1/frcpa(1+234/256))=  +6.50140e-001
data8 0x3fe4dd49cf994058, 0x3c897224d59d3408 // log(1/frcpa(1+235/256))=  +6.52013e-001
data8 0x3fe4eca86e64a680, 0x3cbccf620f24f0cd // log(1/frcpa(1+236/256))=  +6.53889e-001
data8 0x3fe503c43cd8eb68, 0x3c3f872c65971084 // log(1/frcpa(1+237/256))=  +6.56710e-001
data8 0x3fe513356667fc54, 0x3cb9ca64cc3d52c8 // log(1/frcpa(1+238/256))=  +6.58595e-001
data8 0x3fe522ae0738a3d4, 0x3cbe708164c75968 // log(1/frcpa(1+239/256))=  +6.60483e-001
data8 0x3fe5322e26867854, 0x3cb9988ba4aea615 // log(1/frcpa(1+240/256))=  +6.62376e-001
data8 0x3fe541b5cb979808, 0x3ca1662e3a6b95f5 // log(1/frcpa(1+241/256))=  +6.64271e-001
data8 0x3fe55144fdbcbd60, 0x3cb3acd4ca45c1e0 // log(1/frcpa(1+242/256))=  +6.66171e-001
data8 0x3fe560dbc45153c4, 0x3cb4988947959fed // log(1/frcpa(1+243/256))=  +6.68074e-001
data8 0x3fe5707a26bb8c64, 0x3cb3017fe6607ba9 // log(1/frcpa(1+244/256))=  +6.69980e-001
data8 0x3fe587f60ed5b8fc, 0x3cbe7a3266366ed4 // log(1/frcpa(1+245/256))=  +6.72847e-001
data8 0x3fe597a7977c8f30, 0x3ca1e12b9959a90e // log(1/frcpa(1+246/256))=  +6.74763e-001
data8 0x3fe5a760d634bb88, 0x3cb7c365e53d9602 // log(1/frcpa(1+247/256))=  +6.76682e-001
data8 0x3fe5b721d295f10c, 0x3cb716c2551ccbf0 // log(1/frcpa(1+248/256))=  +6.78605e-001
data8 0x3fe5c6ea94431ef8, 0x3ca02b2ed0e28261 // log(1/frcpa(1+249/256))=  +6.80532e-001
data8 0x3fe5d6bb22ea86f4, 0x3caf43a8bbb2f974 // log(1/frcpa(1+250/256))=  +6.82462e-001
data8 0x3fe5e6938645d38c, 0x3cbcedc98821b333 // log(1/frcpa(1+251/256))=  +6.84397e-001
data8 0x3fe5f673c61a2ed0, 0x3caa385eef5f2789 // log(1/frcpa(1+252/256))=  +6.86335e-001
data8 0x3fe6065bea385924, 0x3cb11624f165c5b4 // log(1/frcpa(1+253/256))=  +6.88276e-001
data8 0x3fe6164bfa7cc068, 0x3cbad884f87073fa // log(1/frcpa(1+254/256))=  +6.90222e-001
data8 0x3fe62643fecf9740, 0x3cb78c51da12f4df // log(1/frcpa(1+255/256))=  +6.92171e-001


pow_table_Q:
data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi


// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15
pow_tbl1:
data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF


// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
pow_tbl2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF

.global powf

.section .text
.proc  powf
.align 32

powf:

{ .mfi
          alloc         r32=ar.pfs,1,35,4,0 
          frcpa.s1      POW_B, p6   = f1,f8
          mov           pow_GR_17ones  = 0x1FFFF
}
{ .mfi
(p0)      addl          pow_AD_P   = @ltoff(pow_table_P), gp
          fma.s1        POW_NORM_X     = f8,f1,f0
          mov           pow_GR_FFFE    = 0xFFFE
;;
}


{ .mmf
          ld8 pow_AD_P = [pow_AD_P]
          mov           pow_GR_FFF7    = 0xFFF7
          fmerge.s      POW_abs_f8     = f0,f8
}
;;



// p14 = TRUE ==> X is ZERO
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
{ .mfi
          setf.exp      POW_half        = pow_GR_FFFE 
          fclass.m.unc  p14,p15          = f8, 0x07
          nop.i 999
}
{ .mfi
          mov           pow_GR_16ones   = 0xFFFF
          fma.s1        POW_NORM_Y     = f9,f1,f0
          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
}
;;


// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11
// c                      3
// p11 = TRUE ==> Y is a NAN
{ .mmf
          adds          pow_AD_Q       = pow_table_Q - pow_table_P,  pow_AD_P
          ldfe          POW_P4         = [pow_AD_P], 16
          fclass.m.unc  p11,p0         = f9, 0xc3
}
;;



// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
// p12 = TRUE ==> X is ZERO and Y is ZERO
{ .mmf
          ldfe          POW_P5         = [pow_AD_P], 16
          ldfe          POW_P2         = [pow_AD_Q], 16
(p14)     fclass.m.unc  p12,p0              = f9, 0x07
}
;;


{ .mmf
          ldfe          POW_P3         = [pow_AD_P], 16
          ldfe          POW_P0         = [pow_AD_Q], 16
(p15)     fms.s1        POW_r          = POW_B, POW_NORM_X,f1
}
;;



// p11 = TRUE ==> Y is a NaN
{ .mfi
          ldfe          POW_P1         = [pow_AD_P], 16
          fmerge.s      POW_ABS_NORM_X = f0, POW_NORM_X
          nop.i 999
}
{ .mfb
          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
          fms.s1        POW_Xm1        = POW_abs_f8,f1,f1
(p11)     br.cond.spnt   POW_Y_NAN
}
;;



{ .mmb
          getf.exp      pow_GR_signexp_X    = POW_NORM_X
          ldfe          POW_log2_by_128_hi  = [pow_AD_Q], 16
(p12)     br.cond.spnt POW_X_0_Y_0
}
;;



// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11
// c                      3
// p11 = TRUE ==> X is a NAN
{ .mmf
          getf.sig      pow_GR_sig_X        = POW_NORM_X
          nop.m 999
          fclass.m.unc  p11,p0              = f8, 0xc3
}
;;



{ .mfi
          nop.m 999
          nop.f 999
          and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
}
;;



{ .mfi
          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
          fma.s1        POW_rsq             = POW_r, POW_r,f0
          shl           pow_GR_offset       = pow_GR_sig_X, 1
} 
{ .mfi
(p15)     sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
          nop.f 999
          nop.i 999
}
;;


{ .mfi
          setf.sig POW_int_K                = pow_GR_true_exp_X
          fcvt.fx.s1   POW_int_Y            = POW_NORM_Y
          shr.u     pow_GR_offset           = pow_GR_offset,56
}
{ .mfi
          ldfe      POW_log2_by_128_lo      = [pow_AD_P], 16
          fma.s1    POW_r1sq                = POW_r1, POW_r1,f0
          nop.i 999
;;
}


// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
// p12 = TRUE ==> X is a NAN and Y is a zero
// p13 = TRUE ==> X is a NAN and Y is anything else
{ .mfi
          nop.m 999
(p11)     fclass.m.unc  p12,p13             = f9, 0x07
          shl pow_GR_offset                 = pow_GR_offset, 4
}
{ .mfi
          ldfpd  POW_Q2, POW_Q3             = [pow_AD_P], 16
          nop.f 999
          nop.i 999
;;
}


{ .mfi
          add pow_AD_Tt                     = pow_AD_Tt, pow_GR_offset
          fma.s1 POW_v6                     = POW_r,  POW_P5, POW_P4
          nop.i 999
}
{ .mfi
          ldfpd  POW_Q0, POW_Q1             = [pow_AD_P], 16
          fma.s1 POW_v61                     = POW_r1, POW_P5, POW_P4
          nop.i 999
}
;;




{ .mfi
          getf.exp      pow_GR_signexp_Xm1  = POW_Xm1
          fma.s1 POW_v4                     = POW_P3, POW_r,  POW_P2 
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v41                     = POW_P3, POW_r1, POW_P2 
(p12)     br.cond.spnt POW_X_NAN_Y_0
}
;;



{ .mfi
          ldfpd  POW_T, POW_Tt              = [pow_AD_Tt], 16
          fma.s1 POW_v21                     = POW_P1, POW_r1, POW_P0 
          add pow_AD_tbl1                   = r0, pow_AD_Q 
}
{ .mfi
          nop.m 999
          fma.s1 POW_v2                     = POW_P1, POW_r,  POW_P0 
          nop.i 999
}
;;



{ .mfi
          ldfd   POW_Q4                     = [pow_AD_P], 16
          fma POW_r1sq_by_2                 = POW_r1sq, POW_half, f0 
          and       pow_GR_exp_Xm1          = pow_GR_signexp_Xm1, pow_GR_17ones
}
{ .mfi
          nop.m 999
          fma POW_rsq_by_2                  = POW_rsq, POW_half, f0 
          nop.i 999
}
;;





.pred.rel "mutex",p6,p7
{ .mfi
          nop.m 999
          fma.s1 POW_rcub                   = POW_r,  POW_rsq,  f0 
          cmp.lt.unc p6,p7                  = pow_GR_exp_Xm1, pow_GR_FFF7
}
{ .mfi
          nop.m 999
          fma.s1 POW_r1cub                  = POW_r1, POW_r1sq, f0 
          nop.i 999
}
;;


{ .mfi
          getf.exp  pow_GR_signexp_Y        = POW_NORM_Y 
(p6)      fma.s1 POW_U                      = POW_NORM_Y,POW_r1,f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_U                      = POW_NORM_Y,POW_r,f0
          nop.i 999
}
;;


{ .mfi
          getf.sig pow_GR_sig_int_Y         = POW_int_Y
(p6)      fma.s1 POW_v3                     = POW_v61, POW_r1sq,  POW_v41 
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_v3                     = POW_v6, POW_rsq,  POW_v4 
          nop.i 999
}
;;



// p14 = TRUE ==> X is zero
//    p15 = TRUE ==> X is zero AND Y is negative
//    p10 = TRUE ==> X is zero AND Y is >= zero 
{ .mfi
          nop.m 999
          fcvt.xf POW_K                     = POW_int_K
          nop.i 999
}
{ .mfi
          nop.m 999
(p6)      fma.s1 POW_G                       = f0,f0,f0
          nop.i 999
}
;;



{ .mmf
          andcm pow_GR_sign_Y               = pow_GR_signexp_Y, pow_GR_17ones
          adds pow_AD_tbl2                  = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
(p14)     fcmp.lt.unc.s1 p15, p10           = f9,f0
}
;;


// p15 = TRUE ==> X is ZERO and Y is negative
{ .mfi
          and pow_GR_exp_Y                   = pow_GR_signexp_Y, pow_GR_17ones
(p6)      fnma.s1 POW_V                      = POW_NORM_Y, POW_r1sq_by_2,f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fnma.s1 POW_V                      = POW_NORM_Y, POW_rsq_by_2,f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p6)      fmerge.s POW_delta                 = f0,f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p13)     fma.s f8                           = f8,f1,f0
(p13)     br.ret.spnt  b0
}
;;
          


{ .mfi
          nop.m 999
(p6)      fma.s1 POW_p                      = POW_r1sq, POW_v3, POW_v21
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_p                      = POW_rsq,  POW_v3, POW_v2
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p7)      fma.s1 POW_delta                  = POW_K, POW_log2_lo, POW_Tt
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_G                      = POW_K, POW_log2_hi, POW_T 
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fcvt.xf   POW_float_int_Y               = POW_int_Y
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p7)      fms.s1 POW_e2                     = POW_NORM_Y, POW_r, POW_U
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z2                     = POW_U, f1, POW_V
          nop.i 999
}
;;



// qnan snan inf norm     unorm 0 -+
// 0    0    0   1        0     0 10
// 1                      2
// p11 = TRUE ==> X is NEGATIVE 
// p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                return +0
{ .mfi
          nop.m 999
          fclass.m.unc  p11,p0              = f8, 0x1a
          nop.i 999
}
;;


// DOUBLE 0x10033
// SINGLE 0x10016
{ .mfi
          addl pow_GR_10033                 = 0x10033, r0
(p6)      fma.s1 POW_p                      = POW_p, POW_r1cub, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_p                      = POW_p, POW_rcub, f0
          nop.i 999
}
;;



// p10 = TRUE ==> X is zero  AND Y is positive
//    p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                   return +0
//    p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer) 
{ .mfi
          nop.m 999
(p6)      fms.s1 POW_e2                     = POW_NORM_Y, POW_r1, POW_U
(p10)     cmp.gt.unc p8,p9                  =  pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z1                     = POW_NORM_Y, POW_G, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_e3                     = POW_NORM_Y, POW_delta, f0
          nop.i 999
}
{ .mfi 
          nop.m 999
(p7)      fma.s1 POW_Gpr                    = POW_G, f1, POW_r
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_W2                     = POW_Z2, POW_inv_log2_by_128, f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fms.s1 POW_UmZ2                   = POW_U, f1, POW_Z2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p6)      fma.s1 POW_Gpr                    = POW_G, f1, POW_r1
          nop.i 999
}
;;



// p11 = TRUE ==> X is NEGATIVE
//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already int
//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
// p8  = TRUE ==> X is zero  AND Y is outside intger range (treat as even int)
//                return +0


{ .mfi
          nop.m 999
          fma.s1 POW_Z3                     = POW_NORM_Y, POW_p, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p8)      fma.s f8                          = f0,f0,f0
(p11)     cmp.ge.unc  p12,p13                = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          nop.m 999
          fms.s1 POW_e1                     = POW_NORM_Y, POW_G, POW_Z1
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_W1                     = POW_Z1, POW_inv_log2_by_128, f0
(p8)      br.ret.spnt b0
}
;;



// p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer)
//    p6 = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p7 = TRUE ==>  X is zero  AND  Y is NOT an integer, return +0
{ .mfi
          nop.m 999
(p9)      fcmp.eq.unc.s1 p6,p7             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


// p15 = TRUE ==> X_0_Y_NEG
{ .mfi
          nop.m 999
          fcvt.fx.s1 POW_int_W2                = POW_W2
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_UmZ2pV                 = POW_UmZ2,f1,POW_V
(p15)     br.cond.spnt POW_X_0_Y_NEG
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_Y_Gpr                  = POW_NORM_Y, POW_Gpr, f0
          nop.i 999
}
;;


// p6  = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p8 = TRUE ==>  X is zero  AND  Y is an odd  integer
//    p9 = TRUE ==>  X is zero  AND  Y is an even integer
{ .mfi
          nop.m 999
          fma.s1 POW_Z3sq                   = POW_Z3, POW_Z3, f0
(p6)      tbit.nz.unc  p8,p9                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_v4                     = POW_Z3, POW_Q3, POW_Q2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fcvt.fx.s1 POW_int_W1                = POW_W1
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v2                     = POW_Z3, POW_Q1, POW_Q0
(p8)      br.ret.spnt b0
}
;;


{ .mfi
          nop.m 999
(p7)      fma.s f8                          = f0,f0,f0
          nop.i 999
}
;;



// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
//     p10 = TRUE ==> X is NEG and Y is an int
//     p12 = TRUE ==> X is NEG and Y is not an int
{ .mfi
          nop.m 999
(p13)     fcmp.eq.unc.s1 p10,p12             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
{ .mfi
          nop.m 999
(p9)      fma.s f8                          = f0,f0,f0
          nop.i 999
}
;;


// qnan snan inf norm     unorm 0 -+
// 0    0    1   0        0     0 11
// 2                      3
{ .mfi
          nop.m 999
          fclass.m.unc p15,p0 = POW_NORM_X,  0x23
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_e2                     = POW_e2,f1,POW_UmZ2pV
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fcvt.xf POW_N2float                = POW_int_W2
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v3                     = POW_Z3sq, POW_Q4, POW_v4
(p12)     br.cond.spnt POW_X_NEG_Y_NONINT
}
;;



{ .mbb
          getf.sig pow_GR_int_W2             = POW_int_W2
(p15)     br.cond.spnt POW_X_INF
(p7)      br.ret.spnt b0 
}
;;




{ .mfb
          getf.exp pow_GR_signexp_Y_Gpr       = POW_Y_Gpr
          fcvt.xf POW_N1float               = POW_int_W1
(p9)      br.ret.spnt b0
}
;;



// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
{ .mfi
          nop.m 999
          fma.s1  POW_e12                     = POW_e1,f1,POW_e2
(p10)     tbit.nz.unc  p12,p0                = pow_GR_sig_int_Y,0
}
;;




{ .mfi
          getf.sig pow_GR_int_W1             = POW_int_W1
          fnma.s1 POW_s2                     = POW_N2float, POW_log2_by_128_hi, POW_Z2
          and pow_GR_exp_Y_Gpr               = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
;;



{ .mfi
          sub pow_GR_true_exp_Y_Gpr          = pow_GR_exp_Y_Gpr, pow_GR_16ones
          fma.s1 POW_q                       = POW_Z3sq, POW_v3, POW_v2
          andcm pow_GR_sign_Y_Gpr            = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
;;


// double: p8 TRUE ==> |Y(G + r)| >= 10
// single: p8 TRUE ==> |Y(G + r)| >= 7

// double
//     -2^10  -2^9             2^9   2^10
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |  
// single
//     -2^7   -2^6             2^6   2^7
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |




{ .mfi
          add pow_GR_int_N                   = pow_GR_int_W1, pow_GR_int_W2
          nop.f 999
(p0)      cmp.le.unc p8,p9                   = 7, pow_GR_true_exp_Y_Gpr
}
;;



{ .mfi
          and pow_GR_index1                  = 0x0f, pow_GR_int_N
          fnma.s1 POW_s1                     = POW_N1float, POW_log2_by_128_hi, POW_Z1
          shr r2                             = pow_GR_int_N, 7
}
{ .mfi
          and pow_GR_index2                  = 0x70, pow_GR_int_N
          nop.f 999
(p9)      cmp.le.unc p0,p10                  = 6, pow_GR_true_exp_Y_Gpr
}
;;



{ .mfi
          shladd pow_AD_T1                   = pow_GR_index1, 4, pow_AD_tbl1
          nop.f 999
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_e123                    = POW_e12, f1, POW_e3
(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
}
;;



{ .mmi
          ldfe POW_T1                        = [pow_AD_T1],16
          add pow_AD_T2                      = pow_AD_tbl2, pow_GR_index2
          nop.i 999
}
;;



{ .mmf
          ldfe POW_T2                        = [pow_AD_T2],16
          addl pow_int_GR_M                  = 0xFFFF, r2
          fma.s1 POW_q                       = POW_Z3sq, POW_q, POW_Z3
}
;;


{ .mfi
          setf.exp POW_2M                    = pow_int_GR_M
          fnma.s1 POW_f2                     = POW_N2float, POW_log2_by_128_lo, f1
          nop.i 999
}
{ .mfi
          nop.m 999
          fnma.s1 POW_f1                     = POW_N1float, POW_log2_by_128_lo, f1
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_s                       = POW_s1, f1, POW_s2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_f3                      = POW_e123,f1,f1
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_f12                     = POW_f1, POW_f2,f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999 
          fma.s1 POW_ssq                     = POW_s, POW_s, f0
          nop.i 999
}
{ .mfi
          nop.m 999 
          fma.s1 POW_v4                      = POW_s, POW_Q3, POW_Q2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_v2                      = POW_s, POW_Q1, POW_Q0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_T1T2                    = POW_T1, POW_T2, f0
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_1ps                     = f1,f1,POW_s
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_f123                    = POW_f12, POW_f3, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_ssq, POW_Q4, POW_v4
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_A                      =  POW_2M, POW_T1T2, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p12)     fmerge.s POW_f123 = f8,POW_f123
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_es                     = POW_ssq,  POW_v3, POW_v2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_f123, f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_es                     = POW_es, POW_ssq, POW_1ps
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_es,f0
          nop.i 999
}
;;



{ .mfb
          nop.m 999
(p10)     fma.s f8                          = POW_A, POW_q, POW_A
(p10)     br.ret.sptk     b0
}
;;





// POSSIBLE_OVER_UNDER
// p6 = TRUE ==> Y negative

{ .mfi
        nop.m 999
        fmerge.s POW_abs_A                = f0, POW_A
        cmp.eq.unc p0,p6                  = pow_GR_sign_Y, r0
}
;;

{ .mib
        nop.m 999
        nop.i 999
(p6)    br.cond.spnt POW_POSSIBLE_UNDER 
}
;;

// POSSIBLE_OVER
// We got an answer. 
// overflow is a possibility, not a certainty


// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode

// double
// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// single
// Largest single is FE (biased double)
//                   FE - 7F + FFFF = 1007E
// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ


// Put in s2 (td set, wre set)
{ .mfi
        mov           pow_GR_gt_ln                 = 0x1007f 
        fsetc.s2 0x7F,0x42
        nop.i 999 
}
;;


{ .mfi
        setf.exp POW_gt_pln                        = pow_GR_gt_ln
        fma.s.s2 POW_wre_urm_f8                    = POW_abs_A, POW_q, POW_abs_A
        nop.i 999 ;;
}

// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999
}
;;


// p7 = TRUE ==> yes, we have an overflow
{ .mfi
        nop.m 999
        fcmp.ge.unc.s1 p7, p0                    =  POW_wre_urm_f8, POW_gt_pln
        nop.i 999
}
;;



{ .mfb
(p7)   mov pow_GR_tag                            = 30
       fma.s f8                                  = POW_A, POW_q, POW_A
(p7)   br.cond.spnt __libm_error_region 
}
{ .mfb
       nop.m 999
       nop.f 999
(p0)   br.ret.sptk     b0 
}
;;


POW_POSSIBLE_UNDER:
// We got an answer. input was < -2^9 but > -2^10 (double)
// We got an answer. input was < -2^6 but > -2^7  (float)
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)
// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.
// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.
// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.
//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal


// Put in s2 (td set, ftz set)
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x41
        nop.i 999 
}
;;



{ .mfi
        nop.m 999
        fma.s.s2 POW_ftz_urm_f8                    = POW_A, POW_q, POW_A
        nop.i 999
}
;;


// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999 
}
;;


// p7 = TRUE ==> yes, we have an underflow
{ .mfi
        nop.m 999
        fcmp.eq.unc.s1 p7, p0                     =  POW_ftz_urm_f8, f0
        nop.i 999 
}
;;




{ .mfb
(p7)    mov pow_GR_tag                           = 31
        fma.s f8                                 = POW_A, POW_q, POW_A
(p7)    br.cond.spnt __libm_error_region 
}
;;


{ .mfb
        nop.m 999
        nop.f 999
        br.ret.sptk     b0 
}
;;


POW_X_0_Y_0:
// When X is +-0 and Y is +-0, IEEE returns 1.0 
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 32
         fma.s f8                           = f1,f1,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_INF:
// When X is +-inf and Y is +-, IEEE returns 

// overflow                       
// X +inf  Y +inf             +inf  
// X -inf  Y +inf             +inf 

// X +inf  Y >0               +inf    
// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
// X -inf  Y >0,  odd integer  -inf   

// underflow                     
// X +inf  Y -inf             +0   
// X -inf  Y -inf             +0  

// X +inf  Y <0               +0      
// X -inf  Y <0, !odd integer +0     
// X -inf  Y <0, odd integer  -0    

// X + inf Y=+0                +1
// X + inf Y=-0                +1
// X - inf Y=+0                +1
// X - inf Y=-0                +1

// p13 == Y negative
// p14 == Y positive

// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       p13 == (Y negative) 
//          return +inf
//       p14 == (Y positive)
//          return +0



// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              p13 == (Y negative)    
//                 return (sign_of_x)inf
//              p14 == (Y positive) 
//                 return (sign_of_x)0
//           pxx even                
//              p13 == (Y negative) 
//                 return +inf     
//              p14 == (Y positive)
//                 return +0     

//      pxx == Y is not an integer
//           p13 == (Y negative) 
//                 return +inf
//           p14 == (Y positive)
//                 return +0
// 

{ .mfi
          nop.m 999
          fcmp.lt p13,p14                    = POW_NORM_Y,f0 
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fclass.m p12,p0                    = f9, 0x23
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fclass.m p15,p0                    = f9, 0x07	//@zero
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p15)     fmerge.s f8 = f1,f1
(p15)     br.ret.spnt b0
}
;;

        
{ .mfi
(p13)     mov pow_GR_tag                     = 31
(p14)     frcpa.s1 f8,p10                       = f1,f0
          nop.i 999
}
{ .mfb
(p14)     mov pow_GR_tag                     = 30
(p13)     fma.s1 f8                          = f0,f0,f0
(p12)     br.ret.spnt b0
}
;;

   

{ .mfb
          nop.m 999
(p7)      fcmp.eq.unc.s1 p9,p0              = POW_float_int_Y,  POW_NORM_Y
          nop.b 999
}
;;

{ .mfi
          nop.m 999
          nop.f 999
(p9)      tbit.nz.unc p11,p0                 = pow_GR_sig_int_Y,0
}
;;

{ .mfb
          nop.m 999
(p11)     fmerge.s f8 = POW_NORM_X,f8
          br.ret.sptk b0 
}
;;



POW_X_0_Y_NEG:
// When X is +-0 and Y is negative, IEEE returns 
// X     Y           answer
// +0    -odd int    +inf
// -0    -odd int    -inf

// +0    !-odd int   +inf
// -0    !-odd int   +inf


// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       return +inf

// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              return (sign_of_x)inf
//           p12 even
//              return +inf
//      p10 == Y is not an integer
//         return +inf
// 
// 

{ .mfi
          nop.m 999
          nop.f 999
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          mov pow_GR_tag                     = 33
(p7)      fcmp.eq.unc.s1 p9,p10              = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


{ .mfb
          nop.m 999
(p6)      frcpa.s0 f8,p13                       = f1, f0
(p6)      br.cond.sptk __libm_error_region
}
;;

{ .mfb
          nop.m 999
(p10)     frcpa.s0 f8,p13                       = f1, f0
(p10)     br.cond.sptk __libm_error_region
}
;;



{ .mib
          nop.m 999
(p9)      tbit.nz.unc p11,p12                = pow_GR_sig_int_Y,0
          nop.b 999
}
;;



{ .mfi
          nop.m 999
(p12)     frcpa.s0 f8,p13                      = f1,f0
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p11)     frcpa f8,p13                      = f1,f8 
          br.cond.sptk __libm_error_region
}
;;




POW_X_NEG_Y_NONINT:
// When X is negative and Y is a non-integer, IEEE
// returns a qnan indefinite.
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 34
         frcpa f8,p6                        = f0,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_NAN_Y_0:
// When X is a NAN and Y is zero, IEEE returns 1.
// We call error support with this value.
{ .mfi
         nop.m 0
         fma.s.s0 f10 = f8,f1,f0
         nop.i 0
}
{ .mfb
         mov pow_GR_tag                     = 35 
         fma.s.s0 f8 = f0,f0,f1
         br.cond.sptk __libm_error_region
}
;;

POW_OVER_UNDER_X_NOT_INF:

// p8 is TRUE for overflow
// p9 is TRUE for underflow

// if y is infinity, we should not over/underflow


{ .mfi
          nop.m 999
          fcmp.eq.unc.s1     p14, p13        = POW_ABS_NORM_X,f1
          cmp.eq.unc p8,p9                   = pow_GR_sign_Y_Gpr, r0
}
;;

{ .mfi
          nop.m 999
(p14)     fclass.m.unc       p15, p0         = f9, 0x23
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fclass.m.unc       p11,p0         = f9, 0x23
          nop.i 999
}
;;

// p15 = TRUE if |x|=1, y=inf, return +1
{ .mfb
          nop.m 999
(p15)     fma.s              f8              = f1,f1,f0
(p15)     br.ret.spnt b0
}
;;

.pred.rel "mutex",p8,p9
{  .mfb
(p8)      setf.exp           f8              = pow_GR_17ones
(p9)      fmerge.s           f8              = f0,f0
(p11)     br.ret.sptk b0
}

{ .mfb
          nop.m 999
          nop.f 999
          br.cond.sptk POW_OVER_UNDER_ERROR
}
;;

POW_Y_NAN:

// Is x = +1 then result is +1, else result is quiet Y
{ .mfi
       nop.m 999
       fcmp.eq.s1         p10,p9               = POW_NORM_X, f1 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fma.s f8 = f1,f1,f0 
       nop.i 999
}
{ .mfb
       nop.m 999
(p9)   fma.s f8 = f9,f8,f0 
       br.ret.sptk b0
}
;;


POW_OVER_UNDER_ERROR:

{ .mfi
          nop.m 999
          fmerge.s f10                      = POW_NORM_X,POW_NORM_X
          nop.i 999
}
{ .mfi
          sub   pow_GR_17ones_m1            = pow_GR_17ones, r0, 1
          nop.f 999
          mov pow_GR_one                    = 0x1
}
;;

// overflow
{ .mmb
(p8)     mov pow_GR_tag                     = 30
(p8)     setf.exp f11                       = pow_GR_17ones_m1
         nop.b 999
}
;;

        
// underflow
{ .mmi
(p9)    mov pow_GR_tag                     = 31
(p9)    setf.exp f11                       = pow_GR_one
        nop.i 999
}
;;


// p12 x is negative and y is an odd integer 


{ .mfi
        nop.m 999
        fma.s f8                               = f11, f11, f0
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p12)   fmerge.ns f8                           = f8, f8
        nop.i 999
}
;;


.endp powf


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:

// Answer is inf for overflow and 0 for underflow.
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = POW_NORM_X              // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfs [GR_Parameter_Y] = f8                      // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\rerun.s ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved. 
//**
//** The information and source code contained herein is the exclusive 
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization 
//** from the company.
//**
//###########################################################################

  .file "rerun.s"
  .section .text
  .align 32

  .proc _xrun1args#
  .global _xrun1args#
  .align 32
_xrun1args:
  alloc	r31=ar.pfs,4,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35

  // save old FPSR in r36
  mov.m r36 = ar40
  // save predicates in r38
  mov r38 = pr;;
  // load fpsr in r37
  ld8 r37 = [r33];;
  // set new value of FPSR
  mov ar40 = r37;;
  // clear predicates
  movl r39 = 0x0000000000000001;;
  // load clear predicates from r39
  mov pr = r39,0x1ffff;;
  // load input argument into f8
  ldf.fill f8 = [r35];;
  cmp4.eq p1, p2 = 1, r32;;  // fprsqrta [not used]
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpcvt_fx
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpcvt_fxu
  (p4) cmp4.eq.unc p4, p5 = 4, r32;; // fpcvt_fx_trunc
  (p5) cmp4.eq.unc p5, p6 = 5, r32;; // fpcvt_fxu_trunc
  (p1) fprsqrta.s0 f9,p7 = f8;; // 1/sqrt(f8) in f9
  (p2) fpcvt.fx.s0 f9 = f8;;
  (p3) fpcvt.fxu.s0 f9 = f8;;
  (p4) fpcvt.fx.trunc.s0 f9 = f8;;
  (p5) fpcvt.fxu.trunc.s0 f9 = f8;;
  (p6) mov f9 = f0 // return 0
  // restore predicates from r38
  mov pr = r38,0x1ffff;;
  // store result
  stf.spill [r34] = f9;;
  // save FPSR
  mov.m r37 = ar40;;
  st8 [r33] = r37
  // restore FPSR
  mov ar40 = r36;;
  // return
  br.ret.sptk b0
  .endp _xrun1args


  .proc  _xrun2args#
  .global _xrun2args#
  .align 32

_xrun2args:
  alloc	r31=ar.pfs,5,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39, r40

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35
  // &fr3 (input) is in r36

  // save old FPSR in r37
  mov r37 = ar40
  // save predicates in r39
  mov r39 = pr;;
  // load fpsr in r38
  ld8 r38 = [r33];;
  // set new value of FPSR
  mov ar40 = r38;;
  // clear predicates
  movl r40 = 0x0000000000000001;;
  // load clear predicates from r40
  mov pr = r40,0x1ffff;;
  // load first input argument into f8
  ldf.fill f8 = [r35]
  // load second input argument into f9
  ldf.fill f9 = [r36];;
  cmp4.eq p1, p2 = 1, r32;;  // fprcpa [not used - fprcpa not re-executed]
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpcmp_eq
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpcmp_lt
  (p4) cmp4.eq.unc p4, p5 = 4, r32;; // fpcmp_le
  (p5) cmp4.eq.unc p5, p6 = 5, r32;; // fpcmp_unord
  (p6) cmp4.eq.unc p6, p7 = 6, r32;; // fpcmp_neq
  (p7) cmp4.eq.unc p7, p8 = 7, r32;; // fpcmp_nlt
  (p8) cmp4.eq.unc p8, p9 = 8, r32;; // fpcmp_nle
  (p9) cmp4.eq.unc p9, p10 = 9, r32;; // fpcmp_ord
  (p10) cmp4.eq.unc p10, p11 = 10, r32;; // fpmin
  (p11) cmp4.eq.unc p11, p12 = 11, r32;; // fpmax
  (p12) cmp4.eq.unc p12, p13 = 12, r32;; // fpamin
  (p13) cmp4.eq.unc p13, p14 = 13, r32;; // fpamax
  (p1) fprcpa.s0 f10 , p15 = f8, f9;; // 1 / f3 in f4
  (p2) fpcmp.eq.s0 f10 = f8, f9;;
  (p3) fpcmp.lt.s0 f10 = f8, f9;;
  (p4) fpcmp.le.s0 f10 = f8, f9;;
  (p5) fpcmp.unord.s0 f10 = f8, f9;;
  (p6) fpcmp.neq.s0 f10 = f8, f9;;
  (p7) fpcmp.nlt.s0 f10 = f8, f9;;
  (p8) fpcmp.nle.s0 f10 = f8, f9;;
  (p9) fpcmp.ord.s0 f10 = f8, f9;;
  (p10) fpmin.s0 f10 = f8, f9;;
  (p11) fpmax.s0 f10 = f8, f9;;
  (p12) fpamin.s0 f10 = f8, f9;;
  (p13) fpamax.s0 f10 = f8, f9;;
  (p14) mov f10 = f0 // return 0
  // restore predicates from r39
  mov pr = r39,0x1ffff;;
  // store result
  stf.spill [r34] = f10
  // save FPSR
  mov.m r38 = ar40;;
  st8 [r33] = r38
  // restore FPSR
  mov ar40 = r37;;
  // return
  br.ret.sptk b0
  .endp _xrun2args


  .proc  _xrun3args#
  .global _xrun3args#
  .align 32

_xrun3args:
  alloc	r31=ar.pfs,6,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39, r40, r41

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35
  // &fr3 (input) is in r36
  // &fr4 (input) is in r37

  // save old FPSR in r38
  mov r38 = ar40
  // save predicates in r40
  mov r40 = pr;;
  // load fpsr in r39
  ld8 r39 = [r33];;
  // set new value of FPSR
  mov ar40 = r39;;
  // clear predicates
  movl r41 = 0x0000000000000001;;
  // load clear predicates from r41
  mov pr = r41,0x1ffff;;
  // load first input argument into f8
  ldf.fill f8 = [r35]
  // load second input argument into f9
  ldf.fill f9 = [r36];;
  // load third input argument into f10
  ldf.fill f10 = [r37];;
  cmp4.eq p1, p2 = 1, r32;; // fpma
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpms
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpnma
  (p1) fpma.s0 f11 = f8, f9, f10;; // f11 = f8 * f9 + f10
  (p2) fpms.s0 f11 = f8, f9, f10;; // f11 = f8 * f9 - f10
  (p3) fpnma.s0 f11 = f8, f9, f10;; // f11 = -f8 * f9 + f10
  (p4) mov f11 = f0 // return 0
  // restore predicates from r40
  mov pr = r40,0x1ffff;;
  // store result
  stf.spill [r34] = f11
  // save FPSR
  mov.m r39 = ar40;;
  st8 [r33] = r39
  // restore FPSR
  mov ar40 = r38
  // return
  br.ret.sptk b0
  .endp _xrun3args


  .proc  _thmB#
  .global _thmB#
  .align 32

_thmB:
  alloc r31=ar.pfs,4,2,0,0  // r32, r33, r34, r35, r36, r37

  // &a is in r32 
  // &b is in r33 
  // &div is in r34 (the address of the divide result)
  // &fpsr is in r35

  // general registers used: r31, r32, r33, r34, r35, r36, r37
  // predicate registers used: p6
  // floating-point registers used: f6, f7, f8

  // save old FPSR in r36
  mov r36 = ar40
  // load fpsr in r37
  ld8 r37 = [r35];;
  // set new value of FPSR
  mov ar40 = r37
  // load a, the first argument, in f6
  ldfs f6 = [r32];;
  // load b, the second argument, in f7
  ldfs f7 = [r33];;
  // Step (1)
  // y0 = 1 / b in f8
  frcpa.s0 f8,p6=f6,f7;;
  // Step (2)
  // q0 = a * y0 in f6
  (p6) fma.s1 f6=f6,f8,f0
  // Step (3)
  // e0 = 1 - b * y0 in f7
  (p6) fnma.s1 f7=f7,f8,f1;;
  // Step (4)
  // q1 = q0 + e0 * q0 in f6
  (p6) fma.s1 f6=f7,f6,f6
  // Step (5)
  // e1 = e0 * e0 in f7
  (p6) fma.s1 f7=f7,f7,f0;;
  // Step (6)
  // q2 = q1 + e1 * q1 in f6
  (p6) fma.s1 f6=f7,f6,f6
  // Step (7)
  // e2 = e1 * e1 in f7
  (p6) fma.s1 f7=f7,f7,f0;;
  // Step (8)
  // q3 = q2 + e2 * q2 in f6
  (p6) fma.d.s1 f6=f7,f6,f6;;
  // Step (9)
  // q3' = q3 in f8
  (p6) fma.s.s0 f8=f6,f1,f0;;
  // store result
  stfs [r34]=f8
  // save fpsr
  mov.m r37 = ar40;;
  st8 [r35] = r37
  // restore FPSR
  mov ar40 = r36;;
  // return
  br.ret.sptk b0

  .endp _thmB


  .proc  _thmH#
  .global _thmH#
  .align 32

_thmH:
  alloc r31=ar.pfs,3,2,0,0  // r32, r33, r34, r35, r36

  // &a is in r32
  // &sqrt is in r33 (the address of the sqrt result)
  // &fpsr in r34

  // general registers used: r31, r32, r33, r34, r35
  // predicate registers used: p6
  // floating-point registers used: f6, f7, f8, f9, f10, f11, f12

  //  save old FPSR in r35
  mov r35 = ar40
  // load fpsr in r36
  ld8 r36 = [r34];;
  // set new value of FPSR
  mov ar40 = r36
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe;;
  // +1/2 in f7
  setf.exp f7 = r2
  // load the argument a in f6
  ldfs f6 = [r32];;
  // Step (1)
  // y0 = 1/sqrt(a) in f8
  frsqrta.s0 f8,p6=f6;;
  // Step (2)
  // h = +1/2 * a in f9
  (p6) fma.s1 f9=f7,f6,f0
  // Step (3)
  // t1 = y0 * y0 in f10
  (p6) fma.s1 f10=f8,f8,f0;;
  // Step (4)
  // t2 = 1/2 - t1 * h in f10
  (p6) fnma.s1 f10=f10,f9,f7;;
  // Step (5)
  // y1 = y0 + t2 * y0 in f8
  (p6) fma.s1 f8=f10,f8,f8;;
  // Step (6)
  // S = a * y1 in f10
  (p6) fma.s1 f10=f6,f8,f0
  // Step (7)
  // t3 = y1 * h in f9
  (p6) fma.s1 f9=f8,f9,f0
  // Step (8)
  // H = 1/2 * y1 in f11
  (p6) fma.s1 f11=f7,f8,f0;;
  // Step (9)
  // d = a - S * S in f12
  (p6) fnma.s1 f12=f10,f10,f6
  // Step (10)
  // t4 = 1/2 - t3 * y1 in f7
  (p6) fnma.s1 f7=f9,f8,f7;;
  // Step (11)
  // S1 = S + d * H in f8
  (p6) fma.s.s1 f8=f12,f11,f10
  // Step (12)
  // H1 = H + t4 * H in f7
  (p6) fma.s1 f7=f7,f11,f11;;
  // Step (13)
  // d1 = a - S1 * S1 in f6
  (p6) fnma.s1 f6=f8,f8,f6;;
  // Step (14)
  // R = S1 + d1 * H1 in f8
  (p6) fma.s.s0 f8=f6,f7,f8;;
  // store result
  stfs [r33]=f8
  // save fpsr
  mov.m r36 = ar40;;
  st8 [r34] = r36
  // restore FPSR
  mov ar40 = r35;;
  // return
  br.ret.sptk b0

  .endp _thmH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\modf.s ===
.file "modf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00: Improved speed, corrected result for NaN input
//
// API
//==============================================================
// double modf(double x, double *iptr)
// break a floating point x number into fraction and an exponent
//
// input  floating point f8, address in r33
// output floating point f8 (x fraction), and *iptr (x integral part)
//
// OVERVIEW
//==============================================================
//
// NO FRACTIONAL PART: HUGE
// If
// for double-extended
// If the true exponent is greater than 63
//      1003e ==> 1003e -ffff = 3f = 63(dec)
// for double
// If the true exponent is greater than 52
//                10033 -ffff = 34 = 52(dec)
// for single
// If the true exponent is greater than 23
//                10016 -ffff = 17 = 23(dec)
// then
// we are already an integer (p9 true)

// NO INTEGER PART:    SMALL
//     Is f8 exponent less than register bias (that is, is it
//     less than 1). If it is, get the right sign of
//     zero and store this in iptr.

// CALCULATION: NOT HUGE, NOT SMALL
// To get the integer part
// Take the floating-point  input and truncate 
//   then convert  this integer to fp  Call it  MODF_INTEGER_PART

// Subtract  MODF_INTEGER_PART from MODF_NORM_F8 to get fraction part
// Then put fraction part in f8 
//      put integer  part MODF_INTEGER_PART into *iptr

// Registers used
//==============================================================

// predicate registers used: 
// p6 - p13

//                      0xFFFF           0x10033
// -----------------------+-----------------+-------------
//              SMALL     |      NORMAL     | HUGE
//    p11 --------------->|<----- p12 ----->| <-------------- p9
//    p10 --------------------------------->|
//    p13 --------------------------------------------------->|
//

// floating-point registers used: 
MODF_NORM_F8               = f9
MODF_FRACTION_PART         = f10
MODF_INTEGER_PART          = f11
MODF_INT_INTEGER_PART      = f12


// general registers used 
modf_signexp    = r14
modf_GR_10033   = r15
modf_GR_FFFF    = r16
modf_17_ones    = r17 
modf_exp        = r18
// r33 = iptr
     

.align 32
.global modf#

.section .text
.proc  modf#
.align 32


// Main path is p9, p11, p8 FALSE and p12 TRUE

// Assume input is normalized and get signexp
// Normalize input just in case
// Form exponent bias 
modf: 
{ .mfi
(p0)  getf.exp  modf_signexp = f8
(p0)  fnorm          MODF_NORM_F8  = f8
(p0)  addl           modf_GR_FFFF  = 0xffff, r0
}
// Get integer part of input
// Form exponent mask
{ .mfi
      nop.m 999
(p0)  fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = f8
(p0)  mov  modf_17_ones     = 0x1ffff ;;
}

// Is x unnorm?
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11 = 0x0b UNORM
// Form biased exponent where input only has an integer part
{ .mfi
      nop.m 999
(p0)  fclass.m.unc p8,p0 = f8, 0x0b
(p0)  addl modf_GR_10033 = 0x10033, r0 ;;
}

// Mask to get exponent
// Is x nan or inf?
// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11 = 0xe3 NAN_INF
// Set p13 to indicate calculation path, else p6 if nan or inf 
{ .mfi
(p0)  and       modf_exp = modf_17_ones, modf_signexp 
(p0)  fclass.m.unc p6,p13 = f8, 0xe3
      nop.i 999 ;;
}

// If x unorm get signexp from normalized input
// If x unorm get integer part from normalized input
{ .mfi
(p8)  getf.exp  modf_signexp = MODF_NORM_F8
(p8)  fcvt.fx.trunc  MODF_INT_INTEGER_PART   = MODF_NORM_F8
      nop.i 999 ;;
}

// If x unorm mask to get exponent
// Is x inf? p6 if inf, p7 if nan
{ .mfi
(p8)  and       modf_exp = modf_17_ones, modf_signexp
(p6)  fclass.m.unc p6,p7 = f8, 0x23
      nop.i 999 ;;
}

// p11 <== SMALL, no integer part, fraction is everyting
// p9  <== HUGE,  no fraction part, integer is everything
// p12 <== NORMAL, fraction part and integer part
{ .mii
(p13) cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999
      nop.i 999 ;;
}

// For SMALL set fraction to normalized input, integer part to signed 0
{ .mfi
(p10) cmp.gt.unc p9,p12  = modf_exp, modf_GR_10033
(p11) fmerge.s MODF_INTEGER_PART = f8,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p11) fnorm.d   f8 = MODF_NORM_F8
      nop.i 999 ;;
}

// For HUGE set fraction to signed 0
{ .mfi
      nop.m 999
(p9)  fmerge.s f8 = f8,f0
      nop.i 999
}
// For NORMAL float the integer part
{ .mfi
      nop.m 999
(p12) fcvt.xf    MODF_INTEGER_PART = MODF_INT_INTEGER_PART
      nop.i 999 ;;
}

// If x inf set integer part to INF, fraction to signed 0
{ .mfi
(p6)  stfd [r33] = MODF_NORM_F8
(p6)  fmerge.s  f8 = f8,f0
      nop.i 999
}
// For HUGE set integer part to normalized input
{ .mfi
      nop.m 999
(p9)  fnorm.d MODF_INTEGER_PART = MODF_NORM_F8
      nop.i 999 ;;
}

// If x nan set integer and fraction parts to NaN (quietized)
{ .mfi
(p7)  stfd [r33] = MODF_NORM_F8
(p7)  fmerge.s  f8 = MODF_NORM_F8, MODF_NORM_F8
      nop.i 999 ;;
}

// For NORMAL compute fraction part
{ .mfi
      nop.m 999
(p12) fms.d.s0   f8 = MODF_NORM_F8,f1, MODF_INTEGER_PART
      nop.i 999
}
// For NORMAL test if fraction part is zero; if so append correct sign
{ .mfi
      nop.m 999
(p12) fcmp.eq.unc p12,p0 = MODF_NORM_F8, MODF_INTEGER_PART
      nop.i 999 ;;
}

// For NORMAL if fraction part is zero append sign of input
{ .mfb
(p13) stfd [r33] = MODF_INTEGER_PART
(p12) fmerge.s f8 = MODF_NORM_F8, f8
(p0)  br.ret.sptk    b0 ;;
}

.endp modf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\modff.s ===
.file "modff.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00: Improved speed, corrected result for NaN input
//
// API
//==============================================================
// float modff(float x, float *iptr)
// break a floating point x number into fraction and an exponent
//
// input  floating point f8, address in r33
// output floating point f8 (x fraction), and *iptr (x integral part)
//
// OVERVIEW
//==============================================================

// NO FRACTIONAL PART: HUGE
// If
// for double-extended
// If the true exponent is greater than 63
//      1003e ==> 1003e -ffff = 3f = 63(dec)
// for double
// If the true exponent is greater than 52
//                10033 -ffff = 34 = 52(dec)
// for single
// If the true exponent is greater than 23
//                10016 -ffff = 17 = 23(dec)
// then
// we are already an integer (p9 true)

// NO INTEGER PART:    SMALL
//     Is f8 exponent less than register bias (that is, is it
//     less than 1). If it is, get the right sign of
//     zero and store this in iptr.

// CALCULATION: NOT HUGE, NOT SMALL
// To get the integer part
// Take the floating-point  input and truncate 
//   then convert  this integer to fp  Call it  MODF_INTEGER_PART

// Subtract  MODF_INTEGER_PART from MODF_NORM_F8 to get fraction part
// Then put fraction part in f8 
//      put integer  part MODF_INTEGER_PART into *iptr

// Registers used
//==============================================================

// predicate registers used: 
// p6 - p13

//                      0xFFFF           0x10016
// -----------------------+-----------------+-------------
//              SMALL     |      NORMAL     | HUGE
//    p11 --------------->|<----- p12 ----->| <-------------- p9
//    p10 --------------------------------->|
//    p13 --------------------------------------------------->|
//

// floating-point registers used: 
MODF_NORM_F8               = f9
MODF_FRACTION_PART         = f10
MODF_INTEGER_PART          = f11
MODF_INT_INTEGER_PART      = f12


// general registers used 
modf_signexp    = r14
modf_GR_10016   = r15
modf_GR_FFFF    = r16
modf_17_ones    = r17 
modf_exp        = r18
// r33 = iptr
     

.align 32
.global modff#

.section .text
.proc  modff#
.align 32


// Main path is p9, p11, p8 FALSE and p12 TRUE

// Assume input is normalized and get signexp
// Normalize input just in case
// Form exponent bias 
modff: 
{ .mfi
(p0)  getf.exp  modf_signexp = f8
(p0)  fnorm          MODF_NORM_F8  = f8
(p0)  addl           modf_GR_FFFF  = 0xffff, r0
}
// Get integer part of input
// Form exponent mask
{ .mfi
      nop.m 999
(p0)  fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = f8
(p0)  mov  modf_17_ones     = 0x1ffff ;;
}

// Is x unnorm?
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11 = 0x0b UNORM
// Form biased exponent where input only has an integer part
{ .mfi
      nop.m 999
(p0)  fclass.m.unc p8,p0 = f8, 0x0b
(p0)  addl modf_GR_10016 = 0x10016, r0 ;;
}

// Mask to get exponent
// Is x nan or inf?
// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11 = 0xe3 NAN_INF
// Set p13 to indicate calculation path, else p6 if nan or inf 
{ .mfi
(p0)  and       modf_exp = modf_17_ones, modf_signexp 
(p0)  fclass.m.unc p6,p13 = f8, 0xe3
      nop.i 999 ;;
}

// If x unorm get signexp from normalized input
// If x unorm get integer part from normalized input
{ .mfi
(p8)  getf.exp  modf_signexp = MODF_NORM_F8
(p8)  fcvt.fx.trunc  MODF_INT_INTEGER_PART   = MODF_NORM_F8
      nop.i 999 ;;
}

// If x unorm mask to get exponent
// Is x inf? p6 if inf, p7 if nan
{ .mfi
(p8)  and       modf_exp = modf_17_ones, modf_signexp
(p6)  fclass.m.unc p6,p7 = f8, 0x23
      nop.i 999 ;;
}

// p11 <== SMALL, no integer part, fraction is everyting
// p9  <== HUGE,  no fraction part, integer is everything
// p12 <== NORMAL, fraction part and integer part
{ .mii
(p13) cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999
      nop.i 999 ;;
}

// For SMALL set fraction to normalized input, integer part to signed 0
{ .mfi
(p10) cmp.gt.unc p9,p12  = modf_exp, modf_GR_10016
(p11) fmerge.s MODF_INTEGER_PART = f8,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p11) fnorm.s   f8 = MODF_NORM_F8
      nop.i 999 ;;
}

// For HUGE set fraction to signed 0
{ .mfi
      nop.m 999
(p9)  fmerge.s f8 = f8,f0
      nop.i 999
}
// For NORMAL float the integer part
{ .mfi
      nop.m 999
(p12) fcvt.xf    MODF_INTEGER_PART = MODF_INT_INTEGER_PART
      nop.i 999 ;;
}

// If x inf set integer part to INF, fraction to signed 0
{ .mfi
(p6)  stfs [r33] = MODF_NORM_F8
(p6)  fmerge.s  f8 = f8,f0
      nop.i 999
}
// For HUGE set integer part to normalized input
{ .mfi
      nop.m 999
(p9)  fnorm.s MODF_INTEGER_PART = MODF_NORM_F8
      nop.i 999 ;;
}

// If x nan set integer and fraction parts to NaN (quietized)
{ .mfi
(p7)  stfs [r33] = MODF_NORM_F8
(p7)  fmerge.s  f8 = MODF_NORM_F8, MODF_NORM_F8
      nop.i 999 ;;
}

// For NORMAL compute fraction part
{ .mfi
      nop.m 999
(p12) fms.s.s0   f8 = MODF_NORM_F8,f1, MODF_INTEGER_PART
      nop.i 999
}
// For NORMAL test if fraction part is zero; if so append correct sign
{ .mfi
      nop.m 999
(p12) fcmp.eq.unc p12,p0 = MODF_NORM_F8, MODF_INTEGER_PART
      nop.i 999 ;;
}

// For NORMAL if fraction part is zero append sign of input
{ .mfb
(p13) stfs [r33] = MODF_INTEGER_PART
(p12) fmerge.s f8 = MODF_NORM_F8, f8
(p0)  br.ret.sptk    b0 ;;
}

.endp modff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\pow.s ===
.file "pow.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/03/00  Added p12 to definite over/under path. With odd power we did not
//          maintain the sign of x in this path.
// 4/04/00  Unwind support added
// 4/19/00  pow(+-1,inf) now returns NaN
//          pow(+-val, +-inf) returns 0 or inf, but now does not call error support
//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 9/07/00  Improved performance by eliminating bank conflicts and other stalls,
//          and tweaking the critical path
// 9/08/00  Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
// 9/28/00  Updated NaN**0 path 
//
// API
//==============================================================
// double pow(double)
// float  powf(float)
//
// Overview of operation
//==============================================================
//
// Three steps...
// 1. Log(x)
// 2. y Log(x)
// 3. exp(y log(x))
// 
// This means we work with the absolute value of x and merge in the sign later.
//      Log(x) = G + delta + r -rsq/2 + p
// G,delta depend on the exponent of x and table entries. The table entries are
// indexed by the exponent of x, called K.
// 
// The G and delta come out of the reduction; r is the reduced x.
// 
// B = frcpa(x)
// xB-1 is small means that B is the approximate inverse of x.
// 
//      Log(x) = Log( (1/B)(Bx) )
//             = Log(1/B) + Log(Bx)
//             = Log(1/B) + Log( 1 + (Bx-1))
// 
//      x  = 2^K 1.x_1x_2.....x_52
//      B= frcpa(x) = 2^-k Cm 
//      Log(1/B) = Log(1/(2^-K Cm))
//      Log(1/B) = Log((2^K/ Cm))
//      Log(1/B) = K Log(2) + Log(1/Cm)
// 
//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
// 
// If you take the significand of x, set the exponent to true 0, then Cm is
// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
// m = x_1x_2...x_8 is an 8-bit index.
// 
//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
// 
// We tabluate as two doubles, T and t, where T +t is the value itself.
// 
//      Log(x)   = (K Log(2)_hi + T) + (Log(2)_hi + t) + Log( 1 + (Bx-1))
//      Log(x)   =  G + delta           + Log( 1 + (Bx-1))
// 
// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
// 
//      Log( 1 + (Bx-1)) = r - rsq/2 + p
// 
// Then,
//    
//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
//      yLog(x) = Z1 + e3      + Z2         + Z3 + (e2 + e3)
// 
// 
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//
//
//       exp(Z3) is another series.
//       exp(e1 + e2 + e3) is approximated as f3 = 1 + (e1 + e2 + e3)
//
//       Z1 (128/log2) = number of log2/128 in Z1 is N1
//       Z2 (128/log2) = number of log2/128 in Z2 is N2
//
//       s1 = Z1 - N1 log2/128
//       s2 = Z2 - N2 log2/128
//
//       s = s1 + s2
//       N = N1 + N2
//
//       exp(Z1 + Z2) = exp(Z)
//       exp(Z)       = exp(s) exp(N log2/128)
//
//       exp(r)       = exp(Z - N log2/128)
//
//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
//                =  Z - N (log2/128) 
//
//      Z         = s+d +N (log2/128)
//
//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
//
//      N = M 128 + n
//
//      N log2/128 = M log2 + n log2/128
//
//      n is 8 binary digits = n_7n_6...n_1
//
//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
//      n log2/128 = I2 log2/8 + I1 log2/128
//
//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128 
//
//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
//      exp(Z)    = exp(s) (1+d1) (1+d2)(2^M) 2^I2/8 2^I1/128
//      exp(Z)    = exp(s) f1 f2 (2^M) 2^I2/8 2^I1/128
//
// I1, I2 are table indices. Use a series for exp(s).
// Then get exp(Z) 
//
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//     exp(yLog(x)) = exp(Z) exp(Z3) f3 
//     exp(yLog(x)) = exp(Z)f3 exp(Z3)  
//     exp(yLog(x)) = A exp(Z3)  
//
// We actually calculate exp(Z3) -1.
// Then, 
//     exp(yLog(x)) = A + A( exp(Z3)   -1)
//

// Table Generation
//==============================================================

// The log values
// ==============
// The operation (K*log2_hi) must be exact. K is the true exponent of x.
// If we allow gradual underflow (denormals), K can be represented in 12 bits
// (as a two's complement number). We assume 13 bits as an engineering precaution.
// 
//           +------------+----------------+-+
//           |  13 bits   | 50 bits        | |
//           +------------+----------------+-+
//           0            1                66
//                        2                34
// 
// So we want the lsb(log2_hi) to be 2^-50
// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
// 
//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
// 
// Consider numbering the bits left to right, starting at 0 thru 127.
// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
// 
//  ...79ab
//     0111 1001 1010 1011
//     44
//     89
// 
// So if we shift off the rightmost 14 bits, then (shift back only 
// the top half) we get
// 
//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
// 
// Put the right 64-bit signficand in an FR register, convert to double;
// it is exact. Put the next 128 bits into a quad register and round to double.
// The true exponent of the low part is -51.
// 
// hi is 0 fffe b17217f7d1cf4000
// lo is 0 ffcc e6af278ece601000
// 
// Convert to double memory format and get
// 
// hi is 0x3fe62e42fefa39e8
// lo is 0x3cccd5e4f1d9cc02 
// 
// log2_hi + log2_lo is an accurate value for log2.
// 
// 
// The T and t values
// ==================
// A similar method is used to generate the T and t values.
// 
// K * log2_hi + T  must be exact.
// 
// Smallest T,t
// ----------
// The smallest T,t is 
//       T                   t
// data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
// 
// The exponent is 0x3f6 (biased)  or -9 (true).
// For the smallest T value, what we want is to clip the significand such that
// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the specific 
// for the first entry. In general, it is 0xffff - (biased 15-bit exponent).

// Independently, what we have calculated is the table value as a quad precision number.
// Table entry 1 is
// 0 fff6 80200aaeac44ef38 338f77605fdf8000
// 
// We store this quad precision number in a data structure that is
//    sign:           1 
//    exponent:      15
//    signficand_hi: 64 (includes explicit bit)
//    signficand_lo: 49
// Because the explicit bit is included, the significand is 113 bits.
// 
// Consider significand_hi for table entry 1.
// 
// 
// +-+--- ... -------+--------------------+
// | |
// +-+--- ... -------+--------------------+
// 0 1               4444444455555555556666
//                   2345678901234567890123
// 
// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
// bit 42 goes in 51.
// 
// So what we want to do is shift bits 43 thru 63 into significand_lo.
// This is shifting bit 42 into bit 63, taking care to retain the shifted-off bits.
// Then shifting (just with signficaand_hi) back into bit 42. 
//  
// The shift_value is 63-42 = 21. In general, this is 
//      63 - (51 -(0xffff - 0xfff6))
// For this example, it is
//      63 - (51 - 9) = 63 - 42  = 21
// 
// This means we are shifting 21 bits into significand_lo.  We must maintain more
// that a 128-bit signficand not to lose bits. So before the shift we put the 128-bit 
// significand into a 256-bit signficand and then shift.
// The 256-bit significand has four parts: hh, hl, lh, and ll.
// 
// Start off with
//      hh         hl         lh         ll
//      <64>       <49><15_0> <64_0>     <64_0>
// 
// After shift by 21 (then return for significand_hi),
//      <43><21_0> <21><43>   <6><58_0>  <64_0>
// 
// Take the hh part and convert to a double. There is no rounding here.
// The conversion is exact. The true exponent of the high part is the same as the
// true exponent of the input quad.
// 
// We have some 64 plus significand bits for the low part. In this example, we have
// 70 bits. We want to round this to a double. Put them in a quad and then do a quad fnorm.
// For this example the true exponent of the low part is 
//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
// In general, this is 
//      true_exponent_of_high - (64 - shift_value)  
// 
// 
// Largest T,t
// ----------
// The largest T,t is
// data8 0x3fe62643fecf9742, 0x3c9e3147684bd37d    log(1/frcpa(1+255/256))=  +6.92171e-001
// 
// Table entry 256 is
// 0 fffe b1321ff67cba178c 51da12f4df5a0000
// 
// The shift value is 
//      63 - (51 -(0xffff - 0xfffe)) = 13
// 
// The true exponent of the low part is 
//      true_exponent_of_high - (64 - shift_value)
//      -1 - (64-13) = -52
// Biased as a double, this is 0x3cb
// 
// 
// 
// So then lsb(T) must be >= 2^-51
// msb(Klog2_hi) <= 2^12
// 
//              +--------+---------+
//              |       51 bits    | <== largest T
//              +--------+---------+
//              | 9 bits | 42 bits | <== smallest T
// +------------+----------------+-+
// |  13 bits   | 50 bits        | |
// +------------+----------------+-+



// Special Cases
//==============================================================

//                                   double     float
// overflow                          error 24   30

// underflow                         error 25   31

// X zero  Y zero
//  +0     +0                 +1     error 26   32
//  -0     +0                 +1     error 26   32
//  +0     -0                 +1     error 26   32
//  -0     -0                 +1     error 26   32

// X zero  Y negative
//  +0     -odd integer       +inf   error 27   33  divide-by-zero
//  -0     -odd integer       -inf   error 27   33  divide-by-zero
//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
//  +0     -inf               +inf   error 27   33  divide-by-zero
//  -0     -inf               +inf   error 27   33  divide-by-zero

// X zero  Y positve
//  +0     +odd integer       +0
//  -0     +odd integer       -0
//  +0     !+odd integer      +0
//  -0     !+odd integer      +0
//  +0     +inf               +0
//  -0     +inf               +0

// X one
//  -1     Y inf              +1
//  -1     Y NaN              quiet Y               invalid if Y SNaN
//  +1     Y any              +1

// X -     Y not integer      QNAN   error 28   34  invalid

// X NaN   Y 0                +1     error 29   35
// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
// X NaN   Y any else         quiet X               invalid if X SNaN
// X !+1   Y NaN              quiet Y               invalid if Y SNaN


// X +inf  Y >0               +inf
// X -inf  Y >0, !odd integer +inf
// X -inf  Y >0, odd integer  -inf

// X +inf  Y <0               +0
// X -inf  Y <0, !odd integer +0
// X -inf  Y <0, odd integer  -0

// X +inf  Y =0               +0
// X -inf  Y =0               +0

// Assembly macros
//==============================================================

// integer registers used

pow_AD_Tt                 = r33
pow_GR_FFF7               = r34
pow_GR_exp_Y              = r34 // duplicate
pow_GR_17ones             = r35

pow_AD_P                  = r36
pow_AD_Q                  = r37
pow_AD_tbl1               = r38
pow_AD_tbl2               = r39
pow_GR_exp_X              = r40
pow_GR_true_exp_X         = r40 // duplicate

pow_GR_offset             = r41
pow_GR_exp_Xm1            = r42
pow_GR_sig_X              = r43
pow_GR_signexp_X          = r44

pow_GR_signexp_Xm1        = r46
pow_GR_int_W1             = r47
pow_GR_int_W2             = r48
pow_GR_int_N              = r49
pow_GR_index1             = r50

pow_GR_index2             = r51
pow_AD_T1                 = r52
pow_AD_T2                 = r53
pow_GR_gt_ln              = r53 // duplicate
pow_int_GR_M              = r54
pow_GR_FFFE               = r55
pow_GR_10033              = r55

pow_GR_16ones             = r56
pow_GR_sig_int_Y          = r57
pow_GR_sign_Y_Gpr         = r58
pow_GR_17ones_m1          = r59
pow_GR_one                = r60
pow_GR_sign_Y             = r60 

pow_GR_signexp_Y_Gpr      = r61 
pow_GR_exp_Y_Gpr          = r62 
pow_GR_true_exp_Y_Gpr     = r63 
pow_GR_signexp_Y          = r64 

GR_SAVE_B0                = r65
GR_SAVE_GP                = r66
GR_SAVE_PFS               = r67

GR_Parameter_X            = r68
GR_Parameter_Y            = r69
GR_Parameter_RESULT       = r70
pow_GR_tag                = r71


// floating point registers used

POW_B                     = f32
POW_NORM_X                = f33
POW_Xm1                   = f34
POW_r1                    = f34
POW_P4                    = f35

POW_P5                    = f36
POW_NORM_Y                = f37
POW_Q2                    = f38
POW_Q3                    = f39
POW_P2                    = f40

POW_P3                    = f41
POW_P0                    = f42
POW_log2_lo               = f43
POW_r                     = f44
POW_Q0                    = f45

POW_Q1                    = f46  
POW_v21                   = f47
POW_log2_hi               = f48
POW_Q4                    = f49
POW_P1                    = f50

POW_log2_by_128_hi        = f51
POW_inv_log2_by_128       = f52
POW_rsq                   = f53
POW_r1sq                  = f54
POW_log2_by_128_lo        = f55

POW_v6                    = f56
POW_v61                   = f57
POW_v4                    = f58
POW_v2                    = f59
POW_T                     = f60

POW_Tt                    = f61
POW_r1sq_by_2             = f62
POW_rsq_by_2              = f63
POW_r1cub                 = f64
POW_rcub                  = f65

POW_U                     = f66
POW_G                     = f67
POW_delta                 = f68
POW_v3                    = f69
POW_V                     = f70

POW_p                     = f71
POW_Z1                    = f72
POW_e3                    = f73
POW_e2                    = f74
POW_Z2                    = f75

POW_e1                    = f76
POW_W1                    = f77
POW_UmZ2                  = f78
POW_W2                    = f79
POW_Z3                    = f80

POW_int_W1                = f81
POW_e12                   = f82
POW_int_W2                = f83
POW_UmZ2pV                = f84
POW_Z3sq                  = f85

POW_e123                  = f86
POW_N1float               = f87
POW_N2float               = f88
POW_f3                    = f89
POW_q                     = f90

POW_s1                    = f91
POW_Nfloat                = f92
POW_s2                    = f93
POW_f2                    = f94
POW_f1                    = f95

POW_T1                    = f96
POW_T2                    = f97
POW_2M                    = f98
POW_s                     = f99
POW_f12                   = f100

POW_ssq                   = f101
POW_T1T2                  = f102
POW_1ps                   = f103
POW_A                     = f104
POW_es                    = f105

POW_half                  = f106
POW_int_K                 = f107
POW_K                     = f108
POW_f123                  = f109
POW_Gpr                   = f110

POW_Y_Gpr                 = f111 
POW_int_Y                 = f112
POW_v61                   = f113
POW_v41                   = f114
POW_abs_f8                = f115

POW_float_int_Y           = f116
POW_ftz_urm_f8            = f117
POW_wre_urm_f8            = f118
POW_abs_A                 = f119
POW_gt_pln                = f120

POW_ABS_NORM_X            = f121

// Data tables
//==============================================================

.data

.align 16

pow_table_P:
data8 0x9249FE7F0DC423CF, 0x00003FFC  // P_4
data8 0x8000F7B249FF332D, 0x0000BFFC  // P_5
data8 0xAAAAAAA9E7902C7F, 0x0000BFFC  // P_3
data8 0x80000000000018E5, 0x0000BFFD  // P_1
data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128
data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo


data8 0x3FA5555555554A9E // Q_2
data8 0x3F8111124F4DD9F9 // Q_3
data8 0x3FE0000000000000 // Q_0
data8 0x3FC5555555554733 // Q_1
data8 0x3F56C16D9360FFA0 // Q_4
data8 0x0000000000000000 // pad
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q

pow_Tt:
data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81 // log(1/frcpa(1+0/256))=  +1.95503e-003
data8 0x3f78121214586a00, 0x3cb540e0a5cfc9bc // log(1/frcpa(1+1/256))=  +5.87661e-003
data8 0x3f841929f9683200, 0x3cbdf1d57404da1f // log(1/frcpa(1+2/256))=  +9.81362e-003
data8 0x3f8c317384c75f00, 0x3c69806208c04c22 // log(1/frcpa(1+3/256))=  +1.37662e-002
data8 0x3f91a6b91ac73380, 0x3c7874daa716eb32 // log(1/frcpa(1+4/256))=  +1.72376e-002
data8 0x3f95ba9a5d9ac000, 0x3cacbb84e08d78ac // log(1/frcpa(1+5/256))=  +2.12196e-002
data8 0x3f99d2a807432580, 0x3cbcf80538b441e1 // log(1/frcpa(1+6/256))=  +2.52177e-002
data8 0x3f9d6b2725979800, 0x3c6095e5c8f8f359 // log(1/frcpa(1+7/256))=  +2.87291e-002
data8 0x3fa0c58fa19dfa80, 0x3cb4c5d4e9d0dda2 // log(1/frcpa(1+8/256))=  +3.27573e-002
data8 0x3fa2954c78cbce00, 0x3caa932b860ab8d6 // log(1/frcpa(1+9/256))=  +3.62953e-002
data8 0x3fa4a94d2da96c40, 0x3ca670452b76bbd5 // log(1/frcpa(1+10/256))=  +4.03542e-002
data8 0x3fa67c94f2d4bb40, 0x3ca84104f9941798 // log(1/frcpa(1+11/256))=  +4.39192e-002
data8 0x3fa85188b630f040, 0x3cb40a882cbf0153 // log(1/frcpa(1+12/256))=  +4.74971e-002
data8 0x3faa6b8abe73af40, 0x3c988d46e25c9059 // log(1/frcpa(1+13/256))=  +5.16017e-002
data8 0x3fac441e06f72a80, 0x3cae3e930a1a2a96 // log(1/frcpa(1+14/256))=  +5.52072e-002
data8 0x3fae1e6713606d00, 0x3c8a796f6283b580 // log(1/frcpa(1+15/256))=  +5.88257e-002
data8 0x3faffa6911ab9300, 0x3c5193070351e88a // log(1/frcpa(1+16/256))=  +6.24574e-002
data8 0x3fb0ec139c5da600, 0x3c623f2a75eb992d // log(1/frcpa(1+17/256))=  +6.61022e-002
data8 0x3fb1dbd2643d1900, 0x3ca649b2ef8927f0 // log(1/frcpa(1+18/256))=  +6.97605e-002
data8 0x3fb2cc7284fe5f00, 0x3cbc5e86599513e2 // log(1/frcpa(1+19/256))=  +7.34321e-002
data8 0x3fb3bdf5a7d1ee60, 0x3c90bd4bb69dada3 // log(1/frcpa(1+20/256))=  +7.71173e-002
data8 0x3fb4b05d7aa012e0, 0x3c54e377c9b8a54f // log(1/frcpa(1+21/256))=  +8.08161e-002
data8 0x3fb580db7ceb5700, 0x3c7fdb2f98354cde // log(1/frcpa(1+22/256))=  +8.39975e-002
data8 0x3fb674f089365a60, 0x3cb9994c9d3301c1 // log(1/frcpa(1+23/256))=  +8.77219e-002
data8 0x3fb769ef2c6b5680, 0x3caaec639db52a79 // log(1/frcpa(1+24/256))=  +9.14602e-002
data8 0x3fb85fd927506a40, 0x3c9f9f99a3cf8e25 // log(1/frcpa(1+25/256))=  +9.52125e-002
data8 0x3fb9335e5d594980, 0x3ca15c3abd47d99a // log(1/frcpa(1+26/256))=  +9.84401e-002
data8 0x3fba2b0220c8e5e0, 0x3cb4ca639adf6fc3 // log(1/frcpa(1+27/256))=  +1.02219e-001
data8 0x3fbb0004ac1a86a0, 0x3ca7cb81bf959a59 // log(1/frcpa(1+28/256))=  +1.05469e-001
data8 0x3fbbf968769fca00, 0x3cb0c646c121418e // log(1/frcpa(1+29/256))=  +1.09274e-001
data8 0x3fbccfedbfee13a0, 0x3ca0465fce24ab4b // log(1/frcpa(1+30/256))=  +1.12548e-001
data8 0x3fbda727638446a0, 0x3c82803f4e2e6603 // log(1/frcpa(1+31/256))=  +1.15832e-001
data8 0x3fbea3257fe10f60, 0x3cb986a3f2313d1a // log(1/frcpa(1+32/256))=  +1.19677e-001
data8 0x3fbf7be9fedbfde0, 0x3c97d16a6a621cf4 // log(1/frcpa(1+33/256))=  +1.22985e-001
data8 0x3fc02ab352ff25f0, 0x3c9cc6baad365600 // log(1/frcpa(1+34/256))=  +1.26303e-001
data8 0x3fc097ce579d2040, 0x3cb9ba16d329440b // log(1/frcpa(1+35/256))=  +1.29633e-001
data8 0x3fc1178e8227e470, 0x3cb7bc671683f8e6 // log(1/frcpa(1+36/256))=  +1.33531e-001
data8 0x3fc185747dbecf30, 0x3c9d1116f66d2345 // log(1/frcpa(1+37/256))=  +1.36885e-001
data8 0x3fc1f3b925f25d40, 0x3c8162c9ef939ac6 // log(1/frcpa(1+38/256))=  +1.40250e-001
data8 0x3fc2625d1e6ddf50, 0x3caad3a1ec384fc3 // log(1/frcpa(1+39/256))=  +1.43627e-001
data8 0x3fc2d1610c868130, 0x3cb3ad997036941b // log(1/frcpa(1+40/256))=  +1.47015e-001
data8 0x3fc340c597411420, 0x3cbc2308262c7998 // log(1/frcpa(1+41/256))=  +1.50414e-001
data8 0x3fc3b08b6757f2a0, 0x3cb2170d6cdf0526 // log(1/frcpa(1+42/256))=  +1.53825e-001
data8 0x3fc40dfb08378000, 0x3c9bb453c4f7b685 // log(1/frcpa(1+43/256))=  +1.56677e-001
data8 0x3fc47e74e8ca5f70, 0x3cb836a48fdfce9d // log(1/frcpa(1+44/256))=  +1.60109e-001
data8 0x3fc4ef51f6466de0, 0x3ca07a43919aa64b // log(1/frcpa(1+45/256))=  +1.63553e-001
data8 0x3fc56092e02ba510, 0x3ca85006899d97b0 // log(1/frcpa(1+46/256))=  +1.67010e-001
data8 0x3fc5d23857cd74d0, 0x3ca30a5ba6e7abbe // log(1/frcpa(1+47/256))=  +1.70478e-001
data8 0x3fc6313a37335d70, 0x3ca905586f0ac97e // log(1/frcpa(1+48/256))=  +1.73377e-001
data8 0x3fc6a399dabbd380, 0x3c9b2c6657a96684 // log(1/frcpa(1+49/256))=  +1.76868e-001
data8 0x3fc70337dd3ce410, 0x3cb50bc52f55cdd8 // log(1/frcpa(1+50/256))=  +1.79786e-001
data8 0x3fc77654128f6120, 0x3cad2eb7c9a39efe // log(1/frcpa(1+51/256))=  +1.83299e-001
data8 0x3fc7e9d82a0b0220, 0x3cba127e90393c01 // log(1/frcpa(1+52/256))=  +1.86824e-001
data8 0x3fc84a6b759f5120, 0x3cbd7fd52079f706 // log(1/frcpa(1+53/256))=  +1.89771e-001
data8 0x3fc8ab47d5f5a300, 0x3cbfae141751a3de // log(1/frcpa(1+54/256))=  +1.92727e-001
data8 0x3fc91fe490965810, 0x3cb69cf30a1c319e // log(1/frcpa(1+55/256))=  +1.96286e-001
data8 0x3fc981634011aa70, 0x3ca5bb3d208bc42a // log(1/frcpa(1+56/256))=  +1.99261e-001
data8 0x3fc9f6c407089660, 0x3ca04d68658179a0 // log(1/frcpa(1+57/256))=  +2.02843e-001
data8 0x3fca58e729348f40, 0x3c99f5411546c286 // log(1/frcpa(1+58/256))=  +2.05838e-001
data8 0x3fcabb55c31693a0, 0x3cb9a5350eb327d5 // log(1/frcpa(1+59/256))=  +2.08842e-001
data8 0x3fcb1e104919efd0, 0x3c18965fcce7c406 // log(1/frcpa(1+60/256))=  +2.11855e-001
data8 0x3fcb94ee93e367c0, 0x3cb503716da45184 // log(1/frcpa(1+61/256))=  +2.15483e-001
data8 0x3fcbf851c0675550, 0x3cbdf1b3f7ab5378 // log(1/frcpa(1+62/256))=  +2.18516e-001
data8 0x3fcc5c0254bf23a0, 0x3ca7aab9ed0b1d7b // log(1/frcpa(1+63/256))=  +2.21558e-001
data8 0x3fccc000c9db3c50, 0x3c92a7a2a850072a // log(1/frcpa(1+64/256))=  +2.24609e-001
data8 0x3fcd244d99c85670, 0x3c9f6019120edf4c // log(1/frcpa(1+65/256))=  +2.27670e-001
data8 0x3fcd88e93fb2f450, 0x3c6affb96815e081 // log(1/frcpa(1+66/256))=  +2.30741e-001
data8 0x3fcdedd437eaef00, 0x3c72553595897976 // log(1/frcpa(1+67/256))=  +2.33820e-001
data8 0x3fce530effe71010, 0x3c90913b020fa182 // log(1/frcpa(1+68/256))=  +2.36910e-001
data8 0x3fceb89a1648b970, 0x3c837ba4045bfd25 // log(1/frcpa(1+69/256))=  +2.40009e-001
data8 0x3fcf1e75fadf9bd0, 0x3cbcea6d13e0498d // log(1/frcpa(1+70/256))=  +2.43117e-001
data8 0x3fcf84a32ead7c30, 0x3ca5e3a67b3c6d77 // log(1/frcpa(1+71/256))=  +2.46235e-001
data8 0x3fcfeb2233ea07c0, 0x3cba0c6f0049c5a6 // log(1/frcpa(1+72/256))=  +2.49363e-001
data8 0x3fd028f9c7035c18, 0x3cb0a30b06677ff6 // log(1/frcpa(1+73/256))=  +2.52501e-001
data8 0x3fd05c8be0d96358, 0x3ca0f1c77ccb5865 // log(1/frcpa(1+74/256))=  +2.55649e-001
data8 0x3fd085eb8f8ae790, 0x3cbd513f45fe7a97 // log(1/frcpa(1+75/256))=  +2.58174e-001
data8 0x3fd0b9c8e32d1910, 0x3c927449047ca006 // log(1/frcpa(1+76/256))=  +2.61339e-001
data8 0x3fd0edd060b78080, 0x3c89b52d8435f53e // log(1/frcpa(1+77/256))=  +2.64515e-001
data8 0x3fd122024cf00638, 0x3cbdd976fabda4bd // log(1/frcpa(1+78/256))=  +2.67701e-001
data8 0x3fd14be2927aecd0, 0x3cb02f90ad0bc471 // log(1/frcpa(1+79/256))=  +2.70257e-001
data8 0x3fd180618ef18ad8, 0x3cbd003792c71a98 // log(1/frcpa(1+80/256))=  +2.73461e-001
data8 0x3fd1b50bbe2fc638, 0x3ca9ae64c6403ead // log(1/frcpa(1+81/256))=  +2.76675e-001
data8 0x3fd1df4cc7cf2428, 0x3cb43f0455f7e395 // log(1/frcpa(1+82/256))=  +2.79254e-001
data8 0x3fd214456d0eb8d0, 0x3cb0fbd748d75d30 // log(1/frcpa(1+83/256))=  +2.82487e-001
data8 0x3fd23ec5991eba48, 0x3c906edd746b77e2 // log(1/frcpa(1+84/256))=  +2.85081e-001
data8 0x3fd2740d9f870af8, 0x3ca9802e6a00a670 // log(1/frcpa(1+85/256))=  +2.88333e-001
data8 0x3fd29ecdabcdfa00, 0x3cacecef70890cfa // log(1/frcpa(1+86/256))=  +2.90943e-001
data8 0x3fd2d46602adcce8, 0x3cb97911955f3521 // log(1/frcpa(1+87/256))=  +2.94214e-001
data8 0x3fd2ff66b04ea9d0, 0x3cb12dabe191d1c9 // log(1/frcpa(1+88/256))=  +2.96838e-001
data8 0x3fd335504b355a30, 0x3cbdf9139df924ec // log(1/frcpa(1+89/256))=  +3.00129e-001
data8 0x3fd360925ec44f58, 0x3cb253e68977a1e3 // log(1/frcpa(1+90/256))=  +3.02769e-001
data8 0x3fd38bf1c3337e70, 0x3cb3d283d2a2da21 // log(1/frcpa(1+91/256))=  +3.05417e-001
data8 0x3fd3c25277333180, 0x3cadaa5b035eae27 // log(1/frcpa(1+92/256))=  +3.08735e-001
data8 0x3fd3edf463c16838, 0x3cb983d680d3c108 // log(1/frcpa(1+93/256))=  +3.11399e-001
data8 0x3fd419b423d5e8c0, 0x3cbc86dd921c139d // log(1/frcpa(1+94/256))=  +3.14069e-001
data8 0x3fd44591e0539f48, 0x3c86a76d6dc2782e // log(1/frcpa(1+95/256))=  +3.16746e-001
data8 0x3fd47c9175b6f0a8, 0x3cb59a2e013c6b5f // log(1/frcpa(1+96/256))=  +3.20103e-001
data8 0x3fd4a8b341552b08, 0x3c93f1e86e468694 // log(1/frcpa(1+97/256))=  +3.22797e-001
data8 0x3fd4d4f390890198, 0x3cbf5e4ea7c5105a // log(1/frcpa(1+98/256))=  +3.25498e-001
data8 0x3fd501528da1f960, 0x3cbf58da53e9ad10 // log(1/frcpa(1+99/256))=  +3.28206e-001
data8 0x3fd52dd06347d4f0, 0x3cb98a28cebf6eef // log(1/frcpa(1+100/256))=  +3.30921e-001
data8 0x3fd55a6d3c7b8a88, 0x3c9c76b67c2d1fd4 // log(1/frcpa(1+101/256))=  +3.33644e-001
data8 0x3fd5925d2b112a58, 0x3c9029616a4331b8 // log(1/frcpa(1+102/256))=  +3.37058e-001
data8 0x3fd5bf406b543db0, 0x3c9fb8292ecfc820 // log(1/frcpa(1+103/256))=  +3.39798e-001
data8 0x3fd5ec433d5c35a8, 0x3cb71a1229d17eec // log(1/frcpa(1+104/256))=  +3.42545e-001
data8 0x3fd61965cdb02c18, 0x3cbba94fe1dbb8d2 // log(1/frcpa(1+105/256))=  +3.45300e-001
data8 0x3fd646a84935b2a0, 0x3c9ee496d2c9ae57 // log(1/frcpa(1+106/256))=  +3.48063e-001
data8 0x3fd6740add31de90, 0x3cb1da3a6c7a9dfd // log(1/frcpa(1+107/256))=  +3.50833e-001
data8 0x3fd6a18db74a58c0, 0x3cb494c257add8dc // log(1/frcpa(1+108/256))=  +3.53610e-001
data8 0x3fd6cf31058670e8, 0x3cb0b244a70a8da9 // log(1/frcpa(1+109/256))=  +3.56396e-001
data8 0x3fd6f180e852f0b8, 0x3c9db7aefa866720 // log(1/frcpa(1+110/256))=  +3.58490e-001
data8 0x3fd71f5d71b894e8, 0x3cbe91c4bf324957 // log(1/frcpa(1+111/256))=  +3.61289e-001
data8 0x3fd74d5aefd66d58, 0x3cb06b3d9bfac023 // log(1/frcpa(1+112/256))=  +3.64096e-001
data8 0x3fd77b79922bd378, 0x3cb727d8804491f4 // log(1/frcpa(1+113/256))=  +3.66911e-001
data8 0x3fd7a9b9889f19e0, 0x3ca2ef22df5bc543 // log(1/frcpa(1+114/256))=  +3.69734e-001
data8 0x3fd7d81b037eb6a0, 0x3cb8fd3ba07a7ece // log(1/frcpa(1+115/256))=  +3.72565e-001
data8 0x3fd8069e33827230, 0x3c8bd1e25866e61a // log(1/frcpa(1+116/256))=  +3.75404e-001
data8 0x3fd82996d3ef8bc8, 0x3ca5aab9f5928928 // log(1/frcpa(1+117/256))=  +3.77538e-001
data8 0x3fd85855776dcbf8, 0x3ca56f33337789d6 // log(1/frcpa(1+118/256))=  +3.80391e-001
data8 0x3fd8873658327cc8, 0x3cbb8ef0401db49d // log(1/frcpa(1+119/256))=  +3.83253e-001
data8 0x3fd8aa75973ab8c8, 0x3cbb9961f509a680 // log(1/frcpa(1+120/256))=  +3.85404e-001
data8 0x3fd8d992dc8824e0, 0x3cb220512a53732d // log(1/frcpa(1+121/256))=  +3.88280e-001
data8 0x3fd908d2ea7d9510, 0x3c985f0e513bfb5c // log(1/frcpa(1+122/256))=  +3.91164e-001
data8 0x3fd92c59e79c0e50, 0x3cb82e073fd30d63 // log(1/frcpa(1+123/256))=  +3.93332e-001
data8 0x3fd95bd750ee3ed0, 0x3ca4aa7cdb6dd8a8 // log(1/frcpa(1+124/256))=  +3.96231e-001
data8 0x3fd98b7811a3ee58, 0x3caa93a5b660893e // log(1/frcpa(1+125/256))=  +3.99138e-001
data8 0x3fd9af47f33d4068, 0x3cac294b3b3190ba // log(1/frcpa(1+126/256))=  +4.01323e-001
data8 0x3fd9df270c1914a0, 0x3cbe1a58fd0cd67e // log(1/frcpa(1+127/256))=  +4.04245e-001
data8 0x3fda0325ed14fda0, 0x3cb1efa7950fb57e // log(1/frcpa(1+128/256))=  +4.06442e-001
data8 0x3fda33440224fa78, 0x3c8915fe75e7d477 // log(1/frcpa(1+129/256))=  +4.09379e-001
data8 0x3fda57725e80c380, 0x3ca72bd1062b1b7f // log(1/frcpa(1+130/256))=  +4.11587e-001
data8 0x3fda87d0165dd198, 0x3c91f7845f58dbad // log(1/frcpa(1+131/256))=  +4.14539e-001
data8 0x3fdaac2e6c03f890, 0x3cb6f237a911c509 // log(1/frcpa(1+132/256))=  +4.16759e-001
data8 0x3fdadccc6fdf6a80, 0x3c90ddc4b7687169 // log(1/frcpa(1+133/256))=  +4.19726e-001
data8 0x3fdb015b3eb1e790, 0x3c692dd7d90e1e8e // log(1/frcpa(1+134/256))=  +4.21958e-001
data8 0x3fdb323a3a635948, 0x3c6f85655cbe14de // log(1/frcpa(1+135/256))=  +4.24941e-001
data8 0x3fdb56fa04462908, 0x3c95252d841994de // log(1/frcpa(1+136/256))=  +4.27184e-001
data8 0x3fdb881aa659bc90, 0x3caa53a745a3642f // log(1/frcpa(1+137/256))=  +4.30182e-001
data8 0x3fdbad0bef3db160, 0x3cb32f2540dcc16a // log(1/frcpa(1+138/256))=  +4.32437e-001
data8 0x3fdbd21297781c28, 0x3cbd8e891e106f1d // log(1/frcpa(1+139/256))=  +4.34697e-001
data8 0x3fdc039236f08818, 0x3c809435af522ba7 // log(1/frcpa(1+140/256))=  +4.37718e-001
data8 0x3fdc28cb1e4d32f8, 0x3cb3944752fbd81e // log(1/frcpa(1+141/256))=  +4.39990e-001
data8 0x3fdc4e19b84723c0, 0x3c9a465260cd3fe5 // log(1/frcpa(1+142/256))=  +4.42267e-001
data8 0x3fdc7ff9c74554c8, 0x3c92447d5b6ca369 // log(1/frcpa(1+143/256))=  +4.45311e-001
data8 0x3fdca57b64e9db00, 0x3cb44344a8a00c82 // log(1/frcpa(1+144/256))=  +4.47600e-001
data8 0x3fdccb130a5ceba8, 0x3cbefaddfb97b73f // log(1/frcpa(1+145/256))=  +4.49895e-001
data8 0x3fdcf0c0d18f3268, 0x3cbd3e7bfee57898 // log(1/frcpa(1+146/256))=  +4.52194e-001
data8 0x3fdd232075b5a200, 0x3c9222599987447c // log(1/frcpa(1+147/256))=  +4.55269e-001
data8 0x3fdd490246defa68, 0x3cabafe9a767a80d // log(1/frcpa(1+148/256))=  +4.57581e-001
data8 0x3fdd6efa918d25c8, 0x3cb58a2624e1c6fd // log(1/frcpa(1+149/256))=  +4.59899e-001
data8 0x3fdd9509707ae528, 0x3cbdc3babce578e7 // log(1/frcpa(1+150/256))=  +4.62221e-001
data8 0x3fddbb2efe92c550, 0x3cb0ac0943c434a4 // log(1/frcpa(1+151/256))=  +4.64550e-001
data8 0x3fddee2f3445e4a8, 0x3cbba9d07ce820e8 // log(1/frcpa(1+152/256))=  +4.67663e-001
data8 0x3fde148a1a2726c8, 0x3cb6537e3375b205 // log(1/frcpa(1+153/256))=  +4.70004e-001
data8 0x3fde3afc0a49ff38, 0x3cbfed5518dbc20e // log(1/frcpa(1+154/256))=  +4.72350e-001
data8 0x3fde6185206d5168, 0x3cb6572601f73d5c // log(1/frcpa(1+155/256))=  +4.74702e-001
data8 0x3fde882578823d50, 0x3c9b24abd4584d1a // log(1/frcpa(1+156/256))=  +4.77060e-001
data8 0x3fdeaedd2eac9908, 0x3cb0ceb5e4d2c8f7 // log(1/frcpa(1+157/256))=  +4.79423e-001
data8 0x3fded5ac5f436be0, 0x3ca72f21f1f5238e // log(1/frcpa(1+158/256))=  +4.81792e-001
data8 0x3fdefc9326d16ab8, 0x3c85081a1639a45c // log(1/frcpa(1+159/256))=  +4.84166e-001
data8 0x3fdf2391a21575f8, 0x3cbf11015bdd297a // log(1/frcpa(1+160/256))=  +4.86546e-001
data8 0x3fdf4aa7ee031928, 0x3cb3795bc052a2d1 // log(1/frcpa(1+161/256))=  +4.88932e-001
data8 0x3fdf71d627c30bb0, 0x3c35c61f0f5a88f3 // log(1/frcpa(1+162/256))=  +4.91323e-001
data8 0x3fdf991c6cb3b378, 0x3c97d99419be6028 // log(1/frcpa(1+163/256))=  +4.93720e-001
data8 0x3fdfc07ada69a908, 0x3cbfe9341ded70b1 // log(1/frcpa(1+164/256))=  +4.96123e-001
data8 0x3fdfe7f18eb03d38, 0x3cb85718a640c33f // log(1/frcpa(1+165/256))=  +4.98532e-001
data8 0x3fe007c053c5002c, 0x3cb3addc9c065f09 // log(1/frcpa(1+166/256))=  +5.00946e-001
data8 0x3fe01b942198a5a0, 0x3c9d5aa4c77da6ac // log(1/frcpa(1+167/256))=  +5.03367e-001
data8 0x3fe02f74400c64e8, 0x3cb5a0ee4450ef52 // log(1/frcpa(1+168/256))=  +5.05793e-001
data8 0x3fe04360be7603ac, 0x3c9dd00c35630fe0 // log(1/frcpa(1+169/256))=  +5.08225e-001
data8 0x3fe05759ac47fe30, 0x3cbd063e1f0bd82c // log(1/frcpa(1+170/256))=  +5.10663e-001
data8 0x3fe06b5f1911cf50, 0x3cae8da674af5289 // log(1/frcpa(1+171/256))=  +5.13107e-001
data8 0x3fe078bf0533c568, 0x3c62241edf5fd1f7 // log(1/frcpa(1+172/256))=  +5.14740e-001
data8 0x3fe08cd9687e7b0c, 0x3cb3007febcca227 // log(1/frcpa(1+173/256))=  +5.17194e-001
data8 0x3fe0a10074cf9018, 0x3ca496e84603816b // log(1/frcpa(1+174/256))=  +5.19654e-001
data8 0x3fe0b5343a234474, 0x3cb46098d14fc90a // log(1/frcpa(1+175/256))=  +5.22120e-001
data8 0x3fe0c974c89431cc, 0x3cac0a7cdcbb86c6 // log(1/frcpa(1+176/256))=  +5.24592e-001
data8 0x3fe0ddc2305b9884, 0x3cb2f753210410ff // log(1/frcpa(1+177/256))=  +5.27070e-001
data8 0x3fe0eb524bafc918, 0x3c88affd6682229e // log(1/frcpa(1+178/256))=  +5.28726e-001
data8 0x3fe0ffb54213a474, 0x3cadeefbab9af993 // log(1/frcpa(1+179/256))=  +5.31214e-001
data8 0x3fe114253da97d9c, 0x3cbaf1c2b8bc160a // log(1/frcpa(1+180/256))=  +5.33709e-001
data8 0x3fe128a24f1d9afc, 0x3cb9cf4df375e650 // log(1/frcpa(1+181/256))=  +5.36210e-001
data8 0x3fe1365252bf0864, 0x3c985a621d4be111 // log(1/frcpa(1+182/256))=  +5.37881e-001
data8 0x3fe14ae558b4a92c, 0x3ca104c4aa8977d1 // log(1/frcpa(1+183/256))=  +5.40393e-001
data8 0x3fe15f85a19c7658, 0x3cbadf26e540f375 // log(1/frcpa(1+184/256))=  +5.42910e-001
data8 0x3fe16d4d38c119f8, 0x3cb3aea11caec416 // log(1/frcpa(1+185/256))=  +5.44592e-001
data8 0x3fe18203c20dd130, 0x3cba82d1211d1d6d // log(1/frcpa(1+186/256))=  +5.47121e-001
data8 0x3fe196c7bc4b1f38, 0x3cb6267acc4f4f4a // log(1/frcpa(1+187/256))=  +5.49656e-001
data8 0x3fe1a4a738b7a33c, 0x3c858930213c987d // log(1/frcpa(1+188/256))=  +5.51349e-001
data8 0x3fe1b981c0c9653c, 0x3c9bc2a4a30f697b // log(1/frcpa(1+189/256))=  +5.53895e-001
data8 0x3fe1ce69e8bb1068, 0x3cb7ae6199cf2a00 // log(1/frcpa(1+190/256))=  +5.56447e-001
data8 0x3fe1dc619de06944, 0x3c6b50bb38388177 // log(1/frcpa(1+191/256))=  +5.58152e-001
data8 0x3fe1f160a2ad0da0, 0x3cbd05b2778a5e1d // log(1/frcpa(1+192/256))=  +5.60715e-001
data8 0x3fe2066d7740737c, 0x3cb32e828f9c6bd6 // log(1/frcpa(1+193/256))=  +5.63285e-001
data8 0x3fe2147dba47a390, 0x3cbd579851b8b672 // log(1/frcpa(1+194/256))=  +5.65001e-001
data8 0x3fe229a1bc5ebac0, 0x3cbb321be5237ce8 // log(1/frcpa(1+195/256))=  +5.67582e-001
data8 0x3fe237c1841a502c, 0x3cb3b56e0915ea64 // log(1/frcpa(1+196/256))=  +5.69306e-001
data8 0x3fe24cfce6f80d98, 0x3cb34a4d1a422919 // log(1/frcpa(1+197/256))=  +5.71898e-001
data8 0x3fe25b2c55cd5760, 0x3cb237401ea5015e // log(1/frcpa(1+198/256))=  +5.73630e-001
data8 0x3fe2707f4d5f7c40, 0x3c9d30f20acc8341 // log(1/frcpa(1+199/256))=  +5.76233e-001
data8 0x3fe285e0842ca380, 0x3cbc4d866d5f21c0 // log(1/frcpa(1+200/256))=  +5.78842e-001
data8 0x3fe294294708b770, 0x3cb85e14d5dc54fa // log(1/frcpa(1+201/256))=  +5.80586e-001
data8 0x3fe2a9a2670aff0c, 0x3c7e6f8f468bbf91 // log(1/frcpa(1+202/256))=  +5.83207e-001
data8 0x3fe2b7fb2c8d1cc0, 0x3c930ffcf63c8b65 // log(1/frcpa(1+203/256))=  +5.84959e-001
data8 0x3fe2c65a6395f5f4, 0x3ca0afe20b53d2d2 // log(1/frcpa(1+204/256))=  +5.86713e-001
data8 0x3fe2dbf557b0df40, 0x3cb646be1188fbc9 // log(1/frcpa(1+205/256))=  +5.89350e-001
data8 0x3fe2ea64c3f97654, 0x3c96516fa8df33b2 // log(1/frcpa(1+206/256))=  +5.91113e-001
data8 0x3fe3001823684d70, 0x3cb96d64e16d1360 // log(1/frcpa(1+207/256))=  +5.93762e-001
data8 0x3fe30e97e9a8b5cc, 0x3c98ef96bc97cca0 // log(1/frcpa(1+208/256))=  +5.95531e-001
data8 0x3fe32463ebdd34e8, 0x3caef1dc9a56c1bf // log(1/frcpa(1+209/256))=  +5.98192e-001
data8 0x3fe332f4314ad794, 0x3caa4f0ac5d5fa11 // log(1/frcpa(1+210/256))=  +5.99970e-001
data8 0x3fe348d90e7464cc, 0x3cbe7889f0516acd // log(1/frcpa(1+211/256))=  +6.02643e-001
data8 0x3fe35779f8c43d6c, 0x3ca96bbab7245411 // log(1/frcpa(1+212/256))=  +6.04428e-001
data8 0x3fe36621961a6a98, 0x3ca31f32262db9fb // log(1/frcpa(1+213/256))=  +6.06217e-001
data8 0x3fe37c299f3c3668, 0x3cb15c72c107ee29 // log(1/frcpa(1+214/256))=  +6.08907e-001
data8 0x3fe38ae2171976e4, 0x3cba42a2554b2dd4 // log(1/frcpa(1+215/256))=  +6.10704e-001
data8 0x3fe399a157a603e4, 0x3cb99c62286d8919 // log(1/frcpa(1+216/256))=  +6.12504e-001
data8 0x3fe3afccfe77b9d0, 0x3ca11048f96a43bd // log(1/frcpa(1+217/256))=  +6.15210e-001
data8 0x3fe3be9d503533b4, 0x3ca4022f47588c3e // log(1/frcpa(1+218/256))=  +6.17018e-001
data8 0x3fe3cd7480b4a8a0, 0x3cb4ba7afc2dc56a // log(1/frcpa(1+219/256))=  +6.18830e-001
data8 0x3fe3e3c43918f76c, 0x3c859673d064b8ba // log(1/frcpa(1+220/256))=  +6.21554e-001
data8 0x3fe3f2acb27ed6c4, 0x3cb55c6b452a16a8 // log(1/frcpa(1+221/256))=  +6.23373e-001
data8 0x3fe4019c2125ca90, 0x3cb8c367879c5a31 // log(1/frcpa(1+222/256))=  +6.25197e-001
data8 0x3fe4181061389720, 0x3cb2c17a79c5cc6c // log(1/frcpa(1+223/256))=  +6.27937e-001
data8 0x3fe42711518df544, 0x3ca5f38d47012fc5 // log(1/frcpa(1+224/256))=  +6.29769e-001
data8 0x3fe436194e12b6bc, 0x3cb9854d65a9b426 // log(1/frcpa(1+225/256))=  +6.31604e-001
data8 0x3fe445285d68ea68, 0x3ca3ff9b3a81cd81 // log(1/frcpa(1+226/256))=  +6.33442e-001
data8 0x3fe45bcc464c8938, 0x3cb0a2d8011a6c05 // log(1/frcpa(1+227/256))=  +6.36206e-001
data8 0x3fe46aed21f117fc, 0x3c8a2be41f8e9f3d // log(1/frcpa(1+228/256))=  +6.38053e-001
data8 0x3fe47a1527e8a2d0, 0x3cba4a83594fab09 // log(1/frcpa(1+229/256))=  +6.39903e-001
data8 0x3fe489445efffcc8, 0x3cbf306a23dcbcde // log(1/frcpa(1+230/256))=  +6.41756e-001
data8 0x3fe4a018bcb69834, 0x3ca46c9285029fd1 // log(1/frcpa(1+231/256))=  +6.44543e-001
data8 0x3fe4af5a0c9d65d4, 0x3cbbc1db897580e3 // log(1/frcpa(1+232/256))=  +6.46405e-001
data8 0x3fe4bea2a5bdbe84, 0x3cb84d880d7ef775 // log(1/frcpa(1+233/256))=  +6.48271e-001
data8 0x3fe4cdf28f10ac44, 0x3cb3ec4b7893ce1f // log(1/frcpa(1+234/256))=  +6.50140e-001
data8 0x3fe4dd49cf994058, 0x3c897224d59d3408 // log(1/frcpa(1+235/256))=  +6.52013e-001
data8 0x3fe4eca86e64a680, 0x3cbccf620f24f0cd // log(1/frcpa(1+236/256))=  +6.53889e-001
data8 0x3fe503c43cd8eb68, 0x3c3f872c65971084 // log(1/frcpa(1+237/256))=  +6.56710e-001
data8 0x3fe513356667fc54, 0x3cb9ca64cc3d52c8 // log(1/frcpa(1+238/256))=  +6.58595e-001
data8 0x3fe522ae0738a3d4, 0x3cbe708164c75968 // log(1/frcpa(1+239/256))=  +6.60483e-001
data8 0x3fe5322e26867854, 0x3cb9988ba4aea615 // log(1/frcpa(1+240/256))=  +6.62376e-001
data8 0x3fe541b5cb979808, 0x3ca1662e3a6b95f5 // log(1/frcpa(1+241/256))=  +6.64271e-001
data8 0x3fe55144fdbcbd60, 0x3cb3acd4ca45c1e0 // log(1/frcpa(1+242/256))=  +6.66171e-001
data8 0x3fe560dbc45153c4, 0x3cb4988947959fed // log(1/frcpa(1+243/256))=  +6.68074e-001
data8 0x3fe5707a26bb8c64, 0x3cb3017fe6607ba9 // log(1/frcpa(1+244/256))=  +6.69980e-001
data8 0x3fe587f60ed5b8fc, 0x3cbe7a3266366ed4 // log(1/frcpa(1+245/256))=  +6.72847e-001
data8 0x3fe597a7977c8f30, 0x3ca1e12b9959a90e // log(1/frcpa(1+246/256))=  +6.74763e-001
data8 0x3fe5a760d634bb88, 0x3cb7c365e53d9602 // log(1/frcpa(1+247/256))=  +6.76682e-001
data8 0x3fe5b721d295f10c, 0x3cb716c2551ccbf0 // log(1/frcpa(1+248/256))=  +6.78605e-001
data8 0x3fe5c6ea94431ef8, 0x3ca02b2ed0e28261 // log(1/frcpa(1+249/256))=  +6.80532e-001
data8 0x3fe5d6bb22ea86f4, 0x3caf43a8bbb2f974 // log(1/frcpa(1+250/256))=  +6.82462e-001
data8 0x3fe5e6938645d38c, 0x3cbcedc98821b333 // log(1/frcpa(1+251/256))=  +6.84397e-001
data8 0x3fe5f673c61a2ed0, 0x3caa385eef5f2789 // log(1/frcpa(1+252/256))=  +6.86335e-001
data8 0x3fe6065bea385924, 0x3cb11624f165c5b4 // log(1/frcpa(1+253/256))=  +6.88276e-001
data8 0x3fe6164bfa7cc068, 0x3cbad884f87073fa // log(1/frcpa(1+254/256))=  +6.90222e-001
data8 0x3fe62643fecf9740, 0x3cb78c51da12f4df // log(1/frcpa(1+255/256))=  +6.92171e-001


pow_table_Q:
data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi


// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15
pow_tbl1:
data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF


// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
pow_tbl2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF

.global pow

.section .text
.proc  pow
.align 32

pow:

{ .mfi
          alloc         r32=ar.pfs,1,35,4,0 
          frcpa.s1      POW_B, p6   = f1,f8
          mov           pow_GR_17ones  = 0x1FFFF
}
{ .mfi
(p0)      addl          pow_AD_P   = @ltoff(pow_table_P), gp
          fma.s1        POW_NORM_X     = f8,f1,f0
          mov           pow_GR_FFFE    = 0xFFFE
;;
}


{ .mmf
          ld8 pow_AD_P = [pow_AD_P]
          mov           pow_GR_FFF7    = 0xFFF7
          fmerge.s      POW_abs_f8     = f0,f8
}
;;



// p14 = TRUE ==> X is ZERO
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
{ .mfi
          setf.exp      POW_half        = pow_GR_FFFE 
          fclass.m.unc  p14,p15          = f8, 0x07
          nop.i 999
}
{ .mfi
          mov           pow_GR_16ones   = 0xFFFF
          fma.s1        POW_NORM_Y     = f9,f1,f0
          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
}
;;


// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11
// c                      3
// p11 = TRUE ==> Y is a NAN
{ .mmf
          adds          pow_AD_Q       = pow_table_Q - pow_table_P,  pow_AD_P
          ldfe          POW_P4         = [pow_AD_P], 16
          fclass.m.unc  p11,p0         = f9, 0xc3
}
;;



// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
// p12 = TRUE ==> X is ZERO and Y is ZERO
{ .mmf
          ldfe          POW_P5         = [pow_AD_P], 16
          ldfe          POW_P2         = [pow_AD_Q], 16
(p14)     fclass.m.unc  p12,p0              = f9, 0x07
}
;;


{ .mmf
          ldfe          POW_P3         = [pow_AD_P], 16
          ldfe          POW_P0         = [pow_AD_Q], 16
(p15)     fms.s1        POW_r          = POW_B, POW_NORM_X,f1
}
;;



// p11 = TRUE ==> Y is a NaN
{ .mfi
          ldfe          POW_P1         = [pow_AD_P], 16
          fmerge.s      POW_ABS_NORM_X = f0, POW_NORM_X
          nop.i 999
}
{ .mfb
          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
          fms.s1        POW_Xm1        = POW_abs_f8,f1,f1
(p11)     br.cond.spnt   POW_Y_NAN
}
;;



{ .mmb
          getf.exp      pow_GR_signexp_X    = POW_NORM_X
          ldfe          POW_log2_by_128_hi  = [pow_AD_Q], 16
(p12)     br.cond.spnt POW_X_0_Y_0
}
;;



// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11
// c                      3
// p11 = TRUE ==> X is a NAN
{ .mmf
          getf.sig      pow_GR_sig_X        = POW_NORM_X
          nop.m 999
          fclass.m.unc  p11,p0              = f8, 0xc3
}
;;



{ .mfi
          nop.m 999
          nop.f 999
          and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
}
;;



{ .mfi
          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
          fma.s1        POW_rsq             = POW_r, POW_r,f0
          shl           pow_GR_offset       = pow_GR_sig_X, 1
} 
{ .mfi
(p15)     sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
          nop.f 999
          nop.i 999
}
;;


{ .mfi
          setf.sig POW_int_K                = pow_GR_true_exp_X
          fcvt.fx.s1   POW_int_Y            = POW_NORM_Y
          shr.u     pow_GR_offset           = pow_GR_offset,56
}
{ .mfi
          ldfe      POW_log2_by_128_lo      = [pow_AD_P], 16
          fma.s1    POW_r1sq                = POW_r1, POW_r1,f0
          nop.i 999
;;
}


// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11
// 0                      7
// p12 = TRUE ==> X is a NAN and Y is a zero
// p13 = TRUE ==> X is a NAN and Y is anything else
{ .mfi
          nop.m 999
(p11)     fclass.m.unc  p12,p13             = f9, 0x07
          shl pow_GR_offset                 = pow_GR_offset, 4
}
{ .mfi
          ldfpd  POW_Q2, POW_Q3             = [pow_AD_P], 16
          nop.f 999
          nop.i 999
;;
}


{ .mfi
          add pow_AD_Tt                     = pow_AD_Tt, pow_GR_offset
          fma.s1 POW_v6                     = POW_r,  POW_P5, POW_P4
          nop.i 999
}
{ .mfi
          ldfpd  POW_Q0, POW_Q1             = [pow_AD_P], 16
          fma.s1 POW_v61                     = POW_r1, POW_P5, POW_P4
          nop.i 999
}
;;




{ .mfi
          getf.exp      pow_GR_signexp_Xm1  = POW_Xm1
          fma.s1 POW_v4                     = POW_P3, POW_r,  POW_P2 
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v41                     = POW_P3, POW_r1, POW_P2 
(p12)     br.cond.spnt POW_X_NAN_Y_0
}
;;



{ .mfi
          ldfpd  POW_T, POW_Tt              = [pow_AD_Tt], 16
          fma.s1 POW_v21                     = POW_P1, POW_r1, POW_P0 
          add pow_AD_tbl1                   = r0, pow_AD_Q 
}
{ .mfi
          nop.m 999
          fma.s1 POW_v2                     = POW_P1, POW_r,  POW_P0 
          nop.i 999
}
;;



{ .mfi
          ldfd   POW_Q4                     = [pow_AD_P], 16
          fma POW_r1sq_by_2                 = POW_r1sq, POW_half, f0 
          and       pow_GR_exp_Xm1          = pow_GR_signexp_Xm1, pow_GR_17ones
}
{ .mfi
          nop.m 999
          fma POW_rsq_by_2                  = POW_rsq, POW_half, f0 
          nop.i 999
}
;;





.pred.rel "mutex",p6,p7
{ .mfi
          nop.m 999
          fma.s1 POW_rcub                   = POW_r,  POW_rsq,  f0 
          cmp.lt.unc p6,p7                  = pow_GR_exp_Xm1, pow_GR_FFF7
}
{ .mfi
          nop.m 999
          fma.s1 POW_r1cub                  = POW_r1, POW_r1sq, f0 
          nop.i 999
}
;;


{ .mfi
          getf.exp  pow_GR_signexp_Y        = POW_NORM_Y 
(p6)      fma.s1 POW_U                      = POW_NORM_Y,POW_r1,f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_U                      = POW_NORM_Y,POW_r,f0
          nop.i 999
}
;;


{ .mfi
          getf.sig pow_GR_sig_int_Y         = POW_int_Y
(p6)      fma.s1 POW_v3                     = POW_v61, POW_r1sq,  POW_v41 
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_v3                     = POW_v6, POW_rsq,  POW_v4 
          nop.i 999
}
;;



// p14 = TRUE ==> X is zero
//    p15 = TRUE ==> X is zero AND Y is negative
//    p10 = TRUE ==> X is zero AND Y is >= zero 
{ .mfi
          nop.m 999
          fcvt.xf POW_K                     = POW_int_K
          nop.i 999
}
{ .mfi
          nop.m 999
(p6)      fma.s1 POW_G                       = f0,f0,f0
          nop.i 999
}
;;



{ .mmf
          andcm pow_GR_sign_Y               = pow_GR_signexp_Y, pow_GR_17ones
          adds pow_AD_tbl2                  = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
(p14)     fcmp.lt.unc.s1 p15, p10           = f9,f0
}
;;


// p15 = TRUE ==> X is ZERO and Y is negative
{ .mfi
          and pow_GR_exp_Y                   = pow_GR_signexp_Y, pow_GR_17ones
(p6)      fnma.s1 POW_V                      = POW_NORM_Y, POW_r1sq_by_2,f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fnma.s1 POW_V                      = POW_NORM_Y, POW_rsq_by_2,f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p6)      fmerge.s POW_delta                 = f0,f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p13)     fma.d f8                           = f8,f1,f0
(p13)     br.ret.spnt  b0
}
;;
          


{ .mfi
          nop.m 999
(p6)      fma.s1 POW_p                      = POW_r1sq, POW_v3, POW_v21
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_p                      = POW_rsq,  POW_v3, POW_v2
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p7)      fma.s1 POW_delta                  = POW_K, POW_log2_lo, POW_Tt
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_G                      = POW_K, POW_log2_hi, POW_T 
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fcvt.xf   POW_float_int_Y               = POW_int_Y
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p7)      fms.s1 POW_e2                     = POW_NORM_Y, POW_r, POW_U
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z2                     = POW_U, f1, POW_V
          nop.i 999
}
;;



// qnan snan inf norm     unorm 0 -+
// 0    0    0   1        0     0 10
// 1                      2
// p11 = TRUE ==> X is NEGATIVE 
// p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                return +0
{ .mfi
          nop.m 999
          fclass.m.unc  p11,p0              = f8, 0x1a
          nop.i 999
}
;;


// DOUBLE 0x10033
// SINGLE 0x10016
{ .mfi
          addl pow_GR_10033                 = 0x10033, r0
(p6)      fma.s1 POW_p                      = POW_p, POW_r1cub, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_p                      = POW_p, POW_rcub, f0
          nop.i 999
}
;;



// p10 = TRUE ==> X is zero  AND Y is positive
//    p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                   return +0
//    p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer) 
{ .mfi
          nop.m 999
(p6)      fms.s1 POW_e2                     = POW_NORM_Y, POW_r1, POW_U
(p10)     cmp.gt.unc p8,p9                  =  pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z1                     = POW_NORM_Y, POW_G, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_e3                     = POW_NORM_Y, POW_delta, f0
          nop.i 999
}
{ .mfi 
          nop.m 999
(p7)      fma.s1 POW_Gpr                    = POW_G, f1, POW_r
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_W2                     = POW_Z2, POW_inv_log2_by_128, f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fms.s1 POW_UmZ2                   = POW_U, f1, POW_Z2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p6)      fma.s1 POW_Gpr                    = POW_G, f1, POW_r1
          nop.i 999
}
;;



// p11 = TRUE ==> X is NEGATIVE
//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already int
//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
// p8  = TRUE ==> X is zero  AND Y is outside intger range (treat as even int)
//                return +0


{ .mfi
          nop.m 999
          fma.s1 POW_Z3                     = POW_NORM_Y, POW_p, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p8)      fma.d f8                          = f0,f0,f0
(p11)     cmp.ge.unc  p12,p13                = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          nop.m 999
          fms.s1 POW_e1                     = POW_NORM_Y, POW_G, POW_Z1
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_W1                     = POW_Z1, POW_inv_log2_by_128, f0
(p8)      br.ret.spnt b0
}
;;



// p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer)
//    p6 = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p7 = TRUE ==>  X is zero  AND  Y is NOT an integer, return +0
{ .mfi
          nop.m 999
(p9)      fcmp.eq.unc.s1 p6,p7             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


// p15 = TRUE ==> X_0_Y_NEG
{ .mfi
          nop.m 999
          fcvt.fx.s1 POW_int_W2                = POW_W2
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_UmZ2pV                 = POW_UmZ2,f1,POW_V
(p15)     br.cond.spnt POW_X_0_Y_NEG
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_Y_Gpr                  = POW_NORM_Y, POW_Gpr, f0
          nop.i 999
}
;;


// p6  = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p8 = TRUE ==>  X is zero  AND  Y is an odd  integer
//    p9 = TRUE ==>  X is zero  AND  Y is an even integer
{ .mfi
          nop.m 999
          fma.s1 POW_Z3sq                   = POW_Z3, POW_Z3, f0
(p6)      tbit.nz.unc  p8,p9                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_v4                     = POW_Z3, POW_Q3, POW_Q2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fcvt.fx.s1 POW_int_W1                = POW_W1
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v2                     = POW_Z3, POW_Q1, POW_Q0
(p8)      br.ret.spnt b0
}
;;


{ .mfi
          nop.m 999
(p7)      fma.d f8                          = f0,f0,f0
          nop.i 999
}
;;



// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
//     p10 = TRUE ==> X is NEG and Y is an int
//     p12 = TRUE ==> X is NEG and Y is not an int
{ .mfi
          nop.m 999
(p13)     fcmp.eq.unc.s1 p10,p12             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
{ .mfi
          nop.m 999
(p9)      fma.d f8                          = f0,f0,f0
          nop.i 999
}
;;


// qnan snan inf norm     unorm 0 -+
// 0    0    1   0        0     0 11
// 2                      3
{ .mfi
          nop.m 999
          fclass.m.unc p15,p0 = POW_NORM_X,  0x23
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_e2                     = POW_e2,f1,POW_UmZ2pV
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fcvt.xf POW_N2float                = POW_int_W2
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v3                     = POW_Z3sq, POW_Q4, POW_v4
(p12)     br.cond.spnt POW_X_NEG_Y_NONINT
}
;;



{ .mbb
          getf.sig pow_GR_int_W2             = POW_int_W2
(p15)     br.cond.spnt POW_X_INF
(p7)      br.ret.spnt b0 
}
;;




{ .mfb
          getf.exp pow_GR_signexp_Y_Gpr       = POW_Y_Gpr
          fcvt.xf POW_N1float               = POW_int_W1
(p9)      br.ret.spnt b0
}
;;



// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
{ .mfi
          nop.m 999
          fma.s1  POW_e12                     = POW_e1,f1,POW_e2
(p10)     tbit.nz.unc  p12,p0                = pow_GR_sig_int_Y,0
}
;;




{ .mfi
          getf.sig pow_GR_int_W1             = POW_int_W1
          fnma.s1 POW_s2                     = POW_N2float, POW_log2_by_128_hi, POW_Z2
          and pow_GR_exp_Y_Gpr               = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
;;



{ .mfi
          sub pow_GR_true_exp_Y_Gpr          = pow_GR_exp_Y_Gpr, pow_GR_16ones
          fma.s1 POW_q                       = POW_Z3sq, POW_v3, POW_v2
          andcm pow_GR_sign_Y_Gpr            = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
;;


// double: p8 TRUE ==> |Y(G + r)| >= 10
// single: p8 TRUE ==> |Y(G + r)| >= 7

// double
//     -2^10  -2^9             2^9   2^10
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |  
// single
//     -2^7   -2^6             2^6   2^7
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |




{ .mfi
          add pow_GR_int_N                   = pow_GR_int_W1, pow_GR_int_W2
          nop.f 999
(p0)      cmp.le.unc p8,p9                   = 10, pow_GR_true_exp_Y_Gpr
}
;;



{ .mfi
          and pow_GR_index1                  = 0x0f, pow_GR_int_N
          fnma.s1 POW_s1                     = POW_N1float, POW_log2_by_128_hi, POW_Z1
          shr r2                             = pow_GR_int_N, 7
}
{ .mfi
          and pow_GR_index2                  = 0x70, pow_GR_int_N
          nop.f 999
(p9)      cmp.le.unc p0,p10                  = 9, pow_GR_true_exp_Y_Gpr
}
;;



{ .mfi
          shladd pow_AD_T1                   = pow_GR_index1, 4, pow_AD_tbl1
          nop.f 999
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_e123                    = POW_e12, f1, POW_e3
(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
}
;;



{ .mmi
          ldfe POW_T1                        = [pow_AD_T1],16
          add pow_AD_T2                      = pow_AD_tbl2, pow_GR_index2
          nop.i 999
}
;;



{ .mmf
          ldfe POW_T2                        = [pow_AD_T2],16
          addl pow_int_GR_M                  = 0xFFFF, r2
          fma.s1 POW_q                       = POW_Z3sq, POW_q, POW_Z3
}
;;


{ .mfi
          setf.exp POW_2M                    = pow_int_GR_M
          fnma.s1 POW_f2                     = POW_N2float, POW_log2_by_128_lo, f1
          nop.i 999
}
{ .mfi
          nop.m 999
          fnma.s1 POW_f1                     = POW_N1float, POW_log2_by_128_lo, f1
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_s                       = POW_s1, f1, POW_s2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_f3                      = POW_e123,f1,f1
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_f12                     = POW_f1, POW_f2,f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999 
          fma.s1 POW_ssq                     = POW_s, POW_s, f0
          nop.i 999
}
{ .mfi
          nop.m 999 
          fma.s1 POW_v4                      = POW_s, POW_Q3, POW_Q2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_v2                      = POW_s, POW_Q1, POW_Q0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_T1T2                    = POW_T1, POW_T2, f0
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_1ps                     = f1,f1,POW_s
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_f123                    = POW_f12, POW_f3, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_ssq, POW_Q4, POW_v4
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_A                      =  POW_2M, POW_T1T2, f0
          nop.i 999
}
;;



{ .mfi
          nop.m 999
(p12)     fmerge.s POW_f123 = f8,POW_f123
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_es                     = POW_ssq,  POW_v3, POW_v2
          nop.i 999
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_f123, f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_es                     = POW_es, POW_ssq, POW_1ps
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_es,f0
          nop.i 999
}
;;



{ .mfb
          nop.m 999
(p10)     fma.d f8                          = POW_A, POW_q, POW_A
(p10)     br.ret.sptk     b0
}
;;





// POSSIBLE_OVER_UNDER
// p6 = TRUE ==> Y negative

{ .mfi
        nop.m 999
        fmerge.s POW_abs_A                = f0, POW_A
        cmp.eq.unc p0,p6                  = pow_GR_sign_Y, r0
}
;;

{ .mib
        nop.m 999
        nop.i 999
(p6)    br.cond.spnt POW_POSSIBLE_UNDER 
}
;;

// POSSIBLE_OVER
// We got an answer. 
// overflow is a possibility, not a certainty


// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode

// double
// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// single
// Largest single is FE (biased double)
//                   FE - 7F + FFFF = 1007E
// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ


// Put in s2 (td set, wre set)
{ .mfi
        mov           pow_GR_gt_ln                 = 0x103ff 
        fsetc.s2 0x7F,0x42
        nop.i 999 
}
;;


{ .mfi
        setf.exp POW_gt_pln                        = pow_GR_gt_ln
        fma.d.s2 POW_wre_urm_f8                    = POW_abs_A, POW_q, POW_abs_A
        nop.i 999 ;;
}

// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999
}
;;


// p7 = TRUE ==> yes, we have an overflow
{ .mfi
        nop.m 999
        fcmp.ge.unc.s1 p7, p0                    =  POW_wre_urm_f8, POW_gt_pln
        nop.i 999
}
;;



{ .mfb
(p7)   mov pow_GR_tag                            = 24
       fma.d f8                                  = POW_A, POW_q, POW_A
(p7)   br.cond.spnt __libm_error_region 
}
{ .mfb
       nop.m 999
       nop.f 999
(p0)   br.ret.sptk     b0 
}
;;


POW_POSSIBLE_UNDER:
// We got an answer. input was < -2^9 but > -2^10 (double)
// We got an answer. input was < -2^6 but > -2^7  (float)
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)
// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.
// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.
// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.
//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal


// Put in s2 (td set, ftz set)
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x41
        nop.i 999 
}
;;



{ .mfi
        nop.m 999
        fma.d.s2 POW_ftz_urm_f8                    = POW_A, POW_q, POW_A
        nop.i 999
}
;;


// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999 
}
;;


// p7 = TRUE ==> yes, we have an underflow
{ .mfi
        nop.m 999
        fcmp.eq.unc.s1 p7, p0                     =  POW_ftz_urm_f8, f0
        nop.i 999 
}
;;




{ .mfb
(p7)    mov pow_GR_tag                           = 25
        fma.d f8                                 = POW_A, POW_q, POW_A
(p7)    br.cond.spnt __libm_error_region 
}
;;


{ .mfb
        nop.m 999
        nop.f 999
        br.ret.sptk     b0 
}
;;


POW_X_0_Y_0:
// When X is +-0 and Y is +-0, IEEE returns 1.0 
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 26
         fma.d f8                           = f1,f1,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_INF:
// When X is +-inf and Y is +-, IEEE returns 

// overflow                       
// X +inf  Y +inf             +inf  
// X -inf  Y +inf             +inf 

// X +inf  Y >0               +inf    
// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
// X -inf  Y >0,  odd integer  -inf   

// underflow                     
// X +inf  Y -inf             +0   
// X -inf  Y -inf             +0  

// X +inf  Y <0               +0      
// X -inf  Y <0, !odd integer +0     
// X -inf  Y <0, odd integer  -0    

// X + inf Y=+0                +1
// X + inf Y=-0                +1
// X - inf Y=+0                +1
// X - inf Y=-0                +1

// p13 == Y negative
// p14 == Y positive

// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       p13 == (Y negative) 
//          return +inf
//       p14 == (Y positive)
//          return +0



// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              p13 == (Y negative)    
//                 return (sign_of_x)inf
//              p14 == (Y positive) 
//                 return (sign_of_x)0
//           pxx even                
//              p13 == (Y negative) 
//                 return +inf     
//              p14 == (Y positive)
//                 return +0     

//      pxx == Y is not an integer
//           p13 == (Y negative) 
//                 return +inf
//           p14 == (Y positive)
//                 return +0
// 

{ .mfi
          nop.m 999
          fcmp.lt p13,p14                    = POW_NORM_Y,f0 
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fclass.m p12,p0                    = f9, 0x23
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fclass.m p15,p0                    = f9, 0x07	//@zero
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p15)     fmerge.s f8 = f1,f1
(p15)     br.ret.spnt b0
}
;;

        
{ .mfi
(p13)     mov pow_GR_tag                     = 25
(p14)     frcpa.s1 f8,p10                       = f1,f0
          nop.i 999
}
{ .mfb
(p14)     mov pow_GR_tag                     = 24
(p13)     fma.s1 f8                          = f0,f0,f0
(p12)     br.ret.spnt b0
}
;;

   

{ .mfb
          nop.m 999
(p7)      fcmp.eq.unc.s1 p9,p0              = POW_float_int_Y,  POW_NORM_Y
          nop.b 999
}
;;

{ .mfi
          nop.m 999
          nop.f 999
(p9)      tbit.nz.unc p11,p0                 = pow_GR_sig_int_Y,0
}
;;

{ .mfb
          nop.m 999
(p11)     fmerge.s f8 = POW_NORM_X,f8
          br.ret.sptk b0 
}
;;



POW_X_0_Y_NEG:
// When X is +-0 and Y is negative, IEEE returns 
// X     Y           answer
// +0    -odd int    +inf
// -0    -odd int    -inf

// +0    !-odd int   +inf
// -0    !-odd int   +inf


// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       return +inf

// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              return (sign_of_x)inf
//           p12 even
//              return +inf
//      p10 == Y is not an integer
//         return +inf
// 
// 

{ .mfi
          nop.m 999
          nop.f 999
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          mov pow_GR_tag                     = 27
(p7)      fcmp.eq.unc.s1 p9,p10              = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


{ .mfb
          nop.m 999
(p6)      frcpa.s0 f8,p13                       = f1, f0
(p6)      br.cond.sptk __libm_error_region
}
;;

{ .mfb
          nop.m 999
(p10)     frcpa.s0 f8,p13                       = f1, f0
(p10)     br.cond.sptk __libm_error_region
}
;;



{ .mib
          nop.m 999
(p9)      tbit.nz.unc p11,p12                = pow_GR_sig_int_Y,0
          nop.b 999
}
;;



{ .mfi
          nop.m 999
(p12)     frcpa.s0 f8,p13                      = f1,f0
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p11)     frcpa f8,p13                      = f1,f8 
          br.cond.sptk __libm_error_region
}
;;




POW_X_NEG_Y_NONINT:
// When X is negative and Y is a non-integer, IEEE
// returns a qnan indefinite.
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 28
         frcpa f8,p6                        = f0,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_NAN_Y_0:
// When X is a NAN and Y is zero, IEEE returns 1.
// We call error support with this value.

{ .mfi
         nop.m 0
         fma.d.s0 f10 = f8,f1,f0 
         nop.i 0
}
{ .mfb
         mov pow_GR_tag                     = 29
         fma.d.s0 f8 = f0,f0,f1 
         br.cond.sptk __libm_error_region
}
;;


POW_OVER_UNDER_X_NOT_INF:

// p8 is TRUE for overflow
// p9 is TRUE for underflow

// if y is infinity, we should not over/underflow


{ .mfi
          nop.m 999
          fcmp.eq.unc.s1     p14, p13        = POW_ABS_NORM_X,f1
          cmp.eq.unc p8,p9                   = pow_GR_sign_Y_Gpr, r0
}
;;

{ .mfi
          nop.m 999
(p14)     fclass.m.unc       p15, p0         = f9, 0x23
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fclass.m.unc       p11,p0         = f9, 0x23
          nop.i 999
}
;;

// p15 = TRUE if |x|=1, y=inf, return +1
{ .mfb
          nop.m 999
(p15)     fma.d              f8              = f1,f1,f0
(p15)     br.ret.spnt b0
}
;;

.pred.rel "mutex",p8,p9
{  .mfb
(p8)      setf.exp           f8              = pow_GR_17ones
(p9)      fmerge.s           f8              = f0,f0
(p11)     br.ret.sptk b0
}

{ .mfb
          nop.m 999
          nop.f 999
          br.cond.sptk POW_OVER_UNDER_ERROR
}
;;

POW_Y_NAN:

// Is x = +1 then result is +1, else result is quiet Y
{ .mfi
       nop.m 999
       fcmp.eq.s1         p10,p9               = POW_NORM_X, f1 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fma.d f8 = f1,f1,f0 
       nop.i 999
}
{ .mfb
       nop.m 999
(p9)   fma.d f8 = f9,f8,f0 
       br.ret.sptk b0
}
;;


POW_OVER_UNDER_ERROR:

{ .mfi
          nop.m 999
          fmerge.s f10                      = POW_NORM_X,POW_NORM_X
          nop.i 999
}
{ .mfi
          sub   pow_GR_17ones_m1            = pow_GR_17ones, r0, 1
          nop.f 999
          mov pow_GR_one                    = 0x1
}
;;

// overflow
{ .mmb
(p8)     mov pow_GR_tag                     = 24
(p8)     setf.exp f11                       = pow_GR_17ones_m1
         nop.b 999
}
;;

        
// underflow
{ .mmi
(p9)    mov pow_GR_tag                     = 25
(p9)    setf.exp f11                       = pow_GR_one
        nop.i 999
}
;;


// p12 x is negative and y is an odd integer 


{ .mfi
        nop.m 999
        fma.d f8                               = f11, f11, f0
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p12)   fmerge.ns f8                           = f8, f8
        nop.i 999
}
;;


.endp pow


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:

// Answer is inf for overflow and 0 for underflow.
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = POW_NORM_X              // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfd [GR_Parameter_Y] = f8                      // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\logf.s ===
.file "logf.s"


// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
 
// History
//==============================================================
// ?/??/00  Initial version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// Assembly macros
//=========================================

// integer registers used

 LOG_AD_COEFF               = r33
 LOG_AD_CONSTANTS           = r34
 LOG_mask                   = r35

 LOG_FFF7                   = r36
 LOG_bias                   = r37
 LOG_x_n                    = r38
 LOG_x_ind                  = r39
 LOG_x_sexp                 = r40

 GR_SAVE_B0                 = r41
 GR_SAVE_PFS                = r42
 GR_SAVE_GP                 = r43

 GR_Parameter_X                = r44
 GR_Parameter_Y                = r45
 GR_Parameter_RESULT           = r46
 LOG_tag                       = r47





// floating point registers used

 log_coeff_p3                = f32
 log_coeff_p2                = f33
 log_coeff_p1                = f34
 log_const_log2              = f35

 log_threshhold              = f36
 log_B                       = f37
 log_r                       = f38
 log_poly_p1                 = f39
 log_rsq                     = f40

 log_poly_p2                 = f41
 log_poly_p3                 = f42
 log_n                       = f43
 log_T                       = f44
 log_s                       = f45

 log_poly_q1                 = f46
 log_ssq                     = f47
 log_abs_s                   = f48
 log_poly_q2                 = f49
 log_x_norm                  = f50

 log_inv_ln10                = f51
 log10_f8                    = f52

.data

.align 16


log_coeff_table:
data8 0xbfd0001008f39d59     // p3
data8 0x3fd5556073e0c45a     // p2

log_constants_table:
data8 0xbfdffffffffaea15    // p1
data8 0x3fe62e42fefa39ef    // Log(2)
data8 0x3f70000000000000    // 2^-8, threshhold
data8 0x3fdbcb7b1526e50e    // 1/ln10

data8 0x3F60040155D5889E    //log(1/frcpa(1+   0/256)
data8 0x3F78121214586B54    //log(1/frcpa(1+   1/256)
data8 0x3F841929F96832F0    //log(1/frcpa(1+   2/256)
data8 0x3F8C317384C75F06    //log(1/frcpa(1+   3/256)
data8 0x3F91A6B91AC73386    //log(1/frcpa(1+   4/256)
data8 0x3F95BA9A5D9AC039    //log(1/frcpa(1+   5/256)
data8 0x3F99D2A8074325F4    //log(1/frcpa(1+   6/256)
data8 0x3F9D6B2725979802    //log(1/frcpa(1+   7/256)
data8 0x3FA0C58FA19DFAAA    //log(1/frcpa(1+   8/256)
data8 0x3FA2954C78CBCE1B    //log(1/frcpa(1+   9/256)
data8 0x3FA4A94D2DA96C56    //log(1/frcpa(1+  10/256)
data8 0x3FA67C94F2D4BB58    //log(1/frcpa(1+  11/256)
data8 0x3FA85188B630F068    //log(1/frcpa(1+  12/256)
data8 0x3FAA6B8ABE73AF4C    //log(1/frcpa(1+  13/256)
data8 0x3FAC441E06F72A9E    //log(1/frcpa(1+  14/256)
data8 0x3FAE1E6713606D07    //log(1/frcpa(1+  15/256)
data8 0x3FAFFA6911AB9301    //log(1/frcpa(1+  16/256)
data8 0x3FB0EC139C5DA601    //log(1/frcpa(1+  17/256)
data8 0x3FB1DBD2643D190B    //log(1/frcpa(1+  18/256)
data8 0x3FB2CC7284FE5F1C    //log(1/frcpa(1+  19/256)
data8 0x3FB3BDF5A7D1EE64    //log(1/frcpa(1+  20/256)
data8 0x3FB4B05D7AA012E0    //log(1/frcpa(1+  21/256)
data8 0x3FB580DB7CEB5702    //log(1/frcpa(1+  22/256)
data8 0x3FB674F089365A7A    //log(1/frcpa(1+  23/256)
data8 0x3FB769EF2C6B568D    //log(1/frcpa(1+  24/256)
data8 0x3FB85FD927506A48    //log(1/frcpa(1+  25/256)
data8 0x3FB9335E5D594989    //log(1/frcpa(1+  26/256)
data8 0x3FBA2B0220C8E5F5    //log(1/frcpa(1+  27/256)
data8 0x3FBB0004AC1A86AC    //log(1/frcpa(1+  28/256)
data8 0x3FBBF968769FCA11    //log(1/frcpa(1+  29/256)
data8 0x3FBCCFEDBFEE13A8    //log(1/frcpa(1+  30/256)
data8 0x3FBDA727638446A2    //log(1/frcpa(1+  31/256)
data8 0x3FBEA3257FE10F7A    //log(1/frcpa(1+  32/256)
data8 0x3FBF7BE9FEDBFDE6    //log(1/frcpa(1+  33/256)
data8 0x3FC02AB352FF25F4    //log(1/frcpa(1+  34/256)
data8 0x3FC097CE579D204D    //log(1/frcpa(1+  35/256)
data8 0x3FC1178E8227E47C    //log(1/frcpa(1+  36/256)
data8 0x3FC185747DBECF34    //log(1/frcpa(1+  37/256)
data8 0x3FC1F3B925F25D41    //log(1/frcpa(1+  38/256)
data8 0x3FC2625D1E6DDF57    //log(1/frcpa(1+  39/256)
data8 0x3FC2D1610C86813A    //log(1/frcpa(1+  40/256)
data8 0x3FC340C59741142E    //log(1/frcpa(1+  41/256)
data8 0x3FC3B08B6757F2A9    //log(1/frcpa(1+  42/256)
data8 0x3FC40DFB08378003    //log(1/frcpa(1+  43/256)
data8 0x3FC47E74E8CA5F7C    //log(1/frcpa(1+  44/256)
data8 0x3FC4EF51F6466DE4    //log(1/frcpa(1+  45/256)
data8 0x3FC56092E02BA516    //log(1/frcpa(1+  46/256)
data8 0x3FC5D23857CD74D5    //log(1/frcpa(1+  47/256)
data8 0x3FC6313A37335D76    //log(1/frcpa(1+  48/256)
data8 0x3FC6A399DABBD383    //log(1/frcpa(1+  49/256)
data8 0x3FC70337DD3CE41B    //log(1/frcpa(1+  50/256)
data8 0x3FC77654128F6127    //log(1/frcpa(1+  51/256)
data8 0x3FC7E9D82A0B022D    //log(1/frcpa(1+  52/256)
data8 0x3FC84A6B759F512F    //log(1/frcpa(1+  53/256)
data8 0x3FC8AB47D5F5A310    //log(1/frcpa(1+  54/256)
data8 0x3FC91FE49096581B    //log(1/frcpa(1+  55/256)
data8 0x3FC981634011AA75    //log(1/frcpa(1+  56/256)
data8 0x3FC9F6C407089664    //log(1/frcpa(1+  57/256)
data8 0x3FCA58E729348F43    //log(1/frcpa(1+  58/256)
data8 0x3FCABB55C31693AD    //log(1/frcpa(1+  59/256)
data8 0x3FCB1E104919EFD0    //log(1/frcpa(1+  60/256)
data8 0x3FCB94EE93E367CB    //log(1/frcpa(1+  61/256)
data8 0x3FCBF851C067555F    //log(1/frcpa(1+  62/256)
data8 0x3FCC5C0254BF23A6    //log(1/frcpa(1+  63/256)
data8 0x3FCCC000C9DB3C52    //log(1/frcpa(1+  64/256)
data8 0x3FCD244D99C85674    //log(1/frcpa(1+  65/256)
data8 0x3FCD88E93FB2F450    //log(1/frcpa(1+  66/256)
data8 0x3FCDEDD437EAEF01    //log(1/frcpa(1+  67/256)
data8 0x3FCE530EFFE71012    //log(1/frcpa(1+  68/256)
data8 0x3FCEB89A1648B971    //log(1/frcpa(1+  69/256)
data8 0x3FCF1E75FADF9BDE    //log(1/frcpa(1+  70/256)
data8 0x3FCF84A32EAD7C35    //log(1/frcpa(1+  71/256)
data8 0x3FCFEB2233EA07CD    //log(1/frcpa(1+  72/256)
data8 0x3FD028F9C7035C1C    //log(1/frcpa(1+  73/256)
data8 0x3FD05C8BE0D9635A    //log(1/frcpa(1+  74/256)
data8 0x3FD085EB8F8AE797    //log(1/frcpa(1+  75/256)
data8 0x3FD0B9C8E32D1911    //log(1/frcpa(1+  76/256)
data8 0x3FD0EDD060B78081    //log(1/frcpa(1+  77/256)
data8 0x3FD122024CF0063F    //log(1/frcpa(1+  78/256)
data8 0x3FD14BE2927AECD4    //log(1/frcpa(1+  79/256)
data8 0x3FD180618EF18ADF    //log(1/frcpa(1+  80/256)
data8 0x3FD1B50BBE2FC63B    //log(1/frcpa(1+  81/256)
data8 0x3FD1DF4CC7CF242D    //log(1/frcpa(1+  82/256)
data8 0x3FD214456D0EB8D4    //log(1/frcpa(1+  83/256)
data8 0x3FD23EC5991EBA49    //log(1/frcpa(1+  84/256)
data8 0x3FD2740D9F870AFB    //log(1/frcpa(1+  85/256)
data8 0x3FD29ECDABCDFA04    //log(1/frcpa(1+  86/256)
data8 0x3FD2D46602ADCCEE    //log(1/frcpa(1+  87/256)
data8 0x3FD2FF66B04EA9D4    //log(1/frcpa(1+  88/256)
data8 0x3FD335504B355A37    //log(1/frcpa(1+  89/256)
data8 0x3FD360925EC44F5D    //log(1/frcpa(1+  90/256)
data8 0x3FD38BF1C3337E75    //log(1/frcpa(1+  91/256)
data8 0x3FD3C25277333184    //log(1/frcpa(1+  92/256)
data8 0x3FD3EDF463C1683E    //log(1/frcpa(1+  93/256)
data8 0x3FD419B423D5E8C7    //log(1/frcpa(1+  94/256)
data8 0x3FD44591E0539F49    //log(1/frcpa(1+  95/256)
data8 0x3FD47C9175B6F0AD    //log(1/frcpa(1+  96/256)
data8 0x3FD4A8B341552B09    //log(1/frcpa(1+  97/256)
data8 0x3FD4D4F3908901A0    //log(1/frcpa(1+  98/256)
data8 0x3FD501528DA1F968    //log(1/frcpa(1+  99/256)
data8 0x3FD52DD06347D4F6    //log(1/frcpa(1+ 100/256)
data8 0x3FD55A6D3C7B8A8A    //log(1/frcpa(1+ 101/256)
data8 0x3FD5925D2B112A59    //log(1/frcpa(1+ 102/256)
data8 0x3FD5BF406B543DB2    //log(1/frcpa(1+ 103/256)
data8 0x3FD5EC433D5C35AE    //log(1/frcpa(1+ 104/256)
data8 0x3FD61965CDB02C1F    //log(1/frcpa(1+ 105/256)
data8 0x3FD646A84935B2A2    //log(1/frcpa(1+ 106/256)
data8 0x3FD6740ADD31DE94    //log(1/frcpa(1+ 107/256)
data8 0x3FD6A18DB74A58C5    //log(1/frcpa(1+ 108/256)
data8 0x3FD6CF31058670EC    //log(1/frcpa(1+ 109/256)
data8 0x3FD6F180E852F0BA    //log(1/frcpa(1+ 110/256)
data8 0x3FD71F5D71B894F0    //log(1/frcpa(1+ 111/256)
data8 0x3FD74D5AEFD66D5C    //log(1/frcpa(1+ 112/256)
data8 0x3FD77B79922BD37E    //log(1/frcpa(1+ 113/256)
data8 0x3FD7A9B9889F19E2    //log(1/frcpa(1+ 114/256)
data8 0x3FD7D81B037EB6A6    //log(1/frcpa(1+ 115/256)
data8 0x3FD8069E33827231    //log(1/frcpa(1+ 116/256)
data8 0x3FD82996D3EF8BCB    //log(1/frcpa(1+ 117/256)
data8 0x3FD85855776DCBFB    //log(1/frcpa(1+ 118/256)
data8 0x3FD8873658327CCF    //log(1/frcpa(1+ 119/256)
data8 0x3FD8AA75973AB8CF    //log(1/frcpa(1+ 120/256)
data8 0x3FD8D992DC8824E5    //log(1/frcpa(1+ 121/256)
data8 0x3FD908D2EA7D9512    //log(1/frcpa(1+ 122/256)
data8 0x3FD92C59E79C0E56    //log(1/frcpa(1+ 123/256)
data8 0x3FD95BD750EE3ED3    //log(1/frcpa(1+ 124/256)
data8 0x3FD98B7811A3EE5B    //log(1/frcpa(1+ 125/256)
data8 0x3FD9AF47F33D406C    //log(1/frcpa(1+ 126/256)
data8 0x3FD9DF270C1914A8    //log(1/frcpa(1+ 127/256)
data8 0x3FDA0325ED14FDA4    //log(1/frcpa(1+ 128/256)
data8 0x3FDA33440224FA79    //log(1/frcpa(1+ 129/256)
data8 0x3FDA57725E80C383    //log(1/frcpa(1+ 130/256)
data8 0x3FDA87D0165DD199    //log(1/frcpa(1+ 131/256)
data8 0x3FDAAC2E6C03F896    //log(1/frcpa(1+ 132/256)
data8 0x3FDADCCC6FDF6A81    //log(1/frcpa(1+ 133/256)
data8 0x3FDB015B3EB1E790    //log(1/frcpa(1+ 134/256)
data8 0x3FDB323A3A635948    //log(1/frcpa(1+ 135/256)
data8 0x3FDB56FA04462909    //log(1/frcpa(1+ 136/256)
data8 0x3FDB881AA659BC93    //log(1/frcpa(1+ 137/256)
data8 0x3FDBAD0BEF3DB165    //log(1/frcpa(1+ 138/256)
data8 0x3FDBD21297781C2F    //log(1/frcpa(1+ 139/256)
data8 0x3FDC039236F08819    //log(1/frcpa(1+ 140/256)
data8 0x3FDC28CB1E4D32FD    //log(1/frcpa(1+ 141/256)
data8 0x3FDC4E19B84723C2    //log(1/frcpa(1+ 142/256)
data8 0x3FDC7FF9C74554C9    //log(1/frcpa(1+ 143/256)
data8 0x3FDCA57B64E9DB05    //log(1/frcpa(1+ 144/256)
data8 0x3FDCCB130A5CEBB0    //log(1/frcpa(1+ 145/256)
data8 0x3FDCF0C0D18F326F    //log(1/frcpa(1+ 146/256)
data8 0x3FDD232075B5A201    //log(1/frcpa(1+ 147/256)
data8 0x3FDD490246DEFA6B    //log(1/frcpa(1+ 148/256)
data8 0x3FDD6EFA918D25CD    //log(1/frcpa(1+ 149/256)
data8 0x3FDD9509707AE52F    //log(1/frcpa(1+ 150/256)
data8 0x3FDDBB2EFE92C554    //log(1/frcpa(1+ 151/256)
data8 0x3FDDEE2F3445E4AF    //log(1/frcpa(1+ 152/256)
data8 0x3FDE148A1A2726CE    //log(1/frcpa(1+ 153/256)
data8 0x3FDE3AFC0A49FF40    //log(1/frcpa(1+ 154/256)
data8 0x3FDE6185206D516E    //log(1/frcpa(1+ 155/256)
data8 0x3FDE882578823D52    //log(1/frcpa(1+ 156/256)
data8 0x3FDEAEDD2EAC990C    //log(1/frcpa(1+ 157/256)
data8 0x3FDED5AC5F436BE3    //log(1/frcpa(1+ 158/256)
data8 0x3FDEFC9326D16AB9    //log(1/frcpa(1+ 159/256)
data8 0x3FDF2391A2157600    //log(1/frcpa(1+ 160/256)
data8 0x3FDF4AA7EE03192D    //log(1/frcpa(1+ 161/256)
data8 0x3FDF71D627C30BB0    //log(1/frcpa(1+ 162/256)
data8 0x3FDF991C6CB3B379    //log(1/frcpa(1+ 163/256)
data8 0x3FDFC07ADA69A910    //log(1/frcpa(1+ 164/256)
data8 0x3FDFE7F18EB03D3E    //log(1/frcpa(1+ 165/256)
data8 0x3FE007C053C5002E    //log(1/frcpa(1+ 166/256)
data8 0x3FE01B942198A5A1    //log(1/frcpa(1+ 167/256)
data8 0x3FE02F74400C64EB    //log(1/frcpa(1+ 168/256)
data8 0x3FE04360BE7603AD    //log(1/frcpa(1+ 169/256)
data8 0x3FE05759AC47FE34    //log(1/frcpa(1+ 170/256)
data8 0x3FE06B5F1911CF52    //log(1/frcpa(1+ 171/256)
data8 0x3FE078BF0533C568    //log(1/frcpa(1+ 172/256)
data8 0x3FE08CD9687E7B0E    //log(1/frcpa(1+ 173/256)
data8 0x3FE0A10074CF9019    //log(1/frcpa(1+ 174/256)
data8 0x3FE0B5343A234477    //log(1/frcpa(1+ 175/256)
data8 0x3FE0C974C89431CE    //log(1/frcpa(1+ 176/256)
data8 0x3FE0DDC2305B9886    //log(1/frcpa(1+ 177/256)
data8 0x3FE0EB524BAFC918    //log(1/frcpa(1+ 178/256)
data8 0x3FE0FFB54213A476    //log(1/frcpa(1+ 179/256)
data8 0x3FE114253DA97D9F    //log(1/frcpa(1+ 180/256)
data8 0x3FE128A24F1D9AFF    //log(1/frcpa(1+ 181/256)
data8 0x3FE1365252BF0865    //log(1/frcpa(1+ 182/256)
data8 0x3FE14AE558B4A92D    //log(1/frcpa(1+ 183/256)
data8 0x3FE15F85A19C765B    //log(1/frcpa(1+ 184/256)
data8 0x3FE16D4D38C119FA    //log(1/frcpa(1+ 185/256)
data8 0x3FE18203C20DD133    //log(1/frcpa(1+ 186/256)
data8 0x3FE196C7BC4B1F3B    //log(1/frcpa(1+ 187/256)
data8 0x3FE1A4A738B7A33C    //log(1/frcpa(1+ 188/256)
data8 0x3FE1B981C0C9653D    //log(1/frcpa(1+ 189/256)
data8 0x3FE1CE69E8BB106B    //log(1/frcpa(1+ 190/256)
data8 0x3FE1DC619DE06944    //log(1/frcpa(1+ 191/256)
data8 0x3FE1F160A2AD0DA4    //log(1/frcpa(1+ 192/256)
data8 0x3FE2066D7740737E    //log(1/frcpa(1+ 193/256)
data8 0x3FE2147DBA47A394    //log(1/frcpa(1+ 194/256)
data8 0x3FE229A1BC5EBAC3    //log(1/frcpa(1+ 195/256)
data8 0x3FE237C1841A502E    //log(1/frcpa(1+ 196/256)
data8 0x3FE24CFCE6F80D9A    //log(1/frcpa(1+ 197/256)
data8 0x3FE25B2C55CD5762    //log(1/frcpa(1+ 198/256)
data8 0x3FE2707F4D5F7C41    //log(1/frcpa(1+ 199/256)
data8 0x3FE285E0842CA384    //log(1/frcpa(1+ 200/256)
data8 0x3FE294294708B773    //log(1/frcpa(1+ 201/256)
data8 0x3FE2A9A2670AFF0C    //log(1/frcpa(1+ 202/256)
data8 0x3FE2B7FB2C8D1CC1    //log(1/frcpa(1+ 203/256)
data8 0x3FE2C65A6395F5F5    //log(1/frcpa(1+ 204/256)
data8 0x3FE2DBF557B0DF43    //log(1/frcpa(1+ 205/256)
data8 0x3FE2EA64C3F97655    //log(1/frcpa(1+ 206/256)
data8 0x3FE3001823684D73    //log(1/frcpa(1+ 207/256)
data8 0x3FE30E97E9A8B5CD    //log(1/frcpa(1+ 208/256)
data8 0x3FE32463EBDD34EA    //log(1/frcpa(1+ 209/256)
data8 0x3FE332F4314AD796    //log(1/frcpa(1+ 210/256)
data8 0x3FE348D90E7464D0    //log(1/frcpa(1+ 211/256)
data8 0x3FE35779F8C43D6E    //log(1/frcpa(1+ 212/256)
data8 0x3FE36621961A6A99    //log(1/frcpa(1+ 213/256)
data8 0x3FE37C299F3C366A    //log(1/frcpa(1+ 214/256)
data8 0x3FE38AE2171976E7    //log(1/frcpa(1+ 215/256)
data8 0x3FE399A157A603E7    //log(1/frcpa(1+ 216/256)
data8 0x3FE3AFCCFE77B9D1    //log(1/frcpa(1+ 217/256)
data8 0x3FE3BE9D503533B5    //log(1/frcpa(1+ 218/256)
data8 0x3FE3CD7480B4A8A3    //log(1/frcpa(1+ 219/256)
data8 0x3FE3E3C43918F76C    //log(1/frcpa(1+ 220/256)
data8 0x3FE3F2ACB27ED6C7    //log(1/frcpa(1+ 221/256)
data8 0x3FE4019C2125CA93    //log(1/frcpa(1+ 222/256)
data8 0x3FE4181061389722    //log(1/frcpa(1+ 223/256)
data8 0x3FE42711518DF545    //log(1/frcpa(1+ 224/256)
data8 0x3FE436194E12B6BF    //log(1/frcpa(1+ 225/256)
data8 0x3FE445285D68EA69    //log(1/frcpa(1+ 226/256)
data8 0x3FE45BCC464C893A    //log(1/frcpa(1+ 227/256)
data8 0x3FE46AED21F117FC    //log(1/frcpa(1+ 228/256)
data8 0x3FE47A1527E8A2D3    //log(1/frcpa(1+ 229/256)
data8 0x3FE489445EFFFCCC    //log(1/frcpa(1+ 230/256)
data8 0x3FE4A018BCB69835    //log(1/frcpa(1+ 231/256)
data8 0x3FE4AF5A0C9D65D7    //log(1/frcpa(1+ 232/256)
data8 0x3FE4BEA2A5BDBE87    //log(1/frcpa(1+ 233/256)
data8 0x3FE4CDF28F10AC46    //log(1/frcpa(1+ 234/256)
data8 0x3FE4DD49CF994058    //log(1/frcpa(1+ 235/256)
data8 0x3FE4ECA86E64A684    //log(1/frcpa(1+ 236/256)
data8 0x3FE503C43CD8EB68    //log(1/frcpa(1+ 237/256)
data8 0x3FE513356667FC57    //log(1/frcpa(1+ 238/256)
data8 0x3FE522AE0738A3D8    //log(1/frcpa(1+ 239/256)
data8 0x3FE5322E26867857    //log(1/frcpa(1+ 240/256)
data8 0x3FE541B5CB979809    //log(1/frcpa(1+ 241/256)
data8 0x3FE55144FDBCBD62    //log(1/frcpa(1+ 242/256)
data8 0x3FE560DBC45153C7    //log(1/frcpa(1+ 243/256)
data8 0x3FE5707A26BB8C66    //log(1/frcpa(1+ 244/256)
data8 0x3FE587F60ED5B900    //log(1/frcpa(1+ 245/256)
data8 0x3FE597A7977C8F31    //log(1/frcpa(1+ 246/256)
data8 0x3FE5A760D634BB8B    //log(1/frcpa(1+ 247/256)
data8 0x3FE5B721D295F10F    //log(1/frcpa(1+ 248/256)
data8 0x3FE5C6EA94431EF9    //log(1/frcpa(1+ 249/256)
data8 0x3FE5D6BB22EA86F6    //log(1/frcpa(1+ 250/256)
data8 0x3FE5E6938645D390    //log(1/frcpa(1+ 251/256)
data8 0x3FE5F673C61A2ED2    //log(1/frcpa(1+ 252/256)
data8 0x3FE6065BEA385926    //log(1/frcpa(1+ 253/256)
data8 0x3FE6164BFA7CC06B    //log(1/frcpa(1+ 254/256)
data8 0x3FE62643FECF9743    //log(1/frcpa(1+ 255/256)

.global logf
.global log10f

.text
.proc  log10f
.align 32
log10f:

{     .mfi
     alloc      r32           = ar.pfs,1,11,4,0
     frcpa.s1  log_B,p15      =    f1,f8
     addl      LOG_AD_COEFF   =    @ltoff(log_coeff_table),gp
}
{     .mfi
     mov       LOG_mask            =    0x1FFFF
     fnorm.s1  log_x_norm          =    f8
     addl      LOG_AD_CONSTANTS    =    @ltoff(log_constants_table),gp;;
}

{     .mfi
     mov            LOG_FFF7  =    0xFFF7
     fclass.m.unc   p8,p0     =    f8,0x7	// @zero
     shr            LOG_bias  =    LOG_mask,1
}
{     .mfi
     nop.m                 999
     fms.s1    log_s          =    f1,f8,f1
     cmp.eq    p6,p7          =    r0,r0 ;; 
}

{     .mfi
     ld8       LOG_AD_COEFF   =    [LOG_AD_COEFF]
     nop.f                      999
     nop.i                      999
}
{     .mfb
     ld8       LOG_AD_CONSTANTS    =    [LOG_AD_CONSTANTS]
     nop.f                           999
     br.sptk   LOGF_LOG10F_COMMON
}


.endp log10f


.text
.proc  logf
.align 32
logf:


{     .mfi 
     alloc      r32           = ar.pfs,1,11,4,0
     frcpa.s1  log_B,p15      =    f1,f8
     addl      LOG_AD_COEFF   =    @ltoff(log_coeff_table),gp
} 
{     .mfi 
     mov       LOG_mask            =    0x1FFFF
     fnorm.s1  log_x_norm          =    f8
     addl      LOG_AD_CONSTANTS    =    @ltoff(log_constants_table),gp;;
}

 
{     .mfi 
     mov            LOG_FFF7  =    0xFFF7
     fclass.m.unc   p8,p0     =    f8,0x7	// @zero
     shr            LOG_bias  =    LOG_mask,1
} 
{     .mfi 
     nop.m                 999
     fms.s1    log_s          =    f1,f8,f1
     cmp.eq    p7,p6          =    r0,r0 ;; 
}

 

{     .mfi 
     ld8       LOG_AD_COEFF   =    [LOG_AD_COEFF]
     nop.f                      999
     nop.i                      999
} 
{     .mfi 
     ld8       LOG_AD_CONSTANTS    =    [LOG_AD_CONSTANTS]
     nop.f                           999
     nop.i                           999;;
}

 
LOGF_LOG10F_COMMON:

{     .mfi 
     ldfpd     log_coeff_p3,log_coeff_p2     =    [LOG_AD_COEFF],16
     fms.s1    log_r                         =    f8,log_B,f1
     nop.i                                     999
} 
{     .mfb 
     ldfpd     log_coeff_p1,log_const_log2   =    [LOG_AD_CONSTANTS],16
     nop.f                                     999
(p8) br.cond.spnt   LOG_NAN_INF_NEG_ZERO       ;;
}

 
{     .mfi 
     ldfpd     log_threshhold, log_inv_ln10 =    [LOG_AD_CONSTANTS],16
     fma.s1    log_ssq        =    log_s,log_s,f0
     nop.i                      999;;
} 
 
{     .mfi 
     getf.exp  LOG_x_sexp     =    log_x_norm
     fmerge.s  log_abs_s      =    f1,log_s
     nop.i                      999;;
} 
 
{     .mfi 
     getf.sig  LOG_x_ind =    log_x_norm
     nop.f                 999
     nop.i                 999;;
} 
 
{     .mfi 
     and       LOG_x_n   =    LOG_x_sexp,LOG_mask
     fma.s1    log_rsq   =    log_r,log_r,f0
     cmp.ge    p10,p0    =    LOG_x_sexp,LOG_mask;;
} 
 
{     .mfi 
     sub       LOG_x_n   =    LOG_x_n,LOG_bias
     nop.f                 999
     shl       LOG_x_ind =    LOG_x_ind,1;;
} 
 
{     .mfi 
     setf.sig  log_n     =    LOG_x_n
     nop.f                 999
     shr.u     LOG_x_ind =    LOG_x_ind,56;;
} 
 
{     .mfi 
     nop.m                 999
     nop.f                 999
     shl       LOG_x_ind =    LOG_x_ind,3;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    log_poly_q1    =    log_s,log_coeff_p3,log_coeff_p2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    log_poly_p1    =    log_r,log_coeff_p3,log_coeff_p2
     nop.i                      999;;
}

 
{     .mfb 
          add            LOG_AD_CONSTANTS         =    LOG_AD_CONSTANTS,LOG_x_ind
          fcmp.lt.s1     p11,p12                  =    log_abs_s,log_threshhold
(p10)     br.cond.spnt   LOG_NAN_INF_NEG_ZERO       ;;
} 
 
{     .mfi 
     ldfd      log_T     =    [LOG_AD_CONSTANTS]
     nop.f                 999
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    log_poly_q2    =    log_s,log_poly_q1,log_coeff_p1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    log_poly_p2    =    log_r,log_poly_p1,log_coeff_p1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fcvt.xf   log_n     =    log_n
     nop.i                 999;;
} 
 
{     .mfi 
          nop.m            999
(p11)     fma.s     f8   =    log_ssq,log_poly_q2,log_s
          nop.i            999
} 
{     .mfi 
     nop.m                      999
     fma.s1    log_poly_p3    =    log_rsq,log_poly_p2,log_r
     nop.i                      999;;
}

{     .mfi 
      nop.m 999
(p11) fma.s1       log10_f8 = log_ssq,log_poly_q2,log_s
      nop.i 999
}
;;



 
{     .mfi 
     nop.m                 999
     fma.s1    log_T     =    log_n,log_const_log2,log_T
     nop.i                 999;;
} 
 
{     .mfb 
          nop.m            999
(p12)     fma.s     f8   =    log_T,f1,log_poly_p3
          nop.b 999
} 


{     .mfb 
          nop.m 999
(p12)     fma.s1    log10_f8   =    log_T,f1,log_poly_p3
          nop.b 999
}
;;

{     .mfb 
          nop.m 999
(p6)      fma.s     f8   =    log_inv_ln10, log10_f8, f0
          br.ret.sptk    b0   
}
;;


 
LOG_NAN_INF_NEG_ZERO:

//   Log[inf]      = inf

//   Log[0]        = -infinity,       call error support, tag 4
//   Log[-0]       = -infinity,       call error support, tag 4

//   Log[-nonzero] = qnan indefinite, call error support, tag 5
//   Log[-inf]     = qnan indefinite, call error support, tag 5

//   Log[0]        = -infinity,       call error support, tag 10
//   Log[-0]       = -infinity,       call error support, tag 10

//   Log[-nonzero] = qnan indefinite, call error support, tag 11
//   Log[-inf]     = qnan indefinite, call error support, tag 11

//   Log[Nan]      = quite NaN

///////////////////////
// if x is Nan, leave immediately
      fclass.m.unc     p8,p0          = f8,0xc3	// @snan | @qnan
;;
(p8)  fnorm            f8             = f8
;;
(p8)  br.ret.spnt      b0


///////////////////////
// if x is +infinity, leave immediately
      fclass.m.unc     p8,p0          = f8,0x21	// @inf | @pos
;;
(p8)  frcpa.s1         f8,p15         = f1,f0
;;
(p8)  br.ret.spnt      b0


// else if x is zero, set tag to 4 (logf) or 10 (log10f) and call error support
// Log[+-0] = -infinity, with dbz set. Range error

      fclass.m.unc     p8,p9          = f8,0x7	// @zero
;;
(p8)  frcpa            f8,p15         = f1,f0
;;

.pred.rel "mutex",p7,p6
(p8)  fmerge.ns        f8             = f8,f8
(p7)  mov              LOG_tag        = 4
(p6)  mov              LOG_tag        = 10

(p8)  br.cond.spnt     __libm_error_region

// else if x is -non-zero, set tag to 5 and call error support
// Log[-norm, -unorm, -inf] = qnan indefinite, invalid set, domain error

(p9)  fclass.m.unc     p10, p0         = f8,0x3a	// @inf | @norm | @unorm | @neg
;;
(p10)  frcpa.s0        f8,p15         = f0,f0
(p7)  mov              LOG_tag        = 5
(p6)  mov              LOG_tag        = 11

      br.cond.spnt     __libm_error_region

.endp logf




///////////////////////////////////////////////////////////////////
// Error handling region
///////////////////////////////////////////////////////////////////



// Stack operations when calling error support.
//       (1)                   (2)
//   sp   -> +                 psp -> +
//           |                        |
//           |                        | <- GR_Y
//           |                        |
//           | <-GR_Y             Y2->|
//           |                        |
//           |                        | <- GR_X
//           |                        |
//  sp-64 -> +                 sp ->  +
//    save ar.pfs                 save b0
//    save gp



//      (3) (call)              (4)
//   psp -> +                   sp -> +
//          |                         |
//     R3 ->| <- GR_RESULT            | -> f8
//          |                         |
//     Y2 ->| <- GR_Y                 |
//          |                         |
//     X1 ->|                         |
//          |                         |
//   sp ->  +                         +
//                                 restore gp
//                                 restore ar.pfs

.proc __libm_error_region
__libm_error_region:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = f1,16          // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp             // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                      // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = log_x_norm           // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
        nop.b 0
}
{ .mib
        stfs [GR_Parameter_Y] = f8                    // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;


{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;

{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sincos.s ===
.file "sincos.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial revision 
// 4/02/00  Unwind support added.
// 6/16/00  Updated tables to enforce symmetry
// 8/31/00  Saved 2 cycles in main path, and 9 in other paths.
// 9/20/00  The updated tables regressed to an old version, so reinstated them

// API
//==============================================================
// double sin( double x);
// double cos( double x);
//
// Overview of operation
//==============================================================
//
// Step 1
// ======
// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k
//    divide x by pi/2^k. 
//    Multiply by 2^k/pi.  
//    nfloat = Round result to integer (round-to-nearest) 
// 
// r = x -  nfloat * pi/2^k 
//    Do this as (x -  nfloat * HIGH(pi/2^k)) - nfloat * LOW(pi/2^k) for increased accuracy. 
//    pi/2^k is stored as two numbers that when added make pi/2^k. 
//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k) 
// 
// x = (nfloat * pi/2^k) + r 
//    r is small enough that we can use a polynomial approximation 
//    and is referred to as the reduced argument.  
// 
// Step 3
// ======
// Take the unreduced part and remove the multiples of 2pi.  
// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
// 
//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1) 
//    N * 2^(k+1)
//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
//    nfloat * pi/2^k = N2pi + M * pi/2^k
// 
// 
// Sin(x) = Sin((nfloat * pi/2^k) + r)
//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
// 
//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k) 
//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
//                               = Sin(Mpi/2^k)
// 
//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k) 
//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
//                               = Cos(Mpi/2^k)
// 
// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
// 
// 
// Step 4
// ======
// 0 <= M < 2^(k+1)
// There are 2^(k+1) Sin entries in a table.
// There are 2^(k+1) Cos entries in a table.
// 
// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
// 
// 
// Step 5
// ======
// Calculate Cos(r) and Sin(r) by polynomial approximation.
// 
// Cos(r) = 1 + r^2 q1  + r^4 q2 + r^6 q3 + ... = Series for Cos
// Sin(r) = r + r^3 p1  + r^5 p2 + r^7 p3 + ... = Series for Sin
//
// and the coefficients q1, q2, ... and p1, p2, ... are stored in a table
// 
// 
// Calculate
// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
// 
// as follows
// 
//    Sm = Sin(Mpi/2^k) and Cm = Cos(Mpi/2^k)
//    rsq = r*r
// 
// 
//    P = p1 + r^2p2 + r^4p3 + r^6p4
//    Q = q1 + r^2q2 + r^4q3 + r^6q4
// 
//       rcub = r * rsq 
//       Sin(r) = r + rcub * P
//              = r + r^3p1  + r^5p2 + r^7p3 + r^9p4 + ... = Sin(r)
// 
//            The coefficients are not exactly these values, but almost.
// 
//            p1 = -1/6  = -1/3!
//            p2 = 1/120 =  1/5!
//            p3 = -1/5040 = -1/7!
//            p4 = 1/362889 = 1/9!
// 
//       P =  r + rcub * P
// 
//    Answer = Sm Cos(r) + Cm P 
// 
//       Cos(r) = 1 + rsq Q
//       Cos(r) = 1 + r^2 Q
//       Cos(r) = 1 + r^2 (q1 + r^2q2 + r^4q3 + r^6q4)
//       Cos(r) = 1 + r^2q1 + r^4q2 + r^6q3 + r^8q4 + ...
// 
//       Sm Cos(r) = Sm(1 + rsq Q)
//       Sm Cos(r) = Sm + Sm rsq Q
//       Sm Cos(r) = Sm + s_rsq Q
//       Q         = Sm + s_rsq Q 
// 
// Then,
// 
//    Answer = Q + Cm P


// Registers used
//==============================================================
// general input registers: 
// r32 -> r45 

// predicate registers used:  
// p6 -> p13

// floating-point registers used:  31
// f9 -> f15
// f32 -> f54

// Assembly macros
//==============================================================
sind_W                       = f10
sind_int_Nfloat              = f11
sind_Nfloat                  = f12

sind_r                       = f13
sind_rsq                     = f14
sind_rcub                    = f15

sind_Inv_Pi_by_16            = f32
sind_Pi_by_16_hi             = f33
sind_Pi_by_16_lo             = f34

sind_Inv_Pi_by_64            = f35
sind_Pi_by_64_hi             = f36
sind_Pi_by_64_lo             = f37

sind_Sm                      = f38
sind_Cm                      = f39

sind_P1                      = f40
sind_Q1                      = f41
sind_P2                      = f42
sind_Q2                      = f43
sind_P3                      = f44
sind_Q3                      = f45
sind_P4                      = f46
sind_Q4                      = f47

sind_P_temp1                 = f48
sind_P_temp2                 = f49

sind_Q_temp1                 = f50
sind_Q_temp2                 = f51

sind_P                       = f52
sind_Q                       = f53

sind_srsq                    = f54

/////////////////////////////////////////////////////////////

sind_r_signexp               = r36
sind_AD_beta_table           = r37
sind_r_sincos                = r38

sind_r_exp                   = r39
sind_r_17_ones               = r40

GR_SAVE_PFS                  = r41
GR_SAVE_B0                   = r42
GR_SAVE_GP                   = r43


.data

.align 16
double_sind_pi:
   data8 0xA2F9836E4E44152A, 0x00004001 // 16/pi
//         c90fdaa22168c234 
   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 hi
//         c4c6628b80dc1cd1  29024e088a
   data8 0xC4C6628B80DC1CD1, 0x00003FBC

double_sind_pq_k4:
   data8 0x3EC71C963717C63A // P4
   data8 0x3EF9FFBA8F191AE6 // Q4
   data8 0xBF2A01A00F4E11A8 // P3
   data8 0xBF56C16C05AC77BF // Q3
   data8 0x3F8111111110F167 // P2
   data8 0x3FA555555554DD45 // Q2
   data8 0xBFC5555555555555 // P1
   data8 0xBFDFFFFFFFFFFFFC // Q1


double_sin_cos_beta_k4:

data8 0x0000000000000000 , 0x00000000 // sin( 0 pi/16)  S0
data8 0x8000000000000000 , 0x00003fff // cos( 0 pi/16)  C0

data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin( 1 pi/16)  S1
data8 0xfb14be7fbae58157 , 0x00003ffe // cos( 1 pi/16)  C1

data8 0xc3ef1535754b168e , 0x00003ffd // sin( 2 pi/16)  S2
data8 0xec835e79946a3146 , 0x00003ffe // cos( 2 pi/16)  C2

data8 0x8e39d9cd73464364 , 0x00003ffe // sin( 3 pi/16)  S3
data8 0xd4db3148750d181a , 0x00003ffe // cos( 3 pi/16)  C3

data8 0xb504f333f9de6484 , 0x00003ffe // sin( 4 pi/16)  S4
data8 0xb504f333f9de6484 , 0x00003ffe // cos( 4 pi/16)  C4


data8 0xd4db3148750d181a , 0x00003ffe // sin( 5 pi/16)  C3
data8 0x8e39d9cd73464364 , 0x00003ffe // cos( 5 pi/16)  S3

data8 0xec835e79946a3146 , 0x00003ffe // sin( 6 pi/16)  C2
data8 0xc3ef1535754b168e , 0x00003ffd // cos( 6 pi/16)  S2

data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 7 pi/16)  C1
data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos( 7 pi/16)  S1

data8 0x8000000000000000 , 0x00003fff // sin( 8 pi/16)  C0
data8 0x0000000000000000 , 0x00000000 // cos( 8 pi/16)  S0


data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 9 pi/16)  C1
data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos( 9 pi/16)  -S1

data8 0xec835e79946a3146 , 0x00003ffe // sin(10 pi/16)  C2
data8 0xc3ef1535754b168c , 0x0000bffd // cos(10 pi/16)  -S2

data8 0xd4db3148750d181a , 0x00003ffe // sin(11 pi/16)  C3
data8 0x8e39d9cd73464364 , 0x0000bffe // cos(11 pi/16)  -S3

data8 0xb504f333f9de6484 , 0x00003ffe // sin(12 pi/16)  S4
data8 0xb504f333f9de6484 , 0x0000bffe // cos(12 pi/16)  -S4


data8 0x8e39d9cd73464364 , 0x00003ffe // sin(13 pi/16) S3
data8 0xd4db3148750d181a , 0x0000bffe // cos(13 pi/16) -C3

data8 0xc3ef1535754b168e , 0x00003ffd // sin(14 pi/16) S2
data8 0xec835e79946a3146 , 0x0000bffe // cos(14 pi/16) -C2

data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin(15 pi/16) S1
data8 0xfb14be7fbae58157 , 0x0000bffe // cos(15 pi/16) -C1

data8 0x0000000000000000 , 0x00000000 // sin(16 pi/16) S0
data8 0x8000000000000000 , 0x0000bfff // cos(16 pi/16) -C0

data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(17 pi/16) -S1
data8 0xfb14be7fbae58157 , 0x0000bffe // cos(17 pi/16) -C1

data8 0xc3ef1535754b168e , 0x0000bffd // sin(18 pi/16) -S2
data8 0xec835e79946a3146 , 0x0000bffe // cos(18 pi/16) -C2

data8 0x8e39d9cd73464364 , 0x0000bffe // sin(19 pi/16) -S3
data8 0xd4db3148750d181a , 0x0000bffe // cos(19 pi/16) -C3

data8 0xb504f333f9de6484 , 0x0000bffe // sin(20 pi/16) -S4
data8 0xb504f333f9de6484 , 0x0000bffe // cos(20 pi/16) -S4


data8 0xd4db3148750d181a , 0x0000bffe // sin(21 pi/16) -C3
data8 0x8e39d9cd73464364 , 0x0000bffe // cos(21 pi/16) -S3

data8 0xec835e79946a3146 , 0x0000bffe // sin(22 pi/16) -C2
data8 0xc3ef1535754b168e , 0x0000bffd // cos(22 pi/16) -S2

data8 0xfb14be7fbae58157 , 0x0000bffe // sin(23 pi/16) -C1
data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos(23 pi/16) -S1

data8 0x8000000000000000 , 0x0000bfff // sin(24 pi/16) -C0
data8 0x0000000000000000 , 0x00000000 // cos(24 pi/16) S0


data8 0xfb14be7fbae58157 , 0x0000bffe // sin(25 pi/16) -C1
data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos(25 pi/16) S1

data8 0xec835e79946a3146 , 0x0000bffe // sin(26 pi/16) -C2
data8 0xc3ef1535754b168e , 0x00003ffd // cos(26 pi/16) S2

data8 0xd4db3148750d181a , 0x0000bffe // sin(27 pi/16) -C3
data8 0x8e39d9cd73464364 , 0x00003ffe // cos(27 pi/16) S3

data8 0xb504f333f9de6484 , 0x0000bffe // sin(28 pi/16) -S4
data8 0xb504f333f9de6484 , 0x00003ffe // cos(28 pi/16) S4


data8 0x8e39d9cd73464364 , 0x0000bffe // sin(29 pi/16) -S3
data8 0xd4db3148750d181a , 0x00003ffe // cos(29 pi/16) C3

data8 0xc3ef1535754b168e , 0x0000bffd // sin(30 pi/16) -S2
data8 0xec835e79946a3146 , 0x00003ffe // cos(30 pi/16) C2

data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(31 pi/16) -S1
data8 0xfb14be7fbae58157 , 0x00003ffe // cos(31 pi/16) C1

data8 0x0000000000000000 , 0x00000000 // sin(32 pi/16) S0
data8 0x8000000000000000 , 0x00003fff // cos(32 pi/16) C0
   
.align 32
.global sin#
.global cos#

////////////////////////////////////////////////////////
// There are two entry points: sin and cos 


// If from sin, p8 is true
// If from cos, p9 is true

.section .text
.proc  sin#
.align 32

sin: 

// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mfi
      alloc          r32=ar.pfs,1,13,0,0               
(p0)  fnorm     f8  = f8   
(p0)  cmp.eq.unc     p8,p9         = r0, r0            
}
{ .mib
(p0)  addl           r33   = @ltoff(double_sind_pi), gp
(p0)  mov            sind_r_sincos = 0x0               
(p0)  br.sptk        SIND_SINCOS ;;                       
}

.endp sin    


.section .text
.proc  cos#
.align 32
cos: 

// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms
{ .mfi
      alloc          r32=ar.pfs,1,13,0,0               
(p0)  fnorm     f8  = f8   
(p0)  cmp.eq.unc     p9,p8         = r0, r0            
}
{ .mib
(p0)  addl           r33   = @ltoff(double_sind_pi), gp
(p0)  mov            sind_r_sincos = 0x8               
(p0)  br.sptk        SIND_SINCOS ;;
}



////////////////////////////////////////////////////////
// All entry points end up here.
// If from sin, sind_r_sincos is 0 and p8 is true
// If from cos, sind_r_sincos is 8 = 2^(k-1) and p9 is true
// We add sind_r_sincos to N

SIND_SINCOS:

{ .mmi
      ld8 r33 = [r33]
(p0)  addl           r34   = @ltoff(double_sind_pq_k4), gp
(p0)  mov       sind_r_17_ones    = 0x1ffff
}
;;

{ .mfi
      ld8 r34 = [r34]
      nop.f 999
      nop.i 999 ;;
}

// 0x10009 is register_bias + 10.
// So if f8 > 2^10 = Gamma, go to DBX
{ .mii
(p0)  ldfe      sind_Inv_Pi_by_16 = [r33],16          
(p0)  mov       r35 = 0x10009
      nop.i 999 ;;
}

// Start loading P, Q coefficients
{ .mmi
(p0)  ldfpd      sind_P4,sind_Q4 = [r34],16                 
(p0)  addl           sind_AD_beta_table   = @ltoff(double_sin_cos_beta_k4), gp
      nop.i 999 ;;
}

// SIN(0)
{ .mfi
      ld8 sind_AD_beta_table = [sind_AD_beta_table]
(p8)  fclass.m.unc  p6,p0 = f8, 0x07           
      nop.i 999 ;;
}


// COS(0)
{ .mfi
(p0)  getf.exp  sind_r_signexp    = f8                
(p9)  fclass.m.unc  p7,p0 = f8, 0x07           
      nop.i 999
}
{ .mfi
(p0)  ldfe      sind_Pi_by_16_hi  = [r33],16          
      nop.f 999
      nop.i 999 ;;
}

{ .mfb
(p0)  ldfe      sind_Pi_by_16_lo  = [r33],16          
      nop.f 999
(p6)  br.ret.spnt    b0 ;;
}

{ .mfb
(p0)  and       sind_r_exp = sind_r_17_ones, sind_r_signexp
(p7)  fmerge.s      f8 = f1,f1                
(p7)  br.ret.spnt    b0 ;;
}

// p10 is true if we must call DBX SIN
// p10 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)

{ .mib
(p0)  ldfpd      sind_P3,sind_Q3 = [r34],16                 
(p0)  cmp.ge.unc  p10,p0 = sind_r_exp,r35 
(p10) br.cond.spnt   SIND_DBX ;;
}

{ .mfi
(p0)  ldfpd      sind_P2,sind_Q2 = [r34],16                 
      nop.f 999
      nop.i 999 ;;
}

// sind_W          = x * sind_Inv_Pi_by_16
{ .mfi
(p0)  ldfpd      sind_P1,sind_Q1 = [r34]
(p0)  fma.s1    sind_W   = f8,          sind_Inv_Pi_by_16, f0     
      nop.i 999 ;;
}


// sind_int_Nfloat = Round_Int_Nearest(sind_W)
// sind_r          = -sind_Nfloat * sind_Pi_by_16_hi + x
// sind_r          = sind_r -sind_Nfloat * sind_Pi_by_16_lo 
{ .mfi
      nop.m 999
(p0)  fcvt.fx.s1  sind_int_Nfloat = sind_W                             
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf     sind_Nfloat = sind_int_Nfloat                        
      nop.i 999 ;;
}

// get N = (int)sind_int_Nfloat 
// Add 2^(k-1) (which is in sind_r_sincos) to N 

{ .mfi
(p0)  getf.sig  r43 = sind_int_Nfloat
      nop.f 999
      nop.i 999 ;;
}

{ .mmi
(p0)  add       r43 = r43, sind_r_sincos ;;
(p0)  and       r44 = 0x1f,r43              
      nop.i 999 ;;
}

// Get M (least k+1 bits of N)
// Add 32*M to address of sin_cos_beta table
{ .mfi
      nop.m 999
(p0)  fnma.s1  sind_r      = sind_Nfloat, sind_Pi_by_16_hi,  f8     
(p0)  shl       r44 = r44,5 ;;
}

{ .mmi
(p0)  add       r45 = r44, sind_AD_beta_table
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
(p0)  ldfe      sind_Sm = [r45],16 ;;
(p0)  ldfe      sind_Cm = [r45]                      
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fnma.s1  sind_r      = sind_Nfloat, sind_Pi_by_16_lo,  sind_r 
      nop.i 999 ;;
}

// get rsq 
{ .mfi
      nop.m 999
(p0)  fma.s1   sind_rsq  = sind_r, sind_r,   f0  
      nop.i 999 ;;
}

// form P and Q series
{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P_temp1 = sind_rsq, sind_P4, sind_P3       
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q_temp1 = sind_rsq, sind_Q4, sind_Q3       
      nop.i 999 ;;
}

// get rcube and sm*rsq 
{ .mfi
      nop.m 999
(p0)  fmpy.s1     sind_srsq    = sind_Sm,sind_rsq                 
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fmpy.s1     sind_rcub    = sind_r, sind_rsq                 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q_temp2 = sind_rsq, sind_Q_temp1, sind_Q2  
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P_temp2 = sind_rsq, sind_P_temp1, sind_P2  
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q       = sind_rsq, sind_Q_temp2, sind_Q1  
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P       = sind_rsq, sind_P_temp2, sind_P1  
      nop.i 999 ;;
}

// Get final P and Q
{ .mfi
      nop.m 999
(p0)  fma.s1   sind_Q = sind_srsq,sind_Q, sind_Sm     
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1   sind_P = sind_rcub,sind_P, sind_r      
      nop.i 999 ;;
}

// Final calculation
{ .mfb
      nop.m 999
(p0)  fma.d    f8     = sind_Cm, sind_P, sind_Q       
(p0)  br.ret.sptk    b0 ;;
}
.endp cos#



.proc __libm_callout_1
__libm_callout_1:
SIND_DBX: 
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mbb
      nop.m 999
(p9)  br.cond.spnt   COSD_DBX 
(p8)  br.call.spnt.many   b0=__libm_sin_double_dbx# ;;
}
;;


// if we come out of __libm_sin_double_dbx#
// we want to ensure that p9 is false.

{ .mii
         nop.m 999
         nop.i 999
(p0)  cmp.eq.unc p8,p9 = r0,r0                               
;;
}

COSD_DBX: 
{ .mib
      nop.m 999
      nop.i 999
(p9)  br.call.spnt.many   b0=__libm_cos_double_dbx# ;;
}


{ .mfi
(p0)   mov gp        = GR_SAVE_GP
       nop.f  999
(p0)   mov b0        = GR_SAVE_B0
}
;;

{ .mib
      nop.m 999
(p0)  mov ar.pfs    = GR_SAVE_PFS
(p0)  br.ret.sptk     b0 ;;
}
.endp  __libm_callout_1



// ====================================================================
// ====================================================================

// These functions calculate the sin and cos for inputs
// greater than 2^10 
// __libm_sin_double_dbx# and __libm_cos_double_dbx#

//*********************************************************************
//*********************************************************************
//
// Function:   Combined sin(x) and cos(x), where
//
//             sin(x) = sine(x), for double precision x values
//             cos(x) = cosine(x), for double precision x values
//
//*********************************************************************
//
// Accuracy:       Within .7 ulps for 80-bit floating point values
//                 Very accurate for double precision values
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8 (Input and Return Value) 
//                              f32-f99
//
//    General Purpose Registers:
//      r32-r43 
//      r44-r45 (Used to pass arguments to pi_by_2 reduce routine)
//
//    Predicate Registers:      p6-p13
//
//*********************************************************************
//
//  IEEE Special Conditions:
//
//    Denormal  fault raised on denormal inputs
//    Overflow exceptions do not occur
//    Underflow exceptions raised when appropriate for sin 
//    (No specialized error handling for this routine)
//    Inexact raised when appropriate by algorithm
//
//    sin(SNaN) = QNaN
//    sin(QNaN) = QNaN
//    sin(inf) = QNaN 
//    sin(+/-0) = +/-0
//    cos(inf) = QNaN 
//    cos(SNaN) = QNaN
//    cos(QNaN) = QNaN
//    cos(0) = 1
// 
//*********************************************************************
//
//  Mathematical Description
//  ========================
//
//  The computation of FSIN and FCOS is best handled in one piece of 
//  code. The main reason is that given any argument Arg, computation 
//  of trigonometric functions first calculate N and an approximation 
//  to alpha where
//
//  Arg = N pi/2 + alpha, |alpha| <= pi/4.
//
//  Since
//
//  cos( Arg ) = sin( (N+1) pi/2 + alpha ),
//
//  therefore, the code for computing sine will produce cosine as long 
//  as 1 is added to N immediately after the argument reduction 
//  process.
//
//  Let M = N if sine
//      N+1 if cosine.  
//
//  Now, given
//
//  Arg = M pi/2  + alpha, |alpha| <= pi/4,
//
//  let I = M mod 4, or I be the two lsb of M when M is represented 
//  as 2's complement. I = [i_0 i_1]. Then
//
//  sin( Arg ) = (-1)^i_0  sin( alpha )	if i_1 = 0,
//             = (-1)^i_0  cos( alpha )     if i_1 = 1.
//
//  For example:
//       if M = -1, I = 11   
//         sin ((-pi/2 + alpha) = (-1) cos (alpha)
//       if M = 0, I = 00   
//         sin (alpha) = sin (alpha)
//       if M = 1, I = 01   
//         sin (pi/2 + alpha) = cos (alpha)
//       if M = 2, I = 10   
//         sin (pi + alpha) = (-1) sin (alpha)
//       if M = 3, I = 11   
//         sin ((3/2)pi + alpha) = (-1) cos (alpha)
//
//  The value of alpha is obtained by argument reduction and 
//  represented by two working precision numbers r and c where
//
//  alpha =  r  +  c     accurately.
//
//  The reduction method is described in a previous write up.
//  The argument reduction scheme identifies 4 cases. For Cases 2 
//  and 4, because |alpha| is small, sin(r+c) and cos(r+c) can be 
//  computed very easily by 2 or 3 terms of the Taylor series 
//  expansion as follows:
//
//  Case 2:
//  -------
//
//  sin(r + c) = r + c - r^3/6	accurately
//  cos(r + c) = 1 - 2^(-67)	accurately
//
//  Case 4:
//  -------
//
//  sin(r + c) = r + c - r^3/6 + r^5/120	accurately
//  cos(r + c) = 1 - r^2/2 + r^4/24		accurately
//
//  The only cases left are Cases 1 and 3 of the argument reduction 
//  procedure. These two cases will be merged since after the 
//  argument is reduced in either cases, we have the reduced argument 
//  represented as r + c and that the magnitude |r + c| is not small 
//  enough to allow the usage of a very short approximation.
//
//  The required calculation is either
//
//  sin(r + c)  =  sin(r)  +  correction,  or
//  cos(r + c)  =  cos(r)  +  correction.
//
//  Specifically,
//
//	sin(r + c) = sin(r) + c sin'(r) + O(c^2)
//		   = sin(r) + c cos (r) + O(c^2)
//		   = sin(r) + c(1 - r^2/2)  accurately.
//  Similarly,
//
//	cos(r + c) = cos(r) - c sin(r) + O(c^2)
//		   = cos(r) - c(r - r^3/6)  accurately.
//
//  We therefore concentrate on accurately calculating sin(r) and 
//  cos(r) for a working-precision number r, |r| <= pi/4 to within
//  0.1% or so.
//
//  The greatest challenge of this task is that the second terms of 
//  the Taylor series
//	
//	r - r^3/3! + r^r/5! - ...
//
//  and
//
//	1 - r^2/2! + r^4/4! - ...
//
//  are not very small when |r| is close to pi/4 and the rounding 
//  errors will be a concern if simple polynomial accumulation is 
//  used. When |r| < 2^-3, however, the second terms will be small 
//  enough (6 bits or so of right shift) that a normal Horner 
//  recurrence suffices. Hence there are two cases that we consider 
//  in the accurate computation of sin(r) and cos(r), |r| <= pi/4.
//
//  Case small_r: |r| < 2^(-3)
//  --------------------------
//
//  Since Arg = M pi/4 + r + c accurately, and M mod 4 is [i_0 i_1],
//  we have
//
//	sin(Arg) = (-1)^i_0 * sin(r + c)	if i_1 = 0
//		 = (-1)^i_0 * cos(r + c) 	if i_1 = 1
//
//  can be accurately approximated by
//
//  sin(Arg) = (-1)^i_0 * [sin(r) + c]	if i_1 = 0
//           = (-1)^i_0 * [cos(r) - c*r] if i_1 = 1
//
//  because |r| is small and thus the second terms in the correction 
//  are unneccessary.
//
//  Finally, sin(r) and cos(r) are approximated by polynomials of 
//  moderate lengths.
//
//  sin(r) =  r + S_1 r^3 + S_2 r^5 + ... + S_5 r^11
//  cos(r) =  1 + C_1 r^2 + C_2 r^4 + ... + C_5 r^10
//
//  We can make use of predicates to selectively calculate 
//  sin(r) or cos(r) based on i_1. 
//
//  Case normal_r: 2^(-3) <= |r| <= pi/4
//  ------------------------------------
//
//  This case is more likely than the previous one if one considers
//  r to be uniformly distributed in [-pi/4 pi/4]. Again,
// 
//  sin(Arg) = (-1)^i_0 * sin(r + c)	if i_1 = 0
//           = (-1)^i_0 * cos(r + c) 	if i_1 = 1.
//
//  Because |r| is now larger, we need one extra term in the 
//  correction. sin(Arg) can be accurately approximated by
//
//  sin(Arg) = (-1)^i_0 * [sin(r) + c(1-r^2/2)]      if i_1 = 0
//           = (-1)^i_0 * [cos(r) - c*r*(1 - r^2/6)]    i_1 = 1.
//
//  Finally, sin(r) and cos(r) are approximated by polynomials of 
//  moderate lengths.
//
//	sin(r) =  r + PP_1_hi r^3 + PP_1_lo r^3 + 
//	              PP_2 r^5 + ... + PP_8 r^17
//
//	cos(r) =  1 + QQ_1 r^2 + QQ_2 r^4 + ... + QQ_8 r^16
//
//  where PP_1_hi is only about 16 bits long and QQ_1 is -1/2. 
//  The crux in accurate computation is to calculate 
//
//  r + PP_1_hi r^3   or  1 + QQ_1 r^2
//
//  accurately as two pieces: U_hi and U_lo. The way to achieve this 
//  is to obtain r_hi as a 10 sig. bit number that approximates r to 
//  roughly 8 bits or so of accuracy. (One convenient way is
//
//  r_hi := frcpa( frcpa( r ) ).)
//
//  This way,
//
//	r + PP_1_hi r^3 =  r + PP_1_hi r_hi^3 +
//	                        PP_1_hi (r^3 - r_hi^3)
//		        =  [r + PP_1_hi r_hi^3]  +  
//			   [PP_1_hi (r - r_hi) 
//			      (r^2 + r_hi r + r_hi^2) ]
//		        =  U_hi  +  U_lo
//
//  Since r_hi is only 10 bit long and PP_1_hi is only 16 bit long,
//  PP_1_hi * r_hi^3 is only at most 46 bit long and thus computed 
//  exactly. Furthermore, r and PP_1_hi r_hi^3 are of opposite sign 
//  and that there is no more than 8 bit shift off between r and 
//  PP_1_hi * r_hi^3. Hence the sum, U_hi, is representable and thus 
//  calculated without any error. Finally, the fact that 
//
//	|U_lo| <= 2^(-8) |U_hi|
//
//  says that U_hi + U_lo is approximating r + PP_1_hi r^3 to roughly 
//  8 extra bits of accuracy.
//
//  Similarly,
//
//	1 + QQ_1 r^2  =  [1 + QQ_1 r_hi^2]  +
//	                    [QQ_1 (r - r_hi)(r + r_hi)]
//		      =  U_hi  +  U_lo.
//		      
//  Summarizing, we calculate r_hi = frcpa( frcpa( r ) ). 
//
//  If i_1 = 0, then
//
//    U_hi := r + PP_1_hi * r_hi^3
//    U_lo := PP_1_hi * (r - r_hi) * (r^2 + r*r_hi + r_hi^2)
//    poly := PP_1_lo r^3 + PP_2 r^5 + ... + PP_8 r^17
//    correction := c * ( 1 + C_1 r^2 )
//
//  Else ...i_1 = 1
//
//    U_hi := 1 + QQ_1 * r_hi * r_hi
//    U_lo := QQ_1 * (r - r_hi) * (r + r_hi)
//    poly := QQ_2 * r^4 + QQ_3 * r^6 + ... + QQ_8 r^16
//    correction := -c * r * (1 + S_1 * r^2)
//
//  End
//
//  Finally,
// 
//	V := poly + ( U_lo + correction )
//
//                 /    U_hi  +  V         if i_0 = 0
//	result := |
//                 \  (-U_hi) -  V         if i_0 = 1
//
//  It is important that in the last step, negation of U_hi is 
//  performed prior to the subtraction which is to be performed in 
//  the user-set rounding mode. 
//
//
//  Algorithmic Description
//  =======================
//
//  The argument reduction algorithm is tightly integrated into FSIN 
//  and FCOS which share the same code. The following is complete and 
//  self-contained. The argument reduction description given 
//  previously is repeated below.
//
//
//  Step 0. Initialization. 
//
//   If FSIN is invoked, set N_inc := 0; else if FCOS is invoked,
//   set N_inc := 1.
//
//  Step 1. Check for exceptional and special cases.
//
//   * If Arg is +-0, +-inf, NaN, NaT, go to Step 10 for special 
//     handling.
//   * If |Arg| < 2^24, go to Step 2 for reduction of moderate
//     arguments. This is the most likely case.
//   * If |Arg| < 2^63, go to Step 8 for pre-reduction of large
//     arguments.
//   * If |Arg| >= 2^63, go to Step 10 for special handling.
//
//  Step 2. Reduction of moderate arguments.
//
//  If |Arg| < pi/4 	...quick branch
//     N_fix := N_inc	(integer)
//     r     := Arg
//     c     := 0.0
//     Branch to Step 4, Case_1_complete
//  Else 		...cf. argument reduction
//     N     := Arg * two_by_PI	(fp)
//     N_fix := fcvt.fx( N )	(int)
//     N     := fcvt.xf( N_fix )
//     N_fix := N_fix + N_inc
//     s     := Arg - N * P_1	(first piece of pi/2)
//     w     := -N * P_2	(second piece of pi/2)
//
//     If |s| >= 2^(-33)
//        go to Step 3, Case_1_reduce
//     Else
//        go to Step 7, Case_2_reduce
//     Endif
//  Endif
//
//  Step 3. Case_1_reduce.
//
//  r := s + w
//  c := (s - r) + w	...observe order
//   
//  Step 4. Case_1_complete
//
//  ...At this point, the reduced argument alpha is
//  ...accurately represented as r + c.
//  If |r| < 2^(-3), go to Step 6, small_r.
//
//  Step 5. Normal_r.
//
//  Let [i_0 i_1] by the 2 lsb of N_fix.
//  FR_rsq  := r * r
//  r_hi := frcpa( frcpa( r ) )
//  r_lo := r - r_hi
//
//  If i_1 = 0, then
//    poly := r*FR_rsq*(PP_1_lo + FR_rsq*(PP_2 + ... FR_rsq*PP_8))
//    U_hi := r + PP_1_hi*r_hi*r_hi*r_hi	...any order
//    U_lo := PP_1_hi*r_lo*(r*r + r*r_hi + r_hi*r_hi)
//    correction := c + c*C_1*FR_rsq		...any order
//  Else
//    poly := FR_rsq*FR_rsq*(QQ_2 + FR_rsq*(QQ_3 + ... + FR_rsq*QQ_8))
//    U_hi := 1 + QQ_1 * r_hi * r_hi		...any order
//    U_lo := QQ_1 * r_lo * (r + r_hi)
//    correction := -c*(r + S_1*FR_rsq*r)	...any order
//  Endif
//
//  V := poly + (U_lo + correction)	...observe order
//
//  result := (i_0 == 0?   1.0 : -1.0)
//
//  Last instruction in user-set rounding mode
//
//  result := (i_0 == 0?   result*U_hi + V :
//                        result*U_hi - V)
//
//  Return
//
//  Step 6. Small_r.
// 
//  ...Use flush to zero mode without causing exception
//    Let [i_0 i_1] be the two lsb of N_fix.
//
//  FR_rsq := r * r
//
//  If i_1 = 0 then
//     z := FR_rsq*FR_rsq; z := FR_rsq*z *r
//     poly_lo := S_3 + FR_rsq*(S_4 + FR_rsq*S_5)
//     poly_hi := r*FR_rsq*(S_1 + FR_rsq*S_2)
//     correction := c
//     result := r
//  Else
//     z := FR_rsq*FR_rsq; z := FR_rsq*z
//     poly_lo := C_3 + FR_rsq*(C_4 + FR_rsq*C_5)
//     poly_hi := FR_rsq*(C_1 + FR_rsq*C_2) 
//     correction := -c*r
//     result := 1
//  Endif
//
//  poly := poly_hi + (z * poly_lo + correction)
//
//  If i_0 = 1, result := -result
//
//  Last operation. Perform in user-set rounding mode
//
//  result := (i_0 == 0?     result + poly :
//                          result - poly )
//  Return
//
//  Step 7. Case_2_reduce.
//
//  ...Refer to the write up for argument reduction for 
//  ...rationale. The reduction algorithm below is taken from
//  ...argument reduction description and integrated this.
//
//  w := N*P_3
//  U_1 := N*P_2 + w		...FMA
//  U_2 := (N*P_2 - U_1) + w	...2 FMA
//  ...U_1 + U_2 is  N*(P_2+P_3) accurately
//   
//  r := s - U_1
//  c := ( (s - r) - U_1 ) - U_2
//
//  ...The mathematical sum r + c approximates the reduced
//  ...argument accurately. Note that although compared to
//  ...Case 1, this case requires much more work to reduce
//  ...the argument, the subsequent calculation needed for
//  ...any of the trigonometric function is very little because
//  ...|alpha| < 1.01*2^(-33) and thus two terms of the 
//  ...Taylor series expansion suffices.
//
//  If i_1 = 0 then
//     poly := c + S_1 * r * r * r	...any order
//     result := r
//  Else
//     poly := -2^(-67)
//     result := 1.0
//  Endif
//   
//  If i_0 = 1, result := -result
//
//  Last operation. Perform in user-set rounding mode
//
//  result := (i_0 == 0?     result + poly :
//                           result - poly )
//   
//  Return
//
//  
//  Step 8. Pre-reduction of large arguments.
// 
//  ...Again, the following reduction procedure was described
//  ...in the separate write up for argument reduction, which
//  ...is tightly integrated here.

//  N_0 := Arg * Inv_P_0
//  N_0_fix := fcvt.fx( N_0 )
//  N_0 := fcvt.xf( N_0_fix)
   
//  Arg' := Arg - N_0 * P_0
//  w := N_0 * d_1
//  N := Arg' * two_by_PI
//  N_fix := fcvt.fx( N )
//  N := fcvt.xf( N_fix )
//  N_fix := N_fix + N_inc 
//
//  s := Arg' - N * P_1
//  w := w - N * P_2
//
//  If |s| >= 2^(-14)
//     go to Step 3
//  Else
//     go to Step 9
//  Endif
//
//  Step 9. Case_4_reduce.
// 
//    ...first obtain N_0*d_1 and -N*P_2 accurately
//   U_hi := N_0 * d_1		V_hi := -N*P_2
//   U_lo := N_0 * d_1 - U_hi	V_lo := -N*P_2 - U_hi	...FMAs
//
//   ...compute the contribution from N_0*d_1 and -N*P_3
//   w := -N*P_3
//   w := w + N_0*d_2
//   t := U_lo + V_lo + w		...any order
//
//   ...at this point, the mathematical value
//   ...s + U_hi + V_hi  + t approximates the true reduced argument
//   ...accurately. Just need to compute this accurately.
//
//   ...Calculate U_hi + V_hi accurately:
//   A := U_hi + V_hi
//   if |U_hi| >= |V_hi| then
//      a := (U_hi - A) + V_hi
//   else
//      a := (V_hi - A) + U_hi
//   endif
//   ...order in computing "a" must be observed. This branch is
//   ...best implemented by predicates.
//   ...A + a  is U_hi + V_hi accurately. Moreover, "a" is 
//   ...much smaller than A: |a| <= (1/2)ulp(A).
//
//   ...Just need to calculate   s + A + a + t
//   C_hi := s + A		t := t + a
//   C_lo := (s - C_hi) + A	
//   C_lo := C_lo + t
//
//   ...Final steps for reduction
//   r := C_hi + C_lo
//   c := (C_hi - r) + C_lo
//
//   ...At this point, we have r and c
//   ...And all we need is a couple of terms of the corresponding
//   ...Taylor series.
//
//   If i_1 = 0
//      poly := c + r*FR_rsq*(S_1 + FR_rsq*S_2)
//      result := r
//   Else
//      poly := FR_rsq*(C_1 + FR_rsq*C_2)
//      result := 1
//   Endif
//
//   If i_0 = 1, result := -result
//
//   Last operation. Perform in user-set rounding mode
//
//   result := (i_0 == 0?     result + poly :
//                            result - poly )
//   Return
//  
//   Large Arguments: For arguments above 2**63, a Payne-Hanek
//   style argument reduction is used and pi_by_2 reduce is called.
//
 

.data
.align 64 

FSINCOS_CONSTANTS:

data4 0x4B800000, 0xCB800000, 0x00000000,0x00000000 // two**24, -two**24
data4 0x4E44152A, 0xA2F9836E, 0x00003FFE,0x00000000 // Inv_pi_by_2
data4 0xCE81B9F1, 0xC84D32B0, 0x00004016,0x00000000 // P_0 
data4 0x2168C235, 0xC90FDAA2, 0x00003FFF,0x00000000 // P_1 
data4 0xFC8F8CBB, 0xECE675D1, 0x0000BFBD,0x00000000 // P_2 
data4 0xACC19C60, 0xB7ED8FBB, 0x0000BF7C,0x00000000 // P_3 
data4 0x5F000000, 0xDF000000, 0x00000000,0x00000000 // two_to_63, -two_to_63
data4 0x6EC6B45A, 0xA397E504, 0x00003FE7,0x00000000 // Inv_P_0 
data4 0xDBD171A1, 0x8D848E89, 0x0000BFBF,0x00000000 // d_1 
data4 0x18A66F8E, 0xD5394C36, 0x0000BF7C,0x00000000 // d_2 
data4 0x2168C234, 0xC90FDAA2, 0x00003FFE,0x00000000 // pi_by_4 
data4 0x2168C234, 0xC90FDAA2, 0x0000BFFE,0x00000000 // neg_pi_by_4 
data4 0x3E000000, 0xBE000000, 0x00000000,0x00000000 // two**-3, -two**-3
data4 0x2F000000, 0xAF000000, 0x9E000000,0x00000000 // two**-33, -two**-33, -two**-67
data4 0xA21C0BC9, 0xCC8ABEBC, 0x00003FCE,0x00000000 // PP_8 
data4 0x720221DA, 0xD7468A05, 0x0000BFD6,0x00000000 // PP_7 
data4 0x640AD517, 0xB092382F, 0x00003FDE,0x00000000 // PP_6 
data4 0xD1EB75A4, 0xD7322B47, 0x0000BFE5,0x00000000 // PP_5 
data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1 
data4 0x00000000, 0xAAAA0000, 0x0000BFFC,0x00000000 // PP_1_hi 
data4 0xBAF69EEA, 0xB8EF1D2A, 0x00003FEC,0x00000000 // PP_4 
data4 0x0D03BB69, 0xD00D00D0, 0x0000BFF2,0x00000000 // PP_3 
data4 0x88888962, 0x88888888, 0x00003FF8,0x00000000 // PP_2
data4 0xAAAB0000, 0xAAAAAAAA, 0x0000BFEC,0x00000000 // PP_1_lo 
data4 0xC2B0FE52, 0xD56232EF, 0x00003FD2,0x00000000 // QQ_8
data4 0x2B48DCA6, 0xC9C99ABA, 0x0000BFDA,0x00000000 // QQ_7
data4 0x9C716658, 0x8F76C650, 0x00003FE2,0x00000000 // QQ_6
data4 0xFDA8D0FC, 0x93F27DBA, 0x0000BFE9,0x00000000 // QQ_5
data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC,0x00000000 // S_1 
data4 0x00000000, 0x80000000, 0x0000BFFE,0x00000000 // QQ_1 
data4 0x0C6E5041, 0xD00D00D0, 0x00003FEF,0x00000000 // QQ_4 
data4 0x0B607F60, 0xB60B60B6, 0x0000BFF5,0x00000000 // QQ_3 
data4 0xAAAAAA9B, 0xAAAAAAAA, 0x00003FFA,0x00000000 // QQ_2 
data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1 
data4 0xAAAA719F, 0xAAAAAAAA, 0x00003FFA,0x00000000 // C_2 
data4 0x0356F994, 0xB60B60B6, 0x0000BFF5,0x00000000 // C_3
data4 0xB2385EA9, 0xD00CFFD5, 0x00003FEF,0x00000000 // C_4 
data4 0x292A14CD, 0x93E4BD18, 0x0000BFE9,0x00000000 // C_5
data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC,0x00000000 // S_1 
data4 0x888868DB, 0x88888888, 0x00003FF8,0x00000000 // S_2 
data4 0x055EFD4B, 0xD00D00D0, 0x0000BFF2,0x00000000 // S_3 
data4 0x839730B9, 0xB8EF1C5D, 0x00003FEC,0x00000000 // S_4
data4 0xE5B3F492, 0xD71EA3A4, 0x0000BFE5,0x00000000 // S_5
data4 0x38800000, 0xB8800000, 0x00000000            // two**-14, -two**-14

FR_Input_X        = f8 
FR_Neg_Two_to_M3  = f32 
FR_Two_to_63      = f32 
FR_Two_to_24      = f33 
FR_Pi_by_4        = f33 
FR_Two_to_M14     = f34 
FR_Two_to_M33     = f35 
FR_Neg_Two_to_24  = f36 
FR_Neg_Pi_by_4    = f36 
FR_Neg_Two_to_M14 = f37 
FR_Neg_Two_to_M33 = f38 
FR_Neg_Two_to_M67 = f39 
FR_Inv_pi_by_2    = f40 
FR_N_float        = f41 
FR_N_fix          = f42 
FR_P_1            = f43 
FR_P_2            = f44 
FR_P_3            = f45 
FR_s              = f46 
FR_w              = f47 
FR_c              = f48 
FR_r              = f49 
FR_Z              = f50 
FR_A              = f51 
FR_a              = f52 
FR_t              = f53 
FR_U_1            = f54 
FR_U_2            = f55 
FR_C_1            = f56 
FR_C_2            = f57 
FR_C_3            = f58 
FR_C_4            = f59 
FR_C_5            = f60 
FR_S_1            = f61 
FR_S_2            = f62 
FR_S_3            = f63 
FR_S_4            = f64 
FR_S_5            = f65 
FR_poly_hi        = f66 
FR_poly_lo        = f67 
FR_r_hi           = f68 
FR_r_lo           = f69 
FR_rsq            = f70 
FR_r_cubed        = f71 
FR_C_hi           = f72 
FR_N_0            = f73 
FR_d_1            = f74 
FR_V              = f75 
FR_V_hi           = f75 
FR_V_lo           = f76 
FR_U_hi           = f77 
FR_U_lo           = f78 
FR_U_hiabs        = f79 
FR_V_hiabs        = f80 
FR_PP_8           = f81 
FR_QQ_8           = f81 
FR_PP_7           = f82 
FR_QQ_7           = f82 
FR_PP_6           = f83 
FR_QQ_6           = f83 
FR_PP_5           = f84 
FR_QQ_5           = f84 
FR_PP_4           = f85 
FR_QQ_4           = f85 
FR_PP_3           = f86 
FR_QQ_3           = f86 
FR_PP_2           = f87 
FR_QQ_2           = f87 
FR_QQ_1           = f88 
FR_N_0_fix        = f89 
FR_Inv_P_0        = f90 
FR_corr           = f91 
FR_poly           = f92 
FR_d_2            = f93 
FR_Two_to_M3      = f94 
FR_Neg_Two_to_63  = f94 
FR_P_0            = f95 
FR_C_lo           = f96 
FR_PP_1           = f97 
FR_PP_1_lo        = f98 
FR_ArgPrime       = f99 

GR_Table_Base  = r32 
GR_Table_Base1 = r33 
GR_i_0         = r34
GR_i_1         = r35
GR_N_Inc       = r36 
GR_Sin_or_Cos  = r37 

GR_SAVE_B0     = r39
GR_SAVE_GP     = r40
GR_SAVE_PFS    = r41

.section .text
.proc __libm_sin_double_dbx#
.align 64 
__libm_sin_double_dbx: 

{ .mlx
alloc GR_Table_Base = ar.pfs,0,12,2,0
(p0)   movl GR_Sin_or_Cos = 0x0 ;;
}

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mib
      nop.m 999
      nop.i 999
(p0)   br.cond.sptk SINCOS_CONTINUE ;;
}

.endp __libm_sin_double_dbx#

.section .text
.proc __libm_cos_double_dbx#
__libm_cos_double_dbx: 

{ .mlx
alloc GR_Table_Base= ar.pfs,0,12,2,0
(p0)   movl GR_Sin_or_Cos = 0x1 ;;
}

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;

//
//     Load Table Address
//
SINCOS_CONTINUE: 

{ .mmi
(p0)   add GR_Table_Base1 = 96, GR_Table_Base
(p0)   ldfs	FR_Two_to_24 = [GR_Table_Base], 4
       nop.i 999
}
;;

{ .mmi
      nop.m 999
//
//     Load 2**24, load 2**63.
//
(p0)   ldfs	FR_Neg_Two_to_24 = [GR_Table_Base], 12
(p0)   mov   r41 = ar.pfs ;;
}

{ .mfi
(p0)   ldfs	FR_Two_to_63 = [GR_Table_Base1], 4
//
//     Check for unnormals - unsupported operands. We do not want
//     to generate denormal exception
//     Check for NatVals, QNaNs, SNaNs, +/-Infs
//     Check for EM unsupporteds
//     Check for Zero 
//
(p0)   fclass.m.unc  p6, p8 =  FR_Input_X, 0x1E3
(p0)   mov   r40 = gp ;;
}

{ .mfi
      nop.m 999
(p0)   fclass.nm.unc p8, p0 =  FR_Input_X, 0x1FF
// GR_Sin_or_Cos denotes 
(p0)   mov   r39 = b0
}

{ .mfb
(p0)   ldfs	FR_Neg_Two_to_63 = [GR_Table_Base1], 12
(p0)   fclass.m.unc p10, p0 = FR_Input_X, 0x007
(p6)   br.cond.spnt SINCOS_SPECIAL ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p8)   br.cond.spnt SINCOS_SPECIAL ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Branch if +/- NaN, Inf.
//     Load -2**24, load -2**63.
//
(p10)  br.cond.spnt SINCOS_ZERO ;;
}

{ .mmb
(p0)   ldfe	FR_Inv_pi_by_2 = [GR_Table_Base], 16
(p0)   ldfe	FR_Inv_P_0 = [GR_Table_Base1], 16
      nop.b 999 ;;
}

{ .mmb
      nop.m 999
(p0)   ldfe		FR_d_1 = [GR_Table_Base1], 16
      nop.b 999 ;;
}
//
//     Raise possible denormal operand flag with useful fcmp
//     Is x <= -2**63
//     Load Inv_P_0 for pre-reduction
//     Load Inv_pi_by_2
//

{ .mmb
(p0)   ldfe		FR_P_0 = [GR_Table_Base], 16
(p0)   ldfe	FR_d_2 = [GR_Table_Base1], 16
      nop.b 999 ;;
}
//
//     Load P_0
//     Load d_1
//     Is x >= 2**63
//     Is x <= -2**24?
//

{ .mmi
(p0)   ldfe	FR_P_1 = [GR_Table_Base], 16 ;;
//
//     Load P_1
//     Load d_2
//     Is x >= 2**24?
//
(p0)   ldfe	FR_P_2 = [GR_Table_Base], 16
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p0)   ldfe	FR_P_3 = [GR_Table_Base], 16
(p0)   fcmp.le.unc.s1	p7, p8 = FR_Input_X, FR_Neg_Two_to_24
}

{ .mfi
      nop.m 999
//
//     Branch if +/- zero.
//     Decide about the paths to take:
//     If -2**24 < FR_Input_X < 2**24 - CASE 1 OR 2 
//     OTHERWISE - CASE 3 OR 4 
//
(p0)   fcmp.le.unc.s0	p10, p11 = FR_Input_X, FR_Neg_Two_to_63
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fcmp.ge.s1 p7, p0 = FR_Input_X, FR_Two_to_24
      nop.i 999
}

{ .mfi
(p0)   ldfe	FR_Pi_by_4 = [GR_Table_Base1], 16
(p11)  fcmp.ge.s1	p10, p0 = FR_Input_X, FR_Two_to_63
      nop.i 999 ;;
}

{ .mmi
(p0)   ldfe	FR_Neg_Pi_by_4 = [GR_Table_Base1], 16 ;;
(p0)   ldfs	FR_Two_to_M3 = [GR_Table_Base1], 4
      nop.i 999 ;;
}

{ .mib
(p0)   ldfs	FR_Neg_Two_to_M3 = [GR_Table_Base1], 12
      nop.i 999
//
//     Load P_2
//     Load P_3
//     Load pi_by_4
//     Load neg_pi_by_4
//     Load 2**(-3)
//     Load -2**(-3).
//
(p10)  br.cond.spnt SINCOS_ARG_TOO_LARGE ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Branch out if x >= 2**63. Use Payne-Hanek Reduction
//
(p7)   br.cond.spnt SINCOS_LARGER_ARG ;;
}

{ .mfi
      nop.m 999
// 
//     Branch if Arg <= -2**24 or Arg >= 2**24 and use pre-reduction.
//
(p0)   fma.s1	FR_N_float = FR_Input_X, FR_Inv_pi_by_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)   fcmp.lt.unc.s1	p6, p7 = FR_Input_X, FR_Pi_by_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     Select the case when |Arg| < pi/4 
//     Else Select the case when |Arg| >= pi/4 
//
(p0)   fcvt.fx.s1 FR_N_fix = FR_N_float
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N  = Arg * 2/pi
//     Check if Arg < pi/4
//
(p6)   fcmp.gt.s1 p6, p7 = FR_Input_X, FR_Neg_Pi_by_4
      nop.i 999 ;;
}
//
//     Case 2: Convert integer N_fix back to normalized floating-point value.
//     Case 1: p8 is only affected  when p6 is set
//

{ .mfi
(p7)   ldfs FR_Two_to_M33 = [GR_Table_Base1], 4
//
//     Grab the integer part of N and call it N_fix
//
(p6)   fmerge.se FR_r = FR_Input_X, FR_Input_X
//     If |x| < pi/4, r = x and c = 0 
//     lf |x| < pi/4, is x < 2**(-3).
//     r = Arg 
//     c = 0
(p6)   mov GR_N_Inc = GR_Sin_or_Cos ;;
}

{ .mmf
      nop.m 999
(p7)   ldfs FR_Neg_Two_to_M33 = [GR_Table_Base1], 4
(p6)   fmerge.se FR_c = f0, f0
}

{ .mfi
      nop.m 999
(p6)   fcmp.lt.unc.s1	p8, p9 = FR_Input_X, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     lf |x| < pi/4, is -2**(-3)< x < 2**(-3) - set p8.
//     If |x| >= pi/4, 
//     Create the right N for |x| < pi/4 and otherwise 
//     Case 2: Place integer part of N in GP register
//
(p7)   fcvt.xf FR_N_float = FR_N_fix
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p7)   getf.sig	GR_N_Inc = FR_N_fix
(p8)   fcmp.gt.s1 p8, p0 = FR_Input_X, FR_Neg_Two_to_M3 ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Load 2**(-33), -2**(-33)
//
(p8)   br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p6)   br.cond.sptk SINCOS_NORMAL_R ;;
}
//
//     if |x| < pi/4, branch based on |x| < 2**(-3) or otherwise.
//
//
//     In this branch, |x| >= pi/4.
// 

{ .mfi
(p0)   ldfs FR_Neg_Two_to_M67 = [GR_Table_Base1], 8
//
//     Load -2**(-67)
// 
(p0)   fnma.s1	FR_s = FR_N_float, FR_P_1, FR_Input_X
//
//     w = N * P_2
//     s = -N * P_1  + Arg
//
(p0)   add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos
}

{ .mfi
      nop.m 999
(p0)   fma.s1	FR_w = FR_N_float, FR_P_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     Adjust N_fix by N_inc to determine whether sine or
//     cosine is being calculated
//
(p0)   fcmp.lt.unc.s1 p7, p6 = FR_s, FR_Two_to_M33
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fcmp.gt.s1 p7, p6 = FR_s, FR_Neg_Two_to_M33
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//     Remember x >= pi/4.
//     Is s <= -2**(-33) or s >= 2**(-33) (p6)
//     or -2**(-33) < s < 2**(-33) (p7)
(p6)   fms.s1 FR_r = FR_s, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.s1 FR_U_1 = FR_N_float, FR_P_2, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p6)   fms.s1 FR_c = FR_s, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     For big s: r = s - w: No futher reduction is necessary 
//     For small s: w = N * P_3 (change sign) More reduction
//
(p6)   fcmp.lt.unc.s1 p8, p9 = FR_r, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fcmp.gt.s1 p8, p9 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fms.s1 FR_r = FR_s, f1, FR_U_1
      nop.i 999
}

{ .mfb
      nop.m 999
//
//     For big s: Is |r| < 2**(-3)?
//     For big s: c = S - r
//     For small s: U_1 = N * P_2 + w
//
//     If p8 is set, prepare to branch to Small_R.
//     If p9 is set, prepare to branch to Normal_R.
//     For big s,  r is complete here.
//
(p6)   fms.s1 FR_c = FR_c, f1, FR_w
// 
//     For big s: c = c + w (w has not been negated.)
//     For small s: r = S - U_1
//
(p8)   br.cond.spnt	SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p9)   br.cond.sptk	SINCOS_NORMAL_R ;;
}

{ .mfi
(p7)   add GR_Table_Base1 = 224, GR_Table_Base1
//
//     Branch to SINCOS_SMALL_R or SINCOS_NORMAL_R
//
(p7)   fms.s1 FR_U_2 = FR_N_float, FR_P_2, FR_U_1
// 
//     c = S - U_1
//     r = S_1 * r
//
//
(p7)   extr.u	GR_i_1 = GR_N_Inc, 0, 1
}

{ .mmi
      nop.m 999 ;;
//
//     Get [i_0,i_1] - two lsb of N_fix_gr.
//     Do dummy fmpy so inexact is always set.
//
(p7)   cmp.eq.unc p9, p10 = 0x0, GR_i_1
(p7)   extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}
// 
//     For small s: U_2 = N * P_2 - U_1
//     S_1 stored constant - grab the one stored with the
//     coefficients.
// 

{ .mfi
(p7)   ldfe FR_S_1 = [GR_Table_Base1], 16
//
//     Check if i_1 and i_0  != 0
//
(p10)  fma.s1	FR_poly = f0, f1, FR_Neg_Two_to_M67
(p7)   cmp.eq.unc p11, p12 = 0x0, GR_i_0 ;;
}

{ .mfi
      nop.m 999
(p7)   fms.s1	FR_s = FR_s, f1, FR_r
      nop.i 999
}

{ .mfi
      nop.m 999
// 
//     S = S - r
//     U_2 = U_2 + w
//     load S_1
//
(p7)   fma.s1	FR_rsq = FR_r, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.s1	FR_U_2 = FR_U_2, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fmerge.se FR_Input_X = FR_r, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)  fma.s1 FR_Input_X = f0, f1, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     FR_rsq = r * r
//     Save r as the result.
//
(p7)   fms.s1	FR_c = FR_s, f1, FR_U_1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     if ( i_1 ==0) poly = c + S_1*r*r*r
//     else Result = 1
//
(p12)  fnma.s1 FR_Input_X = FR_Input_X, f1, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fma.s1	FR_r = FR_S_1, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.d.s0	FR_S_1 = FR_S_1, FR_S_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     If i_1 != 0, poly = 2**(-67)
//
(p7)   fms.s1 FR_c = FR_c, f1, FR_U_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     c = c - U_2
// 
(p9)   fma.s1 FR_poly = FR_r, FR_rsq, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     i_0 != 0, so Result = -Result
//
(p11)  fma.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p12)  fms.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
//
//     if (i_0 == 0),  Result = Result + poly
//     else            Result = Result - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_LARGER_ARG: 

{ .mfi
      nop.m 999
(p0)   fma.s1 FR_N_0 = FR_Input_X, FR_Inv_P_0, f0
      nop.i 999
}
;;

//     This path for argument > 2*24 
//     Adjust table_ptr1 to beginning of table.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


// 
//     Point to  2*-14 
//     N_0 = Arg * Inv_P_0
//

{ .mmi
(p0)   add GR_Table_Base = 688, GR_Table_Base ;;
(p0)   ldfs FR_Two_to_M14 = [GR_Table_Base], 4
      nop.i 999 ;;
}

{ .mfi
(p0)   ldfs FR_Neg_Two_to_M14 = [GR_Table_Base], 0
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Load values 2**(-14) and -2**(-14)
//
(p0)   fcvt.fx.s1 FR_N_0_fix = FR_N_0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N_0_fix  = integer part of N_0
//
(p0)   fcvt.xf FR_N_0 = FR_N_0_fix 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Make N_0 the integer part
//
(p0)   fnma.s1 FR_ArgPrime = FR_N_0, FR_P_0, FR_Input_X
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)   fma.s1 FR_w = FR_N_0, FR_d_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Arg' = -N_0 * P_0 + Arg
//     w  = N_0 * d_1
//
(p0)   fma.s1 FR_N_float = FR_ArgPrime, FR_Inv_pi_by_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N = A' * 2/pi	
//
(p0)   fcvt.fx.s1 FR_N_fix = FR_N_float
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N_fix is the integer part	
//
(p0)   fcvt.xf FR_N_float = FR_N_fix 
      nop.i 999 ;;
}

{ .mfi
(p0)   getf.sig GR_N_Inc = FR_N_fix
      nop.f 999
      nop.i 999 ;;
}

{ .mii
      nop.m 999
      nop.i 999 ;;
(p0)   add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos ;;
}

{ .mfi
      nop.m 999
//
//     N is the integer part of the reduced-reduced argument.
//     Put the integer in a GP register
//
(p0)   fnma.s1 FR_s = FR_N_float, FR_P_1, FR_ArgPrime
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)   fnma.s1 FR_w = FR_N_float, FR_P_2, FR_w
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     s = -N*P_1 + Arg'
//     w = -N*P_2 + w
//     N_fix_gr = N_fix_gr + N_inc
//
(p0)   fcmp.lt.unc.s1 p9, p8 = FR_s, FR_Two_to_M14
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fcmp.gt.s1 p9, p8 = FR_s, FR_Neg_Two_to_M14
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     For |s|  > 2**(-14) r = S + w (r complete)
//     Else       U_hi = N_0 * d_1
//
(p9)   fma.s1 FR_V_hi = FR_N_float, FR_P_2, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p9)   fma.s1 FR_U_hi = FR_N_0, FR_d_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Either S <= -2**(-14) or S >= 2**(-14)
//     or -2**(-14) < s < 2**(-14)
//
(p8)   fma.s1 FR_r = FR_s, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p9)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     We need abs of both U_hi and V_hi - don't
//     worry about switched sign of V_hi.
//
(p9)   fms.s1 FR_A = FR_U_hi, f1, FR_V_hi
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Big s: finish up c = (S - r) + w (c complete)	
//     Case 4: A =  U_hi + V_hi
//     Note: Worry about switched sign of V_hi, so subtract instead of add.
//
(p9)   fnma.s1 FR_V_lo = FR_N_float, FR_P_2, FR_V_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fms.s1 FR_U_lo = FR_N_0, FR_d_1, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fmerge.s FR_V_hiabs = f0, FR_V_hi
      nop.i 999
}

{ .mfi
      nop.m 999
//     For big s: c = S - r
//     For small s do more work: U_lo = N_0 * d_1 - U_hi
//
(p9)   fmerge.s FR_U_hiabs = f0, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     For big s: Is |r| < 2**(-3)	
//     For big s: if p12 set, prepare to branch to Small_R.
//     For big s: If p13 set, prepare to branch to Normal_R.
//
(p8)   fms.s1 FR_c = FR_s, f1, FR_r 
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     For small S: V_hi = N * P_2
//                  w = N * P_3
//     Note the product does not include the (-) as in the writeup
//     so (-) missing for V_hi and w.
//
(p8)   fcmp.lt.unc.s1 p12, p13 = FR_r, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fcmp.gt.s1 p12, p13 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fma.s1 FR_c = FR_c, f1, FR_w
      nop.i 999
}

{ .mfb
      nop.m 999
(p9)   fms.s1 FR_w = FR_N_0, FR_d_2, FR_w
(p12)  br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p13)  br.cond.sptk SINCOS_NORMAL_R ;;
}

{ .mfi
      nop.m 999
// 
//     Big s: Vector off when |r| < 2**(-3).  Recall that p8 will be true. 
//     The remaining stuff is for Case 4.
//     Small s: V_lo = N * P_2 + U_hi (U_hi is in place of V_hi in writeup)
//     Note: the (-) is still missing for V_lo.
//     Small s: w = w + N_0 * d_2
//     Note: the (-) is now incorporated in w.
//
(p9)   fcmp.ge.unc.s1 p10, p11 = FR_U_hiabs, FR_V_hiabs
(p0)   extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
}

{ .mfi
      nop.m 999
//
//     C_hi = S + A
//
(p9)   fma.s1 FR_t = FR_U_lo, f1, FR_V_lo
(p0)   extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
//
//     t = U_lo + V_lo 
//
//
(p10)  fms.s1 FR_a = FR_U_hi, f1, FR_A
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11)  fma.s1 FR_a = FR_V_hi, f1, FR_A
      nop.i 999
}
;;

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
(p0)   add GR_Table_Base = 528, GR_Table_Base
//
//     Is U_hiabs >= V_hiabs?
//
(p9)   fma.s1 FR_C_hi = FR_s, f1, FR_A
      nop.i 999 ;;
}

{ .mmi
(p0)   ldfe FR_C_1 = [GR_Table_Base], 16 ;;
(p0)   ldfe FR_C_2 = [GR_Table_Base], 64
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
//
//     c = c + C_lo  finished.
//     Load  C_2
//
(p0)   ldfe	FR_S_1 = [GR_Table_Base], 16
//
//     C_lo = S - C_hi 
//
(p0)   fma.s1 FR_t = FR_t, f1, FR_w ;;
}
//
//     r and c have been computed.
//     Make sure ftz mode is set - should be automatic when using wre
//     |r| < 2**(-3)
//     Get [i_0,i_1] - two lsb of N_fix.
//     Load S_1
//

{ .mfi
(p0)   ldfe FR_S_2 = [GR_Table_Base], 64
//
//     t = t + w	
//
(p10)  fms.s1 FR_a = FR_a, f1, FR_V_hi
(p0)   cmp.eq.unc p9, p10 = 0x0, GR_i_0
}

{ .mfi
      nop.m 999
//
//     For larger u than v: a = U_hi - A
//     Else a = V_hi - A (do an add to account for missing (-) on V_hi
//
(p0)   fms.s1 FR_C_lo = FR_s, f1, FR_C_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11)  fms.s1 FR_a = FR_U_hi, f1, FR_a
(p0)   cmp.eq.unc p11, p12 = 0x0, GR_i_1
}

{ .mfi
      nop.m 999
//
//     If u > v: a = (U_hi - A)  + V_hi
//     Else      a = (V_hi - A)  + U_hi
//     In each case account for negative missing from V_hi.
//
(p0)   fma.s1 FR_C_lo = FR_C_lo, f1, FR_A
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     C_lo = (S - C_hi) + A	
//
(p0)   fma.s1 FR_t = FR_t, f1, FR_a
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     t = t + a 
//
(p0)   fma.s1 FR_C_lo = FR_C_lo, f1, FR_t
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     C_lo = C_lo + t
//     Adjust Table_Base to beginning of table
//
(p0)   fma.s1 FR_r = FR_C_hi, f1, FR_C_lo
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Load S_2
//
(p0)   fma.s1 FR_rsq = FR_r, FR_r, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Table_Base points to C_1
//     r = C_hi + C_lo
//
(p0)   fms.s1 FR_c = FR_C_hi, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: poly = S_2 * FR_rsq + S_1
//     else        poly = C_2 * FR_rsq + C_1
//
(p11)  fma.s1 FR_Input_X = f0, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_Input_X = f0, f1, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Compute r_cube = FR_rsq * r	
//
(p11)  fma.s1 FR_poly = FR_rsq, FR_S_2, FR_S_1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_poly = FR_rsq, FR_C_2, FR_C_1
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Compute FR_rsq = r * r
//     Is i_1 == 0 ?
//
(p0)   fma.s1 FR_r_cubed = FR_rsq, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     c = C_hi - r
//     Load  C_1
//
(p0)   fma.s1 FR_c = FR_c, f1, FR_C_lo
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: poly = r_cube * poly + c
//     else        poly = FR_rsq * poly
//
(p10)  fms.s1 FR_Input_X = f0, f1, FR_Input_X
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: Result = r
//     else        Result = 1.0
//
(p11)  fma.s1 FR_poly = FR_r_cubed, FR_poly, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_0 !=0: Result = -Result 
//
(p9)   fma.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p10)  fms.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
//
//     if i_0 == 0: Result = Result + poly
//     else         Result = Result - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_SMALL_R: 

{ .mii
      nop.m 999
(p0)  	extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
//
//
//      Compare both i_1 and i_0 with 0.
//      if i_1 == 0, set p9.
//      if i_0 == 0, set p11.
//
(p0)  	cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
}

{ .mfi
      nop.m 999
(p0)  	fma.s1 FR_rsq = FR_r, FR_r, f0
(p0)  	extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
//
// 	Z = Z * FR_rsq 
//
(p10)	fnma.s1	FR_c = FR_c, FR_r, f0
(p0)  	cmp.eq.unc p11, p12 = 0x0, GR_i_0
}
;;

// ******************************************************************
// ******************************************************************
// ******************************************************************
//      r and c have been computed.
//      We know whether this is the sine or cosine routine.
//      Make sure ftz mode is set - should be automatic when using wre
//      |r| < 2**(-3)
//
//      Set table_ptr1 to beginning of constant table.
//      Get [i_0,i_1] - two lsb of N_fix_gr.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


// 
//      Set table_ptr1 to point to S_5.
//      Set table_ptr1 to point to C_5.
//      Compute FR_rsq = r * r
//

{ .mfi
(p9)  	add GR_Table_Base = 672, GR_Table_Base
(p10)	fmerge.s FR_r = f1, f1
(p10) 	add GR_Table_Base = 592, GR_Table_Base ;;
}
// 
//      Set table_ptr1 to point to S_5.
//      Set table_ptr1 to point to C_5.
//

{ .mmi
(p9)  	ldfe FR_S_5 = [GR_Table_Base], -16 ;;
//
//      if (i_1 == 0) load S_5
//      if (i_1 != 0) load C_5
//
(p9)  	ldfe FR_S_4 = [GR_Table_Base], -16
      nop.i 999 ;;
}

{ .mmf
(p10) 	ldfe FR_C_5 = [GR_Table_Base], -16
// 
//      Z = FR_rsq * FR_rsq
//
(p9)  	ldfe FR_S_3 = [GR_Table_Base], -16
//
//      Compute FR_rsq = r * r
//      if (i_1 == 0) load S_4
//      if (i_1 != 0) load C_4
//
(p0)   	fma.s1 FR_Z = FR_rsq, FR_rsq, f0 ;;
}
//
//      if (i_1 == 0) load S_3
//      if (i_1 != 0) load C_3
//

{ .mmi
(p9)  	ldfe FR_S_2 = [GR_Table_Base], -16 ;;
//
//      if (i_1 == 0) load S_2
//      if (i_1 != 0) load C_2
//
(p9)  	ldfe FR_S_1 = [GR_Table_Base], -16
      nop.i 999
}

{ .mmi
(p10) 	ldfe FR_C_4 = [GR_Table_Base], -16 ;;
(p10)  	ldfe FR_C_3 = [GR_Table_Base], -16
      nop.i 999 ;;
}

{ .mmi
(p10) 	ldfe FR_C_2 = [GR_Table_Base], -16 ;;
(p10) 	ldfe FR_C_1 = [GR_Table_Base], -16
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 != 0):
//      poly_lo = FR_rsq * C_5 + C_4
//      poly_hi = FR_rsq * C_2 + C_1
//
(p9)  	fma.s1 FR_Z = FR_Z, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0) load S_1
//      if (i_1 != 0) load C_1
//
(p9)  	fma.s1 FR_poly_lo = FR_rsq, FR_S_5, FR_S_4
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      c = -c * r
//      dummy fmpy's to flag inexact.
//
(p9)	fma.d.s0 FR_S_4 = FR_S_4, FR_S_4, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      poly_lo = FR_rsq * poly_lo + C_3
//      poly_hi = FR_rsq * poly_hi
//
(p0)    fma.s1	FR_Z = FR_Z, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)  	fma.s1 FR_poly_hi = FR_rsq, FR_S_2, FR_S_1
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0):
//      poly_lo = FR_rsq * S_5 + S_4
//      poly_hi = FR_rsq * S_2 + S_1
//
(p10) 	fma.s1 FR_poly_lo = FR_rsq, FR_C_5, FR_C_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0):
//      Z = Z * r  for only one of the small r cases - not there
//      in original implementation notes.
// 
(p9)  	fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_S_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) 	fma.s1 FR_poly_hi = FR_rsq, FR_C_2, FR_C_1
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.d.s0 FR_C_1 = FR_C_1, FR_C_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)  	fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      poly_lo = FR_rsq * poly_lo + S_3
//      poly_hi = FR_rsq * poly_hi
//
(p10) 	fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_C_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) 	fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
// 	if (i_1 == 0): dummy fmpy's to flag inexact
// 	r = 1
//
(p9)	fma.s1 FR_poly_hi = FR_r, FR_poly_hi, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
// 	poly_hi = r * poly_hi 
//
(p0)    fma.s1	FR_poly = FR_Z, FR_poly_lo, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.s1	FR_r = f0, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      poly_hi = Z * poly_lo + c	
// 	if i_0 == 1: r = -r     
//
(p0) 	fma.s1	FR_poly = FR_poly, f1, FR_poly_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.d.s0 FR_Input_X = FR_r, f1, FR_poly
      nop.i 999
}

{ .mfb
      nop.m 999
//
//      poly = poly + poly_hi	
//
(p11)	fma.d.s0 FR_Input_X = FR_r, f1, FR_poly
//
//      if (i_0 == 0) Result = r + poly
//      if (i_0 != 0) Result = r - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_NORMAL_R: 

{ .mii
      nop.m 999
(p0)	extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
//
//      Set table_ptr1 and table_ptr2 to base address of
//      constant table.
(p0)	cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
}

{ .mfi
      nop.m 999
(p0)	fma.s1	FR_rsq = FR_r, FR_r, f0
(p0)	extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
(p0)	frcpa.s1 FR_r_hi, p6 = f1, FR_r
(p0)	cmp.eq.unc p11, p12 = 0x0, GR_i_0
}
;;

// ******************************************************************
// ******************************************************************
// ******************************************************************
//
//      r and c have been computed.
//      We known whether this is the sine or cosine routine.
//      Make sure ftz mode is set - should be automatic when using wre
//      Get [i_0,i_1] - two lsb of N_fix_gr alone.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
(p10)	add GR_Table_Base = 384, GR_Table_Base
(p12)	fms.s1 FR_Input_X = f0, f1, f1
(p9)	add GR_Table_Base = 224, GR_Table_Base ;;
}

{ .mmf
      nop.m 999
(p10)	ldfe FR_QQ_8 = [GR_Table_Base], 16
//
//      if (i_1==0) poly = poly * FR_rsq + PP_1_lo
//      else        poly = FR_rsq * poly
//
(p11)	fma.s1 FR_Input_X = f0, f1, f1 ;;
}

{ .mmf
(p10)	ldfe FR_QQ_7 = [GR_Table_Base], 16
//
// 	Adjust table pointers based on i_0 
//      Compute rsq = r * r
//
(p9)	ldfe FR_PP_8 = [GR_Table_Base], 16
(p0)	fma.s1 FR_r_cubed = FR_r, FR_rsq, f0 ;;
}

{ .mmf
(p9)	ldfe FR_PP_7 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_6 = [GR_Table_Base], 16
//
//      Load PP_8 and QQ_8; PP_7 and QQ_7
//
(p0)	frcpa.s1 FR_r_hi, p6 = f1, FR_r_hi ;;
}
//
//      if (i_1==0) poly =   PP_7 + FR_rsq * PP_8.
//      else        poly =   QQ_7 + FR_rsq * QQ_8.
//

{ .mmb
(p9)	ldfe FR_PP_6 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_5 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmb
(p9)	ldfe FR_PP_5 = [GR_Table_Base], 16
(p10)	ldfe FR_S_1 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmb
(p10)	ldfe FR_QQ_1 = [GR_Table_Base], 16
(p9)	ldfe FR_C_1 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmi
(p10)	ldfe FR_QQ_4 = [GR_Table_Base], 16 ;;
(p9)	ldfe FR_PP_1 = [GR_Table_Base], 16
      nop.i 999 ;;
}

{ .mmf
(p10)	ldfe FR_QQ_3 = [GR_Table_Base], 16
//
//      if (i_1=0) corr = corr + c*c
//      else       corr = corr * c 
//
(p9)	ldfe FR_PP_4 = [GR_Table_Base], 16
(p10)	fma.s1 FR_poly = FR_rsq, FR_QQ_8, FR_QQ_7 ;;
}
//
//      if (i_1=0) poly = rsq * poly + PP_5 
//      else       poly = rsq * poly + QQ_5 
//      Load PP_4 or QQ_4
//

{ .mmf
(p9)	ldfe FR_PP_3 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_2 = [GR_Table_Base], 16
//
//      r_hi =   frcpa(frcpa(r)).
//      r_cube = r * FR_rsq.
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_PP_8, FR_PP_7 ;;
}
//
//      Do dummy multiplies so inexact is always set. 
//

{ .mfi
(p9)	ldfe FR_PP_2 = [GR_Table_Base], 16
//
//      r_lo = r - r_hi	
//
(p9)	fma.s1 FR_U_lo = FR_r_hi, FR_r_hi, f0
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p9)	ldfe FR_PP_1_lo = [GR_Table_Base], 16
(p10)	fma.s1 FR_corr = FR_S_1, FR_r_cubed, FR_r
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_6
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_lo = r_hi * r_hi
//      else       U_lo = r_hi + r
//
(p9)	fma.s1 FR_corr = FR_C_1, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) corr = C_1 * rsq
//      else       corr = S_1 * r_cubed + r
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_6
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_r_hi, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_hi = r_hi + U_hi 
//      else       U_hi = QQ_1 * U_hi + 1
//
(p9)	fma.s1 FR_U_lo = FR_r, FR_r_hi, FR_U_lo
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      U_hi = r_hi * r_hi	
//
(p0)	fms.s1 FR_r_lo = FR_r, f1, FR_r_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      Load PP_1, PP_6, PP_5, and C_1
//      Load QQ_1, QQ_6, QQ_5, and S_1
//
(p0)	fma.s1 FR_U_hi = FR_r_hi, FR_r_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_5
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fnma.s1	FR_corr = FR_corr, FR_c, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_lo = r * r_hi + U_lo 
//      else       U_lo = r_lo * U_lo
//
(p9)	fma.s1 FR_corr = FR_corr, FR_c, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_5
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 =0) U_hi = r + U_hi
//      if (i_1 =0) U_lo = r_lo * U_lo 
//      
//
(p9)	fma.d.s0 FR_PP_5 = FR_PP_5, FR_PP_4, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_lo = FR_r, FR_r, FR_U_lo
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) poly = poly * rsq + PP_6
//      else       poly = poly * rsq + QQ_6 
//
(p9)	fma.s1 FR_U_hi = FR_r_hi, FR_U_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_4
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_hi = FR_QQ_1, FR_U_hi, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.d.s0 FR_QQ_5 = FR_QQ_5, FR_QQ_5, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1!=0) U_hi = PP_1 * U_hi  
//      if (i_1!=0) U_lo = r * r  + U_lo  
//      Load PP_3 or QQ_3
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_QQ_1,FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_hi = FR_PP_1, FR_U_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      Load PP_2, QQ_2
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly = FR_rsq * poly  + PP_3
//      else        poly = FR_rsq * poly  + QQ_3
//      Load PP_1_lo
//
(p9)	fma.s1 FR_U_lo = FR_PP_1, FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 =0) poly = poly * rsq + pp_r4
//      else        poly = poly * rsq + qq_r4
//
(p9)	fma.s1 FR_U_hi = FR_r, f1, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) U_lo =  PP_1_hi * U_lo
//      else        U_lo =  QQ_1 * U_lo
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_0==0)  Result = 1
//      else         Result = -1
//
(p0) 	fma.s1 FR_V = FR_U_lo, f1, FR_corr
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly =  FR_rsq * poly + PP_2
//      else poly =  FR_rsq * poly + QQ_2
// 
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_1_lo
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      V = U_lo + corr
//
(p9)	fma.s1 FR_poly = FR_r_cubed, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly = r_cube * poly
//      else        poly = FR_rsq * poly
//
(p0)	fma.s1	FR_V = FR_poly, f1, FR_V
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.d.s0 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
      nop.i 999
}

{ .mfb
      nop.m 999
//
//      V = V + poly	
//
(p11)	fma.d.s0 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
//
//      if (i_0==0) Result = Result * U_hi + V
//      else        Result = Result * U_hi - V
//
(p0)   br.ret.sptk   b0 ;;
}

//
//      If cosine, FR_Input_X = 1
//      If sine, FR_Input_X = +/-Zero (Input FR_Input_X)
//      Results are exact, no exceptions
//
SINCOS_ZERO:

{ .mmb
(p0)    cmp.eq.unc p6, p7 = 0x1, GR_Sin_or_Cos
      nop.m 999
      nop.b 999 ;;
}

{ .mfi
      nop.m 999
(p7)    fmerge.s FR_Input_X = FR_Input_X, FR_Input_X
      nop.i 999
}

{ .mfb
      nop.m 999
(p6)    fmerge.s FR_Input_X = f1, f1
(p0)   br.ret.sptk   b0 ;;
}

SINCOS_SPECIAL:

//
//      Path for Arg = +/- QNaN, SNaN, Inf
//      Invalid can be raised. SNaNs
//      become QNaNs
//

{ .mfb
      nop.m 999
(p0)    fmpy.d.s0 FR_Input_X = FR_Input_X, f0
(p0)    br.ret.sptk   b0 ;;
}
.endp __libm_cos_double_dbx#



//
//      Call int pi_by_2_reduce(double* x, double *y)
//      for |arguments| >= 2**63
//      Address to save r and c as double 
//
//      
//      psp    sp+64
//             sp+48  -> f0 c
//      r45    sp+32  -> f0 r
//      r44 -> sp+16  -> InputX  
//      sp     sp     -> scratch provided to callee



.proc __libm_callout_2
__libm_callout_2:
SINCOS_ARG_TOO_LARGE:

.prologue
{ .mfi
        add   r45=-32,sp                        // Parameter: r address
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfe [r45] = f0,16                      // Clear Parameter r on stack
        add  r44 = 16,sp                        // Parameter x address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfe [r45] = f0,-16                     // Clear Parameter c on stack
        nop.i 0
        nop.b 0
}
{ .mib
        stfe [r44] = FR_Input_X                 // Store Parameter x on stack
        nop.i 0
(p0)    br.call.sptk b0=__libm_pi_by_2_reduce# ;;
};;


{ .mii
(p0)    ldfe  FR_Input_X =[r44],16
//
//      Get r and c off stack
//
(p0)    adds  GR_Table_Base1 = -16, GR_Table_Base1
//
//      Get r and c off stack
//
(p0)    add   GR_N_Inc = GR_Sin_or_Cos,r8 ;;
}
{ .mmb
(p0)    ldfe  FR_r =[r45],16
//
//      Get X off the stack
//      Readjust Table ptr
//
(p0)    ldfs FR_Two_to_M3 = [GR_Table_Base1],4
        nop.b 999 ;;
}
{ .mmb
(p0)    ldfs FR_Neg_Two_to_M3 = [GR_Table_Base1],0
(p0)    ldfe  FR_c =[r45]
        nop.b 999 ;;
}

{ .mfi
.restore
        add   sp = 64,sp                       // Restore stack pointer
(p0)    fcmp.lt.unc.s1  p6, p0 = FR_r, FR_Two_to_M3
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        nop.b 0
};;


{ .mfi
      nop.m 999
(p6)    fcmp.gt.unc.s1	p6, p0 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p6)    br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p0)    br.cond.sptk SINCOS_NORMAL_R ;;
}

.endp __libm_callout_2

.type   __libm_pi_by_2_reduce#,@function
.global __libm_pi_by_2_reduce#


.type __libm_sin_double_dbx#,@function
.global __libm_sin_double_dbx#
.type __libm_cos_double_dbx#,@function
.global __libm_cos_double_dbx#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sincosf.s ===
.file "sincosf.s"


// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.


// History
//==============================================================
// 2/02/00  Initial revision 
// 4/02/00  Unwind support added.
// 5/10/00  Improved speed with new algorithm.
// 8/08/00  Improved speed by avoiding SIR flush.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 8/30/00  Put sin_of_r before sin_tbl_S_cos_of_r to gain a cycle 
//
// API
//==============================================================
// float sinf( float x);
// float cosf( float x);
//
// Assembly macros
//==============================================================

// SIN_Sin_Flag               = p6
// SIN_Cos_Flag               = p7

// integer registers used

 SIN_AD_PQ_1                = r33
 SIN_AD_PQ_2                = r34
 sin_GR_Mint                = r35

 sin_GR_index               = r36
 GR_SAVE_B0                 = r37
 GR_SAVE_GP                 = r38
 GR_SAVE_PFS                = r39


// floating point registers used

 sin_coeff_P1               = f32
 sin_coeff_P2               = f33
 sin_coeff_Q1               = f34
 sin_coeff_Q2               = f35
 sin_coeff_P4               = f36
 sin_coeff_P5               = f37
 sin_coeff_Q4               = f38
 sin_coeff_Q5               = f39
 sin_Mx                     = f40
 sin_Mfloat                 = f41
 sin_tbl_S                  = f42
 sin_tbl_C                  = f43
 sin_r                      = f44
 sin_rcube                  = f45
 sin_tsq                    = f46
 sin_r7                     = f47
 sin_t                      = f48
 sin_poly_p2                = f49
 sin_poly_p1                = f50
// f51
 sin_poly_p3                = f52
 sin_poly_p4                = f53
 sin_of_r                   = f54
 sin_S_t                    = f55
 sin_poly_q2                = f56
 sin_poly_q1                = f57
 sin_S_tcube                = f58
 sin_poly_q3                = f59
 sin_poly_q4                = f60
 sin_tbl_S_tcube            = f61
 sin_tbl_S_cos_of_r         = f62

 sin_coeff_Q3               = f63
 sin_coeff_P3               = f64

 sin_coeff_Q6               = f65
 sin_poly_q5                = f66
 sin_poly_q12               = f67
 sin_poly_q3456             = f68


.data

.align 16

sin_coeff_1_table:
data8 0xBFC55555555554CA       // p1
data8 0x3F811111110F2395       // p2
data8 0x3EC71DD1D5E421A4       // p4
data8 0xBE5AC5C9D0ACF95A       // p5
data8 0xBE927E42FDF33FFE       // q5
data8 0xBF2A01A011232913       // p3
 


sin_coeff_2_table:
data8 0xBFE0000000000000       // q1
data8 0x3FA55555555554EF       // q2
data8 0xBF56C16C16BF6462       // q3
data8 0x3EFA01A0128B9EBC       // q4
data8 0x3E21DA5C72A446F3       // q6
data8 0x0000000000000000       // pad


/////////////////////////////////////////

data8 0xBFE1A54991426566   //sin(-32)
data8 0x3FEAB1F5305DE8E5   //cos(-32)
data8 0x3FD9DBC0B640FC81   //sin(-31)
data8 0x3FED4591C3E12A20   //cos(-31)
data8 0x3FEF9DF47F1C903D   //sin(-30)
data8 0x3FC3BE82F2505A52   //cos(-30)
data8 0x3FE53C7D20A6C9E7   //sin(-29)
data8 0xBFE7F01658314E47   //cos(-29)
data8 0xBFD156853B4514D6   //sin(-28)
data8 0xBFEECDAAD1582500   //cos(-28)
data8 0xBFEE9AA1B0E5BA30   //sin(-27)
data8 0xBFD2B266F959DED5   //cos(-27)
data8 0xBFE866E0FAC32583   //sin(-26)
data8 0x3FE4B3902691A9ED   //cos(-26)
data8 0x3FC0F0E6F31E809D   //sin(-25)
data8 0x3FEFB7EEF59504FF   //cos(-25)
data8 0x3FECFA7F7919140F   //sin(-24)
data8 0x3FDB25BFB50A609A   //cos(-24)
data8 0x3FEB143CD0247D02   //sin(-23)
data8 0xBFE10CF7D591F272   //cos(-23)
data8 0x3F8220A29F6EB9F4   //sin(-22)
data8 0xBFEFFFADD8D4ACDA   //cos(-22)
data8 0xBFEAC5E20BB0D7ED   //sin(-21)
data8 0xBFE186FF83773759   //cos(-21)
data8 0xBFED36D8F55D3CE0   //sin(-20)
data8 0x3FDA1E043964A83F   //cos(-20)
data8 0xBFC32F2D28F584CF   //sin(-19)
data8 0x3FEFA377DE108258   //cos(-19)
data8 0x3FE8081668131E26   //sin(-18)
data8 0x3FE52150815D2470   //cos(-18)
data8 0x3FEEC3C4AC42882B   //sin(-17)
data8 0xBFD19C46B07F58E7   //cos(-17)
data8 0x3FD26D02085F20F8   //sin(-16)
data8 0xBFEEA5257E962F74   //cos(-16)
data8 0xBFE4CF2871CEC2E8   //sin(-15)
data8 0xBFE84F5D069CA4F3   //cos(-15)
data8 0xBFEFB30E327C5E45   //sin(-14)
data8 0x3FC1809AEC2CA0ED   //cos(-14)
data8 0xBFDAE4044881C506   //sin(-13)
data8 0x3FED09CDD5260CB7   //cos(-13)
data8 0x3FE12B9AF7D765A5   //sin(-12)
data8 0x3FEB00DA046B65E3   //cos(-12)
data8 0x3FEFFFEB762E93EB   //sin(-11)
data8 0x3F7220AE41EE2FDF   //cos(-11)
data8 0x3FE1689EF5F34F52   //sin(-10)
data8 0xBFEAD9AC890C6B1F   //cos(-10)
data8 0xBFDA6026360C2F91   //sin( -9)
data8 0xBFED27FAA6A6196B   //cos( -9)
data8 0xBFEFA8D2A028CF7B   //sin( -8)
data8 0xBFC29FBEBF632F94   //cos( -8)
data8 0xBFE50608C26D0A08   //sin( -7)
data8 0x3FE81FF79ED92017   //cos( -7)
data8 0x3FD1E1F18AB0A2C0   //sin( -6)
data8 0x3FEEB9B7097822F5   //cos( -6)
data8 0x3FEEAF81F5E09933   //sin( -5)
data8 0x3FD22785706B4AD9   //cos( -5)
data8 0x3FE837B9DDDC1EAE   //sin( -4)
data8 0xBFE4EAA606DB24C1   //cos( -4)
data8 0xBFC210386DB6D55B   //sin( -3)
data8 0xBFEFAE04BE85E5D2   //cos( -3)
data8 0xBFED18F6EAD1B446   //sin( -2)
data8 0xBFDAA22657537205   //cos( -2)
data8 0xBFEAED548F090CEE   //sin( -1)
data8 0x3FE14A280FB5068C   //cos( -1)
data8 0x0000000000000000   //sin(  0)
data8 0x3FF0000000000000   //cos(  0)
data8 0x3FEAED548F090CEE   //sin(  1)
data8 0x3FE14A280FB5068C   //cos(  1)
data8 0x3FED18F6EAD1B446   //sin(  2)
data8 0xBFDAA22657537205   //cos(  2)
data8 0x3FC210386DB6D55B   //sin(  3)
data8 0xBFEFAE04BE85E5D2   //cos(  3)
data8 0xBFE837B9DDDC1EAE   //sin(  4)
data8 0xBFE4EAA606DB24C1   //cos(  4)
data8 0xBFEEAF81F5E09933   //sin(  5)
data8 0x3FD22785706B4AD9   //cos(  5)
data8 0xBFD1E1F18AB0A2C0   //sin(  6)
data8 0x3FEEB9B7097822F5   //cos(  6)
data8 0x3FE50608C26D0A08   //sin(  7)
data8 0x3FE81FF79ED92017   //cos(  7)
data8 0x3FEFA8D2A028CF7B   //sin(  8)
data8 0xBFC29FBEBF632F94   //cos(  8)
data8 0x3FDA6026360C2F91   //sin(  9)
data8 0xBFED27FAA6A6196B   //cos(  9)
data8 0xBFE1689EF5F34F52   //sin( 10)
data8 0xBFEAD9AC890C6B1F   //cos( 10)
data8 0xBFEFFFEB762E93EB   //sin( 11)
data8 0x3F7220AE41EE2FDF   //cos( 11)
data8 0xBFE12B9AF7D765A5   //sin( 12)
data8 0x3FEB00DA046B65E3   //cos( 12)
data8 0x3FDAE4044881C506   //sin( 13)
data8 0x3FED09CDD5260CB7   //cos( 13)
data8 0x3FEFB30E327C5E45   //sin( 14)
data8 0x3FC1809AEC2CA0ED   //cos( 14)
data8 0x3FE4CF2871CEC2E8   //sin( 15)
data8 0xBFE84F5D069CA4F3   //cos( 15)
data8 0xBFD26D02085F20F8   //sin( 16)
data8 0xBFEEA5257E962F74   //cos( 16)
data8 0xBFEEC3C4AC42882B   //sin( 17)
data8 0xBFD19C46B07F58E7   //cos( 17)
data8 0xBFE8081668131E26   //sin( 18)
data8 0x3FE52150815D2470   //cos( 18)
data8 0x3FC32F2D28F584CF   //sin( 19)
data8 0x3FEFA377DE108258   //cos( 19)
data8 0x3FED36D8F55D3CE0   //sin( 20)
data8 0x3FDA1E043964A83F   //cos( 20)
data8 0x3FEAC5E20BB0D7ED   //sin( 21)
data8 0xBFE186FF83773759   //cos( 21)
data8 0xBF8220A29F6EB9F4   //sin( 22)
data8 0xBFEFFFADD8D4ACDA   //cos( 22)
data8 0xBFEB143CD0247D02   //sin( 23)
data8 0xBFE10CF7D591F272   //cos( 23)
data8 0xBFECFA7F7919140F   //sin( 24)
data8 0x3FDB25BFB50A609A   //cos( 24)
data8 0xBFC0F0E6F31E809D   //sin( 25)
data8 0x3FEFB7EEF59504FF   //cos( 25)
data8 0x3FE866E0FAC32583   //sin( 26)
data8 0x3FE4B3902691A9ED   //cos( 26)
data8 0x3FEE9AA1B0E5BA30   //sin( 27)
data8 0xBFD2B266F959DED5   //cos( 27)
data8 0x3FD156853B4514D6   //sin( 28)
data8 0xBFEECDAAD1582500   //cos( 28)
data8 0xBFE53C7D20A6C9E7   //sin( 29)
data8 0xBFE7F01658314E47   //cos( 29)
data8 0xBFEF9DF47F1C903D   //sin( 30)
data8 0x3FC3BE82F2505A52   //cos( 30)
data8 0xBFD9DBC0B640FC81   //sin( 31)
data8 0x3FED4591C3E12A20   //cos( 31)
data8 0x3FE1A54991426566   //sin( 32)
data8 0x3FEAB1F5305DE8E5   //cos( 32)

//////////////////////////////////////////

// SIN_Sin_Flag is set to 0 for sin, and 1 for cosine

.global sinf
.global cosf

.text
.proc cosf
.align 32


cosf:
{ .mfi
     alloc          r32                      = ar.pfs,1,7,0,0
     fcvt.fx.s1     sin_Mx                   =    f8
     addl           SIN_AD_PQ_1              =    @ltoff(sin_coeff_1_table),gp
}
{ .mfi
//     cmp.ne    SIN_Sin_Flag,SIN_Cos_Flag     =    r0,r0
     cmp.ne    p6,p7     =    r0,r0
     nop.f 999
     addl      SIN_AD_PQ_2                   =    @ltoff(sin_coeff_2_table),gp
}
;;
{ .mmb
     ld8       SIN_AD_PQ_1    =    [SIN_AD_PQ_1]
     ld8       SIN_AD_PQ_2    =    [SIN_AD_PQ_2]
     br.sptk SINCOSF_COMMON
}
.endp cosf


.text
.proc  sinf
.align 32

sinf:
{ .mfi
     alloc          r32                      = ar.pfs,1,7,0,0
     fcvt.fx.s1     sin_Mx                   =    f8
     addl           SIN_AD_PQ_1              =    @ltoff(sin_coeff_1_table),gp
}
{ .mfi
//     cmp.eq    SIN_Sin_Flag,SIN_Cos_Flag     =    r0,r0
     cmp.eq    p6,p7     =    r0,r0
     nop.f     999
     addl      SIN_AD_PQ_2                   =    @ltoff(sin_coeff_2_table),gp
}
;;

{ .mmf
     ld8       SIN_AD_PQ_1    =    [SIN_AD_PQ_1]
     ld8       SIN_AD_PQ_2    =    [SIN_AD_PQ_2]
     nop.f     999
}
;;


SINCOSF_COMMON:

////////////////////////////////////////////
// need to special case Cos(0) = 1.0 
// (SIN_Cos_Flag)     fclass.m.unc  p8,p0       =    f8, 0x07
// (p8) fmerge.s      f8 = f1,f1
// (p8) br.ret.spnt b0
// need to special case sin(-0) = -0
// 
// 

//////////////////////////////////////////////////////////////////////
// We dont really have to test for Nan because an input Nan does return
// quiet version

//                    fclass.m.unc  p10,p0      =    f8, 0xc3	//@snan | @qnan 
// (p10)              fma.s         f8          =    f8,f1,f0
// (p10               br.ret.spnt   b0
// 

//////////////////////////////////////////////////////////////////////
// Same for +- infinity
//                    fclass.m.unc  p11,p0      =    f8, 0x23	//@inf
// (p11)              frcpa.s1      f8,p12      =    f0,f0
// (p11)              br.ret.spnt   b0




{ .mmf
      ldfpd      sin_coeff_P1, sin_coeff_P2     = [SIN_AD_PQ_1], 16
      ldfpd      sin_coeff_Q1, sin_coeff_Q2     = [SIN_AD_PQ_2], 16
//(SIN_Sin_Flag)   fclass.m.unc  p13,p0       =    f8, 0x07
(p6)   fclass.m.unc  p13,p0       =    f8, 0x07
}
;;

{ .mmf
      ldfpd      sin_coeff_P4, sin_coeff_P5     = [SIN_AD_PQ_1], 16
      ldfpd      sin_coeff_Q3, sin_coeff_Q4     = [SIN_AD_PQ_2], 16
//(SIN_Cos_Flag)   fclass.m.unc  p8,p0       =    f8, 0x07
(p7)   fclass.m.unc  p8,p0       =    f8, 0x07
}
;;

{ .mmf
      ldfpd      sin_coeff_Q5, sin_coeff_P3     = [SIN_AD_PQ_1], 16
      ldfd       sin_coeff_Q6                   = [SIN_AD_PQ_2], 16 
      fcvt.xf    sin_Mfloat                     =    sin_Mx
}
;;

{     .mfb
     getf.sig  sin_GR_Mint    =    sin_Mx
     nop.f                      999
(p13) br.ret.spnt b0
}
;;

{     .mfb
     nop.m                      999
(p8) fma.s      f8 = f1,f1,f0
(p8) br.ret.spnt b0
}
;;

{     .mfi
     add       sin_GR_index   =    32,sin_GR_Mint
     nop.f                      999
     cmp.ge    p8,p9          = -33,sin_GR_Mint
}
;;

{ .mfi
(p9) cmp.le    p10,p11        = 33, sin_GR_Mint 
     nop.f                      999
     shl       sin_GR_index   =    sin_GR_index,4
}
;;


{     .mfb
     nop.m                 999
     fnma.s1   sin_r     =    f1,sin_Mfloat,f8
(p8) br.cond.spnt SIN_DOUBLE
}
{    .mfb
     nop.m                 999
     nop.f                 999
(p10) br.cond.spnt SIN_DOUBLE
}
;;

{     .mfi
     nop.m                      999
     nop.f                      999
     add       SIN_AD_PQ_2    =    sin_GR_index,SIN_AD_PQ_2
}
;;

{     .mfi
     nop.m                 999
     fma.s1    sin_t     =    sin_r,sin_r,f0
     nop.i                 999
}
;;

.pred.rel "mutex",p6,p7    //SIN_Sin_Flag, SIN_Cos_Flag
{     .mmi
//(SIN_Sin_Flag) ldfpd     sin_tbl_S,sin_tbl_C =    [SIN_AD_PQ_2]
(p6) ldfpd     sin_tbl_S,sin_tbl_C =    [SIN_AD_PQ_2]
//(SIN_Cos_Flag) ldfpd     sin_tbl_C,sin_tbl_S =    [SIN_AD_PQ_2]
(p7) ldfpd     sin_tbl_C,sin_tbl_S =    [SIN_AD_PQ_2]
               nop.i                           999
}
;;

{     .mfi
     nop.m                 999
     fma.s1    sin_rcube =    sin_t,sin_r,f0
     nop.i                 999
}
{     .mfi
     nop.m                 999
     fma.s1    sin_tsq   =    sin_t,sin_t,f0
     nop.i                 999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q3    =    sin_t,sin_coeff_Q4,sin_coeff_Q3
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q5    =    sin_t,sin_coeff_Q6,sin_coeff_Q5
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p1    =    sin_t,sin_coeff_P5,sin_coeff_P4
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q1    =    sin_t,sin_coeff_Q2,sin_coeff_Q1
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p2    =    sin_t,sin_coeff_P2,sin_coeff_P1
     nop.i                      999
}
;;

{     .mfi
     nop.m                 999
     fma.s1    sin_S_t   =    sin_t,sin_tbl_S,f0
     nop.i                 999
}
{     .mfi
     nop.m                 999
     fma.s1    sin_r7    =    sin_rcube,sin_tsq,f0
     nop.i                 999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q3456 =    sin_tsq,sin_poly_q5,sin_poly_q3
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p3    =    sin_t,sin_poly_p1,sin_coeff_P3
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p4    =    sin_rcube,sin_poly_p2,sin_r
     nop.i                      999
}
;;

{     .mfi
     nop.m                           999
     fma.s1    sin_tbl_S_tcube     =    sin_S_t,sin_tsq,f0
     nop.i                           999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q12   =    sin_S_t,sin_poly_q1,sin_tbl_S
     nop.i                      999
}
;;

{     .mfi
     nop.m                 999
     fma.d.s1  sin_of_r  =    sin_r7,sin_poly_p3,sin_poly_p4
     nop.i                 999
}
;;

{     .mfi
     nop.m                           999
     fma.d.s1  sin_tbl_S_cos_of_r  =    sin_tbl_S_tcube,sin_poly_q3456,sin_poly_q12
     nop.i                           999
}
;;


.pred.rel "mutex",p6,p7    //SIN_Sin_Flag, SIN_Cos_Flag
{     .mfi
               nop.m            999
//(SIN_Sin_Flag) fma.s     f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
(p6) fma.s     f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
               nop.i            999
}
{     .mfb
               nop.m            999
//(SIN_Cos_Flag) fnma.s    f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
(p7) fnma.s    f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
               br.ret.sptk     b0
}

.endp sinf


.proc SIN_DOUBLE 
SIN_DOUBLE:
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mbb
       nop.m 999
(p6)   br.call.sptk.many   b0=sin 
(p7)   br.call.sptk.many   b0=cos
}
;;

{ .mfi
(p0)   mov gp        = GR_SAVE_GP
       nop.f  999
(p0)   mov b0        = GR_SAVE_B0
}
;;

{ .mfi
      nop.m 999
      fma.s f8 = f8,f1,f0
(p0)  mov ar.pfs    = GR_SAVE_PFS
}
{ .mib
      nop.m 999
      nop.i 999
(p0)  br.ret.sptk     b0 
}
.endp  SIN_DOUBLE 

.type sin,@function
.global sin 
.type cos,@function
.global cos
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sqrt.s ===
.file "sqrt.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//********************************************************************
// History
//********************************************************************
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//********************************************************************
//
// Function:   Combined sqrt(x), where
//                        _
//             sqrt(x) = |x, for double precision x values
//
//********************************************************************
//
// Accuracy:       Correctly Rounded
//
//********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f7 -f14
//
//    General Purpose Registers:
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6, p7, p8
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    sqrt(QNaN) = QNaN
//    sqrt(SNaN) = QNaN
//    sqrt(+/-0) = +/-0
//    sqrt(negative) = QNaN and error handling is called
//
//*********************************************************************
//
// Implementation:
//
//  Modified Newton-Raphson Algorithm
//
//*********************************************************************

GR_SAVE_PFS          = r33
GR_SAVE_B0           = r34
GR_SAVE_GP           = r35

GR_Parameter_X       = r37
GR_Parameter_Y       = r38
GR_Parameter_RESULT  = r39


.section .text
.proc sqrt#
.global sqrt#
.align 64 

sqrt:
{ .mfi
  alloc r32= ar.pfs,0,5,4,0
  frsqrta.s0 f7,p6=f8
  nop.i 0
} { .mlx
  // BEGIN DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
  nop.m 0
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe;;
} { .mmi
  // +1/2 in f9
  setf.exp f9 = r2
  nop.m 0
  nop.i 0
} { .mlx
  nop.m 0
  // 3/2 in r3
  movl r3=0x3fc00000;;
} { .mfi
  setf.s f10=r3
  // Step (1)
  // y0 = 1/sqrt(a) in f7
  fclass.m.unc p7,p8 = f8,0x3A 
  nop.i 0;;
} { .mlx
  nop.m 0
  // 5/2 in r2
  movl r2 = 0x40200000
} { .mlx
  nop.m 0
  // 63/8 in r3
  movl r3 = 0x40fc0000;;
} { .mfi
  setf.s f11=r2
  // Step (2)
  // h = +1/2 * y0 in f6
  (p6) fma.s1 f6=f9,f7,f0
  nop.i 0
} { .mfi
  setf.s f12=r3
  // Step (3)
  // g = a * y0 in f7
  (p6) fma.s1 f7=f8,f7,f0
  nop.i 0
} { .mfi
  nop.m 0
  mov   f15 = f8
  nop.i 0;;
} { .mlx
  nop.m 0
  // 231/16 in r2
  movl r2 = 0x41670000;;
} { .mfi
  setf.s f13=r2
  // Step (4)
  // e = 1/2 - g * h in f9
  (p6) fnma.s1 f9=f7,f6,f9
  nop.i 0
} { .mlx
  nop.m 0
  // 35/8 in r3
  movl r3 = 0x408c0000;;
} { .mfi
  setf.s f14=r3
  // Step (5)
  // S = 3/2 + 5/2 * e in f10
  (p6) fma.s1 f10=f11,f9,f10
  nop.i 0
} { .mfi
  nop.m 0
  // Step (6)
  // e2 = e * e in f11
  (p6) fma.s1 f11=f9,f9,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (7)
  // t = 63/8 + 231/16 * e in f12
  (p6) fma.s1 f12=f13,f9,f12
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (8)
  // S1 = e + e2 * S in f10
  (p6) fma.s1 f10=f11,f10,f9
  nop.i 0
} { .mfi
  nop.m 0
  // Step (9)
  // e4 = e2 * e2 in f11
  (p6) fma.s1 f11=f11,f11,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (10)
  // t1 = 35/8 + e * t in f9
  (p6) fma.s1 f9=f9,f12,f14
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (11)
  // G = g + S1 * g in f12
  (p6) fma.s1 f12=f10,f7,f7
  nop.i 0
} { .mfi
  nop.m 0
  // Step (12)
  // E = g * e4 in f7
  (p6) fma.s1 f7=f7,f11,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (13)
  // u = S1 + e4 * t1 in f10
  (p6) fma.s1 f10=f11,f9,f10
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (14)
  // g1 = G + t1 * E in f7
  (p6) fma.d.s1 f7=f9,f7,f12
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (15)
  // h1 = h + u * h in f6
  (p6) fma.s1 f6=f10,f6,f6
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (16)
  // d = a - g1 * g1 in f9
  (p6) fnma.s1 f9=f7,f7,f8
  nop.i 0;;
} { .mfb
  nop.m 0
  // Step (17)
  // g2 = g1 + d * h1 in f7
  (p6) fma.d.s0 f8=f9,f6,f7
  (p6) br.ret.sptk b0 ;;
} 

{ .mfb
  nop.m 0
  (p0) mov   f8 = f7
  (p8) br.ret.sptk b0 ;;
}
{ .mfb
  (p7) mov   r40 = 49
  nop.f 0
  (p7) br.cond.sptk __libm_error_region ;;
}
// END DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
.endp sqrt#

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs


.proc __libm_error_region
__libm_error_region:

//
// This branch includes all those special values that are not negative,
// with the result equal to frcpa(x)
// 

.prologue
// We are distinguishing between over(under)flow and letting
// __libm_error_support set ERANGE or do anything else needed.

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f15                    // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfd [GR_Parameter_Y] = f8                     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#          // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region




.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_atan.s ===
#include "atan.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sinh.s ===
.file "sinh.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 10/12/00 Update to set denormal operand and underflow flags
//
// API
//==============================================================
// double = sinh(double)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers: 
// r32 -> r47
// predicate registers used:
// p6 p7 p8 p9
// floating-point registers used:
// f9 -> f15; f32 -> f44; 
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are four paths
// 1. |x| < 0.25        SINH_BY_POLY
// 2. |x| < 32          SINH_BY_TBL
// 3. |x| < 2^14        SINH_BY_EXP
// 4. |x_ >= 2^14       SINH_HUGE
//
// For double extended we get infinity for x >= 400c b174 ddc0 31ae c0ea
//                                           >= 1.0110001.... x 2^13
//                                           >= 11357.2166
//
// But for double we get infinity for x >= 408633ce8fb9f87e
//                                      >= 1.0110...x 2^9
//                                      >= +7.10476e+002
//
// And for single we get infinity for x >= 42b3a496
//                                      >= 1.0110... 2^6
//                                      >= 89.8215
//
// SAFE: If there is danger of overflow set SAFE to 0
//       NOT implemented: if there is danger of underflow, set SAFE to 0
// SAFE for all paths listed below
//
// 1. SINH_BY_POLY
// ===============
// If |x| is less than the tiny threshold, then clear SAFE 
// For double, the tiny threshold is -1022 = -0x3fe => -3fe + ffff = fc01
//             register-biased, this is fc01
// For single, the tiny threshold is -126  = -7e    => -7e  + ffff = ff81
// If |x| < tiny threshold, set SAFE = 0
//
// 2. SINH_BY_TBL
// =============
// SAFE: SAFE is always 1 for TBL; 
//
// 3. SINH_BY_EXP
// ==============
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// r34 has N-1; 16382 is in register biased form, 0x13ffd
// There is danger of double overflow if N-1 > 0x3fe
//                       in register biased form, 0x103fd
// Analagously, there is danger of single overflow if N-1 > 0x7e
//                       in register biased form, 0x1007d
// SAFE: If there is danger of overflow set SAFE to 0
//
// 4. SINH_HUGE
// ============
// SAFE: SAFE is always 0 for HUGE
//
// Assembly macros
//==============================================================
sinh_FR_X            = f44
sinh_FR_X2           = f9
sinh_FR_X4           = f10
sinh_FR_SGNX         = f40

sinh_FR_Inv_log2by64 = f9
sinh_FR_log2by64_lo  = f11
sinh_FR_log2by64_hi  = f10

sinh_FR_A1           = f9
sinh_FR_A2           = f10
sinh_FR_A3           = f11

sinh_FR_Rcub         = f12
sinh_FR_M_temp       = f13
sinh_FR_R_temp       = f13
sinh_FR_Rsq          = f13
sinh_FR_R            = f14

sinh_FR_M            = f38

sinh_FR_B1           = f15
sinh_FR_B2           = f32
sinh_FR_B3           = f33

sinh_FR_peven_temp1  = f34
sinh_FR_peven_temp2  = f35
sinh_FR_peven        = f36

sinh_FR_podd_temp1   = f34
sinh_FR_podd_temp2   = f35
sinh_FR_podd         = f37

sinh_FR_poly_podd_temp1    =  f11 
sinh_FR_poly_podd_temp2    =  f13
sinh_FR_poly_peven_temp1   =  f11
sinh_FR_poly_peven_temp2   =  f13

sinh_FR_J_temp       = f9
sinh_FR_J            = f10

sinh_FR_Mmj          = f39

sinh_FR_N_temp1      = f11
sinh_FR_N_temp2      = f12
sinh_FR_N            = f13

sinh_FR_spos         = f14
sinh_FR_sneg         = f15

sinh_FR_Tjhi         = f32
sinh_FR_Tjlo         = f33
sinh_FR_Tmjhi        = f34
sinh_FR_Tmjlo        = f35

sinh_GR_mJ           = r35
sinh_GR_J            = r36

sinh_AD_mJ           = r38
sinh_AD_J            = r39

sinh_FR_S_hi         = f9
sinh_FR_S_hi_temp    = f10
sinh_FR_S_lo_temp1   = f11 
sinh_FR_S_lo_temp2   = f12 
sinh_FR_S_lo_temp3   = f13 

sinh_FR_S_lo         = f38
sinh_FR_C_hi         = f39

sinh_FR_C_hi_temp1   = f10
sinh_FR_Y_hi         = f11 
sinh_FR_Y_lo_temp    = f12 
sinh_FR_Y_lo         = f13 
sinh_FR_SINH         = f9

sinh_FR_P1           = f14
sinh_FR_P2           = f15
sinh_FR_P3           = f32
sinh_FR_P4           = f33
sinh_FR_P5           = f34
sinh_FR_P6           = f35

sinh_FR_TINY_THRESH  = f9

sinh_FR_SINH_temp    = f10
sinh_FR_SCALE        = f11 

sinh_FR_signed_hi_lo = f10


GR_SAVE_PFS          = r41
GR_SAVE_B0           = r42
GR_SAVE_GP           = r43

GR_Parameter_X       = r44
GR_Parameter_Y       = r45
GR_Parameter_RESULT  = r46

// Data tables
//==============================================================

.data

.align 16
double_sinh_arg_reduction:
   data8 0xB8AA3B295C17F0BC, 0x00004005
   data8 0xB17217F7D1000000, 0x00003FF8
   data8 0xCF79ABC9E3B39804, 0x00003FD0

double_sinh_p_table:
   data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC
   data8 0x8888888888888412, 0x00003FF8
   data8 0xD00D00D00D4D39F2, 0x00003FF2
   data8 0xB8EF1D28926D8891, 0x00003FEC
   data8 0xD732377688025BE9, 0x00003FE5
   data8 0xB08AF9AE78C1239F, 0x00003FDE

double_sinh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC
   data8 0x88888888884ECDD5, 0x00003FF8
   data8 0xD00D0C6DCC26A86B, 0x00003FF2
   data8 0x8000000000000002, 0x00003FFE
   data8 0xAAAAAAAAAA402C77, 0x00003FFA
   data8 0xB60B6CC96BDB144D, 0x00003FF5

double_sinh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global sinh#

.section .text
.proc  sinh#
.align 32

sinh: 

// X infinity or NAN?
// Take invalid fault if enabled


{ .mfi
      alloc r32 = ar.pfs,0,12,4,0                  
(p0)     fclass.m.unc  p6,p0 = f8, 0xe3	//@qnan | @snan | @inf 
      nop.i 999
}
;;


{ .mfb
         nop.m 999
(p6)     fma.d.s0   f8 = f8,f1,f8               
(p6)     br.ret.spnt     b0 ;;                          
}

// Put 0.25 in f9; p6 true if x < 0.25
{ .mlx
         nop.m 999
(p0)     movl            r32 = 0x000000000000fffd ;;         
}

{ .mfi
(p0)     setf.exp        f9 = r32                         
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fmerge.s      sinh_FR_X    = f0,f8             
         nop.i 999
}

// Identify denormal operands.
{ .mfi
         nop.m 999
         fclass.m.unc  p10,p0 = f8, 0x09        //  + denorm
         nop.i 999
};;
{ .mfi
         nop.m 999
         fclass.m.unc  p11,p0 = f8, 0x0a        //  - denorm
         nop.i 999 
}

{ .mfi
         nop.m 999
(p0)     fmerge.s      sinh_FR_SGNX = f8,f1             
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fcmp.lt.unc.s1  p0,p7 = sinh_FR_X,f9             
         nop.i 999 ;;
}

{ .mib
         nop.m 999
         nop.i 999
(p7)     br.cond.sptk    SINH_BY_TBL ;;                      
}


SINH_BY_POLY: 

// POLY cannot overflow so there is no need to call __libm_error_support
// Set tiny_SAFE (p7) to 1(0) if answer is not tiny 
// Currently we do not use tiny_SAFE. So the setting of tiny_SAFE is
// commented out.
//(p0)     movl            r32            = 0x000000000000fc01           
//(p0)     setf.exp        f10            = r32                         
//(p0)     fcmp.lt.unc.s1  p6,p7          = f8,f10                     
// Here is essentially the algorithm for SINH_BY_POLY. Care is take for the order 
// of multiplication; and P_1 is not exactly 1/3!, P_2 is not exactly 1/5!, etc.
// Note that ax = |x|
// sinh(x) = sign * (series(e^x) - series(e^-x))/2
//         = sign * (ax + ax^3/3! + ax^5/5! + ax^7/7! + ax^9/9! + ax^11/11! + ax^13/13!)
//         = sign * (ax   + ax * ( ax^2 * (1/3! + ax^4 * (1/7! + ax^4*1/11!)) )
//                        + ax * ( ax^4 * (1/5! + ax^4 * (1/9! + ax^4*1/13!)) ) )
//         = sign * (ax   + ax*p_odd + (ax*p_even))
//         = sign * (ax   + Y_lo)
// sinh(x) = sign * (Y_hi + Y_lo)
// Get the values of P_x from the table
{ .mfb
(p0)  addl           r34   = @ltoff(double_sinh_p_table), gp
(p10) fma.d.s0       f8 =  f8,f8,f8
(p10) br.ret.spnt    b0
}
;;

{ .mfb
      ld8 r34 = [r34]
(p11) fnma.d.s0      f8 =  f8,f8,f8
(p11) br.ret.spnt    b0
}
;;

// Calculate sinh_FR_X2 = ax*ax and sinh_FR_X4 = ax*ax*ax*ax
{ .mmf
         nop.m 999
(p0)     ldfe            sinh_FR_P1 = [r34],16                 
(p0)     fma.s1        sinh_FR_X2 = sinh_FR_X, sinh_FR_X, f0 ;;           
}

{ .mmi
(p0)     ldfe            sinh_FR_P2 = [r34],16 ;;                 
(p0)     ldfe            sinh_FR_P3 = [r34],16                 
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            sinh_FR_P4 = [r34],16 ;;                 
(p0)     ldfe            sinh_FR_P5 = [r34],16                 
         nop.i 999 ;;
}

{ .mfi
(p0)     ldfe            sinh_FR_P6 = [r34],16                 
(p0)     fma.s1        sinh_FR_X4 = sinh_FR_X2, sinh_FR_X2, f0         
         nop.i 999 ;;
}

// Calculate sinh_FR_podd = p_odd and sinh_FR_peven = p_even 
{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_poly_podd_temp1 = sinh_FR_X4, sinh_FR_P5, sinh_FR_P3                
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_poly_podd_temp2 = sinh_FR_X4, sinh_FR_poly_podd_temp1, sinh_FR_P1   
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_poly_peven_temp1 = sinh_FR_X4, sinh_FR_P6, sinh_FR_P4               
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_podd       = sinh_FR_X2, sinh_FR_poly_podd_temp2, f0           
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_poly_peven_temp2 = sinh_FR_X4, sinh_FR_poly_peven_temp1, sinh_FR_P2 
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_peven       = sinh_FR_X4, sinh_FR_poly_peven_temp2, f0         
         nop.i 999 ;;
}

// Calculate sinh_FR_Y_lo = ax*p_odd + (ax*p_even)
{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_Y_lo_temp    = sinh_FR_X, sinh_FR_peven, f0                    
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_Y_lo         = sinh_FR_X, sinh_FR_podd,  sinh_FR_Y_lo_temp          
         nop.i 999 ;;
}

// Calculate sinh_FR_SINH = Y_hi + Y_lo. Note that ax = Y_hi
{ .mfi
         nop.m 999
(p0)     fma.s1      sinh_FR_SINH        = sinh_FR_X, f1, sinh_FR_Y_lo                      
         nop.i 999 ;;
}

// Calculate f8 = sign * (Y_hi + Y_lo)
// Go to return
{ .mfb
         nop.m 999
(p0)     fma.d.s0        f8 = sinh_FR_SGNX,sinh_FR_SINH,f0                       
(p0)     br.ret.sptk     b0 ;;                          
}


SINH_BY_TBL: 

// Now that we are at TBL; so far all we know is that |x| >= 0.25.
// The first two steps are the same for TBL and EXP, but if we are HUGE
// we want to leave now. 
// Double-extended:
// Go to HUGE if |x| >= 2^14, 1000d (register-biased) is e = 14 (true)
// Double
// Go to HUGE if |x| >= 2^10, 10009 (register-biased) is e = 10 (true)
// Single
// Go to HUGE if |x| >= 2^7,  10006 (register-biased) is e =  7 (true)

{ .mlx
         nop.m 999
(p0)     movl            r32 = 0x0000000000010009 ;;         
}

{ .mfi
(p0)     setf.exp        f9 = r32                         
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fcmp.ge.unc.s1  p6,p7 = sinh_FR_X,f9             
         nop.i 999 ;;
}

{ .mib
         nop.m 999
         nop.i 999
(p6)     br.cond.spnt    SINH_HUGE ;;                        
}

// r32 = 1
// r34 = N-1 
// r35 = N
// r36 = j
// r37 = N+1

// TBL can never overflow
// sinh(x) = sinh(B+R)
//         = sinh(B)cosh(R) + cosh(B)sinh(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calcualte M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// sinh(B) = 1/2(e^B -e^-B)
//         = 1/2(2^N * 2^(j*log2/64) - 2^-N * 2^(-j*log2/64)) 
// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses the B coefficients
// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    sinh(B) = S_hi + S_lo
//    cosh(B) = C_hi
// sinh(x) = sinh(B)cosh(R) + cosh(B)sinh(R)
// ******************************************************
// STEP 1 (TBL and EXP)
// ******************************************************
// Get the following constants. 
// f9  = Inv_log2by64
// f10 = log2by64_hi
// f11 = log2by64_lo

{ .mmi
(p0)  adds                 r32 = 0x1,r0      
(p0)  addl           r34   = @ltoff(double_sinh_arg_reduction), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// sinh_FR_spos = 2^(N-1) and sinh_FR_sneg = 2^(-N-1)
// r39 = 0xffff + (N-1)  = 0xffff +N -1
// r40 = 0xffff - (N +1) = 0xffff -N -1

{ .mlx
         nop.m 999
(p0)     movl                r38 = 0x000000000000fffe ;; 
}

{ .mmi
(p0)     ldfe            sinh_FR_Inv_log2by64 = [r34],16 ;;       
(p0)     ldfe            sinh_FR_log2by64_hi  = [r34],16       
         nop.i 999 ;;
}

{ .mbb
(p0)     ldfe            sinh_FR_log2by64_lo  = [r34],16       
         nop.b 999
         nop.b 999 ;;
}

// Get the A coefficients
// f9  = A_1
// f10 = A_2
// f11 = A_3

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(double_sinh_ab_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// Calculate M and keep it as integer and floating point.
// f38 = M = round-to-integer(x*Inv_log2by64)
// sinh_FR_M = M = truncate(ax/(log2/64))
// Put the significand of M in r35
//    and the floating point representation of M in sinh_FR_M

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_M      = sinh_FR_X, sinh_FR_Inv_log2by64, f0 
         nop.i 999
}

{ .mfi
(p0)     ldfe            sinh_FR_A1 = [r34],16            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fcvt.fx.s1      sinh_FR_M_temp = sinh_FR_M                      
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fnorm.s1        sinh_FR_M      = sinh_FR_M_temp                 
         nop.i 999 ;;
}

{ .mfi
(p0)     getf.sig        r35       = sinh_FR_M_temp                 
         nop.f 999
         nop.i 999 ;;
}

// M is still in r35. Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.
// r35 = M
// r36 = j 

{ .mii
         nop.m 999
         nop.i 999 ;;
(p0)     and            r36 = 0x3f, r35 ;;   
}

// Calculate R
// f13 = f44 - f12*f10 = ax - M*log2by64_hi
// f14 = f13 - f8*f11  = R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
         nop.m 999
(p0)     fnma.s1           sinh_FR_R_temp = sinh_FR_M, sinh_FR_log2by64_hi, sinh_FR_X      
         nop.i 999
}

{ .mfi
(p0)     ldfe            sinh_FR_A2 = [r34],16            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fnma.s1           sinh_FR_R      = sinh_FR_M, sinh_FR_log2by64_lo, sinh_FR_R_temp 
         nop.i 999
}

// Get the B coefficients
// f15 = B_1
// f32 = B_2
// f33 = B_3

{ .mmi
(p0)     ldfe            sinh_FR_A3 = [r34],16 ;;            
(p0)     ldfe            sinh_FR_B1 = [r34],16            
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            sinh_FR_B2 = [r34],16 ;;            
(p0)     ldfe            sinh_FR_B3 = [r34],16            
         nop.i 999 ;;
}

{ .mii
         nop.m 999
(p0)     shl            r34 = r36,  0x2 ;;   
(p0)     sxt1           r37 = r34 ;;         
}

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
// f12 = R*R*R
// f13 = R*R
// f14 = R <== from above

{ .mfi
         nop.m 999
(p0)     fma.s1             sinh_FR_Rsq  = sinh_FR_R,   sinh_FR_R, f0  
(p0)     shr            r36 = r37,  0x2 ;;   
}

// r34 = M-j = r35 - r36
// r35 = N = (M-j)/64

{ .mii
(p0)     sub                  r34 = r35, r36    
         nop.i 999 ;;
(p0)     shr                  r35 = r34, 0x6 ;;    
}

{ .mii
(p0)     sub                 r40 = r38, r35           
(p0)     adds                 r37 = 0x1, r35    
(p0)     add                 r39 = r38, r35 ;;           
}

// Get the address of the J table, add the offset, 
// addresses are sinh_AD_mJ and sinh_AD_J, get the T value
// f32 = T(j)_hi
// f33 = T(j)_lo
// f34 = T(-j)_hi
// f35 = T(-j)_lo

{ .mmi
(p0)  sub                  r34 = r35, r32    
(p0)  addl           r37   = @ltoff(double_sinh_j_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r37 = [r37]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
         nop.m 999
(p0)     fma.s1             sinh_FR_Rcub = sinh_FR_Rsq, sinh_FR_R, f0  
         nop.i 999
}

// ******************************************************
// STEP 3 Now decide if we need to branch to EXP
// ******************************************************
// Put 32 in f9; p6 true if x < 32
// Go to EXP if |x| >= 32 

{ .mlx
         nop.m 999
(p0)     movl                r32 = 0x0000000000010004 ;;               
}

// Calculate p_even
// f34 = B_2 + Rsq *B_3
// f35 = B_1 + Rsq*f34      = B_1 + Rsq * (B_2 + Rsq *B_3)
// f36 = p_even = Rsq * f35 = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_peven_temp1 = sinh_FR_Rsq, sinh_FR_B3,          sinh_FR_B2  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_peven_temp2 = sinh_FR_Rsq, sinh_FR_peven_temp1, sinh_FR_B1  
         nop.i 999
}

// Calculate p_odd
// f34 = A_2 + Rsq *A_3
// f35 = A_1 + Rsq * (A_2 + Rsq *A_3)
// f37 = podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_podd_temp1 = sinh_FR_Rsq,        sinh_FR_A3,         sinh_FR_A2  
         nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            sinh_FR_N_temp1 = r39            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_peven       = sinh_FR_Rsq, sinh_FR_peven_temp2, f0     
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_podd_temp2 = sinh_FR_Rsq,        sinh_FR_podd_temp1, sinh_FR_A1  
         nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            f9  = r32                              
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinh_FR_podd       = sinh_FR_podd_temp2, sinh_FR_Rcub,       sinh_FR_R   
         nop.i 999
}

// sinh_GR_mj contains the table offset for -j
// sinh_GR_j  contains the table offset for +j
// p6 is true when j <= 0

{ .mlx
(p0)     setf.exp            sinh_FR_N_temp2 = r40            
(p0)     movl                r40 = 0x0000000000000020 ;;    
}

{ .mfi
(p0)     sub                 sinh_GR_mJ = r40,  r36           
(p0)     fmerge.se           sinh_FR_spos    = sinh_FR_N_temp1, f1 
(p0)     adds                sinh_GR_J  = 0x20, r36 ;;           
}

{ .mii
         nop.m 999
(p0)     shl                  sinh_GR_mJ = sinh_GR_mJ, 5 ;;   
(p0)     add                  sinh_AD_mJ = r37, sinh_GR_mJ ;; 
}

{ .mmi
         nop.m 999
(p0)     ldfe                 sinh_FR_Tmjhi = [sinh_AD_mJ],16                 
(p0)     shl                  sinh_GR_J  = sinh_GR_J, 5 ;;    
}

{ .mfi
(p0)     ldfs                 sinh_FR_Tmjlo = [sinh_AD_mJ],16                 
(p0)     fcmp.lt.unc.s1      p0,p7 = sinh_FR_X,f9                          
(p0)     add                  sinh_AD_J  = r37, sinh_GR_J ;;  
}

{ .mmi
(p0)     ldfe                 sinh_FR_Tjhi  = [sinh_AD_J],16 ;;                  
(p0)     ldfs                 sinh_FR_Tjlo  = [sinh_AD_J],16                  
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)     fmerge.se           sinh_FR_sneg    = sinh_FR_N_temp2, f1 
(p7)     br.cond.spnt        SINH_BY_EXP ;;                            
}

{ .mfi
         nop.m 999
         nop.f 999
         nop.i 999 ;;
}

// ******************************************************
// If NOT branch to EXP
// ******************************************************
// Calculate S_hi and S_lo
// sinh_FR_S_hi_temp = sinh_FR_sneg * sinh_FR_Tmjhi
// sinh_FR_S_hi = sinh_FR_spos * sinh_FR_Tjhi - sinh_FR_S_hi_temp
// sinh_FR_S_hi = sinh_FR_spos * sinh_FR_Tjhi - (sinh_FR_sneg * sinh_FR_Tmjlo)

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_S_hi_temp = sinh_FR_sneg, sinh_FR_Tmjhi, f0   
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fms.s1         sinh_FR_S_hi = sinh_FR_spos, sinh_FR_Tjhi,  sinh_FR_S_hi_temp              
         nop.i 999
}

// Calculate C_hi
// sinh_FR_C_hi_temp1 = sinh_FR_sneg * sinh_FR_Tmjhi
// sinh_FR_C_hi = sinh_FR_spos * sinh_FR_Tjhi + sinh_FR_C_hi_temp1

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_C_hi_temp1 = sinh_FR_sneg, sinh_FR_Tmjhi, f0                   
         nop.i 999 ;;
}

// sinh_FR_S_lo_temp1 =  sinh_FR_spos * sinh_FR_Tjhi - sinh_FR_S_hi
// sinh_FR_S_lo_temp2 = -sinh_FR_sneg * sinh_FR_Tmjlo + (sinh_FR_spos * sinh_FR_Tjhi - sinh_FR_S_hi)
// sinh_FR_S_lo_temp2 = -sinh_FR_sneg * sinh_FR_Tmjlo + (sinh_FR_S_lo_temp1              )

{ .mfi
         nop.m 999
(p0)    fms.s1         sinh_FR_S_lo_temp1 =  sinh_FR_spos, sinh_FR_Tjhi,  sinh_FR_S_hi            
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_C_hi       = sinh_FR_spos, sinh_FR_Tjhi, sinh_FR_C_hi_temp1    
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fnma.s1        sinh_FR_S_lo_temp2 = sinh_FR_sneg, sinh_FR_Tmjhi, sinh_FR_S_lo_temp1       
         nop.i 999
}

// sinh_FR_S_lo_temp1 = sinh_FR_sneg * sinh_FR_Tmjlo
// sinh_FR_S_lo_temp3 = sinh_FR_spos * sinh_FR_Tjlo - sinh_FR_S_lo_temp1
// sinh_FR_S_lo_temp3 = sinh_FR_spos * sinh_FR_Tjlo -(sinh_FR_sneg * sinh_FR_Tmjlo)
// sinh_FR_S_lo = sinh_FR_S_lo_temp3 + sinh_FR_S_lo_temp2

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_S_lo_temp1 =  sinh_FR_sneg, sinh_FR_Tmjlo, f0                  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_S_lo_temp3 =  sinh_FR_spos, sinh_FR_Tjlo,  sinh_FR_S_lo_temp1  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_S_lo       =  sinh_FR_S_lo_temp3, f1,   sinh_FR_S_lo_temp2     
         nop.i 999 ;;
}

// Y_hi = S_hi 
// Y_lo = C_hi*p_odd + (S_hi*p_even + S_lo)
// sinh_FR_Y_lo_temp = sinh_FR_S_hi * sinh_FR_peven + sinh_FR_S_lo
// sinh_FR_Y_lo      = sinh_FR_C_hi * sinh_FR_podd + sinh_FR_Y_lo_temp

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_Y_lo_temp  = sinh_FR_S_hi, sinh_FR_peven, sinh_FR_S_lo           
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_Y_lo       =  sinh_FR_C_hi, sinh_FR_podd, sinh_FR_Y_lo_temp      
         nop.i 999 ;;
}

// sinh_FR_SINH = Y_hi + Y_lo
// f8 = answer = sinh_FR_SGNX * sinh_FR_SINH

{ .mfi
         nop.m 999
(p0)    fma.s1         sinh_FR_SINH       =  sinh_FR_S_hi, f1, sinh_FR_Y_lo    
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)    fma.d.s0       f8 = sinh_FR_SGNX, sinh_FR_SINH,f0                      
(p0)    br.ret.sptk     b0 ;;                          
}


SINH_BY_EXP: 

// When p7 is true,  we know that an overflow is not going to happen
// When p7 is false, we must check for possible overflow
// p7 is the over_SAFE flag
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) +Tjlo
// Scale = sign * 2^(N-1)
// sinh_FR_Y_lo =  sinh_FR_Tjhi * (sinh_FR_peven + sinh_FR_podd)
// sinh_FR_Y_lo =  sinh_FR_Tjhi * (sinh_FR_Y_lo_temp      )

{ .mfi
         nop.m 999
(p0)   fma.s1            sinh_FR_Y_lo_temp =  sinh_FR_peven, f1, sinh_FR_podd                   
         nop.i 999
}

// Now we are in EXP. This is the only path where an overflow is possible
// but not for certain. So this is the only path where over_SAFE has any use.
// r34 still has N-1
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// There is a danger of double overflow            if N-1 > 0x3fe = 1022
{ .mlx
         nop.m 999
(p0)   movl                r32          = 0x00000000000003fe ;;                       
}

{ .mfi
(p0)   cmp.gt.unc          p0,p7        = r34, r32                                 
(p0)   fmerge.s          sinh_FR_SCALE     = sinh_FR_SGNX, sinh_FR_spos                         
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s1            sinh_FR_Y_lo      =  sinh_FR_Tjhi,  sinh_FR_Y_lo_temp, sinh_FR_Tjlo    
         nop.i 999 ;;
}

// f8 = answer = scale * (Y_hi + Y_lo)
{ .mfi
         nop.m 999
(p0)   fma.s1            sinh_FR_SINH_temp = sinh_FR_Y_lo,  f1, sinh_FR_Tjhi       
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.d.s0          f44          = sinh_FR_SCALE,  sinh_FR_SINH_temp, f0      
         nop.i 999 ;;
}

// If over_SAFE is set, return
{ .mfb
       nop.m 999
(p7)   fmerge.s            f8 = f44,f44                                            
(p7)   br.ret.sptk     b0 ;;                          
}

// Else see if we overflowed
// S0 user supplied status
// S2 user supplied status + WRE + TD  (Overflows)
// If WRE is set then an overflow will not occur in EXP.
// The input value that would cause a register (WRE) value to overflow is about 2^15
// and this input would go into the HUGE path.
// Answer with WRE is in f43.

{ .mfi
         nop.m 999
(p0)   fsetc.s2            0x7F,0x42                                               
         nop.i 999;;
}

{ .mfi
         nop.m 999
(p0)   fma.d.s2            f43  = sinh_FR_SCALE,  sinh_FR_SINH_temp, f0                      
         nop.i 999 ;;
}

// 103FF => 103FF -FFFF = 400(true)
// 400 + 3FF = 7FF, which is 1 more that the exponent of the largest
// double (7FE). So 0 103FF 8000000000000000  is one ulp more than
// largest double in register bias
// Now  set p8 if the answer with WRE is greater than or equal this value
// Also set p9 if the answer with WRE is less than or equal to negative this value

{ .mlx
         nop.m 999
(p0)   movl                r32     = 0x000000000103FF ;;                              
}

{ .mmf
         nop.m 999
(p0)   setf.exp            f41 = r32                                               
(p0)   fsetc.s2            0x7F,0x40 ;;                                               
}

{ .mfi
         nop.m 999
(p0)   fcmp.ge.unc.s1 p8, p0 =  f43, f41                                           
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)   fmerge.ns           f42 = f41, f41                                          
         nop.i 999 ;;
}

// The error tag for overflow is 127
{ .mii
         nop.m 999
         nop.i 999 ;;
(p8)   mov                 r47 = 127 ;;                                               
}

{ .mfb
         nop.m 999
(p0)   fcmp.le.unc.s1      p9, p0 =  f43, f42                                      
(p8)   br.cond.spnt SINH_ERROR_SUPPORT ;;
}

{ .mii
         nop.m 999
         nop.i 999 ;;
(p9)   mov                 r47 = 127                                               
}

{ .mib
         nop.m 999
         nop.i 999
(p9)   br.cond.spnt SINH_ERROR_SUPPORT ;;
}

{ .mfb
         nop.m 999
(p0)   fmerge.s            f8 = f44,f44                                            
(p0)   br.ret.sptk     b0 ;;                          
}

SINH_HUGE: 

// for SINH_HUGE, put 24000 in exponent; take sign from input; add 1
// SAFE: SAFE is always 0 for HUGE

{ .mlx
         nop.m 999
(p0)   movl                r32 = 0x0000000000015dbf ;;                                
}

{ .mfi
(p0)   setf.exp            f9  = r32                                               
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s1              sinh_FR_signed_hi_lo = sinh_FR_SGNX, f9, f1                       
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.d.s0            f44 = sinh_FR_signed_hi_lo,  f9, f0                          
(p0)   mov                 r47 = 127                                               
}
.endp sinh

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
SINH_ERROR_SUPPORT:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8                     // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                            
}
{ .mib
        stfd [GR_Parameter_Y] = f44                    // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#          // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sinhf.s ===
.file "sinhf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 10/12/00 Update to set denormal operand and underflow flags
//
// API
//==============================================================
// float = sinhf(float)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers:
// r32 -> r47
//
// predicate registers used:
// p6 p7 p8 p9
//
// floating-point registers used:
// f9 -> f15; f32 -> f44;
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are four paths
// 1. |x| < 0.25        SINH_BY_POLY
// 2. |x| < 32          SINH_BY_TBL
// 3. |x| < 2^14        SINH_BY_EXP
// 4. |x_ >= 2^14       SINH_HUGE
//
// For double extended we get infinity for x >= 400c b174 ddc0 31ae c0ea
//                                           >= 1.0110001.... x 2^13
//                                           >= 11357.2166
//
// But for double we get infinity for x >= 408633ce8fb9f87e
//                                      >= 1.0110...x 2^9
//                                      >= +7.10476e+002
//
// And for single we get infinity for x >= 42b3a496
//                                      >= 1.0110... 2^6
//                                      >= 89.8215
//
// SAFE: If there is danger of overflow set SAFE to 0
//       NOT implemented: if there is danger of underflow, set SAFE to 0
// SAFE for all paths listed below
//
// 1. SINH_BY_POLY
// ===============
// If |x| is less than the tiny threshold, then clear SAFE 
// For double, the tiny threshold is -1022 = -0x3fe => -3fe + ffff = fc01
//             register-biased, this is fc01
// For single, the tiny threshold is -126  = -7e    => -7e  + ffff = ff81
// If |x| < tiny threshold, set SAFE = 0
//
// 2. SINH_BY_TBL
// =============
// SAFE: SAFE is always 1 for TBL; 
//
// 3. SINH_BY_EXP
// ==============
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// r34 has N-1; 16382 is in register biased form, 0x13ffd
// There is danger of double overflow if N-1 > 0x3fe
//                       in register biased form, 0x103fd
// Analagously, there is danger of single overflow if N-1 > 0x7e
//                       in register biased form, 0x1007d
// SAFE: If there is danger of overflow set SAFE to 0
//
// 4. SINH_HUGE
// ============
// SAFE: SAFE is always 0 for HUGE
//
// Assembly macros
//==============================================================
sinhf_FR_X            = f44
sinhf_FR_X2           = f9
sinhf_FR_X4           = f10
sinhf_FR_SGNX         = f40

sinhf_FR_Inv_log2by64 = f9
sinhf_FR_log2by64_lo  = f11
sinhf_FR_log2by64_hi  = f10

sinhf_FR_A1           = f9
sinhf_FR_A2           = f10
sinhf_FR_A3           = f11

sinhf_FR_Rcub         = f12
sinhf_FR_M_temp       = f13
sinhf_FR_R_temp       = f13
sinhf_FR_Rsq          = f13
sinhf_FR_R            = f14

sinhf_FR_M            = f38

sinhf_FR_B1           = f15
sinhf_FR_B2           = f32
sinhf_FR_B3           = f33

sinhf_FR_peven_temp1  = f34
sinhf_FR_peven_temp2  = f35
sinhf_FR_peven        = f36

sinhf_FR_podd_temp1   = f34
sinhf_FR_podd_temp2   = f35
sinhf_FR_podd         = f37

sinhf_FR_poly_podd_temp1    =  f11 
sinhf_FR_poly_podd_temp2    =  f13
sinhf_FR_poly_peven_temp1   =  f11
sinhf_FR_poly_peven_temp2   =  f13

sinhf_FR_J_temp       = f9
sinhf_FR_J            = f10

sinhf_FR_Mmj          = f39

sinhf_FR_N_temp1      = f11
sinhf_FR_N_temp2      = f12
sinhf_FR_N            = f13

sinhf_FR_spos         = f14
sinhf_FR_sneg         = f15

sinhf_FR_Tjhi         = f32
sinhf_FR_Tjlo         = f33
sinhf_FR_Tmjhi        = f34
sinhf_FR_Tmjlo        = f35

sinhf_GR_mJ           = r35
sinhf_GR_J            = r36

sinhf_AD_mJ           = r38
sinhf_AD_J            = r39

sinhf_FR_S_hi         = f9
sinhf_FR_S_hi_temp    = f10
sinhf_FR_S_lo_temp1   = f11 
sinhf_FR_S_lo_temp2   = f12 
sinhf_FR_S_lo_temp3   = f13 

sinhf_FR_S_lo         = f38
sinhf_FR_C_hi         = f39

sinhf_FR_C_hi_temp1   = f10
sinhf_FR_Y_hi         = f11 
sinhf_FR_Y_lo_temp    = f12 
sinhf_FR_Y_lo         = f13 
sinhf_FR_SINH         = f9

sinhf_FR_P1           = f14
sinhf_FR_P2           = f15
sinhf_FR_P3           = f32
sinhf_FR_P4           = f33
sinhf_FR_P5           = f34
sinhf_FR_P6           = f35

sinhf_FR_TINY_THRESH  = f9

sinhf_FR_SINH_temp    = f10
sinhf_FR_SCALE        = f11 

sinhf_FR_signed_hi_lo = f10



GR_SAVE_B0                    = r42
GR_SAVE_PFS                   = r41
GR_SAVE_GP                    = r43 

GR_Parameter_X                = r44
GR_Parameter_Y                = r45
GR_Parameter_RESULT           = r46
//GR_Parameter_TAG              = r47

FR_X             = f8
FR_Y             = f0
FR_RESULT        = f44



// Data tables
//==============================================================

.data

.align 16
single_sinhf_arg_reduction:
   data8 0xB8AA3B295C17F0BC, 0x00004005
   data8 0xB17217F7D1000000, 0x00003FF8
   data8 0xCF79ABC9E3B39804, 0x00003FD0

single_sinhf_p_table:
   data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC
   data8 0x8888888888888412, 0x00003FF8
   data8 0xD00D00D00D4D39F2, 0x00003FF2
   data8 0xB8EF1D28926D8891, 0x00003FEC
   data8 0xD732377688025BE9, 0x00003FE5
   data8 0xB08AF9AE78C1239F, 0x00003FDE

single_sinhf_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC
   data8 0x88888888884ECDD5, 0x00003FF8
   data8 0xD00D0C6DCC26A86B, 0x00003FF2
   data8 0x8000000000000002, 0x00003FFE
   data8 0xAAAAAAAAAA402C77, 0x00003FFA
   data8 0xB60B6CC96BDB144D, 0x00003FF5

single_sinhf_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global sinhf#

.section .text
.proc  sinhf#
.align 32

sinhf: 

// X infinity or NAN?
// Take invalid fault if enabled
{ .mfi
      alloc r32 = ar.pfs,0,12,4,0                  
(p0)     fclass.m.unc  p6,p0 = f8, 0xe3            
	  nop.i 0;;                           
}

{ .mfb
         nop.m 999
(p6)     fma.s.s0   f8 = f8,f1,f8               
(p6)     br.ret.spnt  b0 ;;                 
}

// Put 0.25 in f9; p6 true if x < 0.25
{ .mlx
         nop.m 999
(p0)     movl            r32 = 0x000000000000fffd ;;         
}

{ .mfi
(p0)     setf.exp        f9 = r32                         
(p0)     fmerge.s      sinhf_FR_SGNX = f8,f1
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fmerge.s      sinhf_FR_X    = f0,f8             
         nop.i 999
}

// Identify denormal operands.
{ .mfi
         nop.m 999
         fclass.m.unc  p10,p0 = f8, 0x09        //  + denorm
         nop.i 999
};;
{ .mfi
         nop.m 999
         fclass.m.unc  p11,p0 = f8, 0x0a        //  - denorm
         nop.i 999 
}
{ .mfi
         nop.m 999
(p0)     fcmp.lt.unc.s1  p0,p7 = sinhf_FR_X,f9             
         nop.i 999 ;;
}

{ .mib
         nop.m 999
         nop.i 999
(p7)     br.cond.sptk    SINH_BY_TBL ;;                      
}


SINH_BY_POLY: 

// POLY cannot overflow so there is no need to call __libm_error_support
// Set tiny_SAFE (p7) to 1(0) if answer is not tiny 
// Currently we do not use tiny_SAFE. So the setting of tiny_SAFE is
// commented out.
//(p0)     movl            r32            = 0x000000000000fc01           
//(p0)     setf.exp        f10            = r32                         
//(p0)     fcmp.lt.unc.s1  p6,p7          = f8,f10                     
// Here is essentially the algorithm for SINH_BY_POLY. Care is take for the order 
// of multiplication; and P_1 is not exactly 1/3!, P_2 is not exactly 1/5!, etc.
// Note that ax = |x|
// sinhf(x) = sign * (series(e^x) - series(e^-x))/2
//         = sign * (ax + ax^3/3! + ax^5/5! + ax^7/7! + ax^9/9! + ax^11/11! + ax^13/13!)
//         = sign * (ax   + ax * ( ax^2 * (1/3! + ax^4 * (1/7! + ax^4*1/11!)) )
//                        + ax * ( ax^4 * (1/5! + ax^4 * (1/9! + ax^4*1/13!)) ) )
//         = sign * (ax   + ax*p_odd + (ax*p_even))
//         = sign * (ax   + Y_lo)
// sinhf(x) = sign * (Y_hi + Y_lo)
// Get the values of P_x from the table

{ .mfb
      addl           r34   = @ltoff(single_sinhf_p_table), gp
(p10) fma.s.s0       f8 =  f8,f8,f8
(p10) br.ret.spnt    b0
}
;;

{ .mfb
      ld8 r34 = [r34]
(p11) fnma.s.s0      f8 =  f8,f8,f8
(p11) br.ret.spnt    b0
}
;;

// Calculate sinhf_FR_X2 = ax*ax and sinhf_FR_X4 = ax*ax*ax*ax
{ .mmf
         nop.m 999
(p0)     ldfe            sinhf_FR_P1 = [r34],16                 
(p0)     fma.s1        sinhf_FR_X2 = sinhf_FR_X, sinhf_FR_X, f0 ;;           
}

{ .mmi
(p0)     ldfe            sinhf_FR_P2 = [r34],16 ;;                 
(p0)     ldfe            sinhf_FR_P3 = [r34],16                 
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            sinhf_FR_P4 = [r34],16 ;;                 
(p0)     ldfe            sinhf_FR_P5 = [r34],16                 
         nop.i 999 ;;
}

{ .mfi
(p0)     ldfe            sinhf_FR_P6 = [r34],16                 
(p0)     fma.s1        sinhf_FR_X4 = sinhf_FR_X2, sinhf_FR_X2, f0         
         nop.i 999 ;;
}

// Calculate sinhf_FR_podd = p_odd and sinhf_FR_peven = p_even 
{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_poly_podd_temp1 = sinhf_FR_X4, sinhf_FR_P5, sinhf_FR_P3                
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_poly_podd_temp2 = sinhf_FR_X4, sinhf_FR_poly_podd_temp1, sinhf_FR_P1   
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_poly_peven_temp1 = sinhf_FR_X4, sinhf_FR_P6, sinhf_FR_P4               
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_podd       = sinhf_FR_X2, sinhf_FR_poly_podd_temp2, f0           
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_poly_peven_temp2 = sinhf_FR_X4, sinhf_FR_poly_peven_temp1, sinhf_FR_P2 
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_peven       = sinhf_FR_X4, sinhf_FR_poly_peven_temp2, f0         
         nop.i 999 ;;
}

// Calculate sinhf_FR_Y_lo = ax*p_odd + (ax*p_even)
{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_Y_lo_temp    = sinhf_FR_X, sinhf_FR_peven, f0                    
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_Y_lo         = sinhf_FR_X, sinhf_FR_podd,  sinhf_FR_Y_lo_temp          
         nop.i 999 ;;
}

// Calculate sinhf_FR_SINH = Y_hi + Y_lo. Note that ax = Y_hi
{ .mfi
         nop.m 999
(p0)     fma.s1      sinhf_FR_SINH        = sinhf_FR_X, f1, sinhf_FR_Y_lo                      
         nop.i 999 ;;
}

// Calculate f8 = sign * (Y_hi + Y_lo)
// Go to return
{ .mfb
         nop.m 999
(p0)     fma.s.s0        f8 = sinhf_FR_SGNX,sinhf_FR_SINH,f0                       
(p0)     br.ret.sptk         b0 ;;                                             
}


SINH_BY_TBL: 

// Now that we are at TBL; so far all we know is that |x| >= 0.25.
// The first two steps are the same for TBL and EXP, but if we are HUGE
// we want to leave now. 
// Double-extended:
// Go to HUGE if |x| >= 2^14, 1000d (register-biased) is e = 14 (true)
// Double
// Go to HUGE if |x| >= 2^10, 10009 (register-biased) is e = 10 (true)
// Single
// Go to HUGE if |x| >= 2^7,  10006 (register-biased) is e =  7 (true)

{ .mlx
         nop.m 999
(p0)     movl            r32 = 0x0000000000010006 ;;         
}

{ .mfi
(p0)     setf.exp        f9 = r32                         
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fcmp.ge.unc.s1  p6,p7 = sinhf_FR_X,f9             
         nop.i 999 ;;
}

{ .mib
         nop.m 999
         nop.i 999
(p6)     br.cond.spnt    SINH_HUGE ;;                        
}

// r32 = 1
// r34 = N-1 
// r35 = N
// r36 = j
// r37 = N+1

// TBL can never overflow
// sinhf(x) = sinhf(B+R)
//         = sinhf(B)cosh(R) + cosh(B)sinhf(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calcualte M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// sinhf(B) = 1/2(e^B -e^-B)
//         = 1/2(2^N * 2^(j*log2/64) - 2^-N * 2^(-j*log2/64)) 
// sinhf(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses the B coefficients
// So sinhf(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    sinhf(B) = S_hi + S_lo
//    cosh(B) = C_hi
// sinhf(x) = sinhf(B)cosh(R) + cosh(B)sinhf(R)

// ******************************************************
// STEP 1 (TBL and EXP)
// ******************************************************
// Get the following constants. 
// f9  = Inv_log2by64
// f10 = log2by64_hi
// f11 = log2by64_lo

{ .mmi
(p0)  adds                 r32 = 0x1,r0
(p0)  addl           r34   = @ltoff(single_sinhf_arg_reduction), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;

// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// sinhf_FR_spos = 2^(N-1) and sinhf_FR_sneg = 2^(-N-1)
// r39 = 0xffff + (N-1)  = 0xffff +N -1
// r40 = 0xffff - (N +1) = 0xffff -N -1

{ .mlx
         nop.m 999
(p0)     movl                r38 = 0x000000000000fffe ;; 
}

{ .mmi
(p0)     ldfe            sinhf_FR_Inv_log2by64 = [r34],16 ;;       
(p0)     ldfe            sinhf_FR_log2by64_hi  = [r34],16       
         nop.i 999 ;;
}

{ .mbb
(p0)     ldfe            sinhf_FR_log2by64_lo  = [r34],16       
         nop.b 999
         nop.b 999 ;;
}

// Get the A coefficients
// f9  = A_1
// f10 = A_2
// f11 = A_3

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(single_sinhf_ab_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// Calculate M and keep it as integer and floating point.
// f38 = M = round-to-integer(x*Inv_log2by64)
// sinhf_FR_M = M = truncate(ax/(log2/64))
// Put the significand of M in r35
//    and the floating point representation of M in sinhf_FR_M

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_M      = sinhf_FR_X, sinhf_FR_Inv_log2by64, f0 
         nop.i 999
}

{ .mfi
(p0)     ldfe            sinhf_FR_A1 = [r34],16            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fcvt.fx.s1      sinhf_FR_M_temp = sinhf_FR_M                      
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fnorm.s1        sinhf_FR_M      = sinhf_FR_M_temp                 
         nop.i 999 ;;
}

{ .mfi
(p0)     getf.sig        r35       = sinhf_FR_M_temp                 
         nop.f 999
         nop.i 999 ;;
}

// M is still in r35. Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.
// r35 = M
// r36 = j 

{ .mii
         nop.m 999
         nop.i 999 ;;
(p0)     and            r36 = 0x3f, r35 ;;   
}

// Calculate R
// f13 = f44 - f12*f10 = ax - M*log2by64_hi
// f14 = f13 - f8*f11  = R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
         nop.m 999
(p0)     fnma.s1           sinhf_FR_R_temp = sinhf_FR_M, sinhf_FR_log2by64_hi, sinhf_FR_X      
         nop.i 999
}

{ .mfi
(p0)     ldfe            sinhf_FR_A2 = [r34],16            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fnma.s1           sinhf_FR_R      = sinhf_FR_M, sinhf_FR_log2by64_lo, sinhf_FR_R_temp 
         nop.i 999
}

// Get the B coefficients
// f15 = B_1
// f32 = B_2
// f33 = B_3

{ .mmi
(p0)     ldfe            sinhf_FR_A3 = [r34],16 ;;            
(p0)     ldfe            sinhf_FR_B1 = [r34],16            
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            sinhf_FR_B2 = [r34],16 ;;            
(p0)     ldfe            sinhf_FR_B3 = [r34],16            
         nop.i 999 ;;
}

{ .mii
         nop.m 999
(p0)     shl            r34 = r36,  0x2 ;;   
(p0)     sxt1           r37 = r34 ;;         
}

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
// f12 = R*R*R
// f13 = R*R
// f14 = R <== from above

{ .mfi
         nop.m 999
(p0)     fma.s1             sinhf_FR_Rsq  = sinhf_FR_R,   sinhf_FR_R, f0  
(p0)     shr            r36 = r37,  0x2 ;;   
}

// r34 = M-j = r35 - r36
// r35 = N = (M-j)/64

{ .mii
(p0)     sub                  r34 = r35, r36    
         nop.i 999 ;;
(p0)     shr                  r35 = r34, 0x6 ;;    
}

{ .mii
(p0)     sub                 r40 = r38, r35           
(p0)     adds                 r37 = 0x1, r35    
(p0)     add                 r39 = r38, r35 ;;           
}

// Get the address of the J table, add the offset, 
// addresses are sinhf_AD_mJ and sinhf_AD_J, get the T value
// f32 = T(j)_hi
// f33 = T(j)_lo
// f34 = T(-j)_hi
// f35 = T(-j)_lo

{ .mmi
(p0)  sub                  r34 = r35, r32
(p0)  addl           r37   = @ltoff(single_sinhf_j_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r37 = [r37]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
         nop.m 999
(p0)     fma.s1             sinhf_FR_Rcub = sinhf_FR_Rsq, sinhf_FR_R, f0  
         nop.i 999
}

// ******************************************************
// STEP 3 Now decide if we need to branch to EXP
// ******************************************************
// Put 32 in f9; p6 true if x < 32
// Go to EXP if |x| >= 32 

{ .mlx
         nop.m 999
(p0)     movl                r32 = 0x0000000000010004 ;;               
}

// Calculate p_even
// f34 = B_2 + Rsq *B_3
// f35 = B_1 + Rsq*f34      = B_1 + Rsq * (B_2 + Rsq *B_3)
// f36 = p_even = Rsq * f35 = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_peven_temp1 = sinhf_FR_Rsq, sinhf_FR_B3,          sinhf_FR_B2  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_peven_temp2 = sinhf_FR_Rsq, sinhf_FR_peven_temp1, sinhf_FR_B1  
         nop.i 999
}

// Calculate p_odd
// f34 = A_2 + Rsq *A_3
// f35 = A_1 + Rsq * (A_2 + Rsq *A_3)
// f37 = podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_podd_temp1 = sinhf_FR_Rsq,        sinhf_FR_A3,         sinhf_FR_A2  
         nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            sinhf_FR_N_temp1 = r39            
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_peven       = sinhf_FR_Rsq, sinhf_FR_peven_temp2, f0     
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_podd_temp2 = sinhf_FR_Rsq,        sinhf_FR_podd_temp1, sinhf_FR_A1  
         nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            f9  = r32                              
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1          sinhf_FR_podd       = sinhf_FR_podd_temp2, sinhf_FR_Rcub,       sinhf_FR_R   
         nop.i 999
}

// sinhf_GR_mj contains the table offset for -j
// sinhf_GR_j  contains the table offset for +j
// p6 is true when j <= 0

{ .mlx
(p0)     setf.exp            sinhf_FR_N_temp2 = r40            
(p0)     movl                r40 = 0x0000000000000020 ;;    
}

{ .mfi
(p0)     sub                 sinhf_GR_mJ = r40,  r36           
(p0)     fmerge.se           sinhf_FR_spos    = sinhf_FR_N_temp1, f1 
(p0)     adds                sinhf_GR_J  = 0x20, r36 ;;           
}

{ .mii
         nop.m 999
(p0)     shl                  sinhf_GR_mJ = sinhf_GR_mJ, 5 ;;   
(p0)     add                  sinhf_AD_mJ = r37, sinhf_GR_mJ ;; 
}

{ .mmi
         nop.m 999
(p0)     ldfe                 sinhf_FR_Tmjhi = [sinhf_AD_mJ],16                 
(p0)     shl                  sinhf_GR_J  = sinhf_GR_J, 5 ;;    
}

{ .mfi
(p0)     ldfs                 sinhf_FR_Tmjlo = [sinhf_AD_mJ],16                 
(p0)     fcmp.lt.unc.s1      p0,p7 = sinhf_FR_X,f9                          
(p0)     add                  sinhf_AD_J  = r37, sinhf_GR_J ;;  
}

{ .mmi
(p0)     ldfe                 sinhf_FR_Tjhi  = [sinhf_AD_J],16 ;;                  
(p0)     ldfs                 sinhf_FR_Tjlo  = [sinhf_AD_J],16                  
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)     fmerge.se           sinhf_FR_sneg    = sinhf_FR_N_temp2, f1 
(p7)     br.cond.spnt        SINH_BY_EXP ;;                            
}

{ .mfi
         nop.m 999
         nop.f 999
         nop.i 999 ;;
}

// ******************************************************
// If NOT branch to EXP
// ******************************************************
// Calculate S_hi and S_lo
// sinhf_FR_S_hi_temp = sinhf_FR_sneg * sinhf_FR_Tmjhi
// sinhf_FR_S_hi = sinhf_FR_spos * sinhf_FR_Tjhi - sinhf_FR_S_hi_temp
// sinhf_FR_S_hi = sinhf_FR_spos * sinhf_FR_Tjhi - (sinhf_FR_sneg * sinhf_FR_Tmjlo)

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_S_hi_temp = sinhf_FR_sneg, sinhf_FR_Tmjhi, f0   
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fms.s1         sinhf_FR_S_hi = sinhf_FR_spos, sinhf_FR_Tjhi,  sinhf_FR_S_hi_temp              
         nop.i 999
}

// Calculate C_hi
// sinhf_FR_C_hi_temp1 = sinhf_FR_sneg * sinhf_FR_Tmjhi
// sinhf_FR_C_hi = sinhf_FR_spos * sinhf_FR_Tjhi + sinhf_FR_C_hi_temp1

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_C_hi_temp1 = sinhf_FR_sneg, sinhf_FR_Tmjhi, f0                   
         nop.i 999 ;;
}

// sinhf_FR_S_lo_temp1 =  sinhf_FR_spos * sinhf_FR_Tjhi - sinhf_FR_S_hi
// sinhf_FR_S_lo_temp2 = -sinhf_FR_sneg * sinhf_FR_Tmjlo + (sinhf_FR_spos * sinhf_FR_Tjhi - sinhf_FR_S_hi)
// sinhf_FR_S_lo_temp2 = -sinhf_FR_sneg * sinhf_FR_Tmjlo + (sinhf_FR_S_lo_temp1              )

{ .mfi
         nop.m 999
(p0)    fms.s1         sinhf_FR_S_lo_temp1 =  sinhf_FR_spos, sinhf_FR_Tjhi,  sinhf_FR_S_hi            
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_C_hi       = sinhf_FR_spos, sinhf_FR_Tjhi, sinhf_FR_C_hi_temp1    
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fnma.s1        sinhf_FR_S_lo_temp2 = sinhf_FR_sneg, sinhf_FR_Tmjhi, sinhf_FR_S_lo_temp1       
         nop.i 999
}

// sinhf_FR_S_lo_temp1 = sinhf_FR_sneg * sinhf_FR_Tmjlo
// sinhf_FR_S_lo_temp3 = sinhf_FR_spos * sinhf_FR_Tjlo - sinhf_FR_S_lo_temp1
// sinhf_FR_S_lo_temp3 = sinhf_FR_spos * sinhf_FR_Tjlo -(sinhf_FR_sneg * sinhf_FR_Tmjlo)
// sinhf_FR_S_lo = sinhf_FR_S_lo_temp3 + sinhf_FR_S_lo_temp2

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_S_lo_temp1 =  sinhf_FR_sneg, sinhf_FR_Tmjlo, f0                  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_S_lo_temp3 =  sinhf_FR_spos, sinhf_FR_Tjlo,  sinhf_FR_S_lo_temp1  
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_S_lo       =  sinhf_FR_S_lo_temp3, f1,   sinhf_FR_S_lo_temp2     
         nop.i 999 ;;
}

// Y_hi = S_hi 
// Y_lo = C_hi*p_odd + (S_hi*p_even + S_lo)
// sinhf_FR_Y_lo_temp = sinhf_FR_S_hi * sinhf_FR_peven + sinhf_FR_S_lo
// sinhf_FR_Y_lo      = sinhf_FR_C_hi * sinhf_FR_podd + sinhf_FR_Y_lo_temp

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_Y_lo_temp  = sinhf_FR_S_hi, sinhf_FR_peven, sinhf_FR_S_lo           
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_Y_lo       =  sinhf_FR_C_hi, sinhf_FR_podd, sinhf_FR_Y_lo_temp      
         nop.i 999 ;;
}

// sinhf_FR_SINH = Y_hi + Y_lo
// f8 = answer = sinhf_FR_SGNX * sinhf_FR_SINH

{ .mfi
         nop.m 999
(p0)    fma.s1         sinhf_FR_SINH       =  sinhf_FR_S_hi, f1, sinhf_FR_Y_lo    
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)    fma.s.s0       f8 = sinhf_FR_SGNX, sinhf_FR_SINH,f0                      
(p0)    br.ret.sptk        b0 ;;                                             
}


SINH_BY_EXP: 

// When p7 is true,  we know that an overflow is not going to happen
// When p7 is false, we must check for possible overflow
// p7 is the over_SAFE flag
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) +Tjlo
// Scale = sign * 2^(N-1)
// sinhf_FR_Y_lo =  sinhf_FR_Tjhi * (sinhf_FR_peven + sinhf_FR_podd)
// sinhf_FR_Y_lo =  sinhf_FR_Tjhi * (sinhf_FR_Y_lo_temp      )

{ .mfi
         nop.m 999
(p0)   fma.s1            sinhf_FR_Y_lo_temp =  sinhf_FR_peven, f1, sinhf_FR_podd                   
         nop.i 999
}

// Now we are in EXP. This is the only path where an overflow is possible
// but not for certain. So this is the only path where over_SAFE has any use.
// r34 still has N-1
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// There is a danger of double overflow            if N-1 > 0x3fe = 1022
// There is a danger of single overflow            if N-1 > 0x7e = 126

{ .mlx
         nop.m 999
(p0)   movl                r32          = 0x000000000000007e ;;                       
}

{ .mfi
(p0)   cmp.gt.unc          p0,p7        = r34, r32                                 
(p0)   fmerge.s          sinhf_FR_SCALE     = sinhf_FR_SGNX, sinhf_FR_spos                         
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s1            sinhf_FR_Y_lo      =  sinhf_FR_Tjhi,  sinhf_FR_Y_lo_temp, sinhf_FR_Tjlo    
         nop.i 999 ;;
}

// f8 = answer = scale * (Y_hi + Y_lo)
{ .mfi
         nop.m 999
(p0)   fma.s1            sinhf_FR_SINH_temp = sinhf_FR_Y_lo,  f1, sinhf_FR_Tjhi       
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s.s0          f44          = sinhf_FR_SCALE,  sinhf_FR_SINH_temp, f0      
         nop.i 999 ;;
}

// If over_SAFE is set, return
{ .mfb
         nop.m 999
(p7)   fmerge.s            f8 = f44,f44                                            
(p7)   br.ret.sptk        b0 ;;                                             
}

// Else see if we overflowed
// S0 user supplied status
// S2 user supplied status + WRE + TD  (Overflows)
// If WRE is set then an overflow will not occur in EXP.
// The input value that would cause a register (WRE) value to overflow is about 2^15
// and this input would go into the HUGE path.
// Answer with WRE is in f43.

{ .mfi
         nop.m 999
(p0)   fsetc.s2            0x7F,0x42                                               
         nop.i 999;;
}

{ .mfi
         nop.m 999
(p0)   fma.s.s2            f43  = sinhf_FR_SCALE,  sinhf_FR_SINH_temp, f0                      
         nop.i 999 ;;
}

// 1 more that the exponent of the largest double (7FE)  = 7FF
// 7FF - 3FF = 400 (true); 400 + FFFF = 103FF (register-biased)  
// So 0 103FF 8000000000000000  is one ulp more than
// largest double in register bias
// 1 more that the exponent of the largest single (FE)  = FF
// FF - 7F = 80 (true); 80 + FFFF = 1007F (register-biased)  
// Now  set p8 if the answer with WRE is greater than or equal this value
// Also set p9 if the answer with WRE is less than or equal to negative this value

{ .mlx
         nop.m 999
(p0)   movl                r32     = 0x0000000001007F ;;                              
}

{ .mmf
         nop.m 999
(p0)   setf.exp            f41 = r32                                               
(p0)   fsetc.s2            0x7F,0x40 ;;                                               
}

{ .mfi
         nop.m 999
(p0)   fcmp.ge.unc.s1 p8, p0 =  f43, f41                                           
         nop.i 999
}

{ .mfi
         nop.m 999
(p0)   fmerge.ns           f42 = f41, f41                                          
         nop.i 999 ;;
}

// The error tag for overflow is 128
{ .mii
         nop.m 999
         nop.i 999 ;;
(p8)   mov                 r47 = 128 ;;                                               
}

{ .mfb
         nop.m 999
(p0)   fcmp.le.unc.s1      p9, p0 =  f43, f42                                      
(p8)   br.cond.spnt __libm_error_region ;;
}

{ .mii
         nop.m 999
         nop.i 999 ;;
(p9)   mov                 r47 = 128                                               
}

{ .mib
         nop.m 999
         nop.i 999
(p9)   br.cond.spnt __libm_error_region ;;
}

{ .mfb
         nop.m 999
(p0)   fmerge.s            f8 = f44,f44                                            
(p0)   br.ret.sptk b0 ;; 
}


SINH_HUGE: 

// for SINH_HUGE, put 24000 in exponent; take sign from input; add 1
// SAFE: SAFE is always 0 for HUGE

{ .mlx
         nop.m 999
(p0)   movl                r32 = 0x0000000000015dbf ;;                                
}

{ .mfi
(p0)   setf.exp            f9  = r32                                               
         nop.f 999
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s1              sinhf_FR_signed_hi_lo = sinhf_FR_SGNX, f9, f1                       
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)   fma.s.s0            f44 = sinhf_FR_signed_hi_lo,  f9, f0                          
(p0)   mov                 r47 = 128                                               
}

.endp sinhf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
		nop.i 0                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\tanhf.c ===
#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(tanhf)
#endif

float __cdecl tanhf (float x)
{
	return (float)tanh((double) x);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\tan.s ===
.file "tan.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added
//
// API
//==============================================================
// double tan( double x);
//
// Overview of operation
//==============================================================
// If the input value in radians is |x| >= 1.xxxxx 2^10 call the
// older slower version.
//
// The new algorithm is used when |x| <= 1.xxxxx 2^9.
//
// Represent the input X as Nfloat * pi/2 + r
//    where r can be negative and |r| <= pi/4
//
//     tan_W  = x * 2/pi
//     Nfloat = round_int(tan_W)
//
//     tan_r  = x - Nfloat * (pi/2)_hi
//     tan_r  = tan_r - Nfloat * (pi/2)_lo
//
// We have two paths: p8, when Nfloat is even and p9. when Nfloat is odd.
// p8: tan(X) =  tan(r)
// p9: tan(X) = -cot(r)
//
// Each is evaluated as a series. The p9 path requires 1/r.
//
// The coefficients used in the series are stored in a table as
// are the pi constants.
//
// Registers used
//==============================================================
//
// predicate registers used:  
// p6, p7, p8, p9, p10
//
// floating-point registers used:  
// f32 -> f93
// f8, input
//
// general registers used
// r32 -> r43
//
// Assembly macros
//==============================================================
tan_Inv_Pi_by_2              = f32
tan_Pi_by_2_hi               = f33
tan_Pi_by_2_lo               = f34


tan_P0                       = f35
tan_P1                       = f36
tan_P2                       = f37
tan_P3                       = f38 
tan_P4                       = f39 
tan_P5                       = f40 
tan_P6                       = f41
tan_P7                       = f42
tan_P8                       = f43 
tan_P9                       = f44 
tan_P10                      = f45 
tan_P11                      = f46
tan_P12                      = f47 
tan_P13                      = f48
tan_P14                      = f49
tan_P15                      = f50

tan_Q0                       = f51 
tan_Q1                       = f52 
tan_Q2                       = f53 
tan_Q3                       = f54 
tan_Q4                       = f55 
tan_Q5                       = f56 
tan_Q6                       = f57 
tan_Q7                       = f58 
tan_Q8                       = f59
tan_Q9                       = f60
tan_Q10                      = f61

tan_r                        = f62
tan_rsq                      = f63
tan_rcube                    = f64

tan_v18                      = f65
tan_v16                      = f66
tan_v17                      = f67
tan_v12                      = f68
tan_v13                      = f69
tan_v7                       = f70
tan_v8                       = f71
tan_v4                       = f72
tan_v5                       = f73
tan_v15                      = f74
tan_v11                      = f75
tan_v14                      = f76
tan_v3                       = f77
tan_v6                       = f78
tan_v10                      = f79
tan_v2                       = f80
tan_v9                       = f81
tan_v1                       = f82
tan_int_Nfloat               = f83 
tan_Nfloat                   = f84 

tan_NORM_f8                  = f85 
tan_W                        = f86

tan_y0                       = f87
tan_d                        = f88 
tan_y1                       = f89 
tan_dsq                      = f90 
tan_y2                       = f91 
tan_d4                       = f92 
tan_inv_r                    = f93 


/////////////////////////////////////////////////////////////

tan_AD                       = r33
tan_GR_10009                 = r34 
tan_GR_17_ones               = r35 
tan_GR_N_odd_even            = r36 
tan_GR_N                     = r37 
tan_signexp                  = r38
tan_exp                      = r39
tan_ADQ                      = r40

GR_SAVE_PFS                  = r41 
GR_SAVE_B0                   = r42       
GR_SAVE_GP                   = r43      


.data

.align 16

double_tan_constants:
   data8 0xA2F9836E4E44152A, 0x00003FFE // 2/pi
   data8 0xC90FDAA22168C234, 0x00003FFF // pi/2 hi

   data8 0xBEEA54580DDEA0E1 // P14 
   data8 0x3ED3021ACE749A59 // P15
   data8 0xBEF312BD91DC8DA1 // P12 
   data8 0x3EFAE9AFC14C5119 // P13
   data8 0x3F2F342BF411E769 // P8
   data8 0x3F1A60FC9F3B0227 // P9
   data8 0x3EFF246E78E5E45B // P10
   data8 0x3F01D9D2E782875C // P11
   data8 0x3F8226E34C4499B6 // P4
   data8 0x3F6D6D3F12C236AC // P5
   data8 0x3F57DA1146DCFD8B // P6
   data8 0x3F43576410FE3D75 // P7
   data8 0x3FD5555555555555 // P0
   data8 0x3FC11111111111C2 // P1
   data8 0x3FABA1BA1BA0E850 // P2
   data8 0x3F9664F4886725A7 // P3

double_Q_tan_constants:
   data8 0xC4C6628B80DC1CD1, 0x00003FBF // pi/2 lo
   data8 0x3E223A73BA576E48 // Q8
   data8 0x3DF54AD8D1F2CA43 // Q9
   data8 0x3EF66A8EE529A6AA // Q4
   data8 0x3EC2281050410EE6 // Q5
   data8 0x3E8D6BB992CC3CF5 // Q6
   data8 0x3E57F88DE34832E4 // Q7
   data8 0x3FD5555555555555 // Q0
   data8 0x3F96C16C16C16DB8 // Q1
   data8 0x3F61566ABBFFB489 // Q2
   data8 0x3F2BBD77945C1733 // Q3
   data8 0x3D927FB33E2B0E04 // Q10


   
.align 32
.global tan#

////////////////////////////////////////////////////////



.section .text
.proc  tan#
.align 32
tan: 
// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mmi
      alloc          r32=ar.pfs,1,11,0,0               
(p0)  addl           tan_AD   = @ltoff(double_tan_constants), gp
      nop.i 999
}
;;

{ .mmi
      ld8 tan_AD = [tan_AD]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
	nop.m 999
(p0)  fnorm     tan_NORM_f8  = f8                      
(p0)  mov       tan_GR_17_ones     = 0x1ffff             ;;
}


{ .mfi
	nop.m 999
	nop.f 999
(p0)  mov       tan_GR_10009 = 0x10009  ;;
}
;;

{ .mmi
      adds tan_ADQ = double_Q_tan_constants - double_tan_constants, tan_AD
(p0)  ldfe      tan_Inv_Pi_by_2 = [tan_AD],16          
      nop.i 999
}
;;



{ .mfi
(p0)  ldfe      tan_Pi_by_2_hi = [tan_AD],16 
(p0)  fclass.m.unc  p6,p0 = f8, 0x07        
}
{ .mfi
(p0)  ldfe      tan_Pi_by_2_lo = [tan_ADQ],16           
        nop.f 999 
	nop.i 999 ;;
}


{ .mmb
(p0)  ldfd      tan_P14 = [tan_AD],8                         
(p0)  ldfd      tan_Q8  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P15 = [tan_AD],8                         
(p0)  ldfd      tan_Q9  = [tan_ADQ],8                        
	nop.b 999 ;;
}



{ .mmb
(p0)  ldfd      tan_P12 = [tan_AD],8                         
(p0)  ldfd      tan_Q4  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P13 = [tan_AD],8                         
(p0)  ldfd      tan_Q5  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P8  = [tan_AD],8                         
(p0)  getf.exp  tan_signexp    = tan_NORM_f8                 
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P9  = [tan_AD],8                         
(p0)  ldfd      tan_Q6  = [tan_ADQ],8
(p6)  br.ret.spnt    b0    ;; 
}


{ .mmi
(p0)  ldfd      tan_P10 = [tan_AD],8                         
(p0)  ldfd      tan_Q7  = [tan_ADQ],8                         
(p0)  and       tan_exp = tan_GR_17_ones, tan_signexp         ;;
}



// p7 is true if we must call DBX TAN
// p7 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)

{ .mfi
(p0)  ldfd      tan_P11 = [tan_AD],8                         
(p0)  fma.s1    tan_W   = tan_NORM_f8,          tan_Inv_Pi_by_2, f0    
(p0)  cmp.ge.unc  p7,p0 = tan_exp,tan_GR_10009               
}
{ .mfi
(p0)  ldfd      tan_Q0  = [tan_ADQ],8                         
        nop.f 999
        nop.i 999 ;;
}


{ .mmb
(p0)  ldfd      tan_P4  = [tan_AD],8                         
(p0)  ldfd      tan_Q1  = [tan_ADQ],8                         
(p7) br.cond.spnt   TAN_DBX ;;                                  
}


{ .mmb
(p0)  ldfd      tan_P5  = [tan_AD],8                         
(p0)  ldfd      tan_Q2  = [tan_ADQ],8                         
	nop.b 999 ;;
}



{ .mmb
(p0)  ldfd      tan_P6  = [tan_AD],8                         
(p0)  ldfd      tan_Q3  = [tan_ADQ],8                         
	nop.b 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P7  = [tan_AD],8 
(p0)  ldfd      tan_Q10 = [tan_ADQ],8                         
	nop.i 999 ;;
}


// tan_int_Nfloat = Round_Int_Nearest(tan_W)
{ .mfi
(p0)  ldfd      tan_P0  = [tan_AD],8                         
(p0)  fcvt.fx.s1  tan_int_Nfloat = tan_W                     
	nop.i 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P1  = [tan_AD],8 
        nop.m 999 
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfd      tan_P2  = [tan_AD],8                         
        nop.f 999
	nop.i 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P3  = [tan_AD],8                         
        nop.m 999
        nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fcvt.xf     tan_Nfloat     = tan_int_Nfloat            
	nop.i 999 ;; 
}


{ .mfi
(p0)  getf.sig    tan_GR_N = tan_int_Nfloat                  
	nop.f 999
	nop.i 999 ;;
}


{ .mmi
	nop.m 999
	nop.m 999
(p0)  and         tan_GR_N_odd_even = 0x1, tan_GR_N ;;          
}

// p8 ==> even
// p9 ==> odd
{ .mmi
	nop.m 999
	nop.m 999
(p0)  cmp.eq.unc  p8,p9          = tan_GR_N_odd_even, r0      ;;
}



// tan_r          = -tan_Nfloat * tan_Pi_by_2_hi + x
{ .mfi
	nop.m 999
(p0)  fnma.s1  tan_r      = tan_Nfloat, tan_Pi_by_2_hi,  tan_NORM_f8         
	nop.i 999 ;;
}


// tan_r          = tan_r -tan_Nfloat * tan_Pi_by_2_lo 
{ .mfi
	nop.m 999
(p0)  fnma.s1  tan_r      = tan_Nfloat, tan_Pi_by_2_lo,  tan_r      
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p0)  fma.s1   tan_rsq    = tan_r, tan_r,   f0                      
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  frcpa.s1   tan_y0, p10 = f1,tan_r                  
	nop.i 999  ;;
}





{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v18 = tan_rsq, tan_P15, tan_P14        
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v4  = tan_rsq, tan_P1, tan_P0          
	nop.i 999  ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v16 = tan_rsq, tan_P13, tan_P12        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v17 = tan_rsq, tan_rsq, f0             
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v12 = tan_rsq, tan_P9, tan_P8          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v13 = tan_rsq, tan_P11, tan_P10        
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v7  = tan_rsq, tan_P5, tan_P4          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v8  = tan_rsq, tan_P7, tan_P6          
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fnma.s1    tan_d   = tan_r, tan_y0, f1   
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v5  = tan_rsq, tan_P3, tan_P2          
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v11 = tan_rsq, tan_Q9, tan_Q8         
	nop.i 999
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v12 = tan_rsq, tan_rsq, f0            
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v15 = tan_v17, tan_v18, tan_v16        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v7 = tan_rsq, tan_Q5, tan_Q4          
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v11 = tan_v17, tan_v13, tan_v12        
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v14 = tan_v17, tan_v17, f0             
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v8 = tan_rsq, tan_Q7, tan_Q6          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v3 = tan_rsq, tan_Q1, tan_Q0          
	nop.i 999 ;; 
}




{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v3 = tan_v17, tan_v5, tan_v4           
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v6 = tan_v17, tan_v8, tan_v7           
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1     tan_y1  = tan_y0, tan_d, tan_y0    
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v10 = tan_v12, tan_Q10, tan_v11       
	nop.i 999 ;; 
}


{ .mfi
	nop.m 999
(p9)  fma.s1     tan_dsq = tan_d, tan_d, f0        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v9  = tan_v12, tan_v12,f0             
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v4 = tan_rsq, tan_Q3, tan_Q2          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v6  = tan_v12, tan_v8, tan_v7         
	nop.i 999 ;; 
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v10 = tan_v14, tan_v15, tan_v11        
	nop.i 999 ;; 
}



{ .mfi
	nop.m 999
(p9)  fma.s1     tan_y2  = tan_y1, tan_d, tan_y0         
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1     tan_d4  = tan_dsq, tan_dsq, tan_d       
	nop.i 999  ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v2 = tan_v14, tan_v6, tan_v3           
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v9 = tan_v14, tan_v14, f0              
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v2  = tan_v12, tan_v4, tan_v3         
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v5  = tan_v9, tan_v10, tan_v6         
	nop.i 999  ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1     tan_inv_r = tan_d4, tan_y2, tan_y0      
	nop.i 999 
}
{ .mfi
        nop.m 999
(p8)  fma.s1   tan_rcube  = tan_rsq, tan_r,   f0
        nop.i 999  ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v1 = tan_v9, tan_v10, tan_v2           
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v1  = tan_v9, tan_v5, tan_v2          
	nop.i 999   ;;
}



{ .mfb
	nop.m 999
(p8)  fma.d   f8  = tan_v1, tan_rcube, tan_r             
(p0)  nop.b 999  
}
{ .mfb
	nop.m 999
(p9)  fms.d.s0  f8      = tan_r, tan_v1, tan_inv_r        
(p0)  br.ret.sptk    b0 ;;    
}
.endp tan#


.proc __libm_callout
__libm_callout:
TAN_DBX: 
.prologue

{ .mfi
        nop.m 0
     fmerge.s f9 = f0,f0 
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mfb
      nop.m 999
      nop.f 999
(p0)   br.call.sptk.many  b0=__libm_tan# ;;
}


{ .mfi
(p0)   mov gp        = GR_SAVE_GP
(p0)  fnorm.d     f8 = f8
(p0)   mov b0        = GR_SAVE_B0 
}
;;


{ .mib
         nop.m 999
(p0)  mov ar.pfs    = GR_SAVE_PFS
(p0)  br.ret.sptk     b0
;;
}


.endp  __libm_callout

.type __libm_tan#,@function
.global __libm_tan#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\sqrtf.s ===
.file "sqrtf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
// History:
//
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//
// Function:   Combined sqrtf(x), where
//                         _
//             sqrtf(x) = |x, for single precision x values
//
//********************************************************************
//
// Accuracy:       Correctly Rounded 
//
//********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f7 -f14
//
//    General Purpose Registers:
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6, p7, p8
//
//********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    sqrtf(QNaN) = QNaN
//    sqrtf(SNaN) = QNaN
//    sqrtf(+/-0) = +/-0 
//    sqrtf(negative) = QNaN and error handling is called
//
//********************************************************************
//
// Implementation:
//
//  Modified Newton-Raphson Algorithm
//
//********************************************************************


GR_SAVE_B0                    = r34
GR_SAVE_PFS                   = r33
GR_SAVE_GP                    = r35 

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f13
FR_Y             = f0
FR_RESULT        = f8



.section .text
.proc sqrtf#
.global sqrtf#
.align 64 

sqrtf: 
{ .mlx
  // BEGIN SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
  alloc r32= ar.pfs,0,5,4,0
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe
} { .mfi
  // +1/2 in f12
  nop.m 0
  frsqrta.s0 f7,p6=f8
  nop.i 0;;
} { .mfi
  setf.exp f12 = r2
  // Step (1)
  // y0 = 1/sqrt(a) in f7
  fclass.m.unc p7,p8 = f8,0x3A 
  nop.i 0
} { .mfi
  nop.m 0
  // Make a copy of x just in case 
  mov f13 = f8 
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (2)
  // H0 = 1/2 * y0 in f9
  (p6) fma.s1 f9=f12,f7,f0
  nop.i 0
} { .mfi
  nop.m 0
  // Step (3)
  // S0 = a * y0 in f7
  (p6) fma.s1 f7=f8,f7,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (4)
  // d = 1/2 - S0 * H0 in f10
  (p6) fnma.s1 f10=f7,f9,f12
  nop.i 0
} { .mfi
  nop.m 0
  // Step (0'')
  // 3/2 = 1 + 1/2 in f12
  (p6) fma.s1 f12=f12,f1,f1
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (5)
  // e = 1 + 3/2 * d in f12
  (p6) fma.s1 f12=f12,f10,f1
  nop.i 0
} { .mfi
  nop.m 0
  // Step (6)
  // T0 = d * S0 in f11
  (p6) fma.s1 f11=f10,f7,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (7)
  // G0 = d * H0 in f10
  (p6) fma.s1 f10=f10,f9,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (8)
  // S1 = S0 + e * T0 in f7
  (p6) fma.s.s1 f7=f12,f11,f7
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (9)
  // H1 = H0 + e * G0 in f12
  (p6) fma.s1 f12=f12,f10,f9
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (10)
  // d1 = a - S1 * S1 in f9
  (p6) fnma.s1 f9=f7,f7,f8
  nop.i 0;;;
} { .mfb
  nop.m 0
  // Step (11)
  // S = S1 + d1 * H1 in f7
  (p6) fma.s.s0 f8=f9,f12,f7
  (p6) br.ret.sptk   b0 ;;
// END SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
} { .mfb
  nop.m 0
  (p0) mov   f8 = f7
  (p8) br.ret.sptk b0 ;;
}
//
// This branch includes all those special values that are not negative,
// with the result equal to frcpa(x)
//
.endp sqrtf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
(p0)    mov   GR_Parameter_TAG = 50                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\tanf.s ===
.file "tanf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added
//
// API
//==============================================================
// float tanf( float x);
//
// Overview of operation
//==============================================================
// If the input value in radians is |x| >= 1.xxxxx 2^10 call the
// older slower version.
//
// The new algorithm is used when |x| <= 1.xxxxx 2^9.
//
// Represent the input X as Nfloat * pi/2 + r
//    where r can be negative and |r| <= pi/4
//
//     tan_W  = x * 2/pi
//     Nfloat = round_int(tan_W)
//
//     tan_r  = x - Nfloat * (pi/2)_hi
//     tan_r  = tan_r - Nfloat * (pi/2)_lo
//
// We have two paths: p8, when Nfloat is even and p9. when Nfloat is odd.
// p8: tan(X) =  tan(r)
// p9: tan(X) = -cot(r)
//
// Each is evaluated as a series. The p9 path requires 1/r.
//
// The coefficients used in the series are stored in a table as
// are the pi constants.
//
// Registers used
//==============================================================
//
// predicate registers used:  
// p6, p7, p8, p9, p10
//
// floating-point registers used:  
// f32 ->  f93
// f8, input
//
// general registers used
// r32 -> r43
//
// Assembly macros
//==============================================================
tan_Inv_Pi_by_2              = f32
tan_Pi_by_2_hi               = f33
tan_Pi_by_2_lo               = f34


tan_P0                       = f35
tan_P1                       = f36
tan_P2                       = f37
tan_P3                       = f38 
tan_P4                       = f39 
tan_P5                       = f40 
tan_P6                       = f41
tan_P7                       = f42
tan_P8                       = f43 
tan_P9                       = f44 
tan_P10                      = f45 
tan_P11                      = f46
tan_P12                      = f47 
tan_P13                      = f48
tan_P14                      = f49
tan_P15                      = f50

tan_Q0                       = f51 
tan_Q1                       = f52 
tan_Q2                       = f53 
tan_Q3                       = f54 
tan_Q4                       = f55 
tan_Q5                       = f56 
tan_Q6                       = f57 
tan_Q7                       = f58 
tan_Q8                       = f59
tan_Q9                       = f60
tan_Q10                      = f61

tan_r                        = f62
tan_rsq                      = f63
tan_rcube                    = f64

tan_v18                      = f65
tan_v16                      = f66
tan_v17                      = f67
tan_v12                      = f68
tan_v13                      = f69
tan_v7                       = f70
tan_v8                       = f71
tan_v4                       = f72
tan_v5                       = f73
tan_v15                      = f74
tan_v11                      = f75
tan_v14                      = f76
tan_v3                       = f77
tan_v6                       = f78
tan_v10                      = f79
tan_v2                       = f80
tan_v9                       = f81
tan_v1                       = f82
tan_int_Nfloat               = f83 
tan_Nfloat                   = f84 

tan_NORM_f8                  = f85 
tan_W                        = f86

tan_y0                       = f87
tan_d                        = f88 
tan_y1                       = f89 
tan_dsq                      = f90 
tan_y2                       = f91 
tan_d4                       = f92 
tan_inv_r                    = f93 


/////////////////////////////////////////////////////////////

tan_AD                       = r33
tan_GR_10009                 = r34 
tan_GR_17_ones               = r35 
tan_GR_N_odd_even            = r36 
tan_GR_N                     = r37 
tan_signexp                  = r38
tan_exp                      = r39
tan_ADQ                      = r40

GR_SAVE_B0                    = r42
GR_SAVE_PFS                   = r41
GR_SAVE_GP                    = r43


.data

.align 16

double_tan_constants:
   data8 0xA2F9836E4E44152A, 0x00003FFE // 2/pi
   data8 0xC90FDAA22168C234, 0x00003FFF // pi/2 hi

   data8 0xBEEA54580DDEA0E1 // P14 
   data8 0x3ED3021ACE749A59 // P15
   data8 0xBEF312BD91DC8DA1 // P12 
   data8 0x3EFAE9AFC14C5119 // P13
   data8 0x3F2F342BF411E769 // P8
   data8 0x3F1A60FC9F3B0227 // P9
   data8 0x3EFF246E78E5E45B // P10
   data8 0x3F01D9D2E782875C // P11
   data8 0x3F8226E34C4499B6 // P4
   data8 0x3F6D6D3F12C236AC // P5
   data8 0x3F57DA1146DCFD8B // P6
   data8 0x3F43576410FE3D75 // P7
   data8 0x3FD5555555555555 // P0
   data8 0x3FC11111111111C2 // P1
   data8 0x3FABA1BA1BA0E850 // P2
   data8 0x3F9664F4886725A7 // P3

double_Q_tan_constants:
   data8 0xC4C6628B80DC1CD1, 0x00003FBF // pi/2 lo
   data8 0x3E223A73BA576E48 // Q8
   data8 0x3DF54AD8D1F2CA43 // Q9
   data8 0x3EF66A8EE529A6AA // Q4
   data8 0x3EC2281050410EE6 // Q5
   data8 0x3E8D6BB992CC3CF5 // Q6
   data8 0x3E57F88DE34832E4 // Q7
   data8 0x3FD5555555555555 // Q0
   data8 0x3F96C16C16C16DB8 // Q1
   data8 0x3F61566ABBFFB489 // Q2
   data8 0x3F2BBD77945C1733 // Q3
   data8 0x3D927FB33E2B0E04 // Q10


   
.align 32
.global tan#

////////////////////////////////////////////////////////



.section .text
.global tanf
.proc  tanf
.align 32
tanf: 
// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mmi
      alloc          r32=ar.pfs,1,11,0,0               
(p0)  addl           tan_AD   = @ltoff(double_tan_constants), gp
      nop.i 999
}
;;

{ .mmi
      ld8 tan_AD = [tan_AD]
      nop.m 999
      nop.i 999
}
;;

{ .mfi
	nop.m 999
(p0)  fnorm     tan_NORM_f8  = f8                      
(p0)  mov       tan_GR_17_ones     = 0x1ffff             ;;
}

{ .mfi
	nop.m 999
	nop.f 999
(p0)  mov       tan_GR_10009 = 0x10009  ;;
}



{ .mmi
      adds tan_ADQ = double_Q_tan_constants - double_tan_constants, tan_AD
(p0)  ldfe      tan_Inv_Pi_by_2 = [tan_AD],16          
	nop.i 999  
}
;;


{ .mfi
(p0)  ldfe      tan_Pi_by_2_hi = [tan_AD],16 
(p0)  fclass.m.unc  p6,p0 = f8, 0x07        
}
{ .mfi
(p0)  ldfe      tan_Pi_by_2_lo = [tan_ADQ],16           
        nop.f 999 
	nop.i 999 ;;
}


{ .mmb
(p0)  ldfd      tan_P14 = [tan_AD],8                         
(p0)  ldfd      tan_Q8  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P15 = [tan_AD],8                         
(p0)  ldfd      tan_Q9  = [tan_ADQ],8                        
	nop.b 999 ;;
}



{ .mmb
(p0)  ldfd      tan_P12 = [tan_AD],8                         
(p0)  ldfd      tan_Q4  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P13 = [tan_AD],8                         
(p0)  ldfd      tan_Q5  = [tan_ADQ],8                        
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P8  = [tan_AD],8                         
(p0)  getf.exp  tan_signexp    = tan_NORM_f8                 
	nop.b 999 ;;
}

{ .mmb
(p0)  ldfd      tan_P9  = [tan_AD],8                         
(p0)  ldfd      tan_Q6  = [tan_ADQ],8
(p6)  br.ret.spnt    b0    ;; 
}


{ .mmi
(p0)  ldfd      tan_P10 = [tan_AD],8                         
(p0)  ldfd      tan_Q7  = [tan_ADQ],8                         
(p0)  and       tan_exp = tan_GR_17_ones, tan_signexp         ;;
}



// p7 is true if we must call DBX TAN
// p7 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)

{ .mfi
(p0)  ldfd      tan_P11 = [tan_AD],8                         
(p0)  fma.s1    tan_W   = tan_NORM_f8,          tan_Inv_Pi_by_2, f0    
(p0)  cmp.ge.unc  p7,p0 = tan_exp,tan_GR_10009               
}
{ .mfi
(p0)  ldfd      tan_Q0  = [tan_ADQ],8                         
        nop.f 999
        nop.i 999 ;;
}


{ .mmb
(p0)  ldfd      tan_P4  = [tan_AD],8                         
(p0)  ldfd      tan_Q1  = [tan_ADQ],8                         
(p7) br.cond.spnt   TAN_DBX ;;                                  
}


{ .mmb
(p0)  ldfd      tan_P5  = [tan_AD],8                         
(p0)  ldfd      tan_Q2  = [tan_ADQ],8                         
	nop.b 999 ;;
}



{ .mmb
(p0)  ldfd      tan_P6  = [tan_AD],8                         
(p0)  ldfd      tan_Q3  = [tan_ADQ],8                         
	nop.b 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P7  = [tan_AD],8 
(p0)  ldfd      tan_Q10 = [tan_ADQ],8                         
	nop.i 999 ;;
}


// tan_int_Nfloat = Round_Int_Nearest(tan_W)
{ .mfi
(p0)  ldfd      tan_P0  = [tan_AD],8                         
(p0)  fcvt.fx.s1  tan_int_Nfloat = tan_W                     
	nop.i 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P1  = [tan_AD],8 
        nop.m 999 
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfd      tan_P2  = [tan_AD],8                         
        nop.f 999
	nop.i 999 ;;
}


{ .mmi
(p0)  ldfd      tan_P3  = [tan_AD],8                         
        nop.m 999
        nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fcvt.xf     tan_Nfloat     = tan_int_Nfloat            
	nop.i 999 ;;
}


{ .mmi
	nop.m 999
(p0)  getf.sig    tan_GR_N = tan_int_Nfloat                  
	nop.i 999 ;;
}


{ .mmi
	nop.m 999
	nop.m 999
(p0)  and         tan_GR_N_odd_even = 0x1, tan_GR_N ;;          
}

// p8 ==> even
// p9 ==> odd
{ .mmi
	nop.m 999
	nop.m 999
(p0)  cmp.eq.unc  p8,p9          = tan_GR_N_odd_even, r0      ;;
}



// tan_r          = -tan_Nfloat * tan_Pi_by_2_hi + x
{ .mfi
	nop.m 999
(p0)  fnma.s1  tan_r      = tan_Nfloat, tan_Pi_by_2_hi,  tan_NORM_f8         
	nop.i 999 ;;
}


// tan_r          = tan_r -tan_Nfloat * tan_Pi_by_2_lo 
{ .mfi
	nop.m 999
(p0)  fnma.s1  tan_r      = tan_Nfloat, tan_Pi_by_2_lo,  tan_r      
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p0)  fma.s1   tan_rsq    = tan_r, tan_r,   f0                      
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  frcpa.s1   tan_y0, p10 = f1,tan_r                  
	nop.i 999  ;;
}





{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v18 = tan_rsq, tan_P15, tan_P14        
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v4  = tan_rsq, tan_P1, tan_P0          
	nop.i 999  ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v16 = tan_rsq, tan_P13, tan_P12        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v17 = tan_rsq, tan_rsq, f0             
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v12 = tan_rsq, tan_P9, tan_P8          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v13 = tan_rsq, tan_P11, tan_P10        
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v7  = tan_rsq, tan_P5, tan_P4          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v8  = tan_rsq, tan_P7, tan_P6          
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fnma.s1    tan_d   = tan_r, tan_y0, f1   
	nop.i 999 
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v5  = tan_rsq, tan_P3, tan_P2          
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v11 = tan_rsq, tan_Q9, tan_Q8         
	nop.i 999
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v12 = tan_rsq, tan_rsq, f0            
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v15 = tan_v17, tan_v18, tan_v16        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v7 = tan_rsq, tan_Q5, tan_Q4          
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v11 = tan_v17, tan_v13, tan_v12        
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v14 = tan_v17, tan_v17, f0             
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v8 = tan_rsq, tan_Q7, tan_Q6          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v3 = tan_rsq, tan_Q1, tan_Q0          
	nop.i 999 ;; 
}




{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v3 = tan_v17, tan_v5, tan_v4           
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v6 = tan_v17, tan_v8, tan_v7           
	nop.i 999 ;;
}



{ .mfi
	nop.m 999
(p9)  fma.s1     tan_y1  = tan_y0, tan_d, tan_y0    
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v10 = tan_v12, tan_Q10, tan_v11       
	nop.i 999 ;; 
}


{ .mfi
	nop.m 999
(p9)  fma.s1     tan_dsq = tan_d, tan_d, f0        
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v9  = tan_v12, tan_v12,f0             
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v4 = tan_rsq, tan_Q3, tan_Q2          
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v6  = tan_v12, tan_v8, tan_v7         
	nop.i 999 ;; 
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v10 = tan_v14, tan_v15, tan_v11        
	nop.i 999 ;; 
}



{ .mfi
	nop.m 999
(p9)  fma.s1     tan_y2  = tan_y1, tan_d, tan_y0         
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1     tan_d4  = tan_dsq, tan_dsq, tan_d       
	nop.i 999  ;;
}


{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v2 = tan_v14, tan_v6, tan_v3           
	nop.i 999
}
{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v9 = tan_v14, tan_v14, f0              
	nop.i 999 ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v2  = tan_v12, tan_v4, tan_v3         
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v5  = tan_v9, tan_v10, tan_v6         
	nop.i 999  ;;
}


{ .mfi
	nop.m 999
(p9)  fma.s1     tan_inv_r = tan_d4, tan_y2, tan_y0      
	nop.i 999 
}
{ .mfi
        nop.m 999
(p8)  fma.s1   tan_rcube  = tan_rsq, tan_r,   f0
        nop.i 999  ;;
}



{ .mfi
	nop.m 999
(p8)  fma.s1  tan_v1 = tan_v9, tan_v10, tan_v2           
	nop.i 999 
}
{ .mfi
	nop.m 999
(p9)  fma.s1  tan_v1  = tan_v9, tan_v5, tan_v2          
	nop.i 999   ;;
}



{ .mfb
	nop.m 999
(p8)  fma.s   f8  = tan_v1, tan_rcube, tan_r             
(p0)  nop.b 999  
}
{ .mfb
	nop.m 999
(p9)  fms.s.s0  f8      = tan_r, tan_v1, tan_inv_r        
(p0)  br.ret.sptk    b0 ;;    
}
.endp tanf


.proc TAN_DBX
TAN_DBX: 
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
};;
{ .mfi
        mov GR_SAVE_GP=gp                       // Save gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
}
.body
{ .mfi
	nop.m 999
(p0) fmerge.s f9 = f1,f1 
	nop.i 999   ;;
}

{ .mib
	nop.m 999
	nop.i 999                      
(p0)  br.call.sptk.many   b0=__libm_tan# ;;            
}
{ .mmi
    mov   gp = GR_SAVE_GP                  // Restore gp
	nop.m 999
    mov   b0 = GR_SAVE_B0;;                // Restore return address
}

{ .mfi
      nop.m 999
(p0)  fnorm.s f8 = f8
      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
};;

{ .mib
         nop.m 999
         nop.i 999
(p0)  br.ret.sptk     b0
;;
}
.endp TAN_DBX


.type __libm_tan#,@function
.global __libm_tan#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_ceil.s ===
#include "ceil.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_fabs.s ===
#include "fabs.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_exp.s ===
#include "exp.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_hypot.s ===
#include "hypot.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_floor.s ===
#include "floor.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_fmod.s ===
#include "fmod.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_ldexp.s ===
#include "ldexp.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_log.s ===
#include "log.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_pow.s ===
#include "pow.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_sincos.s ===
#include "sincos.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_modf.s ===
#include "modf.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_tan.s ===
#include "tan.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\_sqrt.s ===
#include "sqrt.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\include\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
//
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals   - only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagReserved,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

enum LocationType
{
    LocIsNull,
    LocIsStatic,
    LocIsTLS,
    LocIsRegRel,
    LocIsThisRel,
    LocIsEnregistered,
    LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
    LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum BasicType
{
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_RESERVED1    = 0xD0,
    CV_CFL_EBC          = 0xE0,
    CV_CFL_THUMB        = 0xF0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194,
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,

    CV_REG_XMM0H    =  202,
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212, // EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228,
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0    =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,

    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,

    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

} CV_HREG_e;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\include\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*	01-25-00  GB    Declared _CxxThrowException __declspec(noreturn)
*	02-08-00  GB    Added HT_ISCOMPLUSEH
*	03-27-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       09-20-00  GB    Add __cdecl to URT C++ EH support routines (vs7#89576)
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#ifdef ONLY_VALUES
#define _EHDATA_NOHEADERS
#endif

#ifndef _CRTBLD
#ifndef _VC_VER_INC
#ifdef _M_ALPHA
#include "vcver.h"
#else
#include "..\include\vcver.h"
#endif
#endif
#endif /* _CRTBLD */


#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#if defined(_M_IA64) || defined(_M_AMD64)
#define EH_EXCEPTION_PARAMETERS 4			// Number of parameters in exception record
#else
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record
#endif

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

#define EH_EMPTY_STATE	-1

#ifndef ONLY_VALUES

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
	__int32		mdisp;		// Offset of intended data within base
	__int32		pdisp;		// Displacement to virtual base pointer
	__int32		vdisp;		// Index within vbTable to offset of base
#else
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
#endif
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

#ifndef WANT_NO_TYPES
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
typedef	__int32	PMFN;					// Image relative offset of Member Function
#else
typedef void (* __ptr64 PMFN)(void* __ptr64);
#endif
#else
typedef void (*PMFN)(void);
#endif
#endif // WANT_NO_TYPES

//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7) || defined(_M_AMD64)
#pragma pack(push, TypeDescriptor, 8)
#endif

#ifndef WANT_NO_TYPES
typedef struct TypeDescriptor
{
#if defined(_WIN64) /*IFSTRIP=IGN*/
	const void * __ptr64	pVFTable;	// Field overloaded by RTTI
	void * __ptr64			spare;		// reserved, possible for RTTI
#else	// _WIN64
#if defined(_RTTI)
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
#endif	// _WIN64
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#endif // WANT_NO_TYPES

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7) || defined(_M_AMD64)
#pragma pack(pop, TypeDescriptor)
#endif
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pType;					// Image relative offset of TypeDescriptor
#else
	TypeDescriptor * __ptr64 pType;			// Pointer to the type descriptor for this type
#endif
#else
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
#endif
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;
#endif // WANT_NO_TYPES

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#if defined(_M_IA64) || defined(_M_AMD64)
#define CT_PTD_IB(ct,ib)		((TypeDescriptor *)((ib) + (ct).pType))
#define CT_COPYFUNC_IB(ct,ib)	((void (* __ptr64)(void* __ptr64))((ib) + (ct).copyFunction))
#else
#define CT_PTD(ct)			((ct).pType)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#endif
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			arrayOfCatchableTypes[];	// Image relative offset of Catchable Types
#else
	CatchableType	* __ptr64 arrayOfCatchableTypes[];
#endif
#else
	CatchableType	*arrayOfCatchableTypes[];
#endif
	} CatchableTypeArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pForwardCompat;		// Image relative offset of Forward compatibility frame handler
	__int32			pCatchableTypeArray;// Image relative offset of CatchableTypeArray
#else
	int	(__cdecl* __ptr64 pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	* __ptr64 pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
#else
	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
} ThrowInfo;
#endif // WANT_NO_TYPES

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#if defined(_M_IA64) || defined(_M_AMD64)
#define THROW_UNWINDFUNC_IB(t,ib)		((void (* __ptr64)(void* __ptr64))((ib) + (t).pmfnUnwind))
#define THROW_FORWARDCOMPAT_IB(t,ib)	((int(__cdecl * __ptr64)(...))((ib) + (t).pForwardCompat))
#define THROW_CTARRAY_IB(t,ib)			((CatchableTypeArray*)((ib) + (t).pCatchableTypeArray))
#define THROW_COUNT_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->nCatchableTypes)
#define THROW_CTLIST_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->arrayOfCatchableTypes)
#else
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#endif
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#ifndef WANT_NO_TYPES
extern "C" int __cdecl __CxxExceptionFilter(void*, void*, int, void *);

// Returns true if the object is really a C++ exception
// If it is, stores the previous exception in *storage, and saves the current one
// This is needed to keep track of the current exception object (used for rethrow & destruction)
extern "C" int __cdecl __CxxRegisterExceptionObject(void *exception, void *storage);

// Returns true if exception is a C++ rethrown exception
// This is needed, so Unregister can know whether or not to destroy the object
extern "C" int __cdecl __CxxDetectRethrow(void *exception);

// Returns the byte count of stack space required to store the exception info
extern "C" int __cdecl __CxxQueryExceptionSize(void);

// Pops the current exception, restoring the previous one from *storage
// This detects whether or not the exception object needs to be destroyed
extern "C" void __cdecl __CxxUnregisterExceptionObject(void *storage, int rethrow);

#endif // WANT_NO_TYPES

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index


//
// HandlerType - description of a single 'catch'
//

#ifndef WANT_NO_TYPES
typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
	__int32			dispType;			// Image relative offset of the corresponding type descriptor
	__int32			dispCatchObj;		// Displacement of catch object from base
	__int32			dispOfHandler;		// Image relative offset of 'catch' code
#if defined(_M_AMD64)
    __int32         dispFrame;          // displacement of address of function frame wrt establisher frame
#endif
#else
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
#if defined(_M_ALPHA64)
	__int32			dispCatchObj;		// Displacement of catch object from base
#else
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
#endif
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
#endif
} HandlerType;
#endif

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)
#define HT_IsComplusEh      0x80000000      // Is handling within complus eh.

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#define HT_PTD_IB(ht,ib)		((TypeDescriptor*)((ib) + (ht).dispType))
#define HT_HANDLER_IB(ht,ib)	((void* __ptr64)((ib) + (ht).dispOfHandler))
#else
#define HT_PTD(ht)				((ht).pType)
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#endif
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)
#define SET_HT_ISCOMPLUSEH(ht)  (HT_ADJECTIVES(ht) |= HT_IsComplusEh)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)
#define HT_ISCOMPLUSEH(ht)      (HT_ADJECTIVES(ht) & HT_IsComplusEh)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		dispHandlerArray;	// Image relative offset of list of handlers for this try
#else
	HandlerType *pHandlerArray;		// List of handlers for this try
#endif
} TryBlockMapEntry;
#endif // WANT_NO_TYPES

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
#define TBME_PLIST(hm,ib)	((HandlerType*)((ib) + (hm).dispHandlerArray))
#define TBME_CATCH(hm,n,ib)	(TBME_PLIST(hm,ib)[n])
#define TBME_PCATCH(hm,n,ib)(&(TBME_PLIST(hm,ib)[n]))
#else
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32			action;				// Image relative offset of funclet
#else
	void			(*action)(void);	// Funclet to call to effect state change
#endif
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UWE_ACTION_IB(uwe,ib)	((void (*__ptr64)(void))((ib) + (uwe).action))
#else
#define UWE_ACTION(uwe)			((uwe).action)
#endif

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		Ip;		// Image relative offset of IP
#else
	ULONG		Ip;
#endif
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

// bbtFlags values
#define BBT_UNIQUE_FUNCINFO 1

#ifndef WANT_NO_TYPES
typedef const struct _s_FuncInfo
{
    unsigned int		magicNumber:29;		// Identifies version of compiler
    unsigned int        bbtFlags:3;         // flags that may be set by BBT processing
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
#if defined(_M_IA64) || defined (_M_AMD64)	/*IFSTRIP=IGN*/
	__int32				dispUnwindMap;		// Image relative offset of the unwind map
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	__int32				dispTryBlockMap;	// Image relative offset of the handler map
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
	__int32				dispIPtoStateMap;	// Image relative offset of the IP to state map
	__int32				dispUwindHelp;		// Displacement of unwind helpers from base
#else
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;		// An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
#endif
} FuncInfo;
#endif // WANT_NO_TYPES

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#if defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_PUNWINDMAP(fi,ib)	((UnwindMapEntry*)((ib) + (fi).dispUnwindMap))
#define FUNC_PHANDLERMAP(fi,ib)	((TryBlockMapEntry*)((ib) + (fi).dispTryBlockMap))
#define FUNC_IPMAP(fi,ib)		((IptoStateMapEntry*)((ib) + (fi).dispIPtoStateMap))
#define FUNC_UNWIND(fi,st,ib)	(FUNC_PUNWINDMAP(fi,ib)[st])
#define FUNC_PUNWIND(fi,st,ib)	(&FUNC_UNWIND(fi,st,ib))
#define FUNC_TRYBLOCK(fi,n,ib)	(FUNC_PHANDLERMAP(fi,ib)[n])
#define FUNC_PTRYBLOCK(fi,n,ib)	(&FUNC_TRYBLOCK(fi,n,ib))
#else
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#endif
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_IPTOSTATE(fi,n,ib)	(FUNC_IPMAP(fi,ib)[n])
#define FUNC_PIPTOSTATE(fi,n,ib)(&FUNC_IPTOSTATE(fi,n,ib))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUwindHelp)
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_IA64) /*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _FRAME_POINTERS {
    __int64 MemoryStackFp;                     // memory stack frame pointer
    __int64 BackingStoreFp;                    // backing store frame pointer
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _UNWIND_INFO {
    unsigned __int16 Version;                  // Version Number
    unsigned __int16 Flags;                    // Flags
    unsigned __int32 DataLength;               // Length of Descriptor Data
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions


//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef FRAME_POINTERS EHRegistrationNode;

#elif defined(_M_AMD64)/*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef union _UNWIND_CODE {
    struct {
        unsigned char CodeOffset;
        unsigned char UnwindOp : 4;
        unsigned char OpInfo : 4;
    };
    unsigned short FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;
typedef struct _UNWIND_INFO {
    unsigned char Version : 3;                 // Version Number
    unsigned char Flags   : 5;                 // Flags
    unsigned char SizeOfProlog;
    unsigned char CountOfCodes;
    unsigned FrameRegister : 4;
    unsigned FrameOffset   : 4;
    UNWIND_CODE UnwindCode[1];
/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes+1)&~1)-1];
 *  union {
 *      OPTIONAL ULONG ExceptionHandler;
 *      OPTIONAL ULONG FunctionEntry;
 *  };
 *  OPTIONAL ULONG ExceptionData[];
 */
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif


typedef struct _xDISPATCHER_CONTEXT {
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;
    ULONG64 TargetIp;
    PCONTEXT ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(push, EHContext, 8)
#endif

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG_PTR BeginAddress;
    ULONG_PTR EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG_PTR PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG_PTR ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;
#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, EHContext)
#endif

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#else
#error "Machine not supported"
#endif

/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//
#if defined(_M_IA64) || defined(_M_ALPHA64)	|| defined(_M_AMD64) /*IFSTRIP=IGN*/
#pragma pack(push, ExceptionRecord, 8)
#endif
#ifndef WANT_NO_TYPES
typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
#if defined(_M_IA64) || defined(_M_AMD64)
		void		*pThrowImageBase;	// Image base of thrown object
#endif
		} params;
} EHExceptionRecord;
#endif // WANT_NO_TYPES
#if defined(_M_IA64) || defined(_M_ALPHA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, ExceptionRecord)
#endif

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#if defined(_M_IA64) || defined(_M_AMD64)
#define PER_PTHROWIB(per)	((per)->params.pThrowImageBase)
#endif
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))

/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_IA64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     unsigned __int64 *TargetGp
    );

#elif defined(_M_AMD64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
RtlUnwindEx (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord,
    IN void *HistoryTable
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     void             *HistoryTable
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );

#endif

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#endif /* ONLY_VALUES */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\include\rttidata.h ===
//
//	_RTTIBaseClassDescriptor
//
//	TypeDescriptor is declared in ehdata.h
//
#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(push, rttidata, 4)
#endif

#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassDescriptor	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32     					pTypeDescriptor;    // Image relative offset of TypeDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
#endif
	DWORD							numContainedBases;
	PMD								where;
	DWORD							attributes;
	} _RTTIBaseClassDescriptor;
#endif // WANT_NO_TYPES

#define BCD_NOTVISIBLE				0x00000001
#define BCD_AMBIGUOUS				0x00000002
#define BCD_PRIVORPROTINCOMPOBJ		0x00000004
#define BCD_PRIVORPROTBASE			0x00000008
#define BCD_VBOFCONTOBJ				0x00000010
#define BCD_NONPOLYMORPHIC			0x00000020

#define BCD_PTD(bcd)				((bcd).pTypeDescriptor)
#define BCD_NUMCONTBASES(bcd)		((bcd).numContainedBases)
#define BCD_WHERE(bcd)				((bcd).where)
#define BCD_ATTRIBUTES(bcd)			((bcd).attributes)
#if defined(_M_IA64)
#define BCD_PTD_IB(bcd,ib)			((TypeDescriptor*)((ib) + (bcd).pTypeDescriptor))
#endif


//
//	_RTTIBaseClassArray
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassArray	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32                 		arrayOfBaseClassDescriptors[];  // Image relative offset of _RTTIBaseClassDescriptor
#else
	_RTTIBaseClassDescriptor		*arrayOfBaseClassDescriptors[];
#endif
	} _RTTIBaseClassArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
//	_RTTIClassHierarchyDescriptor
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIClassHierarchyDescriptor	{
	DWORD							signature;
	DWORD							attributes;
	DWORD							numBaseClasses;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32         				pBaseClassArray;    // Image relative offset of _RTTIBaseClassArray
#else
	_RTTIBaseClassArray				*pBaseClassArray;
#endif
	} _RTTIClassHierarchyDescriptor;
#endif // WANT_NO_TYPES

#define CHD_MULTINH					0x00000001
#define CHD_VIRTINH					0x00000002
#define CHD_AMBIGUOUS				0x00000004

#define CHD_SIGNATURE(chd)			((chd).signature)
#define CHD_ATTRIBUTES(chd)			((chd).attributes)
#define CHD_NUMBASES(chd)			((chd).numBaseClasses)
#define CHD_PBCA(chd)				((chd).pBaseClassArray)
#define CHD_PBCD(bcd)				(bcd)
#if defined(_M_IA64)
#define CHD_PBCA_IB(chd,ib)			((_RTTIBaseClassArray*)((ib) + (chd).pBaseClassArray))
#define CHD_PBCD_IB(bcd,ib)			((_RTTIBaseClassDescriptor*)((ib) + bcd))
#endif

//
//	_RTTICompleteObjectLocator
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTICompleteObjectLocator	{
	DWORD							signature;
	DWORD							offset;
	DWORD							cdOffset;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32		    			    pTypeDescriptor;    // Image relative offset of TypeDescriptor
	__int32                         pClassDescriptor;   // Image relative offset of _RTTIClassHierarchyDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
	_RTTIClassHierarchyDescriptor	*pClassDescriptor;
#endif
	} _RTTICompleteObjectLocator;
#endif // WANT_NO_TYPES

#define COL_SIGNATURE(col)			((col).signature)
#define COL_OFFSET(col)				((col).offset)
#define COL_CDOFFSET(col)			((col).cdOffset)
#define COL_PTD(col)				((col).pTypeDescriptor)
#define COL_PCHD(col)				((col).pClassDescriptor)
#if defined(_M_IA64)
#define COL_PTD_IB(col,ib)			((TypeDescriptor*)((ib) + (col).pTypeDescriptor))
#define COL_PCHD_IB(col,ib)			((_RTTIClassHierarchyDescriptor*)((ib) + (col).pClassDescriptor))
#endif

#ifdef BUILDING_TYPESRC_C
//
// Type of the result of __RTtypeid and internal applications of typeid().
// This also introduces the tag "type_info" as an incomplete type.
//

typedef const class type_info &__RTtypeidReturnType;

//
// Declaration of CRT entrypoints, as seen by the compiler.  Types are 
// simplified so as to avoid type matching hassles.
//

#ifndef THROWSPEC
#if _MSC_VER >= 1300
#define THROWSPEC(_ex) throw _ex
#else
#define THROWSPEC(_ex)
#endif
#endif

// Perform a dynamic_cast on obj. of polymorphic type
extern "C" PVOID __cdecl __RTDynamicCast (
								PVOID,				// ptr to vfptr
								LONG,				// offset of vftable
								PVOID,				// src type
								PVOID,				// target type
								BOOL) THROWSPEC((...)); // isReference

// Perform 'typeid' on obj. of polymorphic type
extern "C" PVOID __cdecl __RTtypeid (PVOID)  THROWSPEC((...));	// ptr to vfptr

// Perform a dynamic_cast from obj. of polymorphic type to void*
extern "C" PVOID __cdecl __RTCastToVoid (PVOID)  THROWSPEC((...)); // ptr to vfptr
#endif

#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(pop, rttidata)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\undname\undname.h ===
#if !defined(_M_I86)
    //  The 32-bit compiler

    #define __far
    #define __near
    #define __pascal
    #define __loadds
#endif


typedef char *        pchar_t;
typedef const char *  pcchar_t;

typedef void * ( __cdecl * Alloc_t )( size_t );
typedef void   ( __cdecl * Free_t  )( void * );
typedef char * ( __cdecl * GetParameter_t  )( long );


#ifdef  __cplusplus
extern "C"
#endif


#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDName (
#else
pchar_t __cdecl unDName (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
                            unsigned short	// Feature disable flags
                        );

#ifdef  __cplusplus
extern "C"
#endif

#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDNameEx (
#else
pchar_t __cdecl unDNameEx (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
							GetParameter_t,	// Function to get any template parameters
                            unsigned long	// Feature disable flags
                        );
/*
 *  The user may provide a buffer into which the undecorated declaration
 *  is to be placed, in which case, the length field must be specified.
 *  The length is the maximum number of characters (including the terminating
 *  NULL character) which may be written into the user buffer.
 *
 *  If the output buffer is NULL, the length field is ignored, and the
 *  undecorator will allocate a buffer exactly large enough to hold the
 *  resulting declaration.  It is the users responsibility to deallocate
 *  this buffer.
 *
 *  The user may also supply the allocator and deallocator functions if
 *  they wish.  If they do, then all heap actions performed by the routine
 *  will use the provided heap functions.
 *
 *  If the allocator address is NULL, then the routine will default to using
 *  the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *  If an error occurs internally, then the routine will return NULL.  If
 *  it was successful, it will return the buffer address provided by the
 *  user, or the address of the buffer allocated on their behalf, if they
 *  specified a NULL buffer address.
 *
 *  If a given name does not have a valid undecoration, the original name
 *  is returned in the output buffer.
 *
 *  Fine selection of a number of undecorator attributes is possible, by
 *  specifying flags (bit-fields) to disable the production of parts of the
 *  complete declaration.  The flags may be OR'ed together to select multiple
 *  disabling of selected fields.  The fields and flags are as follows :-
 */

#define UNDNAME_COMPLETE                (0x0000)    // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)    // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS          (0x0002)    // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS     (0x0004)    // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL     (0x0008)    // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)    // Disable expansion of the declaration language specifier
  #define   UNDNAME_NO_MS_THISTYPE          (0x0020)    /* NYI */   // Disable expansion of MS keywords on the 'this' type for primary declaration
  #define   UNDNAME_NO_CV_THISTYPE          (0x0040)    /* NYI */   // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE             (0x0060)    // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)    // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES     (0x0100)    // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE          (0x0200)    // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL     (0x0400)    // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE           (0x0800)    // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY               (0x1000)    // Crack only the name for primary declaration;
                                                    //  return just [scope::]name.  Does expand template params
#define UNDNAME_TYPE_ONLY               (0x2000)    // Input is just a type encoding; compose an abstract declarator
#define UNDNAME_HAVE_PARAMETERS         (0x4000)    // The real templates parameters are available
#define UNDNAME_NO_ECSU                 (0x8000)    // Suppress enum/class/struct/union
#define UNDNAME_NO_IDENT_CHAR_CHECK     (0x10000)   // Suppress check for IsValidIdentChar
#define UNDNAME_NO_PTR64				(0x20000)	// disable just ptr64 in output
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\undname\undname.cxx ===
//	Make sure all dependent defines exist and have a valid value

#ifndef	NO_COMPILER_NAMES
#define	NO_COMPILER_NAMES		0
#endif

#ifndef VERS_32BIT
#define VERS_32BIT				1
#endif

#ifndef PACK_SIZE
#ifdef _CRTBLD
#define PACK_SIZE				8
#elif !VERS_32BIT
#define PACK_SIZE				2
#elif defined(_X86_)
#define PACK_SIZE				4
#else
#define PACK_SIZE				8
#endif
#endif

//	Check for version inconsistancies, and setup version flags

#ifdef	VERS_BSC
	#undef	NO_COMPILER_NAMES
	#define	NO_COMPILER_NAMES	1

	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#else
	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#endif


#define	PURE	=0

#ifndef CC_COR
#define CC_COR 1
#endif

#include	<stddef.h>
#include	<stdlib.h>
#include	"undname.hxx"

#if !defined(_CRTBLD) && (!VERSP_RELEASE || defined(_DEBUG))
#include	<assert.h>
#define DASSERT(x) assert(x)
#else
#define DASSERT(x)
#endif

#if (defined(_CRTBLD) && defined(_MT))
#include <mtdll.h>
#endif

#pragma warning(disable:4291)	// No matching operator delete

static	unsigned int	__near __pascal	und_strlen ( pcchar_t );
static	pchar_t			__near __pascal	und_strncpy ( pchar_t, pcchar_t, unsigned int );
static	unsigned int	__near __pascal	und_strncmp ( pcchar_t, pcchar_t, unsigned int );

class	DName;
class	DNameNode;
class	Replicator;
class	HeapManager;
class	UnDecorator;


// A '512' byte block including the header
const   unsigned int    memBlockSize = 512 - sizeof(void*);


class	HeapManager
{
private:
		Alloc_t			pOpNew;
		Free_t			pOpDelete;

		struct	Block
		{
			Block *		next;
			char		memBlock[ memBlockSize ];

				__near	Block ()	{	next	= 0;	}

		};

		Block *			head;
		Block *			tail;
		size_t			blockLeft;

public:
		void	__near	Constructor ( Alloc_t pAlloc, Free_t pFree )
						{	pOpNew		= pAlloc;
							pOpDelete	= pFree;
							blockLeft	= 0;
							head		= 0;
							tail		= 0;
						}

		void __far *	__near	getMemory ( size_t, int );

		void	__near	Destructor ( void )
						{	if	( pOpDelete != 0 )
								while	( tail = head )
								{
									head	= tail->next;

									( *pOpDelete )( tail );

								}
						}

		#define	gnew	new(heap,0)
		#define	rnew	new(heap,1)

};



void   *	__near __pascal	operator new ( size_t, HeapManager &, int = 0 );



static	HeapManager	heap;


//	The MS Token table

enum	Tokens
{
#if !VERS_32BIT
	TOK_near,
	TOK_nearSp,
	TOK_nearP,
	TOK_far,
	TOK_farSp,
	TOK_farP,
	TOK_huge,
	TOK_hugeSp,
	TOK_hugeP,
#endif
	TOK_basedLp,
	TOK_cdecl,
	TOK_pascal,
	TOK_stdcall,
	TOK_thiscall,
	TOK_fastcall,
	TOK_cocall,
	TOK_ptr64,
	TOK_restrict,
	TOK_unaligned,
#if !VERS_32BIT
	TOK_interrupt,
	TOK_saveregs,
	TOK_self,
	TOK_segment,
	TOK_segnameLpQ,
#endif
	TOK__last
};


static	const pcchar_t	__near	tokenTable[]	=
{
#if !VERS_32BIT
	"__near",		// TOK_near
	"__near ",		// TOK_nearSp
	"__near*",		// TOK_nearP
	"__far",		// TOK_far
	"__far ",		// TOK_farSp
	"__far*",		// TOK_farP
	"__huge",		// TOK_huge
	"__huge ",		// TOK_hugeSp
	"__huge*",		// TOK_hugeP
#endif
	"__based(",		// TOK_basedLp
	"__cdecl",		// TOK_cdecl
	"__pascal",		// TOK_pascal
	"__stdcall",	// TOK_stdcall
	"__thiscall",	// TOK_thiscall
	"__fastcall",	// TOK_fastcall
	"__clrcall",		// TOK_cocall
	"__ptr64",		// TOK_ptr64
	"__restrict",	// TOK_restrict
	"__unaligned",	// TOK_unaligned
#if !VERS_32BIT
	"__interrupt",	// TOK_interrupt
	"__saveregs",	// TOK_saveregs
	"__self",		// TOK_self
	"__segment",	// TOK_segment
	"__segname(\"",	// TOK_segnameLpQ
#endif
	""
};


//	The operator mapping table

static	const pcchar_t	__near	nameTable[]	=
{
	" new",
	" delete",
	"=",
	">>",
	"<<",
	"!",
	"==",
	"!=",
	"[]",
	"operator",
	"->",
	"*",
	"++",
	"--",
	"-",
	"+",
	"&",
	"->*",
	"/",
	"%",
	"<",
	"<=",
	">",
	">=",
	",",
	"()",
	"~",
	"^",
	"|",
	"&&",
	"||",
	"*=",
	"+=",
	"-=",
	"/=",
	"%=",
	">>=",
	"<<=",
	"&=",
	"|=",
	"^=",

#if	( !NO_COMPILER_NAMES )
	"`vftable'",
	"`vbtable'",
	"`vcall'",
	"`typeof'",
	"`local static guard'",
	"`string'",
	"`vbase destructor'",
	"`vector deleting destructor'",
	"`default constructor closure'",
	"`scalar deleting destructor'",
	"`vector constructor iterator'",
	"`vector destructor iterator'",
	"`vector vbase constructor iterator'",
	"`virtual displacement map'",
	"`eh vector constructor iterator'",
	"`eh vector destructor iterator'",
	"`eh vector vbase constructor iterator'",
	"`copy constructor closure'",
	"`udt returning'",
	"`EH", //eh initialized struct
	"`RTTI", //rtti initialized struct
	"`local vftable'",
	"`local vftable constructor closure'",
#endif	// !NO_COMPILER_NAMES

	" new[]",
	" delete[]",

#if ( !NO_COMPILER_NAMES )
	"`omni callsig'",
	"`placement delete closure'",
	"`placement delete[] closure'",
	"`managed vector constructor iterator'",
	"`managed vector destructor iterator'",
	"`eh vector copy constructor iterator'",
	"`eh vector vbase copy constructor iterator'",
#endif

	""
};

static const pcchar_t __near ehTable[] =
{
	" Ptr to Member Data'",
	" Catchable Type'",
	" Catchable Type Array'",
	" ThrowInfo'",
};

static const pcchar_t __near rttiTable[] =
{
	" Type Descriptor'",
	" Base Class Descriptor at (",
	" Base Class Array'",
	" Class Hierarchy Descriptor'",
	" Complete Object Locator'",
};


//	The following 'enum' should really be nested inside 'class DName', but to
//	make the code compile better with Glockenspiel, I have extracted it

enum	DNameStatus
{
	DN_valid,
	DN_invalid,
	DN_truncated,
	DN_error
};


class	DName
{
public:
					__near	DName ();
					__near	DName ( char );

#if	1
					__near	DName ( const DName & );		// Shallow copy
#endif

					__near	DName ( DNameNode * );
					__near	DName ( pcchar_t );
					__near	DName ( pcchar_t&, char );
					__near	DName ( DNameStatus );
					__near	DName ( DName * );
					__near	DName ( unsigned long );
					__near	DName ( int );

		int			__near	isValid () const;
		int			__near	isEmpty () const;
		DNameStatus	__near	status () const;
		void		__near	clearStatus ();

		DName &		__near	setPtrRef ();
		int			__near	isPtrRef () const;
		int			__near	isUDC () const;
		void		__near	setIsUDC ();
		int			__near	isUDTThunk () const;
		void		__near	setIsUDTThunk ();
		int			__near	isArray() const;
		void		__near	setIsArray();
		int					isNoTE () const;
		void				setIsNoTE ();

		int			__near	length () const;
		char		__near	getLastChar () const;
		pchar_t		__near	getString ( pchar_t, int ) const;

		DName		__near	operator + ( pcchar_t ) const;
		DName		__near	operator + ( const DName & ) const;
		DName		__near	operator + ( char ) const;
		DName		__near	operator + ( DName * ) const;
		DName		__near	operator + ( DNameStatus ) const;

		DName &		__near	operator += ( char );
		DName &		__near	operator += ( pcchar_t );
		DName &		__near	operator += ( DName * );
		DName &		__near	operator += ( DNameStatus );
		DName &		__near	operator += ( const DName & );

		DName &		__near	operator |= ( const DName & );

		DName &		__near	operator = ( pcchar_t );
		DName &		__near	operator = ( const DName & );
		DName &		__near	operator = ( char );
		DName &		__near	operator = ( DName * );
		DName &		__near	operator = ( DNameStatus );

//	Friends :

friend	DName		__near __pascal	operator + ( char, const DName & );
friend	DName		__near __pascal	operator + ( pcchar_t, const DName & );
friend	DName		__near __pascal	operator + ( DNameStatus, const DName & );

private:
		DNameNode *		node;

		DNameStatus		stat	: 4;
		unsigned int	isIndir	: 1;
		unsigned int	isAUDC	: 1;
		unsigned int	isAUDTThunk	: 1;
		unsigned int	isArrayType	: 1;
		unsigned int	NoTE	: 1;

		void		__near	doPchar ( pcchar_t, int );

};



class	Replicator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const Replicator& );

		int				index;
		DName *			dNameBuffer[ 10 ];
		const DName		ErrorDName;
		const DName		InvalidDName;

public:
						__near	Replicator ();

		int				__near	isFull () const;

		Replicator &	__near	operator += ( const DName & );
		const DName &	__near	operator [] ( int ) const;

};



class	UnDecorator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const UnDecorator& );

		Replicator		ArgList;
static	Replicator *	pArgList;

		Replicator		ZNameList;
static	Replicator *	pZNameList;

static	Replicator *	pTemplateArgList;

static	pcchar_t		gName;
static	pcchar_t		name;
static	pchar_t			outputString;
static	int				maxStringLength;
static	unsigned long	disableFlags;
static	bool			fExplicitTemplateParams;
static	bool			fGetTemplateArgumentList;

static	DName	__near	getDecoratedName ( void );
static	DName	__near	getSymbolName ( void );
static	DName	__near	getZName ( bool fUpdateCachedNames );
static	DName	__near	getOperatorName ( void );
static	DName	__near	getScope ( void );
static	DName			getScopedName ( void );
static	DName	__near	getSignedDimension ( void );
static	DName	__near	getDimension ( bool fSigned = false );
static	int		__near	getNumberOfDimensions ( void );
static	DName	__near	getTemplateName ( void );
static	DName	__near	getTemplateArgumentList( void );
static	DName	__near	getTemplateConstant( void );
static	DName	__near	composeDeclaration ( const DName & );
static	int		__near	getTypeEncoding ( void );
static	DName	__near	getBasedType ( void );
static	DName	__near	getECSUName ( void );
static	DName	__near	getEnumType ( void );
static	DName	__near	getCallingConvention ( void );
static	DName	__near	getReturnType ( DName * = 0 );
static	DName	__near	getDataType ( DName * );
static	DName	__near	getPrimaryDataType ( const DName & );
static	DName	__near	getDataIndirectType ( const DName &, char, const DName &, int = FALSE );
static	DName	__near	getDataIndirectType ();
static	DName	__near	getBasicDataType ( const DName & );
static	DName	__near	getECSUDataType ( void );
static	DName	__near	getPtrRefType ( const DName &, const DName &, char );
static	DName	__near	getPtrRefDataType ( const DName &, int );
static	DName	__near	getArrayType ( const DName& );
static	DName			getFunctionIndirectType( const DName & superType );
static	DName	__near	getArgumentTypes ( void );
static	DName	__near	getArgumentList ( void );
static	DName	__near	getThrowTypes ( void );
static	DName	__near	getLexicalFrame ( void );
static	DName	__near	getStorageConvention ( void );
static	DName	__near	getThisType ( void );
static	DName	__near	getPointerType ( const DName &, const DName & );
static	DName	__near	getPointerTypeArray ( const DName &, const DName & );
static	DName	__near	getReferenceType ( const DName &, const DName & );
static	DName	__near	getExternalDataType ( const DName & );
static	DName	__near	getSegmentName ( void );

#if	( !NO_COMPILER_NAMES )
static	DName	__near	getDisplacement ( void );
static	DName	__near	getCallIndex ( void );
static	DName	__near	getGuardNumber ( void );
static	DName	__near	getVfTableType ( const DName & );
static	DName	__near	getVbTableType ( const DName & );
static	DName	__near	getVdispMapType	( const DName & );
static	DName	__near	getVCallThunkType ( void );
#endif	// !NO_COMPILER_NAMES

static	DName			getStringEncoding ( char *prefix, int wantBody );

static GetParameter_t m_pGetParameter;

public:
				__near	UnDecorator ( pchar_t, pcchar_t, int, GetParameter_t, unsigned long );

static	int		__near	doUnderScore ();
static	int		__near	doMSKeywords ();
static	int		__near	doPtr64 ();
static	int		__near	doFunctionReturns ();
static	int		__near	doAllocationModel ();
static	int		__near	doAllocationLanguage ();

#if	0
static	int		__near	doMSThisType ();
static	int		__near	doCVThisType ();
#endif

static	int		__near	doThisTypes ();
static	int		__near	doAccessSpecifiers ();
static	int		__near	doThrowTypes ();
static	int		__near	doMemberTypes ();
static	int		__near	doReturnUDTModel ();

static	int		__near	do32BitNear ();

static	int		__near	doNameOnly ();
static	int		__near	doTypeOnly ();
static	int		__near	haveTemplateParameters ();
static	int		__near	doEcsu ();
static	int		__near	doNoIdentCharCheck ();

static	pcchar_t	__near	UScore ( Tokens );

				__near	operator pchar_t ();

};



Replicator *	UnDecorator::pArgList;
Replicator *	UnDecorator::pZNameList			= 0;
Replicator *	UnDecorator::pTemplateArgList	= 0;
pcchar_t		UnDecorator::gName				= 0;
pcchar_t		UnDecorator::name				= 0;
pchar_t			UnDecorator::outputString		= 0;
int				UnDecorator::maxStringLength	= 0;
unsigned long	UnDecorator::disableFlags		= 0;
GetParameter_t	UnDecorator::m_pGetParameter	= 0;
bool			UnDecorator::fExplicitTemplateParams = false;
bool			UnDecorator::fGetTemplateArgumentList = false;


#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDName (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDName (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											unsigned short disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)
	if	( !( pAlloc ))
		return	0;
	
	pchar_t		unDecoratedName;

#if (defined(_CRTBLD) && defined(_MT))
	if (!_mtinitlocknum(_UNDNAME_LOCK))
		return	0;
	_mlock(_UNDNAME_LOCK);
	__try {
#endif

	heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								0,
								disableFlags
							);
	unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

#if (defined(_CRTBLD) && defined(_MT))
	} __finally {
		_munlock(_UNDNAME_LOCK);
	}
#endif

	//	And return the composed name

	return unDecoratedName;

}	// End of FUNCTION "unDName"




#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDNameEx (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDNameEx (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											GetParameter_t pGetParameter,
											unsigned long disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)

	if	( !( pAlloc ))
		return	0;

	pchar_t		unDecoratedName;

#if (defined(_CRTBLD) && defined(_MT))
	if (!_mtinitlocknum(_UNDNAME_LOCK))
		return	0;
	_mlock(_UNDNAME_LOCK);
	__try {
#endif

	heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								pGetParameter,
								disableFlags
							);
	unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

#if (defined(_CRTBLD) && defined(_MT))
	} __finally {
		_munlock(_UNDNAME_LOCK);
	}
#endif

	//	And return the composed name

	return	unDecoratedName;

}	// End of FUNCTION "unDName"

//	The 'UnDecorator' member functions

inline	__near	UnDecorator::UnDecorator	(	pchar_t output,
												pcchar_t dName,
												int maxLen,
												GetParameter_t pGetParameter,
												unsigned long disable
									)
{
	name			= dName;
	gName			= name;

	if	( output ) {
		maxStringLength	= maxLen - 1;	// The algorithm in getString doesn't leave room
										// for terminating NULL; be paranoid and leave one
										// extra char.
										// It's a lot easier to fix this here....
		outputString	= output;	
	}
	else {
		outputString	= 0;
		maxStringLength	= 0;
	}

	pZNameList		= &ZNameList;
	pArgList		= &ArgList;
	disableFlags	= disable;
	m_pGetParameter	= pGetParameter;
	fExplicitTemplateParams = false;

}	// End of "UnDecorator" CONSTRUCTOR '()'


inline	__near	UnDecorator::operator pchar_t ()
{
	DName		result;
	DName		unDName;


	//	Find out if the name is a decorated name or not.  Could be a reserved
	//	CodeView variant of a decorated name

	if	( name )
	{
		if	(( *name == '?' ) && ( name[ 1 ] == '@' ))
		{
#if	( !NO_COMPILER_NAMES )
			gName	+= 2;
			result	= "CV: " + getDecoratedName ();
#else	// } elif NO_COMPILER_NAMES
			result	= DN_invalid;
#endif	// NO_COMPILER_NAMES

		}	// End of IF then
		else if	(( *name == '?' ) && ( name[1] == '$' )) {
			result	= getTemplateName ();
			if ( result.status () == DN_invalid ) {
				// 
				// What harm could there be to try again ?
				//	Repro:
				//		?$S1@?1??VTFromRegType@CRegParser@ATL@@KAHPBGAAG@Z@4IA
				//	---> unsigned int `protected: static int __cdecl ATL::CRegParser::VTFromRegType(unsigned short const *,unsigned short &)'::`2'::$S1
				//
				//	This is a compiler generated symbol for a local static array init.
				//
				gName = name;
				result.clearStatus();
				result	= getDecoratedName ();
			}
		} else {
			result	= getDecoratedName ();
		}

	}	// End of IF then

	//	If the name was not a valid name, then make the name the same as the original
	//	It is also invalid if there are any remaining characters in the name (except when
	//	we're giving the name only)

	if		( result.status () == DN_error )
		return	0;
	elif	( (*gName && !doNameOnly ()) || ( result.status () == DN_invalid ))
		unDName	= name;	// Return the original name
	else
		unDName	= result;

	//	Construct the return string

	if	( !outputString )
	{
		maxStringLength	= unDName.length () + 1;
		outputString 	= rnew char[ maxStringLength ];

	}	// End of IF

	if	( outputString ) {
		unDName.getString ( outputString, maxStringLength );

		// strip extra whitespace out of name
		pchar_t pRead = outputString;
		pchar_t pWrite = pRead;
		while (*pRead) {
			if (*pRead == ' ') {
				pRead++;
				*pWrite++ = ' ';
				while ( *pRead == ' ' ) {
					pRead++;
				}
			}
			else
				*pWrite++ = *pRead++;
		}
		*pWrite = *pRead;
	}

	//	Return the result

	return	outputString;

}	// End of "UnDecorator" OPERATOR 'pchar_t'



DName	__near	UnDecorator::getDecoratedName ( void )
{
	//	Ensure that it is intended to be a decorated name

	if		( doTypeOnly() )
	{
		// Disable the type-only flag, so that if we get here recursively, eg.
		// in a template tag, we do full name undecoration.
		disableFlags &= ~UNDNAME_TYPE_ONLY;

		// If we're decoding just a type, process it as the type for an abstract
		// declarator, by giving an empty symbol name.

		DName	result = getDataType ( NULL );
		disableFlags |= UNDNAME_TYPE_ONLY;

		return result;
	}
	elif	( *gName == '?' )
	{
		//	Extract the basic symbol name

		gName++;	// Advance the original name pointer


		DName	symbolName	= getSymbolName ();																						
		int		udcSeen		= symbolName.isUDC ();

		//	Abort if the symbol name is invalid

		if	( !symbolName.isValid ())
			return	symbolName;

		//	Extract, and prefix the scope qualifiers

		if	( *gName && ( *gName != '@' )) {
			DName	scope = getScope ();
			
			if	( !scope.isEmpty() )
				if (fExplicitTemplateParams) {
					fExplicitTemplateParams = false;
					symbolName	= symbolName + scope;
					if (*gName != '@') {
						scope = getScope();					
						symbolName	= scope + "::" + symbolName;
					}
				} else {
					symbolName	= scope + "::" + symbolName;
				}
			}

		if	( udcSeen )
			symbolName.setIsUDC ();

		//	Now compose declaration

		if	( symbolName.isEmpty () || symbolName.isNoTE() )
		{
			return	symbolName;
		}
		elif	( !*gName || ( *gName == '@' ) )
		{
			if	( *gName )
				gName++;

			if	(doNameOnly () && !udcSeen) {
				// Eat the rest of the dname, in case this is a recursive invocation,
				// such as for a template argument.
				(void)composeDeclaration( DName() );
				return symbolName;
			}
			else {
				return	composeDeclaration ( symbolName );
			}

		}	// End of ELIF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( *gName )
		return	DN_invalid;
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDecoratedName"



inline	DName	__near	UnDecorator::getSymbolName ( void )
{
	if	( *gName == '?' )
	{
		gName++;

		return	getOperatorName ();

	}	// End of IF then
	else
		return	getZName ( true );

}	// End of "UnDecorator" FUNCTION "getSymbolName"



DName	__near	UnDecorator::getZName ( bool fUpdateCachedNames )
{
	int		zNameIndex	= *gName - '0';


	//	Handle 'zname-replicators', otherwise an actual name

	if	(( zNameIndex >= 0 ) && ( zNameIndex <= 9 ))
	{
		gName++;	// Skip past the replicator

		//	And return the indexed name

		return	( *pZNameList )[ zNameIndex ];

	}	// End of IF then
	else
	{
		DName	zName;

		if	( *gName == '?' )
		{
			zName	= getTemplateName ();

			if	( *gName++ != '@' )
				zName	= *--gName ? DN_invalid : DN_truncated;
		}
		else {
			#define TEMPLATE_PARAMETER "template-parameter-"
			#define TEMPLATE_PARAMETER_LEN 19
			#define GENERIC_TYPE "generic-type-"
			#define GENERIC_TYPE_LEN 13

			pchar_t genericType;
			if (und_strncmp(gName, TEMPLATE_PARAMETER, TEMPLATE_PARAMETER_LEN) == 0) {
				genericType = TEMPLATE_PARAMETER;
				gName += TEMPLATE_PARAMETER_LEN;
			} else if (und_strncmp(gName, GENERIC_TYPE, GENERIC_TYPE_LEN) == 0) {
				genericType = GENERIC_TYPE;
				gName += GENERIC_TYPE_LEN;
			} else {
				genericType = NULL;
			}

			if (genericType) {
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						zName = str;
					}
					else {
						zName = "`";
						zName += genericType + dimension + "'";
					}
				}
				else {
					zName = "`";
					zName += genericType + dimension + "'";
				}
			}
			else {
				//	Extract the 'zname' to the terminator

				zName	= DName( gName, '@' );	// This constructor updates 'name'
			}
		}


		//	Add it to the current list of 'zname's

		if	( fUpdateCachedNames && !pZNameList->isFull ())
			*pZNameList	+= zName;

		//	And return the symbol name
		return	zName;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getZName"



inline	DName	__near	UnDecorator::getOperatorName ( void )
{
	DName	operatorName;
	DName	tmpName;
	int		udcSeen	= FALSE;


	//	So what type of operator is it ?

	switch	( *gName++ )
	{
	case 0:
		gName--;		// End of string, better back-track

		return	DN_truncated;

	case OC_ctor:
	case OC_dtor:
		//
		// The constructor and destructor are special:
		// Their operator name is the name of their first enclosing scope, which
		// will always be a tag, which may be a template specialization!
		//
		{
			//	Use a temporary.  Don't want to advance the name pointer

			pcchar_t	pName	= gName;


			operatorName		= getZName ( false );


			gName = pName;		// Undo our lookahead

			if	( !operatorName.isEmpty () && ( gName[ -1 ] == OC_dtor ))
				operatorName	= '~' + operatorName;

			return	operatorName;

		}	// End of CASE 'OC_ctor,OC_dtor'
		break;

	case OC_new:
	case OC_delete:
	case OC_assign:
	case OC_rshift:
	case OC_lshift:
	case OC_not:
	case OC_equal:
	case OC_unequal:
			operatorName	= nameTable[ gName[ -1 ] - OC_new ];
		break;

	case OC_udc:
			udcSeen	= TRUE;

		//	No break

	case OC_index:
	case OC_pointer:
	case OC_star:
	case OC_incr:
	case OC_decr:
	case OC_minus:
	case OC_plus:
	case OC_amper:
	case OC_ptrmem:
	case OC_divide:
	case OC_modulo:
	case OC_less:
	case OC_leq:
	case OC_greater:
	case OC_geq:
	case OC_comma:
	case OC_call:
	case OC_compl:
	case OC_xor:
	case OC_or:
	case OC_land:
	case OC_lor:
	case OC_asmul:
	case OC_asadd:
	case OC_assub:			// Regular operators from the first group
			operatorName	= nameTable[ gName[ -1 ] - OC_index + ( OC_unequal - OC_new + 1 )];
		break;

	case '_':
			switch	( *gName++ )
			{
			case 0:
				gName--;		// End of string, better back-track

				return	DN_truncated;

			case OC_asdiv:
			case OC_asmod:
			case OC_asrshift:
			case OC_aslshift:
			case OC_asand:
			case OC_asor:
			case OC_asxor:	// Regular operators from the extended group
					operatorName	= nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				break;

#if	( !NO_COMPILER_NAMES )
			case OC_vftable:
			case OC_vbtable:
			case OC_vcall:
				return	nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];


			case OC_string:
				{
				DName result = getStringEncoding( "`string'", TRUE );
				result.setIsNoTE();
				return result;
				}

			case OC_metatype:
			case OC_guard:
			case OC_vbdtor:
			case OC_vdeldtor:
			case OC_defctor:
			case OC_sdeldtor:
			case OC_vctor:
			case OC_vdtor:
			case OC_vallctor:
			case OC_vdispmap:
			case OC_ehvctor:
			case OC_ehvdtor:
			case OC_ehvctorvb:
			case OC_copyctorclosure:
			case OC_locvfctorclosure:
			case OC_locvftable:	// Special purpose names
			case OC_placementDeleteClosure:
			case OC_placementArrayDeleteClosure:
				return	nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

			case OC_udtthunk:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName 		= getOperatorName();
				if ( !tmpName.isEmpty() && tmpName.isUDTThunk() )
					return	DN_invalid;
				return operatorName + tmpName;
				break;
			case OC_eh_init:
				break;
			case OC_rtti_init:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName = rttiTable[ gName[0] - OC_rtti_TD ];
				switch	( *gName++ )
				{
				case OC_rtti_TD:
					{
					DName	result = getDataType ( NULL );
					return result + ' ' + operatorName + tmpName;
					}
					break;
				case OC_rtti_BCD:
					{
					DName	result = operatorName + tmpName;
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getDimension() + ')';
					return result + '\'';
					}
					break;
				case OC_rtti_BCA:
				case OC_rtti_CHD:
				case OC_rtti_COL:
					return operatorName + tmpName;
					break;
				default:
					gName--;
					return DN_truncated;
					break;
				}
				break;

#endif	// !NO_COMPILER_NAMES

			case OC_arrayNew:
			case OC_arrayDelete:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )
#if NO_COMPILER_NAMES
											- ( OC_locvfctorclosure - OC_vftable + 1 )	// discount names not in table
#endif
									];
				break;

			// Yet another level of nested encodings....
			case '?':
				switch( *gName++ ) {

					case 0:
						gName--;		// End of string, better back-track

						return	DN_truncated;

					case OC_anonymousNamespace:
						//
						// Anonymous namespace (new-style) is a string encoding of the
						// machine name and the translation unit name.  Since the remainder
						// of the name doesn't really fit the dname grammar, skip it.
						// There are two '@' markers in the name....
						//
						{
						DName result = getStringEncoding( "`anonymous namespace'", FALSE );
						result.setIsNoTE();
						return result;
						}

					default:
						return	DN_invalid;
				}
				break;

			//
			// A double extended operator
			//
			case '_':
				switch (*gName++) {
					case OC_man_vec_ctor:
					case OC_man_vec_dtor:
					case OC_ehvcctor:
					case OC_ehvcctorvb:
						return nameTable[ gName[ -1 ] - OC_man_vec_ctor + ( OC_placementArrayDeleteClosure - OC_metatype + 1) + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

					default:
						return DN_invalid;
				}
				break;

			default:
				return	DN_invalid;

			}	// End of SWITCH
		break;

	default:
		return	DN_invalid;

	}	// End of SWITCH

	//	This really is an operator name, so prefix it with 'operator'

	if	( udcSeen )
		operatorName.setIsUDC ();
	elif	( !operatorName.isEmpty ())
		operatorName	= "operator" + operatorName;

	return	operatorName;

}	// End of "UnDecorator" FUNCTION "getOperatorName"

DName	UnDecorator::getStringEncoding ( char *prefix, int wantBody )
{
	DName result = prefix;

	// First @ comes right after operator code
	if	( *gName++ != '@' || *gName++ != '_' ) {
		return DN_invalid;
	}

	// Skip the string kind
	*gName++;

	// Get (& discard) the length
	getDimension();

	// Get (& discart) the checksum
	getDimension();

	while ( *gName && *gName != '@' ) {
		// For now, we'll just skip it
		gName++;
	}

	if	( !*gName ) {
		gName--;
		return DN_truncated;
	}

	// Eat the terminating '@'
	gName++;

	return result;
}


DName	__near	UnDecorator::getScope ( void )
{
	DName	scope;
	bool	fNeedBracket = false;


	//	Get the list of scopes

	while	(( scope.status () == DN_valid ) && *gName && ( *gName != '@' ))
	{	//	Insert the scope operator if not the first scope

		if (fExplicitTemplateParams && !fGetTemplateArgumentList) {
			return scope;
		}
		if	( !scope.isEmpty() ) {
			scope	= "::" + scope;

			if (fNeedBracket) {
				scope = '[' + scope;
				fNeedBracket = false;
			}
		}

		//	Determine what kind of scope it is

		if	( *gName == '?' )
			switch	( *++gName )
			{
			case '?':
					if	( gName[1] == '_' && gName[2] == '?' ) {
						//
						// Anonymous namespace name (new style)
						//
						gName++;
						scope = getOperatorName () + scope;

						// There should be a zname termination @...
						if	( *gName == '@' ) {
							gName++;
						}
					}
					else
						scope	= '`' + getDecoratedName () + '\'' + scope;
				break;

			case '$':
					// It's a template name, which is a kind of zname; back up
					// and handle like a zname.
					gName--;
					scope	= getZName ( true ) + scope;
				break;

			case 'A':
					//
					// This is a new-new encoding for anonymous namespaces
					//
					// fall-through

			case '%':
					//
					// It an anonymous namespace (old-style);
					// skip the (unreadable) name and instead insert
					// an appropriate string
					//
					while ( *gName != '@' ) {
						gName++;
					}

					gName++;

					scope = "`anonymous namespace'" + scope;
				break;
			case 'I':
				//
				// This is the interface whose method the class is
				// implementing
				//
				gName++;
				scope = getZName ( true ) + ']' + scope;
				fNeedBracket = true;
				break;

			default:
				scope	= getLexicalFrame () + scope;
				break;

			}	// End of SWITCH
		else
			scope	= getZName ( true ) + scope;

	}	// End of WHILE

	//	Catch error conditions

	switch	( *gName )
	{
	case 0:
			if	( scope.isEmpty() )
				scope	= DN_truncated;
			else
				scope	= DName ( DN_truncated ) + "::" + scope;
		break;

	case '@':		// '@' expected to end the scope list
		break;

	default:
			scope	= DN_invalid;
		break;

	}	// End of SWITCH

	//	Return the composed scope

	return	scope;

}	// End of "UnDecorator" FUNCTION "getScope"


DName	__near	UnDecorator::getSignedDimension ( void )
{
	if		( !*gName )
		return	DN_truncated;
	elif	( *gName == '?' ) {
		gName++;	// skip the '?'
		return	'-' + getDimension();
	}
	else
		return	getDimension();
}	// End of "Undecorator" FUNCTION "getSignedDimension"


DName	__near	UnDecorator::getDimension ( bool fSigned )
{
	char* prefix = 0;
	if (*gName == TC_nontype_dummy) {
		prefix = "`non-type-template-parameter";
		++gName;
	}

	if		( !*gName )
		return	DN_truncated;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	prefix ? (prefix + DName ((unsigned long)( *gName++ - '0' + 1 ))) : DName ((unsigned long)( *gName++ - '0' + 1 ));
	else
	{
		unsigned long dim = 0L;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	DN_truncated;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	DN_invalid;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	DN_invalid;		// Should never get here

		if (fSigned) {
			return prefix ? (prefix + DName((int)dim)) : DName((int)dim);
		} else {
			return prefix ? (prefix + DName(dim)) : dim;
		}

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getDimension"


int	__near	UnDecorator::getNumberOfDimensions ( void )
{
	if		( !*gName )
		return	0;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	(( *gName++ - '0' ) + 1 );
	else
	{
		int	dim	= 0;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	0;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	-1;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	-1;		// Should never get here

		return	dim;

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getNumberOfDimensions"


DName	__near	UnDecorator::getTemplateName ( void )
{
	//
	// First make sure we're really looking at a template name
	//
	if	( gName[0] != '?' || gName[1] != '$' )
		return DN_invalid;

	gName += 2;			// Skip the marker characters

	//
	// Stack the replicators, since template names are their own replicator scope:
	//
	Replicator * pSaveArgList 			= pArgList;
	Replicator * pSaveZNameList 		= pZNameList;
	Replicator * pSaveTemplateArgList 	= pTemplateArgList;

	Replicator localArgList, localZNameList, localTemplateArgList;

	pArgList 			= &localArgList;
	pZNameList 			= &localZNameList;
	pTemplateArgList 	= &localTemplateArgList;

	//
	// Crack the template name:
	//
	DName	templateName	= getZName ( true );

	if	(templateName.isEmpty ()) {
		fExplicitTemplateParams = true;
	}

	templateName	+= '<' + getTemplateArgumentList ();
	if	( templateName.getLastChar () == '>' )
		templateName += ' ';
	templateName	+= '>';

	//
	// Restore the previous replicators:
	//
	pArgList			= pSaveArgList;
	pZNameList			= pSaveZNameList;
	pTemplateArgList	= pSaveTemplateArgList;

	//	Return the completed 'template-name'

	return	templateName;

}	// End of "UnDecorator" FUNCTION "getTemplateName"


DName	__near	UnDecorator::getTemplateArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;
	fGetTemplateArgumentList = true;


	while	(( aList.status () == DN_valid ) && *gName && ( *gName != AT_endoflist ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		int		argIndex	= *gName - '0';


		//	Handle 'template-argument-replicators', otherwise a new argument type

		if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
		{
			gName++;	// Skip past the replicator

			//	Append to the argument list

			aList	+= ( *pTemplateArgList )[ argIndex ];

		}	// End of IF then
		else
		{
			pcchar_t	oldGName	= gName;
			DName		arg;

			//
			//	Extract the 'argument' type
			//

			if	( *gName == DT_void ) {
				gName++;
				arg = "void";
			} 
			elif ( (*gName == '$') && (gName[1] != '$')) {
				gName++;
				arg = getTemplateConstant();
			}
			elif ( *gName == '?' ) {
				//
				// This is a template-parameter, i.e. we have a "specialization" of
				// X<T>. so get the template-parameter-index and use a "generic" name
				// for this parameter
				//
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						arg = str;
					}
					else {
						arg = "`template-parameter" + dimension + "'";
					}
				}
				else {
					arg = "`template-parameter" + dimension + "'";
				}
			}
			else {
				arg = getPrimaryDataType ( DName() );
			}


			//	Add it to the current list of 'template-argument's, if it is bigger than a one byte encoding

			if	((( gName - oldGName ) > 1 ) && !pTemplateArgList->isFull ())
				*pTemplateArgList	+= arg;

			//	Append to the argument list

			aList	+= arg;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed template argument list

	fGetTemplateArgumentList = false;

	return	aList;

}	// End of "UnDecorator" FUNCTION "getTemplateArgumentList"


DName	__near	UnDecorator::getTemplateConstant(void)
{
	//
	// template-constant ::=
	//		'0'	<template-integral-constant>
	//		'1' <template-address-constant>
	//		'2' <template-floating-point-constant>
	//
	char type_category = *gName++;
	switch ( type_category )
	{
		//
		// template-integral-constant ::=
		//		<signed-dimension>
		//
	case TC_integral:
		return 	getSignedDimension ();

		//
		// template-address-constant ::=
		//		'@'			// Null pointer
		//		<decorated-name>
		//
	case TC_address:
		if 	( *gName == TC_nullptr )
		{
			gName++;
			return	"NULL";
		}
		else
			return	DName("&") + getDecoratedName ();

		//
		// template-name ::=
		//		<docorated-name>
		//
	case TC_name:
		return getDecoratedName ();

		//
		// template-floating-point-constant ::=
		//		<normalized-mantissa><exponent>
		//
	case TC_fp:
		{
			DName	mantissa ( getSignedDimension () );
			DName	exponent ( getSignedDimension () );

			if	( mantissa.isValid() && exponent.isValid() )
			{
				//
				// Get string representation of mantissa
				//
				char	buf[100];		// Way overkill for a compiler generated fp constant

				if	( !mantissa.getString( &(buf[1]), 100 ) )	
					return	DN_invalid;

				//
				// Insert decimal point
				//
				buf[0] = buf[1];

				if	( buf[0] == '-' )
				{
					buf[1] = buf[2];
					buf[2] = '.';
				}
				else
					buf[1] = '.';

				//
				// String it all together
				//
				return DName( buf ) + 'e' + exponent;

			} // End of IF then
			else
				return DN_truncated;

		}	// End of BLOCK case TC_fp

	case TC_dummy:
	case TC_nontype_dummy:
		{
			//
			// This is a template-parameter, i.e. we have a "specialization" of
			// X<n>. so get the template-parameter-index and use a "generic" name
			// for this parameter
			//
			DName dimension = getSignedDimension();

			if ( haveTemplateParameters()) {
				char buffer[16];

				dimension.getString( buffer, 16 );

				char *str = (*m_pGetParameter)(atol(buffer));

				if ( str != NULL ) {
					return str;
				}
			}

			if (type_category == TC_dummy) {
				return "`template-parameter" + dimension + "'";
			} else {
				return "`non-type-template-parameter" + dimension + "'";
			}
		}
		break;

	case TC_vptmd:
	case TC_gptmd:
	case TC_mptmf:
	case TC_vptmf:
	case TC_gptmf:
		{
			DName ptm = '{';
		
			switch (type_category) {
			case TC_mptmf:
			case TC_vptmf:
			case TC_gptmf:
				ptm += getDecoratedName();
				ptm += ',';
				break;
			}

			switch (type_category) {
			case TC_gptmf:
			case TC_gptmd:
				ptm += getSignedDimension();
				ptm += ',';
				// fallthrough

			case TC_vptmd:
			case TC_vptmf:
				ptm += getSignedDimension();
				ptm += ',';
				// fallthrough

			case TC_mptmf:
				ptm += getSignedDimension();
			}

			return ptm + '}';
		}
		break;

	case '\0':
		--gName;
		return	DN_truncated;

	default:
		return	DN_invalid;

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getTemplateConstant"

	
inline	DName	__near	UnDecorator::composeDeclaration ( const DName & symbol )
{
	DName			declaration;
	unsigned int	typeCode	= getTypeEncoding ();
	int				symIsUDC	= symbol.isUDC ();


	//	Handle bad typeCode's, or truncation

	if		( TE_isbadtype ( typeCode ))
		return	DN_invalid;
	elif	( TE_istruncated ( typeCode ))
		return	( DN_truncated + symbol );
	elif	( TE_isCident ( typeCode ))
		return	symbol;

	//	This is a very complex part.  The type of the declaration must be
	//	determined, and the exact composition must be dictated by this type.

	//	Is it any type of a function ?
	//	However, for ease of decoding, treat the 'localdtor' thunk as data, since
	//	its decoration is a function of the variable to which it belongs and not
	//	a usual function type of decoration.

#if	( NO_COMPILER_NAMES )
	if	( TE_isthunk ( typeCode ))
		return	DN_invalid;

	if	( TE_isfunction ( typeCode ))
#else	// } elif !NO_COMPILER_NAMES {
	if	( TE_isfunction ( typeCode ) && !(( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode )) ||
			( TE_isthunk ( typeCode ) && ( TE_istemplatector ( typeCode ) || TE_istemplatedtor ( typeCode )))))
#endif	// !NO_COMPILER_NAMES

	{
		//	If it is based, then compose the 'based' prefix for the name

		if	( TE_isbased ( typeCode ))
			if	( doMSKeywords () && doAllocationModel ())
				declaration	= ' ' + getBasedType ();
			else
				declaration	|= getBasedType ();	// Just lose the 'based-type'

#if	( !NO_COMPILER_NAMES )
		//	Check for some of the specially composed 'thunk's

		if	( TE_isthunk ( typeCode ) && TE_isvcall ( typeCode ))
		{
			declaration	+= symbol + '{' + getCallIndex () + ',';
			declaration	+= getVCallThunkType () + "}' ";
			if ( doMSKeywords () && doAllocationLanguage ())
				declaration	= ' ' + getCallingConvention () + ' ' + declaration;	// What calling convention ?
			else
				declaration |= getCallingConvention ();	// Just lose the 'calling-convention'

		}	// End of IF then
		else
#endif	// !NO_COMPILER_NAMES
		{
			DName	vtorDisp;
			DName	adjustment;
			DName	thisType;

#if	( !NO_COMPILER_NAMES )
			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					vtorDisp	= getDisplacement ();

				adjustment	= getDisplacement ();

			}	// End of IF else
#endif	// !NO_COMPILER_NAMES

			//	Get the 'this-type' for non-static function members

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				if	( doThisTypes ())
					thisType	= getThisType ();
				else
					thisType	|= getThisType ();

			if	( doMSKeywords ())
			{
				//	Attach the calling convention

				if	( doAllocationLanguage ())
					declaration	= getCallingConvention () + declaration;	// What calling convention ?
				else
					declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

				//	Any model specifiers ?

#if !VERS_32BIT
				if	( doAllocationModel ())
					if		( TE_isnear ( typeCode ))
						declaration	= UScore ( TOK_nearSp ) + declaration;
					elif	( TE_isfar ( typeCode ))
						declaration	= UScore ( TOK_farSp ) + declaration;
#endif

			}	// End of IF
			else
				declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

			//	Now put them all together

			if	( !symbol.isEmpty ())
				if	( !declaration.isEmpty () && !doNameOnly() )			// And the symbol name
					declaration	+= ' ' + symbol;
				else
					declaration	= symbol;


			//	Compose the return type, catching the UDC case

			DName *	pDeclarator	= 0;
			DName	returnType;


			if	( symIsUDC )		// Is the symbol a UDC operator ?
			{
				declaration	+= " " + getReturnType ();

				if	( doNameOnly() )
					return	declaration;
			}
			else
			{
				pDeclarator	= gnew DName;
				returnType	= getReturnType ( pDeclarator );

			}	// End of IF else

#if	( !NO_COMPILER_NAMES )
			//	Add the displacements for virtual function thunks

			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					declaration	+= "`vtordisp{" + vtorDisp + ',';
				else
					declaration	+= "`adjustor{";

				declaration	+= adjustment + "}' ";

			}	// End of IF
#endif	// !NO_COMPILER_NAMES

			//	Add the function argument prototype

			declaration	+= '(' + getArgumentTypes () + ')';

			//	If this is a non-static member function, append the 'this' modifiers

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				declaration	+= thisType;

			//	Add the 'throw' signature

			if	( doThrowTypes ())
				declaration	+= getThrowTypes ();
			else
				declaration	|= getThrowTypes ();	// Just lose the 'throw-types'

			//	If it has a declarator, then insert it into the declaration,
			//	sensitive to the return type composition

			if	( doFunctionReturns () && pDeclarator )
			{
				*pDeclarator	= declaration;
				declaration		= returnType;

			}	// End of IF
		}	// End of IF else
	}	// End of IF then
	else
	{
		declaration	+= symbol;

		//	Catch the special handling cases

#if	( !NO_COMPILER_NAMES )
		if		( TE_isvftable ( typeCode ))
			return	getVfTableType ( declaration );
		elif	( TE_isvbtable ( typeCode ))
			return	getVbTableType ( declaration );
		elif	( TE_isguard ( typeCode ))
			return	( declaration + '{' + getGuardNumber () + "}'" );
		elif	( TE_isvdispmap ( typeCode ))
			return	getVdispMapType ( declaration );
		elif	( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode ))
			declaration	+= "`local static destructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatector ( typeCode ))
			declaration	+= "`template static data member constructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatedtor ( typeCode ))
			declaration	+= "`template static data member destructor helper'";
		elif	( TE_ismetaclass ( typeCode ))
			//
			// Meta-class information has its information in its operator id
			//
			return declaration;
#else	// } elif NO_COMPILER_NAMES {
		if	( TE_isvftable ( typeCode )
				|| TE_isvbtable ( typeCode )
				|| TE_isguard ( typeCode )
				|| TE_ismetaclass ( typeCode ))
			return	DN_invalid;
#endif	// NO_COMPILER_NAMES

		if ( TE_isthunk( typeCode ) && ( TE_istemplatector( typeCode ) || TE_istemplatedtor( typeCode ))) {
			//
			// Insert a space before the declaration
			//
			declaration = " " + declaration;
		}
		else {
			//	All others are decorated as data symbols
			declaration	= getExternalDataType ( declaration );
		}

	}	// End of IF else

	//	Prepend the 'virtual' and 'static' attributes for members

	if	( TE_ismember ( typeCode ))
	{
		if	( doMemberTypes ())
		{
			if	( TE_isstatic ( typeCode ))
				declaration	= "static " + declaration;

			if	( TE_isvirtual ( typeCode ) || ( TE_isthunk ( typeCode ) && ( TE_isvtoradj ( typeCode ) || TE_isadjustor ( typeCode ))))
				declaration	= "virtual " + declaration;

		}	// End of IF

		//	Prepend the access specifiers

		if	( doAccessSpecifiers ())
			if		( TE_isprivate ( typeCode ))
				declaration	= "private: " + declaration;
			elif	( TE_isprotected ( typeCode ))
				declaration	= "protected: " + declaration;
			elif	( TE_ispublic ( typeCode ))
				declaration	= "public: " + declaration;

	}	// End of IF

#if	( !NO_COMPILER_NAMES )
	//	If it is a thunk, mark it appropriately

	if	( TE_isthunk ( typeCode ))
		declaration	= "[thunk]:" + declaration;
#endif	// !NO_COMPILER_NAMES

	//	Return the composed declaration

	return	declaration;

}	// End of "UnDecorator" FUNCTION "composeDeclaration"


inline	int		__near	UnDecorator::getTypeEncoding ( void )
{
	unsigned int	typeCode	= 0u;


	//	Strip any leading '_' which indicates that it is based

	if	( *gName == '_' )
	{
		TE_setisbased ( typeCode );

		gName++;

	}	// End of IF

	//	Now handle the code proper :-

	if		(( *gName >= 'A' ) && ( *gName <= 'Z' ))	// Is it some sort of function ?
	{
		int	code	= *gName++ - 'A';


		//	Now determine the function type

		TE_setisfunction ( typeCode );	// All of them are functions ?

		//	Determine the calling model

		if	( code & TE_far )
			TE_setisfar ( typeCode );
		else
			TE_setisnear ( typeCode );

		//	Is it a member function or not ?

		if	( code < TE_external )
		{
			//	Record the fact that it is a member

			TE_setismember ( typeCode );

			//	What access permissions does it have

			switch	( code & TE_access )
			{
			case TE_private:
					TE_setisprivate ( typeCode );
				break;

			case TE_protect:
					TE_setisprotected ( typeCode );
				break;

			case TE_public:
					TE_setispublic ( typeCode );
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH

			//	What type of a member function is it ?

			switch	( code & TE_adjustor )
			{
			case TE_adjustor:
					TE_setisadjustor ( typeCode );
				break;

			case TE_virtual:
					TE_setisvirtual ( typeCode );
				break;

			case TE_static:
					TE_setisstatic ( typeCode );
				break;

			case TE_member:
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH
		}	// End of IF
	}	// End of IF then
	elif	( *gName == '$' )	// Extended set ?  Special handling
	{
		//	What type of symbol is it ?

		switch	( *( ++gName ))
		{
		case SHF_localdtor:	// A destructor helper for a local static ?
				TE_setislocaldtor ( typeCode );
			break;

		case SHF_vcall:	// A VCall-thunk ?
				TE_setisvcall ( typeCode );
			break;
		
		case SHF_templateStaticDataMemberCtor:	// A constructor helper for template static data members
				TE_setistemplatector ( typeCode );
			break; 

		case SHF_templateStaticDataMemberDtor:	// A destructor helper for template static data members
				TE_setistemplatedtor ( typeCode );
			break; 
		case SHF_vdispmap:
				TE_setvdispmap ( typeCode );
			break;

		case '$':
			{
				if ( * ( gName + 1 ) == SHF_AnyDLLImportMethod ) {
					gName += 1;
				}

				switch ( *( ++gName )) {
					case SHF_CPPManagedILFunction:				// C++ managed-IL function
					case SHF_CPPManagedNativeFunction:			// C++ managed-native function
					case SHF_CPPManagedILMain:					// C++ managed-IL main
					case SHF_CPPManagedNativeMain:				// C++ managed-native main
					case SHF_CPPManagedILDLLImportData:			// C++ managed-IL DLL-import function
					case SHF_CPPManagedNativeDLLImportData:		// C++ managed-native DLL-import function
						//
						// Skip the encoding
						//
						gName += 1;
						return getTypeEncoding();

					case SHF_CManagedILFunction:				// C (or extern "C") managed-IL function
					case SHF_CManagedNativeFunction:			// C (or extern "C") managed-native function
					case SHF_CManagedILDLLImportData:			// C (or extern "C") managed-IL DLL-import function 
					case SHF_CManagedNativeDLLImportData:		// C (or extern "C") managed-native DLL-import function 
						//
						// Skip the encoding
						//
						gName += 1;

						//
						// The next character should be the number of characters
						// in the byte-count
						//
						if (( *gName >= '0' ) && ( *gName <= '9' )) {
							//
							// Skip the character count and the byte-count
							// itself
							//
							gName += (( *gName - '0' ) + 1 );

							return getTypeEncoding();
						}
						else {
							TE_setisbadtype( typeCode );
						}
						break;

					default:
						break;
				}
			}
			break;

		case 0:
				TE_setistruncated ( typeCode );
			break;

		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':	// Construction displacement adjustor thunks
			{
				int	code	= *gName - '0';


				//	Set up the principal type information

				TE_setisfunction ( typeCode );
				TE_setismember ( typeCode );
				TE_setisvtoradj ( typeCode );

				//	Is it 'near' or 'far' ?

				if	( code & TE_far )
					TE_setisfar ( typeCode );
				else
					TE_setisnear ( typeCode );

				//	What type of access protection ?

				switch	( code & TE_access_vadj )
				{
				case TE_private_vadj:
						TE_setisprivate ( typeCode );
					break;

				case TE_protect_vadj:
						TE_setisprotected ( typeCode );
					break;

				case TE_public_vadj:
						TE_setispublic ( typeCode );
					break;

				default:
						TE_setisbadtype ( typeCode );
						return	typeCode;

				}	// End of SWITCH
			}	// End of CASE '0,1,2,3,4,5'
			break;

		default:
				TE_setisbadtype ( typeCode );
				return	typeCode;

		}	// End of SWITCH

		//	Advance past the code character

		gName++;

	}	// End of ELIF then
	elif	(( *gName >= TE_static_d ) && ( *gName <= TE_metatype ))	// Non function decorations ?
	{
		int	code	= *gName++;


		TE_setisdata ( typeCode );

		//	What type of symbol is it ?

		switch	( code )
		{
		case ( TE_static_d | TE_private_d ):
				TE_setisstatic ( typeCode );
				TE_setisprivate ( typeCode );
			break;

		case ( TE_static_d | TE_protect_d ):
				TE_setisstatic ( typeCode );
				TE_setisprotected ( typeCode );
			break;

		case ( TE_static_d | TE_public_d ):
				TE_setisstatic ( typeCode );
				TE_setispublic ( typeCode );
			break;

		case TE_global:
				TE_setisglobal ( typeCode );
			break;

		case TE_guard:
				TE_setisguard ( typeCode );
			break;

		case TE_local:
				TE_setislocal ( typeCode );
			break;

		case TE_vftable:
				TE_setisvftable ( typeCode );
			break;

		case TE_vbtable:
				TE_setisvbtable ( typeCode );
			break;

		case TE_metatype:
				TE_setismetaclass ( typeCode );
			break;

		default:
				TE_setisbadtype ( typeCode );

				return	typeCode;

		}	// End of SWITCH
	}	// End of ELIF then
	elif	( *gName == '9' ) {
		gName++;

		TE_setisCident ( typeCode );
	}
	elif	( *gName )
		TE_setisbadtype ( typeCode );
	else
		TE_setistruncated ( typeCode );

	//	Return the composed type code

	return	typeCode;

}	// End of "UnDecorator" FUNCTION "getTypeEncoding"



DName	__near	UnDecorator::getBasedType ( void )
{
	DName	basedDecl ( UScore ( TOK_basedLp ));


	//	What type of 'based' is it ?

	if	( *gName )
	{
		switch	( *gName++ )
		{
#if !VERS_32BIT
		case BT_segname:
				basedDecl	+= UScore ( TOK_segnameLpQ ) + getSegmentName () + "\")";
			break;

		case BT_segment:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_segment );
			break;
#endif

		case BT_void:
				basedDecl	+= "void";
			break;

#if !VERS_32BIT
		case BT_self:
				basedDecl	+= UScore ( TOK_self );
			break;

		case BT_nearptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_nearP );
			break;

		case BT_farptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_farP );
			break;

		case BT_hugeptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_hugeP );
			break;

		case BT_segaddr:
				basedDecl	+= "NYI:<segment-address-of-variable>";
			break;
#else
		case BT_nearptr:
				basedDecl	+= getScopedName();
			break;
#endif

		case BT_basedptr:
				//
				// Note: based pointer on based pointer is reserved
				//
				return	DN_invalid;

		}	// End of SWITCH
	}	// End of IF else
	else
		basedDecl	+= DN_truncated;

	//	Close the based syntax

	basedDecl	+= ") ";

	//	Return completed based declaration

	return	basedDecl;

}	// End of "UnDecorator" FUNCTION "getBasedType"



DName	__near	UnDecorator::getScopedName ( void )
{
	DName	name;


	//	Get the beginning of the name

	name	= getZName ( true );

	//	Now the scope (if any)

	if	(( name.status () == DN_valid ) && *gName && ( *gName != '@' ))
		name	= getScope () + "::" + name;

	//	Skip the trailing '@'

	if		( *gName == '@' )
		gName++;
	elif	( *gName )
		name	= DN_invalid;
	elif	( name.isEmpty ())
		name	= DN_truncated;
	else
		name	= DName ( DN_truncated ) + "::" + name;

	//	And return the complete name

	return	name;

}	// End of "UnDecorator" FUNCTION "getECSUName"


inline	DName			UnDecorator::getECSUName ( void )		{ return getScopedName(); }


inline	DName	__near	UnDecorator::getEnumType ( void )
{
	DName	ecsuName;


	if	( *gName )
	{
		//	What type of an 'enum' is it ?

		switch	( *gName )
		{
		case ET_schar:
		case ET_uchar:
				ecsuName	= "char ";
			break;

		case ET_sshort:
		case ET_ushort:
				ecsuName	= "short ";
			break;

		case ET_sint:
			break;

		case ET_uint:
				ecsuName	= "int ";
			break;

		case ET_slong:
		case ET_ulong:
				ecsuName	= "long ";
			break;

		default:
			return	DN_invalid;

		}	// End of SWITCH

		//	Add the 'unsigned'ness if appropriate
		
		switch	( *gName++ )
		{
		case ET_uchar:
		case ET_ushort:
		case ET_uint:
		case ET_ulong:
				ecsuName	= "unsigned " + ecsuName;
			break;

		}	// End of SWITCH

		//	Now return the composed name

		return	ecsuName;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getEnumType"



DName	__near	UnDecorator::getCallingConvention ( void )
{
	if	( *gName )
	{
		unsigned int	callCode	= ((unsigned int)*gName++ ) - 'A';


		//	What is the primary calling convention

		DASSERT(CC_cdecl == 0);
#if CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_cocall ))
#else	// CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_interrupt ))
#endif	// CC_COR
		{
			DName	callType;


			//	Now, what type of 'calling-convention' is it, 'interrupt' is special ?

			if	( doMSKeywords ())
#if !VERS_32BIT
				if	( callCode == CC_interrupt )
					callType	= UScore ( TOK_interrupt );
				else
#endif
				{
					switch	( callCode & ~CC_saveregs )
					{
					case CC_cdecl:
							callType	= UScore ( TOK_cdecl );
						break;

					case CC_pascal:
							callType	= UScore ( TOK_pascal );
						break;

					case CC_thiscall:
							callType	= UScore ( TOK_thiscall );
						break;

					case CC_stdcall:
							callType	= UScore ( TOK_stdcall );
						break;

					case CC_fastcall:
							callType	= UScore ( TOK_fastcall );
						break;

					case CC_cocall:
							callType	= UScore ( TOK_cocall );
						break;

					}	// End of SWITCH

					//	Has it also got 'saveregs' marked ?

#if !VERS_32BIT
					if	( callCode & CC_saveregs )
						callType	+= ' ' + UScore ( TOK_saveregs );
#endif

				}	// End of IF else

			//	And return

			return	callType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getCallingConvention"



DName	__near	UnDecorator::getReturnType ( DName * pDeclarator )
{
	if	( *gName == '@' )	// Return type for constructors and destructors ?
	{
		gName++;

		return	DName ( pDeclarator );

	}	// End of IF then
	else
		return	getDataType ( pDeclarator );

}	// End of "UnDecorator" FUNCTION "getReturnType"



DName	__near	UnDecorator::getDataType ( DName * pDeclarator )
{
	DName	superType ( pDeclarator );


	//	What type is it ?

	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case DT_void:
			gName++;

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

	case '?':
		{

			gName++;	// Skip the '?'

			superType = getDataIndirectType ( superType, 0, DName (), 0);
			return	getPrimaryDataType ( superType );

			return	superType;

		}	// End of CASE '?'

	default:
			return	getPrimaryDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getDataType"



DName	__near	UnDecorator::getPrimaryDataType ( const DName & superType )
{
	DName	cvType;


	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case PDT_volatileReference:
			cvType	= "volatile";

			if	( !superType.isEmpty ())
				cvType	+= ' ';

		// No break

	case PDT_reference:
		{
			DName	superName ( superType );


			gName++;

			return	getReferenceType ( cvType, superName.setPtrRef ());

		}	// End of CASE 'PDT_reference'

	case PDT_extend:
		{
			//
			// Extended Primary Data Type (items overlooked in original design):
			// prefixed by '$$'.
			//
			if	( gName[1] != PDT_extend )
				if	( gName[1] == '\0' ) 
					return DN_truncated + superType;
				else
					return DN_invalid;

			gName += 2;

			switch	( *gName )
			{
			case PDT_ex_function:
				gName++;
				return	getFunctionIndirectType( superType );

			case PDT_ex_other:
				gName++;
				return	getPtrRefDataType( superType, /* isPtr = */ TRUE );

			case PDT_ex_qualified:
				gName++;
				return(getBasicDataType(getDataIndirectType ( superType, 0, DName (), 0)));

			case 0:
				return	( DN_truncated + superType );

			default:
				return	DN_invalid;
			}
		}

	default:
			return	getBasicDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getPrimaryDataType"



DName	__near	UnDecorator::getArgumentTypes ( void )
{
	switch	( *gName )
	{
	case AT_ellipsis:
			return	( gName++, "..." );

	case AT_void:
			return	( gName++, "void" );

	default:
		{
			DName	arguments ( getArgumentList ());


			//	Now, is it a varargs function or not ?

			if	( arguments.status () == DN_valid )
				switch	( *gName )
				{
				case 0:
						return	arguments;

				case AT_ellipsis:
						return	( gName++, arguments + ",..." );

				case AT_endoflist:
						return	( gName++, arguments );

				default:
						return	DN_invalid;

				}	// End of SWITCH
			else
				return	arguments;

		}	// End of DEFAULT
	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getArgumentTypes"


DName	__near	UnDecorator::getArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;


	while	(( aList.status () == DN_valid ) && ( *gName != AT_endoflist ) && ( *gName != AT_ellipsis ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		if	( *gName )
		{
			int		argIndex	= *gName - '0';


			//	Handle 'argument-replicators', otherwise a new argument type

			if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
			{
				gName++;	// Skip past the replicator

				//	Append to the argument list

				aList	+= ( *pArgList )[ argIndex ];

			}	// End of IF then
			else
			{
				pcchar_t	oldGName	= gName;


				//	Extract the 'argument' type

				DName	arg ( getPrimaryDataType ( DName ()));


				//	Add it to the current list of 'argument's, if it is bigger than a one byte encoding

				if	((( gName - oldGName ) > 1 ) && !pArgList->isFull ())
					*pArgList	+= arg;

				//	Append to the argument list

				aList	+= arg;

			}	// End of IF else
		}	// End of IF then
		else
		{
			aList	+= DN_truncated;

			break;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed argument list

	return	aList;

}	// End of "UnDecorator" FUNCTION "getArgumentList"



DName	__near	UnDecorator::getThrowTypes ( void )
{
	if	( *gName )
		if	( *gName == AT_ellipsis )	// Handle ellipsis here to suppress the 'throw' signature
			return	( gName++, DName ());
		else
			return	( " throw(" + getArgumentTypes () + ')' );
	else
		return	( DName ( " throw(" ) + DN_truncated + ')' );

}	// End of "UnDecorator" FUNCTION "getThrowTypes"



DName	__near	UnDecorator::getBasicDataType ( const DName & superType )
{
	if	( *gName )
	{
		unsigned char	bdtCode	= *gName++;
		unsigned char	extended_bdtCode;
		int				pCvCode	= -1;
		DName			basicDataType;


		//	Extract the principal type information itself, and validate the codes

		switch	( bdtCode )
		{
		case BDT_schar:
		case BDT_char:
		case ( BDT_char   | BDT_unsigned ):
				basicDataType	= "char";
			break;

		case BDT_short:
		case ( BDT_short  | BDT_unsigned ):
				basicDataType	= "short";
			break;

		case BDT_int:
		case ( BDT_int    | BDT_unsigned ):
				basicDataType	= "int";
			break;

		case BDT_long:
		case ( BDT_long   | BDT_unsigned ):
				basicDataType	= "long";
			break;

#if !VERS_32BIT
		case BDT_segment:
				basicDataType	= UScore ( TOK_segment );
			break;
#endif

		case BDT_float:
				basicDataType	= "float";
			break;

		case BDT_longdouble:
				basicDataType	= "long ";

			// No break

		case BDT_double:
				basicDataType	+= "double";
			break;

		case BDT_pointer:
		case ( BDT_pointer | BDT_const ):
		case ( BDT_pointer | BDT_volatile ):
		case ( BDT_pointer | BDT_const | BDT_volatile ):
				pCvCode	= ( bdtCode & ( BDT_const | BDT_volatile ));
			break;
		case BDT_extend:
			switch(extended_bdtCode = *gName++) {
				case BDT_array:
					pCvCode = -2;
					break;
				case BDT_bool:
					basicDataType	= "bool";
					break;
				case BDT_int8:
				case ( BDT_int8   | BDT_unsigned ):
					basicDataType	= "__int8";
					break;
				case BDT_int16:
				case ( BDT_int16  | BDT_unsigned ):
					basicDataType	= "__int16";
					break;
				case BDT_int32:
				case ( BDT_int32  | BDT_unsigned ):
					basicDataType	= "__int32";
					break;
				case BDT_int64:
				case ( BDT_int64  | BDT_unsigned ):
					basicDataType	= "__int64";
					break;
				case BDT_int128:
				case ( BDT_int128 | BDT_unsigned ):
					basicDataType	= "__int128";
					break;
				case BDT_wchar_t:
					basicDataType	= "wchar_t";
					break;
#if CC_COR
				case BDT_coclass:
				case BDT_cointerface:
					{
						gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

						basicDataType = getECSUDataType();

						if ( basicDataType.isEmpty()) {
							return basicDataType;
						}
					}
					break;
#endif	// CC_COR
				case '$':
					return "__w64 " + getBasicDataType (superType);
				default:
					basicDataType	= "UNKNOWN";
					break;
				}
			break;
		default:
				gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

				basicDataType	= getECSUDataType ();

				if	( basicDataType.isEmpty ())
					return	basicDataType;
			break;

		}	// End of SWITCH

		//	What type of basic data type composition is involved ?

		if	( pCvCode == -1 )	// Simple ?
		{
			//	Determine the 'signed/unsigned'ness

			switch	( bdtCode )
			{
			case ( BDT_char   | BDT_unsigned ):
			case ( BDT_short  | BDT_unsigned ):
			case ( BDT_int    | BDT_unsigned ):
			case ( BDT_long   | BDT_unsigned ):
					basicDataType	= "unsigned " + basicDataType;
				break;

			case BDT_schar:
					basicDataType	= "signed " + basicDataType;
				break;
			case BDT_extend:
				switch	( extended_bdtCode )
				{

					case ( BDT_int8   | BDT_unsigned ):
					case ( BDT_int16  | BDT_unsigned ):
					case ( BDT_int32  | BDT_unsigned ):
					case ( BDT_int64  | BDT_unsigned ):
					case ( BDT_int128 | BDT_unsigned ):
						basicDataType	= "unsigned " + basicDataType;
						break;

				}	// End of SWITCH
				break;

			}	// End of SWITCH

			// 	Add the indirection type to the type

			if	( !superType.isEmpty () )
					basicDataType	+= ' ' + superType;

			//	And return the completed type

			return	basicDataType;

		}	// End of IF then
		else
		{
			DName	cvType;
			DName	superName ( superType );

			if ( pCvCode == -2 )
			{
				superName.setIsArray();
				DName arType =	getPointerTypeArray ( cvType, superName );
				// if we didn't get back an array, append.
				// A multidimensional array sticks the braces in before the
				// other dimensions at sets isArray on it's return type.
				if (!arType.isArray()) {
					arType += "[]";
				}
				return arType;
			}

			//	Is it 'const/volatile' qualified ?
			
			if		( superType . isEmpty() ) 
			{
				//
				// const/volatile are redundantly encoded, except at the start
				// of a "type only" context.  In such a context, the super-type
				// is empty.
				//
				if		( pCvCode & BDT_const )
				{
					cvType	= "const";

					if	( pCvCode & BDT_volatile )
						cvType	+= " volatile";
				}	// End of IF then
				elif	( pCvCode & BDT_volatile )
					cvType	= "volatile";
			}	// End of IF then

			//	Construct the appropriate pointer type declaration

			return	getPointerType ( cvType, superName );

		}	// End of IF else
	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getBasicDataType"



DName	__near	UnDecorator::getECSUDataType ( void )
{
	//	Extract the principal type information itself, and validate the codes

	int fPrefix = doEcsu() && !doNameOnly();

	DName Prefix;

	switch	( *gName++ )
	{
	case 0:
			gName--;	// Backup to permit later error recovery to work safely

			return	"`unknown ecsu'" + DN_truncated;

	case BDT_union:
			Prefix = "union ";
		break;

	case BDT_struct:
			Prefix = "struct ";
		break;

	case BDT_class:
			Prefix = "class ";
		break;

#if CC_COR
	case BDT_coclass:
			Prefix = "coclass ";
		break;

	case BDT_cointerface:
			Prefix = "cointerface ";
		break;
#endif	// CC_COR

	case BDT_enum:
			fPrefix = doEcsu();

			Prefix = "enum " + getEnumType ();
		break;

//	default:
//			return	DN_invalid;

	}	// End of SWITCH

	DName			ecsuDataType;

	if	( fPrefix )
		ecsuDataType	= Prefix;

	//	Get the 'class/struct/union' name

	ecsuDataType	+= getECSUName ();

	//	And return the formed 'ecsu-data-type'

	return	ecsuDataType;

}	// End of "UnDecorator" FUNCTION "getECSUDataType"


//
// Undecorator::getFunctionIndirectType
//
//	Note: this function gets both the function-indirect-type and the function-type.
//
DName		UnDecorator::getFunctionIndirectType( const DName & superType )
{
	if	( ! *gName )
		return DN_truncated + superType;

	if	( ! IT_isfunction( *gName ))
		return DN_invalid;


	int		fitCode	= *gName++ - '6';

	if		( fitCode == ( '_' - '6' ))
	{
		if	( *gName )
		{
			fitCode	= *gName++ - 'A' + FIT_based;

			if	(( fitCode < FIT_based ) || ( fitCode > ( FIT_based | FIT_far | FIT_member )))
				fitCode	= -1;

		}	// End of IF then
		else
			return	( DN_truncated + superType );

	}	// End of IF then
	elif	(( fitCode < FIT_near ) || ( fitCode > ( FIT_far | FIT_member )))
		fitCode	= -1;

	//	Return if invalid name

	if	( fitCode == -1 )
		return	DN_invalid;


	//	Otherwise, what are the function indirect attributes

	DName	thisType;
	DName	fitType = superType;

	//	Is it a pointer to member function ?

	if	( fitCode & FIT_member )
	{
		fitType	= "::" + fitType;

		if	( *gName )
			fitType	= ' ' + getScope () + fitType;
		else
			fitType	= DN_truncated + fitType;

		if	( *gName )
			if	( *gName == '@' )
				gName++;
			else
				return	DN_invalid;
		else
			return	( DN_truncated + fitType );

		if	( doThisTypes ())
			thisType	= getThisType ();
		else
			thisType	|= getThisType ();

	}	// End of IF

	//	Is it a based allocated function ?

	if	( fitCode & FIT_based )
		if	( doMSKeywords ())
			fitType	= ' ' + getBasedType () + fitType;
		else
			fitType	|= getBasedType ();	// Just lose the 'based-type'

	//	Get the 'calling-convention'

	if	( doMSKeywords ())
	{
		fitType	= getCallingConvention () + fitType;

		//	Is it a near or far function pointer

#if !VERS_32BIT
		fitType	= UScore ((( fitCode & FIT_far ) ? TOK_farSp : TOK_nearSp )) + fitType;
#endif

	}	// End of IF then
	else
		fitType	|= getCallingConvention ();	// Just lose the 'calling-convention'

	//	Parenthesise the indirection component, and work on the rest

	if	( ! superType . isEmpty() ) {
		fitType	= '(' + fitType + ')';
	}

	//	Get the rest of the 'function-type' pieces

	DName *	pDeclarator	= gnew DName;
	DName	returnType ( getReturnType ( pDeclarator ));


	fitType	+= '(' + getArgumentTypes () + ')';

	if	( doThisTypes () && ( fitCode & FIT_member ))
		fitType	+= thisType;

	if	( doThrowTypes ())
		fitType	+= getThrowTypes ();
	else
		fitType	|= getThrowTypes ();	// Just lose the 'throw-types'

	//	Now insert the indirected declarator, catch the allocation failure here

	if	( pDeclarator )
		*pDeclarator	= fitType;
	else
		return	DN_error;

	//	And return the composed function type (now in 'returnType' )

	return	returnType;
}


DName	__near	UnDecorator::getPtrRefType ( const DName & cvType, const DName & superType, char ptrChar )
{
	//	Doubles up as 'pointer-type' and 'reference-type'

	if	( *gName )
		if	( IT_isfunction ( *gName ))	// Is it a function or data indirection ?
		{
			DName	fitType	= ptrChar;


			if	( !cvType.isEmpty () && ( superType.isEmpty () || !superType.isPtrRef ()))
				fitType	+= cvType;

			if	( !superType.isEmpty ())
				fitType	+= superType;

			return getFunctionIndirectType( fitType );
		}	// End of IF then
		else
		{
			//	Otherwise, it is either a pointer or a reference to some data type

			DName	innerType ( getDataIndirectType ( superType, ptrChar, cvType ));

			return	getPtrRefDataType ( innerType, ptrChar == '*' );
		}	// End of IF else
	else
	{
		DName	trunk ( DN_truncated );


		trunk	+= ptrChar;

		if	( !cvType.isEmpty ())
			trunk	+= cvType;

		if	( !superType.isEmpty ())
		{
			if	( !cvType.isEmpty ())
				trunk	+= ' ';

			trunk	+= superType;

		}	// End of IF

		return	trunk;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getPtrRefType"



DName	__near	UnDecorator::getDataIndirectType ( const DName & superType, char prType, const DName & cvType, int thisFlag )
{
	DName szComPlusIndirSpecifier;

	if		( *gName )
	{
		if( gName[0] == '$' ) 
		{
			gName++;	// swallow up the dollar

			switch( *gName )
			{
			case PDT_GCPointer:
				szComPlusIndirSpecifier = "__gc ";
				gName++;
				break;

			case PDT_PinnedPointer:
				szComPlusIndirSpecifier = "__pin ";
				gName++;
				break;
			default:
				unsigned int nRank = ((gName[0]-'0') << 4) + (gName[1]-'0');
				gName += 2;

				DASSERT( nRank < 256 );

				szComPlusIndirSpecifier = "__gc[";

				for( unsigned int i=1; i<nRank; i++ )
				{
					szComPlusIndirSpecifier = szComPlusIndirSpecifier + ",";
				}

				szComPlusIndirSpecifier = szComPlusIndirSpecifier + "] ";

				if	( !superType.isEmpty () )
					if ( superType.isArray() )
						szComPlusIndirSpecifier	= superType + szComPlusIndirSpecifier;
					else
						szComPlusIndirSpecifier	= '(' + superType + ')' + szComPlusIndirSpecifier;

				gName++;

				return szComPlusIndirSpecifier;
			}
		}

		unsigned int	ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));

		DName msExtension;
		DName msExtensionPre;

		int fContinue = TRUE;

		do
		{
			switch	( ditCode )
			{
			case DIT_ptr64:
					if	( doMSKeywords () && doPtr64() ) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_ptr64 );
						else
							msExtension = UScore( TOK_ptr64 );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_unaligned:
					if	( doMSKeywords ()) {
						if ( !msExtensionPre.isEmpty())
							msExtensionPre = msExtensionPre + ' ' + UScore( TOK_unaligned );
						else
							msExtensionPre = UScore( TOK_unaligned );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_restrict:
					if	( doMSKeywords ()) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_restrict );
						else
							msExtension = UScore( TOK_restrict );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;

			default:

				fContinue = FALSE;
				break;
			}
		} while (fContinue);

		gName++;		// Skip to next character in name

		//	Is it a valid 'data-indirection-type' ?

		DASSERT(DIT_near == 0);
		if	(( ditCode <= ( DIT_const | DIT_volatile | DIT_modelmask | DIT_member )))
		{
			DName	ditType ( prType );

			ditType = szComPlusIndirSpecifier + ditType;

			if ( !msExtension.isEmpty()) 
				ditType = ditType + ' ' + msExtension;

			if ( !msExtensionPre.isEmpty())
				ditType = msExtensionPre + ' ' + ditType;

			//	If it is a member, then these attributes immediately precede the indirection token

			if	( ditCode & DIT_member )
			{
				//	If it is really 'this-type', then it cannot be any form of pointer to member

				if	( thisFlag )
					return	DN_invalid;

				//	Otherwise, extract the scope for the PM

				if		( prType != '\0' )
				{
					ditType		= "::" + ditType;

					if	( *gName )
						ditType	= getScope () + ditType;
					else
						ditType	= DN_truncated + ditType;
				}
				elif	( *gName )
				{
					//
					// The scope is ignored for special uses of data-indirect-type, such
					// as storage-convention.  I think it's a bug that we ever mark things
					// with Member storage convention, as that is already covered in the
					// scope of the name.  However, we don't want to change the dname scheme,
					// so we're stuck with it.
					//
					ditType |= getScope ();
				}

				//	Now skip the scope terminator

				if		( !*gName )
					ditType	+= DN_truncated;
				elif	( *gName++ != '@' )
					return	DN_invalid;

			}	// End of IF

			//	Add the 'model' attributes (prefixed) as appropriate

			if	( doMSKeywords ()) {
				switch	( ditCode & DIT_modelmask )
				{
#if !VERS_32BIT
				case DIT_near:
						if	( do32BitNear ())
							ditType	= UScore ( TOK_near ) + ditType;
					break;

				case DIT_far:
						ditType	= UScore ( TOK_far ) + ditType;
					break;

				case DIT_huge:
						ditType	= UScore ( TOK_huge ) + ditType;
					break;
#endif

				case DIT_based:
						//	The 'this-type' can never be 'based'

						if	( thisFlag )
							return	DN_invalid;

						ditType	= getBasedType () + ditType;
					break;

				}	// End of SWITCH
			}	// End of IF
			elif	(( ditCode & DIT_modelmask ) == DIT_based )
				ditType	|= getBasedType ();	// Just lose the 'based-type'

			//	Handle the 'const' and 'volatile' attributes

			if	( ditCode & DIT_volatile )
				ditType	= "volatile " + ditType;

			if	( ditCode & DIT_const )
				ditType	= "const " + ditType;

			//	Append the supertype, if not 'this-type'

			if	( !thisFlag )
				if		( !superType.isEmpty ())
				{
					//	Is the super context included 'cv' information, ensure that it is added appropriately

					if	( superType.isPtrRef () || cvType.isEmpty ())
						if (superType.isArray())
							ditType	= superType;	// array type, skip space
						else
							ditType	+= ' ' + superType;
					else
						ditType	+= ' ' + cvType + ' ' + superType;

				}	// End of IF then
				elif	( !cvType.isEmpty ())
					ditType	+= ' ' + cvType;

			//	Make sure qualifiers aren't re-applied
			ditType.setPtrRef ();

			//	Finally, return the composed 'data-indirection-type' (with embedded sub-type)

			return	ditType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( !thisFlag && !superType.isEmpty ())
	{
		//	Is the super context included 'cv' information, ensure that it is added appropriately

		if	( superType.isPtrRef () || cvType.isEmpty ())
			return	( DN_truncated + superType );
		else
			return	( DN_truncated + cvType + ' ' + superType );

	}	// End of ELIF then
	elif	( !thisFlag && !cvType.isEmpty ())
		return	( DN_truncated + cvType );
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDataIndirectType"


inline	DName	__near	UnDecorator::getPtrRefDataType ( const DName & superType, int isPtr )
{
	//	Doubles up as 'pointer-data-type' and 'reference-data-type'

	if	( *gName )
	{
		//	Is this a 'pointer-data-type' ?

		if	( isPtr && ( *gName == PoDT_void ))
		{
			gName++;	// Skip this character

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

		}	// End of IF

		//	Otherwise it may be a 'reference-data-type'

		if	( *gName == RDT_array )	// An array ?
		{
			gName++;

			return	getArrayType( superType );

		}	// End of IF

		//	Otherwise, it is a 'basic-data-type'

		if	( *gName == '_' && gName[1] == 'Z' )	// A boxed type ?
		{
			gName += 2;
			return "__box " + getBasicDataType ( superType );
		}

		return	getBasicDataType ( superType );

	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getPtrRefDataType"


inline	DName	__near	UnDecorator::getArrayType ( const DName & superType )
{
	if	( *gName )
	{
		int	noDimensions	= getNumberOfDimensions ();

		if ( noDimensions < 0 )
			noDimensions = 0;

		if	( !noDimensions )
			return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );
		else
		{
			DName	arrayType;

			if ( superType.isArray() ) {
				arrayType	+= "[]";
			}

			while	( noDimensions-- )
				arrayType	+= '[' + getDimension () + ']';

			//	If it is indirect, then parenthesise the 'super-type'

			if	( !superType.isEmpty () )
				if ( superType.isArray() )
					arrayType	= superType + arrayType;
				else
					arrayType	= '(' + superType + ')' + arrayType;

			//	Return the finished array dimension information

			DName newType =	getPrimaryDataType ( arrayType );
			newType.setIsArray();
			return newType;

		}	// End of IF else
	}	// End of IF
	elif	( !superType.isEmpty ())
		return	getBasicDataType ( '(' + superType + ")[" + DN_truncated + ']' );
	else
		return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );

}	// End of "UnDecorator" FUNCTION "getArrayType"


inline		DName		__near	UnDecorator::getLexicalFrame ( void )		{	return	'`' + getDimension () + '\'';	}
inline		DName		__near	UnDecorator::getStorageConvention ( void )	{	return	getDataIndirectType ();	}
inline		DName		__near	UnDecorator::getDataIndirectType ()			{	return	getDataIndirectType ( DName (),  0, DName ());	}
inline		DName		__near	UnDecorator::getThisType ( void )			{	return	getDataIndirectType ( DName (), 0, DName (), TRUE );	}

inline	DName		__near	UnDecorator::getPointerType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '*' );	}

inline	DName		__near	UnDecorator::getPointerTypeArray ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '\0' );	}

inline	DName		__near	UnDecorator::getReferenceType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '&' );	}

inline	DName		__near	UnDecorator::getSegmentName ( void )		{	return	getZName ( true );	}

#if	( !NO_COMPILER_NAMES )
inline	DName		__near	UnDecorator::getDisplacement ( void )		{	return	getDimension ( true );	}
inline	DName		__near	UnDecorator::getCallIndex ( void )			{	return	getDimension ();	}
inline	DName		__near	UnDecorator::getGuardNumber ( void )		{	return	getDimension ();	}

inline	DName	__near	UnDecorator::getVbTableType ( const DName & superType )
{	return	getVfTableType ( superType );	}


inline	DName	__near	UnDecorator::getVCallThunkType ( void )
{
#if VERS_32BIT
	switch (*gName) {
	case VMT_nTnCnV:
		++gName;
		return DName("{flat}");
	case 0:
		return DN_truncated;
	default:
		return DN_invalid;
	}
#else
	DName	vcallType	= '{';


	//	Get the 'this' model, and validate all values

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_nTnCbV:
	case VMT_nTfCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_fTnCnV:
	case VMT_fTfCnV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case 0:
			return	DN_truncated;

	default:
			return	DN_invalid;

	}	// End of SWITCH

	//	Always append 'this'

	vcallType	+= "this, ";

	//	Get the 'call' model

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_fTnCnV:
	case VMT_nTnCfV:
	case VMT_fTnCfV:
	case VMT_nTnCbV:
	case VMT_fTnCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTfCnV:
	case VMT_fTfCnV:
	case VMT_nTfCfV:
	case VMT_fTfCfV:
	case VMT_nTfCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	}	// End of SWITCH

	//	Always append 'call'

	vcallType	+= "call, ";

	//	Get the 'vfptr' model

	switch	( *gName++ )	// Last time, so advance the pointer
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_fTnCnV:
	case VMT_fTfCnV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case VMT_nTfCbV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
	case VMT_nTnCbV:
			vcallType	+= getBasedType ();
		break;

	}	// End of SWITCH	

	//	Always append 'vfptr'

	vcallType	+= "vfptr}";

	//	And return the resultant 'vcall-model-type'

	return	vcallType;
#endif

}	// End of "UnDecorator" FUNCTION "getVCallThunk"


inline	DName	__near	UnDecorator::getVfTableType ( const DName & superType )
{
	DName	vxTableName	= superType;


	if	( vxTableName.isValid () && *gName )
	{
		vxTableName	= getStorageConvention () + ' ' + vxTableName;

		if	( vxTableName.isValid ())
		{
			if	( *gName != '@' )
			{
				vxTableName	+= "{for ";

				while	( vxTableName.isValid () && *gName && ( *gName != '@' ))
				{
					vxTableName	+= '`' + getScope () + '\'';

					//	Skip the scope delimiter

					if	( *gName == '@' )
						gName++;

					//	Close the current scope, and add a conjunction for the next (if any)

					if	( vxTableName.isValid () && ( *gName != '@' ))
						vxTableName	+= "s ";

				}	// End of WHILE

				if	( vxTableName.isValid ())
				{
					if	( !*gName )
						vxTableName	+= DN_truncated;

					vxTableName	+= '}';

				}	// End of IF
			}	// End of IF

			//	Skip the 'vpath-name' terminator

			if	( *gName == '@' )
				gName++;

		}	// End of IF
	}	// End of IF then
	elif	( vxTableName.isValid ())
		vxTableName	= DN_truncated + vxTableName;

	return	vxTableName;

}	//	End of "UnDecorator" FUNCTION "getVfTableType"


inline	DName	__near	UnDecorator::getVdispMapType ( const DName & superType )
{
	DName	vdispMapName	= superType;
	vdispMapName += "{for ";
	vdispMapName += getScope();
	vdispMapName += '}';

	if	( *gName == '@' )
		gName++;
	return vdispMapName;
}
#endif	// !NO_COMPILER_NAMES


inline	DName	__near	UnDecorator::getExternalDataType ( const DName & superType )
{
	//	Create an indirect declarator for the the rest

	DName *	pDeclarator	= gnew DName ();
	DName	declaration	= getDataType ( pDeclarator );


	//	Now insert the declarator into the declaration along with its 'storage-convention'

	*pDeclarator	= getStorageConvention () + ' ' + superType;

	return	declaration;

}	//	End of "UnDecorator" FUNCTION "getExternalDataType"

inline	int			__near	UnDecorator::doUnderScore ()				{	return	!( disableFlags & UNDNAME_NO_LEADING_UNDERSCORES );	}
inline	int			__near	UnDecorator::doMSKeywords ()				{	return	!( disableFlags & UNDNAME_NO_MS_KEYWORDS );			}
inline	int			__near	UnDecorator::doPtr64 ()						{	return	!( disableFlags & UNDNAME_NO_PTR64 );				}
inline	int			__near	UnDecorator::doFunctionReturns ()			{	return	!( disableFlags & UNDNAME_NO_FUNCTION_RETURNS );	}
inline	int			__near	UnDecorator::doAllocationModel ()			{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_MODEL );	}
inline	int			__near	UnDecorator::doAllocationLanguage ()		{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_LANGUAGE );	}

#if	0
inline	int			__near	UnDecorator::doMSThisType ()				{	return	!( disableFlags & UNDNAME_NO_MS_THISTYPE );			}
inline	int			__near	UnDecorator::doCVThisType ()				{	return	!( disableFlags & UNDNAME_NO_CV_THISTYPE );			}
#endif

inline	int			__near	UnDecorator::doThisTypes ()					{	return	(( disableFlags & UNDNAME_NO_THISTYPE ) != UNDNAME_NO_THISTYPE );	}
inline	int			__near	UnDecorator::doAccessSpecifiers ()			{	return	!( disableFlags & UNDNAME_NO_ACCESS_SPECIFIERS );	}
inline	int			__near	UnDecorator::doThrowTypes ()				{	return	!( disableFlags & UNDNAME_NO_THROW_SIGNATURES );	}
inline	int			__near	UnDecorator::doMemberTypes ()				{	return	!( disableFlags & UNDNAME_NO_MEMBER_TYPE );			}
inline	int			__near	UnDecorator::doReturnUDTModel ()			{	return	!( disableFlags & UNDNAME_NO_RETURN_UDT_MODEL );	}

inline	int			__near	UnDecorator::do32BitNear ()					{	return	!( disableFlags & UNDNAME_32_BIT_DECODE );			}

inline	int			__near	UnDecorator::doNameOnly ()					{	return	( disableFlags & UNDNAME_NAME_ONLY );				}
inline	int			__near	UnDecorator::doTypeOnly ()					{	return	( disableFlags & UNDNAME_TYPE_ONLY );				}
inline	int			__near	UnDecorator::haveTemplateParameters ()		{	return	( disableFlags & UNDNAME_HAVE_PARAMETERS);			}
inline	int 		__near	UnDecorator::doEcsu ()						{	return	!( disableFlags & UNDNAME_NO_ECSU );				}
inline	int 		__near	UnDecorator::doNoIdentCharCheck ()			{	return	( disableFlags & UNDNAME_NO_IDENT_CHAR_CHECK );		}


pcchar_t	__near	UnDecorator::UScore ( Tokens tok  )
{
#if !VERS_32BIT
	if		((( tok == TOK_nearSp ) || ( tok == TOK_nearP )) && !do32BitNear ())
		return	tokenTable[ tok ] + 6;	// Skip '__near'
#endif
	if		( doUnderScore ())
		return	tokenTable[ tok ];
	else
		return	tokenTable[ tok ] + 2 ;

}	// End of "UnDecorator" FUNCTION "UScore"


//	Include the string composition support classes.  Mostly inline stuff, and
//	not important to the algorithm.

#include	"undname.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\langapi\undname\undname.inl ===
/*
 *	This module contains the definitions for the inline functions used by the
 *	name undecorator.  It is intended that this file should be included
 *	somewhere in the source file for the undecorator to maximise the chance
 *	that they will be truly inlined.
 */

//	The following class is a special node class, used in the implementation
//	of the internal chaining mechanism of the 'DName's

class	charNode;
class	pcharNode;
class	pDNameNode;
class	DNameStatusNode;


#if	( NO_VIRTUAL )
enum	NodeType
{
	charNode_t,
	pcharNode_t,
	pDNameNode_t,
	DNameStatusNode_t

};
#endif	// NO_VIRTUAL


class	DNameNode
{
private:

#if	NO_VIRTUAL
		NodeType			typeIndex;
#endif	// NO_VIRTUAL

		DNameNode *			next;

protected:

#if	( !NO_VIRTUAL )
					__near	DNameNode ();
#else	// } elif NO_VIRTUAL {
					__near	DNameNode ( NodeType );
#endif	// NO_VIRTUAL

					__near	DNameNode ( const DNameNode & );

public:

virtual	int			__near	length () const PURE;
virtual	char		__near	getLastChar () const PURE;
virtual	pchar_t		__near	getString ( pchar_t, int ) const PURE;
		DNameNode *	__near	clone ();
		DNameNode *	__near	nextNode () const;

		DNameNode &	__near	operator += ( DNameNode * );

};


class	charNode		: public DNameNode
{
private:
		char				me;

public:
					__near	charNode ( char );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pcharNode		: public DNameNode
{
private:
		pchar_t				me;
		int					myLen;

public:
					__near	pcharNode ( pcchar_t, int = 0 );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pDNameNode		: public DNameNode
{
private:
		DName *				me;

public:
					__near	pDNameNode ( DName * );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	DNameStatusNode	: public DNameNode
{
private:
#define	TruncationMessage		(" ?? ")
#define	TruncationMessageLength	(4)

		DNameStatus			me;
		int					myLen;

public:
					__near	DNameStatusNode ( DNameStatus );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};



//	Memory allocation functions
			
inline	void __far *	__near __pascal	operator new ( size_t sz, HeapManager &, int noBuffer )
{	return	heap.getMemory ( sz, noBuffer );	}

void __far *	__near	HeapManager::getMemory ( size_t sz, int noBuffer )
{
	//	Align the allocation on an appropriate boundary

	sz	= (( sz + PACK_SIZE-1 ) & ~(PACK_SIZE-1) );

	if	( noBuffer )
		return	( *pOpNew )( sz );
	else
	{
		//	Handle a potential request for no space

		if	( !sz )
			sz	= PACK_SIZE;

		if	( blockLeft < sz )
		{
			//	Is the request greater than the largest buffer size ?

			if	( sz > memBlockSize )
				return	0;		// If it is, there is nothing we can do


			//	Allocate a new block

			Block *	pNewBlock	= rnew Block;


			//	Did the allocation succeed ?  If so connect it up

			if	( pNewBlock )
			{
				//	Handle the initial state

				if	( tail )
					tail	= tail->next	= pNewBlock;
				else
					head	= tail			= pNewBlock;

				//	Compute the remaining space

				blockLeft	= memBlockSize - sz;

			}	// End of IF then
			else
				return	0;		// Oh-oh!  Memory allocation failure

		}	// End of IF then
		else
			blockLeft	-= sz;	// Deduct the allocated amount

		//	And return the buffer address

		return	&( tail->memBlock[ blockLeft ]);

	}	// End of IF else
}	// End of "HeapManager" FUNCTION "getMemory(size_t,int)"




//	Friend functions of 'DName'

inline DName	__near __pascal	operator + ( char c, const DName & rd )
{	return	DName ( c ) + rd;	}

inline DName	__near __pascal	operator + ( DNameStatus st, const DName & rd )
{	return	DName ( st ) + rd;	}

inline DName	__near __pascal	operator + ( pcchar_t s, const DName & rd )
{	return	DName ( s ) + rd;	}


//	The 'DName' constructors

inline		__near	DName::DName ()					{	node	= 0;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }
inline		__near	DName::DName ( DNameNode * pd )	{	node	= pd;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }

__near	DName::DName ( char c )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	The NULL character is boring, do not copy

	if	( c )
		doPchar ( &c, 1 );

}	// End of "DName" CONSTRUCTOR '(char)'


#if	1
inline __near	DName::DName ( const DName & rd )
{
	stat	= rd.stat;
	isIndir	= rd.isIndir;
	isAUDC	= rd.isAUDC;
	isAUDTThunk = rd.isAUDTThunk;
	isArrayType = rd.isArrayType;
	node	= rd.node;
	NoTE	= rd.NoTE;
}	// End of "DName" CONSTRUCTOR '(const DName&)'
#endif


__near	DName::DName ( DName * pd )
{
	if	( pd )
	{
		node	= gnew pDNameNode ( pd );
		stat	= ( node ? DN_valid : DN_error );

	}	// End of IF else
	else
	{
		stat	= DN_valid;
		node	= 0;

	}	// End of IF else

	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

}	// End of "DName" CONSTRUCTOR '( DName* )'


__near	DName::DName ( pcchar_t s )
{
	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( s )
		doPchar ( s, und_strlen ( s ));

}	// End of "DName" CONSTRUCTOR '(pcchar_t)'


__near	DName::DName ( pcchar_t & name, char terminator )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	Is there a string ?

	if	( name )
		if	( *name )
		{
			int	len	= 0;


			//	How long is the string ?

			pcchar_t s;
			for	( s = name; *name && ( *name != terminator ); name++ )
				if	( isValidIdentChar ( *name ) || UnDecorator::doNoIdentCharCheck () )
					len++;
				else
				{
					stat	= DN_invalid;

					return;

				}	// End of IF else

			//	Copy the name string fragment

			doPchar ( s, len );

			//	Now gobble the terminator if present, handle error conditions

			if	( *name )
			{
				if	( *name++ != terminator )
				{
					stat	= DN_error;
					node	= 0;

				}	// End of IF then
				else
					stat	= DN_valid;

			}	// End of IF then
			elif	( status () == DN_valid )
				stat	= DN_truncated;

		}	// End of IF then
		else
			stat	= DN_truncated;
	else
		stat	= DN_invalid;

}	// End of "DName" CONSTRUCTOR '(pcchar_t&,char)'


__near	DName::DName ( unsigned long num )
{
	char	buf[ 11 ];
	char *	pBuf	= buf + 10;


	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ultoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	doPchar ( pBuf, ( 10 - (int) ( pBuf - buf )));

}	// End of "DName" CONSTRUCTOR '(unsigned long)'

__near  DName::DName ( int num )
{
	char	buf[ 12 ];
	char *	pBuf	= buf + 11;

	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ltoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	bool	fSigned = false;
	if (num < 0) {
		fSigned = true;
		num = -num;
	}

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	if (fSigned) {
		*(--pBuf) = '-';
	}

	doPchar ( pBuf, ( 11 - (int) ( pBuf - buf )));
}


__near	DName::DName ( DNameStatus st )
{
	stat	= ((( st == DN_invalid ) || ( st == DN_error )) ? st : DN_valid );
	node	= gnew DNameStatusNode ( st );
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( !node )
		stat	= DN_error;

}	// End of "DName" CONSTRUCTOR '(DNameStatus)'



//	Now the member functions for 'DName'

int		__near	DName::isValid () const		{	return	(( status () == DN_valid ) || ( status () == DN_truncated ));	}
int		__near	DName::isEmpty () const		{	return	(( node == 0 ) || !isValid ());	}

inline	DNameStatus	__near	DName::status () const	{	return	(DNameStatus)stat;	}	// The cast is to keep Glockenspiel quiet
inline	void	__near	DName::clearStatus () { stat = DN_valid; }

inline	DName &	__near	DName::setPtrRef ()			{	isIndir	= 1;	return	*this;	}
inline	int		__near	DName::isPtrRef () const	{	return	isIndir;	}
inline	int		__near	DName::isUDC () const		{	return	( !isEmpty () && isAUDC );	}
inline	void	__near	DName::setIsUDC ()			{	if	( !isEmpty ())	isAUDC	= TRUE;	}
inline	int		__near	DName::isUDTThunk () const		{	return	( !isEmpty () && isAUDTThunk );	}
inline	void	__near	DName::setIsUDTThunk ()			{	if	( !isEmpty ())	isAUDTThunk	= TRUE;	}
inline	void	__near	DName::setIsArray ()		{	isArrayType	= 1;	}
inline	int		__near	DName::isArray () const		{	return	isArrayType;	}
inline	int				DName::isNoTE () const		{	return NoTE;	}
inline	void			DName::setIsNoTE ()			{	NoTE = TRUE;	}

int	__near	DName::length () const
{
	int	len	= 0;


	if	( !isEmpty ())
		for	( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			len	+= pNode->length ();

	return	len;

}	// End of "DName" FUNCTION "length"


char	__near	DName::getLastChar () const
{
	DNameNode * pLast = 0;

	if ( !isEmpty ())
		for ( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			if ( pNode->length () != 0 )
				pLast = pNode;

	return	pLast != 0 ? pLast->getLastChar () : '\0';

}	// End of "DName" FUNCTION "getLastChar"


pchar_t	__near	DName::getString ( pchar_t buf, int max ) const
{
	if		( !isEmpty ())
	{
		//	Does the caller want a buffer allocated ?

		if	( !buf )
		{
			max	= length () + 1;
			buf	= gnew char[ max ];	// Get a buffer big enough

		}	// End of IF then

		//	If memory allocation failure, then return no buffer

		if	( buf )
		{
			//	Now, go through the process of filling the buffer (until max is reached)

			int			curLen	= max;
			DNameNode *	curNode	= node;
			pchar_t		curBuf	= buf;


			while	( curNode && ( curLen > 0 ))
			{
				int		fragLen	= curNode->length ();
				pchar_t	fragBuf	= 0;


				//	Skip empty nodes

				if	( fragLen )
				{
					//	Handle buffer overflow

					if	(( curLen - fragLen ) < 0 )
						fragLen	= curLen;

					//	Now copy 'len' number of bytes of the piece to the buffer

					fragBuf	= curNode->getString ( curBuf, fragLen );

					//	Should never happen, but handle it anyway

					if	( fragBuf )
					{
						//	Update string position

						curLen	-= fragLen;
						curBuf	+= fragLen;

					}	// End of IF
				}	// End of IF

				//	Move on to the next name fragment

				curNode	= curNode->nextNode ();

			}	// End of WHILE

			*curBuf	= 0;	// Always NULL terminate the resulting string

		}	// End of IF
	}	// End of IF then
	elif	( buf )
		*buf	= 0;

	//	Return the buffer

	return	buf;

}	// End of "DName" FUNCTION "getString(pchar_t,int)"


DName	__near	DName::operator + ( char ch ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= ch;
	else
		local	+= ch;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(char)"


DName	__near	DName::operator + ( pcchar_t str ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= str;
	else
		local	+= str;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(pcchar_t)"


DName	__near	DName::operator + ( const DName & rd ) const
{
	DName	local ( *this );


	if		( local.isEmpty ())
		local	= rd;
	elif	( rd.isEmpty ())
		local	+= rd.status ();
	else
		local	+= rd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(const DName&)"


DName	__near	DName::operator + ( DName * pd ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= pd;
	else
		local	+= pd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DName*)"


DName	__near	DName::operator + ( DNameStatus st ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= st;
	else
		local	+= st;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DNameStatus)"



DName &	__near	DName::operator += ( char ch )
{
	if	( ch )
		if	( isEmpty ())
			*this	= ch;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew charNode ( ch );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(char)"


DName &	__near	DName::operator += ( pcchar_t str )
{
	if	( str && *str )
		if	( isEmpty ())
			*this	= str;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew pcharNode ( str );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(pcchar_t)"


DName &	__near	DName::operator += ( const DName & rd )
{
	if	( rd.isEmpty ())
		*this	+= rd.status ();
	else
		if	( isEmpty ())
			*this	= rd;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= rd.node;
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(const DName&)"


DName &	__near	DName::operator += ( DName * pd )
{
	if	( pd )
		if		( isEmpty ())
			*this	= pd;
		elif	(( pd->status () == DN_valid ) || ( pd->status () == DN_truncated ))
		{
			DNameNode *	pNew	= gnew pDNameNode ( pd );


			if	( pNew )
			{
				node	= node->clone ();

				if	( node )
					*node	+= pNew;

			}	// End of IF then
			else
				node	= 0;

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	+= pd->status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DName*)"


DName &	__near	DName::operator += ( DNameStatus st )
{
	if	( isEmpty () || (( st == DN_invalid ) || ( st == DN_error )))
		*this	= st;
	else
	{
		DNameNode *	pNew	= gnew DNameStatusNode ( st );


		if	( pNew )
		{
			node	= node->clone ();

			if	( node )
				*node	+= pNew;

		}	// End of IF then
		else
			node	= 0;

		if	( !node )
			stat	= DN_error;

	}	// End of IF else

	//	Return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DNameStatus)"



DName &	__near	DName::operator |= ( const DName & rd )
{
	//	Attenuate the error status.  Always becomes worse.  Don't propogate truncation

	if	(( status () != DN_error ) && !rd.isValid ())
		stat	= rd.status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '|=(const DName&)'



DName &	__near	DName::operator = ( char ch )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( &ch, 1 );

	return	*this;

}	// End of "DName" OPERATOR '=(char)'


DName &	__near	DName::operator = ( pcchar_t str )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( str, und_strlen ( str ));

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(pcchar_t)'


DName &	__near	DName::operator = ( const DName & rd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		stat	= rd.stat;
		isIndir	= rd.isIndir;
		isAUDC	= rd.isAUDC;
		isAUDTThunk = rd.isAUDTThunk;
		isArrayType	= rd.isArrayType;
		node	= rd.node;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(const DName&)'


DName &	__near	DName::operator = ( DName * pd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
		if	( pd )
		{
			isIndir	= 0;
			isAUDC	= 0;
			isAUDTThunk = 0;
			isArrayType	= 0;
			node	= gnew pDNameNode ( pd );

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	= DN_error;

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DName*)'


DName &	__near	DName::operator = ( DNameStatus st )
{
	if	(( st == DN_invalid ) || ( st == DN_error ))
	{
		node	= 0;

		if	( status () != DN_error )
			stat	= st;

	}	// End of IF then
	elif	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		isIndir	= 0;
		isAUDC	= 0;
		isAUDTThunk = 0;
		isArrayType	= 0;
		node	= gnew DNameStatusNode ( st );

		if	( !node )
			stat	= DN_error;

	}	// End of ELIF then

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DNameStatus)'


//	Private implementation functions for 'DName'

void	__near	DName::doPchar ( pcchar_t str, int len )
{
	if	( !(( status () == DN_invalid ) || ( status () == DN_error )))
		if		( node )
			*this	= DN_error;
		elif	( str && len )
		{
			//	Allocate as economically as possible

			switch	( len )
			{
			case 0:
					stat	= DN_error;
				break;

			case 1:
					node	= gnew charNode ( *str );

					if	( !node )
						stat	= DN_error;
				break;

			default:
					node	= gnew pcharNode ( str, len );

					if	( !node )
						stat	= DN_error;
				break;

			}	// End of SWITCH
		}	// End of ELIF
		else
			stat	= DN_invalid;

}	// End of "DName" FUNCTION "doPchar(pcchar_t,int)"



//	The member functions for the 'Replicator'

inline	int	__near	Replicator::isFull () const		{	return	( index == 9 );	}
inline	__near		Replicator::Replicator ()
:	ErrorDName ( DN_error ), InvalidDName ( DN_invalid )
{	index	= -1;	}



Replicator &	__near	Replicator::operator += ( const DName & rd )
{
	if	( !isFull () && !rd.isEmpty ())
	{
		DName *	pNew	= gnew DName ( rd );


		//	Don't update if failed

		if	( pNew )
			dNameBuffer[ ++index ]	= pNew;

	}	// End of IF

	return	*this;

}	// End of "Replicator" OPERATOR '+=(const DName&)'


const DName &	__near	Replicator::operator [] ( int x ) const
{
	if		(( x < 0 ) || ( x > 9 ))
		return	ErrorDName;
	elif	(( index == -1 ) || ( x > index ))
		return	InvalidDName;
	else
		return	*dNameBuffer[ x ];

}	// End of "Replicator" OPERATOR '[](int)'



//	The member functions for the 'DNameNode' classes

#if	( !NO_VIRTUAL )
__near	DNameNode::DNameNode ()
#else	// } elif NO_VIRTUAL {
__near	DNameNode::DNameNode ( NodeType ndTy )
:	typeIndex ( ndTy )
#endif	// NO_VIRTUAL
{	next	= 0;	}

inline	__near	DNameNode::DNameNode ( const DNameNode & rd )	{	next	= (( rd.next ) ? rd.next->clone () : 0 );	}

inline	DNameNode *	__near	DNameNode::nextNode () const		{	return	next;	}

DNameNode *	__near	DNameNode::clone ()
{
	return	gnew pDNameNode ( gnew DName ( this ));
}

#if	( NO_VIRTUAL )
int	__near	DNameNode::length () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->length ();

	case pcharNode_t:
		return	((pcharNode*)this )->length ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->length ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->length ();

	}	// End of SWITCH

	return	0;
}


char	__near	DNameNode::getLastChar () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getLastChar ();

	case pcharNode_t:
		return	((pcharNode*)this )->getLastChar ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->getLastChar ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getLastChar ();

	}	// End of SWITCH

	return	0;
}


pchar_t	__near	DNameNode::getString ( pchar_t s, int l ) const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getString ( s, l );

	case pcharNode_t:
		return	((pcharNode*)this )->getString ( s, l );

	case pDNameNode_t:
		return	((pDNameNode*)this )->getString ( s, l );

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getString ( s, l );

	}	// End of SWITCH

	return	0;
}
#endif	// NO_VIRTUAL


DNameNode &	__near	DNameNode::operator += ( DNameNode * pNode )
{
	if	( pNode )
	{
		if	( next )
		{
			//	Skip to the end of the chain

			DNameNode* pScan;
			for	( pScan = next; pScan->next; pScan = pScan->next )
				;

			//	And append the new node

			pScan->next	= pNode;

		}	// End of IF then
		else
			next	= pNode;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DNameNode" OPERATOR '+=(DNameNode*)'



//	The 'charNode' virtual functions

__near	charNode::charNode ( char ch )
#if	( NO_VIRTUAL )
:	DNameNode ( charNode_t )
#endif	// NO_VIRTUAL
{	me	= ch;	}

inline	int	__near	charNode::length () const		{	return	1;	}

inline	char __near	charNode::getLastChar () const	{	return	me;	}

pchar_t	__near	charNode::getString ( pchar_t buf, int len ) const
{
	if	( buf && len )
		*buf	= me;
	else
		buf		= 0;

	//	Now return the character

	return	buf;

}	// End of "charNode" FUNCTION "getString(pchar_t,int)"



//	The 'pcharNode' virtual functions

inline	int	__near	pcharNode::length () const		{	return	myLen;	}

inline	char __near	pcharNode::getLastChar () const	{	return	( myLen ? me[ myLen - 1 ] : '\0' );	}

__near	pcharNode::pcharNode ( pcchar_t str, int len )
#if ( NO_VIRTUAL )
:	DNameNode ( pcharNode_t )
#endif	// NO_VIRTUAL
{
	//	Get length if not supplied

	if	( !len && str )
		len	= und_strlen ( str );

	//	Allocate a new string buffer if valid state

	if	( len && str )
	{
		me		= gnew char[ len ];
		myLen	= len;

		if	( me )
			und_strncpy ( me, str, len );

	}	// End of IF then
	else
	{
		me		= 0;
		myLen	= 0;

	}	// End of IF else
}	// End of "pcharNode" CONSTRUCTOR '(pcchar_t,int)'


pchar_t	__near	pcharNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > pcharNode::length ())
		len	= pcharNode::length ();

	//	Do the copy as appropriate

	return	(( me && buf && len ) ? und_strncpy ( buf, me, len ) : 0 );

}	// End of "pcharNode" FUNCTION "getString(pchar_t,int)"



//	The 'pDNameNode' virtual functions

__near	pDNameNode::pDNameNode ( DName * pName )
#if	( NO_VIRTUAL )
:	DNameNode ( pDNameNode_t )
#endif	// NO_VIRTUAL
{	me	= (( pName && (( pName->status () == DN_invalid ) || ( pName->status () == DN_error ))) ? 0 : pName );	}

inline	int	__near	pDNameNode::length () const					{	return	( me ? me->length () : 0 );	}

inline	char __near	pDNameNode::getLastChar () const			{	return	( me ? me->getLastChar () : '\0' ); }

pchar_t	__near	pDNameNode::getString ( pchar_t buf, int len ) const
{	return	(( me && buf && len ) ? me->getString ( buf, len ) : 0 );	}



//	The 'DNameStatusNode' virtual functions

__near	DNameStatusNode::DNameStatusNode ( DNameStatus stat )
#if	( NO_VIRTUAL )
:	DNameNode ( DNameStatusNode_t )
#endif	// NO_VIRTUAL
{	me	= stat;	myLen	= (( me == DN_truncated ) ? TruncationMessageLength : 0 );	}

inline	int	__near	DNameStatusNode::length () const	{	return	myLen;	}

inline	char __near	DNameStatusNode::getLastChar () const
{	return (( me == DN_truncated ) ? TruncationMessage[ TruncationMessageLength - 1 ] : '\0' );	}

pchar_t	__near	DNameStatusNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > DNameStatusNode::length ())
		len	= DNameStatusNode::length ();

	//	Do the copy as appropriate

	return	((( me == DN_truncated ) && buf && len ) ? und_strncpy ( buf, TruncationMessage, len ) : 0 );

}	// End of "DNameStatusNode" FUNCTION "getString(pchar_t,int)"


static	unsigned int	__near __pascal	und_strlen ( pcchar_t str )
{
	unsigned int len;

	for	( len = 0; *str; str++ )
		len++;

	return	len;

}	// End of FUNCTION "und_strlen"


static	pchar_t			__near __pascal	und_strncpy ( pchar_t dst, pcchar_t src, unsigned int len )
{
	for	( char __far * d = dst; ( len && ( *d = *src )); d++, src++, len-- )
		;

	return	dst;

}	// End of FUNCTION "und_strncpy"

static	unsigned int	__near __pascal	und_strncmp ( pcchar_t first, pcchar_t last, unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return( *(unsigned char *)first - *(unsigned char *)last );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\iso646.h ===
/* iso646.h standard header */
#ifndef _ISO646
#define _ISO646
#define and		&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not		!
#define not_eq	!=
#define or		||
#define or_eq	|=
#define xor		^
#define xor_eq	^=
#endif /* _ISO646 */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


#if defined(_M_IA64)
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );
#else
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );
#endif // defined(_M_IA64)

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         //XMMI
    _FpCodeFmax,         //XMMI
    _FpCodeConvertTrunc, //XMMI
    _XMMIAddps,          //XMMI
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         //XMMI2 
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   //66 2D
    _XMMI2Cvtsd2si,   //F2
    _XMMI2Cvttpd2pi,  //66 2C
    _XMMI2Cvttsd2si,  //F2
    _XMMI2Cvtps2pd,   //0F 5A
    _XMMI2Cvtss2sd,   //F3
    _XMMI2Cvtpd2ps,   //66
    _XMMI2Cvtsd2ss,   //F2
    _XMMI2Cvtdq2ps,   //0F 5B
    _XMMI2Cvttps2dq,  //F3
    _XMMI2Cvtps2dq,   //66
    _XMMI2Cvttpd2dq,  //66 0F E6
    _XMMI2Cvtpd2dq,   //F2 
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP void *  __cdecl calloc(size_t, size_t);
_CRTIMP void    __cdecl free(void *);
_CRTIMP void *  __cdecl malloc(size_t);
_CRTIMP void *  __cdecl realloc(void *, size_t);
_CRTIMP void    __cdecl _aligned_free(void *);
_CRTIMP void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);
_CRTIMP int     __cdecl _resetstkoflw (void);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#if     defined(_M_MRX000) || defined(_M_PPC) || defined(_M_ALPHA)
#pragma intrinsic(_alloca)
#endif

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
#if     defined(_M_MRX000)
_CRTIMP int     __cdecl abs(int);
_CRTIMP double  __cdecl acos(double);
_CRTIMP double  __cdecl asin(double);
_CRTIMP double  __cdecl atan(double);
_CRTIMP double  __cdecl atan2(double, double);
_CRTIMP double  __cdecl cos(double);
_CRTIMP double  __cdecl cosh(double);
_CRTIMP double  __cdecl exp(double);
_CRTIMP double  __cdecl fabs(double);
_CRTIMP double  __cdecl fmod(double, double);
_CRTIMP long    __cdecl labs(long);
_CRTIMP double  __cdecl log(double);
_CRTIMP double  __cdecl log10(double);
_CRTIMP double  __cdecl pow(double, double);
_CRTIMP double  __cdecl sin(double);
_CRTIMP double  __cdecl sinh(double);
_CRTIMP double  __cdecl tan(double);
_CRTIMP double  __cdecl tanh(double);
_CRTIMP double  __cdecl sqrt(double);
#else
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
#endif
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
#if     defined(_M_ALPHA)
        double  __cdecl ceil(double);
        double  __cdecl floor(double);
#else
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
#endif
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if     defined(_M_MRX000)

/* MIPS fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( float );
_CRTIMP float  __cdecl asinf( float );
_CRTIMP float  __cdecl atanf( float );
_CRTIMP float  __cdecl atan2f( float , float );
_CRTIMP float  __cdecl cosf( float );
_CRTIMP float  __cdecl sinf( float );
_CRTIMP float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( float );
_CRTIMP float  __cdecl sinhf( float );
_CRTIMP float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( float );
_CRTIMP float  __cdecl logf( float );
_CRTIMP float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
_CRTIMP float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl hypotf(float, float);

#endif  /* _M_MRX000 */

#if     defined(_M_ALPHA)

/* ALPHA fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl _hypotf(float, float);

#endif  /* _M_ALPHA */

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
#ifdef  _M_MRX000
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
#else
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif



#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(new_handler);
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ostream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
        ostream(streambuf*);
        virtual ~ostream();

        ostream& flush();
        int  opfx();
        void osfx();

inline  ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline  ostream& operator<<(ios& (__cdecl * _f)(ios&));
        ostream& operator<<(const char *);
inline  ostream& operator<<(const unsigned char *);
inline  ostream& operator<<(const signed char *);
inline  ostream& operator<<(char);
        ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
        ostream& operator<<(short);
        ostream& operator<<(unsigned short);
        ostream& operator<<(int);
        ostream& operator<<(unsigned int);
        ostream& operator<<(long);
        ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
        ostream& operator<<(double);
        ostream& operator<<(long double);
        ostream& operator<<(const void *);
        ostream& operator<<(streambuf*);
inline  ostream& put(char);
        ostream& put(unsigned char);
inline  ostream& put(signed char);
        ostream& write(const char *,int);
inline  ostream& write(const unsigned char *,int);
inline  ostream& write(const signed char *,int);
        ostream& seekp(streampos);
        ostream& seekp(streamoff,ios::seek_dir);
        streampos tellp();

protected:
        ostream();
        ostream(const ostream&);        // treat as private
        ostream& operator=(streambuf*); // treat as private
        ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
        int do_opfx(int);               // not used
        void do_osfx();                 // not used

private:
        ostream(ios&);
        ostream& writepad(const char *, const char *);
        int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline  ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline  ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline  ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline  ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline  ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline  ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline  ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline  ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline  ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
        public:
                ostream_withassign();
                ostream_withassign(streambuf* _is);
                ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&           __cdecl dec(ios&);
_CRTIMP ios&           __cdecl hex(ios&);
_CRTIMP ios&           __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_OSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;



#elif   defined(_M_MRX000)

#ifndef _INC_SETJMPEX
#if     _MSC_VER >= 1100
#define _setjmp  _setjmpVfp
#endif
#define setjmp  _setjmp
#endif

/*
 * All MIPS implementations need _JBLEN of 16
 */

#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif   defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef  _MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp  _setjmpex /* Alpha should always use setjmp as _setjmpex */
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/*
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
#ifdef _M_ALPHA64
#define _JBFILL 3
    unsigned __int64 Fp;
    unsigned __int64 Pc;
    unsigned __int64 Seb;
    unsigned long Type;
    unsigned long Type_Fill;
#else
#define _JBFILL 5
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
#endif
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[_JBFILL];
} _JUMP_BUFFER;
#undef _JBFILL

#elif   defined(_M_PPC)
/*
 * The Microsoft VC++ V4.0 compiler uses an intrinsic _setjmp.
 * The Motorola C8.5 compiler implements setjmp as a function.
 */

#if     _MSC_VER > 850
#ifndef _INC_SETJMPEX
#undef _setjmp
#define setjmp  _setjmp
#endif
#endif

/*
 * Min length is 240 bytes; round to 256 bytes.
 * Since this is allocated as an array of "double", the
 * number of entries required is 32.
 *
 * All PPC implementations need _JBLEN of 32
 */

#define _JBLEN  32
#define _JBTYPE double

/*
 * Define jump buffer layout for PowerPC setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    unsigned long Gpr1;
    unsigned long Gpr2;
    unsigned long Gpr13;
    unsigned long Gpr14;
    unsigned long Gpr15;
    unsigned long Gpr16;
    unsigned long Gpr17;
    unsigned long Gpr18;
    unsigned long Gpr19;
    unsigned long Gpr20;
    unsigned long Gpr21;
    unsigned long Gpr22;
    unsigned long Gpr23;
    unsigned long Gpr24;
    unsigned long Gpr25;
    unsigned long Gpr26;
    unsigned long Gpr27;
    unsigned long Gpr28;
    unsigned long Gpr29;
    unsigned long Gpr30;
    unsigned long Gpr31;
    unsigned long Cr;
    unsigned long Iar;
    unsigned long Type;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

// Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name.
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;

#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    unsigned long iAReserved[6];

    //
    // x86 C9.0 compatibility
    //

    unsigned long Registration;  // point to the UnwindData field.
    unsigned long TryLevel;      // ignored by setjmp
    unsigned long Cookie;        // set to "VC20" by setjmp
    unsigned long UnwindFunc;    // set to EM longjmp() by setjmp

    //
    // First dword is zero to indicate it's an exception registration
    // record prepared by EM setjmp function.
    // Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
    // EM setjmp.
    // Third dword is set to the setjmp site memory stack frame pointer.
    // Fourth dword is set to the setjmp site backing store frame pointer.
    //

    unsigned long UnwindData[6];

    //
    // floating point status register,
    // and preserved floating point registers fs0 - fs19
    //

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    //
    // return link and preserved branch registers bs0 - bs4
    //

    __int64 StIIP;     // continuation address
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    //
    // preserved general registers s0 - s3, sp, nats
    //

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    //
    // bsp, pfs, unat, lc
    //

    __int64 RsBSP;
    __int64 RsPFS;     // previous frame marker (cfm of setjmp's caller)
    __int64 ApUNAT;    // User Nat collection register (preserved)
    __int64 ApLC;      // loop counter

    __int64 IntSp;     // memory stack pointer
    __int64 IntNats;   // Nat bits of preserved integer regs s0 - s3
    __int64 Preds;     // predicates

} _JUMP_BUFFER;

#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    // General User API

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    // User API
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    // Power User/library API


    /* Init functions */

    // These functions all call _CRT_RTC_INIT
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    // If you're not using the CRT, you have to implement _CRT_RTC_INIT
    // Just return either null, or your error reporting function
    // *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    // Compiler generated calls (unlikely to be used, even by power users...)
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif // _INC_RTCAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#elif   defined(_M_MRX000)

#if     _MSC_VER >= 1100
#define _setjmpex _setjmpexVfp
#endif

#define setjmp _setjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stl.h ===
// stl.h supplemental header
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>
using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque : public deque<_Ty, allocator<_Ty> > {
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Deque()
		: deque<_Ty, _A>() {}
	explicit Deque(size_type _N, const _Ty& _V = _Ty())
		: deque<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Deque(_It _F, _It _L)
		: deque<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{deque<_Ty, _A>::swap((deque<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List : public list<_Ty, allocator<_Ty> > {
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit List()
		: list<_Ty, _A>() {}
	explicit List(size_type _N, const _Ty& _V = _Ty())
		: list<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	List(_It _F, _It _L)
		: list<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{list<_Ty, _A>::swap((list<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Map
template<class _K, class _Ty, class _Pr = less<_K> >
	class Map : public map<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Map<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Map(const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Map(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{map<_K, _Ty, _Pr, _A>::
			swap((map<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multimap
template<class _K, class _Ty, class _Pr = less<_K> >
	class Multimap
		: public multimap<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Multimap<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Multimap(const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multimap(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multimap<_K, _Ty, _Pr, _A>::
			swap((multimap<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Set
template<class _K, class _Pr = less<_K> >
	class Set : public set<_K, _Pr, allocator<_K> > {
public:
	typedef Set<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Set(const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Set(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{set<_K, _Pr, _A>::swap((set<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multiset
template<class _K, class _Pr = less<_K> >
	class Multiset : public multiset<_K, _Pr, allocator<_K> > {
public:
	typedef Multiset<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Multiset(const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multiset(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multiset<_K, _Pr, _A>::
			swap((multiset<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector : public vector<_Ty, allocator<_Ty> > {
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Vector()
		: vector<_Ty, _A>(_Al) {}
	explicit Vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Vector(_It _F, _It _L)
		: vector<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Ty, _A>::swap((vector<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// CLASS bit_vector
class bit_vector : public vector<_Bool, _Bool_allocator> {
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _A;
	typedef bit_vector _Myt;
	explicit bit_vector()
		: vector<_Bool, _Bool_allocator>() {}
	explicit bit_vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Bool, _Bool_allocator>(_N, _V) {}
	typedef const_iterator _It;
	bit_vector(_It _F, _It _L)
		: vector<_Bool, _Bool_allocator>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Bool, _Bool_allocator>::
			swap((vector<_Bool, _Bool_allocator>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS priority_queue
template<class _C = vector<_Ty>,
	class _Pr = less<_C::value_type> >
	class Priority_queue
		: public priority_queue<_C::value_type, _C, _Pr,
			allocator<_C::value_type> > {
public:
	typedef _C::value_type _Ty;
	typedef allocator<_C::value_type> _A;
	explicit Priority_queue(const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_X) {}
	typedef const value_type *_It;
	Priority_queue(_It _F, _It _L, const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_F, _L, _X) {}
	};

		// TEMPLATE CLASS queue
template<class _C = deque<_Ty> >
	class Queue
		: public queue<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// TEMPLATE CLASS stack
template<class _C = deque<_Ty> >
	class Stack
		: public stack<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif	/* _STL_H_ */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the stdiostream and stdiobuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>
#include <stdio.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
        stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
        ~stdiobuf();
        int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
        FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {  // note: spec.'d as : public IOS...
public:
        stdiostream(FILE *);
        ~stdiostream();
        stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
        
private:
};

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STDIOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif   defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)_ADDRESSOF(v) + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef  _CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )

#elif   defined(_M_PPC)

/* Microsoft C8 front end (used in Motorola Merged compiler) */
/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
				     _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\strstrea.h ===
/***
*strstrea.h - definitions/declarations for strstreambuf, strstream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the strstream and strstreambuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER

// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <useoldio.h>
#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
                strstreambuf();
                strstreambuf(int);
                strstreambuf(char *, int, char * = 0);
                strstreambuf(unsigned char *, int, unsigned char * = 0);
                strstreambuf(signed char *, int, signed char * = 0);
                strstreambuf(void * (*a)(long), void (*f) (void *));
                ~strstreambuf();

        void    freeze(int =1);
        char * str();

virtual int     overflow(int);
virtual int     underflow();
virtual streambuf* setbuf(char *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int     sync();         // not in spec.

protected:
virtual int     doallocate();
private:
        int     x_dynamic;
        int     x_bufmin;
        int     _fAlloc;
        int     x_static;
        void * (* x_alloc)(long);
        void    (* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
                istrstream(char *);
                istrstream(char *, int);
                ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
                ostrstream();
                ostrstream(char *, int, int = ios::out);
                ~ostrstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char *  str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {    // strstreambase ???
public:
                strstream();
                strstream(char *, int, int);
                ~strstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the streambuf class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>        // need ios::seek_dir definition

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;        // pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef  _MT
    void setlock() { LockFlg--; }       // <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef  _MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef  _MT
    int LockFlg;                // <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;        // lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (int)(_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (int)(_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (int)(_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STREAMB

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


#if     defined(_DLL) && defined(_M_IX86)

#define __argc      (*__p___argc())     /* count of cmd line args */
#define __argv      (*__p___argv())     /* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())    /* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())   /* pointer to environment table */
#ifdef  _POSIX_
extern char ** environ;                 /* pointer to environment table */
#else
#define _wenviron   (*__p__wenviron())  /* pointer to wide environment table */
#endif  /* _POSIX_ */
#define _pgmptr     (*__p__pgmptr())    /* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())   /* points to the module (EXE) wide name */

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);


#else

_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

#endif


_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

#if     defined(_M_MRX000)
_CRTIMP int    __cdecl abs(int);
#else
        int    __cdecl abs(int);
#endif
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
#if     defined(_M_MRX000)
_CRTIMP long __cdecl labs(long);
#else
        long __cdecl labs(long);
#endif
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#ifdef _DLL
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

#ifdef  _M_MRX000
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
_CRTIMP char *  __cdecl _strset(char *, int);
_CRTIMP char *  __cdecl strcpy(char *, const char *);
_CRTIMP char *  __cdecl strcat(char *, const char *);
_CRTIMP int     __cdecl strcmp(const char *, const char *);
_CRTIMP size_t  __cdecl strlen(const char *);
#else
        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#endif
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#if     defined(_M_IA64) || defined(_M_ALPHA)
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/

#ifndef _MAC

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP wctrans_t __cdecl wctrans(const char *);
_CRTIMP wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */

#endif  /* ndef _MAC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   // stdin
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       // stdout
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP wint_t __cdecl btowc(int);
_CRTIMP size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64) || defined(_M_ALPHA)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\useoldio.h ===
/***
*useoldio.h - force the use of the Microsoft "classic" iostream libraries.
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Generates default library directives for the old ("classic") IOSTREAM
*       libraries.  The exact name of the library specified in the directive
*       depends on the compiler switches (-ML, -MT, -MD, -MLd, -MTd, and -MDd).
*
*       This header file is only included by other header files.
*
*       [Public]
*
****/

#ifndef _USE_OLD_IOSTREAMS
#define _USE_OLD_IOSTREAMS
#ifndef _M_IA64
/*
 * Warning C4995, '_OLD_IOSTREAMS_ARE_DEPRECATED' is a deprecated name, is 
 * being issued because the old I/O Streams headers iostreams.h et al will no
 * longer be supported from VC8.  Replace references such as #include 
 * <iostreams.h> with #include <iostreams>, using the new, more conformant, I/O
 * Streams headers.
 */

#pragma deprecated(_OLD_IOSTREAMS_ARE_DEPRECATED)
extern void _OLD_IOSTREAMS_ARE_DEPRECATED();
#endif  /* _M_IA64 */
#ifdef  _MT
#ifdef  _DLL
#ifdef  _DEBUG
#pragma comment(lib,"msvcirtd")
#else   /* _DEBUG */
#pragma comment(lib,"msvcirt")
#endif  /* _DEBUG */

#else   /* _DLL */
#ifdef  _DEBUG
#pragma comment(lib,"libcimtd")
#else   /* _DEBUG */
#pragma comment(lib,"libcimt")
#endif  /* _DEBUG */
#endif  /* _DLL */

#else   /* _MT */
#ifdef  _DEBUG
#pragma comment(lib,"libcid")
#else   /* _DEBUG */
#pragma comment(lib,"libci")
#endif  /* _DEBUG */
#endif

#endif  /* _USE_OLD_IOSTREAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <wctype.h>
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN
		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1
 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4
		/* IEEE 754 double properties */
#define _DFRAC	((1 << _DOFF) - 1)
#define _DMASK	(0x7fff & ~_DFRAC)
#define _DMAX	((1 << (15 - _DOFF)) - 1)
#define _DSIGN	0x8000
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define SAFE_EXP	(_DMAX >> 1)
		/* IEEE 754 float properties */
#define _FFRAC	((1 << _FOFF) - 1)
#define _FMASK	(0x7fff & ~_FFRAC)
#define _FMAX	((1 << (15 - _FOFF)) - 1)
#define _FSIGN	0x8000
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define FSAFE_EXP	(_FMAX >> 1)
 #define _F0	1	/* little-endian order */
 #define _F1	0
		/* IEEE 754 long double properties */
#define _LFRAC	(-1)
#define _LMASK	0x7fff
#define _LMAX	0x7fff
#define _LSIGN	0x8000
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define LSAFE_EXP	(_LMAX >> 1)
 #define _L0	4	/* little-endian order */
 #define _L1	3
 #define _L2	2
 #define _L3	1
 #define _L4	0
		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE
_C_LIB_DECL
		/* double declarations */
_CRTIMP double _Atan(double, unsigned short);
_CRTIMP short _Dint(double *, short);
_CRTIMP short _Dnorm(unsigned short *);
_CRTIMP short _Dscale(double *, long);
_CRTIMP double _Dtento(double, long);
_CRTIMP short _Dunscale(short *, double *);
_CRTIMP double _Poly(double, const double *, int);
extern _CRTIMP const _Dconst _Eps, _Rteps;
extern _CRTIMP const double _Xbig;
		/* float declarations */
_CRTIMP float _FAtan(float, unsigned short);
_CRTIMP short _FDint(float *, short);
_CRTIMP short _FDnorm(unsigned short *);
_CRTIMP short _FDscale(float *, long);
_CRTIMP float _FDtento(float, long);
_CRTIMP short _FDunscale(short *, float *);
_CRTIMP float _FPoly(float, const float *, int);
extern _CRTIMP const _Dconst _FEps, _FRteps;
extern _CRTIMP const float _FXbig;
		/* long double functions */
_CRTIMP long double _LAtan(long double, unsigned short);
_CRTIMP short _LDint(long double *, short);
_CRTIMP short _LDnorm(unsigned short *);
_CRTIMP short _LDscale(long double *, long);
_CRTIMP long double _LDtento(long double, long);
_CRTIMP short _LDunscale(short *, long double *);
_CRTIMP long double _LPoly(long double, const long double *, int);
extern _CRTIMP const _Dconst _LEps, _LRteps;
extern _CRTIMP const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
#include <yvals.h>
#endif


		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _LC_ALL			LC_ALL
#define _LC_COLLATE		LC_COLLATE
#define _LC_CTYPE		LC_CTYPE
#define _LC_MONETARY	LC_MONETARY
#define _LC_NUMERIC		LC_NUMERIC
#define _LC_TIME 		LC_TIME
#define _LC_MAX			LC_MAX 
#define _LC_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_LC_COLLATE)
#define _M_CTYPE	_CATMASK(_LC_CTYPE)
#define _M_MONETARY	_CATMASK(_LC_MONETARY)
#define _M_NUMERIC	_CATMASK(_LC_NUMERIC)
#define _M_TIME		_CATMASK(_LC_TIME)
#define _M_MESSAGE	_CATMASK(_LC_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP _Collvec __cdecl _Getcoll();
_CRTIMP _Ctypevec __cdecl _Getctype();
_CRTIMP _Cvtvec __cdecl _Getcvt();
char *__cdecl _Getdays();
char *__cdecl _Getmonths();
void *__cdecl _Gettnames();
_CRTIMP int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
extern float __cdecl _Stof(const char *, char **, long);
extern double __cdecl _Stod(const char *, char **, long);
extern long double __cdecl _Stold(const char *, char **, long);
_CRTIMP int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

#ifdef  _M_ALPHA
typedef struct {
    char *a0;           /* pointer to first homed integer argument */
    int offset;         /* byte offset of next parameter */
} va_list;
#else
typedef char *va_list;
#endif

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#elif   defined(_M_MRX000)      /* _MIPS_ */


#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]
/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */
extern void * __builtin_va_start(va_list, ...);

#define va_dcl long va_alist;
#define va_start(list) __builtin_va_start(list, va_alist, 0)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#elif   defined(_M_PPC)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (PPC architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
/* this is for LITTLE-ENDIAN PowerPC */

/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\ymath.h ===
/* ymath.h internal header */
#ifndef _YMATH
#define _YMATH
#include <wctype.h>
#include <math.h>
#ifndef _YVALS
#include <yvals.h>
#endif
		/* MACROS */
#define _FINITE		-1
#define _INFCODE	1
#define _NANCODE	2
		/* TYPE DEFINITIONS */
typedef union {
	unsigned short _W[5];
	float _F;
	double _D;
	long double _L;
	} _Dconst;
_C_LIB_DECL
		/* double DECLARATIONS */
_CRTIMP double __cdecl _Cosh(double, double);
_CRTIMP short __cdecl _Dtest(double *);
_CRTIMP short __cdecl _Exp(double *, double, short);
_CRTIMP double __cdecl _Sinh(double, double);
extern _CRTIMP const _Dconst _Denorm, _Hugeval, _Inf, _Nan, _Snan;
		/* float DECLARATIONS */
_CRTIMP float __cdecl _FCosh(float, float);
_CRTIMP short __cdecl _FDtest(float *);
_CRTIMP short __cdecl _FExp(float *, float, short);
_CRTIMP float __cdecl _FSinh(float, float);
extern _CRTIMP const _Dconst _FDenorm, _FInf, _FNan, _FSnan;
		/* long double DECLARATIONS */
_CRTIMP long double __cdecl _LCosh(long double, long double);
_CRTIMP short __cdecl _LDtest(long double *);
_CRTIMP short __cdecl _LExp(long double *, long double, short);
_CRTIMP long double __cdecl _LSinh(long double, long double);
extern _CRTIMP const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
#endif /* _YMATH */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS
#include <use_ansi.h>

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _CRTIMP */

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

 #pragma warning(4: 4018 4114 4146 4244 4245)
 #pragma warning(4: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		};
  #define _STD_USING
 #else
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END
 #endif /* __cplusplus */
_STD_BEGIN
		/* TYPE bool */
 #if defined(__cplusplus)
typedef bool _Bool;
 #endif /* __cplusplus */
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif /* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
#define _CDECL
		// CLASS _Lockit
 #if defined(__cplusplus)
class _CRTIMP _Lockit
	{	// lock while object in existence
public:
  #ifdef _MT
   #define _LOCKIT(x)	lockit x
	_Lockit();
	~_Lockit();
  #else
   #define _LOCKIT(x)
	_Lockit()
		{}
	~_Lockit()
		{}
  #endif /* _MT */
	};
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}
#define _MAX	_cpp_max
#define _MIN	_cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };
#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP void __cdecl _ftime64(struct __timeb64 *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _fstat64(int, struct __stat64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
_CRTIMP int __cdecl _stat64(const char *, struct __stat64 *);
#endif

#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


#if defined(_M_IA64)
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );
#else
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );
#endif // defined(_M_IA64)

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\inc64\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);

_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _utime64(const char *, struct __utimbuf64 *);
_CRTIMP int __cdecl _futime64(int, struct __utimbuf64 *);
_CRTIMP int __cdecl _wutime64(const wchar_t *, struct __utimbuf64 *);
#endif

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         //XMMI
    _FpCodeFmax,         //XMMI
    _FpCodeConvertTrunc, //XMMI
    _XMMIAddps,          //XMMI
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         //XMMI2 
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   //66 2D
    _XMMI2Cvtsd2si,   //F2
    _XMMI2Cvttpd2pi,  //66 2C
    _XMMI2Cvttsd2si,  //F2
    _XMMI2Cvtps2pd,   //0F 5A
    _XMMI2Cvtss2sd,   //F3
    _XMMI2Cvtpd2ps,   //66
    _XMMI2Cvtsd2ss,   //F2
    _XMMI2Cvtdq2ps,   //0F 5B
    _XMMI2Cvttps2dq,  //F3
    _XMMI2Cvtps2dq,   //66
    _XMMI2Cvttpd2dq,  //66 0F E6
    _XMMI2Cvtpd2dq,   //F2 
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\dvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *	File name : dvec.h  class definitions
 *
 *	Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *	Facilitates an easy transition to compiler intrinsics
 *	or assembly language.
 *
 */

#ifndef DVEC_H_INCLUDED
#define DVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <fvec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */


/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

/* EMM Functionality Intrinsics */

class I8vec16;			/* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;			/* 16 elements, each element a signed char data type */
class Iu8vec16;			/* 16 elements, each element an unsigned char data type */
class I16vec8;			/* 8 elements, each element a signed or unsigned short */
class Is16vec8;			/* 8 elements, each element a signed short */
class Iu16vec8;			/* 8 elements, each element an unsigned short */
class I32vec4;			/* 4 elements, each element a signed or unsigned long */
class Is32vec4;			/* 4 elements, each element a signed long */
class Iu32vec4;			/* 4 elements, each element a unsigned long */
class I64vec2;			/* 2 element, each a __m64 data type */
class I128vec1;			/* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

inline const __m128i get_mask128()
{
	static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
	return mask128;
}


/* M128 Class:
 * 1 element, a __m128i data type
 * Contructors & Logical Operations
 */

class M128
{
protected:
		__m128i vec;

public:
	M128()									{ }
	M128(__m128i mm)						{ vec = mm; }

	operator __m128i() const					{ return vec; }

	/* Logical Operations */
	M128& operator&=(const M128 &a)					{ return *this = (M128) _mm_and_si128(vec,a); }
	M128& operator|=(const M128 &a)					{ return *this = (M128) _mm_or_si128(vec,a); }
	M128& operator^=(const M128 &a)					{ return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)	{ return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)	{ return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)	{ return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)	{ return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128
{
public:
	I128vec1()								{ }
	I128vec1(__m128i mm) : M128(mm)				{ }

	I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
	I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
	I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
	I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class:
 * 2 elements, each element signed or unsigned 64-bit integer
 */
class I64vec2 : public M128
{
public:
	I64vec2() { }
	I64vec2(__m128i mm) : M128(mm) { }

	I64vec2(__m64 q1, __m64 q0)
	{
		_MM_2QW(0,vec) = *(__int64*)&q0;
		_MM_2QW(1,vec) = *(__int64*)&q1;
	}

	/* Assignment Operator */
	I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

	/* Logical Assignment Operators */
	I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
	I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
	I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I64vec2& operator +=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_add_epi64(vec,a); }
	I64vec2& operator -=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sub_epi64(vec,a); }

	/* Shift Logical Operators */
	I64vec2 operator<<(const I64vec2 &a) 			{ return _mm_sll_epi64(vec,a); }
	I64vec2 operator<<(int count) 					{ return _mm_slli_epi64(vec,count); }
	I64vec2& operator<<=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sll_epi64(vec,a); }
	I64vec2& operator<<=(int count) 				{ return *this = (I64vec2) _mm_slli_epi64(vec,count); }
	I64vec2 operator>>(const I64vec2 &a) 			{ return _mm_srl_epi64(vec,a); }
	I64vec2 operator>>(int count) 					{ return _mm_srli_epi64(vec,count); }
	I64vec2& operator>>=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_srl_epi64(vec,a); }
	I64vec2& operator>>=(int count) 				{ return *this = (I64vec2) _mm_srli_epi64(vec,count); }

	/* Element Access for Debug, No data modified */
	const __int64& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	__int64& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class:
 * 4 elements, each element either a signed or unsigned int
 */
class I32vec4 : public M128
{
public:
	I32vec4() { }
	I32vec4(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I32vec4& operator= (const M128 &a)				{ return *this = (I32vec4) a; }

	/* Logicals Operators */
	I32vec4& operator&=(const M128 &a)				{ return *this = (I32vec4) _mm_and_si128(vec,a); }
	I32vec4& operator|=(const M128 &a)				{ return *this = (I32vec4) _mm_or_si128(vec,a); }
	I32vec4& operator^=(const M128 &a)				{ return *this = (I32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec4& operator +=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_add_epi32(vec,a); }
	I32vec4& operator -=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	I32vec4 operator<<(const I32vec4 &a) 			{ return _mm_sll_epi32(vec,a); }
	I32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	I32vec4& operator<<=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sll_epi32(vec,a); }
	I32vec4& operator<<=(int count) 				{ return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class:
 * 4 elements, each element signed integer
 */
class Is32vec4 : public I32vec4
{
public:
	Is32vec4() { }
	Is32vec4(__m128i mm) : I32vec4(mm) { }
	Is32vec4(int i3, int i2, int i1, int i0)
	{
		_MM_4DW(0,vec) = i0;
		_MM_4DW(1,vec) = i1;
		_MM_4DW(2,vec) = i2;
		_MM_4DW(3,vec) = i3;
	}

	/* Assignment Operator */
	Is32vec4& operator= (const M128 &a)		{ return *this = (Is32vec4) a; }

	/* Logical Operators */
	Is32vec4& operator&=(const M128 &a)		{ return *this = (Is32vec4) _mm_and_si128(vec,a); }
	Is32vec4& operator|=(const M128 &a)		{ return *this = (Is32vec4) _mm_or_si128(vec,a); }
	Is32vec4& operator^=(const M128 &a)		{ return *this = (Is32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec4& operator +=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_add_epi32(vec,a); }
	Is32vec4& operator -=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Is32vec4 operator<<(const M128 &a) 		{ return _mm_sll_epi32(vec,a); }
	Is32vec4 operator<<(int count) 			{ return _mm_slli_epi32(vec,count); }
	Is32vec4& operator<<=(const M128 &a)	{ return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
	Is32vec4& operator<<=(int count) 		{ return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec4 operator>>(const M128 &a) 		{ return _mm_sra_epi32(vec,a); }
	Is32vec4 operator>>(int count) 			{ return _mm_srai_epi32(vec,count); }
	Is32vec4& operator>>=(const M128 &a)	{ return *this = (Is32vec4) _mm_sra_epi32(vec,a); }
	Is32vec4& operator>>=(int count) 		{ return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec4 &a)
	{
		os << "[3]:" << _MM_4DW(3,a)
			<< " [2]:" << _MM_4DW(2,a)
			<< " [1]:" << _MM_4DW(1,a)
			<< " [0]:" << _MM_4DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}

	/* Element Access for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b) 	    	{ return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)			{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b) 		{ return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)		{ return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class:
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4
{
public:
	Iu32vec4() { }
	Iu32vec4(__m128i mm) : I32vec4(mm) { }
	Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
	{
		_MM_4UDW(0,vec) = ui0;
		_MM_4UDW(1,vec) = ui1;
		_MM_4UDW(2,vec) = ui2;
		_MM_4UDW(3,vec) = ui3;
	}

	/* Assignment Operator */
	Iu32vec4& operator= (const M128 &a)		{ return *this = (Iu32vec4) a; }

	/* Logical Assignment Operators */
	Iu32vec4& operator&=(const M128 &a)		{ return *this = (Iu32vec4) _mm_and_si128(vec,a); }
	Iu32vec4& operator|=(const M128 &a)		{ return *this = (Iu32vec4) _mm_or_si128(vec,a); }
	Iu32vec4& operator^=(const M128 &a)		{ return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec4& operator +=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
	Iu32vec4& operator -=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Iu32vec4 operator<<(const M128 &a) 				{ return _mm_sll_epi32(vec,a); }
	Iu32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	Iu32vec4& operator<<=(const M128 &a)			{ return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
	Iu32vec4& operator<<=(int count) 				{ return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
	Iu32vec4 operator>>(const M128 &a) 				{ return _mm_srl_epi32(vec,a); }
	Iu32vec4 operator>>(int count) 					{ return _mm_srli_epi32(vec,count); }
	Iu32vec4& operator>>=(const M128 &a)			{ return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
	Iu32vec4& operator>>=(int count) 				{ return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec4 &a)
	{
		os << "[3]:" << _MM_4UDW(3,a)
			<< " [2]:" << _MM_4UDW(2,a)
			<< " [1]:" << _MM_4UDW(1,a)
			<< " [0]:" << _MM_4UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)	{ return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class:
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128
{
public:
	I16vec8() { }
	I16vec8(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I16vec8& operator= (const M128 &a)		{ return *this = (I16vec8) a; }

	/* Logical Assignment Operators */
	I16vec8& operator&=(const M128 &a)		{ return *this = (I16vec8) _mm_and_si128(vec,a); }
	I16vec8& operator|=(const M128 &a)		{ return *this = (I16vec8) _mm_or_si128(vec,a); }
	I16vec8& operator^=(const M128 &a)		{ return *this = (I16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec8& operator +=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_add_epi16(vec,a); }
	I16vec8& operator -=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_sub_epi16(vec,a); }
	I16vec8& operator *=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	I16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	I16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	I16vec8& operator<<=(const M128 &a)				{ return *this = (I16vec8)_mm_sll_epi16(vec,a); }
	I16vec8& operator<<=(int count) 				{ return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class:
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8
{
public:
	Is16vec8() { }
	Is16vec8(__m128i mm) : I16vec8(mm) { }
	Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
	 {
		_MM_8W(0,vec) = s0;
		_MM_8W(1,vec) = s1;
		_MM_8W(2,vec) = s2;
		_MM_8W(3,vec) = s3;
		_MM_8W(4,vec) = s4;
		_MM_8W(5,vec) = s5;
		_MM_8W(6,vec) = s6;
		_MM_8W(7,vec) = s7;
	}

	/* Assignment Operator */
	Is16vec8& operator= (const M128 &a)		{ return *this = (Is16vec8) a; }

	/* Logical Assignment Operators */
	Is16vec8& operator&=(const M128 &a)		{ return *this = (Is16vec8) _mm_and_si128(vec,a); }
	Is16vec8& operator|=(const M128 &a)		{ return *this = (Is16vec8) _mm_or_si128(vec,a); }
	Is16vec8& operator^=(const M128 &a)		{ return *this = (Is16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec8& operator +=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_add_epi16(vec,a); }
	Is16vec8& operator -=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_sub_epi16(vec,a); }
	Is16vec8& operator *=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Is16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Is16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	Is16vec8& operator<<=(const M128 &a)			{ return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
	Is16vec8& operator<<=(int count) 				{ return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
	/* Shift Arithmetic Operators */
	Is16vec8 operator>>(const M128 &a) 				{ return _mm_sra_epi16(vec,a); }
	Is16vec8 operator>>(int count) 				{ return _mm_srai_epi16(vec,count); }
	Is16vec8& operator>>=(const M128 &a)			{ return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
	Is16vec8& operator>>=(int count) 				{ return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec8 &a)
	{
		os << "[7]:" << _MM_8W(7,a)
			<< " [6]:" << _MM_8W(6,a)
			<< " [5]:" << _MM_8W(5,a)
			<< " [4]:" << _MM_8W(4,a)
			<< " [3]:" << _MM_8W(3,a)
			<< " [2]:" << _MM_8W(2,a)
			<< " [1]:" << _MM_8W(1,a)
			<< " [0]:" << _MM_8W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mullo_epi16(a,b); }


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_min_epi16(a,b); }


/* Iu16vec8 Class:
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8
{
public:
	Iu16vec8() { }
	Iu16vec8(__m128i mm) : I16vec8(mm) { }
	Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
	{
		_MM_8UW(0,vec) = s0;
		_MM_8UW(1,vec) = s1;
		_MM_8UW(2,vec) = s2;
		_MM_8UW(3,vec) = s3;
		_MM_8UW(4,vec) = s4;
		_MM_8UW(5,vec) = s5;
		_MM_8UW(6,vec) = s6;
		_MM_8UW(7,vec) = s7;
	}

	/* Assignment Operator */
	Iu16vec8& operator= (const M128 &a)		{ return *this = (Iu16vec8) a; }
	/* Logical Assignment Operators */
	Iu16vec8& operator&=(const M128 &a)		{ return *this = (Iu16vec8) _mm_and_si128(vec,a); }
	Iu16vec8& operator|=(const M128 &a)		{ return *this = (Iu16vec8) _mm_or_si128(vec,a); }
	Iu16vec8& operator^=(const M128 &a)		{ return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu16vec8& operator +=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
	Iu16vec8& operator -=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }
	Iu16vec8& operator *=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Iu16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Iu16vec8 operator<<(int count) 					{ return _mm_slli_epi16(vec,count); }
	Iu16vec8& operator<<=(const M128 &a)			{ return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
	Iu16vec8& operator<<=(int count) 				{ return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
	Iu16vec8 operator>>(const M128 &a) 				{ return _mm_srl_epi16(vec,a); }
	Iu16vec8 operator>>(int count) 					{ return _mm_srli_epi16(vec,count); }
	Iu16vec8& operator>>=(const M128 &a)			{ return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
	Iu16vec8& operator>>=(int count) 				{ return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu16vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UW(7,a))
			<< " [6]:" << unsigned short(_MM_8UW(6,a))
			<< " [5]:" << unsigned short(_MM_8UW(5,a))
			<< " [4]:" << unsigned short(_MM_8UW(4,a))
			<< " [3]:" << unsigned short(_MM_8UW(3,a))
			<< " [2]:" << unsigned short(_MM_8UW(2,a))
			<< " [1]:" << unsigned short(_MM_8UW(1,a))
			<< " [0]:" << unsigned short(_MM_8UW(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}

	/* Element Access for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class:
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128
{
public:
	I8vec16() { }
	I8vec16(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I8vec16& operator= (const M128 &a)		{ return *this = (I8vec16) a; }

	/* Logical Assignment Operators */
	I8vec16& operator&=(const M128 &a)		{ return *this = (I8vec16) _mm_and_si128(vec,a); }
	I8vec16& operator|=(const M128 &a)		{ return *this = (I8vec16) _mm_or_si128(vec,a); }
	I8vec16& operator^=(const M128 &a)		{ return *this = (I8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec16& operator +=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_add_epi8(vec,a); }
	I8vec16& operator -=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_sub_epi8(vec,a); }

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)	{ return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class:
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16
{
public:
	Is8vec16() { }
	Is8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Is8vec16& operator= (const M128 &a)		{ return *this = (Is8vec16) a; }

	/* Logical Assignment Operators */
	Is8vec16& operator&=(const M128 &a)		{ return *this = (Is8vec16) _mm_and_si128(vec,a); }
	Is8vec16& operator|=(const M128 &a)		{ return *this = (Is8vec16) _mm_or_si128(vec,a); }
	Is8vec16& operator^=(const M128 &a)		{ return *this = (Is8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec16& operator +=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_add_epi8(vec,a); }
	Is8vec16& operator -=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Is8vec16 &a)
	{
		 os << "[15]:"  << short(_MM_16B(15,a))
			<< " [14]:" << short(_MM_16B(14,a))
			<< " [13]:" << short(_MM_16B(13,a))
			<< " [12]:" << short(_MM_16B(12,a))
			<< " [11]:" << short(_MM_16B(11,a))
			<< " [10]:" << short(_MM_16B(10,a))
			<< " [9]:" << short(_MM_16B(9,a))
			<< " [8]:" << short(_MM_16B(8,a))
		      << " [7]:" << short(_MM_16B(7,a))
			<< " [6]:" << short(_MM_16B(6,a))
			<< " [5]:" << short(_MM_16B(5,a))
			<< " [4]:" << short(_MM_16B(4,a))
			<< " [3]:" << short(_MM_16B(3,a))
			<< " [2]:" << short(_MM_16B(2,a))
			<< " [1]:" << short(_MM_16B(1,a))
			<< " [0]:" << short(_MM_16B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

	/* Element Access for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class:
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16
{
public:
	Iu8vec16() { }
	Iu8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Iu8vec16& operator= (const M128 &a)		{ return *this = (Iu8vec16) a; }

	/* Logical Assignment Operators */
	Iu8vec16& operator&=(const M128 &a)		{ return *this = (Iu8vec16) _mm_and_si128(vec,a); }
	Iu8vec16& operator|=(const M128 &a)		{ return *this = (Iu8vec16) _mm_or_si128(vec,a); }
	Iu8vec16& operator^=(const M128 &a)		{ return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu8vec16& operator +=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
	Iu8vec16& operator -=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec16 &a)
	{
		 os << "[15]:"  << unsigned short(_MM_16UB(15,a))
			<< " [14]:" << unsigned short(_MM_16UB(14,a))
			<< " [13]:" << unsigned short(_MM_16UB(13,a))
			<< " [12]:" << unsigned short(_MM_16UB(12,a))
			<< " [11]:" << unsigned short(_MM_16UB(11,a))
			<< " [10]:" << unsigned short(_MM_16UB(10,a))
			<< " [9]:" << unsigned short(_MM_16UB(9,a))
			<< " [8]:" << unsigned short(_MM_16UB(8,a))
		      << " [7]:" << unsigned short(_MM_16UB(7,a))
			<< " [6]:" << unsigned short(_MM_16UB(6,a))
			<< " [5]:" << unsigned short(_MM_16UB(5,a))
			<< " [4]:" << unsigned short(_MM_16UB(4,a))
			<< " [3]:" << unsigned short(_MM_16UB(3,a))
			<< " [2]:" << unsigned short(_MM_16UB(2,a))
			<< " [1]:" << unsigned short(_MM_16UB(1,a))
			<< " [0]:" << unsigned short(_MM_16UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b) 	{ return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); }

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 )))));	\
}
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)


#undef IVEC128_SELECT


class F64vec2
{
protected:
   	 __m128d vec;
public:

	/* Constructors: __m128d, 2 doubles */
	F64vec2() {}

	/* initialize 2 DP FP with __m128d data type */
	F64vec2(__m128d m)					{ vec = m;}

	/* initialize 2 DP FPs with 2 doubles */
	F64vec2(double d1, double d0)		                { vec= _mm_set_pd(d1,d0); }

	/* Explicitly initialize each of 2 DP FPs with same double */
	EXPLICIT F64vec2(double d)	{ vec = _mm_set1_pd(d); }

	/* Conversion functions */
	operator  __m128d() const	{ return vec; }		/* Convert to __m128d */

 	/* Logical Operators */
	friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
	friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
	friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

	/* Arithmetic Operators */
	friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
	friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); }
	friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); }
	friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

	F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
	F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }
	F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); }
	F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
	F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
	F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
	F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

	/* Horizontal Add */
	friend double add_horizontal(F64vec2 &a)
	{
		F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
		return ftemp[0];
	}

	/* And Not */
	friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

	/* Square Root */
	friend F64vec2 sqrt(const F64vec2 &a)		{ return _mm_sqrt_pd(a); }

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
			friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b)
			{ return _mm_cmpeq_ps(a,b);} */
	#define F64vec2_COMP(op) \
	friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
		F64vec2_COMP(eq)					// expanded to cmpeq(a,b)
		F64vec2_COMP(lt)					// expanded to cmplt(a,b)
		F64vec2_COMP(le)					// expanded to cmple(a,b)
		F64vec2_COMP(gt)					// expanded to cmpgt(a,b)
		F64vec2_COMP(ge)					// expanded to cmpge(a,b)
		F64vec2_COMP(ngt)					// expanded to cmpngt(a,b)
		F64vec2_COMP(nge)					// expanded to cmpnge(a,b)
		F64vec2_COMP(neq)					// expanded to cmpneq(a,b)
		F64vec2_COMP(nlt)					// expanded to cmpnlt(a,b)
		F64vec2_COMP(nle)					// expanded to cmpnle(a,b)
	#undef F64vec2_COMP

	/* Min and Max */
	friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
	friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
	#define F64vec2_COMI(op) \
	friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
		F64vec2_COMI(eq)					// expanded to comieq(a,b)
		F64vec2_COMI(lt)					// expanded to comilt(a,b)
		F64vec2_COMI(le)					// expanded to comile(a,b)
		F64vec2_COMI(gt)					// expanded to comigt(a,b)
		F64vec2_COMI(ge)					// expanded to comige(a,b)
		F64vec2_COMI(neq)					// expanded to comineq(a,b)
	#undef F64vec2_COMI

        /* Compare lower DP FP values */
	#define F64vec2_UCOMI(op) \
	friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
		F64vec2_UCOMI(eq)					// expanded to ucomieq(a,b)
		F64vec2_UCOMI(lt)					// expanded to ucomilt(a,b)
		F64vec2_UCOMI(le)					// expanded to ucomile(a,b)
		F64vec2_UCOMI(gt)					// expanded to ucomigt(a,b)
		F64vec2_UCOMI(ge)					// expanded to ucomige(a,b)
		F64vec2_UCOMI(neq)					// expanded to ucomineq(a,b)
	#undef F64vec2_UCOMI

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F64vec2 &a)
	{
	/* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */
	  double *dp = (double*)&a;
		os <<	" [1]:" << *(dp+1)
			<< " [0]:" << *dp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const double& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
	/* Element Access and Modification*/
	double& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)
{ return _mm_movemask_pd(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)
{ a = _mm_loadu_pd(p); }

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)
{ _mm_storeu_pd(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a)
{ _mm_stream_pd(p,a);}

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d) 	   \
{																\
	F64vec2 mask = _mm_cmp##op##_pd(a,b);						\
	return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d))));	\
}
F64vec2_SELECT(eq)		// generates select_eq(a,b)
F64vec2_SELECT(lt)		// generates select_lt(a,b)
F64vec2_SELECT(le)		// generates select_le(a,b)
F64vec2_SELECT(gt)		// generates select_gt(a,b)
F64vec2_SELECT(ge)		// generates select_ge(a,b)
F64vec2_SELECT(neq)		// generates select_neq(a,b)
F64vec2_SELECT(nlt)		// generates select_nlt(a,b)
F64vec2_SELECT(nle)		// generates select_nle(a,b)
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{

	return _mm_cvttsd_si32(a);

}

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{
	return _mm_cvtps_pd(a);
}

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{
	return _mm_cvtpd_ps(a);
}

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{
	return _mm_cvtsi32_sd(a,b);
}

#pragma pack(pop) /* 16-B aligned */
#endif // DVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\emmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * emmintrin.h
 *
 * Principal header file for Willamette New Instruction intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _EMM_FUNCTIONALITY is defined; if it is, the C implementation
 * will be used (the "functional intrinsics").
 */

#ifndef _INCLUDED_EMM
#define _INCLUDED_EMM

/*
 * the __m128 & __m64 types are required for the intrinsics
 */
#include <xmmintrin.h>

#ifdef __ICL
#ifdef _EMM_FUNCTIONALITY
#include "emm_func.h"
#else
typedef long long __m128d;
typedef long long __m128i;
#endif
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];    
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;
#endif

/*
 * Macro function for shuffle
 */
#define _MM_SHUFFLE2(x,y) (((x)<<1) | (y))

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * DP, arithmetic
 */

extern __m128d _mm_add_sd(__m128d a, __m128d b);
extern __m128d _mm_add_pd(__m128d a, __m128d b);
extern __m128d _mm_sub_sd(__m128d a, __m128d b);
extern __m128d _mm_sub_pd(__m128d a, __m128d b);
extern __m128d _mm_mul_sd(__m128d a, __m128d b);
extern __m128d _mm_mul_pd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_sd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_pd(__m128d a);
extern __m128d _mm_div_sd(__m128d a, __m128d b);
extern __m128d _mm_div_pd(__m128d a, __m128d b);
extern __m128d _mm_min_sd(__m128d a, __m128d b);
extern __m128d _mm_min_pd(__m128d a, __m128d b);
extern __m128d _mm_max_sd(__m128d a, __m128d b);
extern __m128d _mm_max_pd(__m128d a, __m128d b);

/*
 * DP, logicals
 */

extern __m128d _mm_and_pd(__m128d a, __m128d b);
extern __m128d _mm_andnot_pd(__m128d a, __m128d b);
extern __m128d _mm_or_pd(__m128d a, __m128d b);
extern __m128d _mm_xor_pd(__m128d a, __m128d b);

/*
 * DP, comparisons
 */

extern __m128d _mm_cmpeq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpeq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmple_sd(__m128d a, __m128d b);
extern __m128d _mm_cmple_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_sd(__m128d a, __m128d b);
extern int _mm_comieq_sd(__m128d a, __m128d b);
extern int _mm_comilt_sd(__m128d a, __m128d b);
extern int _mm_comile_sd(__m128d a, __m128d b);
extern int _mm_comigt_sd(__m128d a, __m128d b);
extern int _mm_comige_sd(__m128d a, __m128d b);
extern int _mm_comineq_sd(__m128d a, __m128d b);
extern int _mm_ucomieq_sd(__m128d a, __m128d b);
extern int _mm_ucomilt_sd(__m128d a, __m128d b);
extern int _mm_ucomile_sd(__m128d a, __m128d b);
extern int _mm_ucomigt_sd(__m128d a, __m128d b);
extern int _mm_ucomige_sd(__m128d a, __m128d b);
extern int _mm_ucomineq_sd(__m128d a, __m128d b);

/*
 * DP, converts
 */

extern __m128d _mm_cvtepi32_pd(__m128i a);
extern __m128i _mm_cvtpd_epi32(__m128d a);
extern __m128i _mm_cvttpd_epi32(__m128d a);
extern __m128 _mm_cvtepi32_ps(__m128i a);
extern __m128i _mm_cvtps_epi32(__m128 a);
extern __m128i _mm_cvttps_epi32(__m128 a);
extern __m128 _mm_cvtpd_ps(__m128d a);
extern __m128d _mm_cvtps_pd(__m128 a);
extern __m128 _mm_cvtsd_ss(__m128 a, __m128d b);
extern __m128d _mm_cvtss_sd(__m128d a, __m128 b);

extern int _mm_cvtsd_si32(__m128d a);
extern int _mm_cvttsd_si32(__m128d a);
extern __m128d _mm_cvtsi32_sd(__m128d a, int b);

extern __m64 _mm_cvtpd_pi32(__m128d a);
extern __m64 _mm_cvttpd_pi32(__m128d a);
extern __m128d _mm_cvtpi32_pd(__m64 a);

/*
 * DP, misc
 */

extern __m128d _mm_unpackhi_pd(__m128d a, __m128d b);
extern __m128d _mm_unpacklo_pd(__m128d a, __m128d b);
extern int _mm_movemask_pd(__m128d a);
extern __m128d _mm_shuffle_pd(__m128d a, __m128d b, int i);

/*
 * DP, loads
 */

extern __m128d _mm_load_pd(double const*dp);
extern __m128d _mm_load1_pd(double const*dp);
extern __m128d _mm_loadr_pd(double const*dp);
extern __m128d _mm_loadu_pd(double const*dp);
extern __m128d _mm_load_sd(double const*dp);
extern __m128d _mm_loadh_pd(__m128d a, double const*dp);
extern __m128d _mm_loadl_pd(__m128d a, double const*dp);

/*
 * DP, sets
 */

extern __m128d _mm_set_sd(double w);
extern __m128d _mm_set1_pd(double a);
extern __m128d _mm_set_pd(double z, double y);
extern __m128d _mm_setr_pd(double y, double z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d a, __m128d b);;

/* 
 * DP, stores
 */

extern void _mm_store_sd(double *dp, __m128d a);
extern void _mm_store1_pd(double *dp, __m128d a);
extern void _mm_store_pd(double *dp, __m128d a);
extern void _mm_storeu_pd(double *dp, __m128d a);
extern void _mm_storer_pd(double *dp, __m128d a);
extern void _mm_storeh_pd(double *dp, __m128d a);
extern void _mm_storel_pd(double *dp, __m128d a);

/*
 * Integer, arithmetic
 */

extern __m128i _mm_add_epi8(__m128i a, __m128i b);
extern __m128i _mm_add_epi16(__m128i a, __m128i b);
extern __m128i _mm_add_epi32(__m128i a, __m128i b);
extern __m64 _mm_add_si64(__m64 a, __m64 b);
extern __m128i _mm_add_epi64(__m128i a, __m128i b);
extern __m128i _mm_adds_epi8(__m128i a, __m128i b);
extern __m128i _mm_adds_epi16(__m128i a, __m128i b);
extern __m128i _mm_adds_epu8(__m128i a, __m128i b);
extern __m128i _mm_adds_epu16(__m128i a, __m128i b);
extern __m128i _mm_avg_epu8(__m128i a, __m128i b);
extern __m128i _mm_avg_epu16(__m128i a, __m128i b);
extern __m128i _mm_madd_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epu8(__m128i a, __m128i b);
extern __m128i _mm_min_epi16(__m128i a, __m128i b);
extern __m128i _mm_min_epu8(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epu16(__m128i a, __m128i b);
extern __m128i _mm_mullo_epi16(__m128i a, __m128i b);
extern __m64 _mm_mul_su32(__m64 a, __m64 b);
extern __m128i _mm_mul_epu32(__m128i a, __m128i b);
extern __m128i _mm_sad_epu8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi16(__m128i a, __m128i b);
extern __m128i _mm_sub_epi32(__m128i a, __m128i b);
extern __m64 _mm_sub_si64(__m64 a, __m64 b);
extern __m128i _mm_sub_epi64(__m128i a, __m128i b);
extern __m128i _mm_subs_epi8(__m128i a, __m128i b);
extern __m128i _mm_subs_epi16(__m128i a, __m128i b);
extern __m128i _mm_subs_epu8(__m128i a, __m128i b);
extern __m128i _mm_subs_epu16(__m128i a, __m128i b);

/*
 * Integer, logicals
 */

extern __m128i _mm_and_si128(__m128i a, __m128i b);
extern __m128i _mm_andnot_si128(__m128i a, __m128i b);
extern __m128i _mm_or_si128(__m128i a, __m128i b);
extern __m128i _mm_xor_si128(__m128i a, __m128i b);

/*
 * Integer, shifts
 */

extern __m128i _mm_slli_si128(__m128i a, int imm);
extern __m128i _mm_slli_epi16(__m128i a, int count);
extern __m128i _mm_sll_epi16(__m128i a, __m128i count);
extern __m128i _mm_slli_epi32(__m128i a, int count);
extern __m128i _mm_sll_epi32(__m128i a, __m128i count);
extern __m128i _mm_slli_epi64(__m128i a, int count);
extern __m128i _mm_sll_epi64(__m128i a, __m128i count);
extern __m128i _mm_srai_epi16(__m128i a, int count);
extern __m128i _mm_sra_epi16(__m128i a, __m128i count);
extern __m128i _mm_srai_epi32(__m128i a, int count);
extern __m128i _mm_sra_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_si128(__m128i a, int imm);
extern __m128i _mm_srli_epi16(__m128i a, int count);
extern __m128i _mm_srl_epi16(__m128i a, __m128i count);
extern __m128i _mm_srli_epi32(__m128i a, int count);
extern __m128i _mm_srl_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_epi64(__m128i a, int count);
extern __m128i _mm_srl_epi64(__m128i a, __m128i count);

/*
 * Integer, comparisons
 */

extern __m128i _mm_cmpeq_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi32(__m128i a, __m128i b);

/*
 * Integer, converts
 */

extern __m128i _mm_cvtsi32_si128(int a);
extern int _mm_cvtsi128_si32(__m128i a);

/*
 * Integer, misc
 */

extern __m128i _mm_packs_epi16(__m128i a, __m128i b);
extern __m128i _mm_packs_epi32(__m128i a, __m128i b);
extern __m128i _mm_packus_epi16(__m128i a, __m128i b);
extern int _mm_extract_epi16(__m128i a, int imm);
extern __m128i _mm_insert_epi16(__m128i a, int b, int imm);
extern int _mm_movemask_epi8(__m128i a);
extern __m128i _mm_shuffle_epi32(__m128i a, int imm);
extern __m128i _mm_shufflehi_epi16(__m128i a, int imm);
extern __m128i _mm_shufflelo_epi16(__m128i a, int imm);
extern __m128i _mm_unpackhi_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi64(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi64(__m128i a, __m128i b);

/*
 * Integer, loads
 */

extern __m128i _mm_load_si128(__m128i const*p);
extern __m128i _mm_loadu_si128(__m128i const*p);
extern __m128i _mm_loadl_epi64(__m128i const*p);

/*
 * Integer, sets
 */

extern __m128i _mm_set_epi64(__m64 q1, __m64 q0);
extern __m128i _mm_set_epi32(int i3, int i2, int i1, int i0);
extern __m128i _mm_set_epi16(short w7, short w6, short w5, short w4,
                             short w3, short w2, short w1, short w0);
extern __m128i _mm_set_epi8(char b15, char b14, char b13, char b12, 
                            char b11, char b10, char b9, char b8, 
                            char b7, char b6, char b5, char b4, 
                            char b3, char b2, char b1, char b0);
extern __m128i _mm_set1_epi64(__m64 q);
extern __m128i _mm_set1_epi32(int i);
extern __m128i _mm_set1_epi16(short w);
extern __m128i _mm_set1_epi8(char b);
extern __m128i _mm_setl_epi64(__m128i q);
extern __m128i _mm_setr_epi64(__m64 q0, __m64 q1);
extern __m128i _mm_setr_epi32(int i0, int i1, int i2, int i3);
extern __m128i _mm_setr_epi16(short w0, short w1, short w2, short w3, 
                              short w4, short w5, short w6, short w7);
extern __m128i _mm_setr_epi8(char b15, char b14, char b13, char b12, 
                             char b11, char b10, char b9, char b8, 
                             char b7, char b6, char b5, char b4, 
                             char b3, char b2, char b1, char b0);
extern __m128i _mm_setzero_si128();

/*
 * Integer, stores
 */

extern void _mm_store_si128(__m128i *p, __m128i b);
extern void _mm_storeu_si128(__m128i *p, __m128i b);
extern void _mm_storel_epi64(__m128i *p, __m128i q);
extern void _mm_maskmoveu_si128(__m128i d, __m128i n, char *p);

/*
 * Integer, moves
 */

extern __m128i _mm_move_epi64(__m128i q);
extern __m128i _mm_movpi64_epi64(__m64 q);
extern __m64 _mm_movepi64_pi64(__m128i q);

/*
 * Cacheability support
 */

extern void _mm_stream_pd(double *dp, __m128d a);;
extern void _mm_stream_si128(__m128i *p, __m128i a);
extern void _mm_clflush(void const*p);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *p, int i);
extern void _mm_pause(void);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_EMM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP void *  __cdecl calloc(size_t, size_t);
_CRTIMP void    __cdecl free(void *);
_CRTIMP void *  __cdecl malloc(size_t);
_CRTIMP void *  __cdecl realloc(void *, size_t);
_CRTIMP void    __cdecl _aligned_free(void *);
_CRTIMP void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);
_CRTIMP int     __cdecl _resetstkoflw (void);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#if     defined(_M_MRX000) || defined(_M_PPC) || defined(_M_ALPHA)
#pragma intrinsic(_alloca)
#endif

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
#ifdef  _M_MRX000
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
#else
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\mm3dnow.h ===
/**
*** Copyright (C) 1999 Advanced Micro Devices Inc.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Advanced Micro Devices and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * mm3dnow.h
 *
 */

#ifndef _MM3DNOW_H_INCLUDED
#define _MM3DNOW_H_INCLUDED

#include <mmintrin.h>
#include <xmmintrin.h>

#if defined __cplusplus
extern "C" { /* Intrinsics use C name-mangling.  */
#endif /* __cplusplus */

/* 3DNOW intrinsics */

void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(void*);

__m64 _m_from_float(float);
float _m_to_float(__m64);

/* Athlon DSP intrinsics */

__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MM3DNOW_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\mmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * Definitions and declarations for use with compiler intrinsics.
 */

#ifndef _MMINTRIN_H_INCLUDED
#define _MMINTRIN_H_INCLUDED

#if defined __cplusplus
extern "C" { /* Begin "C" */
/* Intrinsics use C name-mangling.
 */
#endif /* __cplusplus */

#ifdef __ICL
typedef unsigned long long __m64; 
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];    
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;
#endif

/* General support intrinsics */
void  _m_empty(void);
__m64 _m_from_int(int i);
int   _m_to_int(__m64 m);
__m64 _m_packsswb(__m64 m1, __m64 m2);
__m64 _m_packssdw(__m64 m1, __m64 m2);
__m64 _m_packuswb(__m64 m1, __m64 m2);
__m64 _m_punpckhbw(__m64 m1, __m64 m2);
__m64 _m_punpckhwd(__m64 m1, __m64 m2);
__m64 _m_punpckhdq(__m64 m1, __m64 m2);
__m64 _m_punpcklbw(__m64 m1, __m64 m2);
__m64 _m_punpcklwd(__m64 m1, __m64 m2);
__m64 _m_punpckldq(__m64 m1, __m64 m2);

/* Packed arithmetic intrinsics */
__m64 _m_paddb(__m64 m1, __m64 m2);
__m64 _m_paddw(__m64 m1, __m64 m2);
__m64 _m_paddd(__m64 m1, __m64 m2);
__m64 _m_paddsb(__m64 m1, __m64 m2);
__m64 _m_paddsw(__m64 m1, __m64 m2);
__m64 _m_paddusb(__m64 m1, __m64 m2);
__m64 _m_paddusw(__m64 m1, __m64 m2);
__m64 _m_psubb(__m64 m1, __m64 m2);
__m64 _m_psubw(__m64 m1, __m64 m2);
__m64 _m_psubd(__m64 m1, __m64 m2);
__m64 _m_psubsb(__m64 m1, __m64 m2);
__m64 _m_psubsw(__m64 m1, __m64 m2);
__m64 _m_psubusb(__m64 m1, __m64 m2);
__m64 _m_psubusw(__m64 m1, __m64 m2);
__m64 _m_pmaddwd(__m64 m1, __m64 m2);
__m64 _m_pmulhw(__m64 m1, __m64 m2);
__m64 _m_pmullw(__m64 m1, __m64 m2);

/* Shift intrinsics */
__m64 _m_psllw(__m64 m, __m64 count);
__m64 _m_psllwi(__m64 m, int count);
__m64 _m_pslld(__m64 m, __m64 count);
__m64 _m_pslldi(__m64 m, int count);
__m64 _m_psllq(__m64 m, __m64 count);
__m64 _m_psllqi(__m64 m, int count);
__m64 _m_psraw(__m64 m, __m64 count);
__m64 _m_psrawi(__m64 m, int count);
__m64 _m_psrad(__m64 m, __m64 count);
__m64 _m_psradi(__m64 m, int count);
__m64 _m_psrlw(__m64 m, __m64 count);
__m64 _m_psrlwi(__m64 m, int count);
__m64 _m_psrld(__m64 m, __m64 count);
__m64 _m_psrldi(__m64 m, int count);
__m64 _m_psrlq(__m64 m, __m64 count);
__m64 _m_psrlqi(__m64 m, int count);

/* Logical intrinsics */
__m64 _m_pand(__m64 m1, __m64 m2);
__m64 _m_pandn(__m64 m1, __m64 m2);
__m64 _m_por(__m64 m1, __m64 m2);
__m64 _m_pxor(__m64 m1, __m64 m2);

/* Comparison intrinsics */
__m64 _m_pcmpeqb(__m64 m1, __m64 m2);
__m64 _m_pcmpeqw(__m64 m1, __m64 m2);
__m64 _m_pcmpeqd(__m64 m1, __m64 m2);
__m64 _m_pcmpgtb(__m64 m1, __m64 m2);
__m64 _m_pcmpgtw(__m64 m1, __m64 m2);
__m64 _m_pcmpgtd(__m64 m1, __m64 m2);

/* Utility intrinsics */
__m64 _mm_setzero_si64();
__m64 _mm_set_pi32(int i1, int i0);
__m64 _mm_set_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_set_pi8(char b7, char b6, char b5, char b4,
                  char b3, char b2, char b1, char b0);
__m64 _mm_set1_pi32(int i);
__m64 _mm_set1_pi16(short s);
__m64 _mm_set1_pi8(char b);
__m64 _mm_setr_pi32(int i1, int i0);
__m64 _mm_setr_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_setr_pi8(char b7, char b6, char b5, char b4,
                   char b3, char b2, char b1, char b0);

/* Alternate intrinsic name definitions */
#define _mm_empty         _m_empty
#define _mm_cvtsi32_si64  _m_from_int
#define _mm_cvtsi64_si32  _m_to_int
#define _mm_packs_pi16    _m_packsswb
#define _mm_packs_pi32    _m_packssdw
#define _mm_packs_pu16    _m_packuswb
#define _mm_unpackhi_pi8  _m_punpckhbw
#define _mm_unpackhi_pi16 _m_punpckhwd
#define _mm_unpackhi_pi32 _m_punpckhdq
#define _mm_unpacklo_pi8  _m_punpcklbw
#define _mm_unpacklo_pi16 _m_punpcklwd
#define _mm_unpacklo_pi32 _m_punpckldq
#define _mm_add_pi8       _m_paddb
#define _mm_add_pi16      _m_paddw
#define _mm_add_pi32      _m_paddd
#define _mm_adds_pi8      _m_paddsb
#define _mm_adds_pi16     _m_paddsw
#define _mm_adds_pu8      _m_paddusb
#define _mm_adds_pu16     _m_paddusw
#define _mm_sub_pi8       _m_psubb
#define _mm_sub_pi16      _m_psubw
#define _mm_sub_pi32      _m_psubd
#define _mm_subs_pi8      _m_psubsb
#define _mm_subs_pi16     _m_psubsw
#define _mm_subs_pu8      _m_psubusb
#define _mm_subs_pu16     _m_psubusw
#define _mm_madd_pi16     _m_pmaddwd
#define _mm_mulhi_pi16    _m_pmulhw
#define _mm_mullo_pi16    _m_pmullw
#define _mm_sll_pi16      _m_psllw
#define _mm_slli_pi16     _m_psllwi
#define _mm_sll_pi32      _m_pslld
#define _mm_slli_pi32     _m_pslldi
#define _mm_sll_si64      _m_psllq
#define _mm_slli_si64     _m_psllqi
#define _mm_sra_pi16      _m_psraw
#define _mm_srai_pi16     _m_psrawi
#define _mm_sra_pi32      _m_psrad
#define _mm_srai_pi32     _m_psradi
#define _mm_srl_pi16      _m_psrlw
#define _mm_srli_pi16     _m_psrlwi
#define _mm_srl_pi32      _m_psrld
#define _mm_srli_pi32     _m_psrldi
#define _mm_srl_si64      _m_psrlq
#define _mm_srli_si64     _m_psrlqi
#define _mm_and_si64      _m_pand
#define _mm_andnot_si64   _m_pandn
#define _mm_or_si64       _m_por
#define _mm_xor_si64      _m_pxor
#define _mm_cmpeq_pi8     _m_pcmpeqb
#define _mm_cmpeq_pi16    _m_pcmpeqw
#define _mm_cmpeq_pi32    _m_pcmpeqd
#define _mm_cmpgt_pi8     _m_pcmpgtb
#define _mm_cmpgt_pi16    _m_pcmpgtw
#define _mm_cmpgt_pi32    _m_pcmpgtd


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MMINTRIN_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ostream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
        ostream(streambuf*);
        virtual ~ostream();

        ostream& flush();
        int  opfx();
        void osfx();

inline  ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline  ostream& operator<<(ios& (__cdecl * _f)(ios&));
        ostream& operator<<(const char *);
inline  ostream& operator<<(const unsigned char *);
inline  ostream& operator<<(const signed char *);
inline  ostream& operator<<(char);
        ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
        ostream& operator<<(short);
        ostream& operator<<(unsigned short);
        ostream& operator<<(int);
        ostream& operator<<(unsigned int);
        ostream& operator<<(long);
        ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
        ostream& operator<<(double);
        ostream& operator<<(long double);
        ostream& operator<<(const void *);
        ostream& operator<<(streambuf*);
inline  ostream& put(char);
        ostream& put(unsigned char);
inline  ostream& put(signed char);
        ostream& write(const char *,int);
inline  ostream& write(const unsigned char *,int);
inline  ostream& write(const signed char *,int);
        ostream& seekp(streampos);
        ostream& seekp(streamoff,ios::seek_dir);
        streampos tellp();

protected:
        ostream();
        ostream(const ostream&);        // treat as private
        ostream& operator=(streambuf*); // treat as private
        ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
        int do_opfx(int);               // not used
        void do_osfx();                 // not used

private:
        ostream(ios&);
        ostream& writepad(const char *, const char *);
        int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline  ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline  ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline  ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline  ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline  ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline  ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline  ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline  ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline  ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
        public:
                ostream_withassign();
                ostream_withassign(streambuf* _is);
                ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&           __cdecl dec(ios&);
_CRTIMP ios&           __cdecl hex(ios&);
_CRTIMP ios&           __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_OSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\ivec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef IVEC_H_INCLUDED
#define IVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <mmintrin.h>
#include <assert.h>

/*
 * Define _SILENCE_IVEC_C4799 to disable warning C4799 inside this header.
 * Be careful that any code that uses these functions properly executes EMMS
 * or _m_empty() after using any MMX instruction and before using the x87 NDP.
 */
#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(push)
	#pragma warning(disable: 4799)
#endif

/*
 * Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output
 */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class I8vec8;			/* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;			/* 8 elements, each element a signed char data type */
class Iu8vec8;			/* 8 elements, each element an unsigned char data type */
class I16vec4;			/* 4 elements, each element a signed or unsigned short */
class Is16vec4;			/* 4 elements, each element a signed short */
class Iu16vec4;			/* 4 elements, each element an unsigned short */
class I32vec2;			/* 2 elements, each element a signed or unsigned long */
class Is32vec2;			/* 2 elements, each element a signed long */
class Iu32vec2;			/* 2 elements, each element a unsigned long */
class I64vec1;			/* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type
 * Contructors & Logical Operations
 */
class M64
{
protected:
		__m64 vec;

public:
	M64()									{ }
	M64(__m64 mm)							{ vec = mm; }
	M64(__int64 mm)							{ _MM_QW = mm; }
	M64(int i)								{ vec = _m_from_int(i); }

	operator __m64() const					{ return vec; }

	/* Logical Operations */
	M64& operator&=(const M64 &a)					{ return *this = (M64) _m_pand(vec,a); }
	M64& operator|=(const M64 &a)					{ return *this = (M64) _m_por(vec,a); }
	M64& operator^=(const M64 &a)					{ return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)	{ return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)	{ return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)	{ return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)		{ return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64
{
public:
	I64vec1()								{ }
	I64vec1(__m64 mm) : M64(mm)				{ }
	EXPLICIT I64vec1(int i) : M64(i)		{ }
	EXPLICIT I64vec1(__int64 mm) : M64(mm)	{ }

	I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
	I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
	I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
	I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

	/* Shift Logical Operations */
	I64vec1 operator<<(const M64 &a)				{ return _m_psllq(vec, a); }
	I64vec1 operator<<(int count) 				    { return _m_psllqi(vec, count); }
	I64vec1& operator<<=(const M64 &a)				{ return *this = (I64vec1) _m_psllq(vec, a); }
	I64vec1& operator<<=(int count) 				{ return *this = (I64vec1) _m_psllqi(vec, count); }
	I64vec1 operator>>(const M64 &a)				{ return _m_psrlq(vec, a); }
	I64vec1 operator>>(int count) 					{ return _m_psrlqi(vec, count); }
	I64vec1& operator>>=(const M64 &a)				{ return *this = (I64vec1) _m_psrlq(vec, a); }
	I64vec1& operator>>=(int count) 				{ return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class:
 * 2 elements, each element either a signed or unsigned int
 */
class I32vec2 : public M64
{
public:
	I32vec2() { }
	I32vec2(__m64 mm) : M64(mm) { }
	EXPLICIT I32vec2(int i) : M64 (i) { }
	EXPLICIT I32vec2(__int64 i): M64(i) {}

	/* Assignment Operator */
	I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

	/* Logical Assignment Operators */
	I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
	I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
	I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec2& operator +=(const I32vec2 &a)			{ return *this = (I32vec2) _m_paddd(vec,a); }
	I32vec2& operator -=(const I32vec2 &a)			{ return *this = (I32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	I32vec2 operator<<(const I32vec2 &a) 			{ return _m_pslld(vec,a); }
	I32vec2 operator<<(int count) 				    { return _m_pslldi(vec,count); }
	I32vec2& operator<<=(const I32vec2 &a)			{ return *this = (I32vec2) _m_pslld(vec,a); }
	I32vec2& operator<<=(int count) 				{ return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* Is32vec2 Class:
 * 2 elements, each element a signed int
 */
class Is32vec2 : public I32vec2
{
public:
	Is32vec2() { }
	Is32vec2(__m64 mm) : I32vec2(mm) { }
	Is32vec2(signed int i0, signed int i1)
	{
		_MM_2DW(0,vec) = i1;
		_MM_2DW(1,vec) = i0;
	}
	EXPLICIT Is32vec2(int i) : I32vec2 (i)		{}
	EXPLICIT Is32vec2(__int64 i): I32vec2(i)	{}

	/* Assignment Operator */
	Is32vec2& operator= (const M64 &a)		{ return *this = (Is32vec2) a; }

	/* Logical Assignment Operators */
	Is32vec2& operator&=(const M64 &a)		{ return *this = (Is32vec2) _m_pand(vec,a); }
	Is32vec2& operator|=(const M64 &a)		{ return *this = (Is32vec2) _m_por(vec,a); }
	Is32vec2& operator^=(const M64 &a)		{ return *this = (Is32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec2& operator +=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_paddd(vec,a); }
	Is32vec2& operator -=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Is32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Is32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Is32vec2& operator<<=(const M64 &a)		{ return *this = (Is32vec2) _m_pslld(vec,a); }
	Is32vec2& operator<<=(int count) 		{ return *this = (Is32vec2) _m_pslldi(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec2 operator>>(const M64 &a) 		{ return _m_psrad(vec, a); }
	Is32vec2 operator>>(int count) 	  		{ return _m_psradi(vec, count); }
	Is32vec2& operator>>=(const M64 &a)		{ return *this = (Is32vec2) _m_psrad(vec, a); }
	Is32vec2& operator>>=(int count) 		{ return *this = (Is32vec2) _m_psradi(vec, count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec2 &a)
	{
		os << " [1]:" << _MM_2DW(1,a)
		<< " [0]:" << _MM_2DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckhdq(a,b); }

/* Iu32vec2 Class:
 * 2 elements, each element unsigned int
 */
class Iu32vec2 : public I32vec2
{
public:
	Iu32vec2() { }
	Iu32vec2(__m64 mm) : I32vec2(mm) { }
	Iu32vec2(unsigned int ui0, unsigned int ui1)
	{
		_MM_2UDW(0,vec) = ui1;
		_MM_2UDW(1,vec) = ui0;
	}

	EXPLICIT Iu32vec2(int i) : I32vec2 (i)		{ }
	EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)	{ }

	/* Assignment Operator */
	Iu32vec2& operator= (const M64 &a)		{ return *this = (Iu32vec2) a; }

	/* Logical Assignment Operators */
	Iu32vec2& operator&=(const M64 &a)		{ return *this = (Iu32vec2) _m_pand(vec,a); }
	Iu32vec2& operator|=(const M64 &a)		{ return *this = (Iu32vec2) _m_por(vec,a); }
	Iu32vec2& operator^=(const M64 &a)		{ return *this = (Iu32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec2& operator +=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_paddd(vec,a); }
	Iu32vec2& operator -=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Iu32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Iu32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Iu32vec2& operator<<=(const M64 &a)		{ return *this = (Iu32vec2) _m_pslld(vec,a); }
	Iu32vec2& operator<<=(int count) 		{ return *this = (Iu32vec2) _m_pslldi(vec,count); }
	Iu32vec2 operator>>(const M64 &a) 		{ return _m_psrld(vec,a); }
	Iu32vec2 operator>>(int count) 			{ return _m_psrldi(vec,count); }
	Iu32vec2& operator>>=(const M64 &a)		{ return *this = (Iu32vec2) _m_psrld(vec,a); }
	Iu32vec2& operator>>=(int count) 		{ return *this = (Iu32vec2) _m_psrldi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec2 &a)
	{
		os << " [1]:" << _MM_2UDW(1,a)
		<< " [0]:" << _MM_2UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* I16vec4 Class:
 * 4 elements, each element either a signed or unsigned short
 */
class I16vec4 : public M64
{
public:
	I16vec4() { }
	I16vec4(__m64 mm) : M64(mm) { }
	EXPLICIT I16vec4(__int64 i) : M64 (i) { }
	EXPLICIT I16vec4(int i) : M64 (i) { }

	/* Assignment Operator */
	I16vec4& operator= (const M64 &a)				{ return *this = (I16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator&=(const M64 &a)				{ return *this = (I16vec4) _m_pand(vec,a); }
	I16vec4& operator|=(const M64 &a)				{ return *this = (I16vec4) _m_por(vec,a); }
	I16vec4& operator^=(const M64 &a)				{ return *this = (I16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator +=(const I16vec4 &a)			{ return *this = (I16vec4)_m_paddw(vec,a); }
	I16vec4& operator -=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psubw(vec,a); }
	I16vec4& operator *=(const I16vec4 &a)			{ return *this = (I16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	I16vec4 operator<<(const I16vec4 &a) 			{ return _m_psllw(vec,a); }
	I16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	I16vec4& operator<<=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psllw(vec,a); }
	I16vec4& operator<<=(int count) 				{ return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b) 	{ return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* Is16vec4 Class:
 * 4 elements, each element signed short
 */
class Is16vec4 : public I16vec4
{
public:
	Is16vec4() { }
	Is16vec4(__m64 mm) : I16vec4(mm) { }
	Is16vec4(short i0, short i1, short i2, short i3)
	{
		_MM_4W(0,vec) = i3;
		_MM_4W(1,vec) = i2;
		_MM_4W(2,vec) = i1;
		_MM_4W(3,vec) = i0;
	}

	EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)	{ }
	EXPLICIT Is16vec4(int i) : I16vec4 (i)		{ }

	/* Assignment Operator */
	Is16vec4& operator= (const M64 &a)		{ return *this = (Is16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator&=(const M64 &a)		{ return *this = (Is16vec4) _m_pand(vec,a); }
	Is16vec4& operator|=(const M64 &a)		{ return *this = (Is16vec4) _m_por(vec,a); }
	Is16vec4& operator^=(const M64 &a)		{ return *this = (Is16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator +=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_paddw(vec,a); }
	Is16vec4& operator -=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_psubw(vec,a); }
	Is16vec4& operator *=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Is16vec4 operator<<(const M64 &a) 		{ return _m_psllw(vec,a); }
	Is16vec4 operator<<(int count) 			{ return _m_psllwi(vec,count); }
	Is16vec4& operator<<=(const M64 &a)		{ return *this = (Is16vec4)_m_psllw(vec,a); }
	Is16vec4& operator<<=(int count) 		{ return *this = (Is16vec4)_m_psllwi(vec,count); }
	/* Shift Arithmetic Operations */
	Is16vec4 operator>>(const M64 &a) 		{ return _m_psraw(vec,a); }
	Is16vec4 operator>>(int count) 			{ return _m_psrawi(vec,count); }
	Is16vec4& operator>>=(const M64 &a)		{ return *this = (Is16vec4) _m_psraw(vec,a); }
	Is16vec4& operator>>=(int count) 		{ return *this = (Is16vec4) _m_psrawi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec4 &a)
	{
		os << "[3]:" << _MM_4W(3,a)
			<< " [2]:" << _MM_4W(2,a)
			<< " [1]:" << _MM_4W(1,a)
			<< " [0]:" << _MM_4W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}

	/* Element Access for Debug */
	short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaddwd(a,b);}


/* Iu16vec4 Class:
 * 4 elements, each element unsigned short
 */
class Iu16vec4 : public I16vec4
{
public:
	Iu16vec4() { }
	Iu16vec4(__m64 mm) : I16vec4(mm) { }
	Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
	{
		_MM_4UW(0,vec) = ui3;
		_MM_4UW(1,vec) = ui2;
		_MM_4UW(2,vec) = ui1;
		_MM_4UW(3,vec) = ui0;
	}
	EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }
	EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }

	/* Assignment Operator */
	Iu16vec4& operator= (const M64 &a)		{ return *this = (Iu16vec4) a; }

	/* Logical Assignment Operators */
	Iu16vec4& operator&=(const M64 &a)		{ return *this = (Iu16vec4) _m_pand(vec,a); }
	Iu16vec4& operator|=(const M64 &a)		{ return *this = (Iu16vec4) _m_por(vec,a); }
	Iu16vec4& operator^=(const M64 &a)		{ return *this = (Iu16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu16vec4& operator +=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_paddw(vec,a); }
	Iu16vec4& operator -=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_psubw(vec,a); }
	Iu16vec4& operator *=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Iu16vec4 operator<<(const M64 &a) 				{ return _m_psllw(vec,a); }
	Iu16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	Iu16vec4& operator<<=(const M64 &a)				{ return *this = (Iu16vec4)_m_psllw(vec,a); }
	Iu16vec4& operator<<=(int count) 				{ return *this = (Iu16vec4)_m_psllwi(vec,count); }
	Iu16vec4 operator>>(const M64 &a) 				{ return _m_psrlw(vec,a); }
	Iu16vec4 operator>>(int count) 				    { return _m_psrlwi(vec,count); }
	Iu16vec4& operator>>=(const M64 &a)				{ return *this = (Iu16vec4) _m_psrlw(vec,a); }
	Iu16vec4& operator>>=(int count) 				{ return *this = (Iu16vec4) _m_psrlwi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu16vec4 &a)
	{
		os << "[3]:" << _MM_4UW(3,a)
			<< " [2]:" << _MM_4UW(2,a)
			<< " [1]:" << _MM_4UW(1,a)
			<< " [0]:" << _MM_4UW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* I8vec8 Class:
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64
{
public:
	I8vec8() { }
	I8vec8(__m64 mm) : M64(mm) { }
	EXPLICIT I8vec8(__int64 i) : M64 (i) { }
	EXPLICIT I8vec8(int i) : M64 (i) { }

	/* Assignment Operator */
	I8vec8& operator= (const M64 &a)		{ return *this = (I8vec8) a; }

	/* Logical Assignment Operators */
	I8vec8& operator&=(const M64 &a)		{ return *this = (I8vec8) _m_pand(vec,a); }
	I8vec8& operator|=(const M64 &a)		{ return *this = (I8vec8) _m_por(vec,a); }
	I8vec8& operator^=(const M64 &a)		{ return *this = (I8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec8& operator +=(const I8vec8 &a)	{ return *this = (I8vec8) _m_paddb(vec,a); }
	I8vec8& operator -=(const I8vec8 &a)	{ return *this = (I8vec8) _m_psubb(vec,a); }
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class:
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8
{
public:
	Is8vec8() { }
	Is8vec8(__m64 mm) : I8vec8(mm) { }
	Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
	 {
		_MM_8B(0,vec) = s7;
		_MM_8B(1,vec) = s6;
		_MM_8B(2,vec) = s5;
		_MM_8B(3,vec) = s4;
		_MM_8B(4,vec) = s3;
		_MM_8B(5,vec) = s2;
		_MM_8B(6,vec) = s1;
		_MM_8B(7,vec) = s0;
	}

	EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Is8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Is8vec8& operator= (const M64 &a)		{ return *this = (Is8vec8) a; }

	/* Logical Assignment Operators */
	Is8vec8& operator&=(const M64 &a)		{ return *this = (Is8vec8) _m_pand(vec,a); }
	Is8vec8& operator|=(const M64 &a)		{ return *this = (Is8vec8) _m_por(vec,a); }
	Is8vec8& operator^=(const M64 &a)		{ return *this = (Is8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec8& operator +=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_paddb(vec,a); }
	Is8vec8& operator -=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is8vec8 &a)
	{
		os << "[7]:" << short(_MM_8B(7,a))
			<< " [6]:" << short(_MM_8B(6,a))
			<< " [5]:" << short(_MM_8B(5,a))
			<< " [4]:" << short(_MM_8B(4,a))
			<< " [3]:" << short(_MM_8B(3,a))
			<< " [2]:" << short(_MM_8B(2,a))
			<< " [1]:" << short(_MM_8B(1,a))
			<< " [0]:" << short(_MM_8B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_psubsb(a,b); }

/* Iu8vec8 Class:
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8
{
public:
	Iu8vec8() { }
	Iu8vec8(__m64 mm) : I8vec8(mm) { }
	Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
	{
		_MM_8UB(0,vec) = s7;
		_MM_8UB(1,vec) = s6;
		_MM_8UB(2,vec) = s5;
		_MM_8UB(3,vec) = s4;
		_MM_8UB(4,vec) = s3;
		_MM_8UB(5,vec) = s2;
		_MM_8UB(6,vec) = s1;
		_MM_8UB(7,vec) = s0;
	}
	EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Iu8vec8& operator= (const M64 &a)		{ return *this = (Iu8vec8) a; }
	/* Logical Assignment Operators */
	Iu8vec8& operator&=(const M64 &a)		{ return *this = (Iu8vec8) _m_pand(vec,a); }
	Iu8vec8& operator|=(const M64 &a)		{ return *this = (Iu8vec8) _m_por(vec,a); }
	Iu8vec8& operator^=(const M64 &a)		{ return *this = (Iu8vec8) _m_pxor(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu8vec8& operator +=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_paddb(vec,a); }
	Iu8vec8& operator -=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UB(7,a))
			<< " [6]:" << unsigned short(_MM_8UB(6,a))
			<< " [5]:" << unsigned short(_MM_8UB(5,a))
			<< " [4]:" << unsigned short(_MM_8UB(4,a))
			<< " [3]:" << unsigned short(_MM_8UB(3,a))
			<< " [2]:" << unsigned short(_MM_8UB(2,a))
			<< " [1]:" << unsigned short(_MM_8UB(1,a))
			<< " [0]:" << unsigned short(_MM_8UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)		{ return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b) 		{ return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); }

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 )))));	\
}
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)

IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)


#undef IVEC_SELECT

inline static void empty(void) 		{ _m_empty(); }

#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(pop)
#endif

#endif // IVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    // General User API

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    // User API
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    // Power User/library API


    /* Init functions */

    // These functions all call _CRT_RTC_INIT
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    // If you're not using the CRT, you have to implement _CRT_RTC_INIT
    // Just return either null, or your error reporting function
    // *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    // Compiler generated calls (unlikely to be used, even by power users...)
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif // _INC_RTCAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\fvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *
 *	File name : fvec.h  Fvec class definitions
 *
 *	Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *
 *	Facilitates an easy transition to compiler intrinsics
 *
 *	or assembly language.
 *
 *	F32vec4:	4 packed single precision
 *				32-bit floating point numbers
*/

#ifndef FVEC_H_INCLUDED
#define FVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <ivec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class F32vec4
{
protected:
   	 __m128 vec;
public:

	/* Constructors: __m128, 4 floats, 1 float */
	F32vec4() {}

	/* initialize 4 SP FP with __m128 data type */
	F32vec4(__m128 m)					{ vec = m;}

	/* initialize 4 SP FPs with 4 floats */
	F32vec4(float f3, float f2, float f1, float f0)		{ vec= _mm_set_ps(f3,f2,f1,f0); }

	/* Explicitly initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec4(float f)	{ vec = _mm_set_ps1(f); }

	/* Explicitly initialize each of 4 SP FPs with same double */
	EXPLICIT F32vec4(double d)	{ vec = _mm_set_ps1((float) d); }

	/* Assignment operations */

	F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

	F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to __m128 */

 	/* Logical Operators */
	friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
	friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
	friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
	friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); }
	friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); }
	friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

	F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
	F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
	F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
	F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }
	F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); }
	F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
	F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

	/* Horizontal Add */
	friend float add_horizontal(F32vec4 &a)
	{
		F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
		return ftemp[0];
	}

	/* Square Root */
	friend F32vec4 sqrt(const F32vec4 &a)		{ return _mm_sqrt_ps(a); }
	/* Reciprocal */
	friend F32vec4 rcp(const F32vec4 &a)		{ return _mm_rcp_ps(a); }
	/* Reciprocal Square Root */
	friend F32vec4 rsqrt(const F32vec4 &a)		{ return _mm_rsqrt_ps(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
	friend F32vec4 rcp_nr(const F32vec4 &a)
	{
		F32vec4 Ra0 = _mm_rcp_ps(a);
		return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */
	friend F32vec4 rsqrt_nr(const F32vec4 &a)
	{
		static const F32vec4 fvecf0pt5(0.5f);
		static const F32vec4 fvecf3pt0(3.0f);
		F32vec4 Ra0 = _mm_rsqrt_ps(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b)
	{ return _mm_cmpeq_ps(a,b);} */
	#define Fvec32s4_COMP(op) \
	friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
		Fvec32s4_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s4_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s4_COMP(le)					// expanded to cmple(a,b)
		Fvec32s4_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s4_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s4_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s4_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s4_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s4_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s4_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s4_COMP

	/* Min and Max */
	friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
	friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec4 &a)
	{
	/* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "[3]:" << *(fp+3)
			<< " [2]:" << *(fp+2)
			<< " [1]:" << *(fp+1)
			<< " [0]:" << *fp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const float& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
	/* Element Access and Modification*/
	float& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)
{ return _mm_movemask_ps(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)
{ a = _mm_loadu_ps(p); }

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)
{ _mm_storeu_ps(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a)
{ _mm_stream_ps(p,a);}

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)
{
	F32vec4 mask = _mm_cmpeq_ps(a,b);
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 	   \
{																\
	F32vec4 mask = _mm_cmp##op##_ps(a,b);						\
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	\
}
Fvec32s4_SELECT(eq)			// generates select_eq(a,b)
Fvec32s4_SELECT(lt)			// generates select_lt(a,b)
Fvec32s4_SELECT(le)			// generates select_le(a,b)
Fvec32s4_SELECT(gt)			// generates select_gt(a,b)
Fvec32s4_SELECT(ge)			// generates select_ge(a,b)
Fvec32s4_SELECT(neq)		// generates select_neq(a,b)
Fvec32s4_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s4_SELECT(nle)		// generates select_nle(a,b)
Fvec32s4_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s4_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits	of each vec of a */
inline int move_mask(const I8vec8 &a)								{ return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)	{ _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)
{

	return _mm_cvtt_ss2si(a);

}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{

	__m64 result;
	result = _mm_cvtt_ps2pi(a);
	return Is32vec2(result);

}

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{

	__m128 result;
	result = _mm_cvt_si2ss(a,i);
	return F32vec4(result);

}

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b)
{

	__m128 result;
	result = _mm_cvt_pi2ps(a,b);
	return F32vec4(result);
}

class F32vec1
{
protected:
   	 __m128 vec;
public:

	/* Constructors: 1 float */
	F32vec1() {}

	F32vec1(int i)		{ vec = _mm_cvt_si2ss(vec,i);};

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(float f)	{ vec = _mm_set_ss(f); }

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(double d)	{ vec = _mm_set_ss((float) d); }

	/* initialize with __m128 data type */
	F32vec1(__m128 m)	{ vec = m; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to float */

 	/* Logical Operators */
	friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
	friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
	friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
	friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
	friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
	friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

	F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
	F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
	F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
	F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
	F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


	/* Square Root */
	friend F32vec1 sqrt(const F32vec1 &a)		{ return _mm_sqrt_ss(a); }
	/* Reciprocal */
	friend F32vec1 rcp(const F32vec1 &a)		{ return _mm_rcp_ss(a); }
	/* Reciprocal Square Root */
	friend F32vec1 rsqrt(const F32vec1 &a)		{ return _mm_rsqrt_ss(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
	friend F32vec1 rcp_nr(const F32vec1 &a)
	{
		F32vec1 Ra0 = _mm_rcp_ss(a);
		return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
	friend F32vec1 rsqrt_nr(const F32vec1 &a)
	{
		static const F32vec1 fvecf0pt5(0.5f);
		static const F32vec1 fvecf3pt0(3.0f);
		F32vec1 Ra0 = _mm_rsqrt_ss(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
	{ return _mm_cmpeq_ss(a,b);} */
	#define Fvec32s1_COMP(op) \
	friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
		Fvec32s1_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s1_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s1_COMP(le)					// expanded to cmple(a,b)
		Fvec32s1_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s1_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s1_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s1_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s1_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s1_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s1_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s1_COMP

	/* Min and Max */
	friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
	friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec1 &a)
	{
	/* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "float:" << *fp;
		return os;
	}
#endif

};

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
	F32vec1 mask = _mm_cmpeq_ss(a,b);
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d) 	   \
{													   \
	F32vec1 mask = _mm_cmp##op##_ss(a,b);						                   \
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));	                                           \
}
Fvec32s1_SELECT(eq)			// generates select_eq(a,b)
Fvec32s1_SELECT(lt)			// generates select_lt(a,b)
Fvec32s1_SELECT(le)			// generates select_le(a,b)
Fvec32s1_SELECT(gt)			// generates select_gt(a,b)
Fvec32s1_SELECT(ge)			// generates select_ge(a,b)
Fvec32s1_SELECT(neq)		// generates select_neq(a,b)
Fvec32s1_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s1_SELECT(nle)		// generates select_nle(a,b)
Fvec32s1_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s1_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
	return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */
#endif /* FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#elif   defined(_M_MRX000)

#if     _MSC_VER >= 1100
#define _setjmpex _setjmpexVfp
#endif

#define setjmp _setjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
#if     defined(_M_MRX000)
_CRTIMP int     __cdecl abs(int);
_CRTIMP double  __cdecl acos(double);
_CRTIMP double  __cdecl asin(double);
_CRTIMP double  __cdecl atan(double);
_CRTIMP double  __cdecl atan2(double, double);
_CRTIMP double  __cdecl cos(double);
_CRTIMP double  __cdecl cosh(double);
_CRTIMP double  __cdecl exp(double);
_CRTIMP double  __cdecl fabs(double);
_CRTIMP double  __cdecl fmod(double, double);
_CRTIMP long    __cdecl labs(long);
_CRTIMP double  __cdecl log(double);
_CRTIMP double  __cdecl log10(double);
_CRTIMP double  __cdecl pow(double, double);
_CRTIMP double  __cdecl sin(double);
_CRTIMP double  __cdecl sinh(double);
_CRTIMP double  __cdecl tan(double);
_CRTIMP double  __cdecl tanh(double);
_CRTIMP double  __cdecl sqrt(double);
#else
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
#endif
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
#if     defined(_M_ALPHA)
        double  __cdecl ceil(double);
        double  __cdecl floor(double);
#else
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
#endif
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if     defined(_M_MRX000)

/* MIPS fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( float );
_CRTIMP float  __cdecl asinf( float );
_CRTIMP float  __cdecl atanf( float );
_CRTIMP float  __cdecl atan2f( float , float );
_CRTIMP float  __cdecl cosf( float );
_CRTIMP float  __cdecl sinf( float );
_CRTIMP float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( float );
_CRTIMP float  __cdecl sinhf( float );
_CRTIMP float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( float );
_CRTIMP float  __cdecl logf( float );
_CRTIMP float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
_CRTIMP float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl hypotf(float, float);

#endif  /* _M_MRX000 */

#if     defined(_M_ALPHA)

/* ALPHA fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl _hypotf(float, float);

#endif  /* _M_ALPHA */

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the stdiostream and stdiobuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>
#include <stdio.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
        stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
        ~stdiobuf();
        int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
        FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {  // note: spec.'d as : public IOS...
public:
        stdiostream(FILE *);
        ~stdiostream();
        stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
        
private:
};

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STDIOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif



#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
namespace std {
        typedef void (__cdecl * new_handler) ();
        _CRTIMP2 new_handler __cdecl set_new_handler(new_handler) throw();
};
using std::new_handler;
using std::set_new_handler;
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the streambuf class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>        // need ios::seek_dir definition

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;        // pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef  _MT
    void setlock() { LockFlg--; }       // <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef  _MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef  _MT
    int LockFlg;                // <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;        // lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (int)(_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (int)(_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (int)(_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STREAMB

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

#ifdef  _M_MRX000
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
_CRTIMP char *  __cdecl _strset(char *, int);
_CRTIMP char *  __cdecl strcpy(char *, const char *);
_CRTIMP char *  __cdecl strcat(char *, const char *);
_CRTIMP int     __cdecl strcmp(const char *, const char *);
_CRTIMP size_t  __cdecl strlen(const char *);
#else
        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#endif
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#if     defined(_M_IA64) || defined(_M_ALPHA)
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\strstrea.h ===
/***
*strstrea.h - definitions/declarations for strstreambuf, strstream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the strstream and strstreambuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER

// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <useoldio.h>
#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
                strstreambuf();
                strstreambuf(int);
                strstreambuf(char *, int, char * = 0);
                strstreambuf(unsigned char *, int, unsigned char * = 0);
                strstreambuf(signed char *, int, signed char * = 0);
                strstreambuf(void * (*a)(long), void (*f) (void *));
                ~strstreambuf();

        void    freeze(int =1);
        char * str();

virtual int     overflow(int);
virtual int     underflow();
virtual streambuf* setbuf(char *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int     sync();         // not in spec.

protected:
virtual int     doallocate();
private:
        int     x_dynamic;
        int     x_bufmin;
        int     _fAlloc;
        int     x_static;
        void * (* x_alloc)(long);
        void    (* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
                istrstream(char *);
                istrstream(char *, int);
                ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
                ostrstream();
                ostrstream(char *, int, int = ios::out);
                ~ostrstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char *  str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {    // strstreambase ???
public:
                strstream();
                strstream(char *, int, int);
                ~strstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;



#elif   defined(_M_MRX000)

#ifndef _INC_SETJMPEX
#if     _MSC_VER >= 1100
#define _setjmp  _setjmpVfp
#endif
#define setjmp  _setjmp
#endif

/*
 * All MIPS implementations need _JBLEN of 16
 */

#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif   defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef  _MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp  _setjmpex /* Alpha should always use setjmp as _setjmpex */
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/*
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
#ifdef _M_ALPHA64
#define _JBFILL 3
    unsigned __int64 Fp;
    unsigned __int64 Pc;
    unsigned __int64 Seb;
    unsigned long Type;
    unsigned long Type_Fill;
#else
#define _JBFILL 5
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
#endif
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[_JBFILL];
} _JUMP_BUFFER;
#undef _JBFILL

#elif   defined(_M_PPC)
/*
 * The Microsoft VC++ V4.0 compiler uses an intrinsic _setjmp.
 * The Motorola C8.5 compiler implements setjmp as a function.
 */

#if     _MSC_VER > 850
#ifndef _INC_SETJMPEX
#undef _setjmp
#define setjmp  _setjmp
#endif
#endif

/*
 * Min length is 240 bytes; round to 256 bytes.
 * Since this is allocated as an array of "double", the
 * number of entries required is 32.
 *
 * All PPC implementations need _JBLEN of 32
 */

#define _JBLEN  32
#define _JBTYPE double

/*
 * Define jump buffer layout for PowerPC setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    unsigned long Gpr1;
    unsigned long Gpr2;
    unsigned long Gpr13;
    unsigned long Gpr14;
    unsigned long Gpr15;
    unsigned long Gpr16;
    unsigned long Gpr17;
    unsigned long Gpr18;
    unsigned long Gpr19;
    unsigned long Gpr20;
    unsigned long Gpr21;
    unsigned long Gpr22;
    unsigned long Gpr23;
    unsigned long Gpr24;
    unsigned long Gpr25;
    unsigned long Gpr26;
    unsigned long Gpr27;
    unsigned long Gpr28;
    unsigned long Gpr29;
    unsigned long Gpr30;
    unsigned long Gpr31;
    unsigned long Cr;
    unsigned long Iar;
    unsigned long Type;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

// Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name.
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;

#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    unsigned long iAReserved[6];

    //
    // x86 C9.0 compatibility
    //

    unsigned long Registration;  // point to the UnwindData field.
    unsigned long TryLevel;      // ignored by setjmp
    unsigned long Cookie;        // set to "VC20" by setjmp
    unsigned long UnwindFunc;    // set to EM longjmp() by setjmp

    //
    // First dword is zero to indicate it's an exception registration
    // record prepared by EM setjmp function.
    // Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
    // EM setjmp.
    // Third dword is set to the setjmp site memory stack frame pointer.
    // Fourth dword is set to the setjmp site backing store frame pointer.
    //

    unsigned long UnwindData[6];

    //
    // floating point status register,
    // and preserved floating point registers fs0 - fs19
    //

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    //
    // return link and preserved branch registers bs0 - bs4
    //

    __int64 StIIP;     // continuation address
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    //
    // preserved general registers s0 - s3, sp, nats
    //

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    //
    // bsp, pfs, unat, lc
    //

    __int64 RsBSP;
    __int64 RsPFS;     // previous frame marker (cfm of setjmp's caller)
    __int64 ApUNAT;    // User Nat collection register (preserved)
    __int64 ApLC;      // loop counter

    __int64 IntSp;     // memory stack pointer
    __int64 IntNats;   // Nat bits of preserved integer regs s0 - s3
    __int64 Preds;     // predicates

} _JUMP_BUFFER;

#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif   defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)_ADDRESSOF(v) + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef  _CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )

#elif   defined(_M_PPC)

/* Microsoft C8 front end (used in Motorola Merged compiler) */
/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
				     _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)


extern void __cdecl __va_start(va_list *, ...);

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\useoldio.h ===
/***
*useoldio.h - force the use of the Microsoft "classic" iostream libraries.
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Generates default library directives for the old ("classic") IOSTREAM
*       libraries.  The exact name of the library specified in the directive
*       depends on the compiler switches (-ML, -MT, -MD, -MLd, -MTd, and -MDd).
*
*       This header file is only included by other header files.
*
*       [Public]
*
****/

#ifndef _USE_OLD_IOSTREAMS
#define _USE_OLD_IOSTREAMS
#ifndef _M_IA64
/*
 * Warning C4995, '_OLD_IOSTREAMS_ARE_DEPRECATED' is a deprecated name, is 
 * being issued because the old I/O Streams headers iostreams.h et al will no
 * longer be supported from VC8.  Replace references such as #include 
 * <iostreams.h> with #include <iostreams>, using the new, more conformant, I/O
 * Streams headers.
 */

#pragma deprecated(_OLD_IOSTREAMS_ARE_DEPRECATED)
extern void _OLD_IOSTREAMS_ARE_DEPRECATED();
#endif  /* _M_IA64 */
#ifdef  _MT
#ifdef  _DLL
#ifdef  _DEBUG
#pragma comment(lib,"msvcirtd")
#else   /* _DEBUG */
#pragma comment(lib,"msvcirt")
#endif  /* _DEBUG */

#else   /* _DLL */
#ifdef  _DEBUG
#pragma comment(lib,"libcimtd")
#else   /* _DEBUG */
#pragma comment(lib,"libcimt")
#endif  /* _DEBUG */
#endif  /* _DLL */

#else   /* _MT */
#ifdef  _DEBUG
#pragma comment(lib,"libcid")
#else   /* _DEBUG */
#pragma comment(lib,"libci")
#endif  /* _DEBUG */
#endif

#endif  /* _USE_OLD_IOSTREAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stl.h ===
// stl.h supplemental header
#pragma once
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque
		: public deque<_Ty, allocator<_Ty> >
	{	// wrap new deque as old
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Deque()
		: deque<_Ty, _Alloc>()
		{	// construct empty deque
		}

	explicit Deque(size_type _Count)
		: deque<_Ty, _Alloc>(_Count, _Ty())
		{	// construct deque from _Count * _Ty()
		}

	Deque(size_type _Count, const _Ty& _Val)
		: deque<_Ty, _Alloc>(_Count, _Val)
		{	// construct deque from _Count * _Val
		}

	typedef const_iterator _Iter;

	Deque(_Iter _First, _Iter _Last)
		: deque<_Ty, _Alloc>(_First, _Last)
		{	// construct deque from [_First, _Last)
		}
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List
		: public list<_Ty, allocator<_Ty> >
	{	// wrap new list as old
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	List()
		: list<_Ty, _Alloc>()
		{	// construct empty list
		}

	explicit List(size_type _Count)
		: list<_Ty, _Alloc>(_Count, _Ty())
		{	// construct list from _Count * _Ty()
		}

	List(size_type _Count, const _Ty& _Val)
		: list<_Ty, _Alloc>(_Count, _Val)
		{	// construct list from _Count * _Val
		}

	typedef const_iterator _Iter;

	List(_Iter _First, _Iter _Last)
		: list<_Ty, _Alloc>(_First, _Last)
		{	// construct list from [_First, _Last)
		}
	};

		// TEMPLATE CLASS Map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Map
		: public map<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new map as old
public:
	typedef Map<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Map()
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Map(const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Map(_Iter _First, _Iter _Last)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Map(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Multimap
		: public multimap<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new multimap as old
public:
	typedef Multimap<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Multimap()
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Multimap(const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Multimap(_Iter _First, _Iter _Last)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Multimap(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Set
template<class _Kty,
	class _Pr = less<_Kty> >
	class Set
		: public set<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new set as old
public:
	typedef Set<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Set()
		: set<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Set(const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Set(_Iter _First, _Iter _Last)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Set(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multiset
template<class _Kty,
	class _Pr = less<_Kty> >
	class Multiset
		: public multiset<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new multiset as old
public:
	typedef Multiset<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Multiset()
		: multiset<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Multiset(const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Multiset(_Iter _First, _Iter _Last)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Multiset(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector
		: public vector<_Ty, allocator<_Ty> >
	{	// wrap new vector as old
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Vector()
		: vector<_Ty, _Alloc>()
		{	// construct empty vector
		}

	explicit Vector(size_type _Count)
		: vector<_Ty, _Alloc>(_Count, _Ty())
		{	// construct vector from _Count * _Ty()
		}

	Vector(size_type _Count, const _Ty& _Val)
		: vector<_Ty, _Alloc>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	Vector(_Iter _First, _Iter _Last)
		: vector<_Ty, _Alloc>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// CLASS bit_vector
class bit_vector
	: public vector<_Bool, _Bool_allocator>
	{	// wrap new vector<bool> as old
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _Alloc;
	typedef bit_vector _Myt;

	bit_vector()
		: vector<_Bool, _Bool_allocator>()
		{	// construct empty vector
		}

	explicit bit_vector(size_type _Count, const _Ty& _Val = _Ty())
		: vector<_Bool, _Bool_allocator>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	bit_vector(_Iter _First, _Iter _Last)
		: vector<_Bool, _Bool_allocator>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// TEMPLATE CLASS priority_queue
template<class _Container,
	class _Pr = less<_Container::value_type> >
	class Priority_queue
		: public priority_queue<_Container::value_type, _Container, _Pr>
	{	// wrap new priority_queue as old
public:
	typedef typename _Container::value_type _Ty;

	Priority_queue()
		: priority_queue<_Ty, _Container, _Pr>(_Pr())
		{	// construct empty queue from defaults
		}

	explicit Priority_queue(const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_Pred)
		{	// construct empty queue from comparator
		}

	typedef const _Ty *_Iter;

	Priority_queue(_Iter _First, _Iter _Last)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pr())
		{	// construct queue from [_First, _Last)
		}

	Priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS queue
template<class _Container>
	class Queue
		: public queue<_Container::value_type, _Container>
	{	// wrap new queue as old
	};

		// TEMPLATE CLASS stack
template<class _Container>
	class Stack
		: public stack<_Container::value_type, _Container>
	{	// wrap new stack as old
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif /* _STL_H_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX 
#define _X_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGE	_CATMASK(_X_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2 int __cdecl _Getdateorder();
_CRTIMP2 char *__cdecl _Getdays();
_CRTIMP2 char *__cdecl _Getmonths();
_CRTIMP2 void *__cdecl _Gettnames();

_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2 float __cdecl _Stof(const char *, char **, long);
_CRTIMP2 double __cdecl _Stod(const char *, char **, long);
_CRTIMP2 long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

		/* return values for _Stopfx/_Stoflt */
#define FL_ERR	0
#define FL_DEC	1
#define FL_HEX	2
#define FL_INF	3
#define FL_NAN	4
#define FL_NEG	8

_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double __cdecl _Atan(double, int);
_CRTIMP2 short __cdecl _Dint(double *, short);
_CRTIMP2 short __cdecl _Dnorm(unsigned short *);
_CRTIMP2 short __cdecl _Dscale(double *, long);
_CRTIMP2 double __cdecl _Dtento(double, long);
_CRTIMP2 short __cdecl _Dunscale(short *, double *);
_CRTIMP2 double __cdecl _Poly(double, const double *, int);

_CRTIMP2 int __cdecl _Stoflt(const char *, char **, long[], int);

extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;

		/* float declarations */
_CRTIMP2 float __cdecl _FAtan(float, int);
_CRTIMP2 short __cdecl _FDint(float *, short);
_CRTIMP2 short __cdecl _FDnorm(unsigned short *);
_CRTIMP2 short __cdecl _FDscale(float *, long);
_CRTIMP2 float __cdecl _FDtento(float, long);
_CRTIMP2 short __cdecl _FDunscale(short *, float *);
_CRTIMP2 float __cdecl _FPoly(float, const float *, int);

extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;

		/* long double functions */
_CRTIMP2 long double __cdecl _LAtan(long double, int);
_CRTIMP2 short __cdecl _LDint(long double *, short);
_CRTIMP2 short __cdecl _LDnorm(unsigned short *);
_CRTIMP2 short __cdecl _LDscale(long double *, long);
_CRTIMP2 long double __cdecl _LDtento(long double, long);
_CRTIMP2 short __cdecl _LDunscale(short *, long double *);
_CRTIMP2 long double __cdecl _LPoly(long double, const long double *, int);

extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL && !STATIC_CPPLIB
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL && !STATIC_CPPLIB

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


#if     defined(_DLL) && defined(_M_IX86)

#define __argc      (*__p___argc())     /* count of cmd line args */
#define __argv      (*__p___argv())     /* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())    /* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())   /* pointer to environment table */
#ifdef  _POSIX_
extern char ** environ;                 /* pointer to environment table */
#else
#define _wenviron   (*__p__wenviron())  /* pointer to wide environment table */
#endif  /* _POSIX_ */
#define _pgmptr     (*__p__pgmptr())    /* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())   /* points to the module (EXE) wide name */

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);


#else

_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

#endif


_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

#if     defined(_M_MRX000)
_CRTIMP int    __cdecl abs(int);
#else
        int    __cdecl abs(int);
#endif
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
#if     defined(_M_MRX000)
_CRTIMP long __cdecl labs(long);
#else
        long __cdecl labs(long);
#endif
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __cdecl _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Log(double, int);
_CRTIMP2 double __cdecl _Sin(double, unsigned int);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FLog(float, int);
_CRTIMP2 float __cdecl _FSin(float, unsigned int);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LLog(long double, int);
_CRTIMP2 long double __cdecl _LSin(long double, unsigned int);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
_CRTIMP2 extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
_C_STD_END
#endif /* _YMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _fstat64(int, struct __stat64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
_CRTIMP int __cdecl _stat64(const char *, struct __stat64 *);
#endif

#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };
#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP void __cdecl _ftime64(struct __timeb64 *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);

_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _utime64(const char *, struct __utimbuf64 *);
_CRTIMP int __cdecl _futime64(int, struct __utimbuf64 *);
_CRTIMP int __cdecl _wutime64(const wchar_t *, struct __utimbuf64 *);
#endif

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

#ifdef  _M_ALPHA
typedef struct {
    char *a0;           /* pointer to first homed integer argument */
    int offset;         /* byte offset of next parameter */
} va_list;
#else
typedef char *va_list;
#endif

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#elif   defined(_M_MRX000)      /* _MIPS_ */


#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]
/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */
extern void * __builtin_va_start(va_list, ...);

#define va_dcl long va_alist;
#define va_start(list) __builtin_va_start(list, va_alist, 0)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#elif   defined(_M_PPC)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (PPC architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
/* this is for LITTLE-ENDIAN PowerPC */

/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)

extern void __cdecl __va_start(va_list *, ...);

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   // stdin
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       // stdout
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP2 wint_t __cdecl btowc(int);
_CRTIMP2 size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP2 size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP2 size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP2 int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64) || defined(_M_ALPHA)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\xmmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * xmmintrin.h
 *
 * Principal header file for Streaming SIMD Extensions intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _MM_FUNCTIONALITY is defined; if it is, the C/x87 implementation
 * will be used (the "faux intrinsics").
 *
 *
 * Note that the m128 datatype provided using _MM2_FUNCTIONALITY mode is
 *   implemented as struct, will not be 128b aligned, will be passed
 *   via the stack, etc.  MM_FUNCTIONALITY mode is not intended for
 *   performance, just semantics.
 *
 */

#ifndef _INCLUDED_MM2
#define _INCLUDED_MM2


/*
 * the m64 type is required for the integer Streaming SIMD Extensions intrinsics
 */
#ifndef _MMINTRIN_H_INCLUDED
#include <mmintrin.h>
#endif

#ifdef _MM2_FUNCTIONALITY
/* support old notation */
#ifndef _MM_FUNCTIONALITY
#define _MM_FUNCTIONALITY
#endif
#endif

#ifdef __ICL
#ifdef _MM_FUNCTIONALITY
#include "xmm_func.h"
#else
/* using real intrinsics */
typedef long long __m128;
#endif
#else

#if _MSC_VER >= 1300
typedef struct __declspec(intrin_type) __declspec(align(16)) __m128 {
    float       m128_f32[4];
} __m128;
#endif

#ifndef _INC_MALLOC
/* pick up _mm_malloc() and _mm_free() */
#include <malloc.h>
#endif
#endif

/*******************************************************/
/* MACRO for shuffle parameter for _mm_shuffle_ps().   */
/* Argument fp3 is a digit[0123] that represents the fp*/
/* from argument "b" of mm_shuffle_ps that will be     */
/* placed in fp3 of result. fp2 is the same for fp2 in */
/* result. fp1 is a digit[0123] that represents the fp */
/* from argument "a" of mm_shuffle_ps that will be     */
/* places in fp1 of result. fp0 is the same for fp0 of */
/* result                                              */
/*******************************************************/
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) (((fp3) << 6) | ((fp2) << 4) | \
                                     ((fp1) << 2) | ((fp0)))


/*******************************************************/
/* MACRO for performing the transpose of a 4x4 matrix  */
/* of single precision floating point values.          */
/* Arguments row0, row1, row2, and row3 are __m128     */
/* values whose elements form the corresponding rows   */
/* of a 4x4 matrix.  The matrix transpose is returned  */
/* in arguments row0, row1, row2, and row3 where row0  */
/* now holds column 0 of the original matrix, row1 now */
/* holds column 1 of the original matrix, etc.         */
/*******************************************************/
#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) {                 \
            __m128 tmp3, tmp2, tmp1, tmp0;                          \
                                                                    \
            tmp0   = _mm_shuffle_ps((row0), (row1), 0x44);          \
            tmp2   = _mm_shuffle_ps((row0), (row1), 0xEE);          \
            tmp1   = _mm_shuffle_ps((row2), (row3), 0x44);          \
            tmp3   = _mm_shuffle_ps((row2), (row3), 0xEE);          \
                                                                    \
            (row0) = _mm_shuffle_ps(tmp0, tmp1, 0x88);              \
            (row1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD);              \
            (row2) = _mm_shuffle_ps(tmp2, tmp3, 0x88);              \
            (row3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD);              \
        }


/* constants for use with _mm_prefetch */
#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

/* (this declspec not supported with 0.A or 0.B) */
#define _MM_ALIGN16 __declspec(align(16))

/* MACRO functions for setting and reading the MXCSR */
#define _MM_EXCEPT_MASK       0x003f
#define _MM_EXCEPT_INVALID    0x0001
#define _MM_EXCEPT_DENORM     0x0002
#define _MM_EXCEPT_DIV_ZERO   0x0004
#define _MM_EXCEPT_OVERFLOW   0x0008
#define _MM_EXCEPT_UNDERFLOW  0x0010
#define _MM_EXCEPT_INEXACT    0x0020

#define _MM_MASK_MASK         0x1f80
#define _MM_MASK_INVALID      0x0080
#define _MM_MASK_DENORM       0x0100
#define _MM_MASK_DIV_ZERO     0x0200
#define _MM_MASK_OVERFLOW     0x0400
#define _MM_MASK_UNDERFLOW    0x0800
#define _MM_MASK_INEXACT      0x1000

#define _MM_ROUND_MASK        0x6000
#define _MM_ROUND_NEAREST     0x0000
#define _MM_ROUND_DOWN        0x2000
#define _MM_ROUND_UP          0x4000
#define _MM_ROUND_TOWARD_ZERO 0x6000

#define _MM_FLUSH_ZERO_MASK   0x8000
#define _MM_FLUSH_ZERO_ON     0x8000
#define _MM_FLUSH_ZERO_OFF    0x0000

#define _MM_SET_EXCEPTION_STATE(mask)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (mask))
#define _MM_GET_EXCEPTION_STATE()                                   \
            (_mm_getcsr() & _MM_EXCEPT_MASK)

#define _MM_SET_EXCEPTION_MASK(mask)                                \
            _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (mask))
#define _MM_GET_EXCEPTION_MASK()                                    \
            (_mm_getcsr() & _MM_MASK_MASK)

#define _MM_SET_ROUNDING_MODE(mode)                                 \
            _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (mode))
#define _MM_GET_ROUNDING_MODE()                                     \
            (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_FLUSH_ZERO_MODE(mode)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (mode))
#define _MM_GET_FLUSH_ZERO_MODE(mode)                               \
            (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * FP, arithmetic
 */

extern __m128 _mm_add_ss(__m128 a, __m128 b);
extern __m128 _mm_add_ps(__m128 a, __m128 b);
extern __m128 _mm_sub_ss(__m128 a, __m128 b);
extern __m128 _mm_sub_ps(__m128 a, __m128 b);
extern __m128 _mm_mul_ss(__m128 a, __m128 b);
extern __m128 _mm_mul_ps(__m128 a, __m128 b);
extern __m128 _mm_div_ss(__m128 a, __m128 b);
extern __m128 _mm_div_ps(__m128 a, __m128 b);
extern __m128 _mm_sqrt_ss(__m128 a);
extern __m128 _mm_sqrt_ps(__m128 a);
extern __m128 _mm_rcp_ss(__m128 a);
extern __m128 _mm_rcp_ps(__m128 a);
extern __m128 _mm_rsqrt_ss(__m128 a);
extern __m128 _mm_rsqrt_ps(__m128 a);
extern __m128 _mm_min_ss(__m128 a, __m128 b);
extern __m128 _mm_min_ps(__m128 a, __m128 b);
extern __m128 _mm_max_ss(__m128 a, __m128 b);
extern __m128 _mm_max_ps(__m128 a, __m128 b);

/*
 * FP, logical
 */

extern __m128 _mm_and_ps(__m128 a, __m128 b);
extern __m128 _mm_andnot_ps(__m128 a, __m128 b);
extern __m128 _mm_or_ps(__m128 a, __m128 b);
extern __m128 _mm_xor_ps(__m128 a, __m128 b);

/*
 * FP, comparison
 */

extern __m128 _mm_cmpeq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpeq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmple_ss(__m128 a, __m128 b);
extern __m128 _mm_cmple_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ps(__m128 a, __m128 b);
extern int _mm_comieq_ss(__m128 a, __m128 b);
extern int _mm_comilt_ss(__m128 a, __m128 b);
extern int _mm_comile_ss(__m128 a, __m128 b);
extern int _mm_comigt_ss(__m128 a, __m128 b);
extern int _mm_comige_ss(__m128 a, __m128 b);
extern int _mm_comineq_ss(__m128 a, __m128 b);
extern int _mm_ucomieq_ss(__m128 a, __m128 b);
extern int _mm_ucomilt_ss(__m128 a, __m128 b);
extern int _mm_ucomile_ss(__m128 a, __m128 b);
extern int _mm_ucomigt_ss(__m128 a, __m128 b);
extern int _mm_ucomige_ss(__m128 a, __m128 b);
extern int _mm_ucomineq_ss(__m128 a, __m128 b);

/*
 * FP, conversions
 */

extern int _mm_cvt_ss2si(__m128 a);
extern __m64 _mm_cvt_ps2pi(__m128 a);
extern int _mm_cvtt_ss2si(__m128 a);
extern __m64 _mm_cvtt_ps2pi(__m128 a);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);

/*
 * FP, misc
 */

extern __m128 _mm_shuffle_ps(__m128 a, __m128 b, unsigned int imm8);
extern __m128 _mm_unpackhi_ps(__m128 a, __m128 b);
extern __m128 _mm_unpacklo_ps(__m128 a, __m128 b);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 a);


/*
 * Integer extensions
 */
extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);

/*
 * memory & initialization
 */

extern __m128 _mm_set_ss(float a);
extern __m128 _mm_set_ps1(float a);
extern __m128 _mm_set_ps(float a, float b, float c, float d);
extern __m128 _mm_setr_ps(float a, float b, float c, float d);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*a);
extern __m128 _mm_load_ps1(float const*a);
extern __m128 _mm_load_ps(float const*a);
extern __m128 _mm_loadr_ps(float const*a);
extern __m128 _mm_loadu_ps(float const*a);
extern void _mm_store_ss(float *v, __m128 a);
extern void _mm_store_ps1(float *v, __m128 a);
extern void _mm_store_ps(float *v, __m128 a);
extern void _mm_storer_ps(float *v, __m128 a);
extern void _mm_storeu_ps(float *v, __m128 a);
extern void _mm_prefetch(char const*a, int sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 a, __m128 b);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);

#ifdef __ICL
extern void* __cdecl _mm_malloc(int siz, int al);
extern void __cdecl _mm_free(void *p);
#endif

/* Alternate intrinsic names definition */
#define _mm_cvtss_si32    _mm_cvt_ss2si
#define _mm_cvtps_pi32    _mm_cvt_ps2pi
#define _mm_cvttss_si32   _mm_cvtt_ss2si
#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
#define _mm_cvtsi32_ss    _mm_cvt_si2ss
#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
#define _mm_extract_pi16  _m_pextrw
#define _mm_insert_pi16   _m_pinsrw
#define _mm_max_pi16      _m_pmaxsw
#define _mm_max_pu8       _m_pmaxub
#define _mm_min_pi16      _m_pminsw
#define _mm_min_pu8       _m_pminub
#define _mm_movemask_pi8  _m_pmovmskb
#define _mm_mulhi_pu16    _m_pmulhuw
#define _mm_shuffle_pi16  _m_pshufw
#define _mm_maskmove_si64 _m_maskmovq
#define _mm_avg_pu8       _m_pavgb
#define _mm_avg_pu16      _m_pavgw
#define _mm_sad_pu8       _m_psadbw
#define _mm_set1_ps       _mm_set_ps1
#define _mm_load1_ps      _mm_load_ps1
#define _mm_store1_ps     _mm_store_ps1

/******************************************************/
/* UTILITY INTRINSICS FUNCTION DEFINITIONS START HERE */
/******************************************************/

/*********************************************************/
/*  NAME : _mm_cvtpi16_ps                                */
/*  DESCRIPTION : Convert 4 16-bit signed integer values */
/*                to 4 single-precision float values     */
/*  IN : __m64 a                                         */
/*  OUT : none                                           */
/*  RETURN : __m128 : (float)a                           */
/*********************************************************/
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_cmpgt_pi16(_mm_setzero_si64(), a);

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/***********************************************************/
/*  NAME : _mm_cvtpu16_ps                                  */
/*  DESCRIPTION : Convert 4 16-bit unsigned integer values */
/*                to 4 single-precision float values       */
/*  IN : __m64 a                                           */
/*  OUT : none                                             */
/*  RETURN : __m128 : (float)a                             */
/***********************************************************/
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi16                             */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 16-bit integer values   */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (short)a                         */
/******************************************************/
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _mm_packs_pi32(_mm_cvtps_pi32(a), 
                        _mm_cvtps_pi32(_mm_movehl_ps(a, a)));
}


/******************************************************/
/*  NAME : _mm_cvtpi8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit integer values to 4 */
/*                single-precision float values       */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _mm_cmpgt_pi8(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_mm_unpacklo_pi8(a, ext_val));
}


/******************************************************/
/*  NAME : _mm_cvtpu8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit unsigned integer    */
/*                values to 4 single-precision float  */
/*                values                              */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_mm_unpacklo_pi8(a, _mm_setzero_si64()));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi8                              */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 8-bit integer values    */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (char)a                          */
/******************************************************/
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _mm_packs_pi16(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


/******************************************************/
/*  NAME : _mm_cvtpi32x2_ps                           */
/*  DESCRIPTION : Convert 4 32-bit integer values     */
/*                to 4 single-precision float values  */
/*  IN : __m64 a : operand 1                          */
/*       __m64 b : operand 2                          */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a,(float)b               */
/******************************************************/
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), 
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
}


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_MM2 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\detab.c ===
/*
**	DETAB - replaces tabs with multiple spaces as appropriate
**		tab width defaults to 8 but may be anything
**		Steve Salisbury 1988-03-09 Wed
**
**	1989 Aug 30 Wed -- arg parsing was wrong
**	1989 Nov 01 Wed 12:00	add selection of non-space fill character
**	1991 Jan 14 Mon 18:20	fix selection of non-space fill character
**	1991 Jan 17 Thu 12:00	change message every 4KB to every 16KB
**				allow command line argument for input file
**				do not use big output buffer if stdout=con
**
**	cl -G2s -Oaltr detab.c -o detab.exr -link slibcr libh /nod:slibce;
**	cl detab -link slibcp libh /nod:slibce, detab;
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>

#define SPACE	' '
#define TAB	'\t'
#define TABWIDTH 8

#define REG register

#define NEWLINE(c)  ( (c) == '\n' || (c) == '\r' || (c) == '\f' )

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  8192
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

static	char	MsgInternalError [ ] = "detab: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "detab: cannot open `%s' for input\n" ;
static	char	MsgWriteError [ ] = "detab: error writing to `%s'\n" ;
static	char	MsgStdin [ ] = "<stdin>" ;
static	char	MsgStdout [ ] = "<stdout>" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;

int main ( int argc , char * * argv )
{
REG int column ;
REG int ch ;
REG int spcount ;
    FILE * input ;
    char * MsgInput ;
    int tabwidth = TABWIDTH ;
    int countflag = 0 ;
    long kilobytes ;
    unsigned bytecount ;
    char * cp ;
    int FillChar = SPACE ;	/* default character to use when detabbing */

    while ( -- argc > 0 && * ( cp = * ++ argv ) == '-' )
    {
	++cp;
	while (*cp)
	{
	    if ( * cp == 'k' )
		++ countflag , ++ cp ;
	    else if ( '0' <= * cp && * cp <= '9' )
	    {
		tabwidth = * cp ++ - '0' ;
		while ( '0' <= * cp && * cp <= '9' )
		    tabwidth = 10 * tabwidth + * cp ++ - '0' ;
	    }
	    else if ( * cp == 'c' )
	    {
		FillChar = * ++ cp ;
		++ cp ;
	    }
	    else
	    {
Usage :
		fprintf ( stderr ,

"Usage: detab [-cX -k -###] [inputfile]\n"
"where ### is the number of colums per tab stop (default=8)\n"
"-k selects progress reports (written to stderr) every 16 Kbytes\n"
"and X is the character to use for tabs (default is space)\n"
) ;

		exit ( 1 ) ;
	    }
	}
    }

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	goto Usage ;

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( _setmode ( _fileno(stdout) , O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( ! _isatty ( _fileno ( stdin ) )
      && setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    kilobytes = bytecount = 0 ;

    column = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == TAB )
	{
	    do
		putchar ( FillChar ) ;
	    while ( ++ column < tabwidth ) ;
	    column = 0 ;
	}
	else {
	    putchar ( ch ) ;
	    if ( NEWLINE(ch) )
		column = 0 ;
	    else if ( ++ column == tabwidth )
		column = 0 ;
	    else if ( column > tabwidth )
	    {
		fprintf ( stderr , MsgInternalError , "" , "column>tabwidth" ) ;
		return 1 ;
	    }
	}

	if ( ++ bytecount >= 16384 )
	{
	    bytecount -= 16384 ;

	    if ( countflag )
		fprintf ( stderr , "%ldK\r" , kilobytes += 16 ) ;

            if ( ferror ( stdout) )
	    {
		fprintf ( stderr , MsgWriteError , MsgStdout ) ;
		return 1 ;
	    }
	}
    }

    if ( ferror ( stdout) || fflush ( stdout ) )
    {
	fprintf ( stderr , MsgWriteError , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\pd.c ===
/*
 * Program:	Recursive Directory listing
 * Author:	Steve Salisbury
 *
 * Last Modified:
 *
 *	1995-03-08 Wed 16:00 PST
 *	**** >>>> Ported to Win32 <<<< ****
 */

#ifdef _WIN32
#define WIN32
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>


#ifdef _DEBUG
int DebugFlag ;
#define	DEBUG(n,x)	if ( DebugFlag & n ) printf x;
#else
#define	DEBUG(n,x)
#endif


#define ISSLASH(ch)	((ch) == '/' || (ch) == '\\')

#define	BL	' '
#define	NAMLEN	8
#define	EXTLEN	3

typedef unsigned char uchar ;
typedef unsigned short ushort ;
typedef unsigned int uint ;
typedef unsigned long ulong ;

#define	ATTRIB_READONLY		0x01
#define	ATTRIB_HIDDEN		0x02
#define	ATTRIB_SYSTEM		0x04
#define	ATTRIB_VOLUMELABEL	0x08
#define	ATTRIB_DIRECTORY	0x10
#define	ATTRIB_ARCHIVE		0x20

#define	ATTRIB_ALL	( ATTRIB_HIDDEN | ATTRIB_SYSTEM | ATTRIB_DIRECTORY )



void PrintFile ( WIN32_FIND_DATA * match ) ;

#define	MAXPATHLENGTH	(_MAX_PATH+4)

char	path [ MAXPATHLENGTH ] ;

char	current_dir [ MAXPATHLENGTH ] ;	/* Current Directory */

int	pathlength ;

uint	clustersize ;
uint	sectorsize ;
uint	availclusters ;
uint	totalclusters ;

int 	numfiles ;
int 	numdirs ;
long	numbytes ;
long	numclusters ;

uint	NewClusterSize ;	/* override actual cluster size */
uint	NewSectorSize ;		/* override actual sector size */

int 	maxwidth = 71 ;	/* Maximum width of an output line */

char	totalstring [] =
	"[ %s files, %s sub-dirs, %s bytes (%s allocated) ]\n" ;

int 	AltNameFlag ;		/* If non-zero, echo 8.3 names as well */
int 	DirOnlyFlag ;		/* If non-zero, only directories are listed */
int 	FileOnlyFlag ;		/* If non-zero, only files are listed */
int		TerseFlag ;			/* If non-zero, output is very terse */
int 	SummaryOnlyFlag ;	/* If non-zero, output ONLY summary information */
int 	NoSummaryFlag ;		/* If non-zero, do not output summary information */

uint	Exclude ;		/* file attributes to excluded from display */
uint	Require ;		/* file attributes to be required for display */


char * VolumeLabel ( char * driveString , unsigned * serialNum ) ;
void PrintDir ( void ) ;
void PrintFile ( WIN32_FIND_DATA * match ) ;
int get_drive ( void ) ;
void get_dir ( char * buffer , int drive ) ;
int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp ) ;
char * PrintWithCommas ( unsigned n ) ;


int main ( int argc , char * * argv )
{
	char	* ap ;		/* ap = *argv when parsing the switch args */
	char	* volume ;
	int 	drive = get_drive ( ) ;
	char	driveString [ _MAX_PATH ] ;
	uint	serialNum ;

	++ argv , -- argc ;

#ifdef _DEBUG
	if ( argc > 0 && argv [ 0 ] [ 0 ] == '-' && argv [ 0 ] [ 1 ] == 'D' )
	{
		char * endptr ;

		DebugFlag = strtoul ( argv [ 0 ] + 2 , & endptr , 0 ) ;
		printf("DebugFlag = 0x%x (%s)\n" , DebugFlag , * argv ) ;

		++ argv , -- argc ;
	}
#endif

	while ( argc > 0 && * ( ap = * argv ) == '-' )
	{
		while ( * ++ ap )
			if ( * ap == 'a' )
			{
				int flag ;

				if ( * ++ ap != '-' && * ap != '=' )
					goto Usage ;

				flag = * ap ;
				while ( * ++ ap )
				{
					if ( * ap == 'a' || * ap == 'A' )
						if ( flag == '-' )
							Exclude |= ATTRIB_ARCHIVE ;
						else
							Require |= ATTRIB_ARCHIVE ;
					else if ( * ap == 'r' || * ap == 'R' )
						if ( flag == '-' )
							Exclude |= ATTRIB_READONLY ;
						else
							Require |= ATTRIB_READONLY ;
					else if ( * ap == 'h' || * ap == 'H' )
						if ( flag == '-' )
							Exclude |= ATTRIB_HIDDEN ;
						else
							Require |= ATTRIB_HIDDEN ;
					else if ( * ap == 's' || * ap == 'S' )
						if ( flag == '-' )
							Exclude |= ATTRIB_SYSTEM ;
						else
							Require |= ATTRIB_SYSTEM ;
					else if ( * ap == '-' || * ap == '=' )
						flag = * ap ;
					else
						goto Usage ;
				}
				
				-- ap ;
			}
			else if ( * ap == 'c' )
			{	/* Use alternate cluster size */
				while ( isdigit ( * ++ ap ) )
					NewClusterSize = NewClusterSize * 10 + * ap - '0' ;
				printf ( "New ClusterSize = %u\n" , NewClusterSize ) ;
				-- ap ;
			}
			else if ( * ap == 'd' )
				/* Print directories but not files */
				++ DirOnlyFlag ;
			else if ( * ap == 'f' )
				/* Print directories but not files */
				++ FileOnlyFlag ;
			else if ( * ap == 's' )
			{	/* Use alternate sector size */
				while ( isdigit ( * ++ ap ) )
					NewSectorSize = NewSectorSize * 10 + * ap - '0' ;
				printf ( "NewSectorSize = %u\n" , NewSectorSize ) ;
				-- ap ;
			}
			else if ( * ap == 'z' )
				/* Display ONLY summary info. */
				++ SummaryOnlyFlag ;
			else if ( * ap == 'Z' )
				/* Display no summary info. */
				++ NoSummaryFlag ;
			else if ( * ap == 't' )
				/* Only file/dir names in output */
				++ TerseFlag ;
			else if ( * ap == 'x' )
				/* Show 8.3 names */
				++ AltNameFlag ;
			else
				goto Usage ;
		-- argc ;
		++ argv ;
	}

	if ( argc > 1 )
	{
Usage:
		puts (
#ifdef _DEBUG
			"usage: pd [-D#] [ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#else
			"usage: pd "    "[ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#endif

			"\twhere path is an optional Path to a directory\n"
#ifdef _DEBUG
			"\t`-D#' means print debugging information (# is a number\n"
			"\t\twhich is interpreted as a bit mask for debug info.)\n"
#endif
			"\t`-d' means print only directory names\n"
			"\t`-f' means print only file names\n"
			"\t`-t' means terse output (only file/directory name)\n"
			"\t`-x' means show 8.3 alternate names after long filenames\n"
			"\t`-z' means output only summary information\n"
			"\t`-Z' means do not output any summary information\n"
			"\t`-a-* means exclude files with attribute(s) * (out of ARHS)\n"
			"\t`-a=* means show only files with attribute(s) *\n"
			"\t        the possible attributes are ARHS\n"
			"\t`-c#' sets logical cluster size to # sectors\n"
			"\t`-s#' sets logical sector size to # bytes\n"
			) ;
		exit ( 1 ) ;
	}

	path [ 0 ] = drive + '@' ;
	path [ 1 ] = ':' ;
	path [ 2 ] = '\\' ;
	path [ 3 ] = '\0' ;

	strcpy ( driveString , path ) ;

	if ( argc == 1 )
	{
		char * arg = argv [ 0 ] ;

		if ( isalpha ( arg [ 0 ] ) && arg [ 1 ] == ':' )
		{
			drive = toupper ( * arg ) ;

			if ( isalpha ( drive ) )
				drive -= 'A' - 1 ;
			else
			{
				fprintf ( stderr , "pd: expected alphabetic character before :\n\t%s\n" , arg ) ;
				exit ( 1 ) ;
			}

			driveString [ 0 ] = path [ 0 ] = * arg ;

			if ( arg [ 2 ] )
				/* Specified Directory & Directory */
				strcpy ( path + 2 , arg + 2 ) ;
			else	/* Specified Drive, Current Directory */
				get_dir ( path + 3 , drive ) ;
		}
		else if ( ISSLASH ( arg [ 0 ] ) && ISSLASH ( arg [ 1 ] ) )
		{
			int n = 2 ;

			/*-
			 * Find the slash that terminates the server name
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected server name plus share point:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			/*-
			 * Find the slash that terminates the share point
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected share point name after server name:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			strcpy ( path , arg ) ;
			strcpy ( driveString , arg ) ;
			driveString [ n ] = '\0' ;
		}
		else	/* Current Drive, Specified Directory */
			strcpy ( path + 2 , arg ) ;
	}
	else	/* Current Drive & Directory */
		get_dir ( path + 3 , drive ) ;

	DEBUG(1, ("path = \"%s\"\n",path))
	DEBUG(1, ("driveString = \"%s\"\n",driveString))

	volume = VolumeLabel ( driveString , & serialNum ) ;

	if ( ! NoSummaryFlag )
	{
		printf ( "Directory %s  " , path ) ;

		if ( * volume )
			printf ( "(Volume = \"%s\", %04X-%04X)\n" , volume ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
		else
			printf ( "(No Volume Label, %04X-%04X)\n" ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
	}
	
	clustersize = get_free ( driveString , & availclusters , & sectorsize ,
		& totalclusters ) ;

	if ( NewClusterSize )
		clustersize = NewClusterSize ;

	if ( NewSectorSize )
		sectorsize = NewSectorSize ;

	if ( ! sectorsize )
	{
		fprintf ( stderr , "pd: warning: assuming 512 bytes/sector.\n" ) ;
		sectorsize = 512 ;
	}

	if ( ! clustersize )
	{
		fprintf ( stderr , "pd: warning: assuming 1 sector/cluster.\n" ) ;
		clustersize = 1 ;
	}

	pathlength = strlen ( path ) ;

	if ( path [ pathlength - 1 ] == '\\' )
		-- pathlength ;	/* Make "\" visible but not present */

	PrintDir ( ) ;

	if ( ! NoSummaryFlag )
		printf ( totalstring , PrintWithCommas ( numfiles ) ,
			PrintWithCommas ( numdirs ) ,
			PrintWithCommas ( numbytes ) ,
			PrintWithCommas ( numclusters * clustersize *
				sectorsize ) ) ;

	return 0 ;
}


/*
 * VolumeLabel -
 *	Get the volume Label
 *	This routine may NOT return NULL
 */

static	char	volume [ _MAX_PATH ] = "12345678901" ;

char * VolumeLabel ( char * driveString , unsigned * pSerialNumber )
{
	uint MaxCompLength ;
	uint FSflags ;

	if ( ! GetVolumeInformation ( driveString , volume , sizeof ( volume ) ,
		pSerialNumber , & MaxCompLength , & FSflags , NULL , 0 ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetVolumeInformation(%s)\n" ,
			GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	DEBUG(2, ("%s: \"%s\" : %04X-%04X; %d c; 0x%X\n",driveString,volume,
		(*pSerialNumber>>16)&0xFFFF,*pSerialNumber&0xFFFF,FSflags))

	return volume ;
}


/*
 * PrintDir -
 *	Print all the files in the current directory
 *	Then recursively print the sub-directories
 *	Ignore the "." and ".." special entries
 */

void PrintDir ( void )
{
	WIN32_FIND_DATA	match ;
	HANDLE handle ;
	int	flag ;

	path [ pathlength ] = '\\' ;
	path [ pathlength + 1 ] = '*' ;
	path [ pathlength + 2 ] = '\0' ;

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(4, ("PrintDir - opening handle %08X (files)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		DEBUG(4, ("PrintDir - FindFirst/NextFile(\"%s\") (files)\n",match.cFileName))

		/* Print everything in the directory except "." and ".." */
		if ( ATTRIB_DIRECTORY & ~ match . dwFileAttributes )
			PrintFile ( & match ) ;

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(4, ("PrintDir - closing handle %08X (files)\n",handle))

	path [ pathlength ] = '\\' ;	/* Restore to "...\*" */

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(8, ("PrintDir - opening handle %08X (dirs)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		char	* cp ;
		int	lensave ;

		DEBUG(8, ("PrintDir - FindFirst/NextFile(\"%s\") (dirs)\n",match.cFileName))

		/* Find all sub-directories except "." and ".." */

		if ( ( match . dwFileAttributes & ATTRIB_DIRECTORY )
		  && strcmp ( match . cFileName , "." )
		  && strcmp ( match . cFileName , ".." ) )
		{
			PrintFile ( & match ) ;

			cp = match . cFileName ;
			lensave = pathlength ;

			/* Add "\dirname" to the current Path */

			path [ pathlength ++ ] = '\\' ;

			while ( path [ pathlength ] = * cp ++ )
				++ pathlength ;

			PrintDir ( ) ;

			path [ pathlength = lensave ] = '\0' ;
		}

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(8, ("PrintDir - closing handle %08X (dirs)\n",handle))
}


/* static	char *	months [ ] = {
/*	"?00" , "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" ,
/*	"Aug" , "Sep" , "Oct" , "Nov" , "Dec" , "?13" , "?14" , "?15" } ;
 */

/* static	char *	weekdays [ ] = {
/*	"Sun" , "Mon" , "Tue" , "Wed" , "Thu" , "Fri" , "Sat" } ;
 */

static	char	monthstarts [ ] =
	/**** Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec */
	{ -1 , 0 , 3 , 3 , 6 , 1 , 4 , 6 , 2 , 5 , 0 , 3 , 5 , -1 , -1 , -1 } ;


/*
 * PrintFile -
 *	Print the information for the file described in "match"
 */

void PrintFile ( WIN32_FIND_DATA * match )
{
	int	year , month , day /* , wkday */ ;
	int	hour , minute , second ;
	long sec , clu ;
	char sizebuf [ 12 ] ;	/* Either size of file or else "****DIR****" */
	FILETIME lftime ;
	SYSTEMTIME systime ;

	/*
	 * If only directories are to be shown, do not list files
	 * and if only files are to be shown, do not list directories
	 */

	if ( ( DirOnlyFlag  && ! ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) )
	||   ( FileOnlyFlag &&	 ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) ) )
		return ;

	/*
	** Check the attribute filters
	*/

	if ( ( match -> dwFileAttributes & Exclude )
	|| ( match -> dwFileAttributes & Require ) != Require )
		return ;

	/*
	** At this point, count this file and its bytes
	*/

	if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
		++ numdirs ;
	else
		++ numfiles ;

	sec = ( match -> nFileSizeLow + sectorsize - 1 ) / sectorsize ;
	clu = ( sec + clustersize - 1 ) / clustersize ;

	numbytes += match -> nFileSizeLow ;
	numclusters += clu ;

	if ( SummaryOnlyFlag )
		return ;

	FileTimeToLocalFileTime ( & match -> ftLastWriteTime , & lftime ) ;
	FileTimeToSystemTime ( & lftime , & systime ) ;

	year = systime . wYear ;
	month = systime . wMonth ;
	day = systime . wDay ;
	hour = systime . wHour ;
	minute = systime . wMinute ;
	second = systime . wSecond ;

	/*
	 * 1980 Jan 01 was a Tuesday (2):
	 *	Add in the day of the month and the month offsets
	 *	Add 1 day for each year since 1980
 	 *	Add 1 for each leap year since 1980
	 */

/*	wkday = 2 + ( day - 1 ) + monthstarts [ month ] +
/*		/* year + leap years before the most recent */
/*		( year - 1980 ) + ( ( year - 1980 ) >> 2 ) +
/*		/* Add in the most recent leap day */
/*		( ( ( year & 3 ) != 0 || month > 2 ) ? 1 : 0 ) ;
/*	wkday %= 7 ;
 */

	if ( TerseFlag )
		printf ( "%s\\%s%s\n" ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ) ;
	else
	{
		char altbuf [ 24 ] ;	/* used to display alternate (8.3) name */

		if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
			strcpy ( sizebuf , "****DIR****" ) ;
		else if ( match -> nFileSizeLow <= 999999999L )
			strcpy ( sizebuf , PrintWithCommas ( match -> nFileSizeLow ) ) ;
		else	/* File too big for 9 digits */
			sprintf ( sizebuf , "%s K" , PrintWithCommas ( ( match -> nFileSizeLow + 1023 ) / 1024 ) ) ;

		if ( AltNameFlag && * match -> cAlternateFileName )
			sprintf ( altbuf , "  [%s]" , match->cAlternateFileName ) ;
		else
			altbuf [ 0 ] = '\0' ;

		printf ( "%11s %04d-%02d-%02d %02d:%02d:%02d %c%c%c%c  %s\\%s%s%s\n" ,
			sizebuf , year , month , day , hour , minute , second ,
			match -> dwFileAttributes & ATTRIB_ARCHIVE  ? 'A' : '-' ,
			match -> dwFileAttributes & ATTRIB_READONLY ? 'R' : '-' ,
			match -> dwFileAttributes & ATTRIB_HIDDEN ? 'H' : '-' ,
			match -> dwFileAttributes & ATTRIB_SYSTEM ? 'S' : '-' ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ,
			altbuf ) ;
	}
}

/*
 * Return the Current Disk Drive (1=A, 2=B, etc.)
 *	Note that DOS uses (0=A,1=B, etc.) for this call
 */

int get_drive ( void )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;
	int drive ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirector\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	drive = toupper ( CurDir [ 0 ] ) - ( 'A' - 1 ) ;

	DEBUG(1, ("get_drive => %d (%c:)\n", drive , CurDir [ 0 ]))

	return drive ;
}


/*
 * Store the Current Directory in the given char buffer
 *	The leading "\" in the path is not stored.
 *	The string is terminated by a null.
 */

void get_dir ( char * buffer , int drive )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirectory\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	strcpy ( buffer , CurDir + 3 ) ;
	DEBUG(1, ("get_dir => \"%s\"\n", buffer ))
}


/*
 * get_free - returns the number of sectors per cluster
 *	and stores the number of available clusters,
 *	the size of a sector (in bytes), and the total
 *	number of clusters on the current drive 
 */

int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp )
{
	unsigned int SectorsPerCluster , BytesPerSector , FreeClusters , Clusters ;

	if ( ! GetDiskFreeSpace ( driveString , & SectorsPerCluster ,
		& BytesPerSector , & FreeClusters , & Clusters ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetDiskFreeSpace ( %s )\n" ,
				GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	* availp = FreeClusters ;
	* totalp = Clusters ;
	* secsizep = BytesPerSector ;

	DEBUG(1, ("get_free => Clusters %d/%d, %d * %d\n",*availp,*totalp,*secsizep,SectorsPerCluster))

	return SectorsPerCluster ;
}


char * PrintWithCommas ( unsigned n )
{
static char buffers [ 16 ] [ 16 ] ;
static int bufnumber ;
	char * p = buffers [ bufnumber ++ % 16 ] ;

	if ( n <= 999 )
		sprintf ( p , "%d" , n ) ;
	else if ( n <= 999999 )
		sprintf ( p , "%d,%03d" , n / 1000 , n % 1000 ) ;
	else if ( n <= 999999999 )
		sprintf ( p , "%d,%03d,%03d" , n / 1000000 , n / 1000 % 1000 , n % 1000 ) ;
	else
		sprintf ( p , "%d,%03d,%03d,%03d" , n / 1000000000 , n / 1000000 % 1000 , n / 1000 % 1000 , n % 1000 ) ;

	return p ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\aliasobj.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include "prodids.h"
#include "version.h"


void
StoreName(PUCHAR sz, PIMAGE_SYMBOL psym, PULONG pcbStrings)
{
    memset((void *)&psym->N.Name, 0, (size_t)sizeof(psym->N.Name));
    if (strlen(sz) <= IMAGE_SIZEOF_SHORT_NAME) {
        strncpy((char *)psym->N.ShortName, (char *)sz, IMAGE_SIZEOF_SHORT_NAME);
    } else {
        psym->N.Name.Long = *pcbStrings;
        *pcbStrings += strlen(sz) + 1;
    }
}


int main(int argc, char **argv)
{
    PUCHAR szFrom, szTo, szFilename;
    FILE *pfile;
    IMAGE_FILE_HEADER hdr;
    IMAGE_SYMBOL sym;
    IMAGE_AUX_SYMBOL aux;
    ULONG cbStrings, foStringTable;
    IMAGE_SECTION_HEADER sec;
    DWORD dwProdid;

    if (argc != 4) {
        printf("usage: ALIASOBJ from-name to-name output-filename\n");
        exit(1);
    }
    szFrom = argv[1];
    szTo = argv[2];
    szFilename = argv[3];

    if ((pfile = fopen(szFilename, "wb")) == NULL) {
        printf("can't open file \"%s\"\n", szFilename);
        exit(1);
    }

    hdr.Machine = IMAGE_FILE_MACHINE_UNKNOWN;
    hdr.NumberOfSections = 1;
    hdr.TimeDateStamp = (DWORD) time(NULL);
    hdr.PointerToSymbolTable = sizeof(hdr) + sizeof(sec);
    hdr.NumberOfSymbols = 4;
    hdr.SizeOfOptionalHeader = 0;
    hdr.Characteristics = 0;

    fwrite(&hdr, sizeof(hdr), 1, pfile);

    // Generate one section header.  This is necessary because of a link bug (vce:182)
    // which fails for .obj's with 0 sections and unknown machine type.
    //
    memset(&sec, 0, sizeof(sec));
    strcpy(sec.Name, ".text");
    sec.Characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
    fwrite(&sec, sizeof(sec), 1, pfile);

    cbStrings = sizeof(ULONG);  // make room for stringtab size

#if     (rmj == 7) && (rmm == 0)

    dwProdid = DwProdidFromProdidWBuild(prodidAliasObj70, rup);

#else

#error  PRODID needs to be assigned

#endif

    memset(sym.N.ShortName, 0, sizeof(sym.N.ShortName));
    strncpy((char *) sym.N.ShortName, symProdIdentName, IMAGE_SIZEOF_SHORT_NAME);
    sym.Value = dwProdid;
    sym.SectionNumber = symProdIdentSection;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = symProdIdentClass;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szTo, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_EXTERNAL;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szFrom, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;
    sym.NumberOfAuxSymbols = 1;
    fwrite(&sym, sizeof(sym), 1, pfile);

    memset(&aux, 0, sizeof(aux));
    aux.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
    aux.Sym.TagIndex = 1;               // symtab index for extern
    fwrite(&aux, sizeof(aux), 1, pfile);

    // Write the string table.
    //
    foStringTable = ftell(pfile);
    fwrite(&cbStrings, sizeof(cbStrings), 1, pfile);
    if (strlen(szTo) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szTo, pfile);
        fputc(0, pfile);
    }
    if (strlen(szFrom) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szFrom, pfile);
        fputc(0, pfile);
    }
    assert(ftell(pfile) - foStringTable == cbStrings);

    fclose(pfile);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\oldnames\weak.asm ===
.386
.model flat, c

extern C alternate:PROC
extern C weak(alternate):PROC

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\include\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#define _CPPLIB_VER	310

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	_MT	/* nontrivial locks if multithreaded */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */
 #else
  #define _TLS_QUAL
 #endif

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif

 #define _HAS_TEMPLATE_PARTIAL_ORDERING	0

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)
   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */
 #endif  /* _CRTIMP2 */

 #if defined(_DLL) && !defined(_STATIC_CPPLIB)
  #define _DLL_CPPLIB
 #endif


 #if (1300 <= _MSC_VER)
  #define _DEPRECATED	__declspec(deprecated)
 #else
  #define _DEPRECATED
 #endif

		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}

  #define _CSTD			::
   #define _C_STD_BEGIN	/* match _STD_BEGIN/END if *.c compiled as C++ */
   #define _C_STD_END

  #define _C_LIB_DECL	extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL }
  #define _EXTERN_C		extern "C" {
  #define _END_EXTERN_C }

 #else /* __cplusplus */
  #define _STD
  #define _STD_BEGIN
  #define _STD_END

  #define _CSTD
  #define _C_STD_BEGIN
  #define _C_STD_END

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _MAX_LOCK		3	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit
class _CRTIMP2 _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD
	explicit _Lockit();	// set default lock
	explicit _Lockit(int);	// set the lock
	~_Lockit();	// clear the lock

private:
	_Lockit(const _Lockit&);				// not defined
	_Lockit& operator=(const _Lockit&);	// not defined

	int _Locktype;
  #else /* _MULTI_THREAD */
   #define _LOCKIT(x)
	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2 _Mutex
	{	// lock under program control
public:
  #if _MULTI_THREAD
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	void *_Mtx;
  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
	_Init_locks();
	~_Init_locks();
 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */ 
	};
_STD_END
 #endif /* __cplusplus */


		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_EXTERN_C
_CRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));
_END_EXTERN_C

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#endif /* _YVALS */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\trailing.c ===
/*
 *	Trailing - strip trailing tabs and blanks from input stream
 *	Assumes no sequence of tabs or spaces is more than MAXWHITE chars long.
 *	This filter also enforces that '\n' is preceeded by '\r'
 *
 *	Last Modified Mon 12 Oct 1987 by Steve Salisbury
 *	1988 Mar 09 Wed (SKS)	Reworked buffering, output counting
 *				check for buffer overflow
 *
 *	cl -Oaltr -G2s trailing.c -o trailing.exr -link slibcr libh /nod:slibce;
 *	cl trailing -link slibcp libh /nod:slibce, trailing;
 */

#define MAXWHITE	4096

#ifndef BIGBUFSIZE
#define BIGBUFSIZE	8192
#endif

#include <stdio.h>
#include <fcntl.h>

#define	REG	register

char InBuf [ BIGBUFSIZE ] ;
char OutBuf [ BIGBUFSIZE ] ;

char	Line [ MAXWHITE ] ;

int main ( int argc , char * * argv )
{
    FILE    * input ;
    FILE    * output ;
    char * inputname ;
    char * outputname ;
REG int     ch ;
REG char    * whiteptr ;
    int     ch_save ;
    int     kbytes = 0 ;
    int     numbytes = 0 ;
    int     countflag = 0 ;
    char    * arg ;

    if ( -1 == _setmode ( _fileno(stdin) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdin)\n" ) ;
	exit ( 1 ) ;
    }

    if ( -1 == _setmode ( _fileno(stdout) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdout)\n" ) ;
	exit ( 1 ) ;
    }

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * * argv == '-' )
    {
	arg = * argv ++ ;
	-- argc ;

	while ( * ++ arg )
	    switch ( * arg )
	    {
	    case 'k' :
		countflag = 1 ;
		break ;
	    default :
		goto Usage;
	    }
    }

    if ( argc > 2 )
    {
Usage:
	fprintf ( stderr , "Usage: trailing [-k] [input [output]]\n" ) ;
	fprintf ( stderr , "`-' for input means use standard input\n" ) ;
	exit ( 1 ) ;
    }

    if ( argc >= 1 && strcmp ( argv [ 0 ] , "-" ) )
    {
	input = fopen ( inputname = argv [ 0 ] , "rb" ) ;
	if ( ! input )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 0 ] ) ;
	    exit ( 2 ) ;
	}
    }
    else
    {
	input = stdin ;
	inputname = "<standard input>" ;
    }

    if ( argc == 2 && strcmp ( argv [ 1 ] , "-" ) )
    {
	output = fopen ( outputname = argv [ 1 ] , "wb" ) ;
	if ( ! output )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 1 ] ) ;
	    exit ( 3 ) ;
	}
    }
    else
    {
	output = stdout ;
	outputname = "<standard output>" ;
    }

    if ( setvbuf ( input , InBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf input)\n" ) ;
	exit ( 1 ) ;
    }

    if ( setvbuf ( output , OutBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf output)\n" ) ;
	exit ( 1 ) ;
    }

    whiteptr = Line ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == '\r' )
	{
	    /*
	    ** '\r' followed by '\n' gets swallowed
	    */
	    if ( ( ch = getc ( input ) ) != '\n' )
	    {
		ungetc ( ch , input ) ; /* pushback */
		ch = '\r' ;
	    }
	    else
		++ numbytes ;
	}

	if ( ch == ' ' || ch == '\t' )
	{
	    * whiteptr ++ = ch ;
	    if ( whiteptr > Line + sizeof ( Line ) )
	    {
		fprintf ( stderr , "trailing: too many spaces/tabs (%d)\n" ,
		     whiteptr - Line ) ;
		exit ( 4 ) ;
	    }
	}
	else if ( ch == '\n' )
	{
	    putc ( '\r' , output ) ;
	    putc ( '\n' , output ) ;
	    whiteptr = Line ;
	}
	else
	{
	    if ( whiteptr != Line )
	    {
		/*
		 * Flush the white space buffer
		 */
		ch_save = ch ;
		ch = whiteptr - Line ;
		whiteptr = Line ;
		do
		    putc ( * whiteptr ++ , output ) ;
		while ( -- ch ) ;
		whiteptr = Line ;
		ch = ch_save ;
	    }
	    putc ( ch , output ) ;
	}

	if ( ++ numbytes >= 4096 )
	{
	    numbytes -= 4096 ;
	    if ( countflag )
		fprintf ( stderr , "%uK\r" , 4 * ++ kbytes ) ;
	}
    }

    if ( fflush ( output ) )
    {
	fprintf ( stderr , "trailing: cannot flush %s\n" , argv [ 1 ] ) ;
	exit ( 4 ) ;
    }

    fclose ( input ) ;
    fclose ( output ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\tolwrupr.c ===
/*
**  TOLWRUPR - translate [a-z] to [A-Z] or vice versa or both (!)
**
**	1994-08-19 Fri - original version, based on DTOX, which translated
**		If the output is the console, case line buffering is used.
**		CR+LF newlines (MS-DOS) to LF-only newlines (XENIX).
**
**	This program (tolwrupr) is equivalent to:
**
**		tolwrupr -L:	tr "[a-z]" "[A-Z]"
**		tolwrupr -U:	tr "[A-Z]" "[a-z]"
**		tolwrupr -X:	tr "[A-Z][a-z]" "[a-z][A-Z]"
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>

#define CR	'\r'
#define LF	'\n'

#define REG register

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  16384
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

int LineBuf;

static	char	MsgInternalError [ ] = "tolwrupr: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "tolwrupr: cannot open `%s' for input\n" ;
static	char	MsgStdin [ ] = "stdin" ;
static	char	MsgStdout [ ] = "stdout" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;
static	char	MsgFflush [ ] = "fflush" ;

static unsigned char map [ 256 ] ;


int main ( int argc , char * * argv ) ;

void Usage ( void ) ;


int main ( int argc , char * * argv )
{
REG int ch ;
    int countflag = 0 ;
    int toupperflag = -1 ;
    unsigned kilobytes ;
    unsigned bytecount ;
    char * MsgInput ;
    FILE * input ;
    char * cp ;

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * ( cp = * argv ) == '-' )
    {
	while ( * ++ cp )
	{
	    if ( * cp == 'k' )
	    {
	        if ( countflag != 0 )
		    Usage ( ) ;

	        countflag = 1 ;
	    }
	    else if ( * cp == 'L' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 0 ;
	    }
	    else if ( * cp == 'U' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 1 ;
	    }
	    else if ( * cp == 'X' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 2 ;
	    }
	    else
	    {
		Usage ( ) ;
	    }
	}

	-- argc ;
	++ argv ;
    }

    /*
     * Either -U or -L must be specified!
     */

    if ( toupperflag == -1 )
	Usage ( ) ;

    for ( ch = 0 ; ch < 256 ; ++ ch )
	map [ ch ] = ch ;

    /*
     * Set the case map
     */

    if ( toupperflag == 1 || toupperflag == 2 )
    {
    	for ( ch = 'a' ; ch <= 'z' ; ++ ch )
	    map [ ch ] -= 'a' - 'A' ;
    }

    if ( toupperflag == 0 || toupperflag == 2 )
    {
    	for ( ch = 'A' ; ch <= 'Z' ; ++ ch )
	    map [ ch ] += 'a' - 'A' ;
    }


    /*
     * Open the Input
     */

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , _O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	Usage ( ) ;

    if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    /* check for the need for line buffering */

    LineBuf = _isatty ( _fileno ( stdout ) ) ;

    /*
     * Process the Input
     */

    kilobytes = bytecount = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	ch = map [ ch ] ;

	putc ( ch , stdout ) ;

	if (ch == '\n' && LineBuf)
	    fflush ( stdout ) ;
	
	if ( countflag )
	    if ( ++ bytecount >= BIGBUFSIZE )
	    {
		bytecount -= BIGBUFSIZE ;
		fprintf ( stderr , "%uK\r" , kilobytes += ( BIGBUFSIZE / 1024 ) ) ;
	    }
    }

    if ( fflush ( stdout ) )
    {
	fprintf ( stderr , MsgInternalError , MsgFflush , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}


void Usage ( void )
{
    fprintf ( stderr ,
	"Usage: tolwrupr [-k] -(L|U|X) [ <InputFile> ]\n"
	"-k means echo progress in kilobytes to stderr\n"
	"-L means map lowercase characters to uppercase (tr \"[A-Z]\" \"[a-z]\")\n"
	"-U means map uppercase characters to lowercase (tr \"[a-z]\" \"[A-Z]\")\n"
	"-X means swap uppercase and lowercase (tr \"[a-z][A-Z]\" \"[A-Z][a-z]\")\n"
	"Exactly one of -L or -U or -X must be specified\n"
	) ;

    exit ( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\errormes.h ===
/***
*Errormes.h - Error / Warning reporting used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Error / Warning reporting used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef ERRORMES_H
#define ERRORMES_H

/* error messages, parameters are strings holding the reason and text of the line that caused the error */
extern void error(char *, char *);

/* warning messages, parameters are strings holding the reason and text of the line that caused the error */
extern void warning(char *, char *);

extern FILE *errorfile;	/* file to output error/warning messages */

#endif /* ERRORMES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\constant.h ===
/***
*Constant.h - Constants used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Constants used by the ifstripper, parser and symbol table
*
*Revision History:
*	09-30-92   MAL  Initial version
*
*******************************************************************************/

#ifndef CONSTANT_H
#define CONSTANT_H

#define TRUE  1
#define FALSE 0 		/* Boolean values */

#define IF          0           /* Tokens for preprocessor statements */
#define ELIF        1           /* These must not be re-ordered */
#define ELSE        2
#define ENDIF       3
#define IFDEF       4
#define IFNDEF      5
#define IF1         6
#define IF2         7
#define IFB         8
#define IFNB        9
#define IFIDN      10
#define IFDIF      11      /* CFW - added */
#define IFE        12      /* CFW - added */
#define maxkeyword 12
#define maxcomment  2      /* number of comment strings */
#define NORMAL    100
#define KEYWORD   101		/* Used only for skipto and copyto */

#define DEFINED    1
#define UNDEFINED  2
#define IGNORE     3
#define NOTPRESENT 4		/* Types of switches (symbols) */

#define MAXNAMELEN     65	/* Maximum length of a switch name */
#define MAXLINELEN    512	/* Maximum input line length */
#define MAXCONDLEN    512	/* Maximum length of a condition */
#define MAXFILENAMELEN 97	/* Maximum file name length */

#endif /* CONSTANT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\wsfdiff.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string>
#include <set>
#include <iostream>
#include <algorithm>
#include <dbghelp.h>

#define F_USE_USH_NAME  0x000001
#define F_OUT_DIFF      0x000002
#define F_OUT_USH       0x000004
#define F_OUT_WCH       0x000008
#define F_OUT_IDEN      0x000010
#define F_OUT_DNAME     0x000020
#define F_OUT_ALL       0x00001e
using namespace std;

int flags = 0;

enum Ext { none, lib, dll};
char tmp[512];

Ext FindExt(const char *Fname)
{
    Fname = strrchr(Fname, '.');
    if ( Fname == NULL)
        return none;
    else if ( !stricmp(Fname, ".Lib"))
         return lib;
    else if ( !stricmp(Fname, ".Dll"))
        return dll;
    else
        return none;
}


char *filter(char* ch, Ext fext)
{
    char *str = strchr(ch, '?');
    return str == NULL ? ch: str;
}


const char* setflags(int argc, char *argv[])
{
    const char *Fname = NULL;
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-' || argv[i][0] == '/')
        {
            for ( int j = 1; argv[i][j] != '\0'; j++)
            {
                switch (argv[i][j])
                {
                case 'u':
                case 'U':
                    flags |= F_OUT_USH;
                    break;
                case 'w':
                case 'W':
                    flags |= F_OUT_WCH;
                    break;
                case 'd':
                case 'D':
                    flags |= F_OUT_DNAME;
                    break;
                case 'i':
                case 'I':
                    flags |= F_OUT_IDEN;
                    break;
                case 'x':
                case 'X':
                    flags |= F_USE_USH_NAME;
                    break;
                default:
                    return NULL;
                }
            }
        }
        else
        {
            if (!Fname)
                Fname = argv[i];
            else
                return NULL;
        }
    }
    if (!(flags & F_OUT_USH) && !(flags & F_OUT_WCH) && !(flags & F_OUT_IDEN))
        flags |= F_OUT_ALL;
    return Fname;
}


void print(string st)
{
    if ( flags & F_OUT_DNAME)
    {
        if (UnDecorateSymbolName( st.c_str(), tmp, 511, 0))
            cout << tmp << '\n';
        else
            cout << st << '\n';
    } else {
        cout << st << '\n';
    }
}

int funccmp(const char *func1, const char *func2)
{
    while (*func1 != 0 && *func2 != 0)
    {
        if ( *func1 == *func2)
            func1++, func2++;
        else if ( func1 == strstr(func1, "_W") && 
                  func2 == strstr(func2, "G"))
            func1 += sizeof("_W"), func2 += sizeof("G");
        else if ( func2 == strstr(func2, "_W") &&
                  func1 == strstr(func1, "G"))
            func2 += sizeof("_W"), func1 += sizeof("G");
        else
            break;
    }
    if (*func1 < *func2)
        return -1;
    else if (*func1 > *func2)
        return 1;
    else
        return 0;
}
int Funccmp(const char *func1, const char *func2)
{
    static char tmp1[512];
    UnDecorateSymbolName(func1, tmp, 511, 0);
    UnDecorateSymbolName(func2, tmp1, 511, 0);
    func1 = tmp;
    func2 = tmp1;

    if (strstr(tmp, "wchar_t") || strstr(tmp, "unsigned short"))
        return 11;
    else if (strstr(tmp1, "wchar_t") || strstr(tmp1, "unsigned short"))
        return 22;
    
    while (*func1 != 0 && *func2 != 0)
    {
        if ( *func1 == *func2)
            func1++, func2++;
        else if ( func1 == strstr(func1, "wchar_t") && 
                  func2 == strstr(func2, "unsigned short"))
            func1 += sizeof("wchar_t"), func2 += sizeof("unsigned short");
        else if ( func2 == strstr(func2, "wchar_t") &&
                  func1 == strstr(func1, "unsigned short"))
            func2 += sizeof("wchar_t"), func1 += sizeof("unsigned short");
        else
            break;
    }
    if (*func1 < *func2)
        return -1;
    else if (*func1 > *func2)
        return 1;
    else
        return 0;
}


int main(int argc, char *argv[])
{
    FILE *phDumpbin;
    Ext Fext;
    const char *Fname;
    int StripLine, i, result;
    char ExeName[256];
    char TmpStr[512];
    char *tch;
    set<string> Sdiff, Wdiff, Iden;


    if (!(Fname = setflags(argc, argv)))
    {
        cout << "Usage : wsfdiff -[options] filename" << endl;
        cout << "-x -X: Use unsigned char as data type in identical functions" << endl;
        cout << "-u -U: Print diff with unsigned short version" << endl;
        cout << "-w -W: Print diff with wchar_t version" << endl;
        cout << "-i -I: Print Identical function" << endl;
        cout << "-d -D: UnDname the function names" << endl;
        cout << "filename can only have be .lib or .dll" << endl;
        return -1;
    }
    strcpy(ExeName, "dumpbin ");
    switch (Fext = FindExt(Fname))
    {
    case dll:
        strcat(ExeName, "-exports ");
        break;
    case lib:
        strcat(ExeName, "-linkermember ");
        break;
    case none:
        return -1;
    }
    strcat(ExeName, Fname);
    phDumpbin = _popen(ExeName, "r");
    
    //Strip header
    if (Fext == dll)
        StripLine = 19;
    else
        StripLine = 18;

    for ( i = 0; i < StripLine; i++)
    {
        fgets(TmpStr, 511, phDumpbin);
        cerr << TmpStr;
    }
    set<string>::iterator spos, wpos;
    while (fgets(TmpStr, 511, phDumpbin))
    {
        tch = filter(TmpStr, Fext);
        tch[strlen(tch) -1] = '\0';
        UnDecorateSymbolName(tch, tmp, 511, 0);
        if (strstr (tmp, "wchar_t"))
        {
            spos = Sdiff.begin();
            result = -1;
            while(spos != Sdiff.end())
            {
                switch(result = funccmp(tch, (*spos).c_str()))
                {
                case 1:
                    ++spos;
                    break;
                case 0:
                    if (flags & F_USE_USH_NAME)
                        Iden.insert(*spos);
                    else
                        Iden.insert(string(tch));
                    Sdiff.erase(spos);
                    break;
                }
                if ( result != 1)
                {
                    break;
                }
            }
            if (result != 0)
                Wdiff.insert(string(tch));
        } else if ( strstr(tmp, "unsigned short"))
        {
            spos = Wdiff.begin();
            result = -1;
            while(spos != Wdiff.end())
            {
                switch(result = funccmp(tch, (*spos).c_str()))
                {
                case 1:
                    ++spos;
                    break;
                case 0:
                    if (flags & F_USE_USH_NAME)
                        Iden.insert(string(tch));
                    else
                        Iden.insert(*spos);
                    Wdiff.erase(spos);
                    break;
                }
                if ( result != 1)
                    break;
            }
            if (result != 0)
                Sdiff.insert(string(tch));
        }
    }
    // final checks for diffs and validity
    for ( wpos = Wdiff.begin(), spos = Sdiff.begin();
          spos != Sdiff.end() && wpos != Wdiff.end();)
    {
        switch(Funccmp((*wpos).c_str(), (*spos).c_str()))
        {
        case 0:
            if (flags & F_USE_USH_NAME)
                Iden.insert(*spos);
            else
                Iden.insert(*wpos);
            spos = Sdiff.erase(spos);
            wpos = Wdiff.erase(wpos);
            break;
        case 1:
            ++spos;
            break;
        case -1:
            ++wpos;
            break;
        case 11:
            wpos = Wdiff.erase(wpos);
            break;
        case 22:
            spos = Sdiff.erase(spos);
        }
    }

    if ( flags & F_OUT_USH)
    {
        cout << "Only Unsigned Short version " << Sdiff.size() << '\n';
        for_each (Sdiff.begin(), Sdiff.end(), print);
        cout <<"-----------------------------------------------------------\n";
    }

    if ( flags & F_OUT_WCH)
    {
        cout << "Only wchar_t versions " << Wdiff.size() << '\n';
        for_each (Wdiff.begin(), Wdiff.end(), print);
        cout <<"-----------------------------------------------------------\n";
    }

    if ( flags & F_OUT_IDEN)
    {
        cout <<"Both the versions are present " << Iden.size() << '\n';
        for_each (Iden.begin(), Iden.end(), print );
        cout <<"-----------------------------------------------------------\n";
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\eval.h ===
/***
*Eval.h - If expression evaluator
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Evaluate complex if expressions
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

/* Take a pointer to workspace for a simplified condition and truth value, and pass in the condition string to simplify */
extern void evaluate(char *, int *, char *);

/* Produce the negative of a truth value,
   !DEFINED    == UNDEFINED
   !UNDEFINED  == DEFINED
   !IGNORE     == IGNORE
   !NOTPRESENT == NOTPRESENT */
extern int negatecondition(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\eval.c ===
/***
*eval.c - if expression evaluator
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	produce truth values and simplified conditions from compound if
*	statements.
*
*Revision History:
*	09-30-92  MAL	Original version
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add support for more operators: == != < > <= >=
*			Add terseflag (-t) to suppress mesgs about directives
*	10-04-94  SKS	Add support for more operators: EQ NE LT GT LE NE
*			@ is an identifier character (e.g., MASM's @Version)
*   01-04-00  GB    Add support for internal crt builds
*
*******************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "eval.h"     /* Header for this module */
#include "symtab.h" 	 /* Symbol table access */
#include "constant.h" /* Constants for tokens etc */
#include "errormes.h" /* Errors and Warning messages */

/* Types */
typedef struct condrec
{
   int truth;
   char *condition;
} condrec, *cond;

/* Global variables */

extern int terseFlag;			/* controls display of forced directives */
extern char **comments;		         /* Language dependent comment strings */
extern int *commlen;                 /* Lengths of above strings */
extern int nonumbers;			     /* allow numeric expressions */
extern enum {NON_CRT = 0, CRT = 1} progtype;

char *operators[] = {
	"!", "(", ")", "||", "&&", "defined" ,
	"==" , "!=" , "<" , ">" , "<=" , ">=" ,
	"EQ" , "NE" , "LT" , "GT" , "LE" , "GE" };
int oplengths[] =   {
	1 , 1 , 1 , 2 , 2 , 7 ,
	2 , 2 , 1 , 1 , 2 , 2 ,
	2 , 2 , 2 , 2 , 2 , 2 };
                                                   /* # significant chars */
#define numoperators 18
	/* These tokens must be in the same order as 'operators' */
#define NOT			0
#define OPENPARENTHESIS		1
#define CLOSEPARENTHESIS	2
#define OR			3
#define AND			4
#define DEFINEDFN		5
#define	EQUALS			6
#define	NOTEQUALS		7
#define	LESSTHAN		8
#define	LESSOREQ		9
#define	GREATERTHAN		10
#define	GREATEROREQ		11
#define	EQUALS_ASM		12
#define	NOTEQUALS_ASM		13
#define	LESSTHAN_ASM		14
#define	LESSOREQ_ASM		15
#define	GREATERTHAN_ASM		16
#define	GREATEROREQ_ASM		17

#define UINT 100
#define ID 101
#define ENDOFLINE 102
#define UNKNOWN 103

/* Global state */
/* String holding input, the current pointer into it, and the current token */
char conditions[MAXLINELEN], *tokenptr, currenttoken[MAXCONDLEN];
int token = -1;

/* Function prototypes */
cond evaluateexpression(void);
cond orexpression(void);
cond andexpression(void);
cond unaryexpression(void);
cond parenthesesexpression(void);
cond atomicexpression(void);
cond createcondition(void);
void destroycondition(cond);
char *createstring(int);
void destroystring(char *);
void gettoken(void);
int issymbolchar(char);

/* CFW - added complex expression warning */
void evalwarn()
{
   warning("cannot parse expression - ignoring", conditions);
}


/*
 *	Comments may be in the input source which contain IFSTRIP Directives:
 *
 *	For C source they should look like:
 *
 *		#if foo>bar !*IFSTRIP=DEF*!		'!' here stands for '/'
 *
 *	and for Assembler source they should look like:
 *
 *		if foo ;;IFSTRIP=UND;;
 *
 *	Note that the directive and an optional preceding blank or tab
 *	are deleted from the input source.  The directive can thus be
 *	followed by a backslash to continue the line, another comment, etc.
 */

static char IfStripCStr[] =
 "/*IFSTRIP="; /* -*IFSTRIP=IGN*- */

static char IfStripAStr[] =
/*0123456789*- -* 0123456789012345 */
 ";;IFSTRIP="; /* ;;IFSTRIP=IGN;; */
	/* IGN may also be DEF or UND */

#define IFSTRIPVALOFF	10
#define IFSTRIPVALEND	13
#define	IFSTRIPVALLEN	15


void evaluate(char *outputstring, int *value, char *inputstring)
{
   int forcevalue = IGNORE;
   cond result;
   strcpy(conditions, inputstring);                /* Prepare the string for tokenising */
   tokenptr = conditions;
   gettoken();                                     /* Read in the first token of input */
   result = evaluateexpression();
   /* check for bad/complex expression */
   if (token != ENDOFLINE)
   {
	  char *adir = NULL;
	  char *cdir = NULL;
	  
	  if(((cdir = strstr(inputstring, IfStripCStr)) && cdir[IFSTRIPVALEND] == '*' && cdir[IFSTRIPVALEND+1] == '/')
	  || ((adir = strstr(inputstring, IfStripAStr)) && adir[IFSTRIPVALEND] == ';' && adir[IFSTRIPVALEND+1] == ';'))
	  {
	  	char *pstr;
		char *ifstr;

		/* fprintf(stderr,"<< evaluate(): (%s)\n", inputstring); */

		pstr = ifstr = ( adir ? adir : cdir ) ;

		/*
		 * Have recognized the /-*-IFSTRIP= directive, interpret its argument
		 * and remove the directive comment from the input/output text.
		 * Back up exactly one white space character (blank or tab) if possible.
		 */

		if(pstr > inputstring && (pstr[-1] == '\t' || pstr[-1] == ' '))
			-- pstr;

		if(!memcmp(ifstr+IFSTRIPVALOFF, "DEF", 3))	/* DEFINED */
			forcevalue = DEFINED;
		else if(!memcmp(ifstr+IFSTRIPVALOFF, "UND", 3))	/* UNDEFINED */
			forcevalue = UNDEFINED;
		else if(memcmp(ifstr+IFSTRIPVALOFF, "IGN", 3))	/* IGNORE */
			warning("cannot recognize IFSTRIP: directive - ignoring", conditions);
		/* else "IGNORE" -- forcevalue is already set by default to IGNORE */

		if(!terseFlag)					
			warning("ifstrip directive forced evaluation", conditions);

		/* remove the directive comment (and preceding blank or tab) from the input line */
		strcpy(pstr, ifstr + IFSTRIPVALLEN);	/* "C" comments have closing -*-/- */

		/* fprintf(stderr,">> evaluate(): (%s)\n", inputstring); */
	  }
	  else
	      evalwarn();

      if (result)
      {
         destroycondition(result);
         result = NULL;
      }
   }
   /* bad/complex expression, return IGNORE and entire expression */
   if (!result)
   {
      *value = forcevalue;
      strcpy(outputstring, inputstring);
      return;
   }
   *value = result -> truth;
   if(!result -> condition)
      * outputstring = '\0';
   else
      strcpy(outputstring, result -> condition);
   /* Convert from internal to external representation */
   destroycondition(result);
}

cond evaluateexpression()
{
   return orexpression();
}

cond orexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = andexpression();
   if (!condition1)
      return NULL;
   while (token == OR)
   {
      gettoken();
      condition2 = andexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:                             /* DEFINED || x == DEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
         case UNDEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* UNDEFINED || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* UNDEFINED || UNDEFINED == UNDEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case IGNORE:                        /* UNDEFINED || IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* IGNORE || UNDEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case IGNORE:                        /* IGNORE || IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" || ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " || ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond andexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = unaryexpression();
   if (!condition1)
      return NULL;
   while (token == AND)
   {
      gettoken();
      condition2 = unaryexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* DEFINED && DEFINED == DEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case UNDEFINED:                     /* DEFINED && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* DEFINED && IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case UNDEFINED:                           /* UNDEFINED && x == UNDEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
        case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE && DEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case UNDEFINED:                     /* IGNORE && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* IGNORE && IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" && ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " && ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond unaryexpression()
{
   cond condition1;
   char *output;
   switch (token)
   {
      case NOT:
         gettoken();
         condition1 = unaryexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition) + 1);
            *output = '!';
            strcpy(output + 1, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         else
            condition1 -> truth = negatecondition(condition1 -> truth);
         break;
      case DEFINEDFN:
         gettoken();
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition)
                                  + (sizeof("defined ") - 1));
            strcpy(output, "defined ");
            strcat(output, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         break;
      default:
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         break;
   }
   return condition1;
}

cond parenthesesexpression()
{
   cond condition1;
   char *output;
   if (token == OPENPARENTHESIS)
   {
      gettoken();
      condition1 = evaluateexpression();
      if (!condition1)
         return NULL;
      if (token != CLOSEPARENTHESIS)
      {
         /* check for bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
      }
      gettoken();
      if ((condition1 -> truth) == IGNORE)
      {
         output = createstring(strlen(condition1 -> condition) + 2);
         *output = '(';
         strcpy(output + 1, condition1 -> condition);
         strcat(output, ")");
         destroystring(condition1 -> condition);
         condition1 -> condition = output;
      }
   }
   else
      condition1 = atomicexpression();
   return condition1;
}

cond atomicexpression()
{
   cond condition1 = createcondition();

   switch (token)
   {
      case UINT:
         if ( progtype == 1)
            condition1 -> truth = DEFINED;
         else
            condition1 -> truth = (atoi(currenttoken) == 0) ? UNDEFINED : DEFINED;
         break;
      case ID:
         condition1 -> truth = lookupsym(currenttoken);
         if ((condition1 -> truth) == NOTPRESENT)
         {
            warning("Switch unlisted - ignoring", currenttoken);
            condition1 -> truth = IGNORE;
         }
         if ((condition1 -> truth) == IGNORE) {
            condition1 -> condition = createstring(strlen(currenttoken));
            strcpy(condition1 -> condition, currenttoken);
         }
         break;
      default:
         /* bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
         break;
   }
   gettoken();
   return condition1;
}

/* Negate condition (MAL) */
__inline int negatecondition(int condvalue)        /* inline for speed */
{
   switch (condvalue)
   {
      case DEFINED:
         return UNDEFINED;
      case UNDEFINED:
         return DEFINED;
      default:
         return condvalue;
   };
}

/* Allocate the memory for an empty condition structure and return a pointer to it */
__inline cond createcondition()
{
   cond retvalue;
   retvalue = (cond) malloc(sizeof(condrec));
   if (retvalue == NULL)
      error("Memory overflow","");
   retvalue -> condition = NULL;
   return retvalue;
}

/* Destroy a condition structure */
__inline void destroycondition(cond condition1)
{
   if (condition1 -> condition)
      free(condition1 -> condition);

   free(condition1);
}

/* Allocate the memory for a string of given length (not including terminator) and return the pointer */
__inline char *createstring(int length)
{
   char *retvalue;
   retvalue = (char *) malloc(length + 1);
   if (retvalue == NULL)
      error("Memory overflow","");
   return retvalue;
}

/* Destroy a string */
__inline void destroystring(char *string)
{
   free(string);
}

int iscomment(char *tokenptr)
{
   int cindex;

   for (cindex = 0; cindex < maxcomment; cindex++)
   {
      if (commlen[cindex] &&
		  !_strnicmp(tokenptr, comments[cindex], commlen[cindex]))
         return TRUE;
   }
   return FALSE;
}

void gettoken()
{
   int numofwhitespace, comparetoken = 0, found = FALSE, isnumber = TRUE;
   char *digitcheck;

   numofwhitespace = strspn(tokenptr, " \t");

   /* CFW - skips comments, assumes comment is last thing on line */
   if (numofwhitespace == (int) strlen(tokenptr))
      token = ENDOFLINE;
   else
   {
      tokenptr += numofwhitespace;
      if (iscomment(tokenptr))
	  {
         token = ENDOFLINE;
	  }
      else
      {

         do
         {
	    if (!_strnicmp(tokenptr, operators[comparetoken], oplengths[comparetoken]))
               found = TRUE;
            else
               comparetoken++;
         } while ( (!found) && (comparetoken < numoperators) );
         if (found)
         {
            tokenptr += oplengths[comparetoken];
            token = comparetoken;
            /* currenttoken is left blank for all but UINTs and IDs */
         }
         else
         {
            digitcheck = tokenptr;
            if (!nonumbers && isdigit(*digitcheck))
            {
               while (isdigit(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               tokenptr = digitcheck;
               token = UINT;
            }
            else if (issymbolchar(*digitcheck))
            {
               while (issymbolchar(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               *(currenttoken + (digitcheck - tokenptr)) = '\0';
               tokenptr = digitcheck;
               token = ID;
            }
            else
               token = UNKNOWN;
         }
      }
   }
}

__inline int issymbolchar(char c)
{
   return (iscsym(c) || (c == '$') || (c == '?') || (c == '@'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\symtab.h ===
/***
*Symtab.h - symbol table storage used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Symbol table storage used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef SYMTAB_H
#define SYMTAB_H

/* read the symbol table from the named switch file */
extern void readsyms(char *);

/* add the named symbol to the table, with the given truth value */
extern void addsym(char *, int);

/* find the truth value for the named symbol */
extern int lookupsym(char *);

/* Check that the named identifier consists of valid characters */
extern int ident_only(char *);

#endif /* SYMTAB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\ifstrip.c ===
/***
*ifstrip.c - Ifdef stripping tool
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Strip in/out conditional code from sources.
*	Refer to ifstrip.doc for more information.
*
*Revision History:
*	??-??-88  PHG	Initial version
*	05-10-90  JCR	Accept .cxx/.hxx files, misc cleanup, etc.
*	09-18-92  MAL	Rewritten to cope with nested IFs, ELIFs etc.
*	09-30-92  MAL	Added support for IF expressions, modularized code
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add terseflag (-t) to suppress mesgs about directives
*	10-05-94  SKS	Fix bug: Add missing space to keyword "ifndef "
*	01-04-99  GB    Added support for internal CRT builds.
*
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <search.h>
#include <direct.h>
#include <io.h>
#include <errno.h>
#include <fcntl.h>
#include "constant.h"                              /* Program constants used by modules */
#include "errormes.h"                              /* Error and warning reporting */
#include "symtab.h"                                /* Symbol table handling */
#include "eval.h"                                  /* If expression evaluation */

/* Global constants */
/* CFW - added ifdef, ifndef asm keywords, added IFE, added IFDIF */
char *syntaxstrings[2][maxkeyword + 1] =
       { {"#if ", "#elif ", "#else ", "#endif ", "#ifdef ", "#ifndef ", "",     "",     "",     "",      "",       "",        "" },
          {"if ",  "",       "else ",  "endif ",  "ifdef ",  "ifndef ",   "if1 ", "if2 ", "ifb ", "ifnb ", "ifidn ", "ifdif ", "ife " } };
       /* Language dependent if constructs, must be in the order c, asm and the keywords in the
          same order as the tokens stored in constant.h - All strings must be followed by a
          space, and those not available in a language should be empty */
int syntaxlengths[2][maxkeyword + 1] = { {3, 5, 5, 6, 6, 7, 0, 0, 0, 0, 0, 0, 0},
                                         {2, 0, 4, 5, 5, 6, 3, 3, 3, 4, 5, 5, 3} };
       /* The lengths of the above strings minus spaces. Unused keywords marked with 0 */

/* CFW - added comment stuff */
char *commentstrings[2][maxcomment] = { {"/* ", "// "}, {"; ",  ""} };      
int commentlengths[2][maxcomment] =   { {2,     2    }, {1,     0} };
      /* must ignore comments in IF statements */

/* Global variables */
int terseFlag = FALSE;			/* TRUE means do not echo forced directives */
int warnings = TRUE;          /* TRUE == print warnings */
int currdir = FALSE;		      /* Put in current dir, use source extension */
int isasm;			            /* TRUE == is assembler file */
char **syntax;   		         /* Language dependent syntax for output / matching */
int *synlen;			         /* Lengths of above strings */
char **comments;		         /* Language dependent comment strings */
int *commlen;                 /* Lengths of above strings */
char extension[5] = ".new";	/* Extension for output file */
FILE *outfile;			         /* Current output file */
char *curr_file;		         /* Name of current input file */
FILE *infile;			         /* Current input file */
FILE *errorfile;			      /* file to output error/warning messages */
int linenum;			         /* Line number of current input file */
int nonumbers;			    	 /* allow numeric expressions */
enum {NOCOMMENT, CSTYLE, CPPSTYLE} commstyle = NOCOMMENT;  /* type of comment to put after #else/#endif */
enum {NON_CRT = 0, CRT=1} progtype = NON_CRT;
char _inputline[MAXLINELEN];

/* Functions */
void setfiletype(char *);
void makenewname(char *, char *);
void usage(void);
void stripprog(void);
void putstring(char *);
void putline(char *);
char *getstring(char *, int, FILE *);
char *cleanse(char *inputstring);
void stripifdef(int, char *);
void definedif(void);
void undefinedif(void);
void undefinedifsubpart(int, char *);
void ignoredif(int, char *);
void ignoredifsubpart(int, char *, char *);
void skipto(int *, char *, int);
void copyto(int *, char *, int);
char *parseline(char *, int *);
void stripif(int, char *);

/* Print message and terminate */
void error(reason, line)
char *reason;
char *line;
{
	fprintf(errorfile, "%s(%d): %s\nfatal error: %s\n\n",
	curr_file, linenum, line, reason);
	exit(1);
}

/* Print message and return */
void warning(reason, line)
char *reason;
char *line;
{
	if (warnings)
		fprintf(errorfile, "%s(%d): %s\nwarning: %s\n\n", curr_file, linenum, line, reason);
}

/* Get a string from the input file, returns as fgets (MAL) */
char *getstring(char *line, int n, FILE *fp)
{
   char *returnvalue;
   int linelength;
   linenum++;
   returnvalue = fgets(line, n, fp);
   if (returnvalue != NULL)
   {
      linelength = strlen(line);
      if (line[linelength-1] == '\n')
         line[linelength-1] = '\0';                /* Strip trailing newline */
      else
         error("Line too long",line);
   }
   strcpy(_inputline, line);
   return returnvalue;
}

/* Put a string to the output file (MAL) */
void putstring(char *string)
{
   if ( fputs(string, outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put a line to the output file (MAL) */
void putline(char *line)
{
   putstring(line);
   if ( fputc('\n', outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put commented line like "#endif //CONDITION" based on comstytle flag
 * keyword = keyword to put
 * condition = condition to put
 */
void putcommentedline(int keyword, char *condition)
{
   if (progtype == CRT) {
       putline(_inputline);
       return;
   }
   putstring(syntax[keyword]);
   switch (commstyle) {
   case CSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" /* ");
     putstring(condition);
	 if (isasm)
	   putline("");
	 else
       putline(" */");
     break;
   case CPPSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" // ");
     putline(condition);
     break;
   case NOCOMMENT:
     putline("");
   }
}

/* Set file type (assembler or C, treat C++ as C) */
/* Language strings added (MAL) */
void setfiletype(filename)
char *filename;
{
	char *p;

	p = strrchr(filename, '.');
	if (p == NULL)
		error("file must have an extension", "");
	if ( (_stricmp(p, ".c")   == 0) || (_stricmp(p, ".h")	== 0) ||
	     (_stricmp(p, ".cpp") == 0) || (_stricmp(p, ".hpp") == 0) ||
	     (_stricmp(p, ".cxx") == 0) || (_stricmp(p, ".hxx") == 0) ||
         (_stricmp(p, ".s") == 0) )
		isasm = FALSE;
	else if  ( (_stricmp(p, ".asm") == 0) || (_stricmp(p, ".inc") == 0) )
		isasm = TRUE;
	else
		error("cannot determine file type", "");
	syntax = syntaxstrings[(isasm) ? 1 : 0];     /* Choose correct set of syntax strings */
	synlen = syntaxlengths[(isasm) ? 1 : 0];     /* and lengths */
   comments = commentstrings[(isasm) ? 1 : 0];  /* Choose correct comment set */
   commlen = commentlengths[(isasm) ? 1 : 0];   /* and lengths */
}

/* Make output file name */
void makenewname(filename, newname)
char *filename, *newname;
{
	char *p;

	if (!currdir) {
		/* put on new extension */
		strcpy(newname, filename);
		p = strrchr(newname, '.');
		if (p == NULL)
			error("file must have an extension", "");
		strcpy(p, extension);
	}
	else {
		/* strip off directory specifier */
		p = strrchr(filename, '\\');
		if (p == NULL)
			error("file must not be in current directory", "");
		strcpy(newname, p+1);
	}
}

/* Strip the ifs within a program or block of program text (MAL) */
void stripprog()
{
   char inputline[MAXLINELEN], *condition;
   int linetype;
   while ( getstring(inputline, MAXLINELEN, infile) != NULL )
   {
      condition = parseline(inputline, &linetype); /* Get the line token and condition pointer */
      switch (linetype)
      {
      case NORMAL:
         putline(inputline);
         break;
      case IFDEF:
      case IFNDEF:
         stripifdef(linetype, condition);
         break;
      case IF:
      case IFE:
         stripif(linetype, condition);
         break;
      case IF1:
      case IF2:
      case IFB:
      case IFNB:
      case IFIDN:
         /* CFW - ignore special assembler directives */
         ignoredif(linetype, condition);
         break;
      default:
         error("Error in program structure - ELSE / ELIF / ENDIF before IF","");
      }
   }
}

// CFW - cleanse condition strings of any trailing junk such as comments
char *cleanse(char *inputstring)
{
	char *linepointer = inputstring;

	while (__iscsym(*linepointer))
      linepointer++;

	*linepointer = '\0';

	return inputstring;
}


/* Strip an if depending on the statement if(n)def and the value of its condition (MAL) */
void stripifdef(int iftype, char *condition)
{
   int condvalue;
   condvalue = lookupsym(cleanse(condition)); /* Find the value of the condition from the symbol table */
   if (iftype == IFNDEF)
      condvalue = negatecondition(condvalue); /* Negate the condition for IFNDEFs */
   switch (condvalue)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif(); /* CFW - changed definedif to undefinedif call */
         break;
      case NOTPRESENT:
         warning("Switch unlisted - ignoring", condition);
         /* Drop through to IGNORE case */
      case IGNORE:
         ignoredif(iftype, condition);
   }
}

void stripif(int linetype, char *condition)
{
   char newcondition[MAXLINELEN];                  /* IGNORE conditions can be MAXLINELEN long */
   int truth;
   evaluate(newcondition, &truth, condition);      /* Get the truth value and new condition. */
   /* CFW - added IFE */
   if (linetype == IFE)
      truth = negatecondition(truth);
   switch (truth)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif();
         break;
      case IGNORE:
         ignoredif(linetype, newcondition);
         break;
   }
}

/* Strip a defined if (MAL) */
void definedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   copyto(&keyword, condition, KEYWORD);           /* Copy up to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)
      skipto(&keyword, condition, ENDIF);          /* Skip forward to the ENDIF if not there already */
}

/* Strip an undefined if (MAL) */
void undefinedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   skipto(&keyword, condition, KEYWORD);           /* Skip to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)                           /* No need to recurse if at ENDIF */
      undefinedifsubpart(keyword, condition);      /* Deal with the ELSE / ELIF */
}

/* Deal with the subparts of an undefined if (MAL) */
void undefinedifsubpart(int keyword, char *condition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXCONDLEN];
   char nextcondition[MAXCONDLEN];
   switch (keyword)
   {
      case ELIF:
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               break;
            case UNDEFINED:
               skipto(&nextkeyword, nextcondition, KEYWORD);
               if (keyword != ENDIF)               /* No need to recurse at ENDIF */
                  undefinedifsubpart(nextkeyword, nextcondition);
               break;
            case IGNORE:
               stripifdef(IFDEF, newcondition);
         }
         break;
      case ELSE:
         copyto(&nextkeyword, nextcondition, ENDIF);
   }
}

/* Strip an ignored if (MAL) */
void ignoredif(int linetype, char *condition)
{
   char *controlcondition;
   int nextkeyword;
   char nextcondition[MAXLINELEN];                 /* IGNORE conditions may be a line long */
   if ( progtype == CRT){
       putline(_inputline);
   } else {
       putstring(syntax[linetype]);                          /* Use IF to cope with any expression */
       putline(condition);
   }
   controlcondition = _strdup(condition);
   copyto(&nextkeyword, nextcondition, KEYWORD);
   ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
   free(controlcondition);
}

/* Deal with the subparts of an ignored if (MAL) */
/* See design document for explanation of actions! */
/* controlcondition is controlling condition of the if */
void ignoredifsubpart(int keyword, char *condition, char *controlcondition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXLINELEN];   /* IGNORE conditions may be a line long */
   char nextcondition[MAXLINELEN];  /* IGNORE conditions may be a line long */
   switch (keyword)
   {
      case ELIF:
         /* CFW - replaced lookupsym with evaluate */
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               putcommentedline(ELSE, controlcondition);              /* ELSIF DEFINED == ELSE */
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               if (progtype == CRT)
                  putline(_inputline);
               else
                  putline(syntax[ENDIF]);
               break;
            case UNDEFINED:                        /* ELSIF UNDEFINED skipped */
               skipto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
               break;
            case IGNORE:
               if ( progtype == CRT)
                  putline(_inputline);
               else {
                  putstring(syntax[ELIF]);            /* ELSIF IGNORED copied like IF */
                  putline(newcondition);
               }
			   controlcondition = _strdup(newcondition);  // new controlling condition.
               copyto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
			   free(controlcondition);
         }
         break;
      case ELSE:
         putcommentedline(ELSE, controlcondition);
         copyto(&nextkeyword, nextcondition, ENDIF);
         putcommentedline(ENDIF, controlcondition);
         break;
      case ENDIF:
         putcommentedline(ENDIF, controlcondition);
   }
}

/* Skip to the target keyword. Returns the keyword found and any condition following it. (MAL) */
void skipto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, ifdepth = 0, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               break;                              /* Ignore a normal line */
            case IFDEF:
            case IFNDEF:
            case IF:
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
            case IFE:
               ifdepth++;
               break;                              /* Register nested if, do not need to test for stripping */
        		case ENDIF:
               if (ifdepth > 0)
               {
                  ifdepth--;                       /* Back up a level if in a nested if */
                  break;
               }
               /* Else drop through to default case */
            default:
               if ( (ifdepth == 0) && ((linetype == target) || (target == KEYWORD)) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return keyword token */
   strcpy(condition, conditioninline);
}

/* Copy to the target keyword. Returns the keyword found and any condition following it.
   Any if statements inside the area being copied are stripped as usual. (MAL) */
void copyto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               putline(currline);                  /* Copy a normal line */
               break;
            case IFDEF:
            case IFNDEF:
               stripifdef(linetype, conditioninline);    /* Strip a nested if(n)def */
               break;
            case IF:
            case IFE:
               stripif(linetype, conditioninline);
               break;
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
               /* CFW - ignore special assembler directives */
               ignoredif(linetype, conditioninline);
               break;
            default:
               if ( (linetype == target) || (target == KEYWORD) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return line token */
   strcpy(condition, conditioninline);
}

/* Parse a line of text returning a condition pointer into the line and placing a line type in
   the integer location supplied (MAL) */
char *parseline(char *inputline, int *linetype)
{
   int numofwhitespace, comparetoken = 0, found = FALSE;
   char *linepointer = inputline;
   numofwhitespace = strspn(inputline, " \t");
   if (*(numofwhitespace + inputline) == '\0')
   {
      *linetype = NORMAL;                          /* Empty line */
      return NULL;
   }
   linepointer += numofwhitespace;
   do
   {
      if (synlen[comparetoken] != 0)
         {
	 if ( (!_strnicmp(linepointer, syntax[comparetoken], (size_t) synlen[comparetoken])) &&
              ( isspace( *(linepointer + synlen[comparetoken]) ) || !*(linepointer + synlen[comparetoken]) ) )
            found = TRUE;
         else
            comparetoken++;
         }
      else
         comparetoken++;
   } while ( (!found) && (comparetoken <= maxkeyword) );
   if (found)
   {
      linepointer += synlen[comparetoken];
      if (*linepointer)
         linepointer += strspn(linepointer, " \t");
      *linetype = comparetoken;
      return linepointer;
   }
   else
   {
      *linetype = NORMAL;
      return NULL;
   }
}

/* Print program usage and quit */
void usage()
{
	fprintf(stderr, "Usage: ifstrip [-n] [-w] [-x[ext]] [-f switchfile] file ...\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    -n  produce no output files\n");
	fprintf(stderr, "    -w  suppresses warning levels\n");
	fprintf(stderr, "    -f  next argument is the switch file\n");
	fprintf(stderr, "    -e  next argument is the error/warning file\n");
	fprintf(stderr, "    -c  comment retained else/endifs with switch condition\n");
	fprintf(stderr, "    -C  save as -C, but C++ style (//) comments\n");
	fprintf(stderr, "    -z  treat numbers (e.g., #if 0) like identifiers\n");
	fprintf(stderr, "    -x  specify extension to use on output files\n");
	fprintf(stderr, "        none means use source extension but put in\n");
	fprintf(stderr, "        current directory (source must be in other dir)\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    file list may contain wild cards\n");
	exit(1);
}



int exclude(struct _finddata_t f_data)
{
    if ( f_data.attrib & _A_SUBDIR )
    {
        printf("%s is a directory\n", f_data.name);
        return 1;
    }
    return 0;
}



void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/* Main program - parse command line, process each file */
void main(argc, argv)
int argc;
char *argv[];
{
	char *errorfilename;
	char *switchfilename = "switches";
	char outfilename[MAXFILENAMELEN];
    int ferrorfile = FALSE;
	int nooutput = FALSE;
	struct _finddata_t f_data;
	long h_find;
    char base_dir[256], curr_dir[256];
    int i;

	for (i = 1; i < argc; ++i) {
		if (argv[i][0] != '-')
			break;
		switch (argv[i][1]) {
		case 'w':
			warnings = FALSE;
			break;
		case 'f':
			++i;
			switchfilename = argv[i];
			break;
		case 't':
			++ terseFlag;
			break;
		case 'z':
		    nonumbers = TRUE;
			break;

      case 'e':
         ++i;
         errorfilename = argv[i];
         ferrorfile = TRUE;
         break;
		case 'x':
			if (argv[i][2] == '\0')
				currdir = TRUE;
			else if (argv[i][2] == '.')
				strncpy(extension, argv[i]+2, 4);
                                /* period was supplied */
			else
				strncpy(extension+1, argv[i]+2, 3);
                                /* period not supplied */
			break;
		case 'n':
			nooutput = TRUE;
			break;
        case 'c':
            commstyle = CSTYLE;
            break;
        case 'C':
            commstyle = CPPSTYLE;
            break;
        case 'a':
            progtype = CRT;
            break;
		default:
			fprintf(errorfile, "unknown switch \"%s\"\n", argv[i]);
			usage();
		}
	}

	if (i >= argc)
		usage();

   if (ferrorfile)
   {
      errorfile = fopen(errorfilename, "a");
      if (errorfile == NULL)
      {
         fprintf(stderr, "cannot open \"%s\" for error, using stderr\n",
                           errorfilename);
         ferrorfile = FALSE;
         errorfile = stderr;
      }
   }
   else
      errorfile = stderr;

	readsyms(switchfilename);

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
	for ( ; i < argc; ++i) {
        gdir(curr_dir, argv[i]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[i], &f_data)) == -1)
			continue;
        do
		{
			if ( exclude(f_data) != 1)
			{
                curr_file = f_data.name;
                linenum = 0;
                setfiletype(curr_file);
                if (nooutput)
                    strcpy(outfilename, "nul");
                else
                    makenewname(curr_file, outfilename);
                infile = fopen(curr_file, "r");
                if (infile == NULL) {
                    printf("%s which is %s is somewhat wrong, and the length is %d\n",f_data.name, strerror(errno),  strlen(f_data.name));
                    error("cannot open file for input", "");
                }
                outfile = fopen(outfilename, "w");
                if (outfile == NULL) {
                    fprintf(stderr, "cannot open \"%s\" for output\n",
                        outfilename);
                    exit(1);
                }
                stripprog();
                fclose(infile);
                fclose(outfile);
            }
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
   if (ferrorfile)
   	fclose(errorfile);

   exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\srcrel\mkclnmkf.c ===
/*
 * MkClnMkf - generates the makefile to cleanse the VC++ v7.0 CRTL sources
 *	in preparation for a Microsoft-internal build of the CRTL.  Those
 *	cleansed sources will also be used for the publicly-released CRTL
 *	source as a part of the VC++ 7.0 retail product.
 *
 * Programmed by Steve Salisbury, 1994-12-07 Wed
 *
 * This program takes 7 arguments:
 *	prefixSrc - path to the raw VC++ 7.0 CRTL sources
 *	prefixDst - path to the partly cleansed VC++ 7.0 CRTL sources
 *	prefixDst2 - path to the final cleansed VC++ 7.0 CRTL sources
 *	inputRaw - a list of raw input files
 *	inputCln - a list of the input files that must be cleansed
 *	output - name of the first output file (may not already exist)
 *	outputRel - name of the second output file (may not already exist)
 *
 * Modified by Steve Salisbury, 1994-12-15 Thu
 *	Restore the crtw32/ and fpw32/ subdirectories
 *	Automate the generation of the directory list
 *
 * Modified 1995-01-16 Mon - take directory list from an input file, too.
 *
 * Modified 1995-01-17 Tue - many changes to make things work when removing
 *	crtw32/ and fpw32/ directories from the target filename paths.
 *
 * Modified 1995-01-18 Wed - The 3 files cleansed with bldmkf.sed should
 *	have that file as an explicit dependency.
 *
 * Modified 1995-01-23 Mon - Add a second output file
 *
 * Modified 1996-06-27 Thu - Fix off by 1 error in list allocation
 *
 * Modified 1997-08-14 Thu (Jamie) - Revved version strings from 4.0 => 6.0
 *
 * Modified 1999-05-16 Sun (PhilipLu) - Removed MAC support
 *
 * Modified 1999-08-02 Mon (PhilipLu) - Revved version strings from 6.0 => 7.0
 *
 * Modified 1999-08-06 Fri (PhilipLu) - Set .RC file names by cmdline switches
 *
 * Modified 1999-10-17 Sun (PhilipLu) - Add -noclean options
 */


/*-
 * Build Version Options
-*/

/* define KEEPDIRS */


/*-
 * Include Header Files
-*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


/*-
 * Define Constants
-*/

#define MAXARGLEN	128

#define	CRTW32	"crtw32\\"

#define	FPW32	"fpw32\\"


/*-
 * Define VERBOSE to get verbose output makefiles
-*/

#ifdef VERBOSE
#define	AT	""
#else
#define	AT	"@"
#endif


#if	defined(_BUILD_IA64)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"ia64"
#elif	defined(_BUILD_ALPHA64)
#define TOOLDIR "..\\libw32\\tools\\alpha"
#define CPUDIR	"alpha64"
#elif	defined(_M_IA64)
#define TOOLDIR "..\\libw32\\tools\\ia64"
#define CPUDIR	"ia64"
#elif	defined(_M_ALPHA64)
#define TOOLDIR "..\\libw32\\tools\\alpha64"
#define CPUDIR	"alpha64"
#elif	defined(_M_IX86)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"intel"
#elif	defined(_M_ALPHA)
#define TOOLDIR "..\\libw32\\tools\\alpha"
#define CPUDIR	"alpha"
#elif	defined(_M_MRX000)
#define TOOLDIR "..\\libw32\\tools\\mips"
#define CPUDIR	"mips"
#elif	defined(_M_PPC)
#define TOOLDIR "..\\libw32\\tools\\ppc"
#define CPUDIR	"ppc"
#endif

#define INTEL_DIR	"intel"

/*-
 * Define Global Variables (Constants)
-*/

#ifndef KEEPDIRS
char fmtRaw2 [ ] =
	"%s%s: %s%s %ssrcrel\\bldmkf.sed\n"
	"\t"	AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;
#endif /* KEEPDIRS */

char fmtRaw [ ] =
	"%s%s: %s%s\n"
	"\t"	AT "echo Copying %s from %s to %s.\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "copy /b %s%s %s%s >nul\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln2 [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem * IFSTRIP is NOT used on .INC assembler include files!\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem " TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "rem del %s%s\n"
	"\t"	AT "rem ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

const char prefixSrc [ ] = "$(SRC)\\" ;

const char prefixDst [ ] = "$(DST)\\" ;

char * * DirList ;

const char * szRcFiles [ 2 ] [ 2 ] [ 3 ] =
{
	{
		{ "msvcirt.rc"   , "msvcprt.rc"   , "msvcrt.rc"   } ,
		{ "msvcirt.rc"   , "msvcprt.rc"   , "msvcrt.rc"   }
	} ,
	{
		{ "sysirt.rc"    , "sysprt.rc"    , "syscrt.rc"   } ,
		{ "sysirt64.rc"  , "sysprt64.rc"  , "syscrt64.rc" }
	}
} ;

/*-
 * Function Declarations (Prototypes)
-*/

int main ( int argc , char * * argv ) ;

void Usage ( void ) ;

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput ) ;

void Progress ( int prefix , char * string , int suffix ) ;

char * SkipFirstDir ( char * string ) ;


/*-
 * Function Definitions (Implementations)
-*/

int main ( int argc , char * * argv )
{
	FILE * inputRaw ;
	FILE * inputCln ;
	FILE * inputDir ;
	FILE * output ;
	FILE * output2 ;
	char lineRaw [ MAXARGLEN ] ;
	char lineCln [ MAXARGLEN ] ;
	char * rvRaw ;
	char * rvCln ;
	char * defaultSrc ;
	char * defaultDst ;
	char * defaultDst2 ;
	char * lineSkip ;
	char * * pDirs ;
	time_t timestamp ;
	struct tm localt ;
	char * * nextArg ;
	int fSysCrt = 0;
	int fCrt64 = 0;
	int fNoClean = 0;

	nextArg = ++ argv ;

	while ( * nextArg != NULL && * * nextArg == '-' )
	{
		if ( strcmp ( * nextArg , "-sys" ) == 0 )
		{
			fSysCrt = 1 ;
		}
		else if ( strcmp ( * nextArg , "-64" ) == 0 )
		{
			fCrt64 = 1 ;
		}
		else if ( strcmp ( * nextArg , "-noclean" ) == 0 )
		{
			fNoClean = 1 ;
		}
		else
		{
			Usage ( ) ;
			exit ( 1 ) ;
		}

		nextArg = ++ argv ;
		-- argc ;
	}

	if ( -- argc != 8 )
	{
		Usage ( ) ;
		exit ( 1 ) ;
	}

	defaultSrc = * nextArg ;
	++ nextArg ;
	defaultDst = * nextArg ;
	++ nextArg ;
	defaultDst2 = * nextArg ;
	++ nextArg ;
	
	if ( ( inputRaw = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputCln = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputDir = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: first output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open first output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output2 = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: second output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output2 = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open second output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	/*-
	 * Read in the list of directories
	-*/

	{
		int numDirs = 0 ;
		int maxNumDirs = 0 ;
		char nextDir [ MAXARGLEN ] ;
		char * pDir ;

		pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;

		while ( pDir )
		{
			if ( numDirs + 1 >= maxNumDirs )
			{
				maxNumDirs += 16 ;
				if ( ! ( DirList = ( char * * ) realloc ( DirList ,
					sizeof ( char * ) * maxNumDirs ) ) )
				{
					fprintf ( stderr ,
						"mkclnmkf: realloc failed (maxNumDirs=%d)\n" ,
							maxNumDirs ) ;

					exit ( 1 ) ;
				}
			}

			DirList [ numDirs ] = _strdup ( nextDir ) ;

			if ( ! DirList [ numDirs ] )
			{
				fprintf ( stderr ,
					"mkclnmkf: strdup failed (nextDir=\"%s\")\n" ,
						nextDir ) ;

				exit ( 1 ) ;
			}

			++ numDirs ;

			pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;
		}

		DirList [ numDirs ] = NULL ;

		{
			int i ;

			fprintf ( stderr , "Reading in directory list...\n" ) ;

			for ( i = 0 ; DirList [ i ] ; ++ i )
				Progress ( '(' , DirList [ i ] , ')' ) ;

			Progress ( '(' , NULL , ')' ) ;
		}
	}

	if ( fclose ( inputDir ) )
	{
		fprintf ( stderr ,
			"mkclnmkf: error closing input file \"%s\"\n" ,
			* nextArg ) ;
	}

	/*
	 * Generate MAKEFILE header comment
	 */

	time ( & timestamp ) ;

	localt = * localtime ( & timestamp ) ;

	fprintf ( output ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy Visual C++ v7.0 C Run-Time Library Source files from the raw\n"
	"# source tree to a directory structure suitable for end user usage\n"
	"# in debugging and modification.  Not all of the VC++ 7.0 CRTL srcs\n"
	"# are provided to end users, but the ones that are 'cleansed' using\n"
	"# an automated process.  Another makefile will copy these cleansed\n"
	"# files to their final directory lay-out.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"files: \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultSrc , defaultDst ) ;


	fprintf ( output2 ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy the cleansed Visual C++ v7.0 C Run-Time Library Source files\n"
	"# to their directory lay-out which will be received by end users.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"dirs:\n"
	"\t" AT "if not exist %s" CPUDIR "\\NUL mkdire %s" CPUDIR "\n"
#if	defined(_BUILD_IA64)
	"\t" AT "if not exist %s" INTEL_DIR "\\NUL mkdire %s" INTEL_DIR "\n"
#endif
	"\t" AT "if not exist %ssys\\NUL mkdire %ssys\n"
	"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n"
	"\t" AT "if not exist %sbuild\\" CPUDIR "\\NUL mkdire %sbuild\\" CPUDIR "\n"
	"\t" AT "if not exist %sbuild\\" CPUDIR "\\bbt\\NUL mkdire %sbuild\\" CPUDIR "\\bbt\n"
	"\n"
	"files: \\\n"
	"\t%s%s \\\n"
	"\t%s%s \\\n"
	"\t%s%s \\\n"
	"\t%smsvcrt40.rc \\\n"
	"\t%smakefile \\\n"
	"\t%smakefile.inc \\\n"
	"\t%smakefile.sub \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultDst , defaultDst2 ,
		/* if not exist ... CPUDIR */
		prefixDst , prefixDst ,
#if	defined(_BUILD_IA64)
		/* if not exist intel */
		prefixDst , prefixDst ,
#endif
		/* if not exist sys */
		prefixDst , prefixDst ,
		/* if not exist build ... */
		prefixDst , prefixDst ,
		prefixDst , prefixDst ,
		prefixDst , prefixDst ,
		/* RC files... */
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 0 ] ,
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ,
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 2 ] ,
		prefixDst ,
		/* makefile.{,inc,sub} */
		prefixDst , prefixDst , prefixDst ) ;

	/*
	 * Generate default ("all") dependecy
	 */

	/*-
	 * First, files that are just copied
	-*/

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 7 ) ;
		}

		if ( ! memcmp ( lineSkip , "stdcpp64\\" , 9 )
		  || ! memcmp ( lineSkip , "stdhpp64\\" , 9 ) )
		{
			/* same goes for stdcpp64 / stdhpp64 */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 9 ) ;
		}

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}
	
	/*-
	 * Second, files that have be cleansed
	-*/

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		lineSkip = lineCln ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		fprintf ( output2 , "\t%s%s \\\n" ,
			prefixDst , SkipFirstDir ( lineSkip ) ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	fprintf ( output ,
		"\n\n# Directory Dependencies:\n\ndirs:\n"
		"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n" ,
			prefixDst , prefixDst ) ;

#ifdef BLDROOTDIR
	/*
	 * Create Root Directory Component by Component
	 *	NOTE: this code assumes prefixDst resembles:
	 *		\msdev\crt\src\
	 */

	{
		char temp [ MAXARGLEN ] ;
		char * prefixSlash ;
		char * prefixNext ;
		int len ;

		strcpy ( temp , prefixDst ) ;
		len = strlen ( temp ) ;

		if ( temp [ len - 1 ] == '\\' )
			temp [ len - 1 ] = '\0' ;

		prefixNext = prefixDst + 1 ;

		while ( prefixSlash = strchr ( prefixNext , '\\' ) )
		{
			temp [ prefixSlash - prefixDst ] = '\0' ;

			fprintf ( output ,
	"\t" AT "if not exist %s\\NUL mkdire %s\n" ,
				temp , temp ) ;

			prefixNext = prefixSlash + 1 ;
			temp [ prefixSlash - prefixDst ] = '\\' ;
		}
	}
#endif /* BLDROOTDIR */

	/*
	 * Create Directories
	 */

	for ( pDirs = DirList ; * pDirs ; ++ pDirs )
	{
		char * targetDir ;

		targetDir = * pDirs ;

#ifndef KEEPDIRS
		if ( ! strcmp ( "crtw32" , targetDir )
		  || ! strcmp ( "fpw32" , targetDir ) )
			continue ;

		if ( ! strncmp ( "crtw32\\" , targetDir , 7 ) )
			targetDir += 7 ;
		else if ( ! strncmp ( "fpw32\\" , targetDir , 6 ) )
			targetDir += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output ,
	"\t" AT "if not exist %s%s\\NUL mkdire %s%s\n" ,
			prefixDst , targetDir ,
			prefixDst , targetDir ,
			prefixDst , targetDir ) ;
	}

	fprintf ( output , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;

	/*
	 * Second output makefile has some special targets
	 */

	fprintf ( output2 , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;
	
	{
		static char * listMkf [ ] =
		{
			"makefile" , "makefile.inc" , "makefile.sub" , NULL
		} ;

		static const char * listSpc [ ] =
		{

			"msvcirt.rc" , "msvcprt.rc" , "msvcrt.rc" ,
			"msvcrt40.rc" , NULL
		} ;

		int i ;

		listSpc [ 0 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 0 ] ;
		listSpc [ 1 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ;
		listSpc [ 2 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 2 ] ;

		for ( i = 0 ; listSpc [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %slibw32\\%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b $** $@ >NUL\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listSpc [ i ] ,
				prefixSrc , listSpc [ i ] ,
				/* echo Copying %s from %s to %s. */
				listSpc [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listSpc [ i ] ,
				prefixDst , listSpc [ i ] ,
				/* copy /b $** $@ >NUL */
				/* attrib +r %s%s */
				prefixDst , listSpc [ i ] ) ;

		for ( i = 0 ; listMkf [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %s%s relmkf.sed\n"
				"\t" AT "echo Copying %s from %s to %s. (using SED)\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "sed -f relmkf.sed %s%s > $@\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listMkf [ i ] ,
				prefixSrc , listMkf [ i ] ,
				/* echo Copying %s from %s to %s. */
				listMkf [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listMkf [ i ] ,
				prefixDst , listMkf [ i ] ,
				/* sed -f relmkf.sed %s%s > $@ */
				prefixSrc , listMkf [ i ] ,
				/* attrib +r %s%s */
				prefixDst , listMkf [ i ] ) ;
	}

	/*
	 * Reset input files for another pass: individual dependencies
	 */

	if ( fseek ( inputRaw , 0L , SEEK_SET )
	  || fseek ( inputCln , 0L , SEEK_SET ) )
	{
		fprintf ( stderr , "mkclnmkf: cannot reset input file(s)\n" ) ;
		exit ( 1 ) ;
	}


	/*
	 * Generate individual dependecies for files that are copied as-is
	 */

	fprintf ( stderr , "Producing copied file dependencies...\n" ) ;

	fprintf ( output , "# Copied File Dependencies:\n\n" ) ;

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;

		if ( ( lineRaw [ 0 ] != 'f'
		  || strcmp ( lineSkip + strlen ( lineSkip ) - 9 , "\\lsources" ) )
		  && strcmp ( "makefile" , lineRaw ) )
#endif /* KEEPDIRS */

			fprintf ( output , fmtRaw ,
				/* %s%s: %s%s */
				prefixDst , lineSkip , prefixSrc , lineRaw ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* copy /b %s%s %s%s */
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#ifndef KEEPDIRS
		else
			fprintf ( output , fmtRaw2 ,
				/* %s%s: %s%s %ssrcrel\\bldmkf.sed */
				prefixDst , lineSkip ,
				prefixSrc , lineRaw , prefixSrc ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s */
				prefixSrc ,
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#endif /* KEEPDIRS */

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ) ;
		}

		if ( ! memcmp ( lineSkip , "stdcpp64\\" , 9 )
		  || ! memcmp ( lineSkip , "stdhpp64\\" , 9 ) )
		{
			/* Same goes for stdcpp64 / stdhpp64 */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 9 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 9 ,
				prefixDst , lineSkip + 9 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 9 ,
				prefixDst , lineSkip + 9 ) ;
		}

		Progress ( '[' , lineRaw , ']' ) ;

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}

	Progress ( '[' , NULL , ']' ) ;

	/*
	 * Generate individual dependecies for files that are cleansed
	 */

	fprintf ( stderr , "Producing cleansed file dependencies...\n" ) ;

	fprintf ( output , "# Cleansed File Dependencies:\n\n" ) ;

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		char * pExt ;
		char pNoExt [ MAXARGLEN ] ;

		lineSkip = lineCln ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		pExt = strrchr ( lineSkip , '.' ) ;

		if ( ! pExt )
		{
			fprintf ( stderr ,
				"Warning: filename has no extension: %s\n" ,
				lineCln ) ;

			pExt = lineSkip + strlen ( pExt ) ;
		}

		strcpy ( pNoExt , lineSkip ) ;
		pNoExt [ pExt - lineSkip ] = '\0' ;

		if ( !fNoClean )

		    /*
		     * .INC files do not get ifstripped - use fmtCln2 for them
		     */

		    fprintf ( output ,
			    strcmp ( ".inc" , pExt ) ? fmtCln : fmtCln2 ,
			    /* %s%s: %scrtw32\%s %ssrcrel\msvc40.if */
			    prefixDst , lineSkip , prefixSrc , lineCln , prefixSrc ,
			    /* echo Cleansing %scrtw32\%s */
			    prefixDst , lineSkip ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* detab < %scrtw32\%s | trailing > ... */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* ifstrip %s\srcrel\msvc40.if %s%s */
			    prefixSrc , prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.TMP *%s */
			    prefixDst , pNoExt , pExt ,
			    /* striphdr -r %s%s */
			    prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.NEW *%s */
			    prefixDst , pNoExt , pExt ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		else

		    /*
		     * -noclean: Just copy, don't cleanse, for development builds
		     */

		    fprintf ( output , fmtRaw ,
			    /* %s%s: %s%s */
			    prefixDst , lineSkip , prefixSrc , lineCln ,
			    /* echo Copying %s from %s to %s */
			    lineSkip , prefixSrc , prefixDst ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* copy /b %s%s %s%s */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		/*
		 * Secondary makefile
		 */

		if ( memcmp ( "libw32" , lineCln , 6 ) )
		{
			char * lineSkipFirst = SkipFirstDir ( lineSkip ) ;

			if ( ! strcmp ( ".asm" , pExt ) &&
			   (  ! memcmp ( "mbstring" , lineSkip , 8 )
			   || ! strcmp ( "memmove.asm" , pExt - 7 )
			   || ! strcmp ( "strcspn.asm" , pExt - 7 )
			   || ! strcmp ( "strpbrk.asm" , pExt - 7 ) )
			  || ! strcmp ( ".c" , pExt ) &&
			   (  ! strcmp ( "mbscat.c" , pExt - 6 )
			   || ! strcmp ( "mbsdup.c" , pExt - 6 ) ) )
				fprintf ( output2 ,
					"%s%s: %s%s asmfile.sed\n"
					"\t" AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "sed -f asmfile.sed %s%s > $@\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s asmfile.sed */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* echo Copying %s from %s to %s... */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* sed -f asmfile.sed %s%s > $@ */
					prefixSrc , lineSkip ,
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
			else
				fprintf ( output2 ,
					"%s%s: %s%s\n"
					"\t" AT "echo Copying %s from %s to %s.\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "copy /b $** $@ >NUL\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* Copying %s from %s to %s */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* copy /b $** $@ >NUL */
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
		}
	
		/*
		 * Show Progress 
		 */

		Progress ( '{' , lineSkip , '}' ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	Progress ( '{' , NULL , '}' ) ;

	return 0 ;
}


/*
 * Usage - print message explaining the arguments to this program
 */

void Usage ( void )
{
	fprintf ( stderr ,
	"Usage: mkclnmkf [opts] prefIn prefOut prefOut2 fRaw fCln dirList mkfOut mkfOut2\n"
	"where\tprefIn is the input prefix (such as \"\\crt\")\n"
	"\tprefOut is the primary output prefix (such as \"\\msdev\\crt\\prebuild\")\n"
	"\tprefOut2 is the secondary output prefix (such as \"\\msdev\\crt\\src\")\n"
	"\tfRaw is a list of files to be copied as-is\n"
	"\tfCln is a list of files to be cleansed\n"
	"\tdirList is a list of the directories to be created\n"
	"\tmkfOut is the primary output makefile (it may not already exist)\n"
	"\tmkfOut2 is the secondary output makefile (it may not already exist)\n\n"
	"\tOptions:\n"
	"\t  -sys\t\tuse system CRT filenames\n"
	"\t  -64\t\tuse Win64 CRT filenames\n"
	"\t  -noclean\tdon't cleanse source files\n"
	) ;
}


/*
 * fgetsNL - same as fgets except final newline character is deleted
 *	Upon EOF or error, make sure the buffer is set to the empty string.
 */

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput )
{
	char * retval = fgets ( lineBuf , lineSize , fileInput ) ;

	if ( retval )
	{
		size_t len = strlen ( lineBuf ) ;

		if ( len < 1 || lineBuf [ len - 1 ] != '\n' )
		{
			fprintf ( stderr , "mkclnmkf: malformed input line:\n\t%s\n" , lineBuf ) ;
		}
		else
			lineBuf [ len - 1 ] = '\0' ;
	}
	else
		lineBuf [ 0 ] = '\0' ;

	return retval ;
}

void Progress ( int prefix , char * string , int suffix )
{
static	size_t prevlen = 0 ;
static	int counter = 0 ;

	if ( string == NULL )
	{
		fprintf ( stderr , "%*s\n" , prevlen + 3 , " " )  ;
		prevlen = 0 ;
		counter = 0 ;
	}
	else if ( ++ counter % 100 == 1 )
	{
		size_t length = strlen ( string ) ;

		fprintf ( stderr , "%c%s%c%*s\r" ,
			prefix , string , suffix ,
			prevlen > length ? prevlen - length : 1 ,
			" " ) ;

		prevlen = length ;
	}
}

char * SkipFirstDir ( char * string )
{
	char * pFile = string ;

	while ( * pFile ++ != '\\' )
		if ( ! * pFile )
		{
			fprintf ( stderr ,
				"mkclnmkf: no \\ in \"%s\"\n" , string ) ;
			exit ( 1 ) ;
		}

	return pFile ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\striphdr\striphdr.c ===
/***************************************************************************
*striphdr.c -  Program to read source files and produce alphabetised
*                    listing of header blocks, telling which files they came
*                    from.
*
*	Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Author:         Tom Corbett, Brian Lewis - Microsoft Corp.
*
*Usage: striphdr [switches] file {file ...}
*  Accepts native code or C source; determines source
*     type based on filename suffix.
*  Wildcards may be used in the file names.
*
*  switches:
*
*  -m        process module headers only
*  -b        process both procedure and module headers
*            [default is procedure headers only]
*  -l        process only first line of each header
*  -n        process none of header (i.e. lists only function name)
*  -s <name> process named section only (may be used with -l)
*            [default is to process whole header]
*  -d        delete processed section from input file
*  -q        quiet, do not print headers (useful only with -d)
*  -x <ext>  gives extension for output file when -d used
*            [default: .new]
*  -r        remove revision histories from file headers
*              (equivalent to -m -d -q -s "Revision History")
*
*Purpose:
*   Given a list of Native code and/or C sources, strip out routine or module
*   headers and produce an alphabetised listing of the headers, telling where
*   (filename) each header came from. Optionally, delete part or all of the
*   headers from the source file.
*
*   For each file on the command line (wildcards may be used), striphdr reads
*   the file, and records information from the file and/or procedure headers.
*   This information is then sorted by procedure name/file name, and printed
*   to stdout, with an indication of which file each procedure is from.  If
*   the -d flag is activated, the information is also deleted from the input
*   file and the new file placed in a file with the same name but the
*   extension .new (this extension can be changed with the -x switch).  The
*   actual input file is also left as is. When using the -d switch, -q will
*   eliminate the output, so that only the deleting action takes place.  By
*   default only the procedure headers are scanned, the -m and -b switches
*   change this.  By default all the information in a header is printed or
*   deleted, the -l, -n, and -s switches change this.  The -r switch is an
*   abbreviation which will remove revision histories from the file headers.
*
*   Input filenames with suffixes of .c or .h are assumed to contain C source,
*   and suffixes of .asm or .inc imply native code source. Routine or module
*   names must be on the first or second line following the start of header;
*   if on the second line then the first line must contain only whitespace
*   after an optional '*' (if C source) or ';' (if native code source).
*   Routine names can contain a return type and parameters; multiple entry
*   point should be seperated by commas.  Header start and end symbols must
*   start in the left-most column. Module headers and routine headers are
*   marked in the same manner; position relative to the beginning of file is
*   used to determine which header type is appropriate.
*
*   Source is detabbed (1 tab assumed to equal 4 spaces in C, 8 spaces in native
*   code) and routine names are parsed to ensure that the correct name is
*   grabbed for sorting.
*
*   C Headers are started with a '/' characters in the first column followed
*   by at least 3 '*' characters, and are ended with at least 4 '*' characters
*   followed by a '/'. Each line within a header must begin with a '*', except
*   lines beginning with '#if', '#else', or '#endif'. Module headers must be
*   preceded with nothing except (perhaps) blank lines; if any non-blank lines
*   are found prior to the first header in a module, it is assumed that the
*   header belongs to a routine, otherwise, to the entire module.
*
*   Native code headers are started by a ';' followed by at least 3 '*'
*   characters, and the header  end is denoted by a ';' followed by at least
*   4 '*' characters. There must be a ';' character in the left-most column of
*   every line of the header block; the only exception to this is that the '
*   if', 'else', and 'endif' switches are allowed inside header blocks. Module
*   headers can be preceded with any number of blank lines, a TITLE statement,
*   a NAME statement, and/or a PAGE statement; if anything else is
*   encountered, subsequent headers will be assumed to be routine headers.
*
*   Sections within a header must have a title beginning on the 2nd
*   character of the line, and the section is assumed to extend to the next
*   line with a non-blank character in position 2.
*
*   No non-header comments should begin in column 1 with '/***' in C or
*   ';***' in native code; this will confuse striphdr.
*
*
*Revision History:
*
*   01-01-83  TOMC Created [tomc]
*   09-09-85  BL   Modified to allow the option of stripping module headers
*                  instead of routine headers via the -m switch
*   09-30-85  BL   Modified to accept either C Source or native code source.
*                  Modified to detab C Source assuming 3 spaces per tab.
*                  Modified to parse C Routine names properly, allowing
*                  types, macros, etc. to precede routine names.
*                  Modified to make the sorting be case insensitive.
*   11-12-85  BL   Fixed bug that caused 1st char to always be removed from
*                  headers, and that caused problems when a blank line follows
*                  header starts.
*   06-01-87  PHG  fixed GetNonBlank()
*                  allowed 'title' and 'Title" as well as 'TITLE'
*                  allowed NAME, PAGE as well as TITLE
*                  made tab expansion for both ASM and C files
*                  both C and ASM procedure names can have args,
*                  multiple entries
*                  simplified some code and a few minor bug fixes
*                  added -b, -n, -s, -d, -q, -x, -r switches
*   05-10-90  JCR  Accept .cxx/.hxx files (C++ support), misc cleanup
*   04-06-95  SKS  Accept .cpp/.hpp as equivalent to .cxx/.hxx, respectively
***************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <direct.h>


#define TRUE 1
#define FALSE 0
#define NAMBUFSZ 20000      /* size of buffer for holding all procedure names */
#define LINEBUFSZ 250       /* maximum size of 1 physical line */
#define MAXENT 3000         /* maximum number of procedure entry points */
#define MAXFUNCS 2000       /* maximum number of function headers */

/* abort codes */
#define NMBUFOV 0           /* name buffer table overflow */
#define FILENF 1            /* file not found */
#define FUNCSOV 2           /* function table overflow */
#define ENTOV 3             /* entry table overflow */
#define FILENO 4            /* cannot open file */
#define OUTSPACE 5          /* out of disk space */

/* tab sizes, pagelength */
#define TABSIZE_C 4
#define TABSIZE_ASM 8       /* tab sizes for code */
#define PAGELEN 60	    /* pagelength for page breaks; 60 for HP LaserJet */

struct {
	char *entname;          /* name of entry point */
	int funcid;             /* function index for this entry point */
	char printed;           /* flag to ensure each entry printed just once */
} 
entry [MAXENT];
int nentries;               /* number of entries parsed so far */

struct {
	char *filename;         /* name of file which contains this function */
	long filepos;           /* seek position on file "temp" */
	int nlines;             /* number of lines in function header */
} 
func [MAXFUNCS];
int nfuncs;                 /* number of function parsed so far */

long ofpos;                 /* output file seek position */
char linebuf[LINEBUFSZ];
char nambuf[NAMBUFSZ];      /* buffer for holding function names */
int nambufi;                /* next free byte in nambuf */
char fEof;
FILE *ofd;                  /* output file descriptor */
FILE *ifd;                  /* input file descriptor */
FILE *cfd;                  /* copy file descriptor */
FILE *fopen();
int outline;                /* output line number (1..PAGELEN) for page ejects */
int fDelete = FALSE;        /* TRUE if copy and delete instead of display */
int fGetModNams = FALSE;    /* TRUE if strip module names */
int fGetProcNams = TRUE;    /* TRUE if strip procedure names */
int fC_Source;              /* TRUE if we're processing C source, false if .asm */
int fDoAll = TRUE;          /* TRUE if we process all of header */
int fDoFirst = FALSE;       /* TRUE if we process first line of header */
int fDoSection = FALSE;     /* TRUE if we process named section of header */
int fQuiet = FALSE;         /* TRUE is quiet mode */
char SectionHead[80];       /* Section name */
char CopyExt[4] = "new";    /* extension of new files */
char *szFilenameCur;        /* name of file being read (for error reporting) */



/*** 
*MyAbort(code, s) - abort program with message
*Purpose:
*   abort the program with correct message.
*
*Entry:
*   code = error code
*   s = filename for code == FILENF
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void MyAbort(code, s)
int code;
char *s;
{
	fprintf(stderr, "Fatal Error - ");
	if (code == NMBUFOV)
		fprintf(stderr, "NAME Buffer overflow\n");
	if (code == FILENF)
		fprintf(stderr, "File not found: %s\n", s);
	if (code == FUNCSOV)
		fprintf(stderr, "Function table overflow\n");
	if (code == ENTOV)
		fprintf(stderr, "Entry table overflow\n");
	if (code == FILENO)
		fprintf(stderr, "Cannot open file: %s\n", s);
	if (code == OUTSPACE)
		fprintf(stderr, "Out of disk space\n", s);

	exit(code);
} /* MyAbort */


/***
*FindIfC(szFile) - find if filename if C or ASM
*
*Purpose:
*   Set global flag fC_Source to TRUE if the filename ends in
*   .c, .h, .cxx (.cpp), or .hxx (.hpp); FALSE if it ends in .asm or .inc.
*   The extension comparison is NOT case senstive.  If none of
*   these are found, don't set the flag,and return FALSE,
*   else return TRUE.
*
*Exit:
*   sets flag fC_Source
*   returns FALSE if neither C nor ASM source
*   returns TRUE if fC_Source set
********************************************************************/

FindIfC(szFile)
char *szFile;
{
	int cbFileName = strlen(szFile);
	char *pbPastName = szFile + cbFileName; /* points at NULL at string end */

	if ((!_stricmp (".c", pbPastName - 2)) ||
	    (!_stricmp (".h", pbPastName - 2)) ||
	    (!_stricmp (".s", pbPastName - 2)) ||
	    (!_stricmp (".cpp", pbPastName - 4)) ||
	    (!_stricmp (".hpp", pbPastName - 4)) ||
	    (!_stricmp (".cxx", pbPastName - 4)) ||
	    (!_stricmp (".hxx", pbPastName - 4)))
		fC_Source = TRUE;       /* file is assumed to be C source */

	else if ((!_stricmp (".asm", pbPastName - 4)) ||
	    (!_stricmp (".inc", pbPastName - 4)))
		fC_Source = FALSE;      /* file is assumed to be Native Code source */

	else return (FALSE);        /* didn't find an appropriate suffix */

	return (TRUE);

} /* FindIfC */


/***
*MakeCopyfileName(filename, copyname) - make copyfile name from input name
*
*Purpose:
*   Put the copy file suffix onto a file name
*
*Entry:
*   filename = input file name
*
*Exit:
*   copyname = filled in with copy file name
*
*Exceptions:
*
*******************************************************************************/

void MakeCopyfileName(filename, copyname)
char *filename, *copyname;
{
	char *p;

	strcpy(copyname, filename);
	p = copyname + strlen(copyname);
	while (*(--p) != '.')
		;                            /* p points to '.' */
	*(p+1) = '\0';                  /* cut off string after '.' */
	strcat(copyname, CopyExt);      /* put on copy file extension */
}



/***
*linelen(pLine)
*
*Purpose:
*       Return the number of characters in a passed line. The line terminator
*       ('\n') is not included in the count.
*
*Entry:
*       pLine = a pointer to the first char in the line.
*Exit:
*       returns the number of characters in the line (an int).
***************************************************************************/

int linelen(pLine)
char *pLine;
{
	register int index;

	for (index = 0; *(pLine + index) != '\n'; index++);
	return (index);
}



static int cLinesRead;
static char fInHeader = FALSE;

/***
*ReadLine(copyit) - read line and analyze it
*
*Purpose:
*   read 1 line from input file into 'linebuf'.
*   if copyit == TRUE, copy previous line to copy file
*
*Entry:
*   copyit = TRUE means copy the line to the copy file
*
*Exit:
*   returns     -1 for EOF,
*                   0 for vanilla lines,
*               if C Source,
*                   1 for lines which begin "/***"  (start of header)
*                   2 for lines which begin "/****" (end of header)
*               if Native Code Source,
*                   1 for lines which begin ";***"  (start of header)
*                   2 for lines which begin ";****" (end of header)
*
***************************************************************************/

int ReadLine(copyit)
int copyit;             /* TRUE = copy line to copy file */
{
	register int i;
	register int cbLine;

	if (copyit) {
		if (fputs(linebuf, cfd) == EOF)
			MyAbort(OUTSPACE);
	}                   /* copy previous line if requested */

	if ((fgets(linebuf, LINEBUFSZ, ifd)) == NULL) {
		fEof = TRUE;
		return(-1);
	}

	cLinesRead++;
	cbLine = linelen(linebuf);

	if ((linebuf[0] == ';') && (!fC_Source)) {  /* native code comment */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			/* know we have either start or end of a header */
			if (fInHeader) {
				fInHeader = FALSE;
				if (linebuf[4] == '*')
					return (2);             /* valid end of header */
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {      /* have a valid start of header */
				fInHeader = TRUE;
				return (1);
			}
	}

	else if ((linebuf[0] == '/') && (fC_Source)) {  /* C code comment? */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			if (fInHeader) {
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {
				fInHeader = TRUE;
				return (1);             /* valid start of header */
			}
	}

	else if ((linebuf[0] == '*') && (fC_Source)) {  /* C code comment? */
		for (i = 1; (i < cbLine) && (linebuf[i] == '*'); i++);

		if ((linebuf[i] == '/') && (i > 3)) {   /* have a valid end of header */
			if (fInHeader) {
				fInHeader = FALSE;
				return (2);
			}
			/* got a header terminator when we weren't within a header */
			fprintf(stderr, "Illegal termination to header for function: %s",
			entry[nentries].entname);
			fprintf(stderr, "  in line %d of file %s\n",
			cLinesRead, szFilenameCur);
		} /* if */
	}   /* else if */

	return(0); /* vanilla line */
} /* ReadLine */


/***
*WriteLine(pb, of) - write a line and expand tabs
*
*Purpose:
*   Write a zero terminated string to file 'of'.
*   If we're writing C Source header lines, detab them as we go.
*
*Entry:
*   pb = points to 1st byte of 0-terminated string.
*   of = aft index for destination file.
*
*Exit:
*   'ofpos' is bumped to reflect current output file position.
*
***************************************************************************/

void WriteLine(pb, of)
register char *pb;
FILE *of;
{
	register int linepos = 0;   /* column position on output line */
	int modTS;                  /* linepos mod tabSize */
	int cSpaces;                /* number of spaces to print to next tab stop */
	int index;                  /* 'for' index for printing spaces */
	int tabSize;                /* current tab size */

	if (fC_Source)
		tabSize = TABSIZE_C;
	else
		tabSize = TABSIZE_ASM;

	while (*pb != '\0') {
		if (*pb == '\t') {      /* if a tab character found */
			modTS = linepos % tabSize;  
			cSpaces = tabSize - modTS;
			for (index = 0; index < cSpaces; index++) {
				fputc(' ', of);
				linepos++;
			}
		}   /* if */
		else {
			fputc(*pb, of);
			linepos++;
		}
		pb++;
	}   /* while */

	if (ferror(of))
		MyAbort(OUTSPACE);
	ofpos = ftell(of);  /* update output file seek position for next line */
} /* WriteLine */


/***
*SwitchFound(s) - see if IF, ELSE, ENDIF switch on this line
*
*Purpose: return TRUE if an "if", "else", or "endif" are identified at
*   the start of string 's'. This is used to check to see if a
*   header line which doesn't start with ';' is an assembler switch.
*Entry:
*   s = pointer to a char which represents the string to be checked.
*   
*Exit:
*   returns TRUE if the string matches "if", "else", or "endif" of either
*   upper or lower case, FALSE otherwise.
***************************************************************************/

SwitchFound(s)
char *s;
{
	if (fC_Source) {
		/* strncmp returns 0 (which maps to FALSE) iff a match was found */
		if (strncmp(s, "#if", 3) &&
		    strncmp(s, "#IF", 3) &&
		    strncmp(s, "#else", 5) &&
		    strncmp(s, "#ELSE", 5) &&
		    strncmp(s, "#endif", 6) &&
		    strncmp(s, "#ENDIF", 6))
			return (FALSE);
	}
	else {
		if (strncmp(s, "if", 2) &&
		    strncmp(s, "IF", 2) &&
		    strncmp(s, "else", 4) &&
		    strncmp(s, "ELSE", 4) &&
		    strncmp(s, "endif", 5) &&
		    strncmp(s, "ENDIF", 5))
			return (FALSE);
	}
	return (TRUE);
}

/***
*GetNonBlank(copyit) - read line, find first non blank character
*
*Purpose:
*   Read in a line; return linebuf index if non-blank line found, -1 otherwise
*
*Entry:
*   copyit = TRUE means copy line to copy file
*
*Exit:
*   returns -1 if blank line read
*   return index of first non-whitespace char otherwise
*
***************************************************************************/
GetNonBlank(copyit)
int copyit;         /* copy lines to copy file if TRUE */
{
	register int i;
	register int cbLine;

	if (ReadLine(copyit) == -1) {
		return(-1);
	}

	cbLine = linelen(linebuf);

	for (i = 0; ((linebuf[i] == ' ') || (linebuf[i] == '\t')) &&
                    (i < cbLine); i++);

	if (i >= cbLine)
		return (-1);
	else
		return (i);

}   /* GetNonBlank */

/***
*ReadToHeader() - reads to beginning of next header
*
*Purpose:
*   Reads to beginning of next header or EOF 
*
*Entry:
*   
*Exit:
*   Returns -1 if at EOF, 0 if at a header
*
************************************************************************/

int ReadToHeader()
{
	while (!fEof && ReadLine(fDelete) != 1)
		;
	if (fEof)
		return -1;      /* at EOF */
	else
		return 0;       /* at beginning of header */
}



/***
*Get1stHdr() - read to first header
*
*Purpose:
*   Read lines until the first header is found. Return TRUE if this is
*   the header for the module, or FALSE if no module header is found.
*   
*   In C Sources, we assume that if the first non-blank line in the source
*       starts with  '/***', then it's the start of a module header.
*   In Native-Code Sources, we assume that there can exist any number
*       of blank lines, optionally followed by a TITLE statement, followed
*       by any number of blanks lines, and then by the module header if
*       it exists.
*
*Entry:
*       NONE
*Exit:
*       TRUE if module header found, FALSE otherwise. Note that if fEof is found,
*       FALSE is returned, and if !fEof and no module header is found, this 
*       routine will read in lines until the first routine header is found,or
*       fEof.
***************************************************************************/

Get1stHdr()
{
	register int index;
	register int i;

	while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
		;

	if (fEof) {
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

	/* now, index is set into linebuf for a non-blank character */
	if (fC_Source) {        /* if header exists, must be first non-blank line */
		if ((linebuf[0] == '/') && (linebuf[1] == '*') &&
		    (linebuf[2] == '*') && (linebuf[3] == '*')) {
			fInHeader = TRUE;
			return (TRUE);
		}
		else {
			/* read to start of first header, tell caller no module header found */
			ReadToHeader();
			fprintf(stderr, "warning: no file header on file ");
			fprintf(stderr, "%s\n", szFilenameCur);
			return (FALSE);
		}
	}

	/* must be native-code source - - - can have a TITLE line with blank
	                lines before and after it - - - all prior to module header       */

	for (i = 1; i <= 3; ++i) { /* do thrice, might have TITLE, NAME, and PAGE */
		if (strncmp("TITLE", linebuf + index, 5) == 0 ||
		    strncmp("title", linebuf + index, 5) == 0 ||
		    strncmp("Title", linebuf + index, 5) == 0 ||
		    strncmp("NAME", linebuf + index, 4) == 0 ||
		    strncmp("name", linebuf + index, 4) == 0 ||
		    strncmp("Name", linebuf + index, 4) == 0 ||
		    strncmp("PAGE", linebuf + index, 4) == 0 ||
		    strncmp("Page", linebuf + index, 4) == 0 ||
		    strncmp("page", linebuf + index, 4) == 0)
		{ /* found TITLE, NAME, or PAGE statement */
			while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
				;

			if (fEof) {
				fprintf(stderr, "warning: no file header on file ");
				fprintf(stderr, "%s\n", szFilenameCur);
				return (FALSE);
			}
		}
	}

	/* if there was a TITLE and/or NAME statement, we've eaten it, 
	                   and any following blank lines;
	               must now have module header, if it exists */

	if ((linebuf[0] == ';') && (linebuf[1] == '*') &&
	    (linebuf[2] == '*') && (linebuf[3] == '*')) {
		fInHeader = TRUE;
		return (TRUE);
	}
	else {
		/* read to start of first header, tell caller no module header found */
		ReadToHeader();
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

}   /* Get1stHdr */

/***
*AdvanceOne(s) - advance one char if one whitespace or comment token
*
*Purpose:
*   's' points to the first character in an input line; if it's a whitespace
*   token or a comment token, return a pointer to the next character in the
*   line, otherwise, return 's' unchanged.
*
*Entry:
*   s = ptr to first char in input line
*
*Exit:
*   returns ptr the next char if *s is whatspace, ';', or '*',
*   otherwise returns s
*
*******************************************************************************/

char *AdvanceOne(s)
char *s;
{
	if (*s == '*') {
		if (fC_Source)
			s++;
	}
	else if (*s == ';') {
		if (!fC_Source)
			s++;
	}
	else if ((*s == ' ') || (*s == '\t'))
		s++;
	return(s);
}   /* AdvanceOne */


/***
*FuncNamePtr(pbName) - find function name from this or next line
*
*Purpose:
*   Given a pointer into the current header line, return a pointer to
*   the first non-blank or comment symbol; if none found in the existing
*   line, read in another and try that one.
*   if a C routine line, skip any types, etc., and return a pointer to
*   the filename itself.
*
*   If a C routine line:
*   -------------------
*       Assumes that C routine names will end with a left paren.
*       Allows left parens in a summary of purpose if said summary is
*           preceded by a '-' which comes after the routine name.
*       Assumes that there are 1 or 0 spaces between the the routine name
*           and the mandatory left paren.
*
*Entry:
*       pbName = a pointer to the place to begin searching in linebuf.
*Exit:
*       Returns a pointer to the filename.
*
***************************************************************************/

char *FuncNamePtr(pbName)
register char *pbName;
{
	register int cbLine;
	char *pbTmp;
	int iStart;

	/* first, see if we have a blank line - if so, read in another one,
	                and assume that it has the filename; don't check that one ... */
	pbTmp = AdvanceOne(pbName);
	cbLine = linelen(pbTmp);
	for (iStart = 0; ((*(pbTmp+iStart) == ' ') || (*(pbTmp+iStart) == ' ')) &&
                    (iStart < cbLine); iStart++);
	    if (iStart >= cbLine) {
		if (ReadLine(fDelete) != 0) {   /* then we got a procedure end w/out a name! */
			if (fEof)
				fprintf(stderr, "EOF not expected\n");
			else
				fprintf(stderr, "Illegal header termination\n");
			fprintf(stderr,
			"  in line %d of file %s\n", cLinesRead, szFilenameCur);
			return((char *)-1);
		}
		pbName = linebuf;
	}

	/* now, assume that there is a filename somewhere at or after pbName */


	iStart = 0;

	while (*(pbName+iStart) != '(' && *(pbName+iStart) != '-' &&
	    *(pbName+iStart) != ',' && *(pbName+iStart) != '\n')
		++iStart;   /* search fwd for '(', '-', ',' or '\n' */
	do {
		--iStart;
	} 
	while ((*(pbName+iStart) == ' ' || *(pbName+iStart) == '\t') &&
	    iStart > 0);
	/* search back through whitespace */ 
	while (*(pbName+iStart) != ' ' && *(pbName+iStart) != '\t' &&
	    *(pbName+iStart) != ';' && *(pbName+iStart) != '*')
		--iStart;
	/* search back to beginning of name */
	++iStart;       /* point to first letter of name */
	return (pbName+iStart); /* return pointer to name */
}   /* FuncNamePtr */


/***
*MyReadFile(pbNam) - read file and remember headers
*
*Purpose:
*   Read one entire file, stripping out and remembering function headers
*   or module headers, as appropriate.
*
***************************************************************************/

void MyReadFile(char *pbNam)
{
	char CopyName[65];                  /* name of copy file */
	char *s, done, backout;
	int funci, svnfuncs, svnentries;
	int inmodhdr;                       /* TRUE if in module header, else FALSE */
	int insection;                      /* TRUE if in scetion to process */
	int onfirst;                        /* TRUE if on first line of header */

	szFilenameCur = pbNam;
	if ((ifd = fopen(pbNam, "r")) <= 0)
		MyAbort(FILENF, pbNam);
	linebuf[0] = '\0';                  /* make linebuf blank so file copying works */
	fEof = FALSE;
	cLinesRead = 0;

	if (!FindIfC(pbNam))    {           /* filename had invalid suffix */
		fprintf(stderr, "Illegal suffix for file %s", pbNam);
		fprintf(stderr, "; must have .c or .asm suffix\n");
		fclose(ifd);
		return;
	}

	if (fDelete) {
		MakeCopyfileName(pbNam, CopyName);  /* put the right extension on */
		cfd = fopen(CopyName, "w");
		if (cfd == NULL)
			MyAbort(FILENO, CopyName);        /* can't open file */
	}

	inmodhdr = Get1stHdr(); 
	if (inmodhdr && !fGetModNams) {
		/* don't want module header */
		ReadToHeader();                 /* skip module header */
		inmodhdr = FALSE;
	}

	/* we are currently at the beginning of a new header.
	        copy it to file TEMP, remember all entry points in NAMBUF.  */

	while (!fEof && (inmodhdr || fGetProcNams)) {
		svnfuncs = nfuncs;
		svnentries = nentries;
		if (++nfuncs >= MAXFUNCS)
			MyAbort(FUNCSOV);
		func[nfuncs].filename = pbNam;
		func[nfuncs].nlines = 0;
		func[nfuncs].filepos = ofpos;
		if (ReadLine(fDelete) == -1)
			done = TRUE;            /* got end-of-file */
		else
			done = FALSE;
		funci = nfuncs;
		s = linebuf;

		while (!done) {
			if (++nentries >= MAXENT)
				MyAbort(ENTOV);
			entry[nentries].entname = nambuf + nambufi;
			entry[nentries].printed = FALSE;
			entry[nentries].funcid = funci;
			s = FuncNamePtr(s);
			if (s == (char *)-1) {
				fprintf(stderr, "Error found in line %d of file %s\n",
				cLinesRead, szFilenameCur);
				s = linebuf;
			}
			while ((*s != '\0') &&  /* transfer function name to nambuf */
			(*s != ',') &&
			    (*s != '(') &&
			    (*s != ' ') &&
			    (*s != '\n') &&
			    (*s != '\t') &&
			    (nambufi < (NAMBUFSZ - 2))) {
				nambuf[nambufi++] = *(s++);
			}
			if (nambufi >= (NAMBUFSZ - 2))
				MyAbort(NMBUFOV, NULL);
			nambuf[nambufi++] = '\0';

			/* make all secondary entry points reference primary entry point */
			if (funci >= 0)
				funci = -1 - nentries;   

			/* next we see if another entry point exists */
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*s == '(') {
				do {
					++s;
				} 
				while (*s != ')' && *s != '\n');  /* skip param list */
				++s;                            /* goto next character */
			}
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*(s++) != ',')
				done = TRUE;                    /* no more entry pts */
			else {
				++s;
				done = FALSE;
			}
		} /* while !done */

		backout = FALSE;

		if (fDoAll || fDoFirst)
			insection = TRUE;
		else
			insection = FALSE;                  /* are we in the correct section */

		onfirst = TRUE;                         /* on first line */

		do {
			s = linebuf;

			if ((!fC_Source && (*s != ';') && !SwitchFound(s)) || 
			    (fC_Source && (*s != '*') && !SwitchFound(s))) {
				/* Illegal Header Format, leave garbage in file TEMP,
				                    but restore nfuncs and nentries to previous values
				                    and backout of this header gracefully. */
				fprintf(stderr, "Invalid Header for function: %s",
				entry[nentries].entname);
				fprintf(stderr, " in line %d", cLinesRead);
				fprintf(stderr, ", in file: %s\n", pbNam);
				nfuncs = svnfuncs;
				nentries = svnentries;
				backout = TRUE;
			}

			s = AdvanceOne(s);

			if (!fDoAll && fDoSection && !onfirst && *s != ' ' && *s != '\t' && *s != '\n') {
				/* now at a section beginning -- and it's significant */
				if (insection)
					insection = FALSE;          /* come to end of section */
				else if (strncmp(s, SectionHead, strlen(SectionHead)) == 0)
					insection = TRUE;           /* come to beginning of section */
			}

			/* if in the section, don't copy, but write to TEMP */
			if (insection) {
				WriteLine(s, ofd);
				func[nfuncs].nlines++;
				ReadLine(FALSE);
			}
			else {
				ReadLine(fDelete);
			}

			if (onfirst && !fDoAll)
				insection = FALSE;

			onfirst = FALSE;                    /* no longer on first line */
		} 
		while ((!fEof) && (!backout) && fInHeader);

		/* skip to start of next function header */
		if (fGetProcNams)
			ReadToHeader();
		inmodhdr = FALSE;

	} /* while !fEof etc. */

	while (!fEof) {
		ReadLine(fDelete);
	}                                       /* read rest of file */

	if (fInHeader) {
		/* Error: reached EOF with unterminated header */
		fInHeader = FALSE;
		fprintf(stderr,
		"Error: function %s not terminated before end-of-file in %s\n",
		entry[nentries].entname, szFilenameCur);
	}

	fclose(ifd);
	fclose(cfd);

} /* MyReadFile */


/***
*PrintSep() - print a seperator
*
*Purpose:
*   Output a some lines which mark function header boundaries.
*
***************************************************************************/

void PrintSep(void)
{
	printf("---------------------------------------");
	printf("----------------------------------------\n");
} /* PrintSep */


/***
*PrintEntry(i) - print out an entry point header/module header
*
*Purpose:
*   Prints the given header out
*
***************************************************************************/

PrintEntry(i)
int i;
{
	int linecnt, m, entrysize;
	if ((m = entry[i].funcid) >= 0)
		entrysize = 4 + func[m].nlines; /* primary entry point */
	else
		entrysize = 4; /* secondary entry point */
	if (outline + entrysize > PAGELEN && outline > 1) {
		while (outline > PAGELEN)
			outline -= PAGELEN;
		while (outline <= PAGELEN) {
			printf("\n");
			outline++;
		}
		outline = 1;
	}
	printf("\n");
	PrintSep();
	printf("%s - ", entry[i].entname);
	if (m < 0)
		printf("see %s\n", entry[-1-m].entname);
	else
		printf("File: %s\n", func[m].filename);
	PrintSep();
	outline = outline + 4;
	if (m < 0 || func[m].nlines == 0)
		return(0);
	fseek(ifd, func[m].filepos, 0);
	fEof = FALSE;
	linecnt = func[m].nlines;
	ReadLine(FALSE);
	do {
		WriteLine(linebuf, stdout);
		outline++;
		ReadLine(FALSE);
	}
	while ((!fEof) && ((--linecnt) > 0));
} /* PrintEntry */

#if 0
/***************************************************************************
*_stricmp(pbLeft, pbRight) - case insensitive string compare
*
*Purpose:
*   Case-insensitive string comparison.
*
*Entry:
*   pbLeft, pbRight = ptrs to strings to compare
*
*Exit:
*   Return 0 if left string == right string, -1 if left string less than
*   right string, 1 otherwise
*
*NOTE:
*       This routine is provided because not all C runtime libraries support
*       this; specifically, MS C for DOS does have this routine, but
*       on a 68k it doesn't seem to be there.
*
***************************************************************************/
char *malloc();
#define isLcase(c)   (((c) >= 'a') && ((c) <= 'z'))
#define upit(c)  ((isLcase(c))? (c) - 'a' + 'A' : (c))

_stricmp(pbLeft, pbRight)
char *pbLeft, *pbRight;
{
	int cbLeft = strlen(pbLeft);
	int cbRight = strlen(pbRight);
	char *pbUCleft = malloc(cbLeft +1);
	char *pbUCright = malloc(cbRight +1);
	register char *pbSrc;
	register char *pbDst;
	register int i, retval;

	pbDst = pbUCleft;
	pbSrc = pbLeft;
	for (i = 0; i <= cbLeft; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	pbDst = pbUCright;
	pbSrc = pbRight;
	for (i = 0; i <= cbRight; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	retval = strcmp(pbUCleft, pbUCright);

	free(pbUCright);
	free(pbUCleft);

	return(retval);
} /* strless */

#endif /* 0 */

/***************************************************************************
* SortFunctions()
*
* Purpose:
*   Print sorted list of functions headers.
*
***************************************************************************/
void SortFunctions(void)
{
	int i, j, low;
	ifd = fopen("temp", "r");
	i = -1;
	while (++i <= nentries) {
		low = 0;
		j = -1;
		while (++j <= nentries) {
			if (!entry[j].printed) {
				if (entry[low].printed)
					low = j;
				else if (0 > _stricmp(entry[j].entname, entry[low].entname))
					low = j;
			}
		}
		PrintEntry(low);
		entry[low].printed = TRUE;
	}
} /* SortFunctions */

/*** 
*UsageError() - print out usage
*Purpose:
*   prints out the usage guidelines
*
*Entry:
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void UsageError(void)
{
	printf("Usage: striphdr [switches] file {file ...}\n\n");
	printf("  Accepts native code or C source; determines source\n");
	printf("     type based on filename suffix.\n");
	printf("  Wildcards may be used in the file names.\n");
	printf("\n");
	printf("Switches:\n");
	printf("  -m        process module headers only\n");
	printf("  -b        processes both procedure and module headers\n");
	printf("            [default is procedure headers only]\n");
	printf("  -l        processes only first line of each header\n");
	printf("  -n        processes none of header (i.e. lists only function name)\n");
	printf("  -s <name> processes named section only (may be used with -l)\n");
	printf("            [default is to process whole header]\n");
	printf("  -d        delete processed section from input file\n");
	printf("  -q        quiet, do not print headers (useful only with -d)\n");
	printf("  -x <ext>  gives extension for output file when -d used\n");
	printf("            [default: .new]\n");
	printf("  -r        remove revision histories from file headers\n");
	printf("              (equivalent to -m -d -q -s \"Revision History\")\n");
	exit(-1);
} /* UsageError */


void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/***
*main() - parse command line and process all file
*
*Purpose:
*   To run the other procedures based on the command line.
*
*******************************************************************************/

int main(int argc, char *argv[])
{
	int filei;
	int fScanningSwitches = TRUE;
    char base_dir[256], curr_dir[256];
    long h_find;
    struct _finddata_t f_data;

	nfuncs = -1;
	nentries = -1;
	nambufi = 0;
	ofpos = 0;
	filei = 1;
	outline = 1;

	if (argc == 1)      /* no args given - print usage message and quit */
		UsageError();

	while (fScanningSwitches) {
		if (filei >= argc) {
			fScanningSwitches = FALSE;
		}
		else if (_stricmp("-d", argv[filei]) == 0) {
			fDelete = TRUE;
			filei++;
		}
		else if (_stricmp("-q", argv[filei]) == 0) {
			fQuiet = TRUE;
			filei++;
		}
		else if (_stricmp("-n", argv[filei]) == 0) {
			fDoFirst = fDoSection = fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-m", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			filei++;
		}
		else if (_stricmp("-b", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = TRUE;
			filei++;
		}
		else if (_stricmp("-l", argv[filei]) == 0) {
			fDoFirst = TRUE;
			fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-s", argv[filei]) == 0) {
			fDoSection = TRUE;
			fDoAll = FALSE;
			filei++;
			if (filei >= argc)
				UsageError();
			strcpy(SectionHead, argv[filei]);   /* copy section header in */
			filei++;
		}
		else if (_stricmp("-x", argv[filei]) == 0) {
			filei++;
			if (argv[filei][0] == '.')
				strncpy(CopyExt, argv[filei]+1, 3);     /* skip '.' */
			else
				strncpy(CopyExt, argv[filei], 3);
			CopyExt[3] = '\0';                  /* terminate string */
			filei++;
		}
		else if (_stricmp("-r", argv[filei]) == 0) {
			fDelete = TRUE;
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			fDoAll = FALSE;
			fDoSection = TRUE;
			fQuiet = TRUE;
			strcpy(SectionHead, "Revision History");
			filei++;
		}
		else if (*(argv[filei]) == '-')
			UsageError();
		else
			fScanningSwitches = FALSE;
	}

	if (filei >= argc)
		UsageError();                           /* no files specified */

	if (fQuiet)
		ofd = fopen("nul", "w");    /* in quiet mode, so no need to save the headers */
	else
		ofd = fopen("temp", "w");
	if (ofd == NULL)
		MyAbort(FILENO, "temp");                  /* can't open file */

	filei--;

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
    while (++filei < argc) {
        gdir(curr_dir, argv[filei]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[filei], &f_data)) == -1)
			continue;
        do
		{
       		MyReadFile(f_data.name);
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
	fclose(ofd);
	if (!fQuiet)
		SortFunctions();
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\srcrel\nmktobat.c ===
/***
*NMKtoBAT.C - convert NMAKE.EXE output into a Windows 9x batch file
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The makefiles provided with the Microsoft Visual C++ (C/C++) Run-Time
*	Library Sources generate commands with multiple commands per line,
*	separated by ampersands (&).  This program will convert such a
*	text file into a batch file which can be executed by the Windows 9x
*	command interpreter (COMMAND.COM) which does not recognize multiple
*	commands on a single line.
*
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc, char **argv);


#define MAXLINE	4096

char InBuf [ MAXLINE ] ;


int main(int argc, char **argv)
{
	/*
	 * If any arguments are given, print a usage message and exit
	 */

	if ( argc != 1 || argv [ 1 ] )
	{
		fprintf ( stderr , "Usage: nmk2bat < input > output\n"
			"This program takes no arguments\n" ) ;
		exit ( 1 ) ;
	}

	/*
	 * Batch file should be terse
	 */

	printf ( "@echo off\n" ) ;

	/*
	 * Process each input line
	 */

	while ( fgets ( InBuf , sizeof ( InBuf ) , stdin ) )
	{
		char * pStart ;
		char * pFinish ;
		char * pNextPart ;

		pStart = InBuf ;
	
		pFinish = pStart + strlen ( pStart ) ;

		/*
		 * Remove the trailing newline character from the
		 * input buffer.  This simplifies the line processing.
		 */

		if ( pFinish > pStart && pFinish [ -1 ] == '\n' )
			pFinish [ -1 ] = '\0' ;

		/*
		 * Process each part of the line.  Parts are delimited
		 * by ampersand characters with optional whitespace.
		 */

		do
		{
			/*
			 * Skip initial whitespace
			 */

			while ( * pStart == ' ' || * pStart == '\t' )
				++ pStart ;

			/*
			 * Find the next command separator or
			 * the end of line, whichever comes first
			 */

			pNextPart = strchr ( pStart , '&' ) ;

			if ( ! pNextPart )
				pNextPart = pStart + strlen ( pStart ) ;
		
			pFinish = pNextPart ;

			/*
			 * Skip blank lines and blank parts of lines
			 */

			if ( pStart == pNextPart )
				break ;
			/*
			 * Skip the trailing whitespace
			 */

			while ( pFinish > pStart
			&& ( pFinish [ -1 ] == ' ' || pFinish [ -1 ] == '\t' ) )
				-- pFinish ;

			/*
			 * Copy to stdout the characters between
			 * the skipped initial whitespace and
			 * the skipped trailing whitespace
			 */

			while ( pStart < pFinish )
				putchar ( * pStart ++ ) ;

			putchar ( '\n' ) ;

			/*
			 * We are done with this line when pNextPart
			 * points to a null character (rather than a '&').
			 */

			pStart = pNextPart ;

		} while ( * pStart ++ ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\srcrel\striplin.c ===
/**
 *	StripLines - strips a text file (usually a Makefile) of
 *		Microsoft-proprietary or other specialized parts
 *
 *	Programmed by Steve Salisbury, Thu 18 May 1995
 *
 *	Fri 19 May 1995 -- add code to skips lines containing STRIPLIN! 
 *		Add line numbers to diagnostic messages
 *		Flag redundant STRIPLIN= directives (which are an error)
 *
 *	This program just copies stdin to stdout.  Depending on the
 *	value of a global state variable, some lines may be ignored.
 *
 *	... STRIPLIN=0 ...
 *		turns off line-by-line copying until STRIPLIN=1 or STRIPLIN=2
 *		is encountered, at which point lines will be copied again.
 *	... STRIPLIN=1 ...
 *		turns on line-by-line copying (initial state)
 *	... STRIPLIN=2 ...
 *		turns on line-by-line copying with deletion of
 *		initial # on each line (if there is one).  If
 *		an input line has no initial #, it is copied as-is.
 *	... STRIPLIN! ...
 *		this single line is not copied (regardless of the 0/1/2 state)
**/


/**
 *
 * Header Files
 *
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/**
 *
 * Global Constants
 *
**/

#define	MAXLINELEN	4096


/**
 *
 * Global Variables
 *
**/

char InputLine [ MAXLINELEN ] ;

char ControlString[ ] = "STRIPLIN=" ;
char DeleteString[ ] = "STRIPLIN!" ;


/**
 *
 * Function Declarations (Prototypes)
 *
**/

int main ( int argc , char * argv [ ] ) ;


/**
 *
 * Function Definitions (Implementations)
 *
**/

int main ( int argc , char * argv [ ] )
{
	int	StateFlag = 1 ;
	int	LineNumber = 0 ;

	while ( fgets ( InputLine , sizeof ( InputLine ) , stdin ) )
	{
		char * pString ;

		++ LineNumber ;

		if ( pString = strstr ( InputLine , ControlString ) )
		{
			int NewStateFlag ;

			NewStateFlag = pString [ strlen ( ControlString ) ] - '0' ;

			if ( NewStateFlag < 0 || 2 < NewStateFlag )
			{
				fprintf ( stderr , "striplin: invalid directive:\n%d:\t%s\n" ,
					LineNumber , InputLine ) ;
				exit ( 1 ) ;
			}

			if ( NewStateFlag == StateFlag )
			{
				fprintf ( stderr , "striplin: redundant directive:\n%d:\t%s\n" ,
					LineNumber , InputLine ) ;
				exit ( 1 ) ;
			}

			StateFlag = NewStateFlag ;
		}
		else if ( StateFlag != 0 )
		{
			char * start = InputLine ;

			/*-
			 * If StateFlag is 2 and the line begins with #, skip the #
			-*/

			if ( StateFlag == 2 && * start == '#' )
				start ++ ;
				
			/*-
			 * Echo lines that do not contain the delete string
			-*/

			if ( ! strstr ( start , DeleteString ) )
				fputs ( start , stdout ) ;
		}
	}
			
	if ( fflush ( stdout ) )
	{
		fprintf ( stderr , "striplin: Error flushing standard output\n" ) ;
		exit ( 1 ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\libw32\tools\source\ifstrip\symtab.c ===
/***
*symtab.c - Ifdef symbol table storage module
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Store the symbols from the switches file.
*
*Revision History:
*	??-??-88   PHG	Initial version
*
*******************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <ctype.h>
#include "constant.h"
#include "errormes.h"
#include "symtab.h"

/* Internal constants */
#define MAXSYMBOLS    512	/* Maximum number of symbols (switches) */
#define IDENT_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_$?"

/* Symbol record */
struct symrec {
	char *name;		/* name of the symbol */
	int type;		/* type of symbol (DEFINED, UNDEFINED, IGNORE)*/
};

/* Internal variables */
int numsyms;			/* Number of symbols */
struct symrec symtable[MAXSYMBOLS];
				/* Symbol table */
/* Procedures */
int compsym(const struct symrec *, const struct symrec *);

/* Compare two records for alphabetical order */
int compsym(rec1, rec2)
const struct symrec *rec1, *rec2;
{
	return strcmp(rec1->name, rec2->name);
}

/* Add symbol to symbol table */
void addsym(symbol, type)
char *symbol;
int type;
{
	if (lookupsym(symbol) != NOTPRESENT) {
		fprintf(stderr, "fatal error: symbol \"%s\" already in symbol table.\n", symbol);
		exit(1);
	}
	symtable[numsyms].name = _strdup(symbol);
	symtable[numsyms].type = type;
	++numsyms;
}

/* Read switches from a file into symbol table */
void readsyms(filename)
char *filename;
{
	FILE *f;
	char name[MAXNAMELEN];
	f = fopen(filename, "r");
	if (f == NULL) {
		fprintf(stderr, "fatal error: cannot open switch file \"%s\".\n", filename);
		exit(1);
	}
	numsyms = 0;

	do {
		if ( fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, DEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, UNDEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL)
			break;
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, IGNORE);
		}
	} while (name[0] != '-');

	fclose(f);
}

/* Lookup symbol in symbol table */
int lookupsym(name)
char *name;
{
	struct symrec srchrec;
	struct symrec *recfound;

	srchrec.name = name;
	recfound = (struct symrec *) _lfind( (const void *)&srchrec, (const void *)symtable,
		&numsyms, sizeof(struct symrec), compsym);
	if (recfound == NULL)
		return NOTPRESENT;
	else
		return recfound->type;
}

/* Check if token is identifier only (must have no whitespace) */
int ident_only(token)
char *token;
{
	/* is an identifier if all characters are in IDENT_CHARS
	   and first character is not a digit */
	return (strspn(token, IDENT_CHARS) == strlen(token) &&
			!isdigit(token[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

# NOTE: DDKBUILD.CMD will exit w/o building a DDK on AXP64 and Alpha.
#        This is by design.
BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_base.ini  ddk $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  hal_base.ini  hal $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ifs_base.ini  ifs $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  processor_base.ini  processor $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\cscdll.c ===
#include "basepch.h"
#pragma hdrstop

#include <cscapi.h>

static
BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
    )
{
    return FALSE;
}

static
BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(cscdll)
{
    DLOENTRY(9, CSCIsCSCEnabled)
    DLOENTRY(42, CSCQueryFileStatusW)
};

DEFINE_ORDINAL_MAP(cscdll)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\basepch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\cfgmgr32.c ===
#include "basepch.h"
#pragma hdrstop

#define _CFGMGR32_
#include <cfgmgr32.h>

#error Do not add any delayload stubs for CFGMGR32.DLL.
#error CFGMGR32.DLL is just a stub DLL that forwards all its exports
#error to the same-named exports in SETUPAPI.DLL.
#error So you should change your SOURCES file
#error to link to SETUPAPI.LIB instead of CFGMGR32.LIB.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\dnsapi.c ===
#include "pch.h"
#pragma hdrstop


#define DNS_STATUS       LONG
#define PIP4_ARRAY       PVOID
#define PDNS_RECORD      PVOID
#define DNS_FREE_TYPE    DWORD
#define DNS_NAME_FORMAT  DWORD

static
BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    )
{
    return FALSE;
}

static
DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      LPSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    return;
}

static
DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}


DEFINE_PROCNAME_ENTRIES(dnsapi)
{
    DLPENTRY(DnsNameCompare_UTF8)
    DLPENTRY(DnsNameCompare_W)
    DLPENTRY(DnsQuery_UTF8)
    DLPENTRY(DnsRecordListFree)
    DLPENTRY(DnsValidateName_W)
};

DEFINE_PROCNAME_MAP(dnsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\pch.h ===
#pragma once

#include <dloadexcept.h>
#include "dload.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\ocmanage.c ===
#include "basepch.h"
#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include <ocmgrlib.h>


static
PVOID
OcInitialize(
    IN  POCM_CLIENT_CALLBACKS Callbacks,
    IN  LPCTSTR               MasterOcInfName,
    IN  UINT                  Flags,
    OUT PBOOL                 ShowError,
    IN  PVOID                 Log
    )
{
    return NULL;
}

static
VOID
OcTerminate(
    IN OUT PVOID *OcManagerContext
    )
{
}

static
UINT
OcGetWizardPages(
    IN  PVOID                OcManagerContext,
    OUT PSETUP_REQUEST_PAGES Pages[WizPagesTypeMax]
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
HPROPSHEETPAGE
OcCreateOcPage(
    IN PVOID             OcManagerContext,
    IN POC_PAGE_CONTROLS WizardPageControlsInfo,
    IN POC_PAGE_CONTROLS DetailsPageControlsInfo
    )
{
    return NULL;
}

static
HPROPSHEETPAGE
OcCreateSetupPage(
    IN PVOID                OcManagerContext,
    IN PSETUP_PAGE_CONTROLS ControlsInfo
    )
{
    return NULL;
}

static
VOID
OcRememberWizardDialogHandle(
    IN PVOID OcManagerContext,
    IN HWND  DialogHandle
    )
{
}

static
BOOL
OcSubComponentsPresent(
    IN PVOID OcManagerContext
   )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ocmanage)
{
    DLPENTRY(OcCreateOcPage)
    DLPENTRY(OcCreateSetupPage)
    DLPENTRY(OcGetWizardPages)
    DLPENTRY(OcInitialize)
    DLPENTRY(OcRememberWizardDialogHandle)    
    DLPENTRY(OcSubComponentsPresent)
    DLPENTRY(OcTerminate)
};

DEFINE_PROCNAME_MAP(ocmanage)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\pidgen.c ===
#include "basepch.h"
#pragma hdrstop

static
BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,
    LPCWSTR lpstrRpc,
    LPCWSTR lpstrSku,
    LPCWSTR lpstrOemId,
    LPWSTR  lpstrLocal24,
    LPBYTE lpbPublicKey,
    DWORD  dwcbPublicKey,
    DWORD  dwKeyIdx,
    BOOL   fOem,

    LPWSTR lpstrPid2,
    LPBYTE  lpbPid3,
    LPDWORD lpdwSeq,
    LPBOOL  pfCCP,
    LPBOOL  pfPSS)
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(pidgen)
{
    DLOENTRY(  2, PIDGenW)    
};

DEFINE_ORDINAL_MAP(pidgen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\sfc.c ===
#include "basepch.h"
#pragma hdrstop

#include <sfcapip.h>
#include <winwlx.h>

static
BOOL
WINAPI
SfcIsFileProtected(
    IN HANDLE RpcHandle, // must be NULL
    IN LPCWSTR ProtFileName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SfcGetNextProtectedFile(
    IN HANDLE RpcHandle, // must be NULL
    IN PPROTECTED_FILE_DATA ProtFileData
    )
{
    return FALSE;
}

static
VOID
SfcWLEventLogon(
    IN PWLX_NOTIFICATION_INFO pInfo
    )
{
    NOTHING;
}

VOID
SfcWLEventLogoff(
    IN PWLX_NOTIFICATION_INFO pInfo
    )
{
    NOTHING;
}

static
HANDLE
WINAPI
SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    return NULL;
}

static
VOID
SfcClose(
    IN HANDLE RpcHandle
    )
{
    NOTHING;
}

static
DWORD
WINAPI
SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return 0;
}

static
DWORD
WINAPI
SfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    )
{
    return 0;
}

static
ULONG
SfcInitProt(
    IN ULONG OverrideRegistry,
    IN ULONG ReqDisable,
    IN ULONG ReqScan,
    IN ULONG ReqQuota,
    IN HWND ProgressWindow, OPTIONAL
    IN PCWSTR SourcePath, OPTIONAL
    IN PCWSTR IgnoreFiles OPTIONAL
    )
{
    return STATUS_UNSUCCESSFUL;
}

static
VOID
SfcTerminateWatcherThread(
    VOID
    )
{
    return;
}

static
BOOL
WINAPI
SfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context
    )
{
    return FALSE;
}

DWORD
SfpInstallCatalog(
    IN LPCTSTR pszCatName, 
    IN LPCTSTR pszCatDependency,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
SfpDeleteCatalog(
    IN LPCTSTR pszCatName,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


BOOL
SfpVerifyFile(
    IN LPCTSTR pszFileName,
    IN LPTSTR  pszError,
    IN DWORD   dwErrSize
    )
{
    return FALSE;    
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(sfc)
{    
    DLOENTRY(1, SfcInitProt)
    DLOENTRY(2, SfcTerminateWatcherThread)
    DLOENTRY(3, SfcConnectToServer)
    DLOENTRY(4, SfcClose)
    DLOENTRY(5, SfcFileException)
    DLOENTRY(6, SfcInitiateScan)
    DLOENTRY(7, SfcInstallProtectedFiles)
    DLOENTRY(8, SfpInstallCatalog)
    DLOENTRY(9, SfpDeleteCatalog)
};

DEFINE_ORDINAL_MAP(sfc)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(sfc)
{
    DLPENTRY(SfcGetNextProtectedFile)
    DLPENTRY(SfcIsFileProtected)
    DLPENTRY(SfcWLEventLogoff)
    DLPENTRY(SfcWLEventLogon)
    DLPENTRY(SfpVerifyFile)
};

DEFINE_PROCNAME_MAP(sfc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\syssetup.c ===
#include "basepch.h"
#pragma hdrstop

#include <prsht.h>
#include <setupapi.h>
#include <syssetup.h>

static
DWORD
SetupChangeFontSize(
    HWND Window,
    PCWSTR SizeSpec)
{
    return ERROR_NOT_ENOUGH_MEMORY;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(syssetup)
{
    DLPENTRY(SetupChangeFontSize)
};

DEFINE_PROCNAME_MAP(syssetup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\sxs.c ===
#include "basepch.h"
#include "sxsapi.h"

DEFINE_PROCNAME_ENTRIES(sxs)
{
    DLPENTRY(SxsBeginAssemblyInstall)
    DLPENTRY(SxsEndAssemblyInstall)
    DLPENTRY(SxsInstallAssemblyW)
};

DEFINE_PROCNAME_MAP(sxs)

static BOOL g_fSxsBeginAssemblyInstallFailed = FALSE;
static BOOL g_fSxsInstallAssemblyFailed = FALSE;

BOOL
WINAPI
SxsBeginAssemblyInstall(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    )
{
    g_fSxsBeginAssemblyInstallFailed = TRUE;
    if (InstallCookie != NULL) {
        *InstallCookie = NULL;
    }
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL
WINAPI
SxsInstallAssemblyW(
    IN PVOID InstallCookie OPTIONAL,
    IN DWORD Flags,
    IN PCWSTR ManifestPath,
    IN OUT PVOID Reserved OPTIONAL
    )
{
    g_fSxsInstallAssemblyFailed = TRUE;
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL
WINAPI
SxsEndAssemblyInstall(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    IN OUT PVOID Reserved OPTIONAL
    )
{
    if (g_fSxsBeginAssemblyInstallFailed || g_fSxsInstallAssemblyFailed) {
// stage this since it is dependent on headers that are published later in the build
#if defined(MYASSERT)
        MYASSERT(Flags & SXS_END_ASSEMBLY_INSTALL_ABORT);
#endif
        return TRUE;
    }
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dload\setupapi.c ===
#include "basepch.h"
#pragma hdrstop

#define _CFGMGR32_
#include <cfgmgr32.h>

#define _SETUPAPI_
#include <setupapi.h>
#include <spapip.h>

static
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
            IN  LOG_CONF  lcLogConf
            )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
             OUT PLOG_CONF plcLogConf,  OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
    OUT PBOOL pbPresent
    )
{
    *pbPresent = FALSE;
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC()
{
    return CR_FAILURE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
VOID
WINAPI
SetupCloseInfFile(
    IN HINF InfHandle
    )
{
}

static
WINSETUPAPI
VOID
WINAPI
SetupCloseLog (
    VOID
    )
{
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueW(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfW(
    IN  PCWSTR  SourceInfFileName,
    IN  PCWSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PWSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PWSTR  *DestinationInfFileNameComponent OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyW(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCWSTR           InfSectionName  OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN HWND       hwndParent OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoW(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCWSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCWSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN HDEVINFO DeviceInfoSet
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallW(
    IN  HINF    InfHandle,
    IN  PCWSTR  InfSectionName,
    OUT PWSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PWSTR  *Extension              OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCSTR       Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsW(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA  ClassImageListData,
    IN  CONST GUID              *ClassGuid,
    OUT PINT                     ImageIndex
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailW(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_W        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
   return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO         DeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCWSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyW(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsW(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_W    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverW(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_W DriverInfoData  OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
DWORD
WINAPI
SetupGetFieldCount(
    IN PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
LONG
WINAPI
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExW(
    IN HINF         InfHandle           OPTIONAL,
    IN PINFCONTEXT  InfContext          OPTIONAL,
    IN PCWSTR       SourceFile          OPTIONAL,
    IN PCWSTR       SourcePathRoot      OPTIONAL,
    IN PCWSTR       DestinationName     OPTIONAL,
    IN DWORD        CopyStyle,
    IN PSP_FILE_CALLBACK CopyMsgHandler OPTIONAL,
    IN PVOID        Context             OPTIONAL,
    OUT PBOOL       FileWasInUse        OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionW(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SectionName,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionW(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context,
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupLogErrorA (
    IN  LPCSTR             MessageString,
    IN  LogSeverity         Severity
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupLogErrorW (
    IN  LPCWSTR             MessageString,
    IN  LogSeverity         Severity
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HINF
WINAPI
SetupOpenMasterInf(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
VOID
WINAPI
SetupTermDefaultQueueCallback(
    IN PVOID Context
    )
{
}

static
BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    )
{
    return 0;
}

BOOL
pSetupConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    )
{
    if (RequiredSize)
        *RequiredSize = 0;

    *Target=0;

    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
DWORD
pSetupInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
pSetupIsUserAdmin(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
DWORD
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(setupapi)
{
    DLPENTRY(CM_Add_Empty_Log_Conf)
    DLPENTRY(CM_Add_Res_Des)
    DLPENTRY(CM_Free_Log_Conf_Handle)
    DLPENTRY(CM_Get_Child)
    DLPENTRY(CM_Get_DevNode_Custom_PropertyW)
    DLPENTRY(CM_Get_DevNode_Registry_Property_ExW)
    DLPENTRY(CM_Get_DevNode_Status)
    DLPENTRY(CM_Get_DevNode_Status_Ex)
    DLPENTRY(CM_Get_Device_IDW)
    DLPENTRY(CM_Get_Device_ID_ExW)
    DLPENTRY(CM_Get_Device_ID_Size)
    DLPENTRY(CM_Get_Device_Interface_List_ExW)
    DLPENTRY(CM_Get_Device_Interface_List_Size_ExW)
    DLPENTRY(CM_Get_First_Log_Conf)
    DLPENTRY(CM_Get_Next_Log_Conf)
    DLPENTRY(CM_Get_Next_Res_Des)
    DLPENTRY(CM_Get_Parent_Ex)
    DLPENTRY(CM_Get_Res_Des_Data)
    DLPENTRY(CM_Get_Res_Des_Data_Size)
    DLPENTRY(CM_Get_Sibling)
    DLPENTRY(CM_Is_Dock_Station_Present)
    DLPENTRY(CM_Locate_DevNodeW)
    DLPENTRY(CM_Open_DevNode_Key)
    DLPENTRY(CM_Request_Eject_PC)
    DLPENTRY(SetupCloseFileQueue)
    DLPENTRY(SetupCloseInfFile)
    DLPENTRY(SetupCloseLog)
    DLPENTRY(SetupCommitFileQueueW)
    DLPENTRY(SetupCopyOEMInfW)
    DLPENTRY(SetupDefaultQueueCallbackW)
    DLPENTRY(SetupDiBuildDriverInfoList)
    DLPENTRY(SetupDiCallClassInstaller)
    DLPENTRY(SetupDiClassGuidsFromNameW)
    DLPENTRY(SetupDiCreateDevRegKeyW)
    DLPENTRY(SetupDiCreateDeviceInfoList)
    DLPENTRY(SetupDiCreateDeviceInfoW)
    DLPENTRY(SetupDiDeleteDeviceInfo)
    DLPENTRY(SetupDiDestroyClassImageList)
    DLPENTRY(SetupDiDestroyDeviceInfoList)
    DLPENTRY(SetupDiEnumDeviceInfo)
    DLPENTRY(SetupDiEnumDeviceInterfaces)
    DLPENTRY(SetupDiEnumDriverInfoW)
    DLPENTRY(SetupDiGetActualSectionToInstallW)
    DLPENTRY(SetupDiGetClassDevsA)
    DLPENTRY(SetupDiGetClassDevsW)
    DLPENTRY(SetupDiGetClassImageIndex)
    DLPENTRY(SetupDiGetClassImageList)
    DLPENTRY(SetupDiGetClassInstallParamsW)
    DLPENTRY(SetupDiGetDeviceInfoListClass)
    DLPENTRY(SetupDiGetDeviceInstallParamsW)
    DLPENTRY(SetupDiGetDeviceInstanceIdW)
    DLPENTRY(SetupDiGetDeviceInterfaceDetailA)
    DLPENTRY(SetupDiGetDeviceInterfaceDetailW)
    DLPENTRY(SetupDiGetDeviceRegistryPropertyW)
    DLPENTRY(SetupDiGetDriverInfoDetailW)
    DLPENTRY(SetupDiGetDriverInstallParamsW)
    DLPENTRY(SetupDiGetSelectedDevice)
    DLPENTRY(SetupDiGetSelectedDriverW)
    DLPENTRY(SetupDiInstallDevice)
    DLPENTRY(SetupDiOpenDevRegKey)
    DLPENTRY(SetupDiOpenDeviceInfoW)
    DLPENTRY(SetupDiOpenDeviceInterfaceW)
    DLPENTRY(SetupDiRegisterDeviceInfo)
    DLPENTRY(SetupDiRemoveDevice)
    DLPENTRY(SetupDiSelectBestCompatDrv)
    DLPENTRY(SetupDiSetClassInstallParamsW)
    DLPENTRY(SetupDiSetDeviceInstallParamsW)
    DLPENTRY(SetupDiSetDeviceRegistryPropertyW)
    DLPENTRY(SetupDiSetDriverInstallParamsW)
    DLPENTRY(SetupDiSetSelectedDevice)
    DLPENTRY(SetupDiSetSelectedDriverW)
    DLPENTRY(SetupFindFirstLineW)
    DLPENTRY(SetupFindNextLine)
    DLPENTRY(SetupFindNextMatchLineW)
    DLPENTRY(SetupGetBinaryField)
    DLPENTRY(SetupGetFieldCount)
    DLPENTRY(SetupGetFileCompressionInfoW)
    DLPENTRY(SetupGetInfInformationW)
    DLPENTRY(SetupGetIntField)
    DLPENTRY(SetupGetLineByIndexW)
    DLPENTRY(SetupGetLineCountW)
    DLPENTRY(SetupGetLineTextW)
    DLPENTRY(SetupGetMultiSzFieldW)
    DLPENTRY(SetupGetSourceFileLocationW)
    DLPENTRY(SetupGetSourceInfoW)
    DLPENTRY(SetupGetStringFieldW)
    DLPENTRY(SetupInitDefaultQueueCallbackEx)
    DLPENTRY(SetupInstallFileExW)
    DLPENTRY(SetupInstallFilesFromInfSectionW)
    DLPENTRY(SetupInstallFromInfSectionW)
    DLPENTRY(SetupInstallServicesFromInfSectionW)
    DLPENTRY(SetupLogErrorA)
    DLPENTRY(SetupLogErrorW)
    DLPENTRY(SetupOpenAppendInfFileW)
    DLPENTRY(SetupOpenFileQueue)
    DLPENTRY(SetupOpenInfFileW)
    DLPENTRY(SetupOpenLog)
    DLPENTRY(SetupOpenMasterInf)
    DLPENTRY(SetupQueryInfVersionInformationW)
    DLPENTRY(SetupQueueCopyW)
    DLPENTRY(SetupScanFileQueueW)
    DLPENTRY(SetupSetDirectoryIdExW)
    DLPENTRY(SetupTermDefaultQueueCallback)
    DLPENTRY(pSetupConcatenatePaths)
    DLPENTRY(pSetupGetQueueFlags)
    DLPENTRY(pSetupInstallCatalog)
    DLPENTRY(pSetupIsUserAdmin)
    DLPENTRY(pSetupSetQueueFlags)
};

DEFINE_PROCNAME_MAP(setupapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\dloadhandler\kernel32dloadhandler.c ===
// this file builds a "lib" (really just an .obj) for people who want to
// use the kernel32.dll delay-load exception handler.

#define DELAYLOAD_VERSION 0x0200

#include <windows.h>
#include <delayimp.h>

// kernel32's base hmodule
extern HANDLE   BaseDllHandle;

// prototype (implemented in kernl32p.lib)
FARPROC
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


// people who care about being notified of dll loadlibray will override this 
PfnDliHook __pfnDliNotifyHook2;

// Instead of implementing a "notify hook" (__pfnDliNotifyHook2) or a 
// "failure hook" (__pfnDliFailureHook2) we are just going to up and implement
// __delayLoadHelper2 which is the stub who's fn. pointer is filled in all
// of the import tables for delayloaded entries. 
//
// This will effectively bypass the linker's LoadLibrary/GetProcAddress thunk code 
// as we simply duplicate it here (most of this fn. was stolen from \vc7\delayhlp.cpp)
 
FARPROC
WINAPI
__delayLoadHelper2(
    PCImgDelayDescr pidd,
    FARPROC *       ppfnIATEntry
    )
{
    UINT iINT;
    PCImgThunkData pitd;
    LPCSTR pszProcName;
    LPCSTR pszDllName = (LPCSTR)PFromRva(pidd->rvaDLLName, NULL);
    HMODULE* phmod = (HMODULE*)PFromRva(pidd->rvaHmod, NULL);
    PCImgThunkData pIAT = (PCImgThunkData)PFromRva(pidd->rvaIAT, NULL);
    PCImgThunkData pINT = (PCImgThunkData)PFromRva(pidd->rvaINT, NULL);
    FARPROC pfnRet = 0;
    HMODULE hmod = *phmod;

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    iINT = IndexFromPImgThunkData((PCImgThunkData)ppfnIATEntry, pIAT);

    pitd = &(pINT[iINT]);

    if (!IMAGE_SNAP_BY_ORDINAL(pitd->u1.Ordinal))
    {
        PIMAGE_IMPORT_BY_NAME pibn = (PIMAGE_IMPORT_BY_NAME)PFromRva((RVA)pitd->u1.AddressOfData, NULL);

        pszProcName = pibn->Name;
    }
    else
    {
        pszProcName = MAKEINTRESOURCEA(IMAGE_ORDINAL(pitd->u1.Ordinal));
    }

    if (hmod == 0)
    {
        hmod = LoadLibraryA(pszDllName);

        if (hmod != 0)
        {
            // Store the library handle.  If it is already there, we infer
            // that another thread got there first, and we need to do a
            // FreeLibrary() to reduce the refcount
            //
            HMODULE hmodT = (HMODULE)InterlockedCompareExchangePointer((void**)phmod, (void*)hmod, NULL);
            if (hmodT == NULL)
            {
                DelayLoadInfo dli = {0};

                dli.cb = sizeof(dli);
                dli.szDll = pszDllName;
                dli.hmodCur = hmod;

                // call the notify hook to inform them that we have successfully LoadLibrary'ed a dll.
                // (we do this in case they want to free it when they unload)
                if (__pfnDliNotifyHook2 != NULL)
                {
                    __pfnDliNotifyHook2(dliNoteEndProcessing, &dli);
                }
            }
            else
            {
                // some other thread beat us to loading this module, use the existing hmod
                FreeLibrary(hmod);
                hmod = hmodT;
            }
        }
    }

    if (hmod)
    {
        // Go for the procedure now.
        pfnRet = GetProcAddress(hmod, pszProcName);
    }

    if (pfnRet == 0)
    {
        pfnRet = DelayLoadFailureHook(pszDllName, pszProcName);
    }

    *ppfnIATEntry = pfnRet;

    return pfnRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\cdboot\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\cdboot.obj \
     $(O)\cdboot.res

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib
        

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OBJS) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\cpuid\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\cpuid.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\cdboot\cdboot.c ===
#include <efi.h>
#include <efilib.h>


//
// Prototype
//
void TrimNonPrint(CHAR16 * str);
void Launch (CHAR16 *exePath);

//
//Globals
//
EFI_HANDLE ExeHdl;
EFI_LOADED_IMAGE *ExeImage;

//
// Defines
//
#define REGISTER1 L"*register"
#define REGISTER2 L"*register*"
#define STARTFILE L"startup.nsh"
#define BOOTOFILE L"boot.nvr"
#define OSLOADOPT L"OSLOADER"
#define PARTENT   L"partition"
#define PARTENTRE L"*partition*"

#define APPNAME_TOLAUNCH   L"setupldr.efi"

EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{

	EFI_STATUS Status;
	EFI_FILE_HANDLE bootFile;
    UINTN Count;
    BOOLEAN LaunchTheApplication;
    CHAR16 App[30];

    InitializeLib (ImageHandle, SystemTable);
	
	ExeHdl = ImageHandle;
	BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, &ExeImage);

    LaunchTheApplication = FALSE;

    ST->ConOut->ClearScreen(ST->ConOut);

    Print (L"Press any key to boot from CD-ROM...");
    for (Count = 0; Count < 3; Count++) {
        Status = WaitForSingleEvent (ST->ConIn->WaitForKey,1*10000000);

        if (Status != EFI_TIMEOUT){
            LaunchTheApplication = TRUE;
            break;
        }

        Print(L".");

    }

    if (!LaunchTheApplication) {

        BS->Exit(ExeHdl,EFI_TIMEOUT,0,NULL);

    }

    StrCpy(App, APPNAME_TOLAUNCH);        
    
    Launch( App );
    

    

	//
	// If we get here, we failed to load the OS
	//
    Print(L"Failed to launch SetupLDR.");

	return EFI_SUCCESS;
}

void
Launch (CHAR16 *exePath)
{
	EFI_HANDLE exeHdl=NULL;
	UINTN i;
	EFI_DEVICE_PATH *ldrDevPath;
	EFI_STATUS 	Status;
    EFI_FILE_IO_INTERFACE   *Vol;
	EFI_FILE_HANDLE         RootFs;
	EFI_FILE_HANDLE         CurDir;
	EFI_FILE_HANDLE         FileHandle;
	CHAR16                  FileName[100],*DevicePathAsString;

	
    //
    // Open the volume for the device where the exe was loaded from.
    //
    Status = BS->HandleProtocol (ExeImage->DeviceHandle,
                                 &FileSystemProtocol,
                                 &Vol
                                 );

    if (EFI_ERROR(Status)) {
        Print(L"Can not get a FileSystem handle for ExeImage->DeviceHandle\n");
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }	
	Status = Vol->OpenVolume (Vol, &RootFs);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the volume for the file system\n");
		 BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	
	CurDir = RootFs;
	
	//
	// Open the file relative to the root.
	//
	
	DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
	
	if (DevicePathAsString!=NULL) {
		StrCpy(FileName,DevicePathAsString);
		FreePool(DevicePathAsString);
	}

	FileName[0] = 0;
	StrCat(FileName,exePath);

//    size = StrLen(FileName);
//    Print(L"Length of filename is %d\n", size);
//    DumpHex(4, 0, 10, &FileName[size - 4]);

    //
    // Get rid of trailing spaces, new lines, whatever
    //
    TrimNonPrint(FileName);


	Status = CurDir->Open (CurDir,
						&FileHandle,
						FileName,
						EFI_FILE_MODE_READ,
						0
						);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the file ->%s<-, error was %X\n",FileName, Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	} else {
//		Print(L"Opened %s\n",FileName);
	}

	ldrDevPath  = FileDevicePath (ExeImage->DeviceHandle,FileName);

/*
	if (ldrDevPath) {
		Print (L"Type: %d\nSub-Type: %d\nLength[0][1]: [%d][%d]\n",ldrDevPath->Type,
			ldrDevPath->SubType,ldrDevPath->Length[0],ldrDevPath->Length[1]);
	}else {
		Print (L"bad dev path\n");
	}
*/
//	DumpHex (4,0,ldrDevPath->Length[0],ldrDevPath);

	Status = BS->LoadImage (FALSE,ExeHdl,ldrDevPath,NULL,0,&exeHdl);
	if (!(EFI_ERROR (Status))) {
//		Print (L"Image loaded!\n");
	
	}else {
		Print (L"Load Error: %X\n",Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	FreePool (ldrDevPath);

	BS->StartImage (exeHdl,&i,NULL);

	return;
}


void
TrimNonPrint(
	CHAR16 * str
)
{
	INTN i,size;


    if ((NULL == str) || (L'\0' == *str)) {
        return;
    }

    size = (INTN) StrLen(str);

//    Print(L"Size is %d\n", size);
//    DumpHex(4, 0, 2, &str[size]);

    for (i = size; i > 0; i--) {

        if (str[i] <= 0x20) {
            str[i] = L'\0';
        }
        else {
            // Leave when we hit a legit character
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\crypto.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    crypto.c
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History

    ** Intel 2000 Update for EFI 1.0
    ** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
    ** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
    ** Digital Equipment Corporation, Maynard, Mass.
    ** To anyone who acknowledges that this file is provided AS IS
    ** without any express or implied warranty: permission to use, copy,
    ** modify, and distribute this file for any purpose is hereby
    ** granted without fee, provided that the above copyright notices and
    ** this notice appears in all source code copies, and that none of
    ** the names of Open Software Foundation, Inc., Hewlett-Packard
    ** Company, or Digital Equipment Corporation be used in advertising
    ** or publicity pertaining to distribution of the software without
    ** specific, written prior permission. Neither Open Software
    ** Foundation, Inc., Hewlett-Packard Company, nor Digital Equipment
    ** Corporation makes any representations about the suitability of
    ** this software for any purpose.

*/


#include "efi.h"
#include "efilib.h"
#include "md5.h"

#define HASHLEN 16

void GenNodeID(
  unsigned char *pDataBuf,
  long cData, 
  UINT8 NodeID[]
)
{
  int i, j;
  unsigned char Hash[HASHLEN];
  MD5_CTX context;

  MD5Init (&context);

  MD5Update (&context, pDataBuf, cData);

  MD5Final (&context);

  for (j = 0; j<6; j++) {
    NodeID[j]=0;
  }
  
  for (i = 0,j = 0; i < HASHLEN; i++) {
    NodeID[j++] ^= Hash[i];
    if (j == 6) {
      j = 0;
    }
  }
  NodeID[0] |= 0x80; // set the multicast bit
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\diskpart.c ===
/*

Module Name:

    DiskPart - GUID Partition Table scheme disk partitioning program.
                (The GPT version of FDISK, if you will)

Abstract:

Revision History

*/

#include "DiskPart.h"
#include "symbols.h"
#include "helpmsg.h"

//
// Globals
//
UINTN       DebugLevel = DEBUG_NONE;
//UINTN       DebugLevel = DEBUG_OPPROMPT;

EFI_STATUS  status;
EFI_HANDLE  *DiskHandleList = NULL;
INTN        DiskHandleCount = 0;
INTN        SelectedDisk = -1;

EFI_HANDLE  SavedImageHandle;

EFI_STATUS  ParseAndExecuteCommands();
BOOLEAN     ExecuteSingleCommand(CHAR16 *Token[]);




VOID DumpGPT(
        EFI_HANDLE DiskHandle,
        PGPT_HEADER Header,
        PGPT_TABLE Table,
        BOOLEAN Raw,
        BOOLEAN Verbose
        );
VOID
PrintGptEntry(
    GPT_ENTRY   *Entry,
    UINTN       Index
    );


EFI_GUID
GetGUID(
    );

#define CLEAN_RANGE (1024*1024)


CHAR16  *TokenChar =
L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`~!@#$%^&*()-_+[]{}':;/?.>,<\\|";



VOID    CmdInspectMBR(CHAR16  **Token);
VOID    CmdCreateMBR(CHAR16  **Token);
VOID    CmdNewMBR(CHAR16  **Token);
VOID    CmdDeleteMBR(CHAR16  **Token);

//
// Worker function type
//
typedef
BOOLEAN
(*PCMD_FUNCTION)(
    CHAR16  **Token
    );

EFI_STATUS
ReinstallFSDStack(
    );

//
// The parse table structure
//
typedef struct {
    CHAR16          *Name;
    PCMD_FUNCTION   Function;
    CHAR16          *HelpSummary;
} CMD_ENTRY;

//
// The parse/command table
//
CMD_ENTRY   CmdTable[] = {
                { STR_LIST,     CmdList,    MSG_LIST },
                { STR_SELECT,   CmdSelect,  MSG_SELECT },
                { STR_INSPECT,  CmdInspect, MSG_INSPECT },
                { STR_CLEAN,    CmdClean,   MSG_CLEAN },
                { STR_NEW,      CmdNew,     MSG_NEW },
                { STR_FIX,      CmdFix,     MSG_FIX },
                { STR_CREATE,   CmdCreate,  MSG_CREATE },
                { STR_DELETE,   CmdDelete,  MSG_DELETE },
                { STR_HELP,     CmdHelp,    MSG_HELP },
                { STR_HELP2,    CmdHelp,    MSG_ABBR_HELP },
                { STR_HELP3,    CmdHelp,    MSG_ABBR_HELP },
                { STR_EXIT,     CmdExit,    MSG_EXIT },
                { STR_SYMBOLS,  CmdSymbols, MSG_SYMBOLS },
                { STR_REMARK,   CmdRemark,  MSG_REMARK },
                { STR_MAKE,     CmdMake,    MSG_MAKE },
                { STR_DEBUG,    CmdDebug,   NULL },
                { STR_ABOUT,    CmdAbout,   MSG_ABOUT },
                { NULL, NULL, NULL }
            };


EFI_STATUS
EfiMain(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    //
    // Initialize the Library.
    //
    SavedImageHandle = ImageHandle;
    InitializeLib (ImageHandle, SystemTable);


    Print(L"DiskPart Version 0.2\n");
    Print(L"Based on EFI core release ");
    Print(MSG_ABOUT02,
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    //
    // See if there are any disks that look like candidates to be partitioned
    //
    status = FindPartitionableDevices(&DiskHandleList, &DiskHandleCount);
    if (EFI_ERROR(status)) {
        Print(L"%s\n", MSG_NO_DISKS);
        return EFI_NOT_FOUND;
    }

    //
    // Start Parse Loop
    //
    ParseAndExecuteCommands();
    
    ReinstallFSDStack();

    DoFree(DiskHandleList);
    return status;
}


EFI_STATUS
ReinstallFSDStack(
    )
/*++ 

    Make sure that the partition driver is alerted to the changes in the
    the file system structures.  One way to effect this end is to 
    reinstall all of the blkio interfaces such that the partition driver
    will receive a notification and probe the partition tables to reconstruct
    the file system stack.


--*/
{
    INTN            Index;      
    EFI_STATUS      Status;
    EFI_BLOCK_IO    *IBlkIo;

    Status = EFI_SUCCESS;

    for (Index = 0; Index < DiskHandleCount; Index++) {
   
        Status = BS->HandleProtocol(
                          DiskHandleList[Index], 
                          &BlockIoProtocol, 
                          &IBlkIo
                          );
 
        if (!EFI_ERROR(Status)) {
            Status = BS->ReinstallProtocolInterface (
                                DiskHandleList[Index], 
                                &BlockIoProtocol, 
                                IBlkIo, 
                                IBlkIo
                                );   
	      }
    }

    return Status;
}




EFI_STATUS
ParseAndExecuteCommands()
/*
    ParseAndExecuteCommands reads 1 line at a time from stdin.
    Lines are parsed for commands and arguments.
    The symbol ";" (semicolon) is used to mark the end of a command
    and start a new one.
    \ is the escape, \\ => '\'

    All commands are upper cased before parsing to give us
    case insensitive operations.  This does not apply to literal
    strings.

    Any white space is treated a token separator.

    Commandline is set quite long.
*/
{
    CHAR16  *Prompt = MSG_PROMPT;
    CHAR16  CommandLine[COMMAND_LINE_MAX];
    CHAR16  *Token[TOKEN_COUNT_MAX];
    UINTN   i;

NewLine:
    while (TRUE) {
        for (i = 0; i < COMMAND_LINE_MAX; i++ ) {
            CommandLine[i] = NUL;
        }
        Input(Prompt, CommandLine, COMMAND_LINE_MAX);
        Print(L"\n");
        if (CommandLine[0] == NUL) {
            continue;
        }
        StrUpr(CommandLine);
        Tokenize(CommandLine, Token);

        if (Token[0] == (CHAR16 *)-1) {
            //
            // syntax error
            //
            Print(L"???\n");
            goto NewLine;
        }

        if (ExecuteSingleCommand(Token) == TRUE) {
            return TRUE;
        }
        if (DebugLevel >= DEBUG_ERRPRINT) {
            if (EFI_ERROR(status)) {
                Print(L"status = %x %r\n", status, status);
            }
        }
    }
    return EFI_SUCCESS;
}


VOID
Tokenize(
    CHAR16  *CommandLine,
    CHAR16  *Token[]
    )
/*
    Tokenize -

        find the tokens, where a token is any string of letter & numbers.
        tokens to contain blanks, etc, must begin end with "

    return
        Token[] set.  if Token[0] = NULL, nothing in THIS command
*/
{
    CHAR16  *ch;
    UINTN   tx;

    //
    // init the token array
    //
    for (tx = 0; tx < TOKEN_COUNT_MAX; tx++) {
        Token[tx] = NULL;
    }
    tx = 0;

    //
    // sweep for tokens
    //
    ch = CommandLine;
    while (TRUE) {

        //
        // if we see a quote, advance to the closing quote
        // and call the result a token.
        //
        if (*ch == '"') {
            ch++;
            Token[tx] = ch;
            while ((*ch != '"') && (*ch != NUL)) {
                ch++;
            }
            if (*ch == '"') {
                //
                // we have the closing ", we have a token
                //
                *ch = NUL;                   // mark end of token
                ch++;
                tx++;
            } else {
                Token[0] = (CHAR16 *)-1;              // report error
                return;
            }
        } else {
            //
            // not a quoted string, so pick off a normal token
            //
            // Start by finding start of token
            //
            for ( ; *ch != NUL; ch++) {
                if (IsIn(*ch, TokenChar)) {
                    Token[tx] = ch;
                    tx++;
                    break;
                }
            }
            while (IsIn(*ch, TokenChar)) {
                ch++;
            }

            //
            // if we're at the end of the command line, we're done
            // else, trim off token and go on
            //
            if (*ch == NUL) {
                //
                // we hit the end
                //
                Token[tx] = NULL;
                return;
            } else {
                *ch = NUL;
                ch++;
            }
        } // else
    } // while
}

BOOLEAN
ExecuteSingleCommand(
    CHAR16      *Token[]
    )
/*
    Returns TRUE to tell program to exit, else FALSE

*/
{
    UINTN   i;

    for (i = 0; CmdTable[i].Name != NULL; i++) {
        if (StrCmp(CmdTable[i].Name, Token[0]) == 0) {
            return CmdTable[i].Function(Token);
        }
    }

    //
    // If we're here, we didn't understand the command
    //
    Print(L"%s\n%s\n", MSG_BAD_CMD, MSG_GET_HELP);
    return FALSE;
}

BOOLEAN
CmdAbout(
    CHAR16  **Token
    )
{
    Print(MSG_ABOUT02,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );
    return FALSE;
}

BOOLEAN
CmdList(
    CHAR16  **Token
    )
/*
    CmdList - print the list of Partionable Disks

    Globals:    DiskHandleList, DiskHandleCount
    Cmd Args:   None.
*/
{
    INTN            i;
    EFI_BLOCK_IO    *BlkIo;
    CHAR16          c;

    Print(MSG_LIST01);
    Print(MSG_LIST01B);
    for (i = 0; i < DiskHandleCount; i++) {
        status = BS->HandleProtocol(DiskHandleList[i], &BlockIoProtocol, &BlkIo);

        if (i == SelectedDisk) {
            c = '*';
        } else {
            c = ' ';
        }

        if (EFI_ERROR(status)) {
            Print(MSG_LIST03, i);
        } else {
            Print(
                MSG_LIST02,
                c,
                i,
                BlkIo->Media->BlockSize,
                BlkIo->Media->LastBlock+1
                );
        }
    }
    return FALSE;
}

BOOLEAN
CmdSelect(
    CHAR16  **Token
    )
/*
    CmdSelect - Select the disk that most commands operate on.

    Globals:    SelectedDisk, DiskHandleCount
    Options:    None.
    Cmd Args:   none for display, number to select
*/
{
    INTN     NewSelect;

    if (Token[1] == NULL) {
        if (SelectedDisk == -1) {
            Print(MSG_SELECT01);
        } else {
            Print(MSG_SELECT02, SelectedDisk);
        }
    } else {
        NewSelect = Atoi(Token[1]);
        if ((NewSelect >= 0) &&
            (NewSelect < DiskHandleCount) &&
            (IsIn(*Token[1], L"0123456789")) )
        {
            SelectedDisk = NewSelect;
            Print(MSG_SELECT02, SelectedDisk);
        } else {
            Print(MSG_SELECT03);
        }
    }
    return FALSE;
}

BOOLEAN
CmdInspect(
    CHAR16  **Token
    )
/*
    CmdInspect - report data on the currently selected disk

    Globals:    SelectedDisk, DiskHandleList
    Cmd Args:   [RAW] [VER]
*/
{
    EFI_HANDLE  DiskHandle;
    UINTN       DiskType = 0;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    BOOLEAN     Raw;
    BOOLEAN     Verbose;
    UINTN       i;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }


    if (DiskType == DISK_RAW) {
        Print(MSG_INSPECT04);
        goto Exit;

    } else if (DiskType == DISK_MBR) {
        CmdInspectMBR(Token);
        goto Exit;

    } else if (DiskType == DISK_GPT_BAD) {
        Print(MSG_INSPECT06);
        goto Exit;

    } else if ( (DiskType != DISK_GPT_UPD) &&
                (DiskType != DISK_GPT))
    {
        TerribleError(L"Bad Disk Type returnted to Inspect!");
        goto Exit;
    }

    if (DiskType == DISK_GPT_UPD) {
        Print(MSG_INSPECT03);
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(InspectHelpText);
        goto Exit;
    }

    Raw = FALSE;
    Verbose = FALSE;
    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_RAW) == 0) {
            Raw = TRUE;
        } else if (StrCmp(Token[i], STR_VER) == 0) {
            Verbose = TRUE;
        } else {
            PrintHelp(InspectHelpText);
            goto Exit;
        }
    }
    DumpGPT(DiskHandle, Header, Table, Raw, Verbose);

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


typedef struct {
    UINTN   Slot;
    EFI_LBA StartingLBA;
} SORT_SLOT_ENTRY;

VOID
DumpGPT(
    EFI_HANDLE  DiskHandle,
    PGPT_HEADER Header,
    PGPT_TABLE  Table,
    BOOLEAN     Raw,
    BOOLEAN     Verbose
    )
/*
    DumpGPT - print out the GPT passed in via Header and Table

    if (Raw) print slot order, all slots, table order.
        else print only allocated slots, StartingLBA order.
    if (Verbose) print out the Header data.
*/
{
    EFI_BLOCK_IO    *BlkIo;
    UINTN           i;
    UINTN           AllocatedSlots;
    CHAR16          Buffer[PART_NAME_LEN+1];
    BOOLEAN         changed;
    SORT_SLOT_ENTRY *SortSlot;
    GPT_ENTRY       Entry;
    UINTN           tslot;
    EFI_LBA         tlba;

    SortSlot = DoAllocate(Header->EntriesAllocated * sizeof(SORT_SLOT_ENTRY));
    if (SortSlot == NULL) {
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_INSPECT02);
        return;
    }

    //
    // Dump the handle data just as List would
    //
    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    Print(MSG_LIST01);
    Print(MSG_LIST01B);
    Print(MSG_LIST02, '*', SelectedDisk, BlkIo->Media->BlockSize, BlkIo->Media->LastBlock+1);

    if (Verbose) {
        //
        // Dump the header
        //
        Print(L"\nHeader Structure\n");
        Print(L"         Signature= %16lx     Revision=%8X\n",
            Header->Signature, Header->Revision);
        Print(L"        HeaderSize=%8x           HeaderCRC32=%8x\n",
            Header->HeaderSize, Header->HeaderCRC32);
        Print(L"             MyLBA=%16lx  AlternateLBA=%16lx\n",
            Header->MyLBA, Header->AlternateLBA);
        Print(L"    FirstUsableLBA=%16lx LastUsableLBA=%16lx\n",
            Header->FirstUsableLBA, Header->LastUsableLBA);
        Print(L"          TableLBA=%16lx\n", Header->TableLBA);
        Print(L"    EntrySize=%8x  EntriesAllowed=%8x  TableCRC=%8x\n\n",
            Header->SizeOfGPT_ENTRY, Header->EntriesAllocated, Header->TableCRC32);
    }

    //
    // Print the Table of GPT entries
    //
    if (!Raw) {
        //
        // !Raw == Cooked -> Print the Allocated entries in StartingLBA
        // SORTED order...
        //
        // Find ALL of the allocated entries
        //
        AllocatedSlots = 0;
        for (i = 0; i < Header->EntriesAllocated; i++) {
            CopyMem(&Entry, &Table->Entry[i], sizeof(GPT_ENTRY));
            if (CompareMem(&(Entry.PartitionType), &GuidNull, sizeof(EFI_GUID)) != 0) {
                SortSlot[AllocatedSlots].Slot = i;
                SortSlot[AllocatedSlots].StartingLBA = Entry.StartingLBA;
                AllocatedSlots++;
            }
        }
        // j has the count of allocated entries

        //
        // Sort them - yes this is a bubble sort, but the list is probably
        // in order and probably small, so for the vastly typical case
        // this is actually optimal
        //
        if (AllocatedSlots > 0) {
            do {
                changed = FALSE;
                for (i = 0; i < AllocatedSlots-1; i++) {
                    if (SortSlot[i].StartingLBA > SortSlot[i+1].StartingLBA) {
                        tslot = SortSlot[i+1].Slot;
                        tlba = SortSlot[i+1].StartingLBA;
                        changed = TRUE;
                        SortSlot[i+1].Slot = SortSlot[i].Slot;
                        SortSlot[i+1].StartingLBA = SortSlot[i].StartingLBA;
                        SortSlot[i].Slot = tslot;
                        SortSlot[i].StartingLBA = tlba;
                    }
                }
            } while (changed);

            //
            // Print them, but print the SLOT number, not the row number.
            // This is to make Delete be reliable.
            //
            for (i = 0; i < AllocatedSlots; i++) {
                PrintGptEntry(&Table->Entry[SortSlot[i].Slot], SortSlot[i].Slot);
                if (((i+1) % 4) == 0) {
                    Input(MSG_MORE, Buffer, PART_NAME_LEN);
                }
            }
        }

    } else {
        //
        // Raw -> Print ALL of the entries in Table order
        // (mostly for test, debug, looking at cratered disks
        //
        Print(L"RAW RAW RAW\n");
        for (i = 0; i < Header->EntriesAllocated; i++) {
            PrintGptEntry(&Table->Entry[i], i);
            if (((i+1) % 4) == 0) {
                Input(MSG_MORE, Buffer, PART_NAME_LEN);
            }
        }
        Print(L"RAW RAW RAW\n");
    }

    DoFree(SortSlot);
    return;
}


VOID
PrintGptEntry(
    GPT_ENTRY   *Entry,
    UINTN       Index
    )
{
    CHAR16  Buffer[PART_NAME_LEN+1];
    UINTN   j;

    Print(L"\n%3d: ", Index);
    ZeroMem(Buffer, (PART_NAME_LEN+1)*sizeof(CHAR16));
    CopyMem(Buffer, &(Entry->PartitionName), PART_NAME_LEN*sizeof(CHAR16));
    Print(L"%s\n     ", Buffer);
    PrintGuidString(&(Entry->PartitionType));

    for (j = 0; SymbolList[j].SymName; j++) {
        if (CompareMem(&(Entry->PartitionType), SymbolList[j].Value, sizeof(EFI_GUID)) == 0) {
            Print(L" = %s", SymbolList[j].SymName);
        }
     }
     if (CompareMem(&(Entry->PartitionType), &GuidNull, sizeof(EFI_GUID)) == 0) {
        Print(L" = UNALLOCATED SLOT");
    }
    Print(L"\n     ");
    PrintGuidString(&(Entry->PartitionID));
    Print(L" @%16x\n", Entry->Attributes);
    Print(L"      %16lx - %16lx\n",
        Entry->StartingLBA,
        Entry->EndingLBA
        );
}


BOOLEAN
CmdClean(
    CHAR16  **Token
    )
/*
    CmdClean - Clean off the disk

    Globals:    SelectedDisk, DiskHandleList
    Cmd Args:   ALL to clean whole disk, rather than just 1st and last megabyte

    We write out 1 block at a time.  While this is slow, it avoids wondering
    about the Block protocol write size limit, and about how big a buffer
    we can allocate.
*/
{
    EFI_HANDLE  DiskHandle;
    CHAR16  Answer[COMMAND_LINE_MAX];
    BOOLEAN CleanAll;
    UINT32  BlockSize;
    UINT64  DiskSize;
    UINT64  DiskBytes;
    UINT64  RangeBlocks;
    UINT64  EndRange;
    UINT64  i;
    CHAR8   *zbuf;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];
    BlockSize = GetBlockSize(DiskHandle);
    DiskSize = GetDiskSize(DiskHandle);
    DiskBytes = MultU64x32(DiskSize, BlockSize);

    zbuf = DoAllocate(CLEAN_RANGE);
    if (zbuf == NULL) return FALSE;
    ZeroMem(zbuf, CLEAN_RANGE);

    //
    // Are you sure?
    //
    Print(MSG_CLEAN01, SelectedDisk);
    Input(STR_CLEAN_PROMPT, Answer, COMMAND_LINE_MAX);
    StrUpr(Answer);
    Print(L"\n");
    if (StrCmp(Answer, L"Y") != 0) {
        DoFree(zbuf);
        return FALSE;
    }

    //
    // Are you REALLY Sure?
    //
    Print(MSG_CLEAN02);
    Input(STR_CLEAN_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    if (StrCmp(Answer, STR_CLEAN_ANS) != 0) {
        DoFree(zbuf);
        return FALSE;
    }

    //
    // OK, the user really wants to do this
    //

    //
    // All? or just start and end?
    //
    CleanAll = FALSE;
    if (Token[1]) {
        if (StrCmp(Token[1], STR_CLEAN03) == 0) {
            CleanAll = TRUE;
        }
    }

    if (DiskBytes > (2 * CLEAN_RANGE)) {
        RangeBlocks = CLEAN_RANGE / BlockSize;
        WriteBlock(DiskHandle, zbuf, 0, CLEAN_RANGE);
        EndRange = DiskSize - RangeBlocks;
        if (CleanAll) {
            for (i=RangeBlocks; i < DiskSize; i += RangeBlocks) {
                WriteBlock(DiskHandle, zbuf, i, CLEAN_RANGE);
            }
        }
        WriteBlock(DiskHandle, zbuf, EndRange, CLEAN_RANGE);
    } else {
        //
        // Kind of a small disk, clean it all always
        //
        for (i = 0; i < DiskSize; i++) {
            WriteBlock(DiskHandle, zbuf, i, BlockSize);
        }
    }
    FlushBlock(DiskHandle);

    DoFree(zbuf);
    return FALSE;
}

BOOLEAN
CmdNew(
    CHAR16  **Token
    )
/*
    CmdNew [mbr | [gpt=numentry]

    Changes a RAW disk into either an MBR (well, somebody) or GPT disk

    "new mbr" - you want an mbr disk (not implemented)
    "new gpt" - you want a gpt disk, you get a default table
    "new gpt=xyz" - you want a gpt disk, with at least xyz entries
                    (you will get less than xyz if exceeds sanity threshold)

    anything else - try again with right syntax
*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header;
    PGPT_TABLE  Table;
    PLBA_BLOCK  LbaBlock;
    UINTN       DiskType;
    UINTN       GptOptSize;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }

    if (DiskType != DISK_RAW) {
        Print(MSG_NEW01, SelectedDisk);
        Print(MSG_NEW02);
        return FALSE;
    }

    //
    // OK, it's a raw disk...
    //
    GptOptSize = 0;

    if (Token[1]) {
        if (StrCmp(Token[1], STR_GPT) == 0) {
            if (Token[2]) {
                GptOptSize = Atoi(Token[2]);
            }
            CreateGPT(DiskHandle, GptOptSize);
        } else if (StrCmp(Token[1], STR_MBR) == 0) {
            CmdNewMBR(Token);
        }
    } else {
        Print(MSG_NEW03);
    }
    return FALSE;
}

BOOLEAN
CmdFix(
    CHAR16  **Token
    )
/*
    CmdFix - very basic tool to try to fix up GPT disks.

    Basic strategy is to read the GPT, if it seems to be a
    GPT disk (not MBR, RAW, or totally dead) then call
    WriteGPT, which will write both GPTs (and thus sync them)
    and rebuild the shadow MBR, all as a matter of course.

*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    UINTN       DiskType;

    //
    // Setup parameters and error handling
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(FixHelpText);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        Print(MSG_FIX05);
        return FALSE;
    }

    //
    // From this point on, must exit this Procedure with a goto Exit
    // to free up allocated stuff, otherwise we leak pool...
    //
    if (DiskType == DISK_RAW) {
        Print(MSG_FIX01);
        goto Exit;
    }

    if (DiskType == DISK_MBR) {
        Print(MSG_FIX02);
        goto Exit;
    }

    if ((DiskType != DISK_GPT) &&
        (DiskType != DISK_GPT_UPD)) {
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"DiskType = %d\n", DiskType);
        }
        Print(MSG_FIX03);
        goto Exit;
    }

    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_FIX04);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


//
// ----- Create and sub procs thereof
//

BOOLEAN
CmdCreate(
    CHAR16  **Token
    )
/*
    CmdCreate - Create a new partition

    (Actually, this routine is a GPT only partition creator)

        create name="name string" size=sss type=name typeguid=<guid> attributes=hex
            name is label string
            offset is in megabytes, or start at the end of the last partition if absent
            size is in megabytes, or "fill the disk" if 0 or absent or > free space
            type is any named symbol type (symbols gives list)
            typeguid is an arbitrary type guid
            attributes is hex 32bit flag
            if "help" is first arg, print better help data

            name, type or typeguid, required

        if all that parses out OK, read the gpt, edit it, write it back,
        and voila, we have a new partition.
*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    UINTN       DiskType;
    UINT64      SizeInMegaBytes = 0;
    UINT64      OffsetInBlocks = 0;
    UINT64      StartBlock;
    UINT64      EndBlock;
    UINT64      SizeInBytes = 0;
    UINT64      Attributes = 0;
    UINTN       i;
    UINTN       j;
    EFI_GUID    *TypeGuid = NULL;
    EFI_GUID    GuidBody;
    EFI_GUID    PartitionIdGuid;
    CHAR16      *TypeName = NULL;
    CHAR16      PartName[PART_NAME_LEN+1];           // 36 allowed by spec plus NUL we need
    CHAR16      Buffer[10];
    BOOLEAN     Verbose = FALSE;
    UINT32      BlockSize;
    UINT64      DiskSizeBlocks;
    UINT8       *p;
    BOOLEAN     OffsetSpecified = FALSE;
    BOOLEAN     AllZeros;
    INTN        AllZeroEntry;
    INTN        OldFreeEntry;
    UINT64      AvailBlocks;
    UINT64      BlocksToAllocate;
    UINT64      HighSeen;
    UINTN       Slot;


    //
    // Setup parameters and error handling
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if (Token[1] == NULL) {
        PrintHelp(CreateHelpText);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(CreateHelpText);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }

    BlockSize = GetBlockSize(DiskHandle);
    DiskSizeBlocks = GetDiskSize(DiskHandle);

    //
    // From this point on, must exit this Procedure with a goto Exit
    // to free up allocated stuff, otherwise we leak pool...
    //
    if (DiskType == DISK_RAW) {
        Print(MSG_CREATE01, SelectedDisk);
        goto Exit;
    }

    if (DiskType == DISK_MBR) {
        CmdCreateMBR(Token);
        goto Exit;
    }

    if (DiskType != DISK_GPT) {
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"DiskType = %d\n", DiskType);
        }
        Print(MSG_CREATE02);
        goto Exit;
    }

    //
    // Parse arguments...
    //
    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_NAME) == 0) {
            ZeroMem(PartName, (PART_NAME_LEN+1)*sizeof(CHAR16));
            StrCpy(PartName, Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_TYPE) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            for (j = 0; SymbolList[j].SymName != NULL; j++) {
                if (StrCmp(SymbolList[j].SymName, Token[i+1]) == 0) {
                    TypeGuid = SymbolList[j].Value;
                    TypeName = SymbolList[j].SymName;
                    break;
                }
            }
            if (TypeGuid == NULL) {
                Print(MSG_CREATE03);
                goto Exit;
            }
            i++;
        } else if (StrCmp(Token[i], STR_TYPEGUID) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            status = GetGuidFromString(Token[i+1], &GuidBody);
            if (EFI_ERROR(status)) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            TypeGuid = &GuidBody;
            i++;
        } else if (StrCmp(Token[i], STR_OFFSET) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            OffsetInBlocks = Xtoi64(Token[i+1]);
            OffsetSpecified = TRUE;
            i++;
        } else if (StrCmp(Token[i], STR_SIZE) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            SizeInMegaBytes = Atoi64(Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_ATTR) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            Attributes = Xtoi64(Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_VER) == 0) {
            Verbose = TRUE;
            // do NOT increment i, we only consumed 1 Token
        } else {
            Print(L"\n??? % ???\n", Token[i]);
            PrintHelp(CreateHelpText);
            goto Exit;
        }
    }

    if ( (PartName == NULL) ||
         (TypeGuid == NULL) )
    {
        PrintHelp(CreateHelpText);
        goto Exit;
    }

    if ( (DebugLevel >= DEBUG_ARGPRINT) ||
         (Verbose) )
    {
        Print(L"CmdCreate arguments:\n");
        Print(L"SelectedDisk = %d\n", SelectedDisk);
        Print(L"Name=%s\n", PartName);
        Print(L"TypeGuid = ");
        PrintGuidString(TypeGuid);
        Print(L"\n");
        if (TypeName) {
            Print(L"TypeName = %s\n", TypeName);
        }
        Print(L"Requested OffsetInBlocks = %lx\n", OffsetInBlocks);
        Print(L"Requested SizeInMegaBytes = %ld\n", SizeInMegaBytes);
        Print(L"Attributes = %lx\n", Attributes);
    }
    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    //
    // If Requested size is 0, or greater than size remaining,
    // we want to fill the disk.
    // Otherwise, use enough blocks to provide at *least* the
    // required storage.  (Not likely to be a problem...)
    //

    //
    // First, scan the Table and decide where the first unallocated
    // space is.  Note that for this procedure's primitive space allocation,
    // holes between the beginning of the first allocated partition and
    // the last allocated partition are ignored.
    //

    AllZeroEntry = -1;
    OldFreeEntry  = -1;
    HighSeen = Header->FirstUsableLBA - 1;

    if (OffsetSpecified) {
        //
        // if offset is specified, compute the start and end blocks
        //
        StartBlock = OffsetInBlocks;
        if (StartBlock < Header->FirstUsableLBA ||
            StartBlock > Header->LastUsableLBA) {
            //
            // Offset specified is too large
            //
            status = EFI_INVALID_PARAMETER;
            Print(MSG_CREATE08);
            goto Exit;
        }

        SizeInBytes = MultU64x32(SizeInMegaBytes, (1024*1024));
        if (SizeInBytes < SizeInMegaBytes || SizeInBytes == 0) {
            //
            // If size is not specified or too large,
            // try to make the partition as big as it can be
            //
            BlocksToAllocate = EndBlock = SizeInBytes = 0xffffffffffffffff;
        } else {
            BlocksToAllocate = DivU64x32(SizeInBytes, BlockSize, NULL);
            EndBlock = StartBlock + BlocksToAllocate - 1;
            if (EndBlock > Header->LastUsableLBA) {
                EndBlock = Header->LastUsableLBA;
                BlocksToAllocate = EndBlock - StartBlock + 1;
            }
        }
    }

    for (i = 0; i < Header->EntriesAllocated; i++) {
        if (CompareMem(
                &(Table->Entry[i].PartitionType),
                &GuidNull,
                sizeof(EFI_GUID)
                ) != 0)
        {
            //
            // Type not null, so it's allocated
            //
            if (Table->Entry[i].EndingLBA > HighSeen) {
                HighSeen = Table->Entry[i].EndingLBA;
            }
            if (OffsetSpecified) {
                //
                // make sure new partition does not overlap with existing partitions
                //
                if (Table->Entry[i].StartingLBA <= StartBlock &&
                    StartBlock <= Table->Entry[i].EndingLBA) {
                    //
                    // starting block is inside an existing partition
                    //
                    status = EFI_INVALID_PARAMETER;
                    Print(MSG_CREATE08);
                    goto Exit;
                }
                if ((Table->Entry[i].StartingLBA <= EndBlock &&
                     EndBlock <= Table->Entry[i].EndingLBA) ||
                    (StartBlock <= Table->Entry[i].StartingLBA &&
                     Table->Entry[i].StartingLBA <= EndBlock) ||
                    (StartBlock <= Table->Entry[i].EndingLBA &&
                     Table->Entry[i].EndingLBA <= EndBlock)) {
                    //
                    // new partition overlaps with an existing partition
                    // readjust new partition size to avoid overlapping
                    //
                    EndBlock = Table->Entry[i].StartingLBA-1;
                    if (EndBlock < StartBlock) {
                        status = EFI_INVALID_PARAMETER;
                        Print(MSG_CREATE08);
                        goto Exit;
                    } else {
                        BlocksToAllocate = EndBlock - StartBlock + 1;
                    }
                }
            }
        } else {
            p = (UINT8 *)(&(Table->Entry[i]));
            AllZeros = TRUE;
            for (j = 0; j < sizeof(GPT_ENTRY); j++) {
                if (p[j] != 0) {
                    AllZeros = FALSE;
                }
            }
            if (AllZeros) {
                if (AllZeroEntry == -1) {
                    AllZeroEntry = i;
                }
            } else if (OldFreeEntry == -1) {
                OldFreeEntry = i;
            }
        }
    }

    //
    // AllZeroEntry - if not -1, is pointer to a never before used entry (free)
    // OldFreeEntry - if not -1, is pointer to some pre-used free entry
    //
    if ( (AllZeroEntry == -1) && (OldFreeEntry == -1) ) {
        //
        // TABLE IS FULL!!
        //
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_CREATE04);
        goto Exit;
    }

    if (OffsetSpecified) {
        //
        // the user haven't specified the new partition size and we haven't
        // run into any partition that will limit the size of this new partition.
        // So, use the max it can
        //
        if (BlocksToAllocate == -1) {
            EndBlock = Header->LastUsableLBA;
            BlocksToAllocate = EndBlock - StartBlock + 1;
        }
    } else {
        //
        // [HighSeen+1 ... LastUsableLBA] is available...
        // avail = (LastUsableLBA - (HighSeen+1)) + 1 => LastUsabbleLBA - HighSeen
        //
        AvailBlocks = Header->LastUsableLBA - HighSeen;

        if (AvailBlocks == 0) {
            status = EFI_OUT_OF_RESOURCES;
            Print(MSG_CREATE07);
            goto Exit;
        }

        SizeInBytes = MultU64x32(SizeInMegaBytes, (1024*1024));
        if (SizeInBytes < SizeInMegaBytes) {
            //
            // overflow, force a very big answer
            //
            SizeInBytes = 0xffffffffffffffff;
        }

        if  ((SizeInBytes == 0) ||
             (SizeInBytes > (MultU64x32(AvailBlocks, BlockSize)) ) )
        {
            //
            // User asked for zero, or for more than we've got,
            // so give them all that is left
            //
            BlocksToAllocate = AvailBlocks;

        } else {

            //
            // We would have to have a BlockSize > 1mb for Remainder to
            // not be 0.  Since we cannot actually test this case, we
            // ingore it...
            //
            BlocksToAllocate = DivU64x32(SizeInBytes, BlockSize, NULL);

        }
    }

    //
    // We have a name
    // We have a type guid
    // We have a size in blocks
    // We have an attribute mask
    //

    if (BlocksToAllocate < ((1024*1024)/BlockSize)) {
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_CREATE09);
        goto Exit;
    }

    if ( (Verbose) ||
         (DebugLevel > DEBUG_ARGPRINT) )
    {
        Print(L"Requested SizeInMegaBytes = %ld\n", SizeInMegaBytes);
        Print(L"Resulting size in Blocks = %ld\n", BlocksToAllocate);
        Print(L"Results size in Bytes = %ld\n", MultU64x32(BlocksToAllocate, BlockSize));
    }

    if (AllZeroEntry != -1) {
        Slot = AllZeroEntry;
    } else {
        Slot = OldFreeEntry;
    }

    PartitionIdGuid = GetGUID();
    CopyMem(&(Table->Entry[Slot].PartitionType), TypeGuid, sizeof(EFI_GUID));
    CopyMem(&(Table->Entry[Slot].PartitionID), &PartitionIdGuid, sizeof(EFI_GUID));
    if (OffsetSpecified) {
        Table->Entry[Slot].StartingLBA = StartBlock;
        Table->Entry[Slot].EndingLBA = EndBlock;
    } else {
        Table->Entry[Slot].StartingLBA = HighSeen + 1;
        Table->Entry[Slot].EndingLBA = HighSeen + BlocksToAllocate;
    }

    if (! ( ((Table->Entry[Slot].EndingLBA - Table->Entry[Slot].StartingLBA) + 1) == BlocksToAllocate) ) {
        TerribleError(L"Wrong Size for new partiton in CmdCreate\n");
    }

    if ( (Table->Entry[Slot].StartingLBA < Header->FirstUsableLBA) ||
         (Table->Entry[Slot].EndingLBA > Header->LastUsableLBA) )
    {
        TerribleError(L"New Partition out of bounds in CmdCreate\n");
    }

    Table->Entry[Slot].Attributes = Attributes;
    CopyMem(&(Table->Entry[Slot].PartitionName[0]), PartName, PART_NAME_LEN*sizeof(CHAR16));

    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_CREATE05);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}



//
// -----
//


BOOLEAN
CmdDelete(
    CHAR16  **Token
    )
/*
    CmdDelete - deletes a partition from the currently selected disk
*/
{
    EFI_HANDLE  DiskHandle;
    UINTN       DiskType = 0;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    INTN        Victim;
    CHAR16      Answer[COMMAND_LINE_MAX];
    GPT_ENTRY   Entry;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if (Token[1] == NULL) {
        PrintHelp(DeleteHelpText);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(DeleteHelpText);
        return FALSE;
    }

    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);
    if (EFI_ERROR(status)) {
        return FALSE;
    }


    if (DiskType == DISK_RAW) {
        Print(MSG_DELETE02);
        goto Exit;
    } else if (DiskType == DISK_MBR) {
        CmdInspectMBR(Token);
        goto Exit;
    } else if (DiskType == DISK_GPT_UPD) {
        Print(MSG_DELETE03);
        goto Exit;
    } else if (DiskType == DISK_GPT_BAD) {
        Print(MSG_DELETE04);
        goto Exit;
    } else if (DiskType != DISK_GPT) {
        TerribleError(L"Bad Disk Type returned to Delete!");
        goto Exit;
    }

    //
    // OK, it's a Good GPT disk, so do the Delete thing for GPT...
    //
    if ( (Token[1] == NULL) ||
         (Token[2] != NULL) )
    {
        PrintHelp(InspectHelpText);
        goto Exit;
    }

    Victim = Atoi(Token[1]);

    if ( (Victim < 0) ||
         ((UINT32)Victim > Header->EntriesAllocated) )
    {
        Print(MSG_DELETE05);
        goto Exit;
    }

    CopyMem(&Entry, &Table->Entry[Victim], sizeof(GPT_ENTRY));

    if (CompareMem(&(Entry.PartitionType), &GuidNull, sizeof(EFI_GUID)) == 0) {
        Print(MSG_DELETE06);
        goto Exit;
    }

    //
    // What you are going to delete, are you sure, are you really sure...
    //
    Print(MSG_DELETE07, Victim);
    PrintGptEntry(&Entry, Victim);
    Print(L"\n\n");
    Print(MSG_DELETE09);
    Print(MSG_DELETE10);
    Input(STR_DELETE_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    StrUpr(Answer);
    if (StrCmp(Answer, L"Y") != 0) {
        goto Exit;
    }
    Print(MSG_DELETE11);
    Input(STR_DELETE_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    StrUpr(Answer);
    if (StrCmp(Answer, STR_DELETE_ANS) != 0) {
        goto Exit;
    }

    //
    // If we get here, then...
    //      Victim is the number of legal GPT slot
    //      Victim refers to a slot which is allocated
    //      The user has seen confirmation of which slot that is
    //      The user says they realy truly want to delete it
    //
    CopyMem(&(Table->Entry[Victim].PartitionType), &GuidNull, sizeof(EFI_GUID));
    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_DELETE08);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


BOOLEAN
CmdHelp(
    CHAR16  **Token
    )
{
    UINTN   i;

    for (i = 0; CmdTable[i].Name != NULL; i++) {
        Print(L"%s %s\n", CmdTable[i].Name, CmdTable[i].HelpSummary);
    }
    return FALSE;
}


BOOLEAN
CmdExit(
    CHAR16  **Token
    )
{
    Print(L"%s\n", MSG_EXITING);
    return TRUE;
}


BOOLEAN
CmdSymbols(
    CHAR16  **Token
    )
/*
    CmdSymbols - print out the GUID symbols compiled into the program

    For predefined symbol (see ...) we print it's friendly name,
    it's text definition, and it's actual value.
*/
{
    UINTN       i;
    EFI_GUID    *Guid;
    BOOLEAN     Verbose = FALSE;

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_VER) ==  0) )
    {
        Verbose = TRUE;
    }

    for (i = 0; SymbolList[i].SymName != NULL; i++) {
        Guid = SymbolList[i].Value;
        Print(L"%s = %s\n", SymbolList[i].SymName, SymbolList[i].Comment);
        if (Verbose) {
            PrintGuidString(Guid);
            Print(L"\n\n");
        }
    }
    return FALSE;
}


BOOLEAN
CmdRemark(
    CHAR16  **Token
    )
{
    //
    // The remark command does nothing...
    return FALSE;
}


BOOLEAN
CmdMake(
    CHAR16  **Token
    )
{
    UINTN   i;

    Token++;

    if (Token[0] != NULL) {
        for (i = 0; ScriptTable[i].Name != NULL; i++) {
            if (StrCmp(ScriptTable[i].Name, Token[0]) == 0) {
                return ScriptTable[i].Function(Token);
            }
        }
    }
    //
    // Nothing we know about, so run list
    //
    return ScriptList(Token);
}


BOOLEAN
CmdDebug(
    CHAR16  **Token
    )
/*
    Debug -
        Without args, shows last status value, and AllocCount
        If an arg, it sets the debug/checkout support level
            0 = do nothing extra
            1 = print full computed arguments before starting an operation
            2 = print full computed arguments and hold for prompt before
                    doing a major operation.
*/
{
    if (Token[1]) {
        DebugLevel = Atoi(Token[1]);
    }
    Print(L"status = %x %r\n", status, status);
    Print(L"AllocCount = %d\n", AllocCount);
    Print(L"DebugLevel = %d\n", DebugLevel);
    return FALSE;
}


//
// ----- SubUnits to do MBR operations -----
//
VOID
CmdInspectMBR(
    CHAR16  **Token
    )
/*
    CmdInspectMBR - dumps the partition data for an MBR disk
*/
{
    Print(MSG_INSPECT05);
    return;
}

VOID
CmdCreateMBR(
    CHAR16  **Token
    )
/*
    CmdCreateMBR - creates an MBR parititon
*/
{
    Print(MSG_CREATE06);
    return;
}


VOID
CmdNewMBR(
    CHAR16  **Token
    )
/*
    CmdCreateMBR - creates an MBR parititon
*/
{
    Print(MSG_NEW04);
    return;
}


VOID
CmdDeleteMBR(
    CHAR16  **Token
    )
/*
    CmdDeleteMBR - deletes an MBR parititon
*/
{
    Print(MSG_DELETE01);
    return;
}


//
// ----- Various Support Routines -----
//


VOID
PrintGuidString(
    EFI_GUID    *Guid
    )
{
    CHAR16  Buffer[40];

    SPrint(Buffer, 40, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Guid->Data1,
        Guid->Data2,
        Guid->Data3,
        Guid->Data4[0],
        Guid->Data4[1],
        Guid->Data4[2],
        Guid->Data4[3],
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
        );
    Print(L"%s", Buffer);
    return;
}


EFI_STATUS
GetGuidFromString(
    CHAR16      *String,
    EFI_GUID    *Guid
    )
/*
    GetGuidFromString

    This routine scans the string looking for 32 hex digits.  Each
    such digits is shifted into the Guid.  Non hex digits are skipped.
    This means the guid MUST begin with the first digit, not with a filler
    0 or 0x or the like.  However, because non hex digits are skipped,
    any set of dashes, dots, etc. may be used as punctuation.

    So:
        01234567-abcd-ef01-12-34-56-78-9a-bc-de-f0
    &
        01.23.45.67-ab.cd.ef.01-12.34.56.78-9a.bc.de.f0

    Will create the same Guid value.
*/
{
    EFI_GUID    TempGuid;
    INTN    x;
    UINTN   i;
    UINTN   j;

    //
    // scan until we have the right number of hex digits for each part
    // of the guid structure, skipping over non hex digits
    //
    ZeroMem((CHAR16 *)&TempGuid, sizeof(EFI_GUID));

    //
    // 1st uint32
    //
    for (i = 0; i < 8; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data1 = (UINT32)((TempGuid.Data1 * 16) + x);
            i++;
        }
    }

    //
    // 2nd unit - uint16
    //
    for (i = 0; i < 4; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data2 = (TempGuid.Data2 * 16) + (UINT16)x;
            i++;
        }
    }

    //
    // 3nd unit - uint16
    //
    for (i = 0; i < 4; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data3 = (TempGuid.Data3 * 16) + (UINT16)x;
            i++;
        }
    }

    //
    // 4th unit - 8 uint8s
    //
    for (j = 0; j < 8; j++) {
        for (i = 0; i < 2; String++) {
            if (*String == NUL) {
                status = EFI_INVALID_PARAMETER;
                return status;
            }
            x = HexChar(*String);
            if (x != -1) {
                TempGuid.Data4[j] = (TempGuid.Data4[j] * 16) + (UINT8)x;
                i++;
            }
        }
    }

    CopyMem(Guid, &TempGuid, sizeof(EFI_GUID));
    return status = EFI_SUCCESS;
}


INTN
HexChar(
    CHAR16  Ch
    )
/*
    HexChar just finds the offset of Ch in the string "0123456789ABCDEF",
    which in effect converts a hex digit to a number.
    (a one char at a time xtoi)
    If Ch isn't a hex digit, -1 is returned.
*/
{
    UINTN   i;
    CHAR16  *String = L"0123456789ABCDEF";

    for (i = 0; String[i] != NUL; i++) {
        if (Ch == String[i]) {
            return i;
        }
    }
    return -1;
}


UINT64
Xtoi64(
    CHAR16  *String
    )
/*
    Xtoi64 is NOT fully xtoi compatible, it requires that the hex
    number start at the first character and stops at first non hex char
    Always returns a 64bit value
*/
{
    UINT64  BigHex;
    INT32   x;

    BigHex = 0;
    x = (INT32)HexChar(*String);
    while (x != -1) {
        BigHex = MultU64x32(BigHex, 16) + x;
        String++;
        x = (INT32)HexChar(*String);
    }
    return BigHex;
}


UINT64
Atoi64(
    CHAR16  *String
    )
/*
    Atoi64 is NOT fully atoi compatible, it requires that the number
    start at the first character and stops at first non number char
    Always returns a 64bit value
*/
{
    UINT64  BigNum;
    INT32   x;

    BigNum = 0;
    x = (INT32)HexChar(*String);
    while ( (x >= 0) && (x <= 9) ) {
        BigNum = MultU64x32(BigNum, 10);
        BigNum = BigNum + x;
        String++;
        x = (INT32)HexChar(*String);
    }
    return BigNum;
}


BOOLEAN
IsIn(
    CHAR16  What,
    CHAR16  *InWhat
    )
/*
    IsIn - return TRUE if What is found in InWhat, else FALSE;
*/
{
    UINTN   i;

    for (i = 0; InWhat[i] != NUL; i++) {
        if (InWhat[i] == What) {
            return TRUE;
        }
    }
    return FALSE;
}


VOID
PrintHelp(
    CHAR16  *HelpText[]
    )
{
    UINTN   i;

    for (i = 0; HelpText[i] != NULL; i++) {
        Print(HelpText[i]);
    }
    return;
}


VOID
TerribleError(
    CHAR16  *String
    )
{
    CHAR16  *Buffer;

    Buffer = AllocatePool(512);

    SPrint(Buffer, 512, L"Terrible Error = %s status=%x %r\nProgram terminated.\n", String, status, status);
    Print(Buffer);
    BS->Exit(SavedImageHandle, EFI_VOLUME_CORRUPTED, StrLen(Buffer), Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\cpuid\cpuid.c ===
#include <efi.h>
#include <efilib.h>


    // CPUID Registers 
#define    CV_IA64_CPUID0  3328
#define    CV_IA64_CPUID1  3329
#define    CV_IA64_CPUID2  3330
#define    CV_IA64_CPUID3  3331
#define    CV_IA64_CPUID4  3332



EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{
    UINT64  val64;
    UINT32  val32;
    UINT32  model;
    UINT32  revision;
    UINT32  family;

	InitializeLib( ImageHandle, SystemTable );

    Print( L"CPUID Program\n\n" );
	
    SystemTable->ConOut->ClearScreen( SystemTable->ConOut );
    
    val64 = __getReg( CV_IA64_CPUID3 );
    
    model = ( UINT32 )( ( val64 >> 16 ) & 0xFF );             // ProcessorModel
    Print( L"Processor Model    = %x\n", model );

    revision = ( UINT32 )( ( val64 >> 8 ) & 0xFF );           // ProcessorRevision
    Print( L"Processor Revision = %x\n", revision );
    
    family = ( UINT32 ) ( ( val64 >> 24 ) & 0xFF );           // ProcessorFamily
    Print( L"Processor Family   = %x\n", family );

    val32 = ( UINT32 ) ( ( val64 >> 32 ) & 0xFF );            // ProcessorArchRev
    Print( L"Processor ArchRev  = %x\n\n", val32 );

    switch ( model ) {

        case 0:     Print( L"Itanium    " );
                    break;

        case 1:     Print( L"McKinley   " );
                    break;

        default:    Print( L"IA64       " );
                    break;

    }

    switch ( revision ) {

        case 0:     Print( L"A stepping\n\n" );
                    break;

        case 1:     Print( L"B0 stepping\n\n" );
                    break;

        case 2:     Print( L"B1 stepping\n\n" );
                    break;

        case 3:     Print( L"B2 stepping \n\n" );
                    break;

        default:    Print( L"Unknown stepping\n\n" );
                    break;

    }

    // IA64 architected CPUID0 & CPUID1: Vendor Information.

    val64 = __getReg( CV_IA64_CPUID0 );
    Print( L"VendorString[0]         = %X\n", val64 );
    val64 = __getReg( CV_IA64_CPUID1 );
    Print( L"VendorString[1]         = %X\n", val64 );

    // IA64 architected CPUID2: Processor Serial Number.

    val64 = __getReg( CV_IA64_CPUID2 );
    Print( L"Processor Serial Number = %X\n", val64 );

    // IA64 architected CPUID4: General Features / Capability bits.

    val64 = __getReg( CV_IA64_CPUID4 );
    Print( L"Processor Feature Bits  = %X\n\n", val64 );

	return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\gpt.c ===
/*

    Gpt - Guid Partition Table routines

*/


#include "diskpart.h"

BOOLEAN Debug = TRUE;

EFI_STATUS  WriteShadowMBR(EFI_HANDLE   DiskHandle);

EFI_STATUS
ReadGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     *Header,
    PGPT_TABLE      *Table,
    PLBA_BLOCK      *LbaBlock,
    UINTN           *DiskType
    )
/*

    *Header, *Table, *LbaBlock will either be NULL or have a pointer.
    If they have pointers, caller is expected to free them with DoFree();

    RAW and MBR stuff is NOT DONE.

    DISK_RAW     - no known partition scheme on the disk
    DISK_MBR     - an MBR/Legacy disk
    DISK_GPT     - a GPT style disk
    DISK_GPT_UPD - a GPT disk with inconsistent partition tables
                   that need to be fixed up (may also need MBR rewrite)
    DISK_GPT_BAD - a GPT disk that is hopeless (or a hopeless disk
                   that we think is a GPT disk)
*/
{
#define MBR_STATE_RAW   0
#define MBR_STATE_MBR   1
#define MBR_STATE_GPT   2

    UINTN       MbrState = MBR_STATE_RAW;
    UINT32      BlockSize;
    UINT64      DiskSize;
    VOID        *p = NULL;
    PGPT_HEADER h1 = NULL;
    PGPT_HEADER h2 = NULL;
    PGPT_TABLE  t1 = NULL;
    PGPT_TABLE  t2 = NULL;
    PLBA_BLOCK  lba = NULL;
    UINT32      h1crc;
    UINT32      h2crc;
    UINT32      newcrc;
    UINT32      TableSize;
    UINT32      TableBlocks;
    BOOLEAN     PartialGPT = FALSE;
    MBR_ENTRY   *MbrTable;
    UINT16      *MbrSignature;


    BOOLEAN H1T1good = TRUE;
    BOOLEAN H2T2good = TRUE;


    BlockSize = GetBlockSize(DiskHandle);
    DiskSize = GetDiskSize(DiskHandle);

    //
    // Assure that DoFree will notice uninited returns...
    //
    *Header = NULL;
    *Table = NULL;
    *LbaBlock = NULL;

    *DiskType = DISK_ERROR;
    status = EFI_SUCCESS;

    p = DoAllocate(BlockSize);
    if (p == NULL) goto ErrorMem;

    //
    // Read the MBR, if we can't read that, assume
    // we're in deep trouble  (MBR is always block 0, 1 block long)
    //
    status = ReadBlock(DiskHandle, p, (UINT64)0, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    MbrTable = (MBR_ENTRY *)((CHAR8 *)p + MBR_TABLE_OFFSET);
    MbrSignature = (UINT16 *)((CHAR8 *)p + MBR_SIGNATURE_OFFSET);

    if (*MbrSignature == MBR_SIGNATURE) {        // 0xaa55
        //
        // There's an MBR signature, so assume NOT RAW
        //

        //
        // If we find a type 0xEE in the first slot, we'll assume
        // it's a GPT Shadow MBR.   Otherwise we think it's an old MBR.
        // But code below will account for GPT structures as well
        //
        if (MbrTable[0].PartitionType == PARTITION_TYPE_GPT_SHADOW) {   // 0xEE
            //
            // Well, that type should never occur anywhere else,
            // so assume it's a GPT Shadow regardless of how it's set
            //
            MbrState = MBR_STATE_GPT;
        } else {
            //
            // It's not RAW (there's a signature) and it's not
            // GPT Shadow MBR (no 0xEE for Table[0] type
            // So, assume it's an MBR and we're done
            //
            *DiskType = DISK_MBR;
            DoFree(p);
            p = NULL;
            return EFI_SUCCESS;
        }
    } else {
        *DiskType = DISK_RAW;       // if we don't find more...
    }


    //
    // ----- h1/t1 ------------------------------------------------
    //

    //
    // Read Header1. If cannot *read* it, punt.
    // First header is always at Block 1, 1 block long
    //
    h1 = p;
    p = NULL;
    status = ReadBlock(DiskHandle, h1, 1, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    //
    // h1 => header1
    //
    if ( (h1->Signature != GPT_HEADER_SIGNATURE) ||
         (h1->Revision != GPT_REVISION_1_0) ||
         (h1->HeaderSize != sizeof(GPT_HEADER)) ||
         (h1->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))  )
    {
        H1T1good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 1 is incorrect with status %x\n",
                  (h1->Signature != GPT_HEADER_SIGNATURE)*1 +
                  (h1->Revision != GPT_REVISION_1_0)*2 +
                  (h1->HeaderSize != sizeof(GPT_HEADER))*4 +
                  (h1->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))*8);
        }
    }

    h1crc = h1->HeaderCRC32;
    h1->HeaderCRC32 = 0;
    newcrc = GetCRC32(h1, sizeof(GPT_HEADER));
    h1->HeaderCRC32 = h1crc;

    if (h1crc != newcrc) {
        H1T1good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 1 crc is incorrect\n");
        }
    }

    if (H1T1good) {
        PartialGPT = TRUE;
    }

    //
    // if header1 is bad, assume that table1 is bad too...
    //
    if (H1T1good) {

        TableSize = sizeof(GPT_ENTRY) * h1->EntriesAllocated;


        t1 = DoAllocate(TableSize);
        if (t1 == NULL) goto ErrorMem;

        //
        // OK, so how many BLOCKS long is the table?
        //
        TableBlocks = TableSize / BlockSize;

        //
        // if we cannot READ t1, punt...
        //
        status = ReadBlock(DiskHandle, t1, h1->TableLBA, TableSize);
        if (EFI_ERROR(status)) goto ErrorRead;

        newcrc = GetCRC32(t1, TableSize);

        if (h1->TableCRC32 != newcrc) {
            H1T1good = FALSE;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT table 1 crc is incorrect\n");
            }
        }
    }


    //
    // ----- h2/t2 ------------------------------------------------
    //

    //
    // Read Header2. If cannot *read* it, punt.
    //
    h2 = DoAllocate(BlockSize);
    if (h2 == NULL) goto ErrorMem;

    //
    // Header2 is always 1 block long, last block on disk
    //
    status = ReadBlock(DiskHandle, h2, DiskSize-1, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    //
    // h2 => header2
    //
    if ( (h2->Signature != GPT_HEADER_SIGNATURE) ||
         (h2->Revision != GPT_REVISION_1_0) ||
         (h2->HeaderSize != sizeof(GPT_HEADER)) ||
         (h2->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))  )
    {
        H2T2good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 2 is incorrect with status %x\n",
                  (h2->Signature != GPT_HEADER_SIGNATURE)*1 +
                  (h2->Revision != GPT_REVISION_1_0)*2 +
                  (h2->HeaderSize != sizeof(GPT_HEADER))*4 +
                  (h2->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))*8);
        }
    }

    h2crc = h2->HeaderCRC32;
    h2->HeaderCRC32 = 0;
    newcrc = GetCRC32(h2, sizeof(GPT_HEADER));
    h2->HeaderCRC32 = h2crc;

    if (h2crc != newcrc) {
        H2T2good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 2 crc is incorrect\n");
        }
    }

    if (H2T2good) {
        PartialGPT = TRUE;
    }

    //
    // if header2 is bad, assume that table2 is bad too...
    //
    if (H2T2good) {

        TableSize = sizeof(GPT_ENTRY) * h2->EntriesAllocated;

        t2 = DoAllocate(TableSize);
        if (t2 == NULL) goto ErrorMem;

        //
        // OK, so how many BLOCKS long is the table?
        //
        TableBlocks = TableSize / BlockSize;

        //
        // if we cannot READ t2, punt...
        //
        status = ReadBlock(DiskHandle, t2,  h2->TableLBA, TableSize);
        if (EFI_ERROR(status)) goto ErrorRead;

        newcrc = GetCRC32(t2, TableSize);

        if (h2->TableCRC32 != newcrc) {
            H2T2good = FALSE;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT table 2 crc is incorrect\n");
            }
        }
    }

    //
    // ------ analysis  --------------------------------------------------
    //
    // since we are here:
    //  h1 -> header1, t1 -> table1, H1T1good indicates state
    //  h2 -> header2, t2 -> table2, H2T2good indicates state
    //

    lba = (PLBA_BLOCK)DoAllocate(sizeof(LBA_BLOCK));
    if (lba == NULL) goto ErrorMem;

    lba->Header1_LBA = 1;
    lba->Table1_LBA = h1->TableLBA;
    lba->Header2_LBA = (DiskSize - 1);
    lba->Table2_LBA = h2->TableLBA;

    if (H1T1good) {
        *Header = h1;
        *Table = t1;
        *LbaBlock = lba;

        if ( (H2T2good) &&
             (h1->AlternateLBA == (DiskSize-1)) &&
             (CompareMem(t1, t2, TableSize) == 0)
           )
        {
            *DiskType = DISK_GPT;
        } else {
            *DiskType = DISK_GPT_UPD;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT partition table 1 checked out but table 2 is inconsistent with table 1\n");
            }
        }
        DoFree(h2);
        h2 = NULL;
        DoFree(t2);
        t2 = NULL;
        status = EFI_SUCCESS;
        return status;
    }

    if (H2T2good) {
        // since we're here, H1T1good is FALSE...

        *Header = h2;
        *Table = t2;
        *LbaBlock = lba;
        DoFree(h1);
        h1 = NULL;
        DoFree(t1);
        t1 = NULL;

        *DiskType = DISK_GPT_UPD;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT partition table 2 checked out but table 1 is not good\n");
        }
        return EFI_SUCCESS;
    }

    //
    // Since we're HERE, H1T1good AND H2T2good are BOTH false.
    // Unless the shadow MBR says it's a GPT disk, claim it's raw.
    // If we did see a shadow, or GPT partial is set, say it's a bad GPT
    //
    if ( (PartialGPT) || (MbrState == MBR_STATE_GPT) ) {
        //
        // At least one of the headers looked OK,
        //          OR
        // There's an MBR that looks like a GPT shadow MBR
        //          SO
        // Report DISK_GPT_BAD
        //
        *DiskType = DISK_GPT_BAD;
        goto ExitRet;

    } else {
        //
        // It's not an MBR disk, or we wouldn't have gotten here
        //
        *DiskType = DISK_RAW;
        goto ExitRet;
    }

ErrorMem:
    status = EFI_OUT_OF_RESOURCES;
    goto ExitRet;

ErrorRead:
    status = EFI_DEVICE_ERROR;

ExitRet:
    DoFree(p);
    DoFree(h1);
    DoFree(t1);
    DoFree(h2);
    DoFree(t2);
    DoFree(lba);
    return status;
}


EFI_STATUS
WriteGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     Header,
    PGPT_TABLE      Table,
    PLBA_BLOCK      LbaBlock
    )
/*
    CALLER is expected to fill in:
            FirstUseableLBA
            LastUseableLBA
            EntryCount
            DiskGUID

    We fill in the rest, and blast it out.

    Returns a status.

*/
{
    UINT32      BlockSize;
    UINT32      TableSize;
    UINT32      TableBlocks;

    status = EFI_SUCCESS;

    BlockSize = GetBlockSize(DiskHandle);
    TableSize = Header->EntriesAllocated * sizeof(GPT_ENTRY);

    WriteShadowMBR(DiskHandle);
    //
    // Write out the primary header...
    //
    Header->Signature = GPT_HEADER_SIGNATURE;
    Header->Revision = GPT_REVISION_1_0;
    Header->HeaderSize = sizeof(GPT_HEADER);

    Header->MyLBA = LbaBlock->Header1_LBA;
    Header->AlternateLBA = LbaBlock->Header2_LBA;

    Header->TableLBA = LbaBlock->Table1_LBA;
    Header->SizeOfGPT_ENTRY = sizeof(GPT_ENTRY);

    Header->TableCRC32 = GetCRC32(Table, TableSize);

    Header->HeaderCRC32 = 0;
    Header->HeaderCRC32 = GetCRC32(Header, sizeof(GPT_HEADER));

    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"\nWriteGPT\n    DiskHandle = %8X\n", DiskHandle);
        Print(L"    Header=%X\n", Header);
        Print(L"    Signature=%lX\n    Revision=%X  HeaderSize=%X HeaderCRC=%X\n",
                Header->Signature, Header->Revision, Header->HeaderSize, Header->HeaderCRC32);
        Print(L"          MyLBA=%lX  AltLBA=%lX\n", Header->MyLBA, Header->AlternateLBA);
        Print(L"    FirstUsable=%lX    Last=%lX\n", Header->FirstUsableLBA,  Header->LastUsableLBA);
        Print(L"       TableLBA=%lX\n", Header->TableLBA);
    }

    status = WriteBlock(DiskHandle, Header, LbaBlock->Header1_LBA, BlockSize);

    if (EFI_ERROR(status)) return status;

    //
    // Write out the primary table ...
    //
    TableBlocks = TableSize / BlockSize;

    status = WriteBlock(DiskHandle, Table, LbaBlock->Table1_LBA, TableSize);

    if (EFI_ERROR(status)) return status;

    //
    // Write out the secondary header ...
    //
    Header->MyLBA = LbaBlock->Header2_LBA;
    Header->AlternateLBA = 0;
    Header->TableLBA = LbaBlock->Table2_LBA;
    Header->HeaderCRC32 = 0;
    Header->HeaderCRC32 = GetCRC32(Header, sizeof(GPT_HEADER));

    status = WriteBlock(DiskHandle, Header, LbaBlock->Header2_LBA, BlockSize);

    if (EFI_ERROR(status)) return status;

    //
    // write out the secondary table ..
    //
    TableBlocks = TableSize / BlockSize;

    status = WriteBlock(DiskHandle, Table, LbaBlock->Table2_LBA, TableSize);
    FlushBlock(DiskHandle);
    return status;
}


EFI_STATUS
WriteShadowMBR(
    EFI_HANDLE   DiskHandle
    )
/*
    WriteShadowMBR writes out a GPT shadow master boot record,
    which means an MBR full of zeros except:
    a. It has the 0xaa55 signature at 0x1fe
    b. It has a single partition entry of type 'EE'...
*/
{
    UINT32      BlockSize;
    UINT8       *MbrBlock;
    UINT64      DiskSize;
    MBR_ENTRY UNALIGNED *MbrEntry = NULL;
    UINT16    UNALIGNED *MbrSignature;

    BlockSize = GetBlockSize(DiskHandle);
    MbrBlock = DoAllocate(BlockSize);

    if (MbrBlock == NULL) {
        status = EFI_OUT_OF_RESOURCES;
        return status;
    }

    ZeroMem(MbrBlock, BlockSize);
    DiskSize = GetDiskSize(DiskHandle);
    if (DiskSize > 0xffffffff) {
        DiskSize = 0xffffffff;
    }

    MbrEntry = (MBR_ENTRY *)(MbrBlock + MBR_TABLE_OFFSET);
    MbrEntry->ActiveFlag = 0;
    MbrEntry->PartitionType = PARTITION_TYPE_GPT_SHADOW;
    MbrEntry->StartingSector = 1;
    MbrEntry->PartitionLength = (UINT32)DiskSize - MbrEntry->StartingSector;


    //
    // We don't actually know this data, so we'll make up
    // something that seems likely.
    //

    //
    // Old software is expecting the Partition to start on
    // a Track boundary, so we'll set track to 1 to avoid "overlay"
    // with the MBR
    //

    MbrEntry->StartingTrack = 1;
    MbrEntry->StartingCylinderLsb = 0;
    MbrEntry->StartingCylinderMsb = 0;
    MbrEntry->EndingTrack = 0xff;
    MbrEntry->EndingCylinderLsb = 0xff;
    MbrEntry->EndingCylinderMsb = 0xff;
    MbrSignature = (UINT16 *)(MbrBlock + MBR_SIGNATURE_OFFSET);
    *MbrSignature = BOOT_RECORD_SIGNATURE;

    status = WriteBlock(DiskHandle, MbrBlock, 0, BlockSize);

    DoFree(MbrBlock);
    return status;
}


EFI_STATUS
CreateGPT(
    EFI_HANDLE  DiskHandle,
    UINTN       EntryRequest
    )
/*
    Write a new GPT table onto a clean disk

    When we get here, we assume the disk is clean, and
    that the user really wants to do this.

    DiskHandle - the disk we are going to write to

    EntryRequest - number of entries the user wants, ignored
        if less than our minimum, rounded up to number of entries
        that fill up the nearest sector.  So, the user is
        says "at least" this many.

        Ignored if > 1024. (At least for now)

    NOTE:
        Even though the disk is in theory all zeros from
        having been cleaned, we actually rewrite all the data,
        just in case somebody fooled the detector code...

*/
{
    UINTN       EntryCount;
    UINTN       BlockFit;
    UINTN       BlockSize;
    UINTN       EntryBlocks;
    UINT64      DiskSize;
    LBA_BLOCK   LbaBlock;
    PGPT_HEADER Header;
    PGPT_TABLE  Table;
    UINTN       TableSize;
    EFI_LBA     Header1_LBA;
    EFI_LBA     Table1_LBA;
    EFI_LBA     Header2_LBA;
    EFI_LBA     Table2_LBA;
    EFI_LBA     FirstUsableLBA;
    EFI_LBA     LastUsableLBA;

    //
    // BlockSize is the block/sector size, in bytes.
    // It is assumed to be a power of 2 and >= 512
    //
    BlockSize = GetBlockSize(DiskHandle);

    //
    // DiskSize is a Count (1 based, not 0 based) of
    // software visible blocks on the disk.  We assume
    // we may address them as 0 to DiskSize-1.
    //
    DiskSize = GetDiskSize(DiskHandle);

    //
    // By default, we support the max of 32 entries or
    // BlockSize/sizeof(GPT_ENTRY).  (Meaning there will
    // always be at least 32 entries and always be at least
    // enough entries to fill 1 sector)
    // If the user asks for more than that, but less than
    // the sanity threshold, we give the user what they asked
    // for, rounded up to BlockSize/sizeof(GPT_ENTRY)
    //

    EntryCount = ENTRY_DEFAULT;
    BlockFit = BlockSize/sizeof(GPT_ENTRY);

    if (BlockFit > ENTRY_DEFAULT) {
        EntryCount = BlockFit;
    }

    if (EntryRequest > EntryCount) {
        if (EntryRequest <= ENTRY_SANITY_LIMIT) {   // 1024

            EntryCount = ((EntryRequest + BlockFit) / BlockFit) * BlockFit;

            if ((EntryCount < EntryRequest) ||
                (EntryCount < ENTRY_DEFAULT) ||
                (EntryCount < BlockFit))
            {
                TerribleError(L"CreateGPT is terribly confused\n");
            }
        }
    }

    EntryBlocks = EntryCount / BlockFit;

    if ((EntryBlocks * BlockFit) != EntryCount) {
        TerribleError(L"CreateGPT is terribly confused, spot #2\n");
    }

    Header1_LBA = 1;
    Table1_LBA = 2;
    FirstUsableLBA = Table1_LBA + EntryBlocks;

    Header2_LBA = DiskSize - 1;
    Table2_LBA = Header2_LBA - EntryBlocks;
    LastUsableLBA = Table2_LBA - 1;

    TableSize = EntryBlocks * BlockSize;

    if (TableSize != (EntryCount * sizeof(GPT_ENTRY))) {
        TerribleError(L"CreateGPT is terribly confused, spot #3\n");
    }

    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"DiskSize = %lx\n", DiskSize);
        Print(L"BlockSize = %x\n", BlockSize);
        Print(L"Header1_LBA = %lx\n", Header1_LBA);
        Print(L"Table1_LBA = %lx\n", Table1_LBA);
        Print(L"FirstUsableLBA = %lx\n", FirstUsableLBA);
        Print(L"Header2_LBA = %lx\n", Header2_LBA);
        Print(L"Table2_LBA = %lx\n", Table2_LBA);
        Print(L"LastUsableLBA = %lx\n", LastUsableLBA);
        Print(L"EntryCount = %x\n", EntryCount);
        Print(L"EntryBlocks = %x\n", EntryBlocks);
    }

    //
    // OK, from this point it's just filling in structures
    // and writing them out.
    //

    Header = (PGPT_HEADER)DoAllocate(BlockSize);
    if (Header == NULL) {
        return EFI_OUT_OF_RESOURCES;
    }
    ZeroMem(Header, BlockSize);

    //
    // Since we're making empty tables, we just write zeros...
    //

    Table = (PGPT_TABLE)DoAllocate(TableSize);
    if (Table == NULL) {
        DoFree(Header);
        Header = NULL;
        return EFI_OUT_OF_RESOURCES;
    }
    ZeroMem(Table, TableSize);

    //
    // Fill in the things that WriteGPT doesn't understand
    //
    Header->FirstUsableLBA = FirstUsableLBA;
    Header->LastUsableLBA = LastUsableLBA;
    Header->EntriesAllocated = (UINT32)EntryCount;
    Header->DiskGUID = GetGUID();

    LbaBlock.Header1_LBA = Header1_LBA;
    LbaBlock.Header2_LBA = Header2_LBA;
    LbaBlock.Table1_LBA = Table1_LBA;
    LbaBlock.Table2_LBA = Table2_LBA;

    status = WriteGPT(
                DiskHandle,
                Header,
                Table,
                &LbaBlock
                );

    DoFree(Header);
    DoFree(Table);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\doport.c ===
/*

    DoPort.c

    Contains large routines that are too complicated to "wrap", so
    here you have to rewrite the function for whatever the target is.

*/

#include "diskpart.h"

EFI_STATUS
FindPartitionableDevices(
    EFI_HANDLE  **ReturnBuffer,
    UINTN       *Count
    )
/*
    FindPartitionableDevices gets the list of handles that support
    the block I/O protocol.  It then traverses these handles, and
    filters out any that don't appear to be fixed mount, present, read/write,
    disks.

    ReturnBuffer - will be set to point to a buffer with a an array of
                    handles to partitionable disks.  NULL if failure or
                    no such disks found.  Caller may free from pool
an
    Count - number of entries in ReturnBuffer, 0 if none.

    Return is a status.an
*/
{
    EFI_HANDLE      *HandlePointer;
    UINTN           HandleCount;
    EFI_BLOCK_IO    *BlkIo;
    EFI_DEVICE_PATH *DevicePath;
    UINTN           PathSize;
    BOOLEAN         Partitionable;
    EFI_DEVICE_PATH *PathInstance;
    UINTN           SpindleCount;
    UINTN           i;

    *ReturnBuffer = NULL;
    *Count = 0;

    //
    // Try to find all of the hard disks by finding all
    // handles that support BlockIo protocol
    //
    status = LibLocateHandle(
        ByProtocol,
        &BlockIoProtocol,
        NULL,
        &HandleCount,
        &HandlePointer
        );

    if (EFI_ERROR(status)) {
        return status;
    }

    *ReturnBuffer = DoAllocate(sizeof(EFI_HANDLE)*HandleCount);

    if (*ReturnBuffer == NULL) {
        *Count = 0;
        return EFI_OUT_OF_RESOURCES;
    }

    SpindleCount = 0;
    for (i = 0; i < HandleCount; i++) {
        Partitionable = TRUE;
        status = BS->HandleProtocol(HandlePointer[i], &BlockIoProtocol, &BlkIo);
        if (BlkIo->Media->RemovableMedia) {
            //
            // It's removable, it's not for us
            //
            Partitionable = FALSE;
        }
        if ( ! BlkIo->Media->MediaPresent) {
            //
            // It's still not for us
            //
            Partitionable = FALSE;
        }

        if (BlkIo->Media->ReadOnly) {
            //
            // Cannot partition a read-only device!
            //
            Partitionable = FALSE;
        }

        //
        // OK, it seems to be a present, fixed, read/write, block device.
        // Now, make sure it's really the raw device by inspecting the
        // device path.
        //
        DevicePath = DevicePathFromHandle(HandlePointer[i]);
        while (DevicePath != NULL) {
            PathInstance = DevicePathInstance(&DevicePath, &PathSize);

            while (!IsDevicePathEnd(PathInstance)) {
                if ((DevicePathType(PathInstance) == MEDIA_DEVICE_PATH)) {
                    Partitionable = FALSE;
                }

                PathInstance = NextDevicePathNode(PathInstance);
            }
        }

        if (Partitionable) {
            //
            // Return this handle
            //
            (*ReturnBuffer)[*Count] = HandlePointer[i];
            (*Count)++;
        }
    }
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\guidgen.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    guidgen.c
    
Abstract:

    Add the GUID generator logic for the EFI 1.0 Disk Utilities.

Revision History

    ** Intel 2000 Update for EFI 1.0
    ** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
    ** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
    ** Digital Equipment Corporation, Maynard, Mass.
    ** To anyone who acknowledges that this file is provided AS IS
    ** without any express or implied warranty: permission to use, copy,
    ** modify, and distribute this file for any purpose is hereby
    ** granted without fee, provided that the above copyright notices and
    ** this notice appears in all source code copies, and that none of
    ** the names of Open Software Foundation, Inc., Hewlett-Packard
    ** Company, or Digital Equipment Corporation be used in advertising
    ** or publicity pertaining to distribution of the software without
    ** specific, written prior permission. Neither Open Software
    ** Foundation, Inc., Hewlett-Packard Company, nor Digital Equipment
    ** Corporation makes any representations about the suitability of
    ** this software for any purpose.
*/

#include "efi.h"
#include "efilib.h"
#include "md5.h"

//#define NONVOLATILE_CLOCK

extern  EFI_HANDLE  SavedImageHandle;
extern  EFI_HANDLE  *DiskHandleList;
extern  INTN        DiskHandleCount;

#define CLOCK_SEQ_LAST 0x3FFF
#define RAND_MASK CLOCK_SEQ_LAST

typedef struct _uuid_t {
    UINT32 time_low;
    UINT16 time_mid;
    UINT16 time_hi_and_version;
    UINT8 clock_seq_hi_and_reserved;
    UINT8 clock_seq_low;
    UINT8 node[6];
} uuid_t;

typedef struct {
    UINT32 lo;
    UINT32 hi;
} unsigned64_t;


/*
** Add two unsigned 64-bit long integers.
*/
#define ADD_64b_2_64b(A, B, sum) \
    { \
        if (!(((A)->lo & 0x80000000UL) ^ ((B)->lo & 0x80000000UL))) { \
            if (((A)->lo&0x80000000UL)) { \
                (sum)->lo = (A)->lo + (B)->lo; \
                (sum)->hi = (A)->hi + (B)->hi + 1; \
            } \
        else { \
                (sum)->lo = (A)->lo + (B)->lo; \
                (sum)->hi = (A)->hi + (B)->hi; \
        } \
    } \
    else { \
        (sum)->lo = (A)->lo + (B)->lo; \
        (sum)->hi = (A)->hi + (B)->hi; \
        if (!((sum)->lo&0x80000000UL)) (sum)->hi++; \
    } \
}

/*
** Add a 16-bit unsigned integer to a 64-bit unsigned integer.
*/
#define ADD_16b_2_64b(A, B, sum) \
    { \
        (sum)->hi = (B)->hi; \
        if ((B)->lo & 0x80000000UL) { \
            (sum)->lo = (*A) + (B)->lo; \
            if (!((sum)->lo & 0x80000000UL)) (sum)->hi++; \
        } \
        else \
            (sum)->lo = (*A) + (B)->lo; \
    }

/*
** Global variables.
*/
static unsigned64_t time_last;
static UINT16 clock_seq;

VOID
GetIeeeNodeIdentifier(
    UINT8 MacAddress[]
    ) 
// Use the Device Path for the NIC to provide a MAC address
{
    UINTN                       NoHandles, Index;
    EFI_HANDLE                  *Handles;
    EFI_HANDLE                  Handle;
    EFI_DEVICE_PATH             *DevPathNode, *DevicePath;
    MAC_ADDR_DEVICE_PATH        *SourceMacAddress; 
    UINT8                       *Anchor;
    EFI_MEMORY_DESCRIPTOR       *Desc, *MemMap;
    UINTN                       DescriptorSize;
    UINT32                      DescriptorVersion;
    UINTN                       NoDesc, MapKey;
    UINT8                       *pDataBuf;
    UINT32                      cData;
    EFI_TIME                    Time;    
    EFI_STATUS                  Status;

    Status = EFI_SUCCESS;

    //
    // Find all Device Paths
    //

    LibLocateHandle (ByProtocol, &DevicePathProtocol, NULL, &NoHandles, &Handles);

    for (Index=0; Index < NoHandles; Index++) {
        Handle = Handles[Index];   
        DevicePath = DevicePathFromHandle (Handle);

        //
        // Process each device path node
        //    
        DevPathNode = DevicePath;
        while (!IsDevicePathEnd(DevPathNode)) {
            //
            // Find the handler to dump this device path node
            //
            if (DevicePathType(DevPathNode) == MESSAGING_DEVICE_PATH &&
                DevicePathSubType(DevPathNode) == MSG_MAC_ADDR_DP) {
                SourceMacAddress = (MAC_ADDR_DEVICE_PATH *) DevPathNode;
                if (SourceMacAddress->IfType == 0x01 || SourceMacAddress->IfType == 0x00) {               
                    CopyMem(&MacAddress[0], &SourceMacAddress->MacAddress, sizeof(UINT8) * 6);
                    return;
                }
            }
            DevPathNode = NextDevicePathNode(DevPathNode);          
        }
    }

    //
    // Arriving here means that there is not an SNP-compliant
    // device in the system.  Use the MD5 1-way hash function to 
    // generate the node address
    //
    MemMap = LibMemoryMap (&NoDesc, &MapKey, &DescriptorSize, &DescriptorVersion);

    if (!MemMap) {
        Print (L"Memory map was not returned\n");
    } else {
        pDataBuf = AllocatePool (NoDesc * DescriptorSize + 
                    DiskHandleCount * sizeof(EFI_HANDLE) + sizeof(EFI_TIME));
        ASSERT (pDataBuf != NULL);
        Anchor = pDataBuf;
        Desc = MemMap;
        cData = 0;
        if (NoDesc != 0) {
            while (NoDesc --) {
                CopyMem(pDataBuf, Desc, DescriptorSize);
                Desc ++;
                pDataBuf += DescriptorSize;
                cData += (UINT32)DescriptorSize;
            }
        }
        //
        // Also copy in the handles of the Disks
        //
        if (DiskHandleCount != 0) {
            Index = DiskHandleCount;
            while (Index --) {
                CopyMem(pDataBuf, &DiskHandleList [Index], sizeof (EFI_HANDLE));
                pDataBuf += sizeof(EFI_HANDLE);
                cData    += sizeof(EFI_HANDLE);
            }
        }
        Status = RT->GetTime(&Time,NULL);
        if (!EFI_ERROR(Status)) {
            CopyMem(pDataBuf, &Time, sizeof(EFI_TIME));
            pDataBuf += sizeof(EFI_TIME);
            cData += sizeof (EFI_TIME);
        }

        GenNodeID(Anchor, cData, &MacAddress[0]);

        FreePool(Anchor);
        FreePool(MemMap);
        return;
    }
    // Just case fall through
    ZeroMem(MacAddress, 6 * sizeof (UINT8));
    return;
}


static VOID
mult32(UINT32 u, UINT32 v, unsigned64_t *result)
{
    /* Following the notation in Knuth, Vol. 2. */
    UINT32 uuid1, uuid2, v1, v2, temp;
    uuid1 = u >> 16;
    uuid2 = u & 0xFFFF;
    v1 = v >> 16;
    v2 = v & 0xFFFF;
    temp = uuid2 * v2;
    result->lo = temp & 0xFFFF;
    temp = uuid1 * v2 + (temp >> 16);
    result->hi = temp >> 16;
    temp = uuid2 * v1 + (temp & 0xFFFF);
    result->lo += (temp & 0xFFFF) << 16;
    result->hi += uuid1 * v1 + (temp >> 16);
}

static VOID
GetSystemTime(unsigned64_t *uuid_time)
{
//    struct timeval tp;
    EFI_TIME              Time;
    EFI_STATUS            Status;
    unsigned64_t utc, usecs, os_basetime_diff;
    EFI_TIME_CAPABILITIES TimeCapabilities;
    UINTN                 DeadCount;
    UINT8                 Second;

    DeadCount = 0;

//    gettimeofday(&tp, (struct timezone *)0);
    Status = RT->GetTime(&Time,&TimeCapabilities);

    Second = Time.Second;

    //
    // If the time resolution is 1Hz, then spin until a
    // second transition.  This will at least make the 
    // "0 nanoseconds" value appear correct inasmuch as 
    // multiple reads within 1 second are prohibited and
    // the exit on roll-over really implies that the 
    // nanoseconds field "would have" rolled to zero in 
    // a more robust time keeper.
    // 
    //
    if (TimeCapabilities.Resolution == 1) {
        while (Time.Second == Second) {
            Second = Time.Second;
            Status = RT->GetTime(&Time, NULL);
            if (DeadCount++ == 0x1000000) {
                break;
            }
        }
    }

    mult32(Time.Second,     10000000,  &utc);
    mult32(Time.Nanosecond, 10,        &usecs);
    ADD_64b_2_64b(&usecs, &utc, &utc);

    /* Offset between UUID formatted times and Unix formatted times.
    * UUID UTC base time is October 15, 1582.
    * Unix base time is January 1, 1970. */

    os_basetime_diff.lo = 0x13814000;
    os_basetime_diff.hi = 0x01B21DD2;
    ADD_64b_2_64b(&utc, &os_basetime_diff, uuid_time);
}
        
UINT32
getpid() {
  UINT64  FakePidValue;

  BS->GetNextMonotonicCount(&FakePidValue);
  //FakePidValue = 0; //(UINT32) ((UINT32)FakePidValue + (UINT32) SavedImageHandle);
  FakePidValue = (UINT32) ((UINT32)FakePidValue + (UINT32) (UINT64) SavedImageHandle);
  return ((UINT32)FakePidValue);
}

/*
** See The Multiple Prime Random Number Generator by Alexander
** Hass pp. 368-381, ACM Transactions on Mathematical Software,
** 12/87.
*/
static UINT32 rand_m;
static UINT32 rand_ia;
static UINT32 rand_ib;
static UINT32 rand_irand;

static VOID
TrueRandomInit(VOID)
{
    unsigned64_t t;
    EFI_TIME    Time;
    EFI_STATUS  Status;

    UINT16 seed;
    /* Generating our 'seed' value Start with the current time, but,
    * since the resolution of clocks is system hardware dependent
    and
    * most likely coarser than our resolution (10 usec) we 'mixup'
    the
    * bits by xor'ing all the bits together. This will have the
    effect
    * of involving all of the bits in the determination of the seed
    * value while remaining system independent. Then for good
    measure
    * to ensure a unique seed when there are multiple processes
    * creating UUIDs on a system, we add in the PID.
    */
    rand_m = 971;
    rand_ia = 11113;
    rand_ib = 104322;
    rand_irand = 4181;
//    GetSystemTime(&t);
    Status = RT->GetTime(&Time,NULL);

    t.lo = Time.Nanosecond;
    t.hi = (Time.Hour << 16) | Time.Second;

    seed = (UINT16) (t.lo & 0xFFFF);
    seed ^= (t.lo >> 16) & 0xFFFF;
    seed ^= t.hi & 0xFFFF;
    seed ^= (t.hi >> 16) & 0xFFFF;
    rand_irand += seed + getpid();      
}

static UINT16
true_random(VOID)
{
    if ((rand_m += 7) >= 9973)
        rand_m -= 9871;
    if ((rand_ia += 1907) >= 99991)
        rand_ia -= 89989;
    if ((rand_ib += 73939) >= 224729)
        rand_ib -= 96233;
    rand_irand = (rand_irand * rand_m) + rand_ia + rand_ib;
        return (UINT16) ((rand_irand >> 16) ^ (rand_irand & RAND_MASK));
}

/*
** Startup initialization routine for the UUID module.
*/
VOID
InitGuid(VOID)
{
    TrueRandomInit();
    GetSystemTime(&time_last);
    #ifdef NONVOLATILE_CLOCK
    clock_seq = read_clock();
    #else
    clock_seq = true_random();
    #endif
}

static INTN
time_cmp(unsigned64_t *time1, unsigned64_t *time2)
{
    if (time1->hi < time2->hi) return -1;
    if (time1->hi > time2->hi) return 1;
    if (time1->lo < time2->lo) return -1;
    if (time1->lo > time2->lo) return 1;
    return 0;
}

static VOID new_clock_seq(VOID)
{
    clock_seq = (clock_seq + 1) % (CLOCK_SEQ_LAST + 1);
    if (clock_seq == 0) clock_seq = 1;
    #ifdef NONVOLATILE_CLOCK
    write_clock(clock_seq);
    #endif
}

VOID CreateGuid(uuid_t *guid)
{
    static unsigned64_t time_now;
    static UINT16 time_adjust;
    UINT8 eaddr[6];
    INTN got_no_time = 0;

    GetIeeeNodeIdentifier(&eaddr[0]); /* TO BE PROVIDED by EFI device path */

    do {
        GetSystemTime(&time_now);
        switch (time_cmp(&time_now, &time_last)) {
            case -1:
                /* Time went backwards. */
                new_clock_seq();
                time_adjust = 0;
            break;
            case 1:
                time_adjust = 0;
            break;
            default:
                if (time_adjust == 0x7FFF)
                /* We're going too fast for our clock; spin. */
                    got_no_time = 1;
                else
                    time_adjust++;
            break;
        }
    } while (got_no_time);

    time_last.lo = time_now.lo;
    time_last.hi = time_now.hi;
    if (time_adjust != 0) {
        ADD_16b_2_64b(&time_adjust, &time_now, &time_now);
    }
    /* Construct a guid with the information we've gathered
    * plus a few constants. */
    guid->time_low = time_now.lo;
    guid->time_mid = (UINT16) (time_now.hi & 0x0000FFFF);
    guid->time_hi_and_version = (UINT16)  (time_now.hi & 0x0FFF0000) >> 16;
    guid->time_hi_and_version |= (1 << 12);
    guid->clock_seq_low = clock_seq & 0xFF;
    guid->clock_seq_hi_and_reserved = (clock_seq & 0x3F00) >> 8;
    guid->clock_seq_hi_and_reserved |= 0x80;
    CopyMem (guid->node, &eaddr, sizeof guid->node);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\diskpart.h ===
//
// diskpart.h
//

//
// Alignmnet macros
//

#if defined (i386)
#   define UNALIGNED
#elif defined (_IA64_)
#   define UNALIGNED __unaligned
#elif defined (ALPHA)
#   define UNALIGNED __unaligned
#endif


//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#include "efi.h"
#include "efilib.h"
#include "msg.h"
#include "scriptmsg.h"
#include "gpt.h"
#include "mbr.h"

//
// Debug Control
//
#define DEBUG_NONE      0
#define DEBUG_ERRPRINT  1
#define DEBUG_ARGPRINT  2
#define DEBUG_OPPROMPT  3

extern  UINTN   DebugLevel;


//
//  Externs
//
extern  EFI_GUID    BlockIOProtocol;

extern  EFI_STATUS  status;             // always save the last error status
                                        // by using this global

extern  INTN    AllocCount;             // track DoFree/DoAlloc

extern  EFI_HANDLE  *DiskHandleList;
extern  INTN        SelectedDisk;

BOOLEAN ScriptList(CHAR16 **Token);

//
// Prototypes for all fo the workers for main parser in DiskPart
// Declared here so that scripts can call them
//
BOOLEAN CmdAbout(CHAR16 **Token);
BOOLEAN CmdList(CHAR16 **Token);
BOOLEAN CmdSelect(CHAR16 **Token);
BOOLEAN CmdInspect(CHAR16 **Token);
BOOLEAN CmdClean(CHAR16 **Token);
BOOLEAN CmdNew(CHAR16 **Token);
BOOLEAN CmdFix(CHAR16 **Token);
BOOLEAN CmdCreate(CHAR16 **Token);
BOOLEAN CmdDelete(CHAR16 **Token);
BOOLEAN CmdHelp(CHAR16 **Token);
BOOLEAN CmdExit(CHAR16 **Token);
BOOLEAN CmdSymbols(CHAR16 **Token);
BOOLEAN CmdRemark(CHAR16 **Token);
BOOLEAN CmdMake(CHAR16 **Token);
BOOLEAN CmdDebug(CHAR16 **Token);

//
// Worker function type
//
typedef
BOOLEAN
(*PSCRIPT_FUNCTION)(
    CHAR16  **Token
    );

//
// The script table structure
//
typedef struct {
    CHAR16              *Name;
    PSCRIPT_FUNCTION    Function;
    CHAR16              *HelpSummary;
} SCRIPT_ENTRY;

extern  SCRIPT_ENTRY    ScriptTable[];


//
//  Routines that will need to be ported
//
EFI_STATUS
FindPartitionableDevices(
    EFI_HANDLE  **ReturnBuffer,
    UINTN       *Count
    );


//
// Utility/Wrapper routines
//

UINT32      GetBlockSize(EFI_HANDLE  Handle);
UINT64      GetDiskSize(EFI_HANDLE  Handle);
VOID        DoFree(VOID *Buffer);
VOID        *DoAllocate(UINTN Size);
UINT32      GetCRC32(VOID *Buffer, UINT32 Length);
EFI_GUID    GetGUID();

EFI_STATUS
WriteBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      BlockCount
    );


EFI_STATUS
ReadBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    );

EFI_STATUS
FlushBlock(
    EFI_HANDLE  DiskHandle
    );


VOID
TerribleError(
    CHAR16  *String
    );

//
// Misc useful stuff
//
VOID        PrintHelp(CHAR16 *HelpText[]);
EFI_STATUS  GetGuidFromString(CHAR16 *String, EFI_GUID *Guid);
INTN        HexChar(CHAR16 Ch);
UINT64      Xtoi64(CHAR16 *String);
UINT64      Atoi64(CHAR16  *String);
VOID        PrintGuidString(EFI_GUID *Guid);
BOOLEAN     IsIn(CHAR16  What, CHAR16  *InWhat);
VOID        Tokenize(CHAR16  *CommandLine, CHAR16  **Token);
#define COMMAND_LINE_MAX    512
#define TOKEN_COUNT_MAX     256         // most possible in 512 chars


#define NUL     ((CHAR16)0)

//
// Some EFI functions are just a rename of 'C' lib functions,
// so they can just be macroed back.
// Somebody will need to check this out...
//
#if 0
#define CompareMem(a, b, c) memcmp(a, b, c)
#define ZeroMem(a, b)       memset(a, 0, b)

//
// This is a fiction, Print is NOT printf, but it's close
// enough that everything or almost everything will work...
//
#define Print   printf

#endif

//
// Functions that allow the Guid Generator to be used
//

VOID InitGuid(VOID); 
VOID CreateGuid(EFI_GUID *guid);


//
// Status Symbols
//
#define DISK_ERROR      0
#define DISK_RAW        1
#define DISK_MBR        2
#define DISK_GPT        4
#define DISK_GPT_UPD    6
#define DISK_GPT_BAD    7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\doutil.c ===
/*

    DoUtil.c

    Contains "wrappers" for various work routines, which do TWO things:

    A.  Make the semantics friendly the calling program.
    B.  Make it easy to move from Win2k to some emulator to a real EFI box.

*/

#include "diskpart.h"


INTN    AllocCount = 0;

UINT32
GetBlockSize(
    EFI_HANDLE  Handle
    )
/*
    Return the size, in bytes, of a block.  Handle is presumed to
    point to a device supporting Block IO protocol.

    return's 0 if some error.
*/
{
    EFI_BLOCK_IO    *BlkIo;

    status = BS->HandleProtocol(Handle, &BlockIoProtocol, &BlkIo);
    if (EFI_ERROR(status)) {
        return 0;
    }
    return (BlkIo->Media->BlockSize);
}

UINT64
GetDiskSize(
    EFI_HANDLE  Handle
    )
/*
    Return the size, in blocks, of a spindle.  Note that if we return X,
    this means there are blocks with LBAs = 0...(X-1)

    return 0 if some error
*/
{
    EFI_BLOCK_IO    *BlkIo;

    status = BS->HandleProtocol(Handle, &BlockIoProtocol, &BlkIo);
    if (EFI_ERROR(status)) {
        return 0;
    }
    return (BlkIo->Media->LastBlock+1);
}


VOID
DoFree(
    VOID    *Buffer
    )
/*
    If and only if Buffer != NULL, free it.
    If Buffer == NULL, do nothing and return
*/
{
    if (Buffer) {
        FreePool(Buffer);
        AllocCount--;
    }
    return;
}

VOID *
DoAllocate(
    UINTN   Size
    )
/*
    Just allocate at least Size bytes from some heap,
    return pointer.  return NULL if failure
*/
{
    VOID    *v;

    v = AllocatePool(Size);
    if (v) {
        AllocCount++;
    }
    return v;
}


//
// One source quotes this table as being from Dr Dobbs 1992.
// Others say other things
//

UINT32 CRCHelpTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };

UINT32
GetCRC32(
    UINT8   *Buffer,
    UINT32  Length
    )
/*
    Compute a CRC for the Buffer data for Length bytes.
    Remember to zero out any CRC fields included in the Buffer
    and to restore them afterwards.
*/
{
    UINT32      Crc,i;
    Crc = 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = CRCHelpTable [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}

EFI_GUID
GetGUID()
/*
    Return a GUID.
*/
{
    EFI_GUID    Guid;
    CHAR16      Buffer[10];
   
    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    InitGuid();
    CreateGuid(&Guid);

    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    return (Guid);

//    return NullGuid;        // WORK WORK!!!
}

EFI_STATUS
WriteBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    )
/*
    WriteBlock - wrapper routine

    Write Size bytes from Buffer to DiskHandle at Block BlockAddress
*/
{
    EFI_BLOCK_IO   *BlkIo  = NULL;
    EFI_DISK_IO    *DiskIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    BS->HandleProtocol(DiskHandle, &DiskIoProtocol,  &DiskIo);

    status = DiskIo->WriteDisk(
                DiskIo,
                BlkIo->Media->MediaId,
                MultU64x32 (BlockAddress, BlkIo->Media->BlockSize),
                Size,
                Buffer
                );

    return status;
}

EFI_STATUS
ReadBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    )
/*
    ReadBlock - wrapper routine.

    Caller is presumed to know the BlockSize and number of blocks
    on the device.

    Read Size bytes from BlockAddress of DiskHandle into buffer.
    Buffer had better be big enough.
*/
{
    EFI_DISK_IO     *DiskIo = NULL;
    EFI_BLOCK_IO    *BlkIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    BS->HandleProtocol(DiskHandle, &DiskIoProtocol,  &DiskIo);

    status = DiskIo->ReadDisk(
                DiskIo,
                BlkIo->Media->MediaId,
                MultU64x32 (BlockAddress, BlkIo->Media->BlockSize),
                Size,
                Buffer
                );

    return status;
}

EFI_STATUS
FlushBlock(
    EFI_HANDLE  DiskHandle
    )
/*
    FlushBlock - force anything we've written to make it onto the platter
*/
{
    EFI_BLOCK_IO    *BlkIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    return BlkIo->FlushBlocks(BlkIo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\diskpart.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
         $(O)\diskpart.lib \
         $(O)\diskpart.res


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\diskpart.efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\gpt.h ===
//
// GPT (GUID Partition Table) declarations.
//


//
// DO WE EVER ALLOW GPT_TABLEs TO NOT BE PACKED UP AGAINST THEIR HEADER?
// IF NOT, DO WE ALLOW PEOPLE TO MAKE ASSUMPTIONS ABOUT THEIR LOCATION?
// DO WE NEED THE POINTER?
//

//
// Rules:
//      None of these structures ever appear at LBA 0, because
//      we put a "fake" MBR there (the legacy defense MBR).
//      Therefore, LBA of 0 is useable as NULL.
//
//      For All Entry's, StartingLBA must be >= FirstUsableLBA.
//      For All Entry's, EndingLBA must be <= LastUsableLBA.
//
//      0 is not a valid GUID.  Therefore, emtpy GPT_ENTRY's will
//      have a PartitionType of 0.
//      However, if an entry is otherwise valid, but has a PartitionID
//      of 0, this means a GUID needs to be generated and placed there.
//
//      LBA = Logical Block Address == Sector Number.  Always count from 0.
//
//      Block size (sector size) could be any number >= sizeof(GPT_ENTRY)
//      AND >= sizeof(GPT_HEADER).  In practice, always >= 512 bytes.
//
//      A block, B, is free for allocation to a partition if and only if
//      it is in the range FirstUsableLBA <= B <= LastUsableLBA AND it
//      is not already allocated to some other parition.
//
//      GPT partitions are always contiguous arrays of blocks.  however,
//      they need NOT be packed on the disk, their order in the GPT need
//      NOT match their order on the disk, there may be blank entries
//      in the GPT table, etc.  Building an accurate view of the parititon
//      *requires* reading the entire GPT_TABLE into memory.  In practice,
//      it will always be small enough for this to be easy.
//

#pragma pack (4)

//
// Each partition is described by a GPT_ENTRY.
//
#define PART_NAME_LEN       36

typedef struct {
    EFI_GUID    PartitionType;  // declartion of this partition's type
    EFI_GUID    PartitionID;    // Unique ID for this particular partition
                                // (unique to this instance)
    EFI_LBA     StartingLBA;    // 0 based block (sector) address of the
                                // first block included in the partition.
    EFI_LBA     EndingLBA;      // 0 based block (sector) address of the
                                // last block included in the partition.
                                // If StartingLBA == EndingLBA then the
                                // partition is 1 block long.  this is legal.
    UINT64      Attributes;     // Always ZERO for now
    CHAR16      PartitionName[PART_NAME_LEN];  // 36 unicode characters of name
} GPT_ENTRY, *PGPT_ENTRY;

C_ASSERT (sizeof (GPT_ENTRY) == 128);
//
// All of the GPT_ENTRY's are gathered into a GPT_TABLE, which
// is stored as a linear array of blocks on the disk.
//
typedef struct {
    GPT_ENTRY   Entry[1];       // Always an integer number of Entry's
                                // per sector.  Always at least 1 sector.
                                // Can be any number of sectors...
} GPT_TABLE, *PGPT_TABLE;

//
// A main and a backup header each describe the disk, and each points
// to it's own copy of the GPT_TABLE...
//
typedef struct {
    UINT64      Signature;      // GPT PART
    UINT32      Revision;
    UINT32      HeaderSize;
    UINT32      HeaderCRC32;    // computed using 0 for own init value
    UINT32      Reserved0;
    EFI_LBA     MyLBA;          // 0 based sector number of the first
                                // sector of this structure
    EFI_LBA     AlternateLBA;   // 0 based sector (block) number of the
                                // first sector of the secondary
                                // GPT_HEADER, or 0 if this is the
                                // secondary.
    EFI_LBA     FirstUsableLBA; // 0 based sector number of the first
                                // sector that may be included in a partition.
    EFI_LBA     LastUsableLBA;  // last legal LBA, inclusive.
    EFI_GUID    DiskGUID;       // The unique ID of this LUN/spindle/disk
    EFI_LBA     TableLBA;       // The start of the table of entries...
    UINT32      EntriesAllocated; // Number of entries in the table, this is
                                  // how many allocated, NOT how many used.
    UINT32      SizeOfGPT_ENTRY;    // sizeof(GPT_ENTRY) always mult. of 8
    UINT32      TableCRC32;      // CRC32 of the table.
    // Reserved and zeros to the end of the block
    // Don't declare an array or sizeof() gives a nonsense answer..
} GPT_HEADER, *PGPT_HEADER;

C_ASSERT (sizeof (GPT_HEADER) == 92);

#define GPT_HEADER_SIGNATURE    0x5452415020494645
#define GPT_REVISION_1_0        0x00010000

#define ENTRY_DEFAULT       128
//#define ENTRY_DEFAULT       8           // TESTING ONLY
#define ENTRY_SANITY_LIMIT  1024


//
// GPT Disk Layout
//
/*

        +---------------------------------------------------+
LBA=0   | "Fake" MBR to ward off legacy parition apps       |
        +---------------------------------------------------+
LBA=1   | Primary GPT_HEADER                                |
        +---------------------------------------------------+
LBA=2   | Primary GPT_TABLE starts                          |
        ...             ...                                 ...
LBA=n   | Primary GPT_TABLE ends                            |
        +---------------------------------------------------+
LBA=n+1 | FirstUsableLBA = this block                       |
        ...             ...                                 ...
LBA=x   | LastUsableLBA = this block                        |
        +---------------------------------------------------+
LBA=x+1 | Secondary GPT_TABLE starts                        |
        ...             ...                                 ...
LBA=z   | Secondary GPT_TABLE ends                          |
        +---------------------------------------------------+
LBA=z+n | Secondary GPT_HEADER starts                       |
        ...             ...                                 ...
LAST    | Secondary GPT_HEADER ends at last sector of disk  |
        +---------------------------------------------------+

SO:
    Primary GPT_HEADER is always at LBA=1
    Secondary GPT_HEADER is at LBA=Last so long as GPT_HEADER fits
    in 1 sector, which we require.

    Primary Table is stacked up after the primary header,
    which points to it anyway.

    Secondary Table is stacked up before the secondary header,
    which points to it anyway.

*/


//
// ------------------ Functions To Manipulate GPT ---------------
//
typedef struct _LBA_BLOCK {
    EFI_LBA     Header1_LBA;
    EFI_LBA     Table1_LBA;
    EFI_LBA     Header2_LBA;
    EFI_LBA     Table2_LBA;
} LBA_BLOCK, *PLBA_BLOCK;


EFI_STATUS
ReadGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     *Header,
    PGPT_TABLE      *Table,
    PLBA_BLOCK      *LbaBlock,
    UINTN           *DiskType
    );

EFI_STATUS
WriteGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     Header,
    PGPT_TABLE      Table,
    PLBA_BLOCK      LbaBlock
    );

EFI_STATUS
CreateGPT(
    EFI_HANDLE  DiskHandle,
    UINTN       EntryRequest
    );

#pragma pack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\helpmsg.h ===
/*
    Help msg text slammed into variables (which is why it's not in msg.h)
    Localize
*/

CHAR16  *FixHelpText[] = {
        L"fix help - prints this screen\n",
        L"fix takes no arguments.  It attempts to read and rewrite\n",
        L"the GPT tables of a disk.  This simple procedure will\n",
        L"automatically fix some problems.\n",
        L"Fix does not work on MBR disks, or on heavily damaged GPT disks\n",
        NULL
        };

CHAR16  *CreateHelpText[] = {
        L"create [help] or \n",
        L"create name=namestr (type=typename | typeguid=guid) [offset=ooo] [size=sss]\n",
        L"       [attr=aaaa] [ver]\n",
        L"name=namestr is required, namestr may be quoted 'name=\"p01\"'\n",
        L"     one of type=typename or typeguid=guid is required\n",
        L"type=typename -> typename is one of the types listed by the symbols command\n",
        L"typeguid=guid -> guid is of form XXXYYYZZZ\n",
        L"offset=ooo is optional.  ooo is hexadecimal block offset.  if ooo is absent,\n"
        L"       parititon will start at the end of the last partition.\n",
        L"size=sss is optional.  sss is decimal megabytes.  if sss is 0\n"
        L"     or sss is greater than free space or option is absent, parititon\n",
        L"     will fill end of disk.\n",
        L"attr=aaa is optional. aaa is a HEX string of attribute flags.\n",
        L"ver optional command to turn on verbose status.\n",
        L"examples:\n",
        L"  create name=\"a partition\" type=msbasic size=0 attr=1B\n",
        L"  create name=part2 type=efisys size=400\n",
        NULL
        };


CHAR16  *InspectHelpText[] = {
        L"inspect [help] or \n"
        L"inspect [raw] [ver] \n"
        L"raw - print all partition slots, allocated or free, in table order\n",
        L"   by default only print allocated slots, sorted by address on disk\n",
        L"ver - print the the GPT hsd eader\n",
        L"examples:\n",
        L"   inspect\n",
        L"   inspect raw\n",
        L"   inspect raw ver\n",
        L"\n",
        L"For either raw or cooked output, the entry will be tagged with a\n",
        L"SLOT number, which is the number used by Delete\n",
        NULL
        };


CHAR16  *DeleteHelpText[] = {
        L"delete [help]\n",
        L"delete nnn deletes partition nnn from the currently selected disk\n"
        L"nnn is a decimal number that matches output of Inspect\n"
        L"example:\n",
        L"   delete 3\n",
        NULL
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\md5.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    md5.c
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History
*/



/*
 **********************************************************************
 ** md5.c                                                            **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                  **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */
#include "efi.h"
#include "efilib.h"
#include "md5.h"

/* forward declaration */
static void Transform ();

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions: selection, majority, parity */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z))) 

/* ROTATE_LEFT rotates x left n bits */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (
  MD5_CTX *mdContext
  )
{
  mdContext->i[0] = mdContext->i[1] = (UINT32)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT32)0x67452301;
  mdContext->buf[1] = (UINT32)0xefcdab89;
  mdContext->buf[2] = (UINT32)0x98badcfe;
  mdContext->buf[3] = (UINT32)0x10325476;
}

void MD5Update (
  MD5_CTX *mdContext,
  unsigned char *inBuf,
  unsigned int inLen
  )
{
  UINT32 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT32)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT32)inLen << 3);
  mdContext->i[1] += ((UINT32)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT32)mdContext->in[ii+3]) << 24) |
                (((UINT32)mdContext->in[ii+2]) << 16) |
                (((UINT32)mdContext->in[ii+1]) << 8) |
                ((UINT32)mdContext->in[ii]);
      Transform (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (
  MD5_CTX *mdContext
  )
{
  UINT32 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT32)mdContext->in[ii+3]) << 24) |
            (((UINT32)mdContext->in[ii+2]) << 16) |
            (((UINT32)mdContext->in[ii+1]) << 8) |
            ((UINT32)mdContext->in[ii]);
  Transform (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
  }
}

/* Basic MD5 step. Transform buf based on in.
 */
static void Transform (
    UINT32 *buf,
    UINT32 *in
    )
{
  UINT32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
  FF ( a, b, c, d, in[ 0], S11, 3614090360); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 3905402710); /* 2 */
  FF ( c, d, a, b, in[ 2], S13,  606105819); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 3250441966); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 4118548399); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 1200080426); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 2821735955); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 4249261313); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 1770035416); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 2336552879); /* 10 */
  FF ( c, d, a, b, in[10], S13, 4294925233); /* 11 */
  FF ( b, c, d, a, in[11], S14, 2304563134); /* 12 */
  FF ( a, b, c, d, in[12], S11, 1804603682); /* 13 */
  FF ( d, a, b, c, in[13], S12, 4254626195); /* 14 */
  FF ( c, d, a, b, in[14], S13, 2792965006); /* 15 */
  FF ( b, c, d, a, in[15], S14, 1236535329); /* 16 */

  /* Round 2 */
#define S21 5
#define S22 9
#define S23 14
#define S24 20
  GG ( a, b, c, d, in[ 1], S21, 4129170786); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 3225465664); /* 18 */
  GG ( c, d, a, b, in[11], S23,  643717713); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 3921069994); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 3593408605); /* 21 */
  GG ( d, a, b, c, in[10], S22,   38016083); /* 22 */
  GG ( c, d, a, b, in[15], S23, 3634488961); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 3889429448); /* 24 */
  GG ( a, b, c, d, in[ 9], S21,  568446438); /* 25 */
  GG ( d, a, b, c, in[14], S22, 3275163606); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 4107603335); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 1163531501); /* 28 */
  GG ( a, b, c, d, in[13], S21, 2850285829); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 4243563512); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 1735328473); /* 31 */
  GG ( b, c, d, a, in[12], S24, 2368359562); /* 32 */

  /* Round 3 */
#define S31 4
#define S32 11
#define S33 16
#define S34 23
  HH ( a, b, c, d, in[ 5], S31, 4294588738); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 2272392833); /* 34 */
  HH ( c, d, a, b, in[11], S33, 1839030562); /* 35 */
  HH ( b, c, d, a, in[14], S34, 4259657740); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 2763975236); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 1272893353); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 4139469664); /* 39 */
  HH ( b, c, d, a, in[10], S34, 3200236656); /* 40 */
  HH ( a, b, c, d, in[13], S31,  681279174); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 3936430074); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 3572445317); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,   76029189); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 3654602809); /* 45 */
  HH ( d, a, b, c, in[12], S32, 3873151461); /* 46 */
  HH ( c, d, a, b, in[15], S33,  530742520); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 3299628645); /* 48 */

  /* Round 4 */
#define S41 6
#define S42 10
#define S43 15
#define S44 21
  II ( a, b, c, d, in[ 0], S41, 4096336452); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 1126891415); /* 50 */
  II ( c, d, a, b, in[14], S43, 2878612391); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 4237533241); /* 52 */
  II ( a, b, c, d, in[12], S41, 1700485571); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 2399980690); /* 54 */
  II ( c, d, a, b, in[10], S43, 4293915773); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 2240044497); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 1873313359); /* 57 */
  II ( d, a, b, c, in[15], S42, 4264355552); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 2734768916); /* 59 */
  II ( b, c, d, a, in[13], S44, 1309151649); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 4149444226); /* 61 */
  II ( d, a, b, c, in[11], S42, 3174756917); /* 62 */
  II ( c, d, a, b, in[ 2], S43,  718787259); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 3951481745); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\msg.h ===
//
//  msg.h - messages, token, etc. are gathered here to make localization easier
//
//  STR_ are things that maybe don't get localized (command tokens)
//  MSG_ are output messages that probably do get localized
//

#define STR_LIST        L"LIST"
#define STR_SELECT      L"SELECT"
#define STR_INSPECT     L"INSPECT"
#define STR_CLEAN       L"CLEAN"
#define STR_CLEAN_PROMPT    L"CLEAN>> "
#define STR_NEW         L"NEW"
#define STR_FIX         L"FIX"
#define STR_CREATE      L"CREATE"
#define STR_DELETE      L"DELETE"
#define STR_DELETE_PROMPT   L"DELETE>> "
#define STR_HELP        L"HELP"
#define STR_HELP2       L"H"
#define STR_HELP3       L"?"
#define STR_EXIT        L"EXIT"
#define STR_SYMBOLS     L"SYMBOLS"
#define STR_REMARK      L"REM"
#define STR_MAKE        L"MAKE"
#define STR_DEBUG       L"DEBUG"
#define STR_VER         L"VER"
#define STR_RAW         L"RAW"
#define STR_ABOUT       L"ABOUT"

#define MSG_LIST        L"           - Show list of partitionable disks"
#define MSG_SELECT      L"<number> - Select a disk (spindle) to work on"
#define MSG_INSPECT     L"        - Dump the partition data on the selected spindle"
#define MSG_CLEAN       L"[ALL]     - Clean all data off the disk (DESTROY DATA)\n" \
                        L"                  ALL writes 0s to whole disk, without just 1st & last MB"
#define MSG_NEW         L"[MBR | GPT]"
#define MSG_FIX         L" "
#define MSG_CREATE      L" "
#define MSG_DELETE      L" "
#define MSG_HELP        L"           - print this screen.  <cmd> Help for detail on a command"
#define MSG_ABBR_HELP   L"              - print this screen.  <cmd> Help for detail on a command"
#define MSG_EXIT        L"           - Exit program"
#define MSG_SYMBOLS     L"[VER]   - Show list of predefined type GUIDs.. VER is verbose"
#define MSG_REMARK      L"            - Just print a remark"
#define MSG_MAKE        L"[LIST] [make script]\n" \
                        L"                - 'make list' lists make scripts\n" \
                        L"                  'make scripname args' runs script"
#define MSG_ABOUT       L"          - About this version...."

#define MSG_PROMPT      L"DiskPart> "
#define MSG_MORE        L"More> "

#define MSG_BAD_CMD     L"Problem: DiskPart did not understand that"
#define MSG_GET_HELP    L"Help for Help"
#define MSG_NO_DISKS    L"DiskPart cannot find any partitionable disks"

#define MSG_EXITING     L"Exiting...."

//
// Messages for CmdAbout
//
#define MSG_ABOUT01     L"Version 0.99.12.29   2000-08-01\n"
#define MSG_ABOUT02     L"Version %d.%d.%d.%d\n"


//
// Messages used by CmdList
//
#define MSG_LIST01      L"  ###  BlkSize          BlkCount\n"
#define MSG_LIST01B     L"  ---  -------  ----------------\n"
#define MSG_LIST02      L"%c %3d  %7x  %16lx\n"
#define MSG_LIST03      L" %3d  *** Handle Bad ***\n"

//
// Messages used by CmdSelect
//
#define MSG_SELECT01    L"No Disk Selected\n"
#define MSG_SELECT02    L"Selected Disk = %3d\n"
#define MSG_SELECT03    L"Illegal Selection\n"

//
// Messages used by CmdFix
//
#define MSG_FIX01       L"RAW disk, fix cannot help\n"
#define MSG_FIX02       L"MBR disk, fix cannot help\n"
#define MSG_FIX03       L"Disk is too corrupt for fix to help\n"
#define MSG_FIX04       L"Write of disk FAILED\n"
#define MSG_FIX05       L"Read of disk FAILED\n"

//
// Messages used by CmdInspect (some also used elsewhere)
//
#define MSG_INSPECT01   L"You must Select a disk first\n"
#define MSG_INSPECT02   L"Unable to allocate memory for sort\n"
#define MSG_INSPECT03   L"The Guid Partition Tables are out of sync, run FIX\n"
#define MSG_INSPECT04   L"The disk is RAW, nothing to Inspect\n"
#define MSG_INSPECT05   L"Inspect for MBR disks not implemented yet!\n"
#define MSG_INSPECT06   L"This appears to be a GPT disk, but it is corrupt!!\n"
#define MSG_INSPECT07   L" = UNALLOCATED SLOT"


//
// Messages used by CmdClean
//
#define MSG_CLEAN01     L"About to CLEAN (DESTROY) disk %d, are you SURE [y/n]?\n"
#define MSG_CLEAN02     L"If you are REALLY SURE, type '$C'\n"
#define STR_CLEAN_ANS   L"$C"
#define STR_CLEAN03     L"ALL"

//
// Messages used by CmdNew
//
#define STR_MBR         L"MBR"
#define STR_GPT         L"GPT"
#define MSG_NEW01       L"Disk %d is not in RAW state\n"
#define MSG_NEW02       L"Use CLEAN to make it clean/raw\n"
#define MSG_NEW03       L"Must specify 'mbr' or 'gpt'\n"
#define MSG_NEW04       L"New of MBR disks not yet supported!\n"

//
// Messages used by CmdCreate
//
#define MSG_CREATE01    L"Disk %d is RAW, do 'new gpt' first\n"
#define MSG_CREATE02    L"Disk is not GPT disk, use Fix/New/Clean\n"
#define MSG_CREATE03    L"Type name not found, use symbols of list\n"
#define MSG_CREATE04    L"Disk Partition table is FULL, cannot create!\n"
#define MSG_CREATE05    L"Attempt to Write out partition table failed!\n"
#define MSG_CREATE06    L"Create of MBR partition not implemented!\n"
#define MSG_CREATE07    L"Disk has no free blocks (FULL) cannot create!\n"
#define MSG_CREATE08    L"Invalid offset value specified.\n"
#define MSG_CREATE09    L"Partition is too small to be created.\n"
#define STR_NAME        L"NAME"
#define STR_TYPE        L"TYPE"
#define STR_TYPEGUID    L"TYPEGUID"
#define STR_OFFSET      L"OFFSET"
#define STR_SIZE        L"SIZE"
#define STR_ATTR        L"ATTR"

//
// Messages used by CmdDelete
//
#define MSG_DELETE01    L"Delete of MBR partitions not implemented\n"
#define MSG_DELETE02    L"RAW disk, cannot delete from it\n"
#define MSG_DELETE03    L"GPT disk needs updating, run FIX before delete\n"
#define MSG_DELETE04    L"GPT disk is corrupt, cannot use delete on it\n"
#define MSG_DELETE05    L"No partition by that number\n"
#define MSG_DELETE06    L"Not an allocated partition number\n"
#define MSG_DELETE07    L"You have choosen to Delete Partition #%d:\n"
#define MSG_DELETE08    L"Write of disk failed\n"
#define MSG_DELETE09    L"All data in this partition will become inaccessible\n"
#define MSG_DELETE10    L"Are You Sure [y/n]?\n"
#define MSG_DELETE11    L"If you are REALLY SURE, type '$D'>\n"
#define STR_DELETE_ANS  L"$D"

//
// Disk type GUID symbols
//
extern EFI_GUID         GuidNull;

#define STR_MSRES       L"MSRES"        // Microsoft Reserved
#define MSG_MSRES       L"Microsoft Reserved partition for feature support"
extern EFI_GUID         GuidMsReserved;

#define STR_ESP         L"EFISYS"       // EFI System Partition
#define MSG_ESP         L"EFI System Partition - required for boot"
extern EFI_GUID         GuidEfiSystem;

#define STR_MSDATA      L"MSDATA"       // Basic DATA partition
#define MSG_MSDATA      L"User data partition for use by Microsoft OSes"
extern EFI_GUID         GuidMsData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\scriptmsg.h ===
//
//  scriptmsg.h - messages, token, etc. are gathered here to make localization easier
//
//  STR_ are things that maybe don't get localized (command tokens)
//  MSG_ are output messages that probably do get localized
//
//  NOTE:   This file is ONLY for MAKE compiled in scripts in DiskPart.
//          msg.h has symbols for DiskPart proper
//

#define SCRIPT_LIST     L"LIST"
#define SCRIPT_MSFT     L"MSFT"
#define SCRIPT_TEST     L"TEST"

#define MSG_SCR_LIST    L" - show list of compiled in scripts"

//
// ----- Microsoft Style Disk script -----
//
#define MSG_SCR_MSFT    L" - Make Microsoft style disk"
extern  CHAR16  *ScriptMicrosoftMessage[];

#define STR_BOOT    L"BOOT"
#define STR_ESPSIZE L"ESPSIZE"
#define STR_ESPNAME L"ESPNAME"
#define STR_RESSIZE L"RESSIZE"

#define STR_ESP_DEFAULT     L"EFI SYSTEM PARTITION (ESP)"
#define STR_DATA_DEFAULT    L"USER DATA"
#define STR_MSRES_NAME      L"MS RESERVED"

#define DEFAULT_RES_SIZE    (32)              // in MB!
//#define DEFAULT_RES_SIZE    (1)                 // TEST ONLY

#define MIN_ESP_SIZE    (150 * (1024 * 1024))
#define MAX_ESP_SIZE    (500 * (1024 * 1024))

//#define MIN_ESP_SIZE        (1 * (1024 * 1024)) // TEST ONLY
//#define MAX_ESP_SIZE        (2 * (1024 * 1024)) // TEST ONLY


//
// ----- Fill the disk with partitions test script -----
//
#define MSG_SCR_TEST    L" - Fill the slot table with 1mb partitions"
extern  CHAR16  *ScriptTestMessage[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\md5.h ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    md5.h
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History
*/

/*
 **********************************************************************
 ** md5.h -- Header file for implementation of MD5                   **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version              **
 ** Revised (for MD5): RLR 4/27/91                                   **
 **   -- G modified to have y&~z instead of y&z                      **
 **   -- FF, GG, HH modified to add in last register done            **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3    **
 **   -- distinct additive constant for each step                    **
 **   -- round 4 added, working mod 7                                **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */

#ifndef _MD5_H_
#define _MD5_H_

/* Data structure for MD5 (Message Digest) computation */
typedef struct {
  UINT32 i[2];                   /* number of _bits_ handled mod 2^64 */
  UINT32 buf[4];                                    /* scratch buffer */
  unsigned char in[64];                              /* input buffer */
  unsigned char digest[16];     /* actual digest after MD5Final call */
} MD5_CTX;

void MD5Init (
  MD5_CTX *mdContext
  );

void MD5Update (
  MD5_CTX *mdContext,
  unsigned char *inBuf,
  unsigned int inLen
  );
  
void MD5Final (
  MD5_CTX *mdContext
  );

void GenNodeID(
  unsigned char *pDataBuf,
  long cData, 
  UINT8 NodeID[]
  );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\makescript.c ===
/*

Module Name:

    MakeScript - The "MAKE" command's built in scrips for DiskPart

Abstract:

Revision History

*/

#include "DiskPart.h"
#include "scripthelpmsg.h"


BOOLEAN ScriptMicrosoft(CHAR16 **Token);
BOOLEAN ScriptTest(CHAR16 **Token);

UINT64  ComputeDefaultEspSize(EFI_HANDLE  DiskHandle);

//
// The parse/command table
//
SCRIPT_ENTRY   ScriptTable[] = {
                { SCRIPT_LIST,  ScriptList, MSG_SCR_LIST },
                { SCRIPT_MSFT,  ScriptMicrosoft, MSG_SCR_MSFT },
                { SCRIPT_TEST,  ScriptTest, MSG_SCR_TEST  },
                { NULL, NULL, NULL }
            };

BOOLEAN
ScriptList(
    CHAR16  **Token
    )
{
    UINTN   i;

    for (i = 0; ScriptTable[i].Name != NULL; i++) {
        Print(L"%s %s\n", ScriptTable[i].Name, ScriptTable[i].HelpSummary);
    }
    return FALSE;
}


BOOLEAN
ScriptMicrosoft(
    CHAR16  **Token
    )
/*
    ScriptMicrosoft - a compiled make script, invoked via MSFT

    make msft [boot] [size=s1] [name=n1] [ressize=s2] [espsize=s3] [espname=n2]
        espsize -> boot
        espname -> boot

    See help text for syntax

    SPECIAL NOTES:
        This routine just assumes there is enough space for a
        correct MS Reserved and EFI System partitions.  This will
        always be true with a clean disk of any likely size.
        We don't test for clean though...
        (And adding MSRES and ESP partitions to a non-clean disk is a little weird.)
*/
{
    UINTN   i;
    BOOLEAN CreateEsp = FALSE;
    UINT64  EspSize = 0;
    UINT64  ResSize = 0;
    UINT64  DataSize = 0;
    UINT64  DefaultEsp;
    CHAR16  *EspName = NULL;
    CHAR16  *DataName = NULL;
    EFI_HANDLE  DiskHandle;
    CHAR16  *WorkToken[TOKEN_COUNT_MAX];
    CHAR16  CommandLine[COMMAND_LINE_MAX];


    //
    // require selected disk, copy from CmdInspect
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }
    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    //
    // parse
    //
    if ( (Token[1] == NULL) ||
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(ScriptMicrosoftHelp);
        return FALSE;
    }

    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_BOOT) == 0) {
            CreateEsp = TRUE;

        } else if (StrCmp(Token[i], STR_ESPSIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            EspSize = Atoi64(Token[i+1]);
            CreateEsp = TRUE;
            i++;

        } else if (StrCmp(Token[i], STR_ESPNAME) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            EspName = Token[i+1];
            CreateEsp = TRUE;
            i++;

        } else if (StrCmp(Token[i], STR_RESSIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            ResSize = Atoi64(Token[i+1]);
            i++;

        } else if (StrCmp(Token[i], STR_NAME) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            DataName = Token[i+1];
            i++;

        } else if (StrCmp(Token[i], STR_SIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            DataSize = Atoi64(Token[i+1]);
            i++;

        } else {
            goto ParseError;
        }
    }


    //
    // Adjust EspSize (if relevent) ResSize, DataSize
    //
    if (ResSize < DEFAULT_RES_SIZE) {
        ResSize = DEFAULT_RES_SIZE;
    }

    DefaultEsp = ComputeDefaultEspSize(DiskHandle);
    if (EspSize < DefaultEsp) {
        EspSize = DefaultEsp;
    }

    //
    // Adjust names...
    //
    if (EspName == NULL) {
        EspName = STR_ESP_DEFAULT;
    }

    if (DataName == NULL) {
        DataName = STR_DATA_DEFAULT;
    }

    //
    // Start the create sequence.  We build up a Token list
    // and then give it to CmdCreate to parse and execute normally...
    //

    //
    // The reserved partition
    //
    SPrint(
        CommandLine,
        COMMAND_LINE_MAX,
        L"%s %s=\"%s\" %s=%s %s=%ld",
        STR_CREATE,
        STR_NAME,
        STR_MSRES_NAME,
        STR_TYPE,
        STR_MSRES,
        STR_SIZE,
        ResSize
        );
    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"%s\n", CommandLine);
    }
    Tokenize(CommandLine, WorkToken);
    CmdCreate(WorkToken);

    //
    // The ESP
    //
    if (CreateEsp) {
        SPrint(
            CommandLine,
            COMMAND_LINE_MAX,
            L"%s %s=\"%s\" %s=%s %s=%ld",
            STR_CREATE,
            STR_NAME,
            EspName,
            STR_TYPE,
            STR_ESP,
            STR_SIZE,
            EspSize
            );
        if (DebugLevel >= DEBUG_ARGPRINT) {
            Print(L"%s\n", CommandLine);
        }
        Tokenize(CommandLine, WorkToken);
        CmdCreate(WorkToken);
    }

    //
    // MSDATA
    //
    SPrint(
        CommandLine,
        COMMAND_LINE_MAX,
        L"%s %s=\"%s\" %s=%s %s=%ld",
        STR_CREATE,
        STR_NAME,
        DataName,
        STR_TYPE,
        STR_MSDATA,
        STR_SIZE,
        DataSize
        );
    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"%s\n", CommandLine);
    }
    Tokenize(CommandLine, WorkToken);
    CmdCreate(WorkToken);

    return FALSE;

ParseError:
    status = EFI_INVALID_PARAMETER;
    PrintHelp(ScriptMicrosoftHelp);
    return FALSE;
}


UINT64
ComputeDefaultEspSize(
    EFI_HANDLE  DiskHandle
    )
/*
    ComputeDefaultEspSize ...

    Returns an answer in MEGABYTES
*/
{
    UINT64  DiskSize;
    UINT64  DiskSizeBytes;
    UINT32  OnePercent;

    //
    // Note, if DiskSize is so large that 1 % is more than 4G,
    // OnePercent below will overflow, but it will be OK because
    // we'll set a MAX_ESP_SIZE in the code below
    //

    DiskSize = GetDiskSize(DiskHandle);                 // In Blocks
    OnePercent = (UINT32)(DivU64x32(DiskSize, 100, NULL));    // In Blocks
    DiskSizeBytes = MultU64x32(OnePercent, GetBlockSize(DiskHandle));

    if (DiskSizeBytes < MIN_ESP_SIZE) {
        DiskSizeBytes = MIN_ESP_SIZE;
    }

    if (DiskSizeBytes > MAX_ESP_SIZE) {
        DiskSizeBytes = MAX_ESP_SIZE;
    }

    DiskSizeBytes = RShiftU64(DiskSizeBytes, 20);   // 20 bits == 1 mb
    return DiskSizeBytes;
}


CHAR16  NumStr[32];

CHAR16  *TestToken[] = {
    L"CREATE",
    L"NAME",
    NumStr,
    L"TYPE",
    L"MSDATA",
    L"SIZE",
    L"1",
    NULL
    };

BOOLEAN
ScriptTest(
    CHAR16  **Token
    )
{
    CHAR16  Buf[2];
    UINTN   i, j;

    //
    // for this to work, a disk of > 128mb will be needed
    //
    for (i = 0; i < 128; i++) {
        SPrint(NumStr, 32, L"PART#%03d", i);
        Print(L"Token for Create = \n");
        for (j = 0; TestToken[j] != NULL; j++) {
            Print(L"'%s'  ", TestToken[j]);
        }
        Print(L"\n");
        CmdCreate(TestToken);
        if (((i+1) % 4) == 0) {
            Input(L"MORE>", Buf, 2);
            Print(L"\n");
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\mbr.h ===
//
//  mbr.h - minimum stuff to allow diskpart to work on MBRs.
//

//
// MBR:
//  There are 3 kinds of MBRs.
//  1. GPT Shadow MBR - an MBR filled in with particular values
//      to keep legacy software from puking on GPT disks.
//  2. MBR base - an MBR that allows for up to 4 paritions.
//  3. Extended MBR - nested inside other MBRs to allow more than
//      4 partitions on a non-GPT disk.
//
//  This program, and therefore this header file, is only concerned
//  with case 1, and a limited subset of case 2.
//

//
// MBR contains code, with a table of 4 Partition entries and
// a signature at the end.
//

#pragma pack (1)

typedef struct _MBR_ENTRY {
    CHAR8 ActiveFlag;               // Bootable or not
    CHAR8 StartingTrack;            // Not used
    CHAR8 StartingCylinderLsb;      // Not used
    CHAR8 StartingCylinderMsb;      // Not used
    CHAR8 PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    CHAR8 EndingTrack;              // Not used
    CHAR8 EndingCylinderLsb;        // Not used
    CHAR8 EndingCylinderMsb;        // Not used
    UINT32 StartingSector;          // Hidden sectors
    UINT32 PartitionLength;         // Sectors in this partition
} MBR_ENTRY;

//
// Number of partition table entries
//
#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in bytes
//

#define MBR_TABLE_OFFSET               (0x1be)
#define MBR_SIGNATURE_OFFSET           (0x200 - 2)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Special Partition type used only on GPT disks
//

#define PARTITION_TYPE_GPT_SHADOW       (0xEE)


#pragma pack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\scripthelpmsg.h ===
//
//  Help text for Make Script procedures
//

CHAR16 *ScriptMicrosoftHelp[] = {
    L"make msft help  or\n"
    L"make msft [boot] [size=s1] [name=n1] [ressize=s2] [espsize=s3] [espname=n2]\n",
    L"help - prints this page",
    L"boot - creates an EFI system/boot parition (an esp)\n",
    L"       disk will NOT be bootable without this\n",
    L"size=s1 - s1 is size of data partition in megabytes - default is fill disk\n",
    L"name=n1 - n1 is name of data partition, default is 'USER DATA'\n",
    L"ressize=s2 - raises size of reserved MS partition above default, rarely used\n",
    L"espsize=s3 - set size of ESP if greater than default, rarely used\n",
    L"espname=n2 - names ESP, default is EFI SYSTEM\n",
    L"examples:\n",
    L"    make msft - creates msres, msdata to fill disk, NOT bootable\n",
    L"    make msft boot - creates msres, esp, msdata to fill, IS BOOTABLE\n",
    L"    make msft espsize=400 msres=300 espname=ALTBOOT\n",
    L"    make msft size=400 name=DATA1 espsize=200 epsname=ALTBOOT\n",
    L"make msft boot - this is normally what to do if you are not sure\n",
    NULL
    };

CHAR16 *ScriptTestMessage[] = {
    L"fill the table with 1mb partitions...\n",
    NULL
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efichk\usa\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\efichk.obj

EFI_LIBS=..\..\efilib\src\$(ALT_PROJECT)\$(TARGETPATH)\$(TARGET_DIRECTORY)\efilib.lib \
         $(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
!if $(IA64)
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib
!else
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib \
         $(SDK_LIB_PATH)\int64.lib
!endif

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:InitializeEfiChkApplication
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efifmt\usa\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\$(TARGETNAME).obj \
     $(O)\$(TARGETNAME).res

EFI_LIBS=..\..\efilib\src\$(ALT_PROJECT)\$(TARGETPATH)\$(TARGET_DIRECTORY)\efilib.lib \
         $(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
!if $(IA64)
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib
!else
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib \
         $(SDK_LIB_PATH)\int64.lib
!endif

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:InitializeEfiFmtApplication
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efifmt\efifmt.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efifmt.cxx

Abstract:

    This is the main program for the efi version of format.

--*/

#pragma warning(disable: 4091)

#include "ulib.hxx"
#include "wstring.hxx"
#include "efickmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"
#include "fatvol.hxx"
#include "layout.hxx"

#include "efiwintypes.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C"
BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    );

int argc;
WCHAR ** argv;

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );
#endif

VOID
InvokeAutoFmtMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );

extern "C" {

EFI_STATUS
__declspec(dllexport)
InitializeEfiFmtApplication(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_LOADED_IMAGE    *LoadedImage;

    /*
     *  Initialize the Library. Set BS, RT, &ST globals
     *   BS = Boot Services RT = RunTime Services
     *   ST = System Table
     */
    InitializeLib (ImageHandle, SystemTable);
    InitializeShellApplication( ImageHandle, SystemTable );

    DEBUG((D_INFO,(CHAR8*)"EFIFMT application started\n"));

    Print(TEXT("EFI Disk Format Version 0.2\n"));
    Print(TEXT("Based on EFI Core "));
    Print(TEXT("Version %d.%d.%d.%d\n"),
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID**)&LoadedImage);

#if 0
    PrintLoadedImageInfo (LoadedImage);
#endif

    // call into autofmt.
    InvokeAutoFmtMain (ImageHandle, LoadedImage);

#if 0
    EfiWaitForKey();
    ST->ConOut->OutputString (ST->ConOut, TEXT("\n\n"));
#endif

    return EFI_SUCCESS;
}

} // extern "C"

UINT16 *MemoryType[] = {
            TEXT("reserved  "),
            TEXT("LoaderCode"),
            TEXT("LoaderData"),
            TEXT("BS_code   "),
            TEXT("BS_data   "),
            TEXT("RT_code   "),
            TEXT("RT_data   "),
            TEXT("available "),
            TEXT("Unusable  "),
            TEXT("ACPI_recl "),
            TEXT("ACPI_NVS  "),
            TEXT("MemMapIO  "),
            TEXT("MemPortIO "),
            TEXT("PAL_code  "),
            TEXT("BUG:BUG: MaxMemoryType")
};


VOID
InvokeAutoFmtMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_LOADED_IMAGE    *ParentImage;

    if (!LoadedImage->ParentHandle) {
        /*
         *  If you are loaded from the EFI boot manager the ParentHandle
         *   is Null. Thus a pure EFI application will not have a parrent.
         */
        DEBUG((D_INFO,(CHAR8*)"\n%HImage was loaded from EFI Boot Manager%N\n"));
        return;
    }

    BS->HandleProtocol (LoadedImage->ParentHandle, &LoadedImageProtocol, (VOID**)&ParentImage);

#if 0
    Print(TEXT("\n%HImage Parent was %N%s %Hand it passed the following arguments:%N \n   %s\n\n"), DevicePathToStr (ParentImage->FilePath),LoadedImage->LoadOptions);
#endif

    {
        argc = SI->Argc;
        argv = SI->Argv;

        DEBUG((D_INFO,(CHAR8*)"Launching main...\n"));
        // call main.
        main(argc,argv,NULL);
        DEBUG((D_INFO,(CHAR8*)"Returned from main...\n"));

    }
}

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;

    Print(TEXT("\n%HImage was loaded from file %N%s\n"), DevicePathToStr (LoadedImage->FilePath));

    BS->HandleProtocol (LoadedImage->DeviceHandle, &DevicePathProtocol, (VOID**)&DevicePath);
    if (DevicePath) {
        Print(TEXT("%HImage was loaded from this device %N%s\n"), DevicePathToStr (DevicePath));

    }

    Print(TEXT("\n Image Base is %X"), LoadedImage->ImageBase);
    Print(TEXT("\n Image Size is %X"), LoadedImage->ImageSize);
    Print(TEXT("\n  Image Code Type %s"), MemoryType[LoadedImage->ImageCodeType]);
    Print(TEXT("\n  Image Data Type %s"), MemoryType[LoadedImage->ImageDataType]);
    Print(TEXT("\n %d Bytes of Options passed to this Image\n"), LoadedImage->LoadOptionsSize);

    if (LoadedImage->ParentHandle) {
        Status = BS->HandleProtocol (LoadedImage->ParentHandle, &DevicePathProtocol, (VOID**)&DevicePath);
        if (Status == EFI_SUCCESS && DevicePath) {
           Print(TEXT("Images parent is %s\n\n"), DevicePathToStr (DevicePath));
        }
    }
}
#endif

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    )
/*++

Routine Description:

    This routine is the main program for AutoFmt

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autofmt
                  command line is:

    AUTOFMT drive-name /FS:target-file-system [/V:label] [/Q] [/A:size] [/C]
            [/S]

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        return 1;
    }

    PFAT_VOL            fat_volume;
    PDP_DRIVE            dp_drive;

    EFICHECK_MESSAGE    *message = NULL;
    DSTRING             drive_name;
    DSTRING             file_system_name;
    DSTRING             label;
    DSTRING*            plabel;
    DSTRING             fat_name;
    DSTRING             fat32_name;
    DSTRING             raw_name;
    BOOLEAN             quick = FALSE;
    BOOLEAN             compress = FALSE;
    FORMAT_ERROR_CODE   success;
    BOOLEAN             setup_output = FALSE;
    BOOLEAN             textmode_output = FALSE;
    BOOLEAN             drive_already_specified = FALSE;
    BOOLEAN             force_filesystem = FALSE;
    BOOLEAN             showhelp = FALSE;
    BOOLEAN             labelled = FALSE;
    BIG_INT             bigint;
    ULONG               cluster_size = 0;
    int                 i;
    NTSTATUS            result;

    if (!(perrstk = NEW ERRSTACK)) {
        return 1;
    }

    if (!file_system_name.Initialize()) {
        return 1;
    }
    if (!label.Initialize() || NULL == (dp_drive = NEW DP_DRIVE)) {
        return 1;
    }

    //
    //  Parse the arguments.
    //

//    if ( argc < 2 ) {
//        return 1;
//    }

    message = NEW EFICHECK_MESSAGE;

    if (NULL == message || !message->Initialize()) {
        return 1;
    }

    //
    //  The rest of the arguments are flags.
    //
    for (i = 1; i < argc; i++) {

        if (((argv[i][0] == '/' || argv[i][0] == '=') &&
            (argv[i][1] == '?' )) || showhelp
             ) {
            showhelp = TRUE;
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'f' || argv[i][1] == 'F')    &&
            (argv[i][2] == 's' || argv[i][2] == 'S')    &&
            (argv[i][3] == ':')) {

            if (!file_system_name.Initialize(&argv[i][4])) {
                return 1;
            }
            force_filesystem = TRUE;
            DEBUG((D_INFO,(CHAR8*)"fsname: %ws\n", file_system_name.GetWSTR()));
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'v' || argv[i][1] == 'V')    &&
            (argv[i][2] == ':')) {

            if (!label.Initialize(&argv[i][3])) {
                return 1;
            }
            labelled = TRUE;
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'a' || argv[i][1] == 'A')    &&
            (argv[i][2] == ':')) {

            // Check to see if the size is specified in Kb
            if ((argv[i][StrLen(argv[i])-1] == 'k') || (argv[i][StrLen(argv[i])-1] == 'K')) {
                argv[i][StrLen(argv[i])-1] = '\0'; // remove the K and null terminate the string
                cluster_size = (ULONG)Atoi(&argv[i][3]) * 1024;                
            } 
            else {
                cluster_size = (ULONG)Atoi(&argv[i][3]);
            }
        }
        else if (0 == StriCmp(argv[i], TEXT("/Q")) || 0 == StriCmp(argv[i], TEXT("-Q"))) {
            quick = TRUE;
        }
        else if (argv[i][0] != '/' && argv[i][0] != '-') {
            // it's not a switch, assume it is the drive
            // we don't allow two drive at the same time
            if( drive_already_specified ) {
                message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                message->Display();
                return 1;
            }
            drive_already_specified = TRUE;
            if ( !drive_name.Initialize( argv[i] ) ) {
                return 1;
            }
            DEBUG((D_INFO,(CHAR8*)"drive name: %ws\n", drive_name.GetWSTR()));
        }
        else {
            // its not any vaild option we know of
            message->Set(MSG_INVALID_PARAMETER);
            message->Display("%ws",argv[i]);
            message->Set(MSG_BLANK_LINE);
            message->Display();
            showhelp = TRUE;
        }
    }

    DEBUG((D_INFO,(CHAR8*)"Parsed Args.\n"));

    if(showhelp || !drive_already_specified) {
        message->Set(MSG_FORMAT_INFO);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_1);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_2);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_4);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_V);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_Q);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_F);
        message->Display();
        message->Set(MSG_FORMAT_SUPPORTED_SIZES);
        message->Display();

        return 1;
    }

    textmode_output = TRUE;

#if 0 // Shouldn't limit the cluster size as long as it is reasonable.
    if (cluster_size != 0 && cluster_size != 512 && cluster_size != 1024 &&
        cluster_size != 2048 && cluster_size != 4096) {

        message->Set(MSG_UNSUPPORTED_PARAMETER);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }
#endif
    DEBUG((D_INFO,(CHAR8*)"Determining file system type.\n"));

    if (0 == file_system_name.QueryChCount()) {

        // attempt to get the current filesystem type from disk

        if (!IFS_SYSTEM::QueryFileSystemName(&drive_name, &file_system_name, &result, NULL)) {

            message->Set( MSG_FS_NOT_DETERMINED );
            message->Display( "%W", &drive_name );

            DEBUG((D_ERROR,(CHAR8*)"Unable to determine file system type.\n"));

            if(result != 0) {
                message->Set(MSG_CANT_DASD);
                message->Display();
            }

            return 1;
        }
        file_system_name.Strupr();
    }

    if (!fat_name.Initialize("FAT") ||
        !fat32_name.Initialize("FAT32") ||
        !raw_name.Initialize("RAW") ) {

        return 1;
    }

    file_system_name.Strupr();

    //
    // If compression is requested, make sure it's available.
    //
#if 0
    if (compress) {

        message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
        message->Display("%W", &file_system_name);
        return 1;
    }
#endif

    DEBUG((D_INFO,(CHAR8*)"Init DP_DRIVE.\n"));
    if (!dp_drive->Initialize(&drive_name, message)) {
        DEBUG((D_ERROR,(CHAR8*)"Failed Init DP_DRIVE.\n"));
        return 1;
    }
    DEBUG((D_INFO,(CHAR8*)"Init DP_DRIVE success.\n"));

    message->Set(MSG_WARNING_FORMAT);
    message->Display("%W", &drive_name);
    if (!message->IsYesResponse(FALSE)) {
        return 5;
    }

    if (dp_drive->IsFloppy()) {
        DEBUG((D_INFO,(CHAR8*)"**** Is a floppy.\n"));
//        return 1; BUGBUG should i fail this?
    }

    //
    // Print the "formatting <size>" message.
    //

    if (quick) {
        message->Set(MSG_QUICKFORMATTING_MB);
    } else {
        message->Set(MSG_FORMATTING_MB);
    }

    if( labelled == FALSE ) {
        plabel = NULL;
    } else {
        plabel = &label;
    }

    DEBUG((D_INFO,(CHAR8*)"QuerySector count.\n"));

    bigint = dp_drive->QuerySectors() * dp_drive->QuerySectorSize() /
        1048576;

    DEBUG((D_INFO,(CHAR8*)"Sector count is %ld.\n",dp_drive->QuerySectors()));
    DEBUG((D_INFO,(CHAR8*)"Sector size is %d.\n",dp_drive->QuerySectorSize()));

    DebugAssert(bigint.GetHighPart() == 0);

    message->Display("%d", bigint.GetLowPart());

#if 0
    PART_DESCRIPTOR partdes;
    UINT32 fatsize;


    // if the user hasn't forced a filesystem
    if( force_filesystem == FALSE ) {
        // if the disk is big enough to put at least FAT16 on it
        if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat16(dp_drive->QuerySectorSize())) {
            DEBUG((D_INFO,(CHAR8*)"Drive is big enough for FAT16 >= %d.\n",MinSectorsFat16(dp_drive->QuerySectorSize())));
            partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
            partdes.SectorSize = dp_drive->QuerySectorSize();
            partdes.HeaderCount = HEADER_F16;
            partdes.FatEntrySize = 2;
            partdes.MinClusterCount = MIN_CLUSTER_F16;
            partdes.MaxClusterCount = MAX_CLUSTER_F16;
            partdes.FatType = FAT_TYPE_F16;
            file_system_name.Initialize(fat_name.QueryWSTR());

            // if this disk is big enough for FAT32
            if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat32(dp_drive->QuerySectorSize())) {
                DEBUG((D_INFO,(CHAR8*)"Drive is big enough for FAT32 >= %d\n",MinSectorsFat32(dp_drive->QuerySectorSize())));
                partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
                partdes.SectorSize = dp_drive->QuerySectorSize();
                partdes.HeaderCount = HEADER_F32;
                partdes.FatEntrySize = 4;
                partdes.MinClusterCount = MIN_CLUSTER_F32;
                partdes.MaxClusterCount = MAX_CLUSTER_F32;
                partdes.FatType = FAT_TYPE_F32;
                file_system_name.Initialize(fat32_name.QueryWSTR());
            }

            // if the user hasn't forced a cluster size, select an appropriate one for him
            if( cluster_size==0 ) {
                PickClusterSize(&partdes,(UINT32*)&cluster_size,&fatsize); // note this routine doesn't work for FAT12

                cluster_size = cluster_size * dp_drive->QuerySectorSize(); // PickClusterSize return cluster size in sectors
                DEBUG((D_INFO,(CHAR8*)"User hasn't forced a cluster size, picking %d\n",cluster_size));
            }
        } else {
            // do the default, which is going to be FAT12 and whatever regular format picks.
            file_system_name.Initialize(fat_name.QueryWSTR());
        }
    } else {
        // if the drive is big enough for FAT16
        if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat16(dp_drive->QuerySectorSize())) {
            // the user forced a file system, did he force a cluster size?
            if( cluster_size==0 ) {
                // nope, setup and pick a good size
                partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
                partdes.SectorSize = dp_drive->QuerySectorSize();

                if(file_system_name == fat_name) {
                    partdes.HeaderCount = HEADER_F16;
                    partdes.FatEntrySize = 2;
                    partdes.MinClusterCount = MIN_CLUSTER_F16;
                    partdes.MaxClusterCount = MAX_CLUSTER_F16;
                    partdes.FatType = FAT_TYPE_F16;
                } else if(file_system_name == fat32_name){
                    partdes.HeaderCount = HEADER_F32;
                    partdes.FatEntrySize = 4;
                    partdes.MinClusterCount = MIN_CLUSTER_F32;
                    partdes.MaxClusterCount = MAX_CLUSTER_F32;
                    partdes.FatType = FAT_TYPE_F32;
                }
                PickClusterSize(&partdes,(UINT32*)&cluster_size,&fatsize); // note this routine doesn't work for FAT12
                cluster_size = cluster_size * dp_drive->QuerySectorSize(); // PickClusterSize return cluster size in sectors
                DEBUG((D_INFO,(CHAR8*)"FS type forced, user hasn't forced a cluster size, picking %d\n",cluster_size));
            }
        }
    }
#endif

    if (file_system_name == fat_name || file_system_name == fat32_name) {

        BOOLEAN old_fat_vol = TRUE;

        DEBUG((D_INFO,(CHAR8*)"This is an old FAT volume.\n"));

        if( file_system_name == fat32_name ) {
            old_fat_vol = FALSE;
        }

        if( !(fat_volume = NEW FAT_VOL) ||
            NoError != fat_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {
            DEBUG((D_ERROR,(CHAR8*)"fat_volume init failed.\n"));
            //return 1;
        }

        DEBUG((D_INFO,(CHAR8*)"fat_volume init succeeded.\n"));

        success = fat_volume->Format(plabel,
                                     message,
                                     old_fat_vol ? FORMAT_BACKWARD_COMPATIBLE : 0,
                                     cluster_size);

        DEBUG((D_INFO,(CHAR8*)"Format return code: %d\n", success));

        DELETE( fat_volume );

    } else {

        DEBUG((D_ERROR,(CHAR8*)"fs not supported.\n"));

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "EFIFMT", &file_system_name);

        return 1;
    }

    return (success != NoError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efifmt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_NOLIBS=1

MAJORCOMP=ntos
MINORCOMP=efi

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

TARGETNAME=efifmt
TARGETPATH=obj
TARGETTYPE=LIBRARY

386_STDCALL=0

UMENTRYABS=InitializeEfiFmtApplication

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gs1048576

SOURCES=..\efifmt.cxx ..\efifmt.rc

INCLUDES=       ..\..\efilib\src; \
                ..\..\efilib\src\$(ALT_PROJECT); \
                ..\..\efilib\efiinc; \
                ..\..\efilib\inc ; \
                $(EFI_ROOT)\inc; \
!if $(IA64)
                $(EFI_ROOT)\inc\ia64;\
!else
                $(EFI_ROOT)\inc\ia32;\
!endif
                $(EFI_ROOT)\shell\inc

C_DEFINES=-DCONDITION_HANDLING=1 -D_EFICHECK_=1 -DUNICODE=1

!if "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
C_DEFINES=$(C_DEFINES) -DEFI_DEBUG=1
!ENDIF

UMTYPE=console

DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc

NTTARGETFILES=$(O)\$(TARGETNAME).efi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efichk\efichk.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efichk.cxx

Abstract:

    This is the main program for the eficheck version of chkdsk.

--*/

#pragma warning(disable: 4091)

#include "ulib.hxx"
#include "wstring.hxx"
#include "fatvol.hxx"
#include "efickmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "rcache.hxx"
#include "ifsserv.hxx"

#include "efiwintypes.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     INT              ArgCount,
    IN     WCHAR            **ArgArray,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    );

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    );

extern "C" {
#include "efi.h"
#include "efilib.h"
}

int argc;
WCHAR ** argv;

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );
#endif

VOID
InvokeAutochkMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );

extern "C" {

EFI_STATUS
__declspec(dllexport)
InitializeEfiChkApplication(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_LOADED_IMAGE    *LoadedImage;

    /*
     *  Initialize the Library. Set BS, RT, &ST globals
     *   BS = Boot Services RT = RunTime Services
     *   ST = System Table
     */
    InitializeLib (ImageHandle, SystemTable);
    InitializeShellApplication( ImageHandle, SystemTable );

    Print(TEXT("EFI Check Disk Version 0.2\n"));
    Print(TEXT("Based on EFI Core "));
    Print(TEXT("Version %d.%d.%d.%d\n"),
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    DEBUG((D_INFO,(CHAR8*)"EFICHK application started\n"));

    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID**)&LoadedImage);

#if 0
    PrintLoadedImageInfo (LoadedImage);
#endif

    // call into autochk.
    InvokeAutochkMain (ImageHandle, LoadedImage);

#if 0
    EfiWaitForKey();
    ST->ConOut->OutputString (ST->ConOut,  TEXT("\n\n"));
#endif

    return EFI_SUCCESS;
}

} // extern "C"

UINT16 *MemoryType[] = {
             TEXT("reserved  "),
             TEXT("LoaderCode"),
             TEXT("LoaderData"),
             TEXT("BS_code   "),
             TEXT("BS_data   "),
             TEXT("RT_code   "),
             TEXT("RT_data   "),
             TEXT("available "),
             TEXT("Unusable  "),
             TEXT("ACPI_recl "),
             TEXT("ACPI_NVS  "),
             TEXT("MemMapIO  "),
             TEXT("MemPortIO "),
             TEXT("PAL_code  "),
             TEXT("BUG:BUG: MaxMemoryType")
};


VOID
InvokeAutochkMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_LOADED_IMAGE    *ParentImage;

    if (!LoadedImage->ParentHandle) {
        /*
         *  If you are loaded from the EFI boot manager the ParentHandle
         *   is Null. Thus a pure EFI application will not have a parrent.
         */
        DEBUG((D_INFO,(CHAR8*)"\n%HImage was loaded from EFI Boot Manager%N\n"));
        return;
    }

    BS->HandleProtocol (LoadedImage->ParentHandle, &LoadedImageProtocol, (VOID**)&ParentImage);

    {
        argc = SI->Argc;
        argv = SI->Argv;

        DEBUG((D_INFO,(CHAR8*)"Launching main...\n"));
        // call main.
        main(argc,argv,NULL);
        DEBUG((D_INFO,(CHAR8*)"Returned from main...\n"));

    }
}

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;

    Print( TEXT("\n%HImage was loaded from file %N%s\n"), DevicePathToStr (LoadedImage->FilePath));

    BS->HandleProtocol (LoadedImage->DeviceHandle, &DevicePathProtocol, (VOID**)&DevicePath);
    if (DevicePath) {
        Print( TEXT("%HImage was loaded from this device %N%s\n"), DevicePathToStr (DevicePath));

    }

    Print( TEXT("\n Image Base is %X"), LoadedImage->ImageBase);
    Print( TEXT("\n Image Size is %X"), LoadedImage->ImageSize);
    Print( TEXT("\n  Image Code Type %s"), MemoryType[LoadedImage->ImageCodeType]);
    Print( TEXT("\n  Image Data Type %s"), MemoryType[LoadedImage->ImageDataType]);
    Print( TEXT("\n %d Bytes of Options passed to this Image\n"), LoadedImage->LoadOptionsSize);

    if (LoadedImage->ParentHandle) {
        Status = BS->HandleProtocol (LoadedImage->ParentHandle, &DevicePathProtocol, (VOID**)&DevicePath);
        if (Status == EFI_SUCCESS && DevicePath) {
           Print( TEXT("Images parent is %s\n\n"), DevicePathToStr (DevicePath));
        }
    }
}
#endif

BOOLEAN             force = FALSE;
BOOLEAN             readonly = TRUE;

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    )
/*++

Routine Description:

    This routine is the main program for autocheck FAT chkdsk.

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                    the drive to check.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    DEBUG( (D_INFO,(CHAR8*)"\nInit Libs...\n"));

    if (!InitializeUlib( NULL, !DLL_PROCESS_DETACH, NULL ) ||
        !InitializeIfsUtil(NULL,0,NULL) ||
        !InitializeUfat(NULL,0,NULL)) {
        return 1;
    }
    DEBUG( (D_INFO,(CHAR8*)"Init Libs Successful.\n"));
    //
    // The declarations must come after these initialization functions.
    //
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             drive_letter;

    EFICHECK_MESSAGE      *msg = NULL;

    BOOLEAN             onlyifdirty = TRUE;
    BOOLEAN             recover = FALSE;
    BOOLEAN             extend = FALSE;
    BOOLEAN             remove_registry = FALSE;

    ULONG               ArgOffset = 1;

    BOOLEAN             SetupOutput = FALSE;
    BOOLEAN             SetupTextMode = FALSE;
    BOOLEAN             SetupSpecialFixLevel = FALSE;

    ULONG               exit_status = 0;

    BOOLEAN             SuppressOutput = TRUE;      // dots only by default

    BOOLEAN             all_drives = FALSE;
    BOOLEAN             resize_logfile = FALSE;
    BOOLEAN             skip_index_scan = FALSE;
    BOOLEAN             skip_cycle_scan = FALSE;
    BOOLEAN             showhelp = FALSE;
    BOOLEAN             drive_already_specified = FALSE;

    LONG                logfile_size = 0;

    USHORT              rtncode;
    ULONG               chkdsk_flags;

    if (!drive_letter.Initialize() ||
        !volume_name.Initialize()) {
        DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
        return 1;
    }

    force = FALSE;
    onlyifdirty = FALSE;

    // Parse the arguments--the accepted arguments are:
    //
    //      efichk [/f] [/r] device-name
    //
    //      /f - fix errors
    //      /r - recover; implies /f
    //

    msg = NEW EFICHECK_MESSAGE;

    if (NULL == msg || !msg->Initialize()) {
        return 1;
    }

    DEBUG( (D_INFO,(CHAR8*)"\nParse Options\n"));

    for (ArgOffset = 1; ArgOffset < (ULONG)argc; ++ArgOffset) {

        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'r' || argv[ArgOffset][1] == 'R') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /f.
            //
            recover = TRUE;
            readonly = FALSE;
        } else if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'f' || argv[ArgOffset][1] == 'F') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /p.
            //
            readonly = FALSE;
        } else if ((argv[ArgOffset][0] != '/' && argv[ArgOffset][0] != '-')) {
            //  we assume this refers to a device
            if (!volume_name.Initialize(argv[ArgOffset])) {
                return 1;
            }
            drive_already_specified = TRUE;
        } else if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == '?') &&
            (argv[ArgOffset][2] == 0) ) {

            // show some usage help
            showhelp = TRUE;
        } else if ( strcmp(argv[ArgOffset], TEXT("/FORCE")) == 0 ) {
            // have a /FORCE switch to allow efichk to check really messed up volumes.
            force = TRUE;
        } else {
            // this is a switch we don't know of
            msg->Set(MSG_INVALID_PARAMETER);
            msg->Display("%ws",argv[ArgOffset]);
            msg->Set(MSG_BLANK_LINE);
            msg->Display();
            showhelp = TRUE;
        }
    }

    SuppressOutput = FALSE;

    if(showhelp || !drive_already_specified) {
        msg->Set(MSG_CHK_USAGE_HEADER);
        msg->Display();
        msg->Set(MSG_BLANK_LINE);
        msg->Display();
        msg->Set(MSG_CHK_COMMAND_LINE);
        msg->Display();
        msg->Set(MSG_CHK_DRIVE);
        msg->Display();
        msg->Set(MSG_CHK_F_SWITCH);
        msg->Display();
        msg->Set(MSG_CHK_V_SWITCH);
        msg->Display();
        return 1;
    }

    // make drive letter the same as volume name
    if (!drive_letter.Initialize(&volume_name)) {
        return 1;
    }

    DEBUG( (D_INFO,(CHAR8*)"\nParsed Args\n"));

    chkdsk_flags = 0;
    chkdsk_flags = (onlyifdirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    chkdsk_flags |= ((recover || extend) ? CHKDSK_RECOVER_FREE_SPACE : 0);
    chkdsk_flags |= (recover ? CHKDSK_RECOVER_ALLOC_SPACE : 0);

    DEBUG((D_INFO,(CHAR8*)"Invoking chkdsk.\n"));

    rtncode = InvokeAutoChk(&drive_letter,
                            &volume_name,
                            chkdsk_flags,
                            remove_registry,
                            SetupOutput || SetupTextMode,
                            extend,
                            logfile_size,
                            argc,
                            argv,
                            msg,
                            &exit_status);

    DEBUG((D_INFO,(CHAR8*)"Back from chkdsk.\n"));
#if 0
    switch( exit_status ) {
    case 0:
        msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
        break;
    case 1:
    case 2:
        msg->Set(MSG_CHK_ERRORS_FIXED);
        break;
    case 3:
        msg->Set(MSG_CHK_ERRORS_NOT_FIXED);
        break;
    default:
        msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
        break;
    }
    msg->Display();
#endif

    DELETE(msg);

    DEBUG((D_ERROR,(CHAR8*)"EFICHK: Exit Status %d\n", exit_status));

    return exit_status;
}

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     INT              ArgCount,
    IN     WCHAR            **ArgArray,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    )
/*++

Routine Description:

    This is the core of efichk.  It checks the specified drive.

Arguments:

    DriveLetter     - Supplies the drive letter of the drive
                      (can be empty string)
    VolumeName      - Supplies the guid volume name of the drive
    ChkdskFlags     - Supplies the chkdsk control flags
    RemoveRegistry  - Supplies TRUE if registry entry is to be removed
    SetupMode       - Supplies TRUE if invoked through setup
    Extend          - Supplies TRUE if extending the volume (obsolete)
    LogfileSize     - Supplies the size of the logfile
    ArgCount        - Supplies the number of arguments given to autochk.
    ArgArray        - Supplies the arguments given to autochk.
    Msg             - Supplies the outlet of messages
    ExitStatus      - Retrieves the exit status of chkdsk

Return Value:

    0   - Success
    1   - Fatal error
    2   - Volume specific error

--*/
{
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;

    PFAT_VOL            fatvol = NULL;
    PVOL_LIODPDRV       vol;

    BOOLEAN             SetupSpecialFixLevel = FALSE;

    PREAD_CACHE         read_cache;

    DSTRING             boot_execute_log_file_name;
    FSTRING             boot_ex_temp;
    HMEM                logged_message_mem;
    NTSTATUS            result;

    DSTRING             fatname;
    DSTRING             fat32name;
    DSTRING             rawname;
    DSTRING             ntfsname;

    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    if (!fatname.Initialize("FAT") ||
        !rawname.Initialize("RAW") ||
        !fat32name.Initialize("FAT32")) {
        return 1;
    }

    if (VolumeName->QueryChCount() == 0) {
        DEBUG((D_ERROR,(CHAR8*)"EFICHK: Volume name is missing.\n"));
        return 2;   // continue if all_drives are enabled
    }

    if (DriveLetter->QueryChCount() == 0) {
        // unable to map VolumeName to a drive letter so do the default
        if (!IFS_SYSTEM::NtDriveNameToDosDriveName(VolumeName, DriveLetter)) {
            DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
            return 1;
        }
    }

    if (!IFS_SYSTEM::QueryFileSystemName(VolumeName, &fsname,
                                         &result, &fsNameAndVersion)) {
        Msg->Set( MSG_FS_NOT_DETERMINED );
        Msg->Display( "%W", VolumeName );

        if(result != 0 ){
            Msg->Set(MSG_CANT_DASD);
            Msg->Display();
        }
        return 2;
    }

    // Msg->SetLoggingEnabled();
    Msg->Set(MSG_CHK_RUNNING);
    Msg->Display("%W", DriveLetter);

    Msg->Set(MSG_FILE_SYSTEM_TYPE);
    Msg->Display("%W", &fsname);

    if (fsname == fatname || fsname == fat32name || force) {

        if (!(fatvol = NEW FAT_VOL)) {
            DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
            return 1;
        }

        if (NoError != fatvol->Initialize(Msg,
                                          VolumeName,
                                          (BOOLEAN)(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY))) {
            DELETE(fatvol);
            return 2;
        }

        if ((read_cache = NEW READ_CACHE) &&
            read_cache->Initialize(fatvol, 75)) {
            fatvol->SetCache(read_cache);
        } else {
            DELETE(read_cache);
        }

        vol = fatvol;

    } else {
        Msg->Set( MSG_FS_NOT_SUPPORTED );
        Msg->Display( "%s%W", "EFICHK", &fsname );
        return 2;
    }

    // Invoke chkdsk.

    if (!vol->ChkDsk(readonly ? CheckOnly : TotalFix,
                     Msg,
                     ChkdskFlags,
                     LogfileSize,
                     ExitStatus,
                     DriveLetter)) {

        DELETE(vol);

        DEBUG((D_ERROR,(CHAR8*)"EFICHK: ChkDsk failure\n"));

        return 2;
    }

    DELETE(vol);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\diskpart\symbols.h ===
//
//  Symmbols.h - predefined GUID symbols (for partition types)
//
//  Since symbols names are likely to be localized, the actual strings
//  are in msg.h.  So, to add a new partition type, you add STR_ and MSG_
//  entries for it in msg.h, add it's EFI_GUID var name and value here.
//  You then add all of these to SymbolList below.  Also add an extern
//  for each variable to msg.h.
//
//  Internal code (like Make procedures) use the globals.
//

typedef struct {
    CHAR16      *SymName;
    CHAR16      *Comment;
    EFI_GUID    *Value;
} SYMBOL_DEF;


EFI_GUID GuidNull =
{ 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // Null guid => unused entries

EFI_GUID GuidMsReserved =
{ 0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE };  // Microsoft Reserved Space

EFI_GUID GuidEfiSystem =
{ 0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B }; // Efi System Partition (esp)

EFI_GUID GuidMsData =
{ 0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7 }; // MS Basic Data Parition



SYMBOL_DEF  SymbolList[] = {
    { STR_MSRES,    MSG_MSRES,  &GuidMsReserved },
    { STR_ESP,      MSG_ESP,    &GuidEfiSystem  },
    { STR_MSDATA,   MSG_MSDATA, &GuidMsData     },
    { NULL, NULL, NULL }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efichk\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_NOLIBS=1

MAJORCOMP=ntos
MINORCOMP=efi

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

TARGETNAME=efichk
TARGETPATH=obj
TARGETTYPE=LIBRARY

386_STDCALL=0

UMENTRYABS=InitializeEfiChkApplication

MSC_WARNING_LEVEL=/W3

#must set /Gs1048576 to disable stkchk in EFI
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gs1048576

SOURCES=\
    ..\efichk.cxx \
    ..\efichk.rc

INCLUDES=\
    ..\..\efilib\src;\
    ..\..\efilib\src\$(ALT_PROJECT);\
    ..\..\efilib\efiinc;\
    ..\..\efilib\inc;\
    $(EFI_ROOT)\inc;\
!if $(IA64)
                $(EFI_ROOT)\inc\ia64;\
!else
                $(EFI_ROOT)\inc\ia32;\
!endif
    $(EFI_ROOT)\shell\inc

CXX_FLAGS=+d

C_DEFINES=-DCONDITION_HANDLING=1 -D_EFICHECK_=1 -DUNICODE=1

!if "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
C_DEFINES=$(C_DEFINES) -DEFI_DEBUG=1
!endif

UMTYPE=console

DLLDEF=

SOURCES_USED=..\sources.inc

NTTARGETFILES=$(O)\$(TARGETNAME).efi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efilib\efisrc\efimessages.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    efimessages.cxx

--*/
#include "pch.cxx"

#include "efimessages.hxx"

//
// If you change this table, please update the message count EFI_MESSAGE_COUNT
// in efimessages.hxx
//

EFI_MESSAGE MessageTable[] = {
{
    MSG_CONVERT_LOST_CHAINS,
    TEXT("Convert lost chains to files (Y/N)? %0")
},

{
    MSG_CHK_ERROR_IN_DIR,
    TEXT("Unrecoverable error in folder %1.")
},

{
    MSG_CHK_CONVERT_DIR_TO_FILE,
    TEXT("Convert folder to file (Y/N)? %0")
},

{
    MSG_TOTAL_DISK_SPACE,
    TEXT("%1 bytes total disk space.")
},

{
    MSG_BAD_SECTORS,
    TEXT("%1 bytes in bad sectors.")
},

{
    MSG_HIDDEN_FILES,
    TEXT("%1 bytes in %2 hidden files.")
},

{
    MSG_DIRECTORIES,
    TEXT("%1 bytes in %2 folders.")
},

{
    MSG_USER_FILES,
    TEXT("%1 bytes in %2 files.")
},

{
    MSG_RECOVERED_FILES,
    TEXT("%1 bytes in %2 recovered files.")
},

{
    MSG_WOULD_BE_RECOVERED_FILES,
    TEXT("%1 bytes in %2 recoverable files.")
},

{
    MSG_AVAILABLE_DISK_SPACE,
    TEXT("%1 bytes available on disk.")
},

{
    MSG_TOTAL_MEMORY,
    TEXT("%1 total bytes memory.")
},

{
    MSG_AVAILABLE_MEMORY,
    TEXT("%1 bytes free.")
},

{
    MSG_CHK_CANT_NETWORK,
    TEXT("EFI cannot check a disk attached through a network.")
},

{
    MSG_1014,
    TEXT("EFI cannot check a disk that is substituted or\nassigned using the SUBST or ASSIGN command.")
},

{
    MSG_PROBABLE_NON_DOS_DISK,
    TEXT("The specified disk appears to be a non-EFI disk.\nDo you want to continue? (Y/N) %0")
},

{
    MSG_DISK_ERROR_READING_FAT,
    TEXT("An error occurred while reading the file allocation table (FAT %1).")
},

{
    MSG_DIRECTORY,
    TEXT("Folder %1.")
},

{
    MSG_CONTIGUITY_REPORT,
    TEXT("%1 contains %2 non-contiguous blocks.")
},

{
    MSG_ALL_FILES_CONTIGUOUS,
    TEXT("All specified files are contiguous.")
},

{
    MSG_CORRECTIONS_WILL_NOT_BE_WRITTEN,
    TEXT("EFI found errors on the disk, but will not fix them\nbecause disk checking was run without the /F (fix) parameter.")
},

{
    MSG_BAD_FAT_DRIVE,
    TEXT("The file allocation table (FAT) on disk %1 is corrupted.")
},

{
    MSG_BAD_FIRST_UNIT,
    TEXT("%1  first allocation unit is not valid. The entry will be truncated.")
},

{
    MSG_CHK_DONE_CHECKING,
    TEXT("File and folder verification is complete.")
},

{
    MSG_DISK_TOO_LARGE_TO_CONVERT,
    TEXT("The volume is too large to convert.")
},
{
    MSG_CONV_NTFS_CHKDSK,
    TEXT("The volume may have inconsistencies. Run Chkdsk, the disk checking utility.")
},

{
    MSG_1028,
    TEXT("An allocation error occurred. The file size will be adjusted.")
},

{
    MSG_1029,
    TEXT("Cannot recover .. entry, processing continued.")
},

{
    MSG_1030,
    TEXT("Folder is totally empty, no . or ..")
},

{
    MSG_1031,
    TEXT("Folder is joined.")
},

{
    MSG_1032,
    TEXT("Cannot recover .. entry.")
},

{
    MSG_BAD_LINK,
    TEXT("The %1 entry contains a nonvalid link.")
},

{
    MSG_BAD_ATTRIBUTE,
    TEXT("EFI has found an entry that contains a nonvalid attribute.")
},

{
    MSG_BAD_FILE_SIZE,
    TEXT("The size of the %1 entry is not valid.")
},

{
    MSG_CROSS_LINK,
    TEXT("%1 is cross-linked on allocation unit %2.")
}
,
{
    MSG_1037,
    TEXT("EFI cannot find the %1 folder.\nDisk check cannot continue past this point in the folder structure.")
},

{
    MSG_1038,
    TEXT("The folder structure past this point cannot be processed.")
},

{
    MSG_BYTES_FREED,
    TEXT("%1 bytes of free disk space added.")
},

{
    MSG_BYTES_WOULD_BE_FREED,
    TEXT("%1 bytes of free disk space would be added.")
},

{
    // date is !!not!! displayed for EFI, since timeinfo is not implemented.
    MSG_VOLUME_LABEL_AND_DATE,
    TEXT("Volume label %1")
},

{
    MSG_TOTAL_ALLOCATION_UNITS,
    TEXT("%1 total allocation units on disk.")
},

{
    MSG_BYTES_PER_ALLOCATION_UNIT,
    TEXT("%1 bytes in each allocation unit.")
},

{
    MSG_1044,
    TEXT("Disk checking is not available on disk %1.")
},

{
    MSG_1045,
    TEXT("A nonvalid parameter was specified.")
},

{
    MSG_PATH_NOT_FOUND,
    TEXT("The specified path was not found.")
},

{
    MSG_FILE_NOT_FOUND,
    TEXT("The %1 file was not found.")
},

{
    MSG_LOST_CHAINS,
    TEXT("%1 lost allocation units were found in %2 chains.")
},

{
    MSG_BLANK_LINE,
    TEXT("")
},

{
    MSG_1050,
    TEXT("The CHDIR command cannot switch to the root folder.")
},

{
    MSG_BAD_FAT_WRITE,
    TEXT("A disk error occurred during writing of the file allocation table.")
},

{
    MSG_ONE_STRING,
    TEXT("%1.")
},

{
    MSG_ONE_STRING_NEWLINE,
    TEXT("%1")
},

{
    MSG_NO_ROOM_IN_ROOT,
    TEXT("The root folder on this volume is full. To perform a disk check,\nEFI requires space in the root folder. Remove some files\nfrom this folder, then run disk checking again.")
},

{
    MSG_1056,
    TEXT("%1 %2 %3.")
},

{
    MSG_1057,
    TEXT("%1 %2, %3.")
},

{
    MSG_1058,
    TEXT("%1%2%3%4%5.")
},

{
    MSG_1059,
    TEXT("%1%2%3%4.")
},

{
    MSG_UNITS_ON_DISK,
    TEXT("%1 available allocation units on disk.")
},

{
    MSG_1061,
    TEXT("EFI disk checking cannot fix errors (/F) when run from an\nMS-DOS window. Try again from the EFI shell or command prompt.")
},

{
    MSG_CHK_NO_MEMORY,
    TEXT("An unspecified error occurred.")
},

{
    MSG_HIDDEN_STATUS,
    TEXT("This never gets printed.")
},

{
    MSG_CHK_USAGE_HEADER,
    TEXT("Checks a disk and displays a status report.")
},

{
    MSG_CHK_COMMAND_LINE,
    TEXT("EFICHK [/F] [/R] volume")
},

{
    MSG_CHK_DRIVE,
    TEXT("  volume          Specifies the EFI volume without a colon. Example: fs0")
},

{
    MSG_CHK_USG_FILENAME,
    TEXT("filename        FAT only: Specifies the files to check for fragmentation.")
},

{
    MSG_CHK_F_SWITCH,
    TEXT("  /F              Fixes errors on the disk.")
},

{
    MSG_CHK_V_SWITCH,
    TEXT(
"  /R              Locates bad sectors and recovers readable information\n\
                  (implies /F)."
        )
},

{
    MSG_WITHOUT_PARAMETERS,
    TEXT("To check the current disk, type CHKDSK with no parameters.")
},

{
    MSG_CHK_CANT_CDROM,
    TEXT("EFI cannot run disk checking on CD-ROM and DVD-ROM drives.")
},

{
    MSG_CHK_RUNNING,
    TEXT("Checking file system on %1")
},

{
    MSG_CHK_VOLUME_CLEAN,
    TEXT("The volume is clean.")
},

{
    MSG_CHK_TRAILING_DIRENTS,
    TEXT("Removing trailing folder entries from %1")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS,
    TEXT("EFI replaced bad clusters in file %1\nof name %2.")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE,
    TEXT("The disk does not have enough space to replace bad clusters\ndetected in file %1 of name %2.")
},

{
    MSG_CHK_RECOVERING_FREE_SPACE,
    TEXT("EFI is verifying free space...")
},

{
    MSG_CHK_DONE_RECOVERING_FREE_SPACE,
    TEXT("Free space verification is complete.")
},

{
    MSG_CHK_CHECKING_FILES,
    TEXT("EFI is verifying files and folders...")
},

{
    MSG_CHK_CANNOT_UPGRADE_DOWNGRADE_FAT,
    TEXT("EFI cannot upgrade this FAT volume.")
},

{
    MSG_CHK_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The specified volume name does not have a mount point or drive letter.")
},

{
    MSG_CHK_VOLUME_IS_DIRTY,
    TEXT("The volume is dirty.")
},

{
    MSG_CHK_ON_REBOOT,
    TEXT("Do you want to schedule EFI to check your disk the next time\nyou start your computer? (Y/N) %0")
},

{
    MSG_CHK_VOLUME_SET_DIRTY,
    TEXT("EFI will check your disk the next time you start\nyour computer.")
},

{
    MSG_CHK_BOOT_PARTITION_REBOOT,
    TEXT("EFI has finished checking your disk.\nPlease wait while your computer restarts.")
},

{
    MSG_CHK_BAD_LONG_NAME,
    TEXT("Removing nonvalid long folder entry from %1...")
},

{
    MSG_CHK_CHECKING_VOLUME,
    TEXT("Now checking %1...")
},

{
    MSG_CHK_BAD_LONG_NAME_IS,
    TEXT("Removing orphaned long folder entry %1...")
},

{
    MSG_CHK_WONT_ZERO_LOGFILE,
    TEXT("The log file size must be greater than 0.")
},

{
    MSG_CHK_LOGFILE_NOT_NTFS,
    TEXT("EFI can set log file size on NTFS volumes only.")
},

{
    MSG_CHK_BAD_DRIVE_PATH_FILENAME,
    TEXT("The drive, the path, or the file name is not valid.")
},

{
    MSG_KILOBYTES_IN_USER_FILES,
    TEXT("%1 KB in %2 files.")
},

{
    MSG_KILOBYTES_IN_DIRECTORIES,
    TEXT("%1 KB in %2 folders.")
},

{
    MSG_KILOBYTES_IN_HIDDEN_FILES,
    TEXT("%1 KB in %2 hidden files.")
},

{
    MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES,
    TEXT("%1 KB in %2 recoverable files.")
},

{
    MSG_KILOBYTES_IN_RECOVERED_FILES,
    TEXT("%1 KB in %2 recovered files.")
},

{
    MSG_CHK_ABORT_AUTOCHK,
    TEXT("To skip disk checking, press any key within %1 seconds. %r%0")
},

{
    MSG_CHK_AUTOCHK_ABORTED,
    TEXT("Disk checking has been cancelled.                       %b")
},

{
    MSG_CHK_AUTOCHK_RESUMED,
    TEXT("EFI will now check the disk.                        %b")
},

{
    MSG_KILOBYTES_FREED,
    TEXT("%1 KB of free disk space added.")
},

{
    MSG_KILOBYTES_WOULD_BE_FREED,
    TEXT("%1 KB of free disk space would be added.")
},

{
    MSG_CHK_SKIP_INDEX_NOT_NTFS,
    TEXT("The /I option functions only on NTFS volumes.")
},

{
    MSG_CHK_SKIP_CYCLE_NOT_NTFS,
    TEXT("The /C option functions only on NTFS volumes.")
},

{
    MSG_CHK_AUTOCHK_COMPLETE,
    TEXT("EFI has finished checking the disk.")
},

{
    MSG_CHK_AUTOCHK_SKIP_WARNING,
    TEXT("One of your disks needs to be checked for consistency. You\nmay cancel the disk check, but it is strongly recommended\nthat you continue.")
},

{
    MSG_CHK_USER_AUTOCHK_SKIP_WARNING,
    TEXT("A disk check has been scheduled.")
},

{
    MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE,
    TEXT("EFI was unable to determine if the specified volume is a system volume.")
},

{
    MSG_CHK_NO_PROBLEM_FOUND,
    TEXT("EFI has checked the file system and found no problem.")
},

{
    MSG_CHK_ERRORS_FIXED,
    TEXT("EFI has made corrections to the file system.")
},

{
    MSG_CHK_NEED_F_PARAMETER,
    TEXT("EFI found problems with the file system.\nRun CHKDSK with the /F (fix) option to correct these.")
},

{
    MSG_CHK_ERRORS_NOT_FIXED,
    TEXT("EFI found problems with the file system that could not be corrected.")
},

{
    MSG_PERCENT_COMPLETE,
    TEXT("%1 percent completed.               %r%0")
},

{
    MSG_PERCENT_COMPLETE2,
    TEXT("%1 percent completed.%2             %r%0")
},

{
    MSG_FORMAT_COMPLETE,
    TEXT("Format complete.                        %b")
},

{
    MSG_INSERT_DISK,
    TEXT("Insert new disk for drive %1")
},

{
    MSG_REINSERT_DISKETTE,
    TEXT("Reinsert disk for drive %1:")
},

{
    MSG_BAD_IOCTL,
    TEXT("Error in IOCTL call.")
},

{
    MSG_CANT_DASD,
    TEXT("Cannot open volume for direct access.")
},

{
    MSG_CANT_WRITE_FAT,
    TEXT("Error writing File Allocation Table (FAT).")
},

{
    MSG_CANT_WRITE_ROOT_DIR,
    TEXT("Error writing folder.")
},

{
    MSG_FORMAT_NO_NETWORK,
    TEXT("Cannot format a network drive.")
},

{
    MSG_UNSUPPORTED_PARAMETER,
    TEXT("Parameters not supported.")
},

{
    MSG_UNUSABLE_DISK,
    TEXT("Invalid media or Track 0 bad - disk unusable.")
},

{
    MSG_BAD_DIR_READ,
    TEXT("Error reading folder %1.")
},

{
    MSG_PRESS_ENTER_WHEN_READY,
    TEXT("and press ENTER when ready... %0")
},

{
    MSG_ENTER_CURRENT_LABEL,
    TEXT("Enter current volume label for drive %1 %0")
},

{
    MSG_INCOMPATIBLE_PARAMETERS_FOR_FIXED,
    TEXT("Parameters incompatible with fixed disk.")
},

{
    MSG_READ_PARTITION_TABLE,
    TEXT("Error reading partition table.")
},

{
    MSG_NOT_SUPPORTED_BY_DRIVE,
    TEXT("Parameters not supported by drive.")
},

{
    MSG_2029,
    TEXT("\n")
},

{
    MSG_2030,
    TEXT("\n")
},

{
    MSG_INSERT_DOS_DISK,
    TEXT("Insert EFI disk in drive %1:")
},

{
    MSG_WARNING_FORMAT,
    TEXT("WARNING, ALL DATA ON EFI DEVICE\n%1 WILL BE LOST!\nProceed with Format (Y/N)? %0")
},

{
    MSG_FORMAT_ANOTHER,
    TEXT("Format another (Y/N)? %0")
},

{
    MSG_WRITE_PARTITION_TABLE,
    TEXT("Error writing partition table.")
},

{
    MSG_INCOMPATIBLE_PARAMETERS,
    TEXT("Parameters not compatible.")
},

{
    MSG_AVAILABLE_ALLOCATION_UNITS,
    TEXT("%1 allocation units available on disk.")
},

{
    MSG_ALLOCATION_UNIT_SIZE,
    TEXT("%1 bytes in each allocation unit.")
},

{
    MSG_PARAMETER_TWICE,
    TEXT("Same parameter entered twice.")
},

{
    MSG_NEED_BOTH_T_AND_N,
    TEXT("Must enter both /t and /n parameters.")
},

{
    MSG_2042,
    TEXT("Trying to recover allocation unit %1.                          %0")
},

{
    MSG_NO_LABEL_WITH_8,
    TEXT("Volume label is not supported with /8 parameter.")
},

{
    MSG_FMT_NO_MEMORY,
    TEXT("Insufficient memory.")
},

{
    MSG_QUICKFMT_ANOTHER,
    TEXT("QuickFormat another (Y/N)? %0")
},

{
    MSG_CANT_QUICKFMT,
    TEXT("Invalid existing format.\nThis disk cannot be QuickFormatted.\nProceed with unconditional format (Y/N)? %0")
},

{
    MSG_FORMATTING_KB,
    TEXT("Formatting %1K")
},

{
    MSG_FORMATTING_MB,
    TEXT("Formatting %1M")
},

{
    MSG_FORMATTING_DOT_MB,
    TEXT("Formatting %1.%2M")
},

{
    MSG_VERIFYING_KB,
    TEXT("Verifying %1K")
},

{
    MSG_VERIFYING_MB,
    TEXT("Verifying %1M")
},

{
    MSG_VERIFYING_DOT_MB,
    TEXT("Verifying %1.%2M")
},

{
    MSG_2060,
    TEXT("Saving UNFORMAT information.")
},

{
    MSG_2061,
    TEXT("Checking existing disk format.")
},

{
    MSG_QUICKFORMATTING_KB,
    TEXT("QuickFormatting %1K")
},

{
    MSG_QUICKFORMATTING_MB,
    TEXT("QuickFormatting %1M")
},

{
    MSG_QUICKFORMATTING_DOT_MB,
    TEXT("QuickFormatting %1.%2M")
},

{
    MSG_FORMAT_INFO,
    TEXT("Formats a disk for use with EFI.\n")
},

{
    MSG_FORMAT_COMMAND_LINE_1,
    TEXT("EFIFMT device [/FS:file-system] [/V:label] [/Q] [/A:size]\n")
},

{
    MSG_FORMAT_COMMAND_LINE_2,
    TEXT("  device          Specifies the EFI device to format without a colon. Example: blk0")
},

{
    MSG_FORMAT_COMMAND_LINE_3,
    TEXT("")
},

{
    MSG_FORMAT_COMMAND_LINE_4,
     TEXT("  /FS:filesystem  Specifies the type of the file system (FAT, FAT32).")
},

{
    MSG_FORMAT_SLASH_V,
    TEXT("  /V:label        Specifies the volume label.")
},

{
    MSG_FORMAT_SLASH_Q,
    TEXT("  /Q              Performs a quick format.")
},

{
    MSG_FORMAT_SLASH_C,
    TEXT("")
},

{
    MSG_FORMAT_SLASH_F,
TEXT(
"  /A:size         Overrides the default allocation unit size. Default settings\n\
                  are STRONGLY recommended for general use.\n"
    )
},

{
    MSG_FORMAT_SUPPORTED_SIZES,
TEXT(
"                  FAT supports 512, 1024, 2048, 4096, 8192, 16K, 32K\n\
                  FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K\n\
\n\
                  Note that the FAT and FAT32 files systems impose the\n\
                  following restrictions on the number of clusters on a volume:\n\
\n\
                  FAT: Number of clusters <= 65526\n\
                  FAT32: 65526 < Number of clusters < 268435446\n\
\n\
                  Format will stop processing if it decides that\n\
                  the above requirements cannot be met using the specified\n\
                  cluster size."
    )
},

{
    MSG_WRONG_CURRENT_LABEL,
    TEXT("An incorrect volume label was entered for this drive.")
},

{
    MSG_FORMAT_SLASH_T,
    TEXT("/T:tracks       Specifies the number of tracks per disk side.")
},

{
    MSG_FORMAT_SLASH_N,
    TEXT("/N:sectors      Specifies the number of sectors per track.")
},

{
    MSG_FORMAT_SLASH_1,
    TEXT("/1              Formats a single side of a floppy disk.")
},

{
    MSG_FORMAT_SLASH_4,
    TEXT(
"/4              Formats a 5.25-inch 360K floppy disk in a \n\
                high-density drive."
    )
},

{
    MSG_FORMAT_SLASH_8,
    TEXT("/8              Formats eight sectors per track.")
},

{
    MSG_FORMAT_SLASH_X,
    TEXT(
"/X              Forces the volume to dismount first if necessary.  All opened\n\
                handles to the volume would no longer be valid.")
},

{
    MSG_FORMAT_NO_CDROM,
    TEXT("Cannot format a CD-ROM drive.")
},

{
    MSG_FORMAT_NO_RAMDISK,
    TEXT("Cannot format a RAM DISK drive.")
},

{
    MSG_FORMAT_PLEASE_USE_FS_SWITCH,
    TEXT("Please use the /FS switch to specify the file system\nyou wish to use on this volume.")
},

{
    MSG_NTFS_FORMAT_FAILED,
    TEXT("Format failed.")
},

{
    MSG_FMT_WRITE_PROTECTED_MEDIA,
    TEXT("Cannot format.  This media is write protected.")
},

{
    MSG_FMT_INSTALL_FILE_SYSTEM,
    TEXT("WARNING!  The %1 file system is not enabled.\nWould you like to enable it (Y/N)? %0")
},

{
    MSG_FMT_FILE_SYSTEM_INSTALLED,
    TEXT("The file system will be enabled when you restart the system.")
},

{
    MSG_FMT_CANT_INSTALL_FILE_SYSTEM,
    TEXT("FORMAT cannot enable the file system.")
},

{
    MSG_FMT_VOLUME_TOO_SMALL,
    TEXT("The volume is too small for the specified file system.")
},

{
    MSG_FMT_CREATING_FILE_SYSTEM,
    TEXT("Creating file system structures.")
},

{
    MSG_FMT_VARIABLE_CLUSTERS_NOT_SUPPORTED,
    TEXT("%1 FORMAT does not support user selected allocation unit sizes.")
},

{
    MSG_DEVICE_BUSY,
    TEXT("The device is busy.")
},

{
    MSG_FMT_DMF_NOT_SUPPORTED_ON_288_DRIVES,
    TEXT("The specified format cannot be mastered on 2.88MB drives.")
},

{
    MSG_HPFS_NO_FORMAT,
    TEXT("FORMAT does not support the HPFS file system type.")
},

{
    MSG_FMT_ALLOCATION_SIZE_CHANGED,
    TEXT("Allocation unit size changed to %1 bytes.")
},

{
    MSG_FMT_ALLOCATION_SIZE_EXCEEDED,
    TEXT("Allocation unit size must be less than or equal to 64K.")
},

{
    MSG_FMT_TOO_MANY_CLUSTERS,
    TEXT("Number of clusters exceeds 32 bits.")
},

{
    MSG_CONV_PAUSE_BEFORE_REBOOT,
    TEXT("Preinstallation completed successfully.  Press any key to\nshut down/reboot.")
},

{
    MSG_CONV_WILL_REBOOT,
    TEXT("Convert will take some time to process the files on the volume.\nWhen this phase of conversion is complete, the computer will restart.")
},

{
    MSG_FMT_FAT_ENTRY_SIZE,
    TEXT("           %1 bits in each FAT entry.")
},

{
    MSG_FMT_CLUSTER_SIZE_MISMATCH,
    TEXT(
"The cluster size chosen by the system is %1 bytes which\ndiffers from the specified cluster size.\n\
Proceed with Format using the cluster size chosen by the\n\
system (Y/N)? %0"
    )
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_SMALL,
    TEXT("The specified cluster size is too small for %1.")
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_BIG,
    TEXT("The specified cluster size is too big for %1.")
},

{
    MSG_FMT_VOL_TOO_BIG,
    TEXT("The volume is too big for %1.")
},

{
    MSG_FMT_VOL_TOO_SMALL,
    TEXT("The volume is too small for %1.")
},

{
    MSG_FMT_ROOTDIR_WRITE_FAILED,
    TEXT("Failed to write to the root folder.")
},

{
    MSG_FMT_INIT_LABEL_FAILED,
    TEXT("Failed to initialize the volume label.")
},

{
    MSG_FMT_INITIALIZING_FATS,
    TEXT("Initializing the File Allocation Table (FAT)...")
},

{
    MSG_FMT_CLUSTER_SIZE_64K,
    TEXT(
"The cluster size for this volume, 64K bytes, may cause application\n\
compatibility problems, particularly with setup applications.\n\
The volume must be less than 2048 MB in size to change this if the\n\
default cluster size is being used.\n\
Proceed with Format using a 64K cluster (Y/N)? %0"
    )
},

{
    MSG_FMT_SECTORS,
    TEXT("Set number of sectors on drive to %1.")
},

{
    MSG_FMT_BAD_SECTORS,
    TEXT("Environmental variable FORMAT_SECTORS error.")
},

{
    MSG_FMT_FORCE_DISMOUNT_PROMPT,
    TEXT(
"Format cannot run because the volume is in use by another\n\
process.  Format may run if this volume is dismounted first.\n\
ALL OPENED HANDLES TO THIS VOLUME WOULD THEN BE INVALID.\n\
Would you like to force a dismount on this volume? (Y/N) %0"
    )
},

{
    MSG_FORMAT_NO_MEDIA_IN_DRIVE,
    TEXT("There is no media in the drive.")
},

{
    MSG_FMT_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The given volume name does not have a mount point or drive letter.")
},

{
    MSG_FMT_INVALID_DRIVE_SPEC,
    TEXT("Invalid drive specification.")
},

{
    MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The given volume name does not have a mount point or drive letter.")
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN,
    TEXT("The specified cluster size is too small. The minimum valid\ncluster size value for this drive is %1.")
},

{
    MSG_FMT_FAT32_NO_FLOPPIES,
    TEXT("Floppy disk is too small to hold the FAT32 file system.")
},

{
    MSG_CANT_LOCK_THE_DRIVE,
    TEXT("Cannot lock the drive.  The volume is still in use.")
},

{
    MSG_CANT_READ_BOOT_SECTOR,
    TEXT("Cannot read boot sector.")
},

{
    MSG_VOLUME_SERIAL_NUMBER,
    TEXT("Volume Serial Number is %1-%2")
},

{
    MSG_VOLUME_LABEL_PROMPT,
    TEXT("Volume label (11 characters, ENTER for none)? %0")
},

{
    MSG_INVALID_LABEL_CHARACTERS,
    TEXT("Invalid characters in volume label")
},

{
    MSG_CANT_READ_ANY_FAT,
    TEXT("There are no readable file allocation tables (FAT).")
},

{
    MSG_SOME_FATS_UNREADABLE,
    TEXT("Some file allocation tables (FAT) are unreadable.")
},

{
    MSG_CANT_WRITE_BOOT_SECTOR,
    TEXT("Cannot write boot sector.")
},

{
    MSG_SOME_FATS_UNWRITABLE,
    TEXT("Some file allocation tables (FAT) are unwriteable.")
},

{
    MSG_INSUFFICIENT_DISK_SPACE,
    TEXT("Insufficient disk space.")
},

{
    MSG_TOTAL_KILOBYTES,
    TEXT("%1 KB total disk space.")
},

{
    MSG_AVAILABLE_KILOBYTES,
    TEXT("%1 KB are available.")
},

{
    MSG_NOT_FAT,
    TEXT("Disk not formatted or not FAT.")
},

{
    MSG_REQUIRED_PARAMETER,
    TEXT("Required parameter missing -")
},

{
    MSG_FILE_SYSTEM_TYPE,
    TEXT("The type of the file system is %1.")
},

{
    MSG_NEW_FILE_SYSTEM_TYPE,
    TEXT("The new file system is %1.")
},

{
    MSG_FMT_AN_ERROR_OCCURRED,
    TEXT("An error occurred while running Format.")
},

{
    MSG_FS_NOT_SUPPORTED,
    TEXT("%1 is not available for %2 drives.")
},

{
    MSG_FS_NOT_DETERMINED,
    TEXT("Cannot determine file system of drive %1.")
},

{
    MSG_CANT_DISMOUNT,
    TEXT("Cannot dismount the drive.")
},

{
    MSG_NOT_FULL_PATH_NAME,
    TEXT("%1 is not a complete name.")
},

{
    MSG_YES,
    TEXT("Yes")
},

{
    MSG_NO,
    TEXT("No")
},

{
    MSG_DISK_NOT_FORMATTED,
    TEXT("Disk is not formatted.")
},

{
    MSG_NONEXISTENT_DRIVE,
    TEXT("Specified drive does not exist.")
},

{
    MSG_INVALID_PARAMETER,
    TEXT("Invalid parameter - %1")
},

{
    MSG_INSUFFICIENT_MEMORY,
    TEXT("Out of memory.")
},

{
    MSG_ACCESS_DENIED,
    TEXT("Access denied - %1")
},

{
    MSG_DASD_ACCESS_DENIED,
    TEXT("Access denied.")
},

{
    MSG_CANT_LOCK_CURRENT_DRIVE,
    TEXT("Cannot lock current drive.")
},

{
    MSG_INVALID_LABEL,
    TEXT("Invalid volume label")
},

{
    MSG_DISK_TOO_LARGE_TO_FORMAT,
    TEXT("The disk is too large to format for the specified file system.")
},

{
    MSG_VOLUME_LABEL_NO_MAX,
    TEXT("Volume label (ENTER for none)? %0")
},

{
    MSG_CHKDSK_ON_REBOOT_PROMPT,
    TEXT("Chkdsk cannot run because the volume is in use by another\nprocess.  Would you like to schedule this volume to be\nchecked the next time the system restarts? (Y/N) %0")
},

{
    MSG_CHKDSK_CANNOT_SCHEDULE,
    TEXT("Chkdsk could not schedule this volume to be checked\nthe next time the system restarts.")
},

{
    MSG_CHKDSK_SCHEDULED,
    TEXT("This volume will be checked the next time the system restarts.")
},

{
    MSG_COMPRESSION_NOT_AVAILABLE,
    TEXT("Compression is not available for %1.")
},

{
    MSG_CANNOT_ENABLE_COMPRESSION,
    TEXT("Cannot enable compression for the volume.")
},

{
    MSG_CANNOT_COMPRESS_HUGE_CLUSTERS,
    TEXT("Compression is not supported on volumes with clusters larger than\n4096 bytes.")
},

{
    MSG_CANT_UNLOCK_THE_DRIVE,
    TEXT("Cannot unlock the drive.")
},

{
    MSG_CHKDSK_FORCE_DISMOUNT_PROMPT,
TEXT("Chkdsk cannot run because the volume is in use by another\n\
process.  Chkdsk may run if this volume is dismounted first.\n\
ALL OPENED HANDLES TO THIS VOLUME WOULD THEN BE INVALID.\n\
Would you like to force a dismount on this volume? (Y/N) %0")
},

{
    MSG_VOLUME_DISMOUNTED,
    TEXT("Volume dismounted.  All opened handles to this volume are now invalid.")
},

{
    MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT,
TEXT("Chkdsk cannot dismount the volume because it is a system drive or\n\
there is an active paging file on it.  Would you like to schedule\n\
this volume to be checked the next time the system restarts? (Y/N) %0")
},

{
    MSG_TOTAL_MEGABYTES,
    TEXT("%1 MB total disk space.")
},

{
    MSG_AVAILABLE_MEGABYTES,
    TEXT("%1 MB are available.")
},

{
    MSG_CHK_ERRORS_IN_FAT,
    TEXT("Errors in file allocation table (FAT) corrected.")
},

{
    MSG_CHK_EAFILE_HAS_HANDLE,
    TEXT("Extended attribute file has handle.  Handle removed.")
},

{
    MSG_CHK_EMPTY_EA_FILE,
    TEXT("Extended attribute file contains no extended attributes.  File deleted.")
},

{
    MSG_CHK_ERASING_INVALID_LABEL,
    TEXT("Erasing invalid label.")
},

{
    MSG_CHK_EA_SIZE,
    TEXT("%1 bytes in extended attributes.")
},

{
    MSG_CHK_CANT_CHECK_EA_LOG,
    TEXT("Unreadable extended attribute header.\nCannot check extended attribute log.")
},

{
    MSG_CHK_BAD_LOG,
    TEXT("Extended attribute log is unintelligible.\nIgnore log and continue? (Y/N) %0")
},

{
    MSG_CHK_UNUSED_EA_PORTION,
    TEXT("Unused, unreadable, or unwriteable portion of extended attribute file removed.")
},

{
    MSG_CHK_EASET_SIZE,
    TEXT("Total size entry for extended attribute set at cluster %1 corrected.")
},

{
    MSG_CHK_EASET_NEED_COUNT,
    TEXT("Need count entry for extended attribute set at cluster %1 corrected.")
},

{
    MSG_CHK_UNORDERED_EA_SETS,
    TEXT("Extended attribute file is unsorted.\nSorting extended attribute file.")
},

{
    MSG_CHK_NEED_MORE_HEADER_SPACE,
    TEXT("Insufficient space in extended attribute file for its header.\nAttempting to allocate more disk space.")
},

{
    MSG_CHK_INSUFFICIENT_DISK_SPACE,
    TEXT("Insufficient disk space to correct disk error.\nPlease free some disk space and run CHKDSK again.")
},

{
    MSG_CHK_RELOCATED_EA_HEADER,
    TEXT("Bad clusters in extended attribute file header relocated.")
},

{
    MSG_CHK_ERROR_IN_EA_HEADER,
    TEXT("Errors in extended attribute file header corrected.")
},

{
    MSG_CHK_MORE_THAN_ONE_DOT,
    TEXT("More than one dot entry in folder %1.  Entry removed.")
},

{
    MSG_CHK_DOT_IN_ROOT,
    TEXT("Dot entry found in root folder.  Entry removed.")
},

{
    MSG_CHK_DOTDOT_IN_ROOT,
    TEXT("Dot-dot entry found in root folder.  Entry removed.")
},

{
    MSG_CHK_ERR_IN_DOT,
    TEXT("Dot entry in folder %1 has incorrect link.  Link corrected.")
},

{
    MSG_CHK_ERR_IN_DOTDOT,
    TEXT("Dot-dot entry in folder %1 has incorrect link.  Link corrected.")
},

{
    MSG_CHK_DELETE_REPEATED_ENTRY,
    TEXT("More than one %1 entry in folder %2.  Entry removed.")
},

{
    MSG_CHK_CYCLE_IN_TREE,
    TEXT("Folder %1 causes cycle in folder structure.\nFolder entry removed.")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_DIR,
    TEXT("Folder %1 has bad clusters.\nBad clusters removed from folder.")
},

{
    MSG_CHK_BAD_DIR,
    TEXT("Folder %1 is entirely unreadable.\nFolder entry removed.")
},

{
    MSG_CHK_FILENAME,
    TEXT("%1")
},

{
    MSG_CHK_DIR_TRUNC,
    TEXT("Folder truncated.")
},

{
    MSG_CHK_CROSS_LINK_COPY,
    TEXT("Cross link resolved by copying.")
},

{
    MSG_CHK_CROSS_LINK_TRUNC,
    TEXT("Insufficient disk space to copy cross-linked portion.\nFile being truncated.")
},

{
    MSG_CHK_INVALID_NAME,
    TEXT("%1  Invalid name.  Folder entry removed.")
},

{
    MSG_CHK_INVALID_TIME_STAMP,
    TEXT("%1  Invalid time stamp.")
},

{
    MSG_CHK_DIR_HAS_FILESIZE,
    TEXT("%1  Folder has non-zero file size.")
},

{
    MSG_CHK_UNRECOG_EA_HANDLE,
    TEXT("%1  Unrecognized extended attribute handle.")
},

{
    MSG_CHK_SHARED_EA,
    TEXT("%1  Has handle extended attribute set belonging to another file.\nHandle removed.")
},

{
    MSG_CHK_UNUSED_EA_SET,
    TEXT("Unused extended attribute set with handle %1 deleted from\nextended attribute file.")
},

{
    MSG_CHK_NEW_OWNER_NAME,
    TEXT("Extended attribute set with handle %1 owner changed\nfrom %2 to %3.")
},

{
    MSG_CHK_BAD_LINKS_IN_ORPHANS,
    TEXT("Bad links in lost chain at cluster %1 corrected.")
},

{
    MSG_CHK_CROSS_LINKED_ORPHAN,
    TEXT("Lost chain cross-linked at cluster %1.  Orphan truncated.")
},

{
    MSG_ORPHAN_DISK_SPACE,
    TEXT("Insufficient disk space to recover lost data.")
},

{
    MSG_TOO_MANY_ORPHANS,
    TEXT("Insufficient disk space to recover lost data.")
},

{
    MSG_CHK_ERROR_IN_LOG,
    TEXT("Error in extended attribute log.")
},

{
    MSG_CHK_ERRORS_IN_DIR_CORR,
    TEXT("%1 Errors in . and/or .. corrected.")
},

{
    MSG_CHK_RENAMING_FAILURE,
    TEXT("More than one %1 entry in folder %2.\nRenamed to %3 but still could not resolve the name conflict.")
},

{
    MSG_CHK_RENAMED_REPEATED_ENTRY,
    TEXT("More than one %1 entry in folder %2.\nRenamed to %3.")
},

{
    MSG_CHK_UNHANDLED_INVALID_NAME,
    TEXT("%1 may be an invalid name in folder %2.")
},

{
    MSG_CHK_INVALID_NAME_CORRECTED,
    TEXT("Corrected name %1 in folder %2.")
},

{
    MSG_RECOV_BYTES_RECOVERED,
    TEXT("\n%1 of %2 bytes recovered.")
},

{
    MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB,
    TEXT("%1 KB in bad sectors.")
},

{
    MSG_CHK_NTFS_CORRECTING_ERROR_IN_DIRECTORY,
    TEXT("Correcting error in directory %1")
},

{
    MSG_UTILS_HELP,
    TEXT("There is no help for this utility.")
},

{
    MSG_UTILS_ERROR_FATAL,
    TEXT("Critical error encountered.")
},

{
    MSG_UTILS_ERROR_INVALID_VERSION,
    TEXT("Incorrect EFI version")
},

{
    MSG_BOOT_FAT_NTLDR_MISSING,
    TEXT("NTLDR is missing%0")
},

{
    MSG_BOOT_FAT_IO_ERROR,
    TEXT("Disk error%0")
},

{
    MSG_BOOT_FAT_PRESS_KEY,
    TEXT("Press any key to restart%0")
},

{
    MSG_BOOT_NTFS_NTLDR_MISSING,
    TEXT("NTLDR is missing%0")
},

{
    MSG_BOOT_NTFS_NTLDR_COMPRESSED,
    TEXT("NTLDR is compressed%0")
},

{
    MSG_BOOT_NTFS_IO_ERROR,
    TEXT("A disk read error occurred%0")
},

{
    MSG_BOOT_NTFS_PRESS_KEY,
    TEXT("Press Ctrl+Alt+Del to restart%0")
},

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efilib\efisrc\efickmsg.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efickmsg.cxx

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "efiwintypes.hxx"
#include "efickmsg.hxx"
#include "rtmsg.h"

DEFINE_CONSTRUCTOR(EFICHECK_MESSAGE, MESSAGE);


EFICHECK_MESSAGE::~EFICHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for EFICHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
EFICHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
EFICHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
EFICHECK_MESSAGE::Initialize(
    IN BOOLEAN  DotsOnly
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - efichk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _dots_only = DotsOnly;
    return MESSAGE::Initialize();
}


BOOLEAN
EFICHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;
    PWSTR           dis_str;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {

        return FALSE;
    }

   if (!(dis_str = display_string.QueryWSTR())) {

        return FALSE;
    }

    if(MSG_HIDDEN_STATUS != GetMessageId()) {

        Print(dis_str);
    }


    DELETE(dis_str);

    return TRUE;
}

BOOLEAN
EFICHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR16           input_buf[3];
    BOOLEAN          retvalue;

    while(1) {
        Input(TEXT(""), (CHAR16*)&input_buf, 2);

        if(input_buf[0] == L'Y' || input_buf[0] == L'y') {
            retvalue = TRUE;
            break;
        } else if(input_buf[0] == L'N' || input_buf[0] == L'n') {
            retvalue = FALSE;
            break;
        }
    }
    Print(TEXT("\n"));
    return retvalue;
    //return Default;
}


PMESSAGE
EFICHECK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PEFICHECK_MESSAGE  p;

    if (!(p = NEW EFICHECK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize()) {
        DELETE(p);
        return NULL;
    }

    return p;
}

BOOLEAN
EFICHECK_MESSAGE::SetDotsOnly(
    IN  BOOLEAN         DotsOnlyState
    )
/*++

Routine Description:

    This routine modifies the output mode, changing whether full
    output is printed, or just dots.

Arguments:

    DotsOnlyState   - TRUE if only dots should be printed.

Return Value:

    The previous state.

--*/
{
    return FALSE;
}

BOOLEAN
EFICHECK_MESSAGE::IsInAutoChk(
    )
/*++

Routine Description:

    This routine returns TRUE if it is in the regular efichk and not related
    to setup.  This relys on setup using the /s or /t option all the time.

Arguments:

    None.

Return Value:

    TRUE    - if in regular efichk

--*/
{
    return TRUE;
}

BOOLEAN
EFICHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
    )
/*++

Routine Description:

    Check to see if the user has hit any key within the timeout period.

Arguments:

    MsgId            - Supplies the message Id to be displayed
    TimeOutInSeconds - Supplies the count down time in seconds

Return Value:

    TRUE    - A key is pressed within the timeout period.
    FALSE   - No key has been pressed or there is an error

--*/
{
    return FALSE;
}

BOOLEAN
EFICHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    Open the keyboard directly and wait to read something.

Arguments:

    None:

Return Value:

    TRUE    - Something was successfully read.
    FALSE   - An error occured while attempting to open or read.

--*/
{
    return TRUE;
}


BOOLEAN
EFICHECK_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
{
    CHAR16 buf[80];

    Input(TEXT(""), (CHAR16 *)&buf, 79);

    DisplayMsg(MSG_BLANK_LINE);

    return String->Initialize(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efilib\efisrc\basesys.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    basesys.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "basesys.hxx"

ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#define NUMBER_OF_ARGS      20

    STATIC HANDLE   lib_handle = 0;
    PWSTR           args[NUMBER_OF_ARGS];
    WSTR            fmt[20];
    INT             i, j;
    PWSTR           p;
    PWSTRING        gstring;
    DSTRING         UnicodeFormat;
    WSTR            display_buffer[4096];
    BOOL            found;
    NTSTATUS        Status;
    ULONG           Result;

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        args[i] = NULL;
    }

    if (!UnicodeFormat.Initialize(Format)) {
        return FALSE;
    }

    // convert args into an array for RtlFormatMessage.
    i = 0;
    for (p = (PWSTR) UnicodeFormat.GetWSTR(); *p; p++) {

        // if we have a %
        if (*p == '%') {

            // perform W substitutions
            if (*(p + 1) == 'W') {

                p++;
                gstring = va_arg(VarPointer, PWSTRING);
                gstring->QueryWSTR(0, TO_END, display_buffer, 4096);

            } else {
                // convert other substutitions as appropriate by building a fmt string
                j = 0;
                // copy the %
                fmt[j++] = *p++;
                // copy the next character as long at its not a % and not NULL
                while (*p && *p != '%') {
                    if ((*p == 's') && *(p - 1) != 'w') {
                        //if its an ANSI string
                        fmt[j++] = L'a';
                        p++;
                        continue;
                    } else if ((*p == 'c') && *(p - 1) != 'w') {
                        // if its an ANSI character
                        fmt[j++] = L'c'; // BUGBUG hack for now
                        p++;
                        continue;
                    } else if ((*p == 'w' ) && *(p + 1) == 's') {
                        // if its a wide string (%ws->%s)
                        fmt[j++] = L's';
                        p++;
                        p++; // skip the second char
                        continue;
                    } else if ((*p == 'w' ) && *(p + 1) == 'c') {
                        // if its a wide char (%wc->%c)
                        fmt[j++] = L'c';
                        p++;
                        p++; // skip the second char
                        continue;
                    } else if ((*p == 'u' )) {
                        // BUGBUG sprint doesn't seem to work with %u, replace with %d
                        fmt[j++] = L'd';
                        p++;
                    } else if (isdigit(*p)) {
                        // BUGBUG: HACK we skip digit format stuff since Sprint doesn't seem to like em.
                        p++;
                    } else {
                        // otherwise just copy the format indicator
                        fmt[j++] = *p++;
                    }
                }
                p--;
                fmt[j] = 0;

                if (wcsncmp(fmt, TEXT("%I64"), 4) == 0) {
                    // if its a 64 bit integer
                    // do some special stuff to handle LARGE_INTEGERS before telling SPrint to do its thing.
                    ULONGLONG t = (va_arg(VarPointer,LARGE_INTEGER)).QuadPart;
                    fmt[0]='%';
                    fmt[1]='l';
                    fmt[2]='d';
                    fmt[3]=NULL;
//                    Print(L"QueryResourceStringV: fmt: %s\n",fmt);
                    SPrint(display_buffer, 4096, fmt, t);
                } else {
                    // otherwise tell SPrint to do its thing
                    PVOID   voidptr = va_arg(VarPointer, PVOID);
//                    Print(L"QueryResourceStringV: fmt: %s\n",fmt);
                    SPrint(display_buffer, 4096,fmt,voidptr );
                }
            }

            // allocate a buffer and copy the converted string into it.
            args[i] = (PWSTR)MALLOC(wcslen(display_buffer) * sizeof(WCHAR) + sizeof(WCHAR));
            if (NULL == args[i]) {
                return FALSE;
            }
            wcscpy( args[i], display_buffer);

//            Print(L"QueryResourceStringV: args[%d]: %s\n",i,args[i]);

            i++;
        }
    }

    found = FALSE;
    // locate the right message in our table
    for(i=0;i<EFI_MESSAGE_COUNT;i++) {
        if(MessageTable[i].msgId == MsgId ){
            found = TRUE;
            break;
        }
    }

    if (found == FALSE) {
        return FALSE;
    }

    WCHAR *MessageFormat = MessageTable[i].string;

    // shove it through RtlFormatMessage.
    Status = RtlFormatMessage( MessageFormat,
                               0,
                               FALSE,
                               FALSE,
                               TRUE,
                               (va_list *)args,
                               (PWSTR)display_buffer,
                               sizeof( display_buffer ),
                               &Result
                             );

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    return ResourceString->Initialize(display_buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efilib\efisrc\drive.cxx ===
/*++

Copyright (c) 1992-2001 Microsoft Corporation

Module Name:

    drive.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#if 0
#include "error.hxx"
#include "drive.hxx"
#include "rtmsg.h"
#include "message.hxx"
#include "numset.hxx"
#include "dcache.hxx"
#include "hmem.hxx"
#include "ifssys.hxx"
#endif

#if !defined( _EFICHECK_ )
extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
};
#endif

//#define TRAP_A_WRITE    1
//#define TRAP_A_READ     1

// Don't lock down more that 64K for IO.
CONST   MaxIoSize   = 65536;

DEFINE_CONSTRUCTOR( DRIVE, OBJECT );

VOID
DRIVE::Construct (
        )
/*++

Routine Description:

    Contructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DRIVE::~DRIVE(
    )
/*++

Routine Description:

    Destructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
DRIVE::Initialize(
    IN      PCWSTRING    NtDriveName,
    IN OUT  PMESSAGE     Message
    )
/*++

Routine Description:

    This routine initializes a drive object.

Arguments:

    NtDriveName - Supplies an NT style drive name.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!NtDriveName) {
        Destroy();
        return FALSE;
    }

    if (!_name.Initialize(NtDriveName)) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    return TRUE;
}


VOID
DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns a DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DEFINE_EXPORTED_CONSTRUCTOR( DP_DRIVE, DRIVE, IFSUTIL_EXPORT );

VOID
DP_DRIVE::Construct (
        )
/*++

Routine Description:

    Constructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_actual, 0, sizeof(DRTYPE));
    _supported_list = NULL;
    _num_supported = 0;
    _alignment_mask = 0;
    _last_status = 0;
    _handle = 0;
    _alternate_handle = 0;
    _hosted_drive = FALSE;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _block_io = NULL;
    _disk_io  = NULL;
}


IFSUTIL_EXPORT
DP_DRIVE::~DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

NTSTATUS
DP_DRIVE::OpenDrive(
    IN      PCWSTRING   NtDriveName,
    IN      ACCESS_MASK DesiredAccess,
    IN      BOOLEAN     ExclusiveWrite,
#if defined(_EFICHECK_)
    OUT     EFI_BLOCK_IO ** BlockIoPtr,
    OUT     EFI_DISK_IO  ** DiskIoPtr,
#else
    OUT     PHANDLE     Handle,
    OUT     PHANDLE     Handle,
#endif
    OUT     PULONG      Alignment,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method is a worker function for the Initialize methods,
    to open a volume and determine its alignment requirement.

Arguments:

    NtDriveName     - Supplies the name of the drive.
    DesiredAccess   - Supplies the access the client desires to the volume.
    ExclusiveWrite  - Supplies a flag indicating whether the client
                      wishes to exclude other write handles.
    Handle          - Receives the handle to the opened volume.
    Alignment       - Receives the alignment requirement for the volume.
    Message         - Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.


--*/
{
    DEBUG((D_INFO,(CHAR8*)"Entering OpenDrive.\n"));

    WSTR * origName = (WSTR*)NtDriveName->GetWSTR();
    EFI_DEVICE_PATH * devPath = NULL;
    EFI_DEVICE_PATH * devPathPos = NULL;
    EFI_DEVICE_PATH * newDevPath = NULL;
    EFI_DEVICE_PATH * nextDevPath;

    EFI_GUID blk_io_guid = BLOCK_IO_PROTOCOL;
    EFI_GUID dsk_io_guid = DISK_IO_PROTOCOL;

    EFI_HANDLE  handle = NULL;
    EFI_STATUS  status;

    // first we get the device path from the corresponding name

    DEBUG((D_INFO,(CHAR8*)"Attempting to open %s\n", origName ));

    devPath = (EFI_DEVICE_PATH*)ShellGetMap(origName);
    if( devPath == NULL ) {
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive was passed a bogus device name.\n"));
        return STATUS_INVALID_PARAMETER;
    }
    DEBUG((D_INFO,(CHAR8*)"Mapped to %s\n",DevicePathToStr(devPath)));

    // now we query to see if the device supports BLOCK_IO

    devPathPos = devPath;
    // LocateDevicePath advances the pointer
    status = BS->LocateDevicePath(
        &blk_io_guid,
        &devPathPos, // this is an IN OUT param
        &handle
        );

    if( status != EFI_SUCCESS ) {
        // we were passed a bogus drive path
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive was passed a bogus device name.\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // now we retrieve the interface pointer from the object
    BS->HandleProtocol(handle, &blk_io_guid, (VOID**)BlockIoPtr);

    BS->HandleProtocol(handle, &dsk_io_guid, (VOID**)DiskIoPtr);

    if( (*BlockIoPtr)->Media->IoAlign == 0 ) {
        // the IoAlign field can't be zero! we are always at least byte aligned.
        return STATUS_UNSUCCESSFUL;
    }
    *Alignment = (*BlockIoPtr)->Media->IoAlign - 1;
    DEBUG((D_INFO,(CHAR8*)"Io Alignment mask is %d\n", *Alignment ));

    //
    // While we are here lets get some things we will need for twiddling the
    // partition table later on.
    //

    newDevPath = DuplicateDevicePath( devPath );
    if ( !newDevPath ) {
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive failed to get MBR device.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // We have a copy of the partition device path.  Now cut that down to just the
    // device file path.
    //

    nextDevPath = newDevPath;

    while (DevicePathType(nextDevPath) != MEDIA_DEVICE_PATH &&
           DevicePathType(nextDevPath) != END_DEVICE_PATH_TYPE) {
        DEBUG((D_INFO,(CHAR8*)"NextDevPath: %d,%d,%d,%s\n",
                 nextDevPath->Type,
                 nextDevPath->SubType,
                 *(USHORT*)nextDevPath->Length,
                 DevicePathToStr(nextDevPath)));
        nextDevPath = NextDevicePathNode( nextDevPath );
    }

    DEBUG((D_INFO,(CHAR8*)"Final nextDevPath: %d,%d,%d\n",
             nextDevPath->Type,
             nextDevPath->SubType,
             *(USHORT*)nextDevPath->Length));

    if (DevicePathType(nextDevPath) != END_DEVICE_PATH_TYPE) {

        //
        // Get the partition number before we destroy this
        //

        _partition_number = ( ( HARDDRIVE_DEVICE_PATH * ) nextDevPath ) -> PartitionNumber;

        DEBUG((D_INFO,(CHAR8*)"Partition Number %d\n", _partition_number));

        SetDevicePathEndNode( nextDevPath );

    } else {
        DEBUG((D_INFO,(CHAR8*)"There is no partition\n"));
        _partition_number = 0;
    }

    //
    // Get the BLOCK_IO_PROTOCOL for the base disk device
    //

    devPathPos = newDevPath;            // LocateDevicePath advances the pointer

    status = BS->LocateDevicePath(
        &blk_io_guid,
        &devPathPos, // this is an IN OUT param
        &handle
        );

    if( status != EFI_SUCCESS ) {
        // we were passed a bogus drive path
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive couldn't get base disk block_io.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // now we retrieve the interface pointer from the object
    BS->HandleProtocol(handle, &blk_io_guid, (VOID**)&_device_block_io);

    BS->HandleProtocol(handle, &dsk_io_guid, (VOID**)&_device_disk_io);

    DEBUG((D_INFO,(CHAR8*)"Leaving OpenDrive.\n"));

    return STATUS_SUCCESS;
}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a DP_DRIVE object based on the supplied drive
    path.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST NumMediaTypes         = 20;

    DISK_GEOMETRY               disk_geometry;
    PARTITION_INFORMATION       partition_info;
    BOOLEAN                     partition;
    MSGID                       MessageId;

    Destroy();

    DEBUG((D_INFO,(CHAR8*)"Entering DP_DRIVE::Initialize\n"));

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              NULL,     // EFI: doesn't have access permissions.
                              ExclusiveWrite, // EFI: this will be ignored for EFI.
                              &_block_io,         // EFI: this will return an interface pointer
                              &_disk_io,
                              &_alignment_mask, // EFI: this will return the correct alignment mask.
                              Message );


    if(!NT_SUCCESS(_last_status)) {

        Destroy();

        DEBUG((D_ERROR,(CHAR8*)"IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        MessageId = MSG_CANT_DASD;
        Message ? Message->Set(MessageId) : 1;
        Message ? Message->Display() : 1;

        return FALSE;
    }

    _is_writeable = !(_block_io->Media->ReadOnly);

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: _is_writeable %d\n", !(_block_io->Media->ReadOnly)));

    _media_id = _block_io->Media->MediaId;

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: _media_id %d\n", _block_io->Media->MediaId));

    //
    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;

    if( !(_block_io->Media->MediaPresent) ) {
        MessageId = MSG_CANT_DASD;
        Message ? Message->DisplayMsg(MessageId) : 1;
        return FALSE;
    }

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: MediaPresent %d\n", _block_io->Media->MediaPresent));

    // BUGBUG  in EFI we can't get the exact media type, should we care?
    memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
    disk_geometry.MediaType = Unknown;

    partition = (_block_io->Media->LogicalPartition);

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: IsPartition %d\n", _block_io->Media->LogicalPartition));

#if 0
    // BUGBUG Try to read the partition entry.
    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_PARTITION_INFO,
                                             NULL, 0, &partition_info,
                                             sizeof(PARTITION_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

    }

#endif // removed for EFI

    disk_geometry.MediaType = (_block_io->Media->RemovableMedia) ? RemovableMedia : FixedMedia;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: MediaType %x\n", disk_geometry.MediaType));

    disk_geometry.BytesPerSector = _block_io->Media->BlockSize;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: blocksize %x\n", disk_geometry.BytesPerSector));

    // I fake the cylinder count
    disk_geometry.Cylinders.QuadPart = (ULONGLONG)(_block_io->Media->LastBlock)+1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: cylcount %x\n", disk_geometry.Cylinders.QuadPart));

    disk_geometry.SectorsPerTrack = 1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: sec/trk %x\n", disk_geometry.SectorsPerTrack));
    disk_geometry.TracksPerCylinder = 1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: trk/cyl %x\n", disk_geometry.TracksPerCylinder));

    partition_info.BootIndicator = FALSE;
    partition_info.HiddenSectors = 0;
    partition_info.PartitionLength.QuadPart = ((ULONGLONG)_block_io->Media->LastBlock+1) * (ULONGLONG)_block_io->Media->BlockSize;
    partition_info.PartitionNumber = 1;
    partition_info.PartitionType = 0xEF; // BUGBUG need a const
    partition_info.RecognizedPartition = TRUE;
    partition_info.RewritePartition = FALSE;
    partition_info.StartingOffset.QuadPart = (ULONGLONG)0;

    DEBUG((D_INFO, (CHAR8*)"DP_DRIVE:: Initialize: PartitionLength %x\n", partition_info.PartitionLength.QuadPart));

    // Store the information in the class.
    if (partition) {
        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.HiddenSectors,
                                &_actual);
    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

#if 0
        if (IsFloppy()) {


            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }


            if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
#endif
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

// BUGBUG removed for EFI
#if 0
    if (disk_geometry.MediaType == RemovableMedia) {

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status)) {
            Destroy();
            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (layout_info->PartitionCount < 4) {

            _super_floppy = TRUE;
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }
#endif // removed for EFI

    DEBUG((D_INFO,(CHAR8*)"Leaving DP_DRIVE::Initialize\n"));
    return TRUE;

}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This method initializes a hosted drive, i.e. a volume which
    is implemented as a file on another volume.  Instead of opening
    this file by its actual name, we open it by the host file name,
    to prevent interactions with the file system.

Arguments:

    NtDriveName     - Supplies the NT name of the drive itself.
    HostFileName    - Supplies the fully qualified name of the file
                      which contains this drive.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
// removed hosted support for EFI
#if 0

    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK StatusBlock;
    BIG_INT Sectors, FileSize;
    ULONG AlignmentMask, ExtraUlong;


    Destroy();

    if( !DRIVE::Initialize(HostFileName, Message)) {

        Destroy();
        return FALSE;
    }

    _hosted_drive = TRUE;

    // First, make the host file not-readonly.
    //
    if( !IFS_SYSTEM::FileSetAttributes( HostFileName,
                                        FILE_ATTRIBUTE_NORMAL,
                                        &_old_attributes ) ) {

        Message ? Message->DisplayMsg( MSG_CANT_DASD ) : 1;
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( HostFileName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA |
                                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if( !NT_SUCCESS( _last_status ) ) {

        IFS_SYSTEM::FileSetAttributes( HostFileName,
                                       _old_attributes,
                                       &ExtraUlong );

        DEBUG((D_ERROR,(CHAR8*)"IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        Destroy();
        return FALSE;
    }

    if( NtDriveName ) {

        _last_status = OpenDrive( NtDriveName,
                                  SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                  ExclusiveWrite,
                                  &_alternate_handle,
                                  &AlignmentMask,
                                  Message );
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &StatusBlock,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

    // Fill in the drive type information.  Everything except the
    // Sectors field is fixed by default.  The number of Sectors
    // on the drive is determined from the host file's size.
    //
    _actual.MediaType = HostedDriveMediaType;
    _actual.SectorSize = HostedDriveSectorSize;
    _actual.HiddenSectors = HostedDriveHiddenSectors;
    _actual.SectorsPerTrack = HostedDriveSectorsPerTrack;
    _actual.Heads = HostedDriveHeads;

    _last_status = NtQueryInformationFile( _handle,
                                           &StatusBlock,
                                           &FileStandardInfo,
                                           sizeof( FileStandardInfo ),
                                           FileStandardInformation );

    if( !NT_SUCCESS( _last_status ) ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_DISK_TOO_LARGE_TO_FORMAT ) : 1;
        return FALSE;
    }

    FileSize = FileStandardInfo.EndOfFile;
    Sectors = FileSize / _actual.SectorSize;

    if( Sectors.GetHighPart() != 0 ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_BAD_IOCTL ) : 1;
        return FALSE;
    }

    _actual.Sectors = Sectors.GetLargeInteger();


    // This drive has only one supported drive type
    //
    _num_supported = 1;

    if (!(_supported_list = NEW DRTYPE[1])) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    _supported_list[0] = _actual;

    // If this was a transient open, clean it up.
    //
    if (!IsTransient) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
        NtClose(_handle);
        _alternate_handle ? NtClose(_alternate_handle) : 1;
        _handle = 0;
        _alternate_handle = 0;
    }

#endif
    return FALSE;
}


IFSUTIL_EXPORT
ULONG
DP_DRIVE::QuerySectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per sector.

--*/
{
    return _actual.SectorSize;
}

// BUGBUG EFI doesn't need this
#if 0
#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
ULONG
DP_DRIVE::QueryPhysicalSectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per physical sector.

--*/
{
    return _actual.PhysicalSectorSize;
}
#endif
#endif // removed for EFI

IFSUTIL_EXPORT
BIG_INT
DP_DRIVE::QuerySectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number sectors on the disk.  This does not
    include the hidden sectors.

Arguments:

    None.

Return Value:

    The number of sectors on the disk.

--*/
{
    return _actual.Sectors;
}


IFSUTIL_EXPORT
UCHAR
DP_DRIVE::QueryMediaByte(
        ) CONST
/*++

Routine Description:

        This routine computes the media byte used by the FAT and HPFS file
        systems to represent the current media type.

Arguments:

        None.

Return Value:

        The media byte for the drive.

--*/
{
    switch (_actual.MediaType) {
        case F5_1Pt2_512:   // 5.25", 1.2MB,  512 bytes/sector
            return 0xF9;

       case F3_1Pt44_512:   // 3.5",  1.44MB, 512 bytes/sector
            return 0xF0;

        case F3_2Pt88_512:  // 3.5",  2.88MB, 512 bytes/sector
            return 0xF0;

        case F3_120M_512:   // 3.5",  120MB,  512 bytes/sector
            return 0xF0;

        case F3_20Pt8_512:  // 3.5",  20.8MB, 512 bytes/sector
            return 0xF9;

        case F3_720_512:    // 3.5",  720KB,  512 bytes/sector
            return 0xF9;

        case F5_360_512:    // 5.25", 360KB,  512 bytes/sector
            return 0xFD;

        case F5_320_512:    // 5.25", 320KB,  512 bytes/sector
            return 0xFF;

        case F5_180_512:    // 5.25", 180KB,  512 bytes/sector
            return 0xFC;

        case F5_160_512:    // 5.25", 160KB,  512 bytes/sector
            return 0xFE;

        case RemovableMedia:// Removable media other than floppy
            return 0xF8;    // There is no better choice than this.

        case FixedMedia:    // Fixed hard disk media
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.13.1994 SFT KMR
            // Add the set up process for the fixed_hard_disk_mediaID for FMR
            // FMR's media id is different. Case under 64MB or not.

            if(IsFMR_N()) {
                if(_actual.SectorSize * _actual.Sectors <= 63*1024*1024) {
                    return 0xF9;
                } else {
                    return 0xFA;
                }
            } else
#endif
            return 0xF8;

#if defined(FE_SB)
        case F3_128Mb_512:  // 3.5"MO, 128MB, 512 bytes/sector
        case F3_230Mb_512:  // 3.3"MO, 230MB, 512 bytes/sector
            return 0xF0;

#if defined(_X86_)
        // NEC Oct.15.1994
        // FMR Jul.14.1994 SFT KMR

        // For 8"1S , 256KB , 128 bytes/sector
        // If the media_type is 2HD, return the mediaID:FE

        case F8_256_128:    // 8"1S , 256KB , 128 bytes/sector
        case F5_1Pt23_1024: // 5.25", 1.23MB,  1024 bytes/sector
        case F3_1Pt23_1024: // 3.5",  1.23MB,  1024 bytes/sector
            return 0xFE;

        // If the media_type is 2HC, return the mediaID:F9
        // If the media_type is 2DD(720KB), return the mediaID:F9

        case F5_720_512:    // 5.25",  720KB,  512 bytes/sector
        case F3_1Pt2_512:   // 3.5",  1.2MB,    512 bytes/sector
            return 0xF9;

        // If the media_type is 2DD(640KB), return the mediaID:FB

        case F5_640_512:    // 5",    640KB,  512 bytes/sector
        case F3_640_512:    // 3.5",  640KB,  512 bytes/sector
            return 0xFB;
#endif // _X86_
#endif // FE_SB

        case F5_320_1024:
        case Unknown:
            break;

    }
    return 0;
}


VOID
DP_DRIVE::Destroy(
        )
/*++

Routine Description:

    This routine returns a DP_DRIVE to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{

    memset(&_actual, 0, sizeof(DRTYPE));
    DELETE_ARRAY(_supported_list);
    _num_supported = 0;
    _alignment_mask = 0;

// BUGBUG removed for EFI
#if 0
    if (_hosted_drive) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
    }

    if (_alternate_handle) {

        NtClose(_alternate_handle);
        _alternate_handle = 0;
    }

    if (_handle) {

        NtClose(_handle);
        _handle = 0;
    }
#endif

    _hosted_drive = FALSE;
}


VOID
DP_DRIVE::CloseDriveHandle(
    )
{
#if 0
    if (_handle) {
// BUGBUG removed for EFI
        NtClose(_handle);
        _handle = 0;
    }
#endif
}


BOOLEAN
DP_DRIVE::IsSupported(
    IN  MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the supplied media type is supported
    by the drive.

Arguments:

    MediaType   - Supplies the media type.

Return Value:

    FALSE   - The media type is not supported by the drive.
    TRUE    - The media type is supported by the drive.

--*/
{
    INT i;

    for (i = 0; i < _num_supported; i++) {
        if (MediaType == _supported_list[i].MediaType) {
            return TRUE;
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
MEDIA_TYPE
DP_DRIVE::QueryRecommendedMediaType(
    ) CONST
/*++

Routine Description:

    This routine computes the recommended media type for
    drive.  This media type is independant of any existing
    media type for the drive.  It is solely based on the
    list of recommended media types for the drive.

Arguments:

    None.

Return Value:

    The recommended media type for the drive.

--*/
{
    INT         i;
    MEDIA_TYPE  media_type;
    SECTORCOUNT sectors;

    media_type = Unknown;
    sectors = 0;
    for (i = 0; i < _num_supported; i++) {

        // Special case 1.44.  If a drive supports it then
        // that should be the recommended media type.

        if (_supported_list[i].MediaType == F3_1Pt44_512) {
            media_type = _supported_list[i].MediaType;
            break;
        }

        if (_supported_list[i].Sectors > sectors) {
            media_type = _supported_list[i].MediaType;
        }
    }

    return media_type;
}

BOOLEAN
DP_DRIVE::SetMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine alters the media type of the drive.  If 'MediaType' is
    'Unknown' and the current media type for the drive is also 'Unknown'
    then this routine selects the highest density supported by the
    driver.  If the current media type is known then this function
    will have no effect if 'MediaType' is 'Unknown'.

Arguments:

    MediaType   - Supplies the new media type for the drive.

Return Value:

    FALSE   - The proposed media type is not supported by the drive.
    TRUE    - Success.

--*/
{
    INT i;

    if (MediaType == Unknown) {
        if (_actual.MediaType != Unknown) {
            return TRUE;
        } else if (!_num_supported) {
            return FALSE;
        }

        for (i = 0; i < _num_supported; i++) {
            if (_supported_list[i].Sectors > QuerySectors()) {
                _actual = _supported_list[i];
            }
        }

        return TRUE;
    }

    for (i = 0; i < _num_supported; i++) {
        if (_supported_list[i].MediaType == MediaType) {
            _actual = _supported_list[i];
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry    - Supplies the disk geometry for the drive.
    DriveType       - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = DiskGeometry->Cylinders*
                         DiskGeometry->TracksPerCylinder*
                         DiskGeometry->SectorsPerTrack;
    DriveType->HiddenSectors = 0;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    IN  BIG_INT         NumSectors,
    IN  BIG_INT         NumHiddenSectors,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry        - Supplies the disk geometry for the drive.
    NumSectors          - Supplies the total number of non-hidden sectors on
                        the disk.
    NumHiddenSectors    - Supplies the number of hidden sectors on the disk.
    DriveType           - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = NumSectors;
    DriveType->HiddenSectors = NumHiddenSectors;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::IsATformat(
    ) CONST
/*++

Routine Description:

    This routine judged whether it is AT format.

Arguments:

    None.

Return Value:

    FALSE   - The disk is not AT format.
    TRUE    - The disk is AT format.

History:

    PC98 Oct.21.1995

--*/
{
    return _next_format_type == FORMAT_MEDIA_AT;
}
#endif


DEFINE_CONSTRUCTOR( IO_DP_DRIVE, DP_DRIVE );

VOID
IO_DP_DRIVE::Construct (
        )

/*++

Routine Description:

    Constructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _is_locked = FALSE;
    _is_exclusive_write = FALSE;
    _cache = NULL;
    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


VOID
IO_DP_DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns an IO_DP_DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_cache);

    if (_is_exclusive_write) {
        Dismount();
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        Unlock();
        _is_locked = FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


IO_DP_DRIVE::~IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DP_DRIVE::Initialize(NtDriveName, Message, TRUE, ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another
    volume.

Arguments:

    NtDriveName     - Supplies the drive path.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if( !DP_DRIVE::Initialize(NtDriveName,
                              HostFileName,
                              Message,
                              TRUE,
                              ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Write(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
VOID
IO_DP_DRIVE::SetCache(
    IN OUT  PDRIVE_CACHE    Cache
    )
/*++

Routine Description:

    This routine relaces the current cache with the one supplied.
    The object then takes ownership of this cache and it will be
    deleted by the object.

Arguments:

    Cache   - Supplies the new cache to install.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(Cache);
    DELETE(_cache);
    _cache = Cache;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::FlushCache(
    )
/*++

Routine Description:

    This routine flushes the cache and report returns whether any
    IO error occurred during the life of the cache.

Arguments:

    None.

Return Value:

    FALSE   - Some IO errors have occured during the life of the cache.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Flush();
}


BOOLEAN
IO_DP_DRIVE::HardRead(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // allocate a buffer
    PVOID AlignedBuffer = NULL;
    PVOID AlignedBufferRaw = AllocatePool(NumberOfSectors*QuerySectorSize()+QueryAlignmentMask()+1);

    if(!AlignedBufferRaw) {
        DEBUG((D_ERROR,(CHAR8*)"HardRead: Aligned buffer allocation failed!!!!!!\n"));
        return FALSE;
    }

    // align the buffer according to the mask provided
    AlignedBuffer = (PVOID)(( (ULONG_PTR)AlignedBufferRaw + QueryAlignmentMask() ) & ~((ULONG_PTR)QueryAlignmentMask()));

    EFI_STATUS status =
    status = _disk_io->ReadDisk(
        _disk_io,
        _media_id,
        MultU64x32(StartingSector.GetQuadPart(),_block_io->Media->BlockSize),
        NumberOfSectors*QuerySectorSize(),
        AlignedBuffer
        );

    if(status != EFI_SUCCESS) {
        FreePool(AlignedBufferRaw);
        DEBUG((D_ERROR,(CHAR8*)"HardRead: Read Failed %x!!!!!!\n", status));
        return FALSE;
    }

    memcpy(Buffer,AlignedBuffer,NumberOfSectors*QuerySectorSize());

    FreePool(AlignedBufferRaw);

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::HardWrite(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

    After writing each chunk, we read it back to make sure the write
    really succeeded.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // allocate a buffer
    PVOID       AlignedBuffer;
    ULONG       Length = NumberOfSectors*QuerySectorSize();
    PVOID       AlignedBufferRaw = NULL;
    EFI_STATUS  status;

    DEBUG((D_INFO, (CHAR8*)"HardWrite: At %x for %x sectors\n",
             StartingSector,
             NumberOfSectors));

    //
    // Align buffer only if needed
    //
    if (QueryAlignmentMask()) {

        DEBUG((D_INFO, (CHAR8*)"HardWrite: Buffer requires alignment\n"));

        AlignedBufferRaw = AllocatePool(Length+QueryAlignmentMask()+1);

        if(!AlignedBufferRaw) {
            DEBUG((D_ERROR, (CHAR8*)"HardWrite: Aligned buffer allocation failed!!!!!!\n"));
            return FALSE;
        }

        AlignedBuffer = (PVOID)(( (ULONG_PTR)AlignedBufferRaw + QueryAlignmentMask() ) &
                                ~((ULONG_PTR)QueryAlignmentMask()) );

        memcpy(AlignedBuffer, Buffer, NumberOfSectors*QuerySectorSize());

    } else {
        AlignedBuffer = Buffer;
    }

    // align the buffer according to the mask provided
    status = _disk_io->WriteDisk(
        _disk_io,
        _media_id,
        MultU64x32 (StartingSector.GetQuadPart(),_block_io->Media->BlockSize),
        Length,
        AlignedBuffer
        );

    if (status != EFI_SUCCESS) {
        DEBUG((D_ERROR,(CHAR8*)"HardWrite: Write Failed %x!!!!!!\n", status));
    }

    if (AlignedBufferRaw) {
        FreePool(AlignedBufferRaw);
    }

    return (status == EFI_SUCCESS);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors,
    IN  PVOID   TestBuffer1,
    IN  PVOID   TestBuffer2
    )
/*++

Routine Description:

    This routine verifies a run of sectors on the disk.

Arguments:

    StartingSector  - Supplies the first sector of the run to verify.
    NumberOfSectors - Supplies the number of sectors in the run to verify.
    TestBuffer1     - Supplies a buffer containing test write data
    TestBuffer2     - Supplies a buffer containing test write data

Return Value:

    FALSE   - Some of the sectors in the run are bad.
    TRUE    - All of the sectors in the run are good.

--*/
{
    BIG_INT  VerifySize = QuerySectorSize() * NumberOfSectors;
    ULONG    Size = VerifySize.GetLowPart();
    PVOID    TempBuffer;
    BOOLEAN  result = TRUE;

    DEBUG((D_INFO, (CHAR8*)"Verify: Verifying %x sectors starting at %x\n",
             NumberOfSectors,
             StartingSector));

    DebugAssert(VerifySize.GetHighPart() == 0);

    // there is no guarantee that verify cmd will not destroy data
    // there may not be a need to restore the content

    TempBuffer = AllocatePool(Size);
    if (TempBuffer == NULL) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        return FALSE;
    }

    if (!HardWrite(StartingSector, NumberOfSectors.GetLowPart(), TestBuffer1) ||
        !HardRead(StartingSector, NumberOfSectors.GetLowPart(), TempBuffer) ||
        (CompareMem(TestBuffer1, TempBuffer, Size) != 0)) {
        result = FALSE;
    }

    if (result) {

        if (!HardWrite(StartingSector, NumberOfSectors.GetLowPart(), TestBuffer2) ||
            !HardRead(StartingSector, NumberOfSectors.GetLowPart(), TempBuffer) ||
            (CompareMem(TestBuffer2, TempBuffer, Size) != 0)) {
            result = FALSE;
        }
    }

    FreePool(TempBuffer);

    return result;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN      BIG_INT         StartingSector,
    IN      BIG_INT         NumberOfSectors,
    IN OUT  PNUMBER_SET     BadSectors
    )
/*++

Routine Description:

    This routine computes which sectors in the given range are bad
    and adds these bad sectors to the bad sectors list.

Arguments:

    StartingSector  - Supplies the starting sector.
    NumberOfSectors - Supplies the number of sectors.
    BadSectors      - Supplies the bad sectors list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       MaxSectorsInVerify = 0x200;
    ULONG       MaxDiskHits;
    BIG_INT     half;
    PBIG_INT    starts;
    PBIG_INT    run_lengths;
    ULONG       i, n;
    BIG_INT     num_sectors;
    PVOID       TestBuffer1;
    PVOID       TestBuffer2;

    DEBUG((D_INFO, (CHAR8*)"Entering Verify\n"));

    if (NumberOfSectors == 0) {
        DEBUG((D_INFO, (CHAR8*)"Leaving Verify as there is nothing to verify\n"));
        return TRUE;
    }

    if (NumberOfSectors.GetHighPart() != 0) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Number of sectors to verify exceeded 32 bits\n"));
        return FALSE;
    }

    // Allow 20 retries so that a single bad sector in this region
    // will be found accurately.

    MaxDiskHits = (20 + NumberOfSectors/MaxSectorsInVerify + 1).GetLowPart();

    starts = (PBIG_INT)AllocatePool(sizeof(BIG_INT)*MaxDiskHits);

    if (NULL == starts) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        return FALSE;
    }

    run_lengths = (PBIG_INT)AllocatePool(sizeof(BIG_INT)*MaxDiskHits);

    if (NULL == run_lengths) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        FreePool(starts);
        return FALSE;
    }

    num_sectors = NumberOfSectors;
    for (i = 0; num_sectors > 0; i++) {
        starts[i] = StartingSector + i*MaxSectorsInVerify;
        if (MaxSectorsInVerify > num_sectors) {
            run_lengths[i] = num_sectors;
        } else {
            run_lengths[i] = MaxSectorsInVerify;
        }
        num_sectors -= run_lengths[i];
    }

    TestBuffer1 = AllocatePool(MaxSectorsInVerify);
    TestBuffer2 = AllocatePool(MaxSectorsInVerify);

    if (NULL == TestBuffer2 || NULL == TestBuffer1) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        FreePool(TestBuffer1);
        FreePool(TestBuffer2);
        FreePool(starts);
        FreePool(run_lengths);
        return FALSE;
    }

    // fill with 1010s and 0101s
    SetMem(TestBuffer1, MaxSectorsInVerify, 0xAA);
    SetMem(TestBuffer2, MaxSectorsInVerify, 0x55);

    n = i;

    for (i = 0; i < n; i++) {

        if (!Verify(starts[i], run_lengths[i], TestBuffer1, TestBuffer2)) {

            if (BadSectors == NULL) {
                FreePool(TestBuffer1);
                FreePool(TestBuffer2);
                FreePool(starts);
                FreePool(run_lengths);
                return FALSE;
            }

            if (n + 2 > MaxDiskHits) {

                if (!BadSectors->Add(starts[i], run_lengths[i])) {
                    FreePool(TestBuffer1);
                    FreePool(TestBuffer2);
                    FreePool(starts);
                    FreePool(run_lengths);
                    return FALSE;
                }

            } else {

                if (run_lengths[i] == 1) {

                    if (!BadSectors->Add(starts[i])) {
                        FreePool(TestBuffer1);
                        FreePool(TestBuffer2);
                        FreePool(starts);
                        FreePool(run_lengths);
                        return FALSE;
                    }

                } else {

                    half = run_lengths[i]/2;

                    starts[n] = starts[i];
                    run_lengths[n] = half;
                    starts[n + 1] = starts[i] + half;
                    run_lengths[n + 1] = run_lengths[i] - half;

                    n += 2;
                }
            }
        }
    }

    FreePool(TestBuffer1);
    FreePool(TestBuffer2);
    FreePool(starts);
    FreePool(run_lengths);

    DEBUG((D_INFO, (CHAR8*)"Leaving Verify\n"));
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::VerifyWithRead(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies the usability of the given range of sectors
    using read.

Arguments:

    StartingSector      - Supplies the starting sector of the verify.
    Number OfSectors    - Supplies the number of sectors to verify.

Return Value:

    FALSE   - At least one of the sectors in the given range was unreadable.
    TRUE    - All of the sectors in the given range are readable.

--*/
{
    ULONG       grab;
    BIG_INT     i;
    CONST ULONG MaxIoSize = 0x200 * QuerySectorSize();
    PVOID       Buffer = AllocatePool(MaxIoSize);

    DEBUG((D_INFO, (CHAR8*)"Entering VerifyWithRead\n"));

    if (Buffer == NULL) {
        DEBUG((D_ERROR, (CHAR8*)"VerifyWithRead: Out of memory\n"));
        return FALSE;
    }

    grab = MaxIoSize/QuerySectorSize();
    for (i = 0; i < NumberOfSectors; i += grab) {

        if (NumberOfSectors - i < grab) {
            grab = (NumberOfSectors - i).GetLowPart();
        }

        if (!HardRead(StartingSector + i, grab, Buffer)) {
            return FALSE;
        }
    }

    DEBUG((D_INFO, (CHAR8*)"Leaving VerifyWithRead\n"));
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Lock(
    )
/*++

Routine Description:

    This routine locks the drive.  If the drive is already locked then
    this routine will do nothing.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // EFI can just return TRUE.
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::InvalidateVolume(
    )
/*++

Routine Description:

    This routine invalidates the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // BUGBUG need alternate implementaiton for EFI?
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::ForceDirty(
    )
/*++

Routine Description:

    This routine forces the volume to be dirty, so that efichk will
    run next time the system reboots.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // BUGBUG this IOCTL doesn't exist in EFI, do we need an alternate implementation?
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Unlock(
    )
/*++

Routine Description:

    This routine unlocks the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // EFI doesn't need this, we just stub it out
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Dismount(
    )
/*++

Routine Description:

    This routine dismounts the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unneeded for EFI
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::DismountAndUnlock(
    )
/*++

Routine Description:

    This routine dismounts the drive and unlocks it.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // not needed for EFI
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::FormatVerifyFloppy(
    IN      MEDIA_TYPE  MediaType,
    IN OUT  PNUMBER_SET BadSectors,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsDmfFormat
    )
/*++

Routine Description:

    This routine low level formats an entire floppy disk to the media
    type specified.  If no MediaType is specified then a logical one will
    be selected.

Arguments:

    MediaType   - Supplies an optional media type to format to.
    BadSectors  - Returns a list of bad sectors on the disk.
    Message     - Supplies a message object to route messages to.
    IsDmfFormat - Supplies whether or not to perform a DMF type format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
// BUGBUG temporary removal for EFI? do we need this for EFI
#if 0
    IO_STATUS_BLOCK         status_block;
    CONST                   format_parameters_size = sizeof(FORMAT_EX_PARAMETERS) + 20*sizeof(USHORT);
    CHAR                    format_parameters_buffer[format_parameters_size];
    PFORMAT_EX_PARAMETERS   format_parameters;
    PBAD_TRACK_NUMBER       bad;
    ULONG                   num_bad, j;
    ULONG                   i;
    ULONG                   cyl;
    ULONG                   percent;
    ULONG                   sec_per_track;
    ULONG                   sec_per_cyl;
    HMEM                    hmem;
    MSGID                   MessageId;
    USHORT                  swap_buffer[3];

    // We don't make sure that the volume is locked here because
    // it's not strictly necessary and 'diskcopy' will format
    // floppies without locking them.

    if (!SetMediaType(MediaType) ||
        (IsDmfFormat && QueryMediaType() != F3_1Pt44_512)) {

        Message ? Message->DisplayMsg(MSG_NOT_SUPPORTED_BY_DRIVE) : 1;
        return FALSE;
    }

    format_parameters = (PFORMAT_EX_PARAMETERS) format_parameters_buffer;
    format_parameters->MediaType = QueryMediaType();
    format_parameters->StartHeadNumber = 0;
    format_parameters->EndHeadNumber = QueryHeads() - 1;

    if (IsDmfFormat) {
        sec_per_track = 21;
        format_parameters->FormatGapLength = 8;
        format_parameters->SectorsPerTrack = (USHORT) sec_per_track;
        format_parameters->SectorNumber[0] = 12;
        format_parameters->SectorNumber[1] = 2;
        format_parameters->SectorNumber[2] = 13;
        format_parameters->SectorNumber[3] = 3;
        format_parameters->SectorNumber[4] = 14;
        format_parameters->SectorNumber[5] = 4;
        format_parameters->SectorNumber[6] = 15;
        format_parameters->SectorNumber[7] = 5;
        format_parameters->SectorNumber[8] = 16;
        format_parameters->SectorNumber[9] = 6;
        format_parameters->SectorNumber[10] = 17;
        format_parameters->SectorNumber[11] = 7;
        format_parameters->SectorNumber[12] = 18;
        format_parameters->SectorNumber[13] = 8;
        format_parameters->SectorNumber[14] = 19;
        format_parameters->SectorNumber[15] = 9;
        format_parameters->SectorNumber[16] = 20;
        format_parameters->SectorNumber[17] = 10;
        format_parameters->SectorNumber[18] = 21;
        format_parameters->SectorNumber[19] = 11;
        format_parameters->SectorNumber[20] = 1;
    } else {
        sec_per_track = QuerySectorsPerTrack();
    }
    sec_per_cyl = sec_per_track*QueryHeads();

    DebugAssert(QueryCylinders().GetHighPart() == 0);
    cyl = QueryCylinders().GetLowPart();
    num_bad = QueryHeads();
    if (num_bad == 0 || cyl == 0) {
        return FALSE;
    }

        if (!(bad = NEW BAD_TRACK_NUMBER[num_bad])) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    if (!hmem.Acquire(sec_per_cyl*QuerySectorSize(), QueryAlignmentMask())) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }


    Message ? Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0) : 1;

    percent = 0;
    for (i = 0; i < cyl; i++) {

        format_parameters->StartCylinderNumber = i;
        format_parameters->EndCylinderNumber = i;

        if (IsDmfFormat) {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS_EX,
                                                 format_parameters,
                                                 format_parameters_size,
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));

            // Skew the next cylinder by 3 sectors from this one.

            RtlMoveMemory(swap_buffer,
                          &format_parameters->SectorNumber[18],
                          3*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[3],
                          &format_parameters->SectorNumber[0],
                          18*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[0],
                          swap_buffer,
                          3*sizeof(USHORT));

        } else {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS,
                                                 format_parameters,
                                                 sizeof(FORMAT_PARAMETERS),
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));
        }

        if (!NT_SUCCESS(_last_status)) {
            DELETE_ARRAY(bad);

            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_MEDIA_WRITE_PROTECTED:
                    MessageId = MSG_FMT_WRITE_PROTECTED_MEDIA ;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;
            return FALSE;
        }


        // Verify the sectors.

        if (BadSectors) {

            if (!Read(i*sec_per_cyl, sec_per_cyl, hmem.GetBuf())) {

                // If this is the first track then fail.
                // A disk with a bad cylinder 0 is not
                // worth continuing on.
                //
                // As of 7/29/94, formatting 2.88 floppies to 1.44
                // doesn't work on Alphas; if we can't format to
                // 1.44 and 2.88 is supported, try 2.88.
                //
                if (i == 0) {

                    if( !IsDmfFormat &&
                        QueryMediaType() == F3_1Pt44_512 &&
                        SetMediaType(F3_2Pt88_512) ) {

                        return( FormatVerifyFloppy( F3_2Pt88_512,
                                                    BadSectors,
                                                    Message,
                                                    IsDmfFormat ) );

                    } else {

                        Message ? Message->DisplayMsg(MSG_UNUSABLE_DISK) : 1;
                        return FALSE;
                    }
                }

                for (j = 0; j < sec_per_cyl; j++) {
                    if (!Read(i*sec_per_cyl + j, 1, hmem.GetBuf())) {
                        if (!BadSectors->Add(i*sec_per_cyl + j)) {
                            return FALSE;
                        }
                    }
                }
            }
        }

        if ((i + 1)*100/cyl > percent) {
            percent = (i + 1)*100/cyl;
            if (percent > 100) {
                percent = 100;
            }

            // This check for success on the message object
            // has to be there for FMIFS to implement CANCEL.

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                DELETE_ARRAY(bad);
                return FALSE;
            }
        }
    }

    DELETE_ARRAY(bad);
#endif
    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( LOG_IO_DP_DRIVE, IO_DP_DRIVE, IFSUTIL_EXPORT );


IFSUTIL_EXPORT
LOG_IO_DP_DRIVE::~LOG_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for LOG_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite);
}

IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another volume.


Arguments:

    NtDriveName     - Supplies the path of the drive object.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName,
                                   HostFileName,
                                   Message,
                                   ExclusiveWrite);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::SetSystemId(
    IN  PARTITION_SYSTEM_ID   SystemId
    )
/*++

Routine Description:

    This routine sets the system identifier (or partition type) in the
    MBR.  BUGBUG doesn't currently handle extended partitions.

Arguments:

    SystemId    - Supplies the system id to write in the partition entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MBR_PARTITION_RECORD    *partition_info;
    MASTER_BOOT_RECORD      *pMbr;
    EFI_STATUS              status;

    DEBUG((D_INFO,(CHAR8*)"Inside SetSystemId.\n" ));

    //
    // This operation is unnecessary on floppies, super-floppies, and
    // hosted volumes.
    //

    if (IsFloppy() || IsSuperFloppy() || _hosted_drive) {
        DEBUG((D_INFO,(CHAR8*)"No need to set partition type.\n" ));
        return TRUE;
    }

    if( SystemId == SYSID_NONE ) {

        // Note: we should never set it to zero!

        DEBUG((D_INFO,(CHAR8*)"Skip setting the partition type to zero.\n" ));
        return TRUE;
    }

    //
    // Now we have to read the MBR and set the type ourselves
    //

    pMbr = ( MASTER_BOOT_RECORD * ) AllocatePool( sizeof( MASTER_BOOT_RECORD ) );

    if ( !pMbr ) {
        DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't allocate MBR.\n"));
        return FALSE;
    }

    //
    // Now read the MBR
    //

    status = _device_disk_io->ReadDisk  (  _device_disk_io,
                                           _device_block_io->Media->MediaId,
                                           0,
                                           sizeof( MASTER_BOOT_RECORD ),
                                           pMbr
                                         );

    if ( EFI_ERROR( status ) ) {
        DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't read MBR.\n"));
        FreePool (pMbr);
        return FALSE;
    }

    //
    // Check to see if this is a GPT disk
    //

    partition_info = &(pMbr->Partition[0]);

    //
    // According to spec, the GPT signature should be the only thing to determine if
    // it is a GPT partition.  There is no need to check for the partition
    // type to see if it is 0xEE first.  However, LDM does not appear to zap the
    // signature when converting a GPT disk to MBR disk.
    //

    if (partition_info->OSIndicator != SYSID_EFI) {

        if (_partition_number) {

            DEBUG((D_INFO,(CHAR8*)"Setting partition %d id to %x\n", _partition_number, SystemId));

            //
            // Set the system ID in the correct partition
            // of the MBR since it's not a GPT disk
            //

            partition_info = &( pMbr->Partition[_partition_number - 1] );

            partition_info->OSIndicator = (UCHAR)SystemId;


            //
            // Write the MBR back out to the disk
            //

            status = _device_disk_io->WriteDisk( _device_disk_io,
                                                 _device_block_io->Media->MediaId,
                                                 0,
                                                 sizeof( MASTER_BOOT_RECORD ),
                                                 pMbr
                                               );

            if ( EFI_ERROR( status ) ) {
                DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't write MBR.\n"));
                FreePool (pMbr);
                return FALSE;
            }

            _device_block_io->FlushBlocks( _device_block_io );

        } else {
            DEBUG((D_INFO,(CHAR8*)"Partition number is 0.\n" ));
        }
    } else {
        DEBUG((D_INFO,(CHAR8*)"It is a GPT disk.\n" ));
    }

    DEBUG((D_INFO,(CHAR8*)"Leaving SetSystemId.\n" ));

    FreePool (pMbr);
    return TRUE;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Write(StartingSector, NumberOfSectors, Buffer);
}
#endif // FE_SB && _X86_


DEFINE_CONSTRUCTOR( PHYS_IO_DP_DRIVE, IO_DP_DRIVE );

PHYS_IO_DP_DRIVE::~PHYS_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for PHYS_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
PHYS_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a PHYS_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\efiutil\efilib\efisrc\efitimefunc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    efitimefunc.cxx

--*/

#include<pch.cxx>

static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    );

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    );

//
//  The following t