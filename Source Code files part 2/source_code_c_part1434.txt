         // lpClass
                REG_OPTION_NON_VOLATILE,        // dwOptions
                KEY_ALL_ACCESS,                 // samDesired
                NULL,                           // lpSecurityAttributes,
                &key,                           // phkResult
                &disposition                    // lpdwDisposition
                );

    if (err == NO_ERROR)
    {
        length = (wcslen(pValue) + 1) * sizeof(pValue[0]);

        err = RegSetValueExW(
                    key,                        // hKey
                    pValueName,                 // lpValueName
                    0,                          // Reserved
                    REG_EXPAND_SZ,              // dwType
                    (CONST BYTE *)pValue,       // lpData
                    length                      // cbData
                    );

        RegCloseKey( key );
    }

    return err;

}   // WriteRegValue


DWORD
DeleteRegKey(
    IN PWSTR pKeyName
    )
{
    DWORD err;

    err = RegDeleteKeyW(
                HKEY_LOCAL_MACHINE,
                pKeyName
                );

    return err;

}   // DeleteRegKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\inc\errors.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    errors.h

Abstract:

    Definition of the error codes for UL.VXD's usermode API.

Author:

    Mauro Ottaviani (mauroot)       26-Aug-1999

Revision History:

--*/


#ifndef _ERRORS_H_
#define _ERRORS_H_


#define UL_ERROR_SUCCESS					ERROR_SUCCESS // The operation completed successfully
#define UL_ERROR_IO_PENDING					ERROR_IO_PENDING // Overlapped I/O operation is in progress
#define UL_ERROR_MORE_DATA					ERROR_MORE_DATA // More data is available
#define UL_ERROR_INVALID_HANDLE				ERROR_INVALID_HANDLE // The handle is invalid
#define UL_ERROR_HANDLE_NOT_FOUND			ERROR_NOT_FOUND // The handle was invalid
#define UL_ERROR_NOT_READY					ERROR_NOT_READY // The device is not ready
#define UL_ERROR_NOT_IMPLEMENTED			ERROR_BAD_COMMAND // The device does not recognize the command
#define UL_ERROR_BAD_COMMAND				ERROR_BAD_COMMAND // The device does not recognize the command
#define UL_ERROR_URI_REGISTERED				ERROR_PIPE_BUSY // All pipe instances are busy
#define UL_ERROR_NO_TARGET_URI				ERROR_PIPE_NOT_CONNECTED // No process is on the other end of the pipe
#define UL_ERROR_VXDALLOCMEM_FAILED			ERROR_NOT_ENOUGH_MEMORY // Not enough storage is available to process this command
#define UL_ERROR_VXDLOCKMEM_FAILED			ERROR_LOCK_FAILED // Unable to lock a region of a file
#define UL_ERROR_VXDVALIDATEBUFFER_FAILED	ERROR_NOACCESS // Invalid access to memory location
#define UL_ERROR_INVALID_DATA				ERROR_INVALID_DATA // The data is invalid
#define UL_ERROR_NO_SYSTEM_RESOURCES		ERROR_NO_SYSTEM_RESOURCES // Insufficient system resources exist to complete the requested service (1450)
#define UL_ERROR_INTERNAL_ERROR				ERROR_INTERNAL_ERROR // An internal error occurred (1359)
#define UL_ERROR_INVALID_PARAMETER 			ERROR_INVALID_PARAMETER // The parameter is incorrect
#define UL_ERROR_INSUFFICIENT_BUFFER		ERROR_INSUFFICIENT_BUFFER // The data area passed to a system call is too small


// #define UL_ERROR_VXDCOPYMEM_FAILED			ERROR_CANNOT_COPY // CAN'T FAIL
// #define UL_ERROR_SETWIN32EVENT_FAILED		ERROR_INVALID_EVENTNAME // CAN'T FAIL


#endif  // _ERRORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\inc\vxdinfo.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    vxdinfo.h

Abstract:

    Definition of the structures used by UL.VXD to store information
    on processes using the device driver.

Author:

    Mauro Ottaviani (mauroot)       26-Aug-1999

Revision History:

--*/


#ifndef _VXDINFO_H_
#define _VXDINFO_H_

#include "precomp.h"
#include "structs.h"
#include "errors.h"

typedef struct _UL_IRP_LIST
{
	LIST_ENTRY					List;
	HANDLE						hProcess;
	HANDLE						hThread; // need this for cleanup

	HANDLE						hr0Event;
	OVERLAPPED					*pOverlapped;
	BYTE						*pData;
	ULONG						ulBytesToTransfer;

	ULONG						ulBytesTransferred;
	UL_HTTP_REQUEST_ID			*pRequestId;
	
} UL_IRP_LIST, *PUL_IRP_LIST;


typedef struct _UL_REQUEST_LIST
{
	LIST_ENTRY					List;
	LIST_ENTRY					RequestIrpList;
	LIST_ENTRY					ResponseIrpList;
	UL_HTTP_REQUEST_ID			RequestId;

	ULONG						ulRequestHeadersSending;
	ULONG						ulResponseHeadersSending;
	ULONG						ulRequestHeadersSent;
	ULONG						ulResponseHeadersSent;
	ULONG						ulRequestIrpType;
	ULONG						ulResponseIrpType;

	ULONG						ulUriId;

} UL_REQUEST_LIST, *PUL_REQUEST_LIST;


typedef struct _UL_URI_LIST
{
	LIST_ENTRY					List;
	LIST_ENTRY					GlobalList;
	ULONG						ulUriId;
	LIST_ENTRY					*pAppPoolList;
	ULONG						ulUriLength;
	WCHAR						pUri[1];

} UL_URI_LIST, *PUL_URI_LIST;


typedef struct _UL_APPPOOL_LIST
{
	LIST_ENTRY					List;
	LIST_ENTRY					UriList;
	LIST_ENTRY					RequestList;
	HANDLE						hAppPool;
	ULONG						ulUriIdNext;

} UL_APPPOOL_LIST, *PUL_APPPOOL_LIST;


typedef struct _UL_PROCESS_INFO
{
	LIST_ENTRY					List;
	LIST_ENTRY					AppPoolList;
	HANDLE						hProcess;
	HANDLE						hAppPoolNext;

} UL_PROCESS_LIST, *PUL_PROCESS_LIST;


#endif  // _VXDINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\library\ulapi.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    ulapi.c

Abstract:

    This module compiles into ulapi.lib which implements the UL user-mode API.

Author:

    Mauro Ottaviani (mauroot)       09-Aug-1999

Revision History:

--*/


#define UNICODE
#define VXD_NAME "ul.vxd"

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include "ulapi9x.h"
#include "structs.h"


#ifdef DBG

#define UL_LIB_PRINT(x) printf(x)

#else // #ifdef DBG

#define UL_LIB_PRINT(x)

#endif // #ifdef DBG



// Global variables

HANDLE
	hDevice = INVALID_HANDLE_VALUE;

BOOL
	bOK;

// APIs

ULONG
WINAPI
UlInitialize(
    IN ULONG Reserved
    )
{
	if ( hDevice != INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlInitialize() FAILED\n" );

		return ERROR_ALREADY_INITIALIZED;
	}

	if ( Reserved != 0 )
	{
		UL_LIB_PRINT( "(LIBRARY) UlInitialize() FAILED\n" );

		return ERROR_INVALID_PARAMETER;
	}

	hDevice =
	CreateFileA(
		"\\\\.\\" VXD_NAME,
		0,
		0,
		NULL,
		0,
		FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED,
		NULL );

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlInitialize() FAILED\n" );

		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlInitialize() SUCCEEDED\n" );

	return ERROR_SUCCESS;

}	// UlInitialize


VOID
WINAPI
UlTerminate(
    VOID
    )
{
	if ( hDevice != INVALID_HANDLE_VALUE )
	{
		CloseHandle( hDevice );
		hDevice = INVALID_HANDLE_VALUE;
	}

	UL_LIB_PRINT( "(LIBRARY) UlTerminate() SUCCEEDED\n" );

	return;

}	// UlTerminate


// The following APIs will just pack all the information passed in the paramteres
// into the appropriate structure in memory and call DeviceIoControl() with the
// appropriate IOCTL code passing down the pointer to the Input structure.

ULONG
WINAPI
UlCreateAppPool(
    OUT HANDLE *phAppPoolHandle
    )
{
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlCreateAppPool() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_CREATE_APPPOOL,
		phAppPoolHandle,
		sizeof( HANDLE ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlCreateAppPool() SUCCEEDED\n" );

	return ERROR_SUCCESS;
	
}	// UlCreateAppPool


ULONG
WINAPI
UlCloseAppPool(
	IN HANDLE *phAppPoolHandle
	)
{
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlCloseAppPool() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_CLOSE_APPPOOL,
		phAppPoolHandle,
		sizeof( HANDLE ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlCloseAppPool() SUCCEEDED\n" );

	return ERROR_SUCCESS;

}	// UlCloseAppPool


ULONG
WINAPI
UlUnregisterAll(
    IN HANDLE *phAppPoolHandle
    )
{
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlCreateAppPool() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_UNREGISTER_ALL,
		phAppPoolHandle,
		sizeof( HANDLE ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlUnregisterAll() SUCCEEDED\n" );

	return ERROR_SUCCESS;
	
}	// UlUnregisterAll


ULONG
WINAPI
UlRegisterUri(
    IN HANDLE hAppPoolHandle,
    IN PWSTR pUri
    )
{
	ULONG ulUriToRegisterLength;
	IN_IOCTL_UL_REGISTER_URI InIoctl;
	
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	ulUriToRegisterLength = ( pUri == NULL ) ? 0 : lstrlen( pUri );
	if ( ulUriToRegisterLength == 0 )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() INVALID Uri\n" );
		return ERROR_INVALID_PARAMETER;
	}

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_REGISTER_URI ) );
	
	InIoctl.ulSize = sizeof( IN_IOCTL_UL_REGISTER_URI );
	InIoctl.hAppPoolHandle = hAppPoolHandle;
	InIoctl.ulUriToRegisterLength = ulUriToRegisterLength;
	InIoctl.pUriToRegister = ( WCHAR* ) malloc( sizeof( WCHAR ) * ( ulUriToRegisterLength + 1 ) );
	lstrcpy( InIoctl.pUriToRegister, pUri ); // this terminates the string with a \0\0
	if ( _wcslwr( InIoctl.pUriToRegister ) != InIoctl.pUriToRegister )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() INVALID Uri\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_REGISTER_URI,
		&InIoctl,
		sizeof( IN_IOCTL_UL_REGISTER_URI ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() SUCCEEDED\n" );

	return ERROR_SUCCESS;
	
}	// UlRegisterUri


ULONG
WINAPI
UlUnregisterUri(
    IN HANDLE hAppPoolHandle,
    IN PWSTR pUri
    )
{
	ULONG ulUriToUnregisterLength;
	IN_IOCTL_UL_UNREGISTER_URI InIoctl;
	
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlUnregisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	ulUriToUnregisterLength = ( pUri == NULL ) ? 0 : lstrlen( pUri );
	if ( ulUriToUnregisterLength == 0 )
	{
		UL_LIB_PRINT( "(LIBRARY) UlUnregisterUri() INVALID Uri\n" );
		return ERROR_INVALID_PARAMETER;
	}

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_UNREGISTER_URI ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_UNREGISTER_URI );
	InIoctl.hAppPoolHandle = hAppPoolHandle;
	InIoctl.ulUriToUnregisterLength = ulUriToUnregisterLength;
	InIoctl.pUriToUnregister = ( WCHAR* ) malloc( sizeof( WCHAR ) * ( ulUriToUnregisterLength + 1 ) );
	lstrcpy( InIoctl.pUriToUnregister, pUri ); // this terminates the string with a \0\0
	if ( _wcslwr( InIoctl.pUriToUnregister ) != InIoctl.pUriToUnregister )
	{
		UL_LIB_PRINT( "(LIBRARY) UlUnregisterUri() INVALID Uri\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_UNREGISTER_URI,
		&InIoctl,
		sizeof( IN_IOCTL_UL_UNREGISTER_URI ),
		NULL,
		0,
		NULL,
		NULL );

	if ( bOK )
	{
		return ERROR_SUCCESS;
	}

	UL_LIB_PRINT( "(LIBRARY) UlUnregisterUri() SUCCEEDED\n" );

	return GetLastError();
	
}	// UlUnregisterUri


ULONG
WINAPI
UlGetOverlappedResult(
	IN LPOVERLAPPED pOverlapped, // pointer to overlapped structure
	IN PULONG pNumberOfBytesTransferred, // pointer to actual bytes count
	IN BOOL bWait // wait flag
)
{
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlGetOverlappedResult() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	if ( pOverlapped == NULL || pNumberOfBytesTransferred == NULL )
	{
		return ERROR_INVALID_PARAMETER;
	}

	if ( bWait == FALSE )
	{
		*pNumberOfBytesTransferred = pOverlapped->InternalHigh;
		
		if ( pOverlapped->Internal == ERROR_IO_PENDING )
		{
			return ERROR_IO_INCOMPLETE;
		}
	}
	else
	{
		WaitForSingleObject( pOverlapped->hEvent, INFINITE );

		*pNumberOfBytesTransferred = pOverlapped->InternalHigh;
	}
	
	UL_LIB_PRINT( "(LIBRARY) UlGetOverlappedResult() SUCCEEDED\n" );

	return pOverlapped->Internal;
	
} // UlGetOverlappedResult


ULONG
WINAPI
UlSendHttpRequestHeaders(
	IN PWSTR pTargetUri,
	IN PUL_HTTP_REQUEST_ID pRequestId,
	IN ULONG Flags,
	IN PUL_HTTP_REQUEST pRequestBuffer,
	IN ULONG RequestBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	ULONG ulTargetUriLength;
	IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS InIoctl;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	ulTargetUriLength = ( pTargetUri == NULL ) ? 0 : lstrlen( pTargetUri );
	if ( ulTargetUriLength == 0 )
	{
		return ERROR_INVALID_PARAMETER;
	}

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS );
	InIoctl.pTargetUri = ( WCHAR* ) malloc( sizeof( WCHAR ) * ( ulTargetUriLength + 1 ) );
	lstrcpy( InIoctl.pTargetUri, pTargetUri ); // this terminates the string with a \0\0
	if ( _wcslwr( InIoctl.pTargetUri ) != InIoctl.pTargetUri )
	{
		UL_LIB_PRINT( "(LIBRARY) UlSendMessage() INVALID Uri\n" );
		return ERROR_INVALID_PARAMETER;
	}
	InIoctl.pRequestId = pRequestId;
	InIoctl.Flags = Flags;
	InIoctl.pRequestBuffer = pRequestBuffer;
	InIoctl.RequestBufferLength = RequestBufferLength;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;
	InIoctl.ulTargetUriLength = ulTargetUriLength;

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_SEND_HTTP_REQUEST_HEADERS,
		&InIoctl,
		sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlSendHttpRequestHeaders() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlSendHttpRequestHeaders


ULONG
WINAPI
UlSendHttpRequestEntityBody(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PVOID pRequestBuffer,
	IN ULONG RequestBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY );
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pRequestBuffer = pRequestBuffer;
	InIoctl.RequestBufferLength = RequestBufferLength;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY,
		&InIoctl,
		sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlSendHttpRequestEntityBody() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlSendHttpRequestEntityBody


ULONG
WINAPI
UlReceiveHttpRequestHeaders(
	IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_REQUEST pRequestBuffer,
	IN ULONG RequestBufferLength,
	OUT PULONG pBytesReturned OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS );
	InIoctl.AppPoolHandle = AppPoolHandle;
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pRequestBuffer = pRequestBuffer;
	InIoctl.RequestBufferLength = RequestBufferLength;
	InIoctl.pBytesReturned = pBytesReturned;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS,
		&InIoctl,
		sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlReceiveHttpRequestHeaders() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlReceiveHttpRequestHeaders


ULONG
WINAPI
UlReceiveHttpRequestEntityBody(
	IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	OUT PVOID pEntityBuffer,
	IN ULONG EntityBufferLength,
	OUT PULONG pBytesReturned,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY );
	InIoctl.AppPoolHandle = AppPoolHandle;
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pEntityBuffer = pEntityBuffer;
	InIoctl.EntityBufferLength = EntityBufferLength;
	InIoctl.pBytesReturned = pBytesReturned;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY,
		&InIoctl,
		sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlReceiveHttpRequestEntityBody() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlReceiveHttpRequestEntityBody


ULONG
WINAPI
UlSendHttpResponseHeaders(
	IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_RESPONSE pResponseBuffer,
	IN ULONG ResponseBufferLength,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	IN PUL_CACHE_POLICY pCachePolicy OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS );
	InIoctl.AppPoolHandle = AppPoolHandle;
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pResponseBuffer = pResponseBuffer;
	InIoctl.ResponseBufferLength = ResponseBufferLength;
	InIoctl.EntityChunkCount = EntityChunkCount;
	InIoctl.pEntityChunks = pEntityChunks;
	InIoctl.pCachePolicy = pCachePolicy;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS,
		&InIoctl,
		sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlSendHttpResponseHeaders() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlSendHttpResponseHeaders


ULONG
WINAPI
UlSendHttpResponseEntityBody(
	IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY );
	InIoctl.AppPoolHandle = AppPoolHandle;
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.EntityChunkCount = EntityChunkCount;
	InIoctl.pEntityChunks = pEntityChunks;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY,
		&InIoctl,
		sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlSendHttpResponseEntityBody() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlSendHttpResponseEntityBody


ULONG
WINAPI
UlReceiveHttpResponseHeaders(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_RESPONSE pResponseBuffer,
	IN ULONG ResponseBufferLength,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	IN PUL_CACHE_POLICY pCachePolicy OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS );
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pResponseBuffer = pResponseBuffer;
	InIoctl.ResponseBufferLength = ResponseBufferLength;
	InIoctl.EntityChunkCount = EntityChunkCount;
	InIoctl.pEntityChunks = pEntityChunks;
	InIoctl.pCachePolicy = pCachePolicy;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS,
		&InIoctl,
		sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlReceiveHttpResponseHeaders() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlReceiveHttpResponseHeaders


ULONG
WINAPI
UlReceiveHttpResponseEntityBody(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	OUT PVOID pEntityBuffer,
	IN ULONG EntityBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	)
{
	IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY InIoctl;

	memset( &InIoctl, 0, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ) );

	InIoctl.ulSize = sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY );
	InIoctl.RequestId = RequestId;
	InIoctl.Flags = Flags;
	InIoctl.pEntityBuffer = pEntityBuffer;
	InIoctl.EntityBufferLength = EntityBufferLength;
	InIoctl.pBytesSent = pBytesSent;
	InIoctl.pOverlapped = pOverlapped;

	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlRegisterUri() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY,
		&InIoctl,
		sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlReceiveHttpResponseEntityBody() SUCCEEDED\n" );

	return ERROR_SUCCESS;

} // UlReceiveHttpResponseEntityBody


ULONG
WINAPI
UlCancelRequest(
	IN PUL_HTTP_REQUEST_ID pRequestId
	)
{
	if ( hDevice == INVALID_HANDLE_VALUE )
	{
		UL_LIB_PRINT( "(LIBRARY) UlCancelRequest() DRIVER not loaded\n" );
		return ERROR_INVALID_PARAMETER;
	}

	bOK =
	DeviceIoControl(
		hDevice,
		IOCTL_UL_CANCEL_REQUEST,
		pRequestId,
		sizeof( UL_HTTP_REQUEST_ID ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		return GetLastError();
	}

	UL_LIB_PRINT( "(LIBRARY) UlCancelRequest() SUCCEEDED\n" );

	return ERROR_SUCCESS;
	
}	// UlCancelRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\connmngr.h ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

	connmngr.h
	
Abstract:

	XXX

Author:

    Mauro Ottaviani ( mauroot )       21-Dec-1999

Revision History:

--*/


#ifndef _CONNMNGR_H_
#define _CONNMNGR_H_


#include "listener.h"


#define LISTENER_GARBAGE_COLLECT 				1
#define LISTENER_RESPONSE_SET					2
#define LISTENER_DONT_GARBAGE_COLLECT 			3
#define LISTENER_STOP_READING 					4
#define LISTENER_RESPOND_AND_GARBAGE_COLLECT 	5
#define LISTENER_CALL_ME_AGAIN					6

typedef struct _LISTENER_THREAD_STATUS
{
	LIST_ENTRY *pConnectionHead;
	DWORD *pdwEvents;
	HANDLE *phEvents;
	LIST_ENTRY **ppConnection;

} LISTENER_THREAD_STATUS, *PLISTENER_THREAD_STATUS;


//
// prototypes
//


DWORD
GarbageCollector(
	LISTENER_THREAD_STATUS *pThreadStatus,
	BOOL bCleanAll );

DWORD
OnWaitTimedOut(
	LIST_ENTRY *pConnectionHead );

DWORD
ReceiveData(
	SOCKET socket,
	UCHAR *pBuffer,
	DWORD dwBufferSize,
	OVERLAPPED *pOverlapped );

DWORD
SendData(
	SOCKET socket,
	UCHAR *pBuffer,
	DWORD dwBufferSize,
	OVERLAPPED *pOverlapped );

DWORD
CreateRequest(
	LISTENER_CONNECTION *pConnection,
	DWORD dwSize );

DWORD
OnPickConnection(
	LISTENER_THREAD_STATUS *pThreadStatus,
	SOCKET sAcceptedSocket,
	ULONG ulRemoteIPAddress );

DWORD
OnSocketRead(
	LISTENER_CONNECTION *pConnection );

DWORD
OnSocketWrite(
	LISTENER_CONNECTION *pConnection );

DWORD
OnVxdRead(
	LISTENER_CONNECTION *pConnection );

DWORD
OnVxdWrite(
	LISTENER_CONNECTION *pConnection );

DWORD
WINAPI
ConnectionsManager(
	LPVOID lpParam );


#endif // _CONNMNGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\inc\ulapi9x.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

 ulapi9x.h

Abstract:

 Header file for the UL user-mode API.

Author:

 Mauro Ottaviani (mauroot) 11-Aug-1999

Revision History:

--*/


#ifndef _API_H_
#define _API_H_



//
// undef DBG because it causes uldef.h to pull in UNICODE_STRING
// which we don't know about
//

#ifdef DBG
#define _HACK_DBG
#undef DBG
#endif


#include "uldef.h"
//#include "precomp.h" // used to be

//
// restore back DBG if it was defined above
//

#ifdef _HACK_DBG
#define DBG
#undef _HACK_DBG
#endif



#include "errors.h"


#ifdef __cplusplus
extern "C" {
#endif

//
// your function prototypes here
//

ULONG
WINAPI
UlInitialize(
	IN ULONG Reserved
	);

VOID
WINAPI
UlTerminate(
	VOID
	);

ULONG
WINAPI
UlCreateAppPool(
	OUT PHANDLE phAppPoolHandle
	);

// under WinNT (ul.sys) UlCreateAppPool() returns a system handle, so, in
// order to close the AppPool, it is sufficient to call CloseHandle() passing
// in the handle returned by UlCreateAppPool(), we must provide a different
// API for win9x, since our handle is not a kernel object

ULONG
WINAPI
UlCloseAppPool(
	IN HANDLE hAppPoolHandle
	);

ULONG
WINAPI
UlRegisterUri(
	IN HANDLE hAppPoolHandle,
	IN PWSTR pUri
	);

ULONG
WINAPI
UlUnregisterUri(
	IN HANDLE hAppPoolHandle,
	IN PWSTR pUri
	);

ULONG
WINAPI
UlUnregisterAll(
    IN HANDLE *phAppPoolHandle
	);

ULONG
WINAPI
UlGetOverlappedResult(
	IN LPOVERLAPPED pOverlapped,
	IN PULONG pNumberOfBytesTransferred,
	IN BOOL bWait
	);

// ul.sys, for now, exposes only server side Http messaging, our eqivalents
// are:

// UlReceiveHttpRequestHeaders() 		UlReceiveHttpRequest()
// UlReceiveHttpRequestEntityBody()		UlReceiveEntityBody()
// UlSendHttpResponseHeaders()			UlSendHttpResponse()
// UlSendHttpResponseEntityBody()		UlSendEntityBody()

ULONG
WINAPI
UlSendHttpRequestHeaders(
	IN PWSTR pTargetUri,
	IN PUL_HTTP_REQUEST_ID pRequestId,
	IN ULONG Flags,
	IN PUL_HTTP_REQUEST pRequestBuffer,
	IN ULONG RequestBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlSendHttpRequestEntityBody(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	OUT PVOID pEntityBuffer,
	IN ULONG EntityBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlReceiveHttpRequestHeaders(
	IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_REQUEST pRequestBuffer,
	IN ULONG RequestBufferLength,
	OUT PULONG pBytesReturned OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlReceiveHttpRequestEntityBody(
    IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	OUT PVOID pEntityBuffer,
	IN ULONG EntityBufferLength,
	OUT PULONG pBytesReturned,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlSendHttpResponseHeaders(
    IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_RESPONSE pResponseBuffer,
	IN ULONG ResponseBufferLength,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	IN PUL_CACHE_POLICY pCachePolicy OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlSendHttpResponseEntityBody(
    IN HANDLE AppPoolHandle,
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlReceiveHttpResponseHeaders(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	IN PUL_HTTP_RESPONSE pResponseBuffer,
	IN ULONG ResponseBufferLength,
	IN ULONG EntityChunkCount OPTIONAL,
	IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
	IN PUL_CACHE_POLICY pCachePolicy OPTIONAL,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);

ULONG
WINAPI
UlReceiveHttpResponseEntityBody(
	IN UL_HTTP_REQUEST_ID RequestId,
	IN ULONG Flags,
	OUT PVOID pEntityBuffer,
	IN ULONG EntityBufferLength,
	OUT PULONG pBytesSent OPTIONAL,
	IN LPOVERLAPPED pOverlapped OPTIONAL
	);


//
// I need some APIs for IO cancelation:
//

ULONG
WINAPI
UlCancelRequest(
	IN PUL_HTTP_REQUEST_ID pRequestId
	);



#ifdef __cplusplus
};
#endif


#endif // _API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\inc\vxd.inc ===
#
# Default rules for building VXDs in the NT build environment.
#


#
# Provide a default DDB name.
#

!ifndef DDB_NAME
DDB_NAME = $(VXDNAME)_DDB
!endif


#
# Build a default .DEF file for the VXD.
#

$(VXDNAME).DEF: $(BASEDIR)\PRIVATE\INET\IISREARC\UL\WIN9X\INC\VXD.INC
    type << > $(VXDNAME).DEF
VXD $(VXDNAME) DYNAMIC
DESCRIPTION '$(DESCRIPTION)'
EXETYPE         DEV386

SEGMENTS
    _LPTEXT         CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _LTEXT          CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _LDATA          CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _TEXT           CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _DATA           CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    CONST           CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _TLS            CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _BSS            CLASS 'LCODE'   PRELOAD NONDISCARDABLE
    _LMSG           CLASS 'MCODE'   PRELOAD NONDISCARDABLE IOPL
    _IMSG           CLASS 'MCODE'   PRELOAD DISCARDABLE IOPL
    _ITEXT          CLASS 'ICODE'   DISCARDABLE
    _IDATA          CLASS 'ICODE'   DISCARDABLE
    _PTEXT          CLASS 'PCODE'   NONDISCARDABLE
    _PMSG           CLASS 'MCODE'   NONDISCARDABLE IOPL
    _PDATA          CLASS 'PDATA'   NONDISCARDABLE SHARED
    _STEXT          CLASS 'SCODE'   RESIDENT
    _SDATA          CLASS 'SCODE'   RESIDENT
    _DBOSTART       CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING
    _DBOCODE        CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING
    _DBODATA        CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING
    _16ICODE        CLASS '16ICODE' PRELOAD DISCARDABLE
    _RCODE          CLASS 'RCODE'
EXPORTS
    $(DDB_NAME) @1
<<


#
# Link and binplace the VXD.
#
# N.B. The 32-bit linker cannot attach a resource to a VXD; we
# therefore do this with ADRC2VXD.
#

$O\$(VXDNAME).VXD: $(OBJECTS) $O\$(VXDNAME).RES $(VXDNAME).DEF
    $(LINKER) @<< /def:$(VXDNAME).DEF
/nologo
/map
/out:$O\$(VXDNAME).VXD
/nodefaultlib
/align:0x200
/ignore:4039
/ignore:4078
/vxd
/NOD
$(OBJECTS)
$(TARGETLIBS)
<<NOKEEP
    $(MAPSYM_CMD)
    $(WIN9X)\bin\adrc2vxd $O\$(VXDNAME).VXD $O\$(@B).res
    $(BINPLACE_CMD)
    $(BINPLACE_CMD:VXD=SYM)


#
# Make the version resource with a 16bit resource compiler because the
# 32bit versions produce UNICODE strings which ADRC2VXD can't handle.
#
# N.B. We must play silly games with the INCLUDE and PATH environment
# variables because 16-bit tools (specifically RC16.EXE) are lame.
#

$O\$(VXDNAME).res:
    set T_INCLUDE=$(INCLUDE)
    set T_PATH=$(PATH)
    set INCLUDE=$(WIN9X)\ddk\inc;$(WIN9X)\sdk\inc16;$(IISBASEDIR)\inc
    set PATH=$(TOOLS16)
    rc16 $(RC_DEFINES) -r -fo$O\$(VXDNAME).res ..\$(VXDNAME).rc
    set PATH=%%T_PATH%%
    set INCLUDE=%%T_INCLUDE%%
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\connmngr.c ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

	connmngr.c
	
Abstract:

	This module contains the main Connection Manager thread's function.
	This thread basically sits waiting for events in an infinte loop,
	until the hExitCM event is signaled by the main thread for shut down,
	or until the thread itself detects some abnormal system behaviour and
	shuts down automatically.

Author:

    Mauro Ottaviani ( mauroot )       15-Dec-1999

Revision History:

--*/

    
#include "connmngr.h"


/*++

Routine Description:

    Dumps the currents status of connections for debug pourposes.

Arguments:

    pThreadStatus
    	Pointer to LISTENER_THREAD_STATUS containing the global status
    	of the connection manager thread.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
DumpConnections(
	LISTENER_THREAD_STATUS *pThreadStatus )
{
	LIST_ENTRY *pConnectionHead = pThreadStatus->pConnectionHead;
	DWORD *pdwEvents = pThreadStatus->pdwEvents;
	HANDLE *phEvents = pThreadStatus->phEvents;
	LIST_ENTRY **ppConnection = pThreadStatus->ppConnection;

	LIST_ENTRY *pConnectionList, *pPendRequestList, *pBufferReadList, *pBufferWriteList;
	LISTENER_CONNECTION *pConnection = NULL;
	LISTENER_REQUEST *pPendRequest = NULL;
	LISTENER_BUFFER_READ *pBufferRead = NULL;
	LISTENER_BUFFER_WRITE *pBufferWrite = NULL;

	DWORD dwIndex, dwEventIndex;

	// Garbage Collection
	
	LISTENER_DBGPRINTF(( "DumpConnections!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" ));

	pConnectionList = pConnectionHead->Flink;
	
	while ( pConnectionList != pConnectionHead )
	{
	    pConnection =
	    CONTAINING_RECORD(
			pConnectionList,
			LISTENER_CONNECTION,
			List );

		LISTENER_DBGPRINTF((
			"pConnection:%08X - socket:%08X ulTotalAllocatedMemory:%d bKeepAlive:%d bGarbageCollect:%d",
			pConnection,
			pConnection->socket,
			pConnection->ulTotalAllocatedMemory,
			pConnection->bKeepAlive,
			pConnection->bGarbageCollect ));

		pPendRequestList = pConnection->PendRequestHead.Flink;
		
		while ( pPendRequestList != &pConnection->PendRequestHead )
		{
		    pPendRequest =
		    CONTAINING_RECORD(
				pPendRequestList,
				LISTENER_REQUEST,
				List );

			LISTENER_DBGPRINTF((
				" +-+ pPendRequest:%08X - pRequestHeadersBuffer:%08X RequestSendStatus:%d ResponseReceiveStatus:%d bDoneWritingToVxd:%d bDoneReadingFromVxd:%d bDoneWritingToSocket:%d Id:%016X",
				pPendRequest,
				pPendRequest->pRequestHeadersBuffer,
				pPendRequest->RequestSendStatus,
				pPendRequest->ResponseReceiveStatus,
				pPendRequest->bDoneWritingToVxd,
				pPendRequest->bDoneReadingFromVxd,
				pPendRequest->bDoneWritingToSocket,
				pPendRequest->pRequest == NULL ? 0 : pPendRequest->pRequest->RequestId ));

			if ( pPendRequest->RequestSendStatus == RequestSendStatusInitialized )
			{
				LISTENER_ASSERT(
					pPendRequest->ResponseReceiveStatus == ResponseReceiveStatusInitialized &&
					pPendRequest->pRequest->RequestId == 0 &&
					pPendRequest->BufferReadHead.Blink == pPendRequest->BufferReadHead.Flink );
			}

			pBufferReadList = pPendRequest->BufferReadHead.Flink;
			pBufferWriteList = pPendRequest->BufferWriteHead.Flink;

			while ( pBufferReadList != &pPendRequest->BufferReadHead )
			{
			    pBufferRead =
			    CONTAINING_RECORD(
					pBufferReadList,
					LISTENER_BUFFER_READ,
					List );

				LISTENER_DBGPRINTF((
					"   +>+ pBufferRead:%08X - pOverlapped:%08X pBuffer:%08X dwBufferSize:%d dwBytesReceived:%d dwBytesParsed:%d",
					pBufferRead,
					&pBufferRead->Overlapped,
					pBufferRead->pBuffer,
					pBufferRead->dwBufferSize,
					pBufferRead->dwBytesReceived,
					pBufferRead->dwBytesParsed ));

				pBufferReadList = pBufferReadList->Flink;
			}

			while ( pBufferWriteList != &pPendRequest->BufferWriteHead )
			{
			    pBufferWrite =
			    CONTAINING_RECORD(
					pBufferWriteList,
					LISTENER_BUFFER_WRITE,
					List );

				LISTENER_DBGPRINTF((
					"   +<+ pBufferWrite:%08X - pOverlapped:%08X pOverlappedResponse:%08X pBuffer:%08X dwBufferSize:%d dwBytesSent:%d bBufferSent:%d",
					pBufferWrite,
					&pBufferWrite->Overlapped,
					&pBufferWrite->OverlappedResponse,
					pBufferWrite->pBuffer,
					pBufferWrite->dwBufferSize,
					pBufferWrite->dwBytesSent,
					pBufferWrite->bBufferSent ));

				pBufferWriteList = pBufferWriteList->Flink;
			}

			pPendRequestList = pPendRequestList->Flink;
		}

		pConnectionList = pConnectionList->Flink;
	}

	LISTENER_DBGPRINTF(( "DumpConnections!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" ));

	return LISTENER_SUCCESS;

} // DumpConnections


/*++

Routine Description:

    Perform Garbage Collection on the connection database owned by the
    connection manager thread.

Arguments:

    pThreadStatus
    	Pointer to LISTENER_THREAD_STATUS containing the global status
    	of the connection manager thread.
    	
    bCleanAll
    	If TRUE clean all connections regardless if they are marked for
    	garbage collection or not.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
GarbageCollector(
	LISTENER_THREAD_STATUS *pThreadStatus,
	BOOL bCleanAll )
{
	LIST_ENTRY *pConnectionHead = pThreadStatus->pConnectionHead;
	DWORD *pdwEvents = pThreadStatus->pdwEvents;
	HANDLE *phEvents = pThreadStatus->phEvents;
	LIST_ENTRY **ppConnection = pThreadStatus->ppConnection;

	LISTENER_CONNECTION *pConnection = NULL;
	LIST_ENTRY *pConnectionList;

	DWORD dwIndex, dwEventIndex;

	// Garbage Collection
	
	LISTENER_DBGPRINTF(( "--GarbageCollector!Entering the Garbage Collector" ));

	pConnectionList = pConnectionHead->Flink;
	
	while ( pConnectionList != pConnectionHead )
	{
	    pConnection =
	    CONTAINING_RECORD(
			pConnectionList,
			LISTENER_CONNECTION,
			List );

		// move to the next element

		pConnectionList = pConnectionList->Flink;

		if ( pConnection->bGarbageCollect || bCleanAll )
		{
			LISTENER_DBGPRINTF((
				"--GarbageCollector!Connection with socket(%08X) is being "
				"Garbage Collected", pConnection->socket ));

			//
			// get this record out of the DB, close the event handles
			// and release the memory:
			//

			RemoveEntryList( pConnectionList->Blink );

			ConnectionCleanup( pConnection );

			//
			// fix the global event array
			//

			//
			// adjust the event array size
			//

			*pdwEvents -= LISTENER_CONNECTION_EVENTS;
			
			dwEventIndex = pConnection->dwEventIndex;

			//
			// If it's the last element I don't need to move the
			// event handles in the array.
			//
			
			if ( dwEventIndex != *pdwEvents  )
			{
				LISTENER_DBGPRINTF((
					"--GarbageCollector!Moving %d event handles from %d to %d",
					LISTENER_CONNECTION_EVENTS, *pdwEvents , dwEventIndex ));

				for ( dwIndex = 0;
					dwIndex < LISTENER_CONNECTION_EVENTS; dwIndex++ )
				{
					pThreadStatus->phEvents[dwEventIndex + dwIndex] =
						pThreadStatus->phEvents[*pdwEvents  + dwIndex];

					pThreadStatus->ppConnection[dwEventIndex + dwIndex] =
						pThreadStatus->ppConnection[*pdwEvents  + dwIndex];
				}

				pConnection = 
		        CONTAINING_RECORD(
					ppConnection[dwEventIndex],
					LISTENER_CONNECTION,
					List );

				pConnection->dwEventIndex = dwEventIndex;
			}
		}
	}

	return LISTENER_SUCCESS;

} // GarbageCollector


/*++

Routine Description:

    Called when the connection manager thread's wait cycle times out, we
    just check for connection's health updating information on lifetime and
    inactive time cleaning up according to configurable values of
	LISTENER_CONNECTION_TIMEOUT and LISTENER_CONNECTION_LIFETIME.

Arguments:

    pConnectionHead
    	Pointer to the list of connections.

Return Value:

    Number of connections that need to be garbage collected.

--*/

DWORD
OnWaitTimedOut(
	LIST_ENTRY *pConnectionHead )
{
	LISTENER_CONNECTION *pConnection = NULL;
	LIST_ENTRY *pConnectionList = NULL;

	FILETIME FT;
	ULARGE_INTEGER llNow, llThen;
	ULONGLONG lwAge, lwInactive;

	DWORD dwCount = 0;

	// Check for application health

	LISTENER_DBGPRINTF((
		"OnWaitTimedOut!Timed Out: checking for application health" ));

	GetSystemTimeAsFileTime( &FT );
	llNow.LowPart = FT.dwLowDateTime;
	llNow.HighPart = FT.dwHighDateTime;

	pConnectionList = pConnectionHead->Flink;
	while ( pConnectionList != pConnectionHead )
	{
	    pConnection =
	    CONTAINING_RECORD(
			pConnectionList,
			LISTENER_CONNECTION,
			List );

		llThen.LowPart = pConnection->sCreated.dwLowDateTime;
		llThen.HighPart = pConnection->sCreated.dwHighDateTime;
		lwAge = (long int) ( (llNow.QuadPart-llThen.QuadPart)/10000000 );

		llThen.LowPart = pConnection->sLastUsed.dwLowDateTime;
		llThen.HighPart = pConnection->sLastUsed.dwHighDateTime;
		lwInactive = (long int) ( (llNow.QuadPart-llThen.QuadPart)/10000000 );

		if (
			( lwInactive >= LISTENER_CONNECTION_TIMEOUT
				|| lwAge >= LISTENER_CONNECTION_LIFETIME )
			&& !pConnection->bGarbageCollect )
		{
				pConnection->bGarbageCollect = TRUE;
				
				dwCount++;
		}

		LISTENER_DBGPRINTF((
			"OnWaitTimedOut!Socket(%08X). Age:%ld Inactive:%ld GC:%d",
			pConnection->socket, lwAge,	lwInactive,
			pConnection->bGarbageCollect ));

		// move to the next element

		pConnectionList = pConnectionList->Flink;
	}

	return dwCount;
	
} // OnWaitTimedOut


/*++

Routine Description:

    ReceiveData().
    This is just a wrapper for WSARecv, since we don't need to specify any
    particular flags and we don't care of synchronous completion, this will
    save us some coding and improve readability

Arguments:

    socket
    	socket handle on which Read I/O is performed

    pBuffer
    	buffer that will contain the data to be received

    dwBufferSize
    	size of the buffer

    pOverlapped
    	overlapped structure containing the event handle that will be signaled
    	on I/O completion

Return Value:

    LISTENER_SUCCESS on success, LISTENER_ERROR otherwise.

--*/

DWORD
ReceiveData(
	SOCKET socket,
	UCHAR *pBuffer,
	DWORD dwBufferSize,
	OVERLAPPED *pOverlapped )
{
	WSABUF pWSABuf[1];
	DWORD dwRead = 0, dwFlags = LISTENER_SOCKET_FLAGS;
	int result;

	pOverlapped->Internal = 0;
	pOverlapped->InternalHigh = 0;
	pOverlapped->Offset = 0;
	pOverlapped->OffsetHigh = 0;

	pWSABuf[0].buf = pBuffer;
	pWSABuf[0].len = dwBufferSize;

	//
	// Call WSARecv
	//

	LISTENER_DBGPRINTF((
		"--ReceiveData!Calling WSARecv( socket:%08X pBuffer:%08X dwBufferSize:%d) pOverlapped:%08X hEvent:%08X",
		socket,
		pBuffer,
		dwBufferSize,
		pOverlapped,
		pOverlapped->hEvent ));

	result = WSARecv(
		socket,
		pWSABuf,
		1,
		&dwRead,
		&dwFlags,
		pOverlapped,
		NULL );

	if ( result == SOCKET_ERROR && WSAGetLastError() != WSA_IO_PENDING )
	{
		LISTENER_DBGPRINTF((
			"--ReceiveData!WSARecv() failed err:%d", WSAGetLastError() ));

		return LISTENER_ERROR;
	}

	return LISTENER_SUCCESS;

} // ReceiveData


/*++

Routine Description:

    SendData().
    This is just a wrapper for WSASend, since we don't need to specify any
    particular flags and we don't care of synchronous completion, this will
    save us some coding and improve readability

Arguments:

    socket
    	socket handle on which Write I/O is performed

    pBuffer
    	buffer containing the data to be sent

    dwBufferSize
    	size of the buffer

    pOverlapped
    	overlapped structure containing the event handle that will be signaled
    	on I/O completion

Return Value:

    LISTENER_SUCCESS on success, LISTENER_ERROR otherwise.

--*/

DWORD
SendData(
	SOCKET socket,
	UCHAR *pBuffer,
	DWORD dwBufferSize,
	OVERLAPPED *pOverlapped )
{
	WSABUF pWSABuf[1];
	DWORD dwRead, dwFlags = LISTENER_SOCKET_FLAGS;
	int result;

	pOverlapped->Internal = 0;
	pOverlapped->InternalHigh = 0;
	pOverlapped->Offset = 0;
	pOverlapped->OffsetHigh = 0;

	pWSABuf[0].buf = pBuffer;
	pWSABuf[0].len = dwBufferSize;

	// Call WSASend

	LISTENER_DBGPRINTF((
		"--SendData!Calling WSASend( socket:%08X pBuffer:%08X dwBufferSize:%d) pOverlapped:%08X hEvent:%08X",
		socket,
		pBuffer,
		dwBufferSize,
		pOverlapped,
		pOverlapped->hEvent ));

	result = WSASend(
		socket,                                               
		pWSABuf,                                     
		1,                                    
		&dwRead,                            
		dwFlags,                                          
		pOverlapped,
		NULL );

	if ( result == SOCKET_ERROR && WSAGetLastError() != WSA_IO_PENDING )
	{
		LISTENER_DBGPRINTF((
			"--SendData!WSASend() failed err:%d", WSAGetLastError() ));

		return LISTENER_ERROR;
	}

	return LISTENER_SUCCESS;
	
} // SendData


/*++

Routine Description:

	OnPickConnection()
    Called when the connection manager thread picks up a new connection from
    the main thread. We allocate a new LISTENER_CONNECTION structure, store
    information on the connection and perform initialization of structures.
	we also register a Callback URI with ul.vxd to listen for response data.

Arguments:

    pThreadStatus
    	Pointer to LISTENER_THREAD_STATUS containing the global status
    	of the connection manager thread.

	sAcceptedSocket
		socket identifier that was just accepted
		
	ulRemoteIPAddress
		IP address of the connected client

Return Value:

    LISTENER_SUCCESS on success
    otherwise.. CODEWORK

--*/

DWORD
OnPickConnection(
	LISTENER_THREAD_STATUS *pThreadStatus,
	SOCKET sAcceptedSocket,
	ULONG ulRemoteIPAddress )
{
	LIST_ENTRY *pConnectionHead = pThreadStatus->pConnectionHead;
	DWORD *pdwEvents = pThreadStatus->pdwEvents;
	HANDLE *phEvents = pThreadStatus->phEvents;
	LIST_ENTRY **ppConnection = pThreadStatus->ppConnection;

	LISTENER_CONNECTION *pConnection = NULL;
	LISTENER_REQUEST *pPendRequest = NULL;
	LISTENER_BUFFER_READ *pBufferRead = NULL;

	HANDLE hEvent;
	DWORD dwError, dwSize, dwEventIndex;
	BOOL bOK;

	LISTENER_DBGPRINTF((
		"OnPickConnection!Caught signal LISTENER_CNNCTMNGR_PICKCNNCT: "
		"new connection socket:%08X", sAcceptedSocket ));

	// Check if we've reached the maximum number of simultaneous
	// connections: if so we can't accept this one, unless we're
	// able to start a new thread.

	if ( *pdwEvents >= MAXIMUM_WAIT_OBJECTS - 2 )
	{
		// CODEWORK: for the future we could start a new thread.
		// for now we're going to just send a very quick sync response
		// and close the connection.
		
		LISTENER_DBGPRINTF((
			"OnPickConnection!Too many connections: "
			"refusing this one (%08X)", sAcceptedSocket ));

		// send a quick sync response and close the socket

		SendQuickHttpResponse(
			sAcceptedSocket,
			TRUE,
			UlErrorUnavailable );

		return LISTENER_DONT_GARBAGE_COLLECT;
	}

	//
	// Create a new LISTENER_CONNECTION record
	//

	pConnection = NULL;

	LISTENER_ALLOCATE(
		LISTENER_CONNECTION*,
		pConnection,
		sizeof( LISTENER_CONNECTION ),
		pConnection );

	if ( pConnection == NULL )
	{
		LISTENER_DBGPRINTF((
			"OnPickConnection!FAILED memory allocation: "
			"err#%d",
			GetLastError() ));

		// send a quick sync response and close the socket

		SendQuickHttpResponse(
			sAcceptedSocket,
			TRUE,
			UlErrorUnavailable );

		return LISTENER_DONT_GARBAGE_COLLECT;
	}

	//
	// Add this to the list of LISTENER_CONNECTION records.
	// Notice that after we do this, we will be able to call GarbageCollect()
	// in order to clean up this connection (we didn't before, because it
	// wasn't in the list yet.
	//

	InsertTailList( pConnectionHead, &pConnection->List );

	LISTENER_DBGPRINTF((
		"OnPickConnection!New Connection is stored in pConnection:%08X",
		pConnection ));

	// set some basic information in the record's fields

	pConnection->socket = sAcceptedSocket;
	pConnection->ulTotalAllocatedMemory = sizeof( LISTENER_CONNECTION );
	pConnection->ulRemoteIPAddress = ulRemoteIPAddress;
	pConnection->dwEventIndex = *pdwEvents;
	pConnection->bGarbageCollect = FALSE;
	pConnection->bKeepAlive = TRUE;

	LISTENER_DBGPRINTF((
		"CreateRequest!pConnection:%08X ulRemoteIPAddress set to %08X",
		pConnection,
		pConnection->ulRemoteIPAddress ));

	GetSystemTimeAsFileTime( &pConnection->sCreated );
	GetSystemTimeAsFileTime( &pConnection->sLastUsed );

	// Initialize the list of LISTENER_REQUEST records

	InitializeListHead( &pConnection->PendRequestHead );

	// Create the events that will be used for I/O.

	for ( dwEventIndex = 0;
		dwEventIndex < LISTENER_CONNECTION_EVENTS; dwEventIndex++ )
	{
		hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
			
		if ( hEvent == NULL )
		{
			LISTENER_DBGPRINTF((
				"OnPickConnection!FAILED Creating Event Handle: "
				"err#%d",
				GetLastError() ));

			*pdwEvents =
				pConnection->dwEventIndex
					+ LISTENER_CONNECTION_EVENTS;

			pConnection->bGarbageCollect = TRUE;

			return LISTENER_GARBAGE_COLLECT;
		}
		else
		{
			LISTENER_DBGPRINTF((
				"OnPickConnection!New Event Handle: hEvent:%08X",
				hEvent ));
		}

		// store event in state information

		pConnection->pOverlapped[dwEventIndex].hEvent = hEvent;
		phEvents[*pdwEvents] = hEvent;
		ppConnection[*pdwEvents] = &pConnection->List;
		(*pdwEvents)++;
	}

	// Create the first LISTENER_REQUEST record and start receiving data on
	// this connection for the first request.

	dwError =
	CreateRequest(
		pConnection,
		LISTENER_BUFFER_SCKREAD_SIZE );

	if ( dwError != LISTENER_SUCCESS )
	{
		LISTENER_DBGPRINTF((
			"OnPickConnection!CreateRequest() failed err#%d", dwError ));

		pConnection->bGarbageCollect = TRUE;

		return LISTENER_GARBAGE_COLLECT;
	}

	//
	// The first thing to do after creating the first LISTENER_REQUEST record is
	// to read data from the client, so: issue the first async receive to
	// start receiving data from the socket.
	//

	LISTENER_ASSERT( !IsListEmpty( &pConnection->PendRequestHead ) );

	pPendRequest =
    CONTAINING_RECORD(
		pConnection->PendRequestHead.Flink,
		LISTENER_REQUEST,
		List );

	LISTENER_ASSERT( !IsListEmpty( &pPendRequest->BufferReadHead ) );

	pBufferRead =
    CONTAINING_RECORD(
		pPendRequest->BufferReadHead.Flink,
		LISTENER_BUFFER_READ,
		List );

	// The first thing to do after the client's connection is to read
	// data from the client, so: issue the first async receive to
	// start receiving data from the socket.

	dwError =
	ReceiveData(
		pConnection->socket,
		pBufferRead->pBuffer,
		pBufferRead->dwBufferSize,
		pConnection->pOverlapped + LISTENER_SOCKET_READ );

	if ( dwError != LISTENER_SUCCESS )
	{
		LISTENER_DBGPRINTF((
			"OnPickConnection!ReceiveData() failed err:%d", dwError ));
			
		return dwError;
	}

	return LISTENER_SUCCESS;
	
} // OnPickConnection


/*++

Routine Description:

	This function works as a "vacuum cleaner", it's completely driven by data
	coming in from the network, as it is called anytime one of the many
	asynchronous calls we made to WSARecv() has completed. To keep it going
	there shall always be, for each connection, one such pending call (the
	first one will be made in the OnPickConnection() function, as soon as we
	succesfully accepted a new connection), in order to do so, unless the
	connection has to be closed due to errors, the last thing we will do in
	this function is call WSARecv() (or get ready to close the connection).

	Each time we get here, the data that is received must be part of the last
	request that was being received. We are going to incrementally parse it,
	and, as soon as we finished parsing the headers we are going to serialize
	them and sending/routing the data to the right application through the VxD,
	and, if there is any, we will start dealing with the body.
	If the request we are dealing with is complete we are going to create a
	new one and start reading for that one, otherwise the data we will receive
	is still part of the request we were dealing with.

	If the body is chunked we must unchunk it here.

	Error Handling:
	If there's any kind of error while parsing the request we will send a
	response and close the connection to avoid denial of service attaks.
	In some cases we will set an error here for a request
	(e.g. if there's no application to route the data to) and just set
	a response to be sent asynchrnously at a later time (respecting the
	FIFO request/response ordering).

	Pipelining:
	If the client is using pipelining, the data we just read may add up to
	multiple requests, if this is the case, after we finish parsing the
	request some data could be remaining and could be part of another
	request, so we will copy it to a new request and fool the app,
	simulating a WSARecv() I/O completion setting the event and moving
	directly data between buffers.

Arguments:

    pThreadStatus
    	Pointer to LISTENER_THREAD_STATUS containing the global status
    	of the connection manager thread.

Return Value:

    LISTENER_SUCCESS on success
    otherwise.. CODEWORK

--*/

DWORD
OnSocketRead(
	LISTENER_CONNECTION *pConnection )
{
	LISTENER_REQUEST *pPendRequest, *pPendRequestNew;
	LISTENER_BUFFER_READ *pBufferRead, *pBufferReadNew;
	LIST_ENTRY *pBufferReadList;

	HTTP_REQUEST *pRequest;
	
	DWORD dwBytesToCopyOffset, dwBytesToCopy, dwChunkSize;
	DWORD dwError, dwStatus, dwSize, dwFlags;
	DWORD dwBytesReceived, dwBytesTaken;
	BOOL bOK;

	LISTENER_DBGPRINTF((
		"OnSocketRead!I/O on socket %08X", pConnection->socket ));

	//
	// find out what happened
	//

	LISTENER_DBGPRINTF((
		"OnSocketRead!calling WSAGetOverlappedResult(pOverlapped:%08X)",
		pConnection->pOverlapped + LISTENER_SOCKET_READ ));

	bOK = WSAGetOverlappedResult(
		pConnection->socket,
		pConnection->pOverlapped + LISTENER_SOCKET_READ,
		&dwBytesReceived,
		FALSE,
		&dwFlags );

	if ( !bOK )
	{
		dwError = WSAGetLastError();

		if ( dwError != WSA_IO_INCOMPLETE )
		{
			//
			// if it's not the only acceptable error we'll close the
			// connection, because something weird is happening
			//

			LISTENER_DBGPRINTF((
				"OnSocketRead!WSAGetOverlappedResult(%d) failed: err:%d",
				dwBytesReceived, dwError ));

			return LISTENER_GARBAGE_COLLECT;
		}

		//
		// that's still ok, even though it's not clear how it could happen
		// the event was reset by the wait completion and we'll be called
		// again at another time
		//

		LISTENER_DBGPRINTF((
			"OnSocketRead!WSAGetOverlappedResult(%d) failed: WSA_IO_INCOMPLETE",
			dwBytesReceived ));
			
		return LISTENER_SUCCESS;
	}

	//
	// now we know how much data was received from the socket
	//
	
	if ( dwBytesReceived == 0 )
	{
		//
		// usually this happens when the connection is closed on the client
		// side: socket disconnected
		//

		LISTENER_DBGPRINTF((
			"OnSocketRead!WSAGetOverlappedResult() returned 0: "
			"Connection closed, socket %08X disconnected",
			pConnection->socket ));

		return LISTENER_SUCCESS;

		//
		// bugbug: apparently some misteryous behaviour with pipelining?
		//

		//return LISTENER_GARBAGE_COLLECT;
	}

	//
	// update time information on the connection
	//

	GetSystemTimeAsFileTime( &pConnection->sLastUsed );

	//
	// find out which request and requestbuffer are involved
	//

	LISTENER_ASSERT( !IsListEmpty( &pConnection->PendRequestHead ) );

	pPendRequest =
    CONTAINING_RECORD(
		pConnection->PendRequestHead.Blink,
		LISTENER_REQUEST,
		List );

	LISTENER_ASSERT( !IsListEmpty( &pPendRequest->BufferReadHead ) );

	pBufferRead =
    CONTAINING_RECORD(
		pPendRequest->BufferReadHead.Blink,
		LISTENER_BUFFER_READ,
		List );

	pRequest = pPendRequest->pRequest;

	LISTENER_DBGPRINTF((
		"OnSocketRead!WSAGetOverlappedResult(pBufferRead:%08X, "
		"pBufferRead->dwBytesReceived:%d) returns %d",
		pBufferRead, pBufferRead->dwBytesReceived, dwBytesReceived ));

	//
	// update buffer information
	//

	pBufferRead->dwBytesReceived += dwBytesReceived;

	//
	// CODEWORK: this is for debugging purpouses only, it's ugly,
	// get rid of it as soon as we trust the buffer managment enough.
	//
	
	LISTENER_DBGPRINTBUFFERS( pPendRequest );

	//
	// we got new data from the socket, now start/resume the parsing from
	// where it is appropriate and keep calling ParseHttp() until we need
	// more data from the network or we are done reading from this connection
	// as for connection-close or something like that.
	//
	// this code is inspired by UlpParseNextRequest() in httprcv.c in ul.sys
	//

	pPendRequestNew = NULL;
	pBufferReadNew = NULL;
	dwBytesToCopyOffset = 0;
	dwBytesToCopy = 0;

	for (;;)
	{
		//
		// first thing we do here is understand in which state the parsing
		// process is, and act accordingly
		//

		switch ( pRequest->ParseState )
		{

        case ParseVerbState:
        case ParseUrlState:
        case ParseVersionState:
        case ParseHeadersState:
        case ParseCookState:

			//
			// when a Request structure is created, the ParseState is set to
			// ParseVerbState, but we get here if we're still parsing the
			// headers, so keep on moving ahead
			//

			LISTENER_DBGPRINTF((
				"OnSocketRead!Calling ParseHttp(%08X, %08X, %d, %08X)",
				pRequest,
				pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
				pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed,
				&dwBytesTaken ));

			//
			// Parse the incoming Data
			//

			dwStatus = ParseHttp(
				pRequest,
				pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
				pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed,
				&dwBytesTaken );

			LISTENER_DBGPRINTF((
				"OnSocketRead!ParseHttp() returns:%08X taken:%d "
				"State:%s Error:%s",
				dwStatus,
				dwBytesTaken,
				LISTENER_STR_PARSE_STATE( pRequest->ParseState ),
				LISTENER_STR_UL_ERROR( pRequest->ErrorCode ) ));

			//
			// did everything work out ok?
			//

			if ( NT_SUCCESS( dwStatus ) == FALSE
				&& dwStatus != STATUS_MORE_PROCESSING_REQUIRED )
		    {
		    	//
		        // some other bad error!
		        //

				LISTENER_DBGPRINTF((
					"OnSocketRead!ParseHttp() failed returning %08X",
					dwStatus ));

				pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

				goto stop_reading;
		    }

		    //
		    // update offsets
		    //

			pBufferRead->dwBytesParsed += dwBytesTaken;

			LISTENER_DBGPRINTF((
				"OnSocketRead!pBufferRead dwBytesParsed:%d dwBytesReceived:%d",
				pBufferRead->dwBytesParsed,
				pBufferRead->dwBytesReceived ));

			//
			// if the parser consumed no data but returned no error, what does
			// it mean?
			//

			if ( dwBytesTaken == 0 )
			{
				LISTENER_DBGPRINTF((
					"OnSocketRead!parser consumed no data" ));

				pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

				goto stop_reading;
			}

			//
			// check to see if we still didn't reach the entity body
			//

			if ( pRequest->ParseState < ParseEntityBodyState )
			{
				//
				// If we're not finished parsing this request's headers we need to
				// read more data from the network to keep feeding the parser.
				// We must be careful:
				//
				// 1) Don't read too much stuff from the network.
				//    we will assume a valid HTTP request not to require more than
				//    LISTENER_MAX_HEADERS_SIZE bytes to store the headers), this is
				//    the same approach that Keith will use in UL.SYS (12/21/1999)
				//
				// 2) Don't keep the parser stuck because of tokens' spanning.
				//    to avoid this we will grow the buffers if the parser can't
				//    avoid token spanning due only to buffer size.
				//

				LISTENER_DBGPRINTF((
					"OnSocketRead!Need more DATA for the headers" ));

				if ( pBufferRead->dwBufferSize >= LISTENER_MAX_HEADERS_SIZE )
				{
					//
					// Request headers are too big, refuse it sending an erorr
					// response and closing the connection.
					//
					
					LISTENER_DBGPRINTF((
						"OnSocketRead!Request is too big (bigger than %d). "
						"Closing connection", LISTENER_MAX_HEADERS_SIZE ));

					//
					// set an appropriate error state
					//

					pRequest->ErrorCode = UlErrorEntityTooLarge;

					pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

					return LISTENER_GARBAGE_COLLECT;
				}

				//
				// if the buffer is full of data we need anoher
				// buffer or we might simply need to grow this one.
				//

				if ( pBufferRead->dwBufferSize <= pBufferRead->dwBytesReceived )
				{
					//
					// We allocate another buffer: we canNOT throw away the data that
					// is already parsed. if there's data not parsed yet at the end of
					// the buffer we'll copy it at the beginning of the new one and
					// take it into account. The alternative is to RE-HttpParse from
					// the beginning, so we try to avoid that.
					//

					dwSize = pBufferRead->dwBufferSize;

					goto new_buffer;

					if ( pBufferRead->dwBytesParsed == 0 )
					{
						// if we are not able to avoid token spanning into
						// the full buffer, we'll allocate a new buffer
						// double the size and try again until we avoid
						// token spanning or we exceed the maximum size of
						// a buffer.

						// PERFORMANCE: (CODEWORK:)

						dwSize<<=1;

						LISTENER_DBGPRINTF((
							"OnSocketRead!can't avoid token spanning growing to:%d",
							dwSize ));

						if ( dwSize >= LISTENER_MAX_HEADERS_SIZE )
						{
							LISTENER_DBGPRINTF((
								"OnSocketRead!Exceeding maximum header size %d>%d",
								dwSize, LISTENER_MAX_HEADERS_SIZE ));
								
							return LISTENER_GARBAGE_COLLECT;
						}
					}

					// Add this to the list of
					// LISTENER_BUFFER_READ records

					InsertTailList(
						&pPendRequest->BufferReadHead, &pBufferReadNew->List );

					if ( pBufferRead->dwBytesParsed == 0 )
					{
						// if we are growing the buffer, we must get rid
						// of the small old one
						
						BufferReadCleanup(
							pBufferRead,
							pConnection );
					}
				}

				// just keep reading headers in the same buffer

				goto keep_reading;

			} // if ( pRequest->ParseState < ParseEntityBodyState )


			//
			// CODEWORK: check for opportunity to call
			// UlCheckProtocolCompliance()
			//

			//
			// it's pRequest->ParseState >= ParseEntityBodyState here
			// can only be the first time I'm done parsing the headers,
			// serialize them and start writing to the vxd
			//

			LISTENER_ASSERT(
				pPendRequest->RequestSendStatus == RequestSendStatusInitialized );

			//
			// Before getting rid of all the headers we shall save information
			// on all the headers that WE MUST understand:
			// CODEWORK: which ones and why???
			// Content-Length
			// Connection/Keep-Alive
			// Transfer-Encoding.
			//

			pPendRequest->bKeepAlive = IsKeepAlive( pRequest );

			//
		    // calculate the size needed for the request, we'll need it below.
		    // (I assume TotalRequestSize is updated by ParseHttp, the
		    // following code is taken from uk\drv\appool.c line #3534)
		    //

		    pPendRequest->ulRequestHeadersBufferSize =
		    	sizeof(UL_HTTP_REQUEST)
		        + pRequest->TotalRequestSize
				+ (pRequest->UnknownHeaderCount * sizeof(UL_UNKNOWN_HTTP_HEADER))
				+ sizeof(UL_NETWORK_ADDRESS_IPV4) * 2;

			LISTENER_ALLOCATE(
				PUCHAR,
				pPendRequest->pRequestHeadersBuffer,
				pPendRequest->ulRequestHeadersBufferSize,
				pConnection );

			if ( pPendRequest->pRequestHeadersBuffer == NULL )
			{
				goto stop_reading;
			}

			//
			// under NT this is only called once and the entity body is never
			// passed along, we'll do the same, but consider:
			// CODEWORK: stuff in part of the entity body if any read/parsed
			//

			dwStatus =
			UlpHttpRequestToBufferWin9x(
					pRequest,
					pPendRequest->pRequestHeadersBuffer,
					pPendRequest->ulRequestHeadersBufferSize,
					NULL,
					0,
					gLocalIPAdress,
					80,
					pConnection->ulRemoteIPAddress,
					80 );

			if ( dwStatus != STATUS_SUCCESS )
			{
				//
				// couldn't serialize for some bad reason
				//

				LISTENER_DBGPRINTF((
					"OnSocketRead!UlpHttpRequestToBufferWin9x() failed" ));

				pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

				goto stop_reading;
			}

			//
			// now that the headers were serialized, we can:
			// 1) free all the buffers that contained header data (this will
			// be true only if headers are big, and spanned multiple buffers)
			// 2) move the data remaining in the last buffer (if any) at the
			// beginning of the buffer and keep reading from the unused space
			// in this buffer
			//

			//
			// walk the list freeing all buffers that we might find
			// until we reach the head of the list
			//
			
			pBufferReadList = pBufferRead->List.Flink;

			while ( pBufferReadList != &pPendRequest->BufferReadHead )
			{
				pBufferReadNew = 
			    CONTAINING_RECORD(
					pBufferReadList,
					LISTENER_BUFFER_READ,
					List );

				pBufferReadList = pBufferReadList->Flink;

				RemoveEntryList( &pBufferReadNew->List );

				BufferReadCleanup(
					pBufferReadNew,
					pConnection );
			}

			//
			// send the serialized headers to the vxd
			//

			LISTENER_DBGPRINTF((
				"OnSocketRead!HTTP_REQUEST serialized, calling"
				" UlSendHttpRequestHeaders(%S) pOverlapped:%08X hEvent:%08X",
				pRequest->CookedUrl.pUrl,
				&pPendRequest->OverlappedBOF,
				pPendRequest->OverlappedBOF.hEvent ));

			dwError =
			UlSendHttpRequestHeaders(
				pRequest->CookedUrl.pUrl,
				&pRequest->RequestId,
				0,
				(PVOID) pPendRequest->pRequestHeadersBuffer,
				pPendRequest->ulRequestHeadersBufferSize,
				NULL,
				&pPendRequest->OverlappedBOF );

			//
			// many errors can happen here, let's assume that if the
			// vxd fails we send an error response and close the
			// connection. CODEWORK: specialize behaviour (response)
			//

			if ( dwError != ERROR_SUCCESS && GetLastError() != ERROR_IO_PENDING )
			{
				LISTENER_DBGPRINTF((
					"OnSocketRead!UlSendHttpRequestHeaders(%S) failed err:%d",
					pRequest->CookedUrl.pUrl,
					GetLastError() ));

				pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

				//
				// if there was no prefix matching return a "404 Not Found"
				// without sending the request.
				//

				if ( dwError == ERROR_PIPE_NOT_CONNECTED )
				{
					pRequest->ErrorCode = UlErrorNotFound;
				}

				goto stop_reading;
			}

			//
			// update the status, we called UlSendHttpRequestHeaders()
			//

			pPendRequest->RequestSendStatus = RequestSendStatusSendingHeaders;

			LISTENER_DBGPRINTF((
				"OnSocketRead!just called UlSendHttpRequestHeaders, setting status to %d",
				RequestSendStatusSendingHeaders ));

			//
			// now we can coalesce the entity body (or next request headers)
			// bytes left in the buffer (if any) copying them over the header
			// bytes in this buffer
			//

			if ( pBufferRead->dwBytesReceived > pBufferRead->dwBytesParsed )
			{
				//
				// if any, copy the data
				//
				
				LISTENER_DBGPRINTF((
					"OnSocketRead!Copying %d bytes from %08X to %08X",
					pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed,
					pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
					pBufferRead->pBuffer ));

				memcpy(
					pBufferRead->pBuffer,
					pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
					pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed );
			}

			//
			// and fix the buffer sizes
			//
						
			pBufferRead->dwBytesReceived -= pBufferRead->dwBytesParsed;
			pBufferRead->dwBytesParsed = 0;

			//
			// The request will get to the application and we will get
			// signaled on VXD_WRITE when the response comes in. we now have to
			// keep reading more data.
			//

			LISTENER_DBGPRINTF((
				"OnSocketRead!UlSendHttpRequestHeaders() pended with RequestId:%016X",
				pRequest->RequestId ));

			//
			// we don't need to break here, we'll just slide into the next
			// case clause
			//


        case ParseEntityBodyState:
        case ParseTrailerState:

			//
        	// we get here while we see the entity body pass through, either
        	// we're unchunking data or we're just making sure it's all there
        	//


			//
			// parse, unchunk, send entity body here
			//

			if ( pRequest->ParseState < ParseDoneState)
			{
				//
				// we get here if ParseEntityBodyState <= ParseState <= ParseTrailerState
				//
				
				// we get here, if we finished parsing the Headers, sent
				// succesfully data through the VxD, but are not done yet with
				// the request. this means, basically, that this request has
				// a non empty entity body. Part of this entity body may have
				// already been sent to the application in the first chunk, but
				// there's more data coming from the network

				// CODEWORK:

				// the amount of body that we will have to send could be known
				// or not at this time:
				// KNOWN
				// 1) Content-Length header specified
				// UNKNOWN and not empty (but we shouldn't be here in this case)
				// 1) <=HTTP/1.0 client and Content-Length header not specified.
				// 2) <=HTTP/1.1 client and Connection: close
				// 3) Transfer-Encoding: chunked

				while ( pRequest->ParseState != ParseDoneState )
				{
			        //
			        // call the parser again
			        //

					LISTENER_DBGPRINTBUFFERS( pPendRequest );

					dwStatus = ParseHttp(
						pRequest,
						pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
						pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed,
						&dwBytesTaken );

					LISTENER_DBGPRINTF((
						"OnSocketRead!ParseHttp() returns:%08X taken:%d "
						"ChunkBytesToParse:%d State:%s Error:%s",
						dwStatus,
						dwBytesTaken,
						pRequest->ChunkBytesToParse,
						LISTENER_STR_PARSE_STATE( pRequest->ParseState ),
						LISTENER_STR_UL_ERROR( pRequest->ErrorCode ) ));

		            //
		            // was there enough in the buffer to please?
		            //

					if ( NT_SUCCESS( dwStatus ) == FALSE
						&& dwStatus != STATUS_MORE_PROCESSING_REQUIRED )
				    {
				    	//
				        // some other bad error!
				        //

						LISTENER_DBGPRINTF((
							"OnSocketRead!ParseHttp() failed returning %08X",
							dwStatus ));

						pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

						goto stop_reading;
				    }

					if ( dwStatus == STATUS_MORE_PROCESSING_REQUIRED )
					{
						LISTENER_DBGPRINTF((
							"OnSocketRead!need more data to avoid token spanning" ));

						goto keep_reading;
					}

					if ( dwBytesTaken == 0 && pRequest->ChunkBytesToParse == 0 )
					{
						//
						// we're done data must be sent, and left overs copied
						// into new buffer
						//

						dwSize = LISTENER_BUFFER_SCKREAD_SIZE;

						LISTENER_DBGPRINTF((
							"OnSocketRead!send data" ));

						goto send_data;
					}

		            if ( pBufferRead->dwBytesParsed == pBufferRead->dwBytesReceived )
		            {
		            	//
		            	// we consumed all the data received from the network in this
		            	// buffer, we need 
		            	//

						LISTENER_DBGPRINTF((
							"OnSocketRead!keep reading" ));

		            	goto keep_reading;
		            }

		            //
		            // is there anything for us to parse?
		            //

		            if ( pRequest->ChunkBytesToParse > 0 )
		            {
		                //
		                // how much should we parse?
		                //

		                dwChunkSize = (ULONG) MIN(
		                		pRequest->ChunkBytesToParse,
			                	pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed );

		                //
		                // update that we parsed this piece
		                //

		                pRequest->ChunkBytesToParse -= dwChunkSize;
		                pRequest->ChunkBytesParsed += dwChunkSize;

		                if ( dwBytesTaken > 0 )
		                {
		                	//
		                	// if this is chunked encoding
		                	//

							//
							// coalesce data in the buffer, no risk of data
							// being overwritten
							//

							LISTENER_DBGPRINTF((
								"OnSocketRead!Copying %d bytes from %08X to %08X",
								pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed - dwBytesTaken,
								pBufferRead->pBuffer + pBufferRead->dwBytesParsed + dwBytesTaken,
								pBufferRead->pBuffer + pBufferRead->dwBytesParsed ));

							memcpy(
								pBufferRead->pBuffer + pBufferRead->dwBytesParsed,
								pBufferRead->pBuffer + pBufferRead->dwBytesParsed + dwBytesTaken,
								pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed - dwBytesTaken );
						}
						
		                pBufferRead->dwBytesParsed += dwChunkSize;
		            }

					pBufferRead->dwBytesReceived -= dwBytesTaken;
				}

				//
				// we're finally in ParseDoneState, we received and sent to the vxd
				// all the data in the entity body. if there has been pipelining or
				// we have a connection keep-alive, we must create a new request and
				// keep reading in it
				//
			}

			if ( pRequest->ParseState == ParseErrorState )
			{
				LISTENER_DBGPRINTF(( "OnSocketRead!something failed" ));

				pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

				goto stop_reading;
			}

			//
			// if we don't need more data from the network, and we're finsihed parsing
			// unchunking, we need to figure out if we need to close the connection
			// and stop reading or if we need to create a new request and keep reading
			// in it from the same connection, and, possibly, from the same data
			// already available because of pipelining
			//

			if ( pRequest->ParseState == ParseDoneState && pConnection->bKeepAlive )
			{
				//
				// we're finally done with this request and we need to keep
				// reading another one, since it's keep-alive
				// we need to initialize another
				// LISTENER_REQUEST structure and start reading data in it.
				//

				LISTENER_DBGPRINTF((
					"OnSocketRead!Finished parsing the Request (bKeepAlive:%d)",
					pConnection->bKeepAlive  ));

				//
				// If the client is pipelining, there may be some data remaining
				// in the buffer that we will have to copy to the new request
				// (pipelining). Prepare the next request for reading.
				// create another LISTENER_REQUEST record:
				//
				
				goto new_buffer;
			}

			LISTENER_DBGPRINTF((
				"OnSocketRead!trackig pBufferRead:%08X pBufferRead->pBuffer:%08X",
				pBufferRead, pBufferRead->pBuffer ));

        	goto send_data;


        case ParseDoneState:

        	//
        	// create a new request, copy data pending in new buffer (this will
        	// happen if the client is pipelining), if there's no more data
        	// read more, otherwise, keep looping
        	//

        	goto send_data;


		case ParseErrorState:
		default:

			// Illegal or malformed request. Close the connection.

			LISTENER_DBGPRINTF((
				"OnSocketRead!Illegal or malformed request (State:%s Error:%s). "
				"Closing connection",
				LISTENER_STR_PARSE_STATE( pRequest->ParseState ),
				LISTENER_STR_UL_ERROR( pRequest->ErrorCode ) ));

			pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

			goto stop_reading;

        } // switch ( pRequest->ParseState )

	} // for(;;)


send_data:

	//
	// send data to the vxd
	//

	LISTENER_DBGPRINTF((
		"OnSocketRead!buffer full pBufferRead:%08X, calling "
		"UlSendHttpRequestEntityBody(%08X, %d) pOverlapped:%08X hEvent:%08X",
		pBufferRead,
		pBufferRead->pBuffer,
		pBufferRead->dwBytesParsed,
		&pBufferRead->Overlapped,
		pBufferRead->Overlapped.hEvent ));

	dwError =
	UlSendHttpRequestEntityBody(
		pRequest->RequestId,
		0,
		(PVOID) pBufferRead->pBuffer,
		pBufferRead->dwBytesParsed,
		NULL,
		&pBufferRead->Overlapped );

	if ( dwError != ERROR_SUCCESS && GetLastError() != ERROR_IO_PENDING )
	{
		LISTENER_DBGPRINTF((
			"OnSocketRead!UlSendHttpRequestEntityBody() failed err:%d",
			GetLastError() ));

		pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

		goto stop_reading;
	}

new_buffer:

	//
	// we will get here when we need to allocate new memory and receive more
	// data from the network
	//

	dwBytesToCopyOffset = pBufferRead->dwBytesParsed;
	dwBytesToCopy = pBufferRead->dwBytesReceived - pBufferRead->dwBytesParsed;

	LISTENER_DBGPRINTF((
		"OnSocketRead!tracking pBufferRead:%08X dwBytesToCopyOffset:%d dwBytesToCopy:%d",
		pBufferRead, dwBytesToCopyOffset, dwBytesToCopy ));

	if ( pRequest->ParseState == ParseDoneState )
	{
		//
		// end sending request entity body
		//

		LISTENER_DBGPRINTF((
			"OnSocketRead!NULL UlSendHttpRequestEntityBody() ends body"
			" pOverlapped:%08X hEvent:%08X",
			&pPendRequest->OverlappedEOF,
			pPendRequest->OverlappedEOF.hEvent));

		dwError =
		UlSendHttpRequestEntityBody(
			pRequest->RequestId,
			0,
			NULL,
			0,
			NULL,
			&pPendRequest->OverlappedEOF );

		if ( dwError != ERROR_SUCCESS && GetLastError() != ERROR_IO_PENDING )
		{
			LISTENER_DBGPRINTF((
				"OnSocketRead!UlSendHttpRequestEntityBody() failed err:%d",
				GetLastError() ));

			pPendRequest->bFormatResponseBasedOnErrorCode = TRUE;

			goto stop_reading;
		}

		//
		// let's check if it's a keepalive, if it is we're done even if
		// there's more data lef otver or pending
		//

		if ( !pConnection->bKeepAlive )
		{
			goto stop_reading;
		}

		//
		// well, not only we need a new buffer, but we also need a new request
		//

		dwError =
		CreateRequest(
			pConnection,
			LISTENER_BUFFER_SCKREAD_SIZE );

		if ( dwError != LISTENER_SUCCESS )
		{
			goto stop_reading;
		}

		LISTENER_ASSERT( !IsListEmpty( &pConnection->PendRequestHead ) );

		pPendRequestNew =
	    CONTAINING_RECORD(
			pConnection->PendRequestHead.Blink,
			LISTENER_REQUEST,
			List );

		LISTENER_ASSERT( !IsListEmpty( &pPendRequestNew->BufferReadHead ) );

		pBufferReadNew =
	    CONTAINING_RECORD(
			pPendRequestNew->BufferReadHead.Blink,
			LISTENER_BUFFER_READ,
			List );

		pBufferReadNew->dwBufferSize = LISTENER_BUFFER_SCKREAD_SIZE;
		pBufferReadNew->dwBytesParsed = 0;
		// pBufferReadNew->dwBytesReceived = dwBytesToCopy;
	}
	else
	{
		//
		// create another LISTENER_BUFFER_READ record for this same request
		//

		LISTENER_DBGPRINTF((
			"OnSocketRead!new LISTENER_BUFFER_READ with %d bytes buffer",
			dwSize ));

		LISTENER_ASSERT( dwSize != 0 && pBufferReadNew == NULL );

		LISTENER_ALLOCATE(
			LISTENER_BUFFER_READ*,
			pBufferReadNew,
			sizeof( LISTENER_BUFFER_READ ),
			pConnection );

		if ( pBufferReadNew == NULL )
		{
			LISTENER_DBGPRINTF((
				"OnSocketRead!FAILED memory allocation: err#%d",
				GetLastError() ));
				
			return LISTENER_GARBAGE_COLLECT;
		}

		LISTENER_ALLOCATE(
			PUCHAR,
			pBufferReadNew->pBuffer,
			dwSize,
			pConnection );

		if ( pBufferReadNew->pBuffer == NULL )
		{
			LISTENER_DBGPRINTF((
				"OnSocketRead!FAILED memory allocation: err#%d",
				GetLastError() ));
				
			return LISTENER_GARBAGE_COLLECT;
		}

		pBufferReadNew->dwBufferSize = dwSize;
		pBufferReadNew->dwBytesParsed = 0;
		// pBufferReadNew->dwBytesReceived = dwBytesToCopy;

		memset( &pBufferReadNew->Overlapped, 0, sizeof( OVERLAPPED ) );
		pBufferReadNew->Overlapped.hEvent = pBufferRead->Overlapped.hEvent;
	}


	//
	// we have the new buffer
	//

	LISTENER_DBGPRINTF((
		"OnSocketRead!LISTENER_BUFFER_READ pBufferReadNew:%08X "
		"pBufferReadNew->pBuffer:%08X size:%d",
		pBufferReadNew, pBufferReadNew->pBuffer, pBufferReadNew->dwBufferSize ));

	//
	// CODEWORK: if the new buffer is for another request, then we can allocate
	// a new buffer of exactly the size of the data consumed and put that in
	// the queue of the buffers of the current request, using the one already
	// allocated for the new request, thus saving lots of memory space
	//

	//
	// now move leftover/unparsed data from the old buffer into the new one
	//

	if ( dwBytesToCopy != 0 )
	{
		LISTENER_DBGPRINTF((
			"OnSocketRead!Copying %d bytes from %08X to %08X",
			dwBytesToCopy,
			pBufferRead->pBuffer + dwBytesToCopyOffset,
			pBufferReadNew->pBuffer ));

		memcpy(
			pBufferReadNew->pBuffer,
			pBufferRead->pBuffer + dwBytesToCopyOffset,
			dwBytesToCopy );

		//
		// fix pBufferRead->dwBytesReceived
		//

		pBufferRead->dwBytesReceived -= dwBytesToCopy;

		if ( pBufferRead->dwBytesReceived == 0 )
		{
			//
			// if the last buffer from the old request is empty,
			// we might as well get rid of it.
			//

			RemoveEntryList( &pBufferRead->List );

			BufferReadCleanup(
				pBufferRead,
				pConnection );
		}

		//
		// I need to reset the number of bytes read, otherwise the next
		// call to WSAGetOverlappedResult() will return wrong info.
		//

		pConnection->pOverlapped[LISTENER_SOCKET_READ].Internal
			= 0;//ERROR_IO_PENDING;

		pConnection->pOverlapped[LISTENER_SOCKET_READ].InternalHigh
			= dwBytesToCopy;

		//
		// Exit (but we will be called again)
		//

		LISTENER_DBGPRINTF((
			"OnSocketRead!Looping, please LISTENER_CALL_ME_AGAIN" ));

		return LISTENER_CALL_ME_AGAIN;
	}

	if ( pBufferRead->dwBytesReceived == 0 )
	{
		//
		// even if no data was copied and the last buffer from the old request
		// is empty, we might as well get rid of it.
		// this will happen when the buffer ends iwth the request
		//

		RemoveEntryList( &pBufferRead->List );

		BufferReadCleanup(
			pBufferRead,
			pConnection );
	}

	pBufferRead = pBufferReadNew;


keep_reading:

	// At this point pBufferRead contains the buffer we should read from,
	// and all the inofrmation on IO should be up to date.

	LISTENER_DBGPRINTF((
		"OnSocketRead!calling ReceiveData(%08X,%08X,%08X)",
		pConnection->socket,
		pBufferRead->pBuffer + pBufferRead->dwBytesReceived,
		pBufferRead->dwBufferSize - pBufferRead->dwBytesReceived ));

	dwError =
	ReceiveData(
		pConnection->socket,
		pBufferRead->pBuffer + pBufferRead->dwBytesReceived,
		pBufferRead->dwBufferSize - pBufferRead->dwBytesReceived,
		pConnection->pOverlapped + LISTENER_SOCKET_READ );

	if ( dwError != LISTENER_SUCCESS )
	{
		LISTENER_DBGPRINTF((
			"OnSocketRead!ReceiveData() failed err:%d", dwError ));
			
		return dwError;
	}

	return LISTENER_SUCCESS;

stop_reading:

	// Careful, if we get here, it means that we are not coming
	// back to this function anymore, so we re not going to be able to read
	// data from the client on this connection anymore: as soon as we finished
	// writing to the socket we will close the connection.

	// CODEWORK: any failure to allocate memory shows serious problems on the
	// server, so stop_reading is probably the right choice.

	// CODEWORK: network serious problems could require disconnecting,
	// regardless all the pending Socket Sends and VxD Sends/Receives.
	// LISTENER_ABORT_CONNECTION ???

	// CODEWORK: change goto stop_reading; to return LISTENER_STOP_READING;

	// we already have a response for this request.

	// if this is the only request for this connection we could fake a
	// VxdRead I/O and let OnVxdRead() take care of sending the response and
	// clean the connection, or we could do it here (try the first approach)
	// if this is not the only request, then OnVxdRead() will be certainly
	// called at a later time because of responses being read, and it will
	// automatically discover that this request has a response, send it and
	// close the connection for us.

	pConnection->bKeepAlive = FALSE;

	return LISTENER_STOP_READING;
	
} // OnSocketRead







/*++

Routine Description:

    OnVxdWrite().

Arguments:

    pConnection
    	pointer to the LISTENER_CONNECTION structure that contains information
    	on the connection with which we are dealing.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
OnVxdWrite(
	LISTENER_CONNECTION *pConnection )
{
	LISTENER_REQUEST *pPendRequest;
	LIST_ENTRY *pPendRequestList;
	LISTENER_BUFFER_READ *pBufferRead = NULL;

	OVERLAPPED *pOverlapped;
	DWORD dwError, dwStatus, dwBytesSent;
	BOOL bOK;

	//
	// we get here after asynchronous completion of one or more calls to
	// UlSendHttpRequestHeaders()
	// (the client has just least read all the headers)
	// or UlSendHttpRequestEntityBody()
	// (the client has just read a chunk of entity body)
	//

	//
	// there's not much to do here, we'll just validate the IO and make sure
	// everything is going fine, the only important case is when
	// UlSendHttpRequestHeaders() completes, in this case, we must call
	// UlReceiveHttpResponseHeaders() to start receiving the response from the
	// vxd
	//

	//
	// our writes are in a queue, we know that the first one in the queue
	// completed, but we're not sure about the other ones, so we must walk the
	// queue until we find an IO which didn't complete
	//
	
	//
	// figure out which request we're dealing with, start from the head of the
	// queue (oldest request) and then go in an infinite loop that will end either
	// when we reach the head of the list again (error) or when we find the right
	// request, which is the first request that has not been completed yet.
	//

	pPendRequestList = pConnection->PendRequestHead.Flink;

	LISTENER_DBGPRINTF((
		"OnVxdWrite!vxd I/O for socket %08X, pPendRequestList:%08X",
		pConnection->socket, pPendRequestList ));

	for (;;)
	{
		//
		// figure out which one is the request that was added first
		// if there are no more requests for this connection just return
		//
		
		if ( pPendRequestList == &pConnection->PendRequestHead )
		{
			LISTENER_DBGPRINTF((
				"OnVxdWrite!No more queued requests, exiting" ));
				
			return LISTENER_SUCCESS;
		}

		//
		// otherwise get the request that was added first
		//

		pPendRequest =
	    CONTAINING_RECORD(
			pPendRequestList,
			LISTENER_REQUEST,
			List );

		//
		// and move to the next one
		//
		
		pPendRequestList = pPendRequestList->Flink;

		LISTENER_DBGPRINTF((
			"OnVxdWrite!pPendRequest:%08X bFormatResponseBasedOnErrorCode:%d "
			"bDoneReadingFromVxd:%d bKeepAlive:%d RequestId:%016X",
			pPendRequest,
			pPendRequest->bFormatResponseBasedOnErrorCode,
			pPendRequest->bDoneReadingFromVxd,
			pConnection->bKeepAlive,
			pPendRequest->pRequest->RequestId ));

		//
		// skip this request if the status allows for it
		//

		if ( pPendRequest->pRequest->RequestId == 0 )
		{
			LISTENER_DBGPRINTF((
				"OnVxdWrite!premature RequestSendStatus RequestId is 0, skipping" ));

			continue;
		}

		if ( pPendRequest->bDoneWritingToVxd )
		{
			LISTENER_DBGPRINTF((
				"OnVxdWrite!this request has bDoneWritingToVxd, skipping" ));

			continue;
		}

		//
		// understand if the state is consistent
		//

		pOverlapped = NULL;

		switch ( pPendRequest->RequestSendStatus )
		{

		case RequestSendStatusSendingHeaders:

			pOverlapped = &pPendRequest->OverlappedBOF;

			break;


		case RequestSendStatusSendingBody:

			//
			// if I'm writing the entity body (if I have any to write),
			// this list will better not be empty
			//

			LISTENER_ASSERT( !IsListEmpty( &pPendRequest->BufferReadHead ) );

			//
			// the buffer we were trying to write will be the one that was
			// added first, i.e. the one at the beginning of the list, so go
			// forward and pick it up
			//

			pBufferRead =
		    CONTAINING_RECORD(
				pPendRequest->BufferReadHead.Flink,
				LISTENER_BUFFER_READ,
				List );

			pOverlapped = &pBufferRead->Overlapped;

			break;


		case RequestSendStatusDone:

			pOverlapped = &pPendRequest->OverlappedEOF;

			break;


		case RequestSendStatusInitialized:
		case RequestSendStatusCompleted:

			LISTENER_DBGPRINTF((
				"OnVxdWrite!too late or too early for this request, skipping" ));

			break; // continue;


		case RequestSendStatusUndefined:
		case RequestSendStatusMaximum:
		default:

			LISTENER_DBGPRINTF((
				"OnVxdWrite!invalid RequestSendStatus" ));

			return LISTENER_GARBAGE_COLLECT;
		}


		//
		// if no IO could have happened for this request, we'll not even
		// call UlGetOverlappedResult()
		//

		LISTENER_DBGPRINTF((
			"OnVxdWrite!pPendRequest:%08X is in state:%d, pOverlapped:%08X",
			pPendRequest, pPendRequest->RequestSendStatus, pOverlapped ));

		if ( pOverlapped == NULL )
		{
			LISTENER_DBGPRINTF((
				"OnVxdWrite!too early for this request (pOverlapped is NULL) skipping" ));

			continue;
		}

		//
		// find out what happened to the IO
		//

		LISTENER_DBGPRINTF((
			"OnVxdWrite!calling UlGetOverlappedResult(pOverlapped:%08X)",
			pOverlapped ));

		bOK = UlGetOverlappedResult(
			pOverlapped,
			&dwBytesSent,
			FALSE );

		if ( !bOK )
		{
			dwError = GetLastError();

			if ( dwError == ERROR_IO_INCOMPLETE )
			{
				//
				// this IO is incomplete, keep checking
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!UlGetOverlappedResult() failed: "
					"ERROR_IO_INCOMPLETE" ));
					
				continue; // return LISTENER_SUCCESS;
			}
			else
			{
				//
				// Get rid of this, it's a bad connection anyway.
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!UlGetOverlappedResult(%d) failed: err:%d",
					dwBytesSent, dwError ));

				return LISTENER_GARBAGE_COLLECT;
			}
		}

		LISTENER_DBGPRINTF((
			"OnVxdWrite!UlGetOverlappedResult() %d bytes were transferred",
			dwBytesSent ));

		//
		// since we passed the previous switch statement, the status is valid
		//

		switch ( pPendRequest->RequestSendStatus )
		{

		case RequestSendStatusSendingHeaders:

			//
			// assert that the call to UlSendHttpRequestHeaders() completed
			//

			LISTENER_ASSERT( pPendRequest->pRequestHeadersBuffer != NULL );

			//
			// check that the IO transferred the correct amount of data
			//

			if ( dwBytesSent != pPendRequest->ulRequestHeadersBufferSize )
			{
				//
				// something didn't go as expected I'm dropping the connection
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!I was expecting %d bytes to be transferred",
					pPendRequest->ulRequestHeadersBufferSize ));

				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// next step is to start reading the response from the VxD
			// we might not read everything the first time, but we will
			// pass in the Event handle that will be signaled when the
			// client will start writing the response to us. There we
			// will actually find out how much data is available and
			// if the buffer was not big enough we'll read it all together.
			//

			memset( pPendRequest->pRequestHeadersBuffer, 0, pPendRequest->ulRequestHeadersBufferSize );

			pPendRequest->pUlResponse = (UL_HTTP_RESPONSE*)pPendRequest->pRequestHeadersBuffer;
			pPendRequest->ulUlResponseSize = pPendRequest->ulRequestHeadersBufferSize;

			pPendRequest->pRequestHeadersBuffer = NULL;
			pPendRequest->ulRequestHeadersBufferSize = 0;

			LISTENER_DBGPRINTF((
				"OnVxdWrite!calling UlReceiveHttpResponseHeaders("
				"pBuffer:%08X, ulBufferSize:%d) pOverlapped:%08X hEvent:%08X)",
				pPendRequest->pUlResponse,
				pPendRequest->ulUlResponseSize,
				&pPendRequest->OverlappedResponseBOF,
				pPendRequest->OverlappedResponseBOF.hEvent ));

			dwError =
			UlReceiveHttpResponseHeaders(
				pPendRequest->pRequest->RequestId,
				0,
				pPendRequest->pUlResponse,
				pPendRequest->ulUlResponseSize,
				0,
				NULL,
				NULL,
				NULL,
				&pPendRequest->OverlappedResponseBOF );

			//
			// many errors can happen here, let's assume that if the
			// vxd fails we send an error response and close the
			// connection. CODEWORK: specialize behaviour (response)
			//

			if ( dwError != ERROR_SUCCESS
				&& GetLastError() != ERROR_IO_PENDING )
			{
				//
				// CODEWORK: UlSendResponseWin9x();
				// let's just drop the connection for now:
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!UlReceiveHttpResponseHeaders() failed err:%d",
					GetLastError() ));

				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// update the state
			//

			pPendRequest->ResponseReceiveStatus = ResponseReceiveStatusReceivingHeaders;

			pPendRequest->RequestSendStatus =

				IsListEmpty( &pPendRequest->BufferReadHead ) ?

				RequestSendStatusDone
				:
				RequestSendStatusSendingBody;
				

			LISTENER_DBGPRINTF((
				"OnVxdWrite!just called UlReceiveHttpResponseHeaders, setting status to %d",
				pPendRequest->RequestSendStatus ));

			//
			// since we updated the state, let's keep investigating the same
			// request's IO for completion
			//

			pPendRequestList = pPendRequestList->Blink;

			break;


		case RequestSendStatusSendingBody:

			//
			// a call to UlSendHttpRequestEntityBody() completed
			//

			//
			// check that the IO transferred the correct amount of data
			//

			if ( dwBytesSent != pBufferRead->dwBytesParsed )
			{
				//
				// something didn't go as expected I'm dropping the connection
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!I was expecting %d bytes to be transferred from %08X",
					pBufferRead->dwBytesParsed, pBufferRead->pBuffer ));

				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// I can free the buffer
			//

			RemoveEntryList( &pBufferRead->List );

			BufferReadCleanup(
				pBufferRead,
				pConnection );

			//
			// update the state
			//

			LISTENER_DBGPRINTF((
				"OnVxdWrite!setting pPendRequest->bDoneWritingToVxd to TRUE" ));

			pPendRequest->bDoneWritingToVxd = TRUE;

			LISTENER_DBGPRINTF((
				"OnVxdWrite!completed UlSendHttpRequestEntityBody() setting status to %d",
				RequestSendStatusDone ));

			pPendRequest->RequestSendStatus = RequestSendStatusDone;

			break;


		case RequestSendStatusDone:

			//
			// the NULL UlSendHttpRequestEntityBody() which indicates the end
			// of the request body completed, we're done sending the request
			// shall we send the next one?
			//

			//
			// check that the IO transferred the correct amount of data
			//

			if ( dwBytesSent != 0 )
			{
				//
				// something didn't go as expected I'm dropping the connection
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!I was expecting %d bytes to be transferred",
					0 ));

				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// now we can free all the Read buffers allocated
			//

			LISTENER_DBGPRINTF((
				"OnVxdWrite!all request is sent pPendRequest:%08X",
				pPendRequest ));

			if ( pPendRequest->bDoneReadingFromVxd && pPendRequest->bDoneWritingToSocket )
			{
				LISTENER_DBGPRINTF((
					"OnVxdWrite!we're done with this request. Cleaning up"
					" pPendRequest:%08X",
					pPendRequest ));

				RemoveEntryList( &pPendRequest->List );

				RequestCleanup(
					pPendRequest,
					pConnection );
			}
			else
			{
				//
				// update the state
				//

				LISTENER_DBGPRINTF((
					"OnVxdWrite!setting pPendRequest->bDoneWritingToVxd to TRUE" ));

				pPendRequest->bDoneWritingToVxd = TRUE;

				LISTENER_DBGPRINTF((
					"OnVxdWrite!completed UlSendHttpRequestEntityBody(0) setting status to %d",
					RequestSendStatusCompleted ));

				pPendRequest->RequestSendStatus = RequestSendStatusCompleted;
			}

			break;
		}

	} // for (;;)


	//
	// if we didn't complete sending the whole Request Entity Body
	// keep calling UlSendHttpRequestEntityBody() until the body is
	// finished
	//

	return LISTENER_SUCCESS;

} // OnVxdWrite








/*++

Routine Description:

    OnVxdRead().

Arguments:

    pConnection
    	pointer to the LISTENER_CONNECTION structure that contains information
    	on the connection with which we are dealing.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
OnVxdRead(
	LISTENER_CONNECTION *pConnection )
{
	LISTENER_REQUEST *pPendRequest = NULL, *pPendRequestPrev;
	LIST_ENTRY *pPendRequestList, *pBufferWriteList;
	LISTENER_BUFFER_WRITE *pBufferWrite = NULL;

	OVERLAPPED *pOverlapped;
	DWORD dwFlags = LISTENER_SOCKET_FLAGS;
	DWORD dwError, dwStatus, dwExpectedSize, dwSize, dwBytesReceived;
	BOOL bOK, bFirstQueued = TRUE;
	int result;

	// we get here every time some process is sending a response
	// back to a client. the vxd will not (yet) pipeline responses
	// so the pending data will be either a first chunk that
	// includes ALL of the headers and optionally part of or the
	// entire body (if this is small and the size does not exceed
	// LISTENER_BUFFER_VXDREAD_SIZE) or part of the body of size
	// up to LISTENER_BUFFER_VXDREAD_SIZE.

	// we also might get here after an error occurred and we were able to
	// figure out a response without having to send data, in this case the
	// first_in request will have the bFormatResponseBasedOnErrorCode flag set
	
	// of course, there's no guarantee that the data I'm reading here will be
	// part of the response to the first LISTENER_REQUEST in the list pointed
	// by PendRequestHead for this connection. so I'll have to use some
	// payload in each buffer that is sent through the VxD in order to fit in
	// a RequestId

	pPendRequestList = pConnection->PendRequestHead.Flink;

	LISTENER_DBGPRINTF((
		"OnVxdRead!vxd I/O for socket %08X, pPendRequestList:%08X",
		pConnection->socket, pPendRequestList ));

	for (;;)
	{
		//
		// figure out which one is the request that was added first
		// if there are no more requests for this connection just return
		//
		
		if ( pPendRequestList == &pConnection->PendRequestHead )
		{
			LISTENER_DBGPRINTF((
				"OnVxdRead!No more queued requests, exiting" ));
				
			return LISTENER_SUCCESS;
		}

		//
		// save a pointer to the previous request (will be null if this is
		// the first in the queue)
		//

		pPendRequestPrev = pPendRequest;

		if ( pPendRequestPrev != NULL && pPendRequestList != pConnection->PendRequestHead.Flink )
		{
			//
			// if this is not the first request in the queue we will be able
			// to send data on the network only if:
			//

			bFirstQueued &= pPendRequestPrev->bDoneReadingFromVxd;

			// bFirstQueued &= pPendRequestPrev->bDoneWritingToSocket;
		}

		//
		// get the request
		//

		pPendRequest =
	    CONTAINING_RECORD(
			pPendRequestList,
			LISTENER_REQUEST,
			List );

		//
		// and move to the next one
		//
		
		pPendRequestList = pPendRequestList->Flink;

		LISTENER_DBGPRINTF((
			"OnVxdRead!pPendRequest:%08X bFirstQueued:%d bFormatResponseBasedOnErrorCode:%d "
			"bDoneReadingFromVxd:%d bKeepAlive:%d RequestId:%016X",
			pPendRequest,
			bFirstQueued,
			pPendRequest->bFormatResponseBasedOnErrorCode,
			pPendRequest->bDoneReadingFromVxd,
			pConnection->bKeepAlive,
			pPendRequest->pRequest->RequestId ));


		if ( pPendRequest->bFormatResponseBasedOnErrorCode && bFirstQueued )
		{
			//
			// the event was not signaled by an I/O with the VxD, we just have to
			// format the response based on the UL_HTTP_RESPONSE structure and
			// send it off to sockets, complete this LISTENER_REQUEST and get rid
			// of it, close the connection if it's !bKeepAlive and start reading
			// data for the next LISTENER_REQUEST (if there is one)
			//

			SendQuickHttpResponse(
				pConnection->socket,
				TRUE,
				pPendRequest->pRequest->ErrorCode );

			LISTENER_DBGPRINTF((
				"OnVxdRead!SendQuickHttpResponse() completed for %08X",
				pPendRequest ));

			if ( pConnection->bKeepAlive == FALSE )
			{
				// this will close the connection and garbage collect

				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// otherwise we have to just free the LISTENER_REQUEST structure
			// and check if there are other LISTENER_REQUEST that need to read
			// data from the VxD or to send a response
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!Cleaning up %08X",
				pPendRequest ));

			RemoveEntryList( &pPendRequest->List );

			RequestCleanup(
				pPendRequest,
				pConnection );

			pPendRequest = NULL;

			//
			// and go to the next request
			//

			continue;
		}

		if ( pPendRequest->pRequest->RequestId == 0 )
		{
			LISTENER_DBGPRINTF((
				"OnVxdRead!premature RequestSendStatus RequestId is 0, skipping" ));

			continue;
		}

		if ( pPendRequest->bDoneReadingFromVxd )
		{
			LISTENER_DBGPRINTF((
				"OnVxdRead!this request has bDoneReadingFromVxd, skipping" ));

			continue;
		}


		//
		// understand if the state is consistent
		//

		pBufferWriteList = NULL;
		pBufferWrite = NULL;
		pOverlapped = NULL;

		switch ( pPendRequest->ResponseReceiveStatus )
		{

		case ResponseReceiveStatusReceivingHeaders:

			pOverlapped = &pPendRequest->OverlappedResponseBOF;

			break;


		case ResponseReceiveStatusReceivingBody:

			//
			// if I'm reading the entity body (if I have any to read),
			// this list will better not be empty
			//

			LISTENER_ASSERT( !IsListEmpty( &pPendRequest->BufferWriteHead ) );

			//
			// we already read the response headers the data we just read from the
			// vxd is part of the entity body. figure out the buffer and fix
			// the dwBytesSent field
			// to figure out the right buffer we must walk the list until we hit
			// the first one that was not sent on the network yet
			//

			pBufferWriteList = pPendRequest->BufferWriteHead.Flink;

			for (;;)
			{
				//
				// if we reach the end of the list without finding a buffer,
				// something's really bad
				//
				
				if ( pBufferWriteList == &pPendRequest->BufferWriteHead ) 
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!couldn't find a write buffer something's bad" ));

					return LISTENER_GARBAGE_COLLECT;
				}

				pBufferWrite =
			    CONTAINING_RECORD(
					pBufferWriteList,
					LISTENER_BUFFER_WRITE,
					List );

				if ( !pBufferWrite->bBufferSent )
				{
					//
					// found the right buffer
					//

					break;
				}

				//
				// try the next buffer in the queue
				//
				
				pBufferWriteList = pBufferWriteList->Flink;

			} // for (;;)

			LISTENER_DBGPRINTF((
				"OnVxdRead!ResponseReceiveStatusReceivingBody pBufferWrite:%08X",
				pBufferWrite ));

			pOverlapped = &pBufferWrite->OverlappedResponse;

			break;


		case ResponseReceiveStatusInitialized:
		case ResponseReceiveStatusCompleted:

			LISTENER_DBGPRINTF((
				"OnVxdRead!too late or too early for this request, skipping" ));

			break; // continue;


		case ResponseReceiveStatusUndefined:
		case ResponseReceiveStatusMaximum:
		default:

			LISTENER_DBGPRINTF((
				"OnVxdRead!invalid ResponseReceiveStatus" ));

			return LISTENER_GARBAGE_COLLECT;

		}

		//
		// if no IO could have happened for this request, we'll not even
		// call UlGetOverlappedResult()
		//

		LISTENER_DBGPRINTF((
			"OnVxdRead!pPendRequest:%08X is in ResponseReceiveStatus:%d pOverlapped:%08X",
			pPendRequest, pPendRequest->ResponseReceiveStatus, pOverlapped ));

		if ( pOverlapped == NULL )
		{
			LISTENER_DBGPRINTF((
				"OnVxdRead!too early for this request (pOverlapped is NULL) skipping" ));

			continue;
		}

		//
		// find out what happened to the IO
		//

		LISTENER_DBGPRINTF((
			"OnVxdRead!calling UlGetOverlappedResult(pOverlapped:%08X)",
			pOverlapped ));

		bOK = UlGetOverlappedResult(
			pOverlapped,
			&dwBytesReceived,
			FALSE );

		if ( !bOK )
		{
			dwError = GetLastError();

			if ( dwError == ERROR_IO_INCOMPLETE )
			{
				//
				// this IO is incomplete, keep checking
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!UlGetOverlappedResult() failed: "
					"ERROR_IO_INCOMPLETE" ));

				continue; // return LISTENER_SUCCESS;
			}
			else
			{
				//
				// Get rid of this, it's a bad connection anyway.
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!UlGetOverlappedResult(%d) failed: err:%d",
					dwBytesReceived, dwError ));

				return LISTENER_GARBAGE_COLLECT;
			}
		}

		LISTENER_DBGPRINTF((
			"OnVxdRead!UlGetOverlappedResult() %d bytes were transferred",
			dwBytesReceived ));

		//
		// since we passed the previous switch statement
		// the status is now valid
		//

		switch ( pPendRequest->ResponseReceiveStatus )
		{

		case ResponseReceiveStatusReceivingHeaders:

			//
			// completion of UlReceiveHttpResponseHeaders() took us here, read
			// the response headers and then start reading the body and
			// write the data to the network
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!response headers just read from the vxd bFirstQueued:%d",
				bFirstQueued ));

			if ( !bFirstQueued )
			{
				//
				// too early to send data on the network for this request,
				// skip it for now, until it reaches the top of the queue
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!too early for this request, wait till it "
					"reaches the top of the queue, skipping" ));

				continue;
			}

			//
			// check if the buffer provided was big enough to fit the whole
			// response headers, if not we need to grow it to the appropriate
			// size and call UlReceiveHttpResponseHeaders() agaian
			//

			if ( dwBytesReceived > pPendRequest->ulUlResponseSize )
			{
				//
				// grow the buffer
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!buffer was too small, grow it and try again" ));

				//
				// free the old buffer
				//
				
				if ( pPendRequest->pUlResponse == NULL )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!something's wrong, this should be NULL" ));

					return LISTENER_GARBAGE_COLLECT;
				}

				//
				// free the buffer
				//

				LISTENER_FREE(
					pPendRequest->pUlResponse,
					pPendRequest->ulUlResponseSize,
					pConnection );

				pPendRequest->ulUlResponseSize = 0;

				//
				// allocate the new one
				//

				LISTENER_ALLOCATE(
					UL_HTTP_RESPONSE*,
					pPendRequest->pUlResponse,
					dwSize,
					pConnection );

				if ( pPendRequest->pUlResponse == NULL )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!memory allocation failed. cleaning up connection" ));

					return LISTENER_GARBAGE_COLLECT;
				}

				pPendRequest->ulUlResponseSize = dwSize;

				//
				// call UlReceiveHttpResponseHeaders() again
				//

				LISTENER_ASSERT(
					pPendRequest->ResponseReceiveStatus
					== ResponseReceiveStatusReceivingHeaders );

				LISTENER_DBGPRINTF((
					"OnVxdRead!calling again UlReceiveHttpResponseHeaders("
					"pBuffer:%08X, ulBufferSize:%d) pOverlapped:%08X hEvent:%08X",
					pPendRequest->pUlResponse,
					pPendRequest->ulUlResponseSize,
					pPendRequest->OverlappedResponseBOF,
					pPendRequest->OverlappedResponseBOF.hEvent ));

				dwError =
				UlReceiveHttpResponseHeaders(
					pPendRequest->pRequest->RequestId,
					0,
					pPendRequest->pUlResponse,
					pPendRequest->ulUlResponseSize,
					0,
					NULL,
					NULL,
					NULL,
					&pPendRequest->OverlappedResponseBOF );

				if ( dwError != ERROR_SUCCESS
					&& GetLastError() != ERROR_IO_PENDING )
				{
					// CODEWORK: UlSendResponseWin9x();

					// let's just drop the connection for now:

					LISTENER_DBGPRINTF((
						"OnVxdRead!UlReceiveHttpResponseHeaders() failed err:%d",
						GetLastError() ));

					return LISTENER_GARBAGE_COLLECT;
				}

				continue;
			}

			//
			// CODEWORK: looks like the vxd Sets the event but it doesn't
			// get Reset by the system even though it's created as
			// autoreset... BUGBUG?
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!buffer was ok, unparsing headers" ));

			ResetEvent(
				pConnection->pOverlapped[LISTENER_VXD_READ].hEvent );

			//
			// fix the offsets to be actual pointers:
			//
			
			FixUlHttpResponse( pPendRequest->pUlResponse );

			//
			// find out about the UL_HTTP_RESPONSE structure
			//

			pPendRequest->ResponseContentLength =
				ContentLengthFromHeaders(
					pPendRequest->pUlResponse->Headers.pKnownHeaders );

			if ( pPendRequest->ResponseContentLength != -1 )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!ContentLength was set in the headers: %I64u",
					pPendRequest->ResponseContentLength ));
			}

			//
			// CODEWORK:
			// check if the HTTP Response is valid according to the Request and
			// the protocol specifications
			//

			//
			// Now that we have the Response structure parsed and valid, we are
			// ready to start writing the response back to the socket.
			// I'll create a single buffer for the headers and then figure out
			// how to send the body.
			//

			dwSize = ResponseFormat(
				pPendRequest->pUlResponse,
				pPendRequest->pRequest,
				pPendRequest->pReqBodyChunk,
				pPendRequest->ulReqBodyChunkSize,
				NULL,
				0 );

			if ( dwSize == -1 )
			{
				// couldn't format
				LISTENER_DBGPRINTF((
					"OnVxdRead!ResponseFormat() failed" ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			LISTENER_DBGPRINTF((
				"OnVxdRead!ResponseFormat() requires %d bytes",
				dwSize ));

			//
			// Create the first LISTENER_BUFFER_WRITE record
			//

			LISTENER_ALLOCATE(
				LISTENER_BUFFER_WRITE*,
				pBufferWrite,
				sizeof( LISTENER_BUFFER_WRITE ),
				pConnection );

			if ( pBufferWrite == NULL )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!FAILED memory allocation: "
					"err#%d",
					GetLastError() ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// Add this to the list of LISTENER_BUFFER_WRITE records
			//

			InsertTailList(
				&pPendRequest->BufferWriteHead, &pBufferWrite->List );

			LISTENER_ALLOCATE(
				PUCHAR,
				pBufferWrite->pBuffer,
				dwSize,
				pConnection );

			if ( pBufferWrite->pBuffer == NULL )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!FAILED memory allocation: "
					"err#%d",
					GetLastError() ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			pBufferWrite->dwBytesSent = dwSize;
			pBufferWrite->dwBufferSize = dwSize;
			pBufferWrite->bBufferSent = FALSE;
			memset( &pBufferWrite->Overlapped, 0, sizeof( OVERLAPPED ) );
			memset( &pBufferWrite->OverlappedResponse, 0, sizeof( OVERLAPPED ) );
			pBufferWrite->Overlapped.hEvent =
				pConnection->pOverlapped[LISTENER_SOCKET_WRITE].hEvent;
			pBufferWrite->OverlappedResponse.hEvent =
				pConnection->pOverlapped[LISTENER_VXD_READ].hEvent;

			dwExpectedSize = ResponseFormat(
				pPendRequest->pUlResponse,
				pPendRequest->pRequest,
				pPendRequest->pReqBodyChunk,
				pPendRequest->ulReqBodyChunkSize,
				pBufferWrite->pBuffer,
				dwSize );

			LISTENER_ASSERT(
				!pBufferWrite->bBufferSent &&
				dwExpectedSize == dwSize &&
				pPendRequest->pUlResponse != NULL &&
				pPendRequest->pRequestHeadersBuffer == NULL &&
				pPendRequest->ulRequestHeadersBufferSize == 0 );

			//
			// we need to reset the event at this point to make sure that
			// we will not miss the IO completion event signaling
			//

			ResetEvent( pBufferWrite->Overlapped.hEvent );

			//
			// and now call WSASend()
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!sending %d bytes, response headers pBufferWrite:%08X pBuffer:%08X",
				dwSize, pBufferWrite, pBufferWrite->pBuffer ));

			dwError =
			SendData(
				pConnection->socket,
				pBufferWrite->pBuffer,
				pBufferWrite->dwBytesSent,
				&pBufferWrite->Overlapped );

			if ( dwError != LISTENER_SUCCESS )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!SendData() failed err:%d",
					dwError ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// remember that this buffer is being sent on the wire
			// we will free it when the IO completes in OnSocketWrite()
			//

			pBufferWrite->bBufferSent = TRUE;

			//
			// setting pBufferWrite to NULL marks computation so that we will
			// allocate a new write buffer to start reading the entity body
			//

			pBufferWrite = NULL;

			//
			// update state
			//

			pPendRequest->ResponseReceiveStatus	= ResponseReceiveStatusReceivingBody;

			break;


		case ResponseReceiveStatusReceivingBody:

			//
			// we're reading the response entity body
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!the %d bytes are part of the response entity body",
				dwBytesReceived ));

			if ( dwBytesReceived == 0 )
			{
				//
				// we're here but no data was sent, the response is over!!
				// set bDone to TRUE
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!response is over" ));

				LISTENER_ASSERT( !IsListEmpty( &pPendRequest->BufferWriteHead ) );

				pBufferWrite =
			    CONTAINING_RECORD(
					pPendRequest->BufferWriteHead.Blink,
					LISTENER_BUFFER_WRITE,
					List );

				if ( pBufferWrite == NULL )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!something's wrong here, shouldn't be NULL" ));

					return LISTENER_GARBAGE_COLLECT;
				}

				//
				// flush any pending data on the network
				//

				if( !pBufferWrite->bBufferSent )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!flushing pBufferWrite:%08X to socket %d bytes, pBuffer:%08X",
						pBufferWrite, pBufferWrite->dwBytesSent, pBufferWrite->pBuffer ));

					dwError =
					SendData(
						pConnection->socket,
						pBufferWrite->pBuffer,
						pBufferWrite->dwBytesSent,
						&pBufferWrite->Overlapped );

					if ( dwError != LISTENER_SUCCESS )
					{
						LISTENER_DBGPRINTF((
							"OnVxdRead!SendData() failed err:%d",
							dwError ));
							
						return LISTENER_GARBAGE_COLLECT;
					}

					//
					// remember that this buffer is being sent on the wire
					// we will free it when the IO completes in OnSocketWrite()
					//

					pBufferWrite->bBufferSent = TRUE;
				}

				//
				// update the state
				//

				if ( pPendRequest->bDoneWritingToVxd && pPendRequest->bDoneWritingToSocket )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!we're done with this request. Cleaning up"
						" pPendRequest:%08X",
						pPendRequest ));

					RemoveEntryList( &pPendRequest->List );

					RequestCleanup(
						pPendRequest,
						pConnection );

					pPendRequest = NULL;
				}
				else
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!setting pPendRequest->bDoneReadingFromVxd to TRUE" ));

					pPendRequest->bDoneReadingFromVxd = TRUE;
				}

				continue;
			}

			//
			// now that we have the right buffer do the job
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!adjusting dwBytesSent in pBufferWrite:%08X",
				pBufferWrite ));

			pBufferWrite->dwBytesSent += dwBytesReceived;

			LISTENER_DBGPRINTF((
				"OnVxdRead!adjusting dwBytesSent:%d",
				pBufferWrite->dwBytesSent ));

			// PERFORMANCE: (CODEWROK:) it's useless to call the vxd for
			// more data if the space left into this buffer is, say, 1 byte.
			// use some kind of formula here to use something like a 80%
			// treshold for the size of the buffer, or try being even smarter
			// using some adaptive memory allocation.

			// NOTE: like ul.sys, until a 0 size write is done on
			// UlSendHttpResponseEntityBody(), we are not sure if the
			// response is over (regardless of specification of, e.g.,
			// Content-Length header or trailer for chunked encoding)
			// so we'll hang for more data until that write is issued
			
			if ( pBufferWrite->dwBytesSent >= pBufferWrite->dwBufferSize /* *0.8 */ )
			{
				//
				// the buffer we used is full, flush the data on the socket
				// the buffer will be freed when the socket IO will complete
				// in OnSocketWrite()
				//

				LISTENER_DBGPRINTF((
					"OnVxdRead!flushing pBufferWrite:%08X to socket %d bytes, pBuffer:%08X",
					pBufferWrite, pBufferWrite->dwBytesSent, pBufferWrite->pBuffer ));

				LISTENER_ASSERT( !pBufferWrite->bBufferSent );

				dwError =
				SendData(
					pConnection->socket,
					pBufferWrite->pBuffer,
					pBufferWrite->dwBytesSent,
					&pBufferWrite->Overlapped );

				if ( dwError != LISTENER_SUCCESS )
				{
					LISTENER_DBGPRINTF((
						"OnVxdRead!SendData() failed err:%d",
						dwError ));
						
					return LISTENER_GARBAGE_COLLECT;
				}

				//
				// remember that this buffer is being sent on the wire
				// we will free it when the IO completes in OnSocketWrite()
				//

				pBufferWrite->bBufferSent = TRUE;
				
				//
				// then create a new buffer and read more entity body in it
				//

				pBufferWrite = NULL;
			}

			break;


		case ResponseReceiveStatusInitialized:

			break;


		case ResponseReceiveStatusCompleted:

			break;


		case ResponseReceiveStatusUndefined:
		case ResponseReceiveStatusMaximum:
		default:

			LISTENER_DBGPRINTF(( "OnVxdRead!invalid RequestSendStatus" ));

			return LISTENER_GARBAGE_COLLECT;

		}


		//
		// once we sent the headers, we need to start reading the entity body
		//

		if ( pBufferWrite == NULL )
		{
			//
			// Create a new LISTENER_BUFFER_WRITE record
			//

			LISTENER_DBGPRINTF((
				"OnVxdRead!creating a new LISTENER_BUFFER_WRITE record" ));

			LISTENER_ALLOCATE(
				LISTENER_BUFFER_WRITE*,
				pBufferWrite,
				sizeof( LISTENER_BUFFER_WRITE ),
				pConnection );

			if ( pBufferWrite == NULL )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!FAILED memory allocation: "
					"err#%d",
					GetLastError() ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			//
			// Add this to the list of LISTENER_BUFFER_WRITE records
			//

			InsertTailList(
				&pPendRequest->BufferWriteHead, &pBufferWrite->List );

			dwSize = LISTENER_BUFFER_VXDREAD_SIZE;

			LISTENER_ALLOCATE(
				PUCHAR,
				pBufferWrite->pBuffer,
				dwSize,
				pConnection );

			if ( pBufferWrite->pBuffer == NULL )
			{
				LISTENER_DBGPRINTF((
					"OnVxdRead!FAILED memory allocation: "
					"err#%d",
					GetLastError() ));
					
				return LISTENER_GARBAGE_COLLECT;
			}

			pBufferWrite->dwBytesSent = 0;
			pBufferWrite->dwBufferSize = dwSize;
			pBufferWrite->bBufferSent = FALSE;
			memset( &pBufferWrite->Overlapped, 0, sizeof( OVERLAPPED ) );
			memset( &pBufferWrite->OverlappedResponse, 0, sizeof( OVERLAPPED ) );
			pBufferWrite->Overlapped.hEvent =
				pConnection->pOverlapped[LISTENER_SOCKET_WRITE].hEvent;
			pBufferWrite->OverlappedResponse.hEvent =
				pConnection->pOverlapped[LISTENER_VXD_READ].hEvent;
		}

		//
		// now that the LISTENER_BUFFER_WRITE structure is adjusted (or newly
		// created) call ul for more data
		//

		LISTENER_DBGPRINTF((
			"OnVxdRead!calling UlReceiveHttpResponseEntityBody("
			"pBuffer:%08X, dwBufferSize:%d) pOverlapped:%08X hEvent:%08X",
			pBufferWrite->pBuffer + pBufferWrite->dwBytesSent,
			pBufferWrite->dwBufferSize - pBufferWrite->dwBytesSent,
			&pBufferWrite->OverlappedResponse,
			pBufferWrite->OverlappedResponse.hEvent ));

		dwError =
		UlReceiveHttpResponseEntityBody(
			pPendRequest->pRequest->RequestId,
			0,
			pBufferWrite->pBuffer + pBufferWrite->dwBytesSent,
			pBufferWrite->dwBufferSize - pBufferWrite->dwBytesSent,
			NULL,
			&pBufferWrite->OverlappedResponse );

		//
		// many errors can happen here, let's assume that if the
		// vxd fails we send an error response and close the
		// connection. CODEWORK: specialize behaviour (response)
		//

		if ( dwError != ERROR_SUCCESS
			&& GetLastError() != ERROR_IO_PENDING )
		{
			// CODEWORK: UlSendResponseWin9x();

			// let's just drop the connection for now:

			LISTENER_DBGPRINTF((
				"OnVxdRead!UlReceiveHttpResponseEntityBody() failed err:%d",
				GetLastError() ));

			return LISTENER_GARBAGE_COLLECT;
		}

	} // for (;;)


	return LISTENER_SUCCESS;
	
} // OnVxdRead






/*++

Routine Description:

    OnSocketWrite().

Arguments:

    pConnection
    	pointer to the LISTENER_CONNECTION structure that contains information
    	on the connection with which we are dealing.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
OnSocketWrite(
	LISTENER_CONNECTION *pConnection )
{
	LISTENER_REQUEST *pPendRequest = NULL;
	LISTENER_BUFFER_WRITE *pBufferWrite = NULL;
	LIST_ENTRY *pPendRequestList, *pBufferWriteList;

	OVERLAPPED *pOverlapped;
	DWORD dwError, dwBytesSent = 0, dwFlags = LISTENER_SOCKET_FLAGS;
	BOOL bOK;

	LISTENER_DBGPRINTF((
		"OnSocketWrite!I/O on socket %08X", pConnection->socket ));

	GetSystemTimeAsFileTime( &pConnection->sLastUsed );

	//
	// the request we're still dealing with is the first one added for
	// this connection. so figure out which one is the request that was
	// added first if there are no more requests for this connection
	// something's pretty bad: cleanup.
	//

	if( IsListEmpty( &pConnection->PendRequestHead ) )
	{
		LISTENER_DBGPRINTF((
			"OnSocketWrite!this list shouldn't be empty, exiting" ));

		return LISTENER_GARBAGE_COLLECT;
	}

	pPendRequestList = pConnection->PendRequestHead.Flink;

	LISTENER_DBGPRINTF((
		"OnSocketWrite!vxd I/O for socket %08X, pPendRequestList:%08X",
		pConnection->socket, pPendRequestList ));

	pPendRequest =
    CONTAINING_RECORD(
		pPendRequestList,
		LISTENER_REQUEST,
		List );

	pBufferWriteList = pPendRequest->BufferWriteHead.Flink;

	for (;;)
	{
		//
		// figure out the buffer that was just written to the socket
		//

		if( IsListEmpty( &pPendRequest->BufferWriteHead ) )
		{
			//
			// did this request even start???
			//

			if ( pPendRequest->RequestSendStatus >= RequestSendStatusDone ||
				pPendRequest->RequestSendStatus <= RequestSendStatusInitialized )
			{
				//
				// this IO still has to complete, give it some more time
				// or the request still needs to be started
				//

				break;
			}

			//
			// if it did this must be a connection closed on the client side
			//

			LISTENER_DBGPRINTF((
				"OnSocketWrite!WSAGetOverlappedResult() returned 0: "
				"Connection closed, socket %08X disconnected",
				pConnection->socket ));

			return LISTENER_GARBAGE_COLLECT;
		}

		pBufferWrite =
	    CONTAINING_RECORD(
			pBufferWriteList,
			LISTENER_BUFFER_WRITE,
			List );

		pBufferWriteList = pBufferWriteList->Flink;

		//
		// check IO status calling WSAGetOverlappedResult()
		//

		pOverlapped = &pBufferWrite->Overlapped;

		LISTENER_DBGPRINTF((
			"OnSocketWrite!pPendRequest:%08X pBufferWrite:%08X pOverlapped:%08X",
			pPendRequest, pBufferWrite, pOverlapped ));

		//
		// find out what happened
		//

		LISTENER_DBGPRINTF((
			"OnSocketWrite!calling WSAGetOverlappedResult(pOverlapped:%08X)",
			pOverlapped ));

		bOK = WSAGetOverlappedResult(
			pConnection->socket,
			pOverlapped,
			&dwBytesSent,
			FALSE,
			&dwFlags );

		if ( !bOK )
		{
			dwError = WSAGetLastError();

			if ( dwError == WSA_IO_INCOMPLETE )
			{
				// that's OK, I don't know why it should happen though.

				LISTENER_DBGPRINTF((
					"OnSocketWrite!WSAGetOverlappedResult() failed: "
					"WSA_IO_INCOMPLETE" ));
					
				break;
			}
			else
			{
				// Get rid of this, it's a bad connection anyway.

				LISTENER_DBGPRINTF((
					"OnSocketWrite!WSAGetOverlappedResult(%d) failed: err:%d",
					dwBytesSent, dwError ));

				return LISTENER_GARBAGE_COLLECT;
			}
		}
		else if ( dwBytesSent == 0 )
		{
			//
			// this IO still has to complete
			//

			break;
		}

		LISTENER_DBGPRINTF((
			"OnSocketWrite!WSAGetOverlappedResult(pPendRequest:%08X pBufferWrite:%08X, "
			"pBufferWrite->dwBytesSent:%d ) returns %d",
			pPendRequest, pBufferWrite, pBufferWrite->dwBytesSent, dwBytesSent ));

		if ( pBufferWrite->dwBytesSent != dwBytesSent )
		{
			// not all the data we wanted to write was written, some bad error,
			// let's close the connection and clean up

			LISTENER_DBGPRINTF((
				"OnSocketWrite!Not all the data was transferred, GC" ));
			
			return LISTENER_GARBAGE_COLLECT;
		}

		//
		// take this buffer out of the list and clean up
		//

		LISTENER_ASSERT( pBufferWrite->bBufferSent );

		LISTENER_DBGPRINTF((
			"OnSocketWrite!Getting rid of buffers" ));

		RemoveEntryList( &pBufferWrite->List );

		BufferWriteCleanup(
			pBufferWrite,
			pConnection );

		//
		// move to the next buffer
		//

	} // for (;;)

	//
	// just keep making sure that all the data that we send is read by
	// the client and that the connection is healthy, otherwise drop it.
	//

	//
	// check to see if the response was completely sent on the network:
	// this will be true if all the data was read from the vxd and if
	// the write buffer queue is empty
	//
	
	if ( pPendRequest->bDoneReadingFromVxd == TRUE && IsListEmpty( &pPendRequest->BufferWriteHead ) )
	{
		//
		// close the connection and free everything if we have to
		//

		if ( pConnection->bKeepAlive == FALSE )
		{
			//
			// this will close the connection and garbage collect
			//

			LISTENER_DBGPRINTF((
				"OnSocketWrite!we're done with this request, ConnectionClose" ));

			return LISTENER_GARBAGE_COLLECT;
		}

		//
		// otherwise just get rid of this request, we're done with it
		//

		if ( pPendRequest->bDoneWritingToVxd && pPendRequest->bDoneReadingFromVxd )
		{
			LISTENER_DBGPRINTF((
				"OnSocketWrite!we're done with this request. Cleaning up"
				" pPendRequest:%08X",
				pPendRequest ));

			RemoveEntryList( &pPendRequest->List );

			RequestCleanup(
				pPendRequest,
				pConnection );
		}
		else
		{
			LISTENER_DBGPRINTF((
				"OnSocketWrite!setting pPendRequest->bDoneWritingToSocket to TRUE" ));

			pPendRequest->bDoneWritingToSocket = TRUE;
		}
	}

	//
	// CODEWORK: come up with something "better" to make sure we have
	// sent all the data that the client is supposed to read.
	//

	LISTENER_DBGPRINTF((
		"OnSocketWrite!returning LISTENER_SUCCESS" ));

	return LISTENER_SUCCESS;
	
} // OnSocketWrite





/*++

Routine Description:

    Socket Manager Thread Function.
    This thread, soon after some very simple initialization, just sits there
    waiting on a set of events contained in the phEvents array. the first two
    entries in the array are created in the main function listener.c and serve
    the following pourposes:
    
    - hExitSM: signaled by the main thread to make the connection manager
      thread, gracefully Cleanup and exit.

    - hAccept: signaled by the main thread to make the connection manager
      pick up the value of the global variables gAcceptSocket and
      gRemoteIPAddress containing the socket handle and IP address of a
      connection that was just accepted.

	the rest of the array is filled in with four event handles per connection,
	these events are created in the OnPickConnection() function, and are used
	for overlapped I/O with sockets (one for WSASend and one for WSARecv) and
	with ul.vxd (one for UlSendMessage and one for UlReceiveMessage). events
	in the array are always kept adjacent, each time a connection is cleaned
	up in GarbageCollector(), the event handles are closed and the last four
	elements in the array are moved in the four entries that were just cleared
	(unless, of course, these were already the last four).
	the adjacency property, along with the ppConnection array, will allow us
	to find out the connection and the kind of event on that connection that
	caused the WaitForMultipleObjects() to return.

Arguments:

    lpParam
    	Unused.

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
WINAPI
ConnectionsManager( LPVOID lpParam )
{
	LISTENER_THREAD_STATUS ThreadStatus;
	LISTENER_CONNECTION *pConnection = NULL;
	LIST_ENTRY ConnectionHead;

	SOCKET sAcceptedSocket;
	ULONG ulRemoteIPAddress;

	HANDLE phEvents[MAXIMUM_WAIT_OBJECTS];
	LIST_ENTRY *ppConnection[MAXIMUM_WAIT_OBJECTS];

	DWORD dwEventIndex, dwEvents = LISTENER_CNNCTMNGR_FIRSTEVENT;
	DWORD dwStatus, dwWhichEvent, dwWhich = ~LISTENER_CNNCTMNGR_EXIT;
	BOOL bOK;

	LISTENER_DBGPRINTF(( "ConnectionsManager!Thread started: Initializing" ));

  	// Initialize 

	InitializeListHead( &ConnectionHead );

	phEvents[LISTENER_CNNCTMNGR_EXIT] = hExitSM;
 	ppConnection[LISTENER_CNNCTMNGR_EXIT] = NULL;

	phEvents[LISTENER_CNNCTMNGR_PICKCNNCT] = hUpdate;
	ppConnection[LISTENER_CNNCTMNGR_PICKCNNCT] = NULL;

	// Initialize state info

	ThreadStatus.pConnectionHead = &ConnectionHead;
	ThreadStatus.pdwEvents = &dwEvents;
	ThreadStatus.phEvents = phEvents;
	ThreadStatus.ppConnection = ppConnection;

	// enter the "endless" loop, until hExitSM is signaled or some really bad
	// error occurs (such as memory allocation failure or ...).

	do
	{

		{
			UCHAR pchData[16384]; DWORD i;
			for (i=0;i<dwEvents-1;i++) sprintf(pchData+i*17,"hEvent:%08X, \0",phEvents[i]);
			sprintf(pchData+(dwEvents-1)*17,"hEvent:%08X\0",phEvents[dwEvents-1]);

			LISTENER_DBGPRINTF((
				"ConnectionsManager!calling WSAWaitForMultipleEvents(%d %s)",
				dwEvents, pchData ));
		}

		// LISTENER_DBGPRINTF(( "ConnectionsManager!calling WSAWaitForMultipleEvents(%d)", dwEvents ));
		
		dwWhich =
		WSAWaitForMultipleEvents(
			dwEvents,                  
			phEvents,  
			FALSE,
			LISTENER_WAIT_TIMEOUT * 1000,                
			FALSE );

		//
		// we print info on the signaled event handle, this will cause AV if
		// dwWhich is not proper!!!
		//

		LISTENER_DBGPRINTF((
			"ConnectionsManager!WSAWaitForMultipleEvents()"
			" returns %08X (hEvent:%08X)",
			dwWhich, dwWhich>=0 && dwWhich<dwEvents ? phEvents[dwWhich] : NULL ));

		dwWhich -= WAIT_OBJECT_0;
		dwStatus = 0;

		switch ( dwWhich )
		{

		case WAIT_FAILED + WAIT_OBJECT_0:

			LISTENER_DBGPRINTF((
				"ConnectionsManager!WAIT FAILED, closing all connections: err#%d",
				WSAGetLastError() ));

			GarbageCollector( &ThreadStatus, TRUE );

			break;
			

		case WAIT_TIMEOUT + WAIT_OBJECT_0:

			LISTENER_DBGPRINTF((
				"ConnectionsManager!WAIT TIMEOUT, Checking app health" ));

			dwStatus = OnWaitTimedOut( &ConnectionHead );

			if ( dwStatus != 0 )
			{
				GarbageCollector( &ThreadStatus, FALSE );
			}

			break;


		case LISTENER_CNNCTMNGR_EXIT:

			LISTENER_DBGPRINTF((
				"ConnectionsManager!EXIT, shutting down" ));

			break;


		case LISTENER_CNNCTMNGR_PICKCNNCT:

			// There's a new connection: make a local copy of the connected
			// socket and the remote IP address and ....

			sAcceptedSocket = gAcceptSocket;
			ulRemoteIPAddress = gRemoteIPAddress;

			// restart the main thread so that it continues accepting new
			// connections as soon as possible.

			bOK = SetEvent( hAccept );
			LISTENER_ASSERT( bOK );

			LISTENER_DBGPRINTF((
				"ConnectionsManager!New Connection %08X from %d.%d.%d.%d",
				sAcceptedSocket,
				ulRemoteIPAddress     & 0xFF,
				ulRemoteIPAddress>>8  & 0xFF,
				ulRemoteIPAddress>>16 & 0xFF,
				ulRemoteIPAddress>>24 & 0xFF ));

			dwStatus = OnPickConnection(
				&ThreadStatus,
				sAcceptedSocket,
				ulRemoteIPAddress );

			if ( dwStatus == LISTENER_GARBAGE_COLLECT )
			{
				// if this error is returned, something failed in the creation
				// of the LISTENER_CONNECTION struct, but the struct is in the
				// list, but we already know that it is the first, so...

				// assert that there is one connection

				LISTENER_ASSERT( !IsListEmpty( &ConnectionHead ) );

				//
				// take the first one (the last one added to the queue)
				//

		        pConnection =
		        CONTAINING_RECORD(
					ConnectionHead.Flink,
					LISTENER_CONNECTION,
					List );

				// clean it up

				pConnection->bGarbageCollect = TRUE;
				GarbageCollector( &ThreadStatus, FALSE );
			}

			break;


		default:

			// Identify which connection was signaled
			
			LISTENER_ASSERT( !IsListEmpty( ppConnection[dwWhich] ) );

	        pConnection =
	        CONTAINING_RECORD(
				ppConnection[dwWhich],
				LISTENER_CONNECTION,
				List );

			// Identify what kind of I/O was completed

			dwWhichEvent =
				( dwWhich - LISTENER_REQSTMNGR_FIRSTEVENT )
				% LISTENER_CONNECTION_EVENTS;

			LISTENER_ASSERT(
				dwWhichEvent == LISTENER_SOCKET_READ ||
				dwWhichEvent == LISTENER_SOCKET_WRITE ||
				dwWhichEvent == LISTENER_VXD_READ ||
				dwWhichEvent ==	LISTENER_VXD_WRITE );

			LISTENER_DBGPRINTF((
				"ConnectionsManager!pConnection:%08X EventType:%s",
				pConnection,
				dwWhichEvent ==
					LISTENER_SOCKET_READ ? "LISTENER_SOCKET_READ" :
				dwWhichEvent ==
					LISTENER_SOCKET_WRITE ? "LISTENER_SOCKET_WRITE" :
				dwWhichEvent ==
					LISTENER_VXD_READ ? "LISTENER_VXD_READ" :
				dwWhichEvent ==
					LISTENER_VXD_WRITE ? "LISTENER_VXD_WRITE" :
					"Illegal Event" ));

			dwStatus = LISTENER_SUCCESS;

			switch ( dwWhichEvent )
			{

			// CODEWORK: use an array of function pointers?

			case LISTENER_SOCKET_READ:

				do
				{
					dwStatus = OnSocketRead( pConnection );

				} while ( dwStatus == LISTENER_CALL_ME_AGAIN );

				break; // dwWhichEvent == LISTENER_SOCKET_READ


			case LISTENER_SOCKET_WRITE:

				dwStatus = OnSocketWrite( pConnection );

				break; // dwWhichEvent == LISTENER_SOCKET_WRITE

			case LISTENER_VXD_READ:

				dwStatus = OnVxdRead( pConnection );

				break; // dwWhichEvent == LISTENER_VXD_READ


			case LISTENER_VXD_WRITE:

				dwStatus = OnVxdWrite( pConnection );
				
				break; // dwWhichEvent == LISTENER_VXD_WRITE

			default:
			
				// this will never happen, but in case someone changes the
				// code, print something and shut down.
				
				LISTENER_DBGPRINTF((
					"ConnectionsManager!UNEXPECTED BEHAVIOUR, shutting down" ));

				dwStatus = LISTENER_SUCCESS;

				// setting dwWhich to LISTENER_CNNCTMNGR_EXIT will shut down.

				dwWhich = LISTENER_CNNCTMNGR_EXIT;

				break;
			}

			switch ( dwStatus )
			{

			case LISTENER_SUCCESS:

				break; // dwStatus == LISTENER_SUCCESS

			case LISTENER_STOP_READING:

				// somebody has figured out an error response for a request in
				// this connection, so we simulate a LISTENER_VXD_READ as if
				// the response was, in fact, coming in from the VxD.
				// if the request pending was the first_in the response will
				// be formatted and sent, otherwise this response will be
				// sent when the request becomes first_in.

				SetEvent( pConnection->pOverlapped[LISTENER_VXD_READ].hEvent );

				break; // dwStatus == LISTENER_STOP_READING

			case LISTENER_RESPONSE_SET:

				break; // dwStatus == LISTENER_RESPONSE_SET

			case LISTENER_GARBAGE_COLLECT:

				// something went wrong: clean up the connection we
				// were working on

				pConnection->bGarbageCollect = TRUE;
				GarbageCollector( &ThreadStatus, FALSE );

				break; // dwStatus == LISTENER_GARBAGE_COLLECT
			}

			break; // dwWhich == default
		}

		//
		// dump some debug information on the current status
		//

		DumpConnections( &ThreadStatus );

	} while ( dwWhich != LISTENER_CNNCTMNGR_EXIT );

	GarbageCollector( &ThreadStatus, TRUE );

	return LISTENER_SUCCESS;
	
} // ConnectionsManager()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\inc\structs.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    structs.h

Abstract:

    Definition of structs for I/O between UL.VXD and the usermode API.

Author:

    Mauro Ottaviani (mauroot)       26-Aug-1999

Revision History:

--*/


#ifndef _STRUCTS_H_
#define _STRUCTS_H_


typedef enum _UL_IRP_TYPE
{
	UlIrpEmpty,		// 0
	UlIrpReceive,	// 1
	UlIrpSend		// 2

} UL_IRP_TYPE;


#define UL_INVALID_URIHANDLE	((HANDLE)0xFFFFFFFF)
#define UL_CLEAN_ALL			((ULONG)0xFFFFFFFF)


// IoCtls

// UlCreateAppPool
#define IOCTL_UL_CREATE_APPPOOL						0x20

// UlCreateAppPool
#define IOCTL_UL_CLOSE_APPPOOL						0x22

// UlRegisterUri
#define IOCTL_UL_REGISTER_URI						0x24

// UlUnregisterUri
#define IOCTL_UL_UNREGISTER_URI						0x26

// UlUnregisterAll
#define IOCTL_UL_UNREGISTER_ALL						0x38

// UlSendHttpRequest
#define IOCTL_UL_SEND_HTTP_REQUEST_HEADERS			0x28

// UlSendRequestEntityBody
#define IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY		0x2A

// UlReceiveHttpRequest
#define IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS		0x2C

// UlReceiveEntityBody
#define IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY	0x2E

// UlSendHttpResponse
#define IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS			0x30

// UlSendEntityBody
#define IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY		0x32

// UlReceiveHttpResponse
#define IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS		0x34

// UlReceiveResponseEntityBody
#define IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY	0x36

// UlCancelRequest
#define IOCTL_UL_CANCEL_REQUEST						0x3A


typedef struct _IN_IOCTL_UL_REGISTER_URI
{
	ULONG			ulSize; // used for structure validation
    HANDLE 			hAppPoolHandle;
	ULONG			ulUriToRegisterLength;
	PWSTR			pUriToRegister;
	
} IN_IOCTL_UL_REGISTER_URI, *PIN_IOCTL_UL_REGISTER_URI;

typedef struct _IN_IOCTL_UL_UNREGISTER_URI
{
	ULONG			ulSize; // used for structure validation
    HANDLE 			hAppPoolHandle;
	ULONG			ulUriToUnregisterLength;
	PWSTR			pUriToUnregister;
	
} IN_IOCTL_UL_UNREGISTER_URI, *PIN_IOCTL_UL_UNREGISTER_URI;


typedef struct _IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS
{
	ULONG			ulSize; // used for structure validation
	ULONG			ulTargetUriLength;
	PWSTR			pTargetUri;
	PUL_HTTP_REQUEST_ID pRequestId;
	ULONG 			Flags;
	PVOID 			pRequestBuffer; // cast from a PUL_HTTP_REQUEST
	ULONG 			RequestBufferLength;
	PULONG 			pBytesSent;
	LPOVERLAPPED 	pOverlapped;

} IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS, *PIN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS;


typedef struct _IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY
{
	ULONG			ulSize; // used for structure validation
	UL_HTTP_REQUEST_ID RequestId;
	ULONG 			Flags;
	PVOID 			pRequestBuffer;
	ULONG 			RequestBufferLength;
	PULONG 			pBytesSent;
	LPOVERLAPPED 	pOverlapped;

} IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY, *PIN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY;


typedef struct _IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS
{
	ULONG			ulSize; // used for structure validation
	HANDLE			AppPoolHandle;
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	PVOID			pRequestBuffer; // PUL_HTTP_REQUEST
	ULONG			RequestBufferLength;
	PULONG			pBytesReturned;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS, *PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS;


typedef struct _IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY
{
	ULONG			ulSize; // used for structure validation
	HANDLE			AppPoolHandle;
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	PVOID			pEntityBuffer;
	ULONG			EntityBufferLength;
	PULONG			pBytesReturned;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY, *PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY;


typedef struct _IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS
{
	ULONG			ulSize; // used for structure validation
	HANDLE			AppPoolHandle;
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	PVOID			pResponseBuffer; // PUL_HTTP_RESPONSE
	ULONG 			ResponseBufferLength;
	ULONG			EntityChunkCount;
	PVOID			pEntityChunks; // PUL_DATA_CHUNK
	PVOID			pCachePolicy; // PUL_CACHE_POLICY
	PULONG			pBytesSent;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS, *PIN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS;


typedef struct _IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY
{
	ULONG			ulSize; // used for structure validation
	HANDLE			AppPoolHandle;
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	ULONG			EntityChunkCount;
	PVOID			pEntityChunks; // PUL_DATA_CHUNK
	PULONG			pBytesSent;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY, *PIN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY;


typedef struct _IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS
{
	ULONG			ulSize; // used for structure validation
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	PVOID 			pResponseBuffer; // PUL_HTTP_RESPONSE
	ULONG 			ResponseBufferLength;
	ULONG			EntityChunkCount;
	PVOID			pEntityChunks; // PUL_DATA_CHUNK
	PVOID			pCachePolicy; // PUL_CACHE_POLICY
	PULONG			pBytesSent;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS, *PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS;


typedef struct _IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY
{
	ULONG			ulSize; // used for structure validation
	UL_HTTP_REQUEST_ID RequestId;
	ULONG			Flags;
	PVOID			pEntityBuffer;
	ULONG			EntityBufferLength;
	PULONG			pBytesSent;
	LPOVERLAPPED	pOverlapped;

} IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY, *PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY;



#endif  // _STRUCTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\chat\chat.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	chat.h

Abstract:

	CHAT - common includes for client & server.

Author:

    Mauro Ottaviani (mauroot)       20-Aug-1999

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "ioctl.h"
#include "ulapi9x.h"

#define BREAKPOINT { _asm int 03h }


#define CHAT_PUB_URI L"ipc://localhost/chat/pub"
#define CHAT_SUB_URI L"ipc://localhost/chat/sub"


#define CHAT_BUFFER_SIZE 2048
#define CHAT_RCV_BUFFER_SIZE 2048
#define CHAT_SND_BUFFER_SIZE 2048


#define CHAT_PUB_SERVER_TIMEOUT 2000
#define CHAT_SUB_CLIENT_TIMEOUT 5000
#define CHAT_PUB_CLIENT_TIMEOUT 5000


#define CHAT_EVENTS_EXIT	0
#define CHAT_EVENTS_SUB		1
#define CHAT_EVENTS_PUB		1
#define CHAT_EVENTS_SIZE	2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\httputil.c ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

	httputil.c
	
Abstract:

	XXX

Author:

    Mauro Ottaviani ( mauroot )       15-Dec-1999

Revision History:

--*/

    
#include "listener.h"


//
//
// HTTP Helper Functions
//
//

// We are going to use this small buffer preallocated in order to format very
// short responses to be sent, in case we have a memory allocation failure
// we need preallocated memory.

#define LISTENER_QUICK_REPSONSE_BUFFER_SIZE 1024

UCHAR
	gpBuffer[LISTENER_QUICK_REPSONSE_BUFFER_SIZE];

const PWSTR gRequestHeaderStrings[] = {
		L"Cache-Control",
		L"Connection",
		L"Date",
		L"Keep-Alive",
		L"Pragma",
		L"Trailer",
		L"Transfer-Encoding",
		L"Upgrade",
		L"Via",
		L"Warning",
		L"Allow", 
		L"Content-Length",
		L"Content-Type",
		L"Content-Encoding",
		L"Content-Language",
		L"Content-Location",
		L"Content-Md5",
		L"Content-Range",
		L"Expires", 
		L"Last-Modified",
		L"Accept",
		L"Accept-Charset",
		L"Accept-Encoding",
		L"Accept-Language",
		L"Authorization",
		L"Cookie",
		L"Expect",
		L"From",
		L"Host", 
		L"If-Match",
		L"If-Modified-Since",
		L"If-None-Match",
		L"If-Range",
		L"If-Unmodified-Since",
		L"Max-Forwards",
		L"Proxy-Authorization",
		L"Referer",
		L"Range", 
		L"Te",
		L"User-Agent",
		L"Request-Maximum",
		L"Maximum" };

const PWSTR gResponseHeaderStrings[] = {
		L"Cache-Control",
		L"Connection",
		L"Date",
		L"Keep-Alive",
		L"Pragma",
		L"Trailer",
		L"Transfer-Encoding",
		L"Upgrade",
		L"Via",
		L"Warning",
		L"Allow", 
		L"Content-Length",
		L"Content-Type",
		L"Content-Encoding",
		L"Content-Language",
		L"Content-Location",
		L"Content-Md5",
		L"Content-Range",
		L"Expires", 
		L"Last-Modified",
		L"Accept-Ranges",
		L"Age",
		L"Etag",
		L"Location",
		L"Proxy-Authenticate",
		L"Retry-After",
		L"Server",
		L"Set-Cookie", 
		L"Vary",
		L"Www-Authenticate",
		L"Response-Maximum",
		L"Maximum" };

const PUCHAR gpDays[] =
{
	/*was L*/"Sun", /*was L*/"Mon", /*was L*/"Tue", /*was L*/"Wed",
	/*was L*/"Thu", /*was L*/"Fri", /*was L*/"Sat"
};

const PUCHAR gpMonths[] =
{
	/*was L*/"Jan", /*was L*/"Feb", /*was L*/"Mar", /*was L*/"Apr",
	/*was L*/"May", /*was L*/"Jun", /*was L*/"Jul",	/*was L*/"Aug",
	/*was L*/"Sep", /*was L*/"Oct", /*was L*/"Nov", /*was L*/"Dec"
};


// need the following in ResponseFormat()

#define WIDE_TO_CHAR(c) ((((c)&0xff00)!=0 || IS_HTTP_CTL(c))?'_':(CHAR)(c))


// the following are cut & paste from <ul\drv\httprcv.c> lines 2854-2921
// all strings converted to ANSI from UNICODE, changes marked by /* was...*/

typedef struct _UL_HTTP_ERROR_ENTRY
{
    USHORT StatusCode;
    ULONG  ReasonLength;
    PSTR/*was PWSTR*/  pReason;

} UL_HTTP_ERROR_ENTRY, PUL_HTTP_ERROR_ENTRY;

#define HTTP_ERROR_ENTRY(StatusCode, pReason)  \
    { (StatusCode), sizeof((pReason))-sizeof(CHAR/*was WCHAR*/), (pReason) }

const
UL_HTTP_ERROR_ENTRY ErrorTable[] =
{
    //
    // UlError
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request"),
    //
    // UlErrorVerb
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid verb)"),
    //
    // UlErrorUrl
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid url)"),
    //
    // UlErrorHeader
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid header name)"),
    //
    // UlErrorHost
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid hostname)"),
    //
    // UlErrorCRLF
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid CR or LF)"),
    //
    // UlErrorNum
    //
    HTTP_ERROR_ENTRY(400, /*was L*/"Bad Request (invalid number)"),
    //
    // UlErrorVersion
    //
    HTTP_ERROR_ENTRY(505, /*was L*/"HTTP Version not supported"),
    //
    // UlErrorUnavailable
    //
    HTTP_ERROR_ENTRY(503, /*was L*/"Service Unavailable"),
    //
    // UlErrorNotFound
    //
    HTTP_ERROR_ENTRY(404, /*was L*/"Not Found"),
    //
    // UlErrorContentLength
    //
    HTTP_ERROR_ENTRY(411, /*was L*/"Length required"),
    //
    // UlErrorEntityTooLarge
    //
    HTTP_ERROR_ENTRY(413, /*was L*/"Request Entity Too Large"),
    //
    // UlErrorNotImplemented
    //
    HTTP_ERROR_ENTRY(501, /*was L*/"Not Implemented")

};


PWSTR
RequestHeaderString(
	ULONG ulIndex )
{
	return gRequestHeaderStrings[ulIndex];
}

PWSTR
ResponseHeaderString(
	ULONG ulIndex )
{
	return gResponseHeaderStrings[ulIndex];
}



/*++

Routine Description:

    Converts the given system time to string representation containing
    GMT Formatted String.
    from TimeFieldsToHttpDate()

Arguments:

    pBuffer
    	pointer to string which will contain the GMT time on successful return

    BufferLength
    	size of pszBuff in bytes

Return Value:

    -1 on failure, 0 otherwise.

History:

     MuraliK        3-Jan-1995
     paulmcd        4-Mar-1999  copied to ul
     MauroOt       17-Dec-1999  modified for Win9x

--*/

DWORD
__inline
VxdTimeFieldsToHttpDate(
    PSTR pBuffer,
    DWORD BufferLength )
{
    NTSTATUS Status;
    WORD Number;
	SYSTEMTIME pTime[1];

	GetSystemTime( pTime );

    if ( pBuffer == NULL )
    {
		return LISTENER_ERROR;
	}

    if ( BufferLength
    	< sizeof( "DDD, dd MMM YYYY hh:mm:ss GMT" ) - sizeof(CHAR) )
    {
        return LISTENER_ERROR;
    }

    //                          0         1         2
    //                          01234567890123456789012345678
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    //
    // write the constants
    //

    pBuffer[3] = ',';
    pBuffer[4] = pBuffer[7] = pBuffer[11] = pBuffer[16] = pBuffer[25] = ' ';
    pBuffer[19] = pBuffer[22] = ':';
    pBuffer[26] = 'G';
    pBuffer[27] = 'M';
    pBuffer[28] = 'T';

    //
    // now the variants
    //

    //
    // 0-based Weekday
    //

    memcpy ( pBuffer, gpDays[pTime->wDayOfWeek], 3*sizeof(CHAR));

    Number = pTime->wDay;
    pBuffer[6] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[5] = '0' + (CHAR)(Number%10);

    //
    // 1-based Month
    //

    memcpy( pBuffer+8, gpMonths[pTime->wMonth - 1], 3*sizeof(CHAR));

    Number = pTime->wHour;
    pBuffer[18] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[17] = '0' + (CHAR)(Number%10);

    Number = pTime->wMinute;
    pBuffer[21] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[20] = '0' + (CHAR)(Number%10);

    Number = pTime->wSecond;
    pBuffer[24] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[23] = '0' + (CHAR)(Number%10);

    Number = pTime->wYear;
    pBuffer[15] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[14] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[13] = '0' + (CHAR)(Number%10);
    Number/=10;
    pBuffer[12] = '0' + (CHAR)(Number%10);

    return LISTENER_SUCCESS;

} // VxdTimeFieldsToHttpDate()



//
// Formats and sends a very simple HTTP response
//

VOID
SendQuickHttpResponse(
	SOCKET socket,
	BOOL bClose,
	DWORD ErrorCode )
{
	DWORD dwBufferSize, dwStatus, dwOffset;
	DWORD StatusCode, dwStatusCodeOffset, dwReasonOffset, dwDateOffset;
	int result;

	// Parameter validation
	
	if ( socket == INVALID_SOCKET ) return;

    if ( ErrorCode >= DIMENSION( ErrorTable ) )
    {
        ErrorCode = UlError;
    }

	memset( gpBuffer, 0, LISTENER_QUICK_REPSONSE_BUFFER_SIZE );

	dwStatusCodeOffset = sizeof( "HTTP/1.1 " ) - sizeof(CHAR);

	dwReasonOffset = dwStatusCodeOffset + sizeof( "XXX " ) - sizeof(CHAR);

	dwDateOffset =
		dwReasonOffset +
		ErrorTable[ErrorCode].ReasonLength +
		sizeof( "\r\nContent-Length: 0\r\nServer: Microsoft-IIS/UL\r\nContent-Length: 0\r\nDate: " )
		- sizeof(CHAR);

	dwBufferSize =
		dwDateOffset +
		sizeof( "DDD, dd MMM YYYY hh:mm:ss GMT\r\nConnection: close\r\n\r\n" )
		- sizeof(CHAR);

	if ( dwBufferSize > LISTENER_QUICK_REPSONSE_BUFFER_SIZE )
	{
		LISTENER_DBGPRINTF((
			"SendQuickHttpResponse!buffer too small need %d/%d",
			dwBufferSize, LISTENER_QUICK_REPSONSE_BUFFER_SIZE ));

		goto Close;
	}

	// constant stuff

	memcpy( gpBuffer, "HTTP/1.1 ", dwStatusCodeOffset );

	gpBuffer[dwStatusCodeOffset+3] = ' ';

	memcpy(
		gpBuffer + dwReasonOffset + ErrorTable[ErrorCode].ReasonLength,
		"\r\nContent-Length: 0\r\nServer: Microsoft-IIS/UL\r\nContent-Length: 0\r\nDate: ",
		dwDateOffset - dwReasonOffset - ErrorTable[ErrorCode].ReasonLength );

	memcpy(
		gpBuffer + dwDateOffset,
		"DDD, dd MMM YYYY hh:mm:ss GMT\r\nConnection: close\r\n\r\n",
		dwBufferSize - dwDateOffset );

	// variable stuff

    StatusCode = ErrorTable[ErrorCode].StatusCode;

	gpBuffer[dwStatusCodeOffset+2] = '0' + (CHAR)(StatusCode%10);
	StatusCode/=10;
	gpBuffer[dwStatusCodeOffset+1] = '0' + (CHAR)(StatusCode%10);
	StatusCode/=10;
	gpBuffer[dwStatusCodeOffset+0] = '0' + (CHAR)(StatusCode%10);

	memcpy(
		gpBuffer + dwReasonOffset,
		ErrorTable[ErrorCode].pReason,
		ErrorTable[ErrorCode].ReasonLength );

	dwStatus = VxdTimeFieldsToHttpDate(
	    gpBuffer + dwDateOffset,
	    sizeof( "DDD, dd MMM YYYY hh:mm:ss GMT" ) - sizeof(CHAR) );

	if ( dwStatus != 0 )
	{
		LISTENER_DBGPRINTF((
			"SendQuickHttpResponse!VxdTimeFieldsToHttpDate() failed" ));
			
		goto Close;
	}
	
	// this synchronous send has a very small buffer, so winsock is
	// going to copy the buffer and complete it immediately. Even if
	// closesocket() is closed winsock is still going to try to send this
	// data. if it times out then it will also take care of canceling
	// the I/O. So I will:

	gpBuffer[dwBufferSize] = 0; // bugbug!

	LISTENER_DBGPRINTF((
		"SendQuickHttpResponse!calling send()--------\n%s\n-----------------------\n",
		gpBuffer ));

	// 1) send the data...

	result = send(
		socket,                                               
		gpBuffer,                                     
		dwBufferSize,                            
		0 );

	if ( result == SOCKET_ERROR )
	{
		LISTENER_DBGPRINTF((
			"SendQuickHttpResponse!send() failed err:%d",
			WSAGetLastError() ));

		goto Close;
	}

	LISTENER_DBGPRINTF((
		"SendQuickHttpResponse!sent %d bytes (call returns %d)",
		result, dwBufferSize ));

Close:

	// 2) if I'm asked to, close the connection.

	if ( bClose != FALSE )
	{
		result = closesocket( socket );

		if ( result == SOCKET_ERROR )
		{
			LISTENER_DBGPRINTF((
				"SendQuickHttpResponse!closesocket() failed err:%d",
				WSAGetLastError() ));
		}
	}

	return;

} // SendQuickHttpResponse()



ULONGLONG
ContentLengthFromHeaders(
	PUL_HEADER_VALUE pKnownHeaders )
{
	if ( pKnownHeaders[UlHeaderContentLength].RawValueLength == 0
		|| pKnownHeaders[UlHeaderContentLength].pRawValue == NULL )
	{
		// Content-Length Header was not set
		return LISTENER_ERROR;
	}
		
	return _wtoi64( pKnownHeaders[UlHeaderContentLength].pRawValue );

} // ContentLengthFromHeaders()



BOOL
IsKeepAlive(
	HTTP_REQUEST *pRequest )
{
	return
			pRequest != NULL
		&&
			!(

			// the following code is a cut&paste from UlCheckDisconnectInfo()
			// in <\ul\drv\engine.c> with some variations


		    //
		    // pre-version 1.0
		    //

		    (pRequest->Version < UlHttpVersion10) ||

		    //
		    // or version 1.0 with no "Connection: Keep-Alive"
		    // CODEWORK: and no "Keep-Alive" header
		    //

		    (pRequest->Version == UlHttpVersion10 &&
		        pRequest->Headers[UlHeaderConnection].Valid != 1) ||

		    //
		    // or version 1.1 with a Connection: close
		    // CODEWORK: move to parser or just make better in general..
		    //

		    (pRequest->Version == UlHttpVersion11 &&
		        pRequest->Headers[UlHeaderConnection].Valid == 1 &&
		        pRequest->Headers[UlHeaderConnection].HeaderLength == 5 &&
		        _stricmp(pRequest->Headers[UlHeaderConnection].pHeader,
		        	"close") != 0) ||

		    //
		    // or version 1.1 without chunked encoding and no Content-Length
		    // header specified.
		    // CODEWORK: Post-M10, we should consider autogenerating the
		    // Content-Length header in this situation.
		    //

		    (pRequest->Version == UlHttpVersion11 &&
		        pRequest->Chunked == 0 &&
		        pRequest->ContentLength != -1 )
		);

} // IsKeepAlive()



//
// Fixes offsets to pointers in a UL_HTTP_RESPONSE structure
// since UlReceiveHttpResponseHeaders() returns all pointers with a 0 offset
//

VOID
FixUlHttpResponse(
	UL_HTTP_RESPONSE *pUlResponse )
{
	DWORD dwIndex;

	pUlResponse->pReason =
		((WCHAR*)((PBYTE)pUlResponse->pReason
		+ (ULONG)pUlResponse));

	pUlResponse->Headers.pUnknownHeaders =
		((PUL_UNKNOWN_HTTP_HEADER)((PBYTE)pUlResponse->Headers.pUnknownHeaders
		+ (ULONG)pUlResponse));

	for ( dwIndex = 0; dwIndex < UlHeaderResponseMaximum; dwIndex++ )
    {
    	if ( pUlResponse->Headers.pKnownHeaders[dwIndex].RawValueLength > 0 )
    	{
			pUlResponse->Headers.pKnownHeaders[dwIndex].pRawValue =
				((WCHAR*)((PBYTE)pUlResponse->Headers.pKnownHeaders[dwIndex].pRawValue
				+ (ULONG)pUlResponse));
		}
	}

	for (
		dwIndex = 0;
		dwIndex < pUlResponse->Headers.UnknownHeaderCount;
		dwIndex++ )
    {
		pUlResponse->Headers.pUnknownHeaders[dwIndex].pName =
			((WCHAR*)((PBYTE)pUlResponse->Headers.pUnknownHeaders[dwIndex].pName
			+ (ULONG)pUlResponse));

		pUlResponse->Headers.pUnknownHeaders[dwIndex].Value.pRawValue =
			((WCHAR*)((PBYTE)pUlResponse->Headers.pUnknownHeaders[dwIndex].Value.pRawValue
			+ (ULONG)pUlResponse));
	}

	return;

} // FixUlHttpResponse()



//
// Formats a UL_HTTP_RESPONSE structure into a UCHAR buffer
// to be sent as an HTTP Response to an HTTP Request on a connection
//

DWORD
ResponseFormat(
	UL_HTTP_RESPONSE *pUlResponse,
	HTTP_REQUEST *pRequest,
	UCHAR *pEntityBodyFirstChunk,
	DWORD dwEntityBodyFirstChunkSize,
	UCHAR *pBuffer,
	DWORD dwBufferSize )
{
	DWORD i, dwIncrement, dwIndex, dwSize = 0;
	LIST_ENTRY *pList;

	LISTENER_DBGPRINTF((
		"ResponseFormat!pUlResponse:%08X pRequest:%08X pEntityBodyFirstChunk:%08X "
		"dwEntityBodyFirstChunkSize:%d pBuffer:%08X dwBufferSize:%d",
		pUlResponse, pRequest, pEntityBodyFirstChunk, dwEntityBodyFirstChunkSize,
		pBuffer, dwBufferSize ));

	// check for UL_HTTP_RESPONSE validity

	if ( pUlResponse == NULL )
	{
		return LISTENER_ERROR;
	}

	// CHECK FOR Request/Response validity

	// Requests that must have and empty EntityBody Response:

	if (
		pEntityBodyFirstChunk != NULL && dwEntityBodyFirstChunkSize != 0
		&& pRequest->Verb == UlHttpVerbHEAD
		)
	{
		LISTENER_DBGPRINTF((
			"ResponseFormat!Shouldn't be sending an Entity Body" ));
	}

	// Content-Length (http://magnet/http/http-lite.htm)

	if ( pRequest->Headers[UlHeaderContentLength].Valid )
	{
		// Content-Length was specified

		if (
			( pUlResponse->StatusCode>=100
				&& pUlResponse->StatusCode<=199 )
			||
			pUlResponse->StatusCode == 204
			||
			pUlResponse->StatusCode == 205
			||
			pUlResponse->StatusCode == 304
			||
			pRequest->Headers[UlHeaderTransferEncoding].Valid )
		{
			// Shouldn't have been set!

			LISTENER_DBGPRINTF((
				"ResponseFormat!Content-Length shouldn't have been set. "
				"Removing the header" ));

			if ( pRequest->Headers[UlHeaderContentLength].OurBuffer )
			{
				free( pRequest->Headers[UlHeaderContentLength].pHeader );
			}

			memset(
				pRequest->Headers + UlHeaderContentLength,
				0,
				sizeof( HTTP_HEADER ) );
		}
	}
	else
	{
		// Content-Length was not specified

		if ( pRequest->Verb == UlHttpVerbHEAD )
		{
			LISTENER_DBGPRINTF((
				"ResponseFormat!Content-Length should have been set: fail" ));
		}
	}


	// All string lengths are in bytes not including the NULL

    // Ignore:
    // USHORT Flags;

	// UL_HTTP_VERSION Version;

	dwIncrement = 9; // dafaults to "HTTP/1.1 "

	if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
	{
		return LISTENER_ERROR;
	}

	if ( pBuffer != NULL )
	{
		sprintf( pBuffer + dwSize, "HTTP/1.1 " );
	}
	dwSize += dwIncrement;


    // USHORT StatusCode;

	dwIncrement = 4; // "XXX "

	if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
	{
		return LISTENER_ERROR;
	}

	if ( pBuffer != NULL )
	{
		sprintf( pBuffer + dwSize, "%03d ", pUlResponse->StatusCode );
	}
	dwSize += dwIncrement;


    // ULONG ReasonLength;
    // PWSTR pReason;

	dwIncrement = pUlResponse->ReasonLength/2; // "Reason"

	if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
	{
		return LISTENER_ERROR;
	}

	if ( pBuffer != NULL )
	{
		for (i=0;i<dwIncrement;i++)
		{
			pBuffer[dwSize+i] =
				WIDE_TO_CHAR( *(pUlResponse->pReason + i) );
		}
	}
	dwSize += dwIncrement;


	dwIncrement = 2; // dafaults to "\r\n"

	if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
	{
		return LISTENER_ERROR;
	}

	if ( pBuffer != NULL )
	{
		sprintf( pBuffer + dwSize, "\r\n" );
	}
	dwSize += dwIncrement;


    // UL_HTTP_RESPONSE_HEADERS Headers;
		// UL_HEADER_VALUE pKnownHeaders[UlHeaderResponseMaximum];
			// USHORT RawValueLength;
			// PWSTR pRawValue;
	    // ULONG UnknownHeaderCount;
	    // PUL_UNKNOWN_HTTP_HEADER pUnknownHeaders;
			// ULONG NameLength;
			// PWSTR pName;
			// UL_HEADER_VALUE Value;
				// USHORT RawValueLength;
				// PWSTR pRawValue;
    
	// UL_HEADER_VALUE pKnownHeaders[UlHeaderResponseMaximum];

	for ( dwIndex = 0; dwIndex < UlHeaderResponseMaximum; dwIndex++ )
    {
    	if ( pUlResponse->Headers.pKnownHeaders[dwIndex].RawValueLength > 0 )
    	{
			dwIncrement = // "Name"
				wcslen( ResponseHeaderString( dwIndex ) );

			if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
			{
				return LISTENER_ERROR;
			}

			if ( pBuffer != NULL )
			{
				// this is really terrible!
				for ( i = 0; i < dwIncrement; i++ )
				{
					pBuffer[dwSize+i] =
						WIDE_TO_CHAR( *(ResponseHeaderString( dwIndex ) + i) );
				}
			}
			dwSize += dwIncrement;

			dwIncrement = 2; // dafaults to ": "

			if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
			{
				return LISTENER_ERROR;
			}

			if ( pBuffer != NULL )
			{
				sprintf( pBuffer + dwSize, ": " );
			}
			dwSize += dwIncrement;


			dwIncrement = // "Value"
				pUlResponse->Headers.pKnownHeaders[dwIndex].RawValueLength/2;

			if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
			{
				return LISTENER_ERROR;
			}

			if ( pBuffer != NULL )
			{
				for (i=0;i<dwIncrement;i++)
				{
					pBuffer[dwSize+i] =
						WIDE_TO_CHAR( *(pUlResponse->Headers.pKnownHeaders[dwIndex].pRawValue + i) );
				}
			}
			dwSize += dwIncrement;

			dwIncrement = 2; // dafaults to "\r\n"

			if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
			{
				return LISTENER_ERROR;
			}

			if ( pBuffer != NULL )
			{
				sprintf( pBuffer + dwSize, "\r\n" );
			}
			dwSize += dwIncrement;
		}
	}

    // PUL_UNKNOWN_HTTP_HEADER pUnknownHeaders;

	for (
		dwIndex = 0;
		dwIndex < pUlResponse->Headers.UnknownHeaderCount;
		dwIndex++ )
    {
		dwIncrement = // "Name"
			pUlResponse->Headers.pUnknownHeaders[dwIndex].NameLength/2;
		
		if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
		{
			return LISTENER_ERROR;
		}

		if ( pBuffer != NULL )
		{
			for (i=0;i<dwIncrement;i++)
			{
				pBuffer[dwSize+i] =
					WIDE_TO_CHAR( *(pUlResponse->Headers.pUnknownHeaders[dwIndex].pName + i) );
			}
		}
		dwSize += dwIncrement;

		dwIncrement = 2; // dafaults to ": "

		if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
		{
			return LISTENER_ERROR;
		}

		if ( pBuffer != NULL )
		{
			sprintf( pBuffer + dwSize, ": " );
		}
		dwSize += dwIncrement;


		dwIncrement = // "Value"
			pUlResponse->Headers.pUnknownHeaders[dwIndex].Value.RawValueLength/2;

		if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
		{
			return LISTENER_ERROR;
		}

		if ( pBuffer != NULL )
		{
			for (i=0;i<dwIncrement;i++)
			{
				pBuffer[dwSize+i] =
					WIDE_TO_CHAR( *(pUlResponse->Headers.pUnknownHeaders[dwIndex].Value.pRawValue + i) );
			}
		}
		dwSize += dwIncrement;

		dwIncrement = 2; // dafaults to "\r\n"

		if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
		{
			return LISTENER_ERROR;
		}

		if ( pBuffer != NULL )
		{
			sprintf( pBuffer + dwSize, "\r\n" );
		}
		dwSize += dwIncrement;
	}


	dwIncrement = 2; // final "\r\n"

	if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
	{
		return LISTENER_ERROR;
	}

	if ( pBuffer != NULL )
	{
		sprintf( pBuffer + dwSize, "\r\n" );
	}
	dwSize += dwIncrement;


	// Entity Body (if any)

	if ( pEntityBodyFirstChunk != NULL && dwEntityBodyFirstChunkSize != 0 )
	{
		dwIncrement = dwEntityBodyFirstChunkSize;

		if ( dwSize + dwIncrement > dwBufferSize && pBuffer != NULL )
		{
			return LISTENER_ERROR;
		}

		if ( pBuffer != NULL )
		{
			memcpy( pBuffer + dwSize, pEntityBodyFirstChunk, dwIncrement );
		}
		dwSize += dwIncrement;
	}

	return dwSize;

} // ResponseFormat()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\chat\client\client.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	client.c

Abstract:

	CLIENT - sample chat client for skeleton.vxd.

Author:

    Mauro Ottaviani (mauroot)       21-Aug-1999

Revision History:

--*/


#include "..\chat.h"


VOID
WINAPI
__stdcall
Publisher( LPVOID lpParam );

URIHANDLE
	hUlPub = UL_INVALID_URIHANDLE;
	
HANDLE
	hExitThread = NULL,
	hPubThread = NULL;

WCHAR
	pUri[CHAT_BUFFER_SIZE];

VOID
__cdecl
main( int argc, char *argv[] )
{
	ULONG result, ulSize, ulCount;
	DWORD dwThreadId, dwWhich;
	OVERLAPPED Overlapped;

	if ( argc != 2 )
	{
		printf( "Microsoft (R) Chat Client Version 1.00 (NT)\nCopyright (C) Microsoft Corp 1999. All rights reserved.\nusage: CLIENT uri\n" );
		return;
	}

	result = UlInitialize( 0L );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(CLIENT/SUB) UlInitialize() failed. result:%u\n", result );
		goto cleanup;
	}

	for ( ulCount = 0; argv[1][ulCount] != '\0'; ulCount++ ) pUri[ulCount] = argv[1][ulCount];
	pUri[ulCount] = 0;
	ulSize = sizeof( WCHAR ) * ( ulCount + 1 );

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	result = UlSendMessage(
							UL_INVALID_URIHANDLE,
							NULL,
							CHAT_SUB_URI,
							pUri,
							ulSize,
							&ulCount,
							&Overlapped );

	if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
	{
		printf( "(CLIENT/SUB) UlSendMessage() failed. result:%u\n", result );
		goto cleanup;
	}

	dwWhich = WaitForSingleObject( Overlapped.hEvent, CHAT_SUB_CLIENT_TIMEOUT );

	if ( dwWhich != WAIT_OBJECT_0 )
	{
		printf( "(CLIENT/SUB) Uri:%s Chat Server Timed Out. Exiting...\n", argv[1] );
		goto cleanup;
	}

	printf( "(CLIENT/SUB) Uri:%s Chat Server contacted\n", argv[1] );

	result = UlRegisterUri( &hUlPub, UL_INVALID_URIHANDLE, pUri, 0L );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(CLIENT/SUB) UlRegisterUri() failed. result:%u\n", result );
		goto cleanup;
	}

	hExitThread = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( hExitThread == NULL ) goto cleanup;

	hPubThread = CreateThread(
								( LPSECURITY_ATTRIBUTES ) NULL,
								( DWORD ) 0,
								( LPTHREAD_START_ROUTINE ) Publisher,
								( LPVOID ) 0,
								( DWORD ) 0,
								&dwThreadId );

	if ( hPubThread == NULL ) goto cleanup;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	while ( TRUE )
	{
		BYTE pBuffer[CHAT_BUFFER_SIZE];
		ULONG ulCount, ulSize;

		gets( pBuffer );
		ulSize = lstrlenA( pBuffer );

		if ( ulSize == 0 ) break;

		result = UlSendMessage(
								UL_INVALID_URIHANDLE,
								NULL,
								CHAT_PUB_URI,
								pBuffer,
								ulSize,
								&ulCount,
								&Overlapped );

		if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
		{
			printf( "(CLIENT/SUB) UlSendMessage() failed. result:%u\n", result );
			break;
		}

		dwWhich = WaitForSingleObject( Overlapped.hEvent, CHAT_PUB_CLIENT_TIMEOUT );

		if ( dwWhich != WAIT_OBJECT_0 )
		{
			printf( "(CLIENT/SUB) (1) WaitForSingleObject returns %08X\n", dwWhich );
			break;
		}

		printf( "(SND) \"%s\"\n", pBuffer );
	}

cleanup:

	SetEvent( hExitThread );

	WaitForSingleObject( hPubThread, CHAT_PUB_CLIENT_TIMEOUT );

	UlTerminate();

	return;
}


VOID
WINAPI
__stdcall
Publisher( LPVOID lpParam )
{

	HANDLE lpHandles[CHAT_EVENTS_SIZE];
	OVERLAPPED Overlapped;
	BYTE pBuffer[CHAT_BUFFER_SIZE];
	ULONG dwWhich, result, dwSize, ulCount, ulSize;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	lpHandles[CHAT_EVENTS_EXIT] = hExitThread;
	lpHandles[CHAT_EVENTS_PUB] = Overlapped.hEvent;

	while ( TRUE )
	{
		memset( pBuffer, 0, CHAT_BUFFER_SIZE );
		
		result = UlReceiveMessage(
									hUlPub,
									pBuffer,
									CHAT_BUFFER_SIZE,
									&ulCount,
									NULL,
									&Overlapped );

		if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
		{
			printf( "(CLIENT/PUB) UlReceiveMessage() failed. result:%u\n", result );
			break;
		}

		dwWhich = WaitForMultipleObjects( CHAT_EVENTS_SIZE, lpHandles, FALSE, INFINITE );

		if ( dwWhich - WAIT_OBJECT_0 != CHAT_EVENTS_PUB )
		{
			break;
		}

		printf( "(RCV) \"%s\"\n", pBuffer );
	}

	result = UlUnregisterUri( hUlPub );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(CLIENT/PUB) UlUnregisterUri() failed. result:%u\n", result );
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\listener.c ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

    listener.c
    
Abstract:

    This is ul.exe, the unmanaged listener, it will bind to the selected port
    (80), and listen for HTTP Requests coming, through wsock2_32.dll, from the
    network, route them, through ul.vxd, to registered application, get the
    Responses from the application and send them back on the network.

Author:

    Mauro Ottaviani ( mauroot )       01-Nov-1999

Revision History:

--*/

#include "listener.h"
#include "structs.h"



//
// Main Function
//

VOID
__cdecl
main( int argc, char *argv[] )
{
	WSADATA wsaData;
	SOCKET listen_socket;
	SOCKADDR_IN sServer, sClient;
	HOSTENT *pHostEnt;
	DWORD dwError, dwStatus, dwThreadId;
	BOOL bOK;
	int result, size, i;
	CHAR* this_host;
	ULONG
		RemoteIPAddress, Mask, Masked, GreatestCommonSubnet, IPAddressToBind;

	HANDLE
		hConnectionsManager = NULL,
		hShutDown = NULL,
		hReceive = NULL;

	hAccept = NULL;
	hUpdate = NULL;
	hExitSM = NULL;

	LISTENER_DBGPRINTF((
		"Microsoft (R) Listener Version 1.00 (NT)\n"
		"Copyright (C) Microsoft Corp 1999. All rights reserved.\n" ));


	//
	// Command Line Checking
	//

	if ( argc != 3 )
	{
		LISTENER_DBGPRINTF((
			"usage: listener HostName Port\n"
			"example: listener mauroot98 80" ));
			
		return;
	}

	ulPort = atoi( argv[2] );

	if ( ulPort == 0 )
	{
		LISTENER_DBGPRINTF((
			"Invalid Port specified" ));

		return;
	}

	this_host = argv[1];


	//
	// ParseHttp Initialization
	//

	dwError = InitializeHttpUtil();
	LISTENER_ASSERT( dwError == STATUS_SUCCESS );

	dwError = InitializeParser();
	LISTENER_ASSERT( dwError == STATUS_SUCCESS );

	dwError = UlInitialize( 0 );
	LISTENER_ASSERT( dwError == ERROR_SUCCESS );

	//
	// Socket Initialization
	//

	result = WSAStartup( 0x0202, &wsaData );

	if ( result == SOCKET_ERROR )
	{
		LISTENER_DBGPRINTF((
			"listener!WSAStartup() failed err:%d", WSAGetLastError() ));
			
		WSACleanup();
		
		return;
	}


	IPAddressToBind = inet_addr( this_host );

	if ( IPAddressToBind = INADDR_NONE )
	{
		pHostEnt = gethostbyname( this_host );
	}
	else
	{
		pHostEnt = gethostbyaddr( (CHAR*) &IPAddressToBind, 4, AF_INET );
	}

	if ( pHostEnt == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!Internet name resolution:%s failed err:%d",
			this_host, WSAGetLastError() ));
			
		WSACleanup();
		
		return;
	}

	LISTENER_ASSERT(
		pHostEnt->h_addrtype == AF_INET
		&& pHostEnt->h_length == 4 );


	//
	// CODEWORK:
	// How will a route requests < HTTP/1.0 with no Host: header???
	// I need, at least, a default Host: to set for those requests.
	//

	//
	// compute the greatest common subnet:
	//

	GreatestCommonSubnet = 0;
	Mask = 0x80000000;
	
	do
	{
		Masked = Mask & SWAP_LONG( *((ULONG*)(pHostEnt->h_addr_list[0])) );

		for ( i = 1; pHostEnt->h_addr_list[i] != NULL; i++ )
		{
			if ( Masked != ( Mask & SWAP_LONG( *((ULONG*)(pHostEnt->h_addr_list[i])) ) ) )
			{
				Mask = 0;
				break;
			}
		}

		if ( Mask == 0 ) break;

		GreatestCommonSubnet |= Mask;
		Mask >>= 1;
		
	} while ( Mask != 0 );

	GreatestCommonSubnet = SWAP_LONG( GreatestCommonSubnet );
	IPAddressToBind = GreatestCommonSubnet;

	for ( i = 0; pHostEnt->h_addr_list[i] != NULL; i++ )
	{
		IPAddressToBind &= *((ULONG*)(pHostEnt->h_addr_list[i]));
	}

	LISTENER_DBGPRINTF((
		"listener!GreatestCommonSubnet:%08X:%d.%d.%d.%d",
			SWAP_LONG( GreatestCommonSubnet ),
			GreatestCommonSubnet     & 0xFF,
			GreatestCommonSubnet>>8  & 0xFF,
			GreatestCommonSubnet>>16 & 0xFF,
			GreatestCommonSubnet>>24 & 0xFF ));

	LISTENER_DBGPRINTF((
		"listener!IPAddressToBind:%08X:%d.%d.%d.%d:%d",
			SWAP_LONG( IPAddressToBind ),
			IPAddressToBind     & 0xFF,
			IPAddressToBind>>8  & 0xFF,
			IPAddressToBind>>16 & 0xFF,
			IPAddressToBind>>24 & 0xFF,
			ulPort ));

	//
	// Change this and just bind to 0.0.0.0 on the specified port
	// if somebody owns a more specific subnet on IP matching, sockets
	// will give them higher priority.
	//

	IPAddressToBind = 0;

	gLocalIPAdress = IPAddressToBind;
	
	memset( &sServer, 0, sizeof( SOCKADDR_IN ) );
	
	sServer.sin_addr.s_addr = IPAddressToBind;
	sServer.sin_family = AF_INET;
	sServer.sin_port = htons( ( USHORT ) ulPort );

	listen_socket = WSASocket( // socket( AF_INET, SOCK_STREAM, 0 );
		AF_INET,
		SOCK_STREAM,
		IPPROTO_TCP,
		NULL, // protocol info
		0, // Group ID = 0 => no constraints
		WSA_FLAG_OVERLAPPED );
		
	if ( listen_socket == INVALID_SOCKET )
	{
		LISTENER_DBGPRINTF((
			"listener!WSASocket() failed err:%d", WSAGetLastError() ));
			
		WSACleanup();
		
		return;
	}

	result = bind(
		listen_socket,
		(SOCKADDR*) &sServer,
		sizeof( SOCKADDR ) );

	if ( result == SOCKET_ERROR )
	{
		LISTENER_DBGPRINTF((
			"listener!bind() failed err:%d", WSAGetLastError() ));
			
		WSACleanup();
		
		return;
	}

	result = listen(
		listen_socket,
		SOMAXCONN );

	if ( result == SOCKET_ERROR )
	{
		LISTENER_DBGPRINTF((
			"listener!listen() failed err:%d", WSAGetLastError() ));
			
		WSACleanup();
		
		return;
	}


	//
	// Thread Stuff
	//

	//
	// Create the ExitSM event: this will be signaled to ask the
	// ConnectionsManager to greacefully clean up and exit.
	//

	hExitSM = CreateEvent( NULL, FALSE, FALSE, NULL );
	
	if ( hExitSM == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!FAILED Creating Event Handle: err#%d",
			GetLastError() ));

		dwError = GetLastError();

		goto cleanup;
	}
	else
	{
		LISTENER_DBGPRINTF((
			"listener!New Event Handle: hEvent:%08X",
			hExitSM ));
	}

	// Create the Update event: this will be signaled when a connection to
	// a new Socket is made, to ask the ConnectionsManager to update the
	// SocketsDB up and restart receiveing data.

	hUpdate = CreateEvent( NULL, FALSE, FALSE, NULL );
	
	if ( hUpdate == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!FAILED Creating Event Handle: err#%d",
			GetLastError() ));

		dwError = GetLastError();

		goto cleanup;
	}
	else
	{
		LISTENER_DBGPRINTF((
			"listener!New Event Handle: hEvent:%08X",
			hUpdate ));
	}

	// Create the Accept event: this will be signaled when the
	// ConnectionsManager has finished updating the SocketsDB so we can accept
	// other connections.

	hAccept = CreateEvent( NULL, FALSE, FALSE, NULL );
	
	if ( hAccept == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!FAILED Creating Event Handle: err#%d",
			GetLastError() ));

		dwError = GetLastError();

		goto cleanup;
	}
	else
	{
		LISTENER_DBGPRINTF((
			"listener!New Event Handle: hEvent:%08X",
			hAccept ));
	}

	// Create the Receive event: this will be signaled from the
	// ConnectionsManager when it has finished reading a Request that
	// needs to be picked up by the RequestsManager.

	hReceive = CreateEvent( NULL, FALSE, FALSE, NULL );
	
	if ( hReceive == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!FAILED Creating Event Handle: err#%d",
			GetLastError() ));

		dwError = GetLastError();

		goto cleanup;
	}
	else
	{
		LISTENER_DBGPRINTF((
			"listener!New Event Handle: hEvent:%08X",
			hReceive ));
	}

	// NOT USED YET:
	// Create the ShutDown event: this will be signaled when we
	// want to shut down the listener.

	// CODEWORK:
	// I could associate this event to a 0 length NULL buffer UlReceive
	// call, on a "ul://hShutDown" registered Uri. Any UlSend on that Uri
	// would cause the listener to gracefully shut down. Good idea???

	hShutDown = CreateEvent( NULL, FALSE, FALSE, NULL );
	
	if ( hShutDown == NULL )
	{
		LISTENER_DBGPRINTF((
			"listener!FAILED Creating Event Handle: err#%d",
			GetLastError() ));

		dwError = GetLastError();

		goto cleanup;
	}
	else
	{
		LISTENER_DBGPRINTF((
			"listener!New Event Handle: hEvent:%08X",
			hShutDown ));
	}

	// Start the ConnectionsManager Thread

	LISTENER_DBGPRINTF((
		"listener!Starting ConnectionsManager Thread..." ));

	hConnectionsManager =
		CreateThread(
			NULL,
			0,
			(LPTHREAD_START_ROUTINE) ConnectionsManager,
			NULL,
			0,
			&dwThreadId );

	if ( hConnectionsManager == NULL )
	{
		dwError = GetLastError();
		
		goto cleanup;
	}

	while ( TRUE )
	{
		memset( &sClient, 0, size = sizeof( SOCKADDR_IN ) );

		LISTENER_DBGPRINTF(( "listener!Accepting Connections...(%d)", size ));

		gAcceptSocket = accept(
			listen_socket,                   
			(SOCKADDR*) &sClient,
			&size );

		LISTENER_DBGPRINTF(( "listener!accept called" ));

		if ( gAcceptSocket == INVALID_SOCKET )
		{
			LISTENER_DBGPRINTF((
				"listener!accept() failed err:%d", WSAGetLastError() ));

			dwError = WSAGetLastError();
		
			goto cleanup;
		}

		gRemoteIPAddress = sClient.sin_addr.s_addr;
		
		LISTENER_DBGPRINTF((
			"listener!Client connected size:%d gAcceptSocket:%08X "
			"gRemoteIPAddress:%08X (%d.%d.%d.%d:%d)",
			size,
			gAcceptSocket,
			gRemoteIPAddress,
			sClient.sin_addr.S_un.S_un_b.s_b4,
			sClient.sin_addr.S_un.S_un_b.s_b3,
			sClient.sin_addr.S_un.S_un_b.s_b2,
			sClient.sin_addr.S_un.S_un_b.s_b1, ulPort ));

		// signal the ConnectionsManager() thread to add this
		// gAcceptSocket to the list of connected sockets.

		LISTENER_DBGPRINTF(( "listener!calling WSASetEvent()" ));

		bOK = SetEvent( hUpdate );
		LISTENER_ASSERT( bOK );

		// wait for the Thread to update and signal the Accept event

		LISTENER_DBGPRINTF(( "listener!calling WaitForSingleObject()" ));

		dwStatus = WaitForSingleObject( hAccept, LISTENER_WAIT_TIMEOUT*1000 );
			
	    if ( dwStatus != WAIT_TIMEOUT )
	    {
			LISTENER_ASSERT( dwStatus == WAIT_OBJECT_0  );
	    }
	    else
	    {
		    // if the previous wait timed out, the ConnectionsManager is
		    // probably hanged or unhealthy. best thing is to clean up
		    // everything and restart from the beginning.

		    // Clean-Up and restart
	    }
	}

cleanup:

 	// Signal the ConnectionsManager for termination

	if ( hConnectionsManager != NULL )
	{
		BOOL bOK;
		DWORD dwWhich;
		
		LISTENER_DBGPRINTF((
			"[THRDTERMN] Terminating ConnectionsManager Thread hThread:%08X "
			"signaling event hEvent:%08X",
			hConnectionsManager,
			hExitSM ));
			
		SetEvent( hExitSM );

		dwWhich =
			WaitForSingleObject(
				hConnectionsManager,
				LISTENER_WAIT_TIMEOUT * 1000 );
		
	    if ( dwWhich == WAIT_OBJECT_0 )
	    {
	    	bOK = CloseHandle( hConnectionsManager );
	    	LISTENER_ASSERT( bOK );
	    }
	    else
	    {
	    	bOK = TerminateThread( hConnectionsManager, FALSE );
	    	LISTENER_ASSERT( bOK );
	    }
	    
		hConnectionsManager = NULL;
	}

	if ( hExitSM != NULL )
	{
		BOOL bOK;
		
		LISTENER_DBGPRINTF((
			"[EVNTCLOSR] Closing Event Handle hEvent:%08X)",
			hExitSM ));
			
		bOK = CloseHandle( hExitSM );
		LISTENER_ASSERT( bOK );
		
		hExitSM = NULL;
	}

	if ( hUpdate != NULL )
	{
		BOOL bOK;
		
		LISTENER_DBGPRINTF((
			"[EVNTCLOSR] Closing Event Handle hEvent:%08X)",
			hUpdate ));
			
		bOK = CloseHandle( hUpdate );
		LISTENER_ASSERT( bOK );
		
		hUpdate = NULL;
	}

	if ( hAccept != NULL )
	{
		BOOL bOK;
		
		LISTENER_DBGPRINTF((
			"[EVNTCLOSR] Closing Event Handle hEvent:%08X)",
			hAccept ));
			
		bOK = CloseHandle( hAccept );
		LISTENER_ASSERT( bOK );
		
		hAccept = NULL;
	}

	if ( hReceive != NULL )
	{
		BOOL bOK;
		
		LISTENER_DBGPRINTF((
			"[EVNTCLOSR] Closing Event Handle hEvent:%08X)",
			hReceive ));
			
		bOK = CloseHandle( hReceive );
		LISTENER_ASSERT( bOK );
		
		hReceive = NULL;
	}

	if ( hShutDown != NULL )
	{
		BOOL bOK;
		
		LISTENER_DBGPRINTF((
			"[EVNTCLOSR] Closing Event Handle hEvent:%08X)",
			hShutDown ));
			
		bOK = CloseHandle( hShutDown );
		LISTENER_ASSERT( bOK );
		
		hShutDown = NULL;
	}

 	// Terminate Sockets Session

	WSACleanup();

 	// Terminate Ul Session

	UlTerminate();

	return;
	
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\structs.c ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

	structs.c
	
Abstract:

	XXX

Author:

    Mauro Ottaviani ( mauroot )       15-Dec-1999

Revision History:

--*/

    
#include "connmngr.h"



/*++

Routine Description:

    UlpFreeHttpRequest().
	Gracefully and Robustly frees a HTTP_REQUEST

Arguments:

    pRequest
    	pointer to the HTTP_REQUEST structure that contains information
    	on the request with which we are dealing.

Return Value:

    VOID

--*/

VOID
UlpFreeHttpRequest(
	HTTP_REQUEST *pRequest,
	LISTENER_CONNECTION *pConnection )
{

// I need the following hack beacuse somehow the one in debug.h doesn't work.

#define UL_VXD_FREE_POOL( ptr, tag )\
	HeapFree( GetProcessHeap(), 0 , (ptr) ) // UL_FREE_POOL( ptr, tag )

	int i;
	DWORD dwError;
	PLIST_ENTRY pList;

	LISTENER_DBGPRINTF((
		"UlpFreeHttpRequest!freeing pRequest:%08X (%016X)",
		pRequest, pRequest->RequestId ));

	if ( pRequest == NULL )
	{
		return;
	}

	//
	// cancel all pending IOs with ul.vxd
	//

	if ( UL_IS_NULL_ID( &pRequest->RequestId ) == FALSE )
	{
		dwError = UlCancelRequest( &pRequest->RequestId );

		if ( dwError != LISTENER_SUCCESS )
		{
			//
			// if this call fails it's no problem, it will usually fail if
			// the request completed already
			//

			LISTENER_DBGPRINTF((
				"UlpFreeHttpRequest!UlCancelRequest() failed err#%d", dwError ));
		}
	}
	
	//
    // free any known header buffers allocated
    //

    for (i = 0; i < UlHeaderRequestMaximum; i++)
    {
        if (pRequest->Headers[i].Valid == 1 &&
            pRequest->Headers[i].OurBuffer == 1)
        {
			LISTENER_DBGPRINTF((
				"UlpFreeHttpRequest!freeing %08X", pRequest->Headers[i].pHeader ));

            UL_VXD_FREE_POOL(
                pRequest->Headers[i].pHeader,
                HEADER_VALUE_POOL_TAG );

            pRequest->Headers[i].OurBuffer = 0;
            pRequest->Headers[i].Valid = 0;
        }
    }

    //
    // and any unknown header buffers allocated
    //

    while (IsListEmpty(&pRequest->UnknownHeaderList) == FALSE)
    {
        PHTTP_UNKNOWN_HEADER pUnknownHeader;

        pList = RemoveHeadList(&pRequest->UnknownHeaderList);
        pList->Flink = pList->Blink = NULL;

        pUnknownHeader = CONTAINING_RECORD(
                                pList,
                                HTTP_UNKNOWN_HEADER,
                                List
                                );

        if (pUnknownHeader->HeaderValue.OurBuffer == 1)
        {
			LISTENER_DBGPRINTF((
				"UlpFreeHttpRequest!freeing %08X", pUnknownHeader->HeaderValue.pHeader ));

            UL_VXD_FREE_POOL(
                pUnknownHeader->HeaderValue.pHeader,
                HEADER_VALUE_POOL_TAG );

            pUnknownHeader->HeaderValue.OurBuffer = 0;
        }

        //
        // Free the header structure
        //

		LISTENER_DBGPRINTF((
			"UlpFreeHttpRequest!freeing %08X", pUnknownHeader ));

        UL_VXD_FREE_POOL( pUnknownHeader, HTTP_UNKNOWN_HEADER_POOL_TAG );
    }

    LISTENER_DBGPRINTF((
		"UlpFreeHttpRequest!memory freed pRequest:%08X",
		pRequest ));

	return;
}




/*++

Routine Description:

    BufferReadCleanup().
	Gracefully and Robustly frees a LISTENER_BUFFER_READ

Arguments:

    pBufferRead
    	pointer to the LISTENER_BUFFER_READ structure that contains information
    	on the request with which we are dealing.

Return Value:

    VOID

--*/

VOID
BufferReadCleanup(
	LISTENER_BUFFER_READ *pBufferRead,
	LISTENER_CONNECTION *pConnection )
{
	if ( pBufferRead == NULL || pBufferRead->pBuffer == NULL )
	{
		LISTENER_DBGPRINTF(( "BufferReadCleanup!FAILED: NULL pointer" ));
		
		return;
	}

	LISTENER_FREE(
		pBufferRead->pBuffer,
		pBufferRead->dwBufferSize,
		pConnection );

	return;

} // BufferReadCleanup


/*++

Routine Description:

    BufferWriteCleanup().
	Gracefully and Robustly frees a LISTENER_BUFFER_WRITE

Arguments:

    pBufferWrite
    	pointer to the LISTENER_BUFFER_WRITE structure that contains information
    	on the request with which we are dealing.

Return Value:

    VOID

--*/

VOID
BufferWriteCleanup(
	LISTENER_BUFFER_WRITE *pBufferWrite,
	LISTENER_CONNECTION *pConnection )
{
	if ( pBufferWrite == NULL || pBufferWrite->pBuffer == NULL )
	{
		LISTENER_DBGPRINTF(( "BufferWriteCleanup!FAILED: NULL pointer" ));
		
		return;
	}

	LISTENER_FREE(
		pBufferWrite->pBuffer,
		pBufferWrite->dwBufferSize,
		pConnection );

	return;
	
} // BufferWriteCleanup


/*++

Routine Description:

    RequestCleanup().
	Gracefully and Robustly frees a LISTENER_REQUEST

Arguments:

    pPendRequest
    	pointer to the LISTENER_REQUEST structure that contains information
    	on the request with which we are dealing.

Return Value:

    VOID

--*/

VOID
RequestCleanup(
	LISTENER_REQUEST *pPendRequest,
	LISTENER_CONNECTION *pConnection )
{
	LIST_ENTRY *pBufferWriteList, *pBufferReadList;
	LISTENER_BUFFER_WRITE *pBufferWrite;
	LISTENER_BUFFER_READ *pBufferRead;

	LISTENER_DBGPRINTF((
		"RequestCleanup!cleaning pPendRequest:%08X",
		pPendRequest ));

	if ( pPendRequest == NULL )
	{
		return;
	}

	//
	// Free the HTTP_REQUEST structure
	//

	LISTENER_DBGPRINTF((
		"RequestCleanup!Calling UlpFreeHttpRequest(%08X)",
		pPendRequest->pRequest ));

	UlpFreeHttpRequest(
		pPendRequest->pRequest,
		pConnection );

	LISTENER_DBGPRINTF((
		"RequestCleanup!freeing HTTP_REQUEST pRequest:%08X",
		pPendRequest->pRequest ));

	LISTENER_FREE(
		pPendRequest->pRequest,
		pPendRequest->ulRequestSize,
		pConnection );

	//
	// Free the UL_HTTP_RESPONSE structure
	//

	LISTENER_DBGPRINTF((
		"RequestCleanup!freeing UL_HTTP_RESPONSE pUlResponse:%08X",
		pPendRequest->pUlResponse ));

	LISTENER_FREE(
		pPendRequest->pUlResponse,
		pPendRequest->ulUlResponseSize,
		pConnection );

	//
	// release all the Read Buffers exisiting
	// for this Pending Requests.
	//

	if ( pPendRequest->pRequestHeadersBuffer != NULL
		&& pPendRequest->ulRequestHeadersBufferSize > 0 )
	{
		LISTENER_DBGPRINTF((
			"RequestCleanup!freeing pHeadersBuffer:%08X",
			pPendRequest->pRequestHeadersBuffer ));

		LISTENER_FREE(
			pPendRequest->pRequestHeadersBuffer,
			pPendRequest->ulRequestHeadersBufferSize,
			pConnection );
	}

	if ( pPendRequest->pReqBodyChunk != NULL && pPendRequest->ulReqBodyChunkSize > 0 )
	{
		LISTENER_DBGPRINTF((
			"RequestCleanup!freeing pReqBodyChunk:%08X",
			pPendRequest->pReqBodyChunk ));

		LISTENER_FREE(
			pPendRequest->pReqBodyChunk,
			pPendRequest->ulReqBodyChunkSize,
			pConnection );
	}

	pBufferReadList = pPendRequest->BufferReadHead.Flink;

	while ( pBufferReadList != &pPendRequest->BufferReadHead )
	{
	    pBufferRead =
	    CONTAINING_RECORD(
			pBufferReadList,
			LISTENER_BUFFER_READ,
			List );

		pBufferReadList = pBufferReadList->Flink;

		RemoveEntryList( &pBufferRead->List );

		BufferReadCleanup(
			pBufferRead,
			pConnection );
	}

	pBufferWriteList = pPendRequest->BufferWriteHead.Flink;

	while ( pBufferWriteList != &pPendRequest->BufferWriteHead )
	{
	    pBufferWrite =
	    CONTAINING_RECORD(
			pBufferWriteList,
			LISTENER_BUFFER_WRITE,
			List );

		pBufferWriteList = pBufferWriteList->Flink;

		RemoveEntryList( &pBufferWrite->List );

		BufferWriteCleanup(
			pBufferWrite,
			pConnection );
	}

	LISTENER_DBGPRINTF((
		"RequestCleanup!freeing memory pPendRequest:%08X",
		pPendRequest ));

	LISTENER_FREE(
		pPendRequest,
		sizeof( LISTENER_REQUEST ),
		pConnection );

	return;

} // RequestCleanup


/*++

Routine Description:

    ConnectionCleanup().
	Gracefully and Robustly frees a LISTENER_CONNECTION
	(this also closes the connection)

Arguments:

    pConnection
    	pointer to the LISTENER_CONNECTION structure that contains information
    	on the connection with which we are dealing.

Return Value:

    VOID

--*/

VOID
ConnectionCleanup(
	LISTENER_CONNECTION *pConnection )
{
	LISTENER_REQUEST *pPendRequest;
	LIST_ENTRY *pList;
	DWORD dwError, dwEventIndex;

	if ( pConnection == NULL )
	{
		return;
	}

	LISTENER_DBGPRINTF((
		"ConnectionCleanup!Cleaning up after connection:%08X socket:%08X",
		pConnection,
		pConnection->socket ));

	// disconnect and close the socket

	closesocket( pConnection->socket );

	// close the event handles:

	for ( dwEventIndex = 0;
		dwEventIndex < LISTENER_CONNECTION_EVENTS; dwEventIndex++ )
	{
		if ( pConnection->pOverlapped[dwEventIndex].hEvent != NULL )
		{
			BOOL bOK;
			
			LISTENER_DBGPRINTF((
				"ConnectionCleanup!Closing Event Handle hEvent:%08X)",
				pConnection->pOverlapped[dwEventIndex].hEvent ));
				
			bOK =
			CloseHandle(
				pConnection->pOverlapped[dwEventIndex].hEvent );
				
			LISTENER_ASSERT( bOK );
			
			pConnection->pOverlapped[dwEventIndex].hEvent = NULL;
		}
	}

	//
	// release all the Pending Requests exisiting
	// for this Connection.
	//

	pList = pConnection->PendRequestHead.Flink;

	while( pList != &pConnection->PendRequestHead )
	{
		pPendRequest =
		CONTAINING_RECORD(
			pList,
			LISTENER_REQUEST,
			List );

        pList = pList->Flink;

		RemoveEntryList( &pPendRequest->List );

		RequestCleanup(
			pPendRequest,
			pConnection );
	}

	LISTENER_DBGPRINTF((
		"ConnectionCleanup!Memory freed p:%08X",
		pConnection ));

	LISTENER_FREE(
		pConnection,
		sizeof( LISTENER_CONNECTION ),
		pConnection );

	return;

} // ConnectionCleanup


/*++

Routine Description:

    CreateRequest().
    we allocate a LISTENER_REQUEST structure, we initialize it, and stick it
    in the associated connection. each connection mantains a queue of requests
    in order to obey the FIFO request/repsonse HTTP model

Arguments:

    pConnection
    	pointer to the LISTENER_CONNECTION structure that contains information
    	on the connection with which we are dealing.

    dwSize
    	size of the first READ buffer to allocate

Return Value:

    LISTENER_SUCCESS.

--*/

DWORD
CreateRequest(
	LISTENER_CONNECTION *pConnection,
	DWORD dwBufferSize )
{
	LISTENER_BUFFER_READ *pBufferRead = NULL;
	LISTENER_REQUEST *pPendRequest = NULL;

	DWORD dwError;

	//
	// allocate a LISTENER_REQUEST record
	//

	LISTENER_ALLOCATE(
		LISTENER_REQUEST*,
		pPendRequest,
		sizeof( LISTENER_REQUEST ),
		pConnection );

	if ( pPendRequest == NULL )
	{
		LISTENER_DBGPRINTF((
			"InitializeListenerRequest!FAILED memory allocation: err#%d",
			GetLastError() ));
			
		goto failure;
	}

	LISTENER_DBGPRINTF((
		"InitializeListenerRequest!setting default values" ));

	pPendRequest->bFormatResponseBasedOnErrorCode = FALSE;
	pPendRequest->bKeepAlive = FALSE;
	pPendRequest->bDoneWritingToSocket = FALSE;
	pPendRequest->bDoneReadingFromVxd = FALSE;
	pPendRequest->bDoneWritingToVxd = FALSE;
	pPendRequest->ResponseContentLength = -1;
	pPendRequest->RequestSendStatus = RequestSendStatusInitialized;
	pPendRequest->ResponseReceiveStatus = ResponseReceiveStatusInitialized;
	pPendRequest->pRequestHeadersBuffer = NULL;
	pPendRequest->ulRequestHeadersBufferSize = 0;
	pPendRequest->pReqBodyChunk = NULL;
	pPendRequest->ulReqBodyChunkSize = 0;
	pPendRequest->pRequest = NULL;
	pPendRequest->ulRequestSize = 0;
	pPendRequest->pUlResponse = NULL;
	pPendRequest->ulUlResponseSize = 0;

	memset( &pPendRequest->OverlappedBOF, 0, sizeof( OVERLAPPED ) );
	memset( &pPendRequest->OverlappedEOF, 0, sizeof( OVERLAPPED ) );
	memset( &pPendRequest->OverlappedResponseBOF, 0, sizeof( OVERLAPPED ) );


	//
	// Initialize the list of LISTENER_BUFFER_READ records
	//

	InitializeListHead( &pPendRequest->BufferReadHead );
	InitializeListHead( &pPendRequest->BufferWriteHead );

	//
	// allocate a HTTP_REQUEST structure
	//

	LISTENER_DBGPRINTF((
		"InitializeListenerRequest!allocating a HTTP_REQUEST structure" ));

	LISTENER_ALLOCATE(
		HTTP_REQUEST*,
		pPendRequest->pRequest,
		sizeof( HTTP_REQUEST ),
		pConnection );

	if ( pPendRequest->pRequest == NULL )
	{
		LISTENER_DBGPRINTF((
			"InitializeListenerRequest!FAILED memory allocation: err#%d",
			GetLastError() ));
			
		goto failure;
	}

	pPendRequest->ulRequestSize = sizeof( HTTP_REQUEST );

	LISTENER_DBGPRINTF((
		"InitializeListenerRequest!setting HTTP_REQUEST default values" ));

	// Initialize the HTTP_REQUEST structure
	// (check UlCreateHttpRequest() in <HttpConn.c>)
	pPendRequest->pRequest->Signature = HTTP_REQUEST_POOL_TAG;
	pPendRequest->pRequest->RequestId = UL_NULL_ID;
	pPendRequest->pRequest->pHttpConn = (PVOID)-1;
	pPendRequest->pRequest->pAppPoolResource = (PVOID)-1;
	pPendRequest->pRequest->RefCount = 1;
	pPendRequest->pRequest->ParseState = ParseVerbState;
	pPendRequest->pRequest->ErrorCode = UlError;
	pPendRequest->pRequest->ContentLength = -1;

	InitializeListHead( &pPendRequest->pRequest->UnknownHeaderList );
	InitializeListHead( &pPendRequest->pRequest->IrpHead );

	//
	// allocate the first LISTENER_BUFFER_READ record
	//

	LISTENER_ALLOCATE(
		LISTENER_BUFFER_READ*,
		pBufferRead,
		sizeof( LISTENER_BUFFER_READ ),
		pConnection );

	if ( pBufferRead == NULL )
	{
		LISTENER_DBGPRINTF((
			"InitializeListenerRequest!FAILED memory allocation: err#%d",
			GetLastError() ));
			
		goto failure;
	}

	//
	// allocate the read buffer
	//

	LISTENER_ALLOCATE(
		PUCHAR,
		pBufferRead->pBuffer,
		dwBufferSize,
		pConnection );

	if ( pBufferRead->pBuffer == NULL )
	{
		LISTENER_DBGPRINTF((
			"InitializeListenerRequest!FAILED memory allocation: err#%d",
			GetLastError() ));
			
		goto failure;
	}

	pBufferRead->dwBytesReceived = 0;
	pBufferRead->dwBytesParsed = 0;
	pBufferRead->dwBufferSize = dwBufferSize;
	memset( &pBufferRead->Overlapped, 0, sizeof( OVERLAPPED ) );
	pBufferRead->Overlapped.hEvent =
		pConnection->pOverlapped[LISTENER_VXD_WRITE].hEvent;

	//
	// Add this to the list of LISTENER_BUFFER_READ records
	//

	InsertTailList( &pPendRequest->BufferReadHead, &pBufferRead->List );

	LISTENER_DBGPRINTF((
		"InitializeListenerRequest!LISTENER_REQUEST in %08X succeeded "
		"(HTTP_REQUEST:%08X LISTENER_BUFFER_READ:%08X pBuffer:%08X)",
		pPendRequest, pPendRequest->pRequest,
		pBufferRead, pBufferRead->pBuffer ));

	//
	// Add this to the list of LISTENER_REQUEST records
	//

	InsertTailList(
		&pConnection->PendRequestHead, &pPendRequest->List );

	// ul.vxd is going to give each request an ID so that we can match incoming
	// responses with requests that were sent to applications.

	// Copy the LISTENER_VXD_WRITE event in the overlapped structure, since
	// we can have multiple pending writes with the vxd (in order to improve
	// throughput by taking advantage of asynchronous I/O), but we will use
	// the same event handle, since it is obvious (from the way the vxd's
	// messaging works) that when the event is signaled, th completed I/O was
	// the first issued.

	pPendRequest->OverlappedEOF.hEvent =
		pConnection->pOverlapped[LISTENER_VXD_WRITE].hEvent;

	pPendRequest->OverlappedBOF.hEvent =
		pConnection->pOverlapped[LISTENER_VXD_WRITE].hEvent;

	pPendRequest->OverlappedResponseBOF.hEvent =
		pConnection->pOverlapped[LISTENER_VXD_READ].hEvent;

	// we'll stuff, IP in pAppPoolResource and port in pHttpConn, since I'm
	// not using them and I need it to implement UlLocalAddressFromConnection

	pPendRequest->pRequest->pHttpConn = (PVOID)SWAP_SHORT(ulPort);
	pPendRequest->pRequest->pAppPoolResource = (PVOID)SWAP_LONG(pConnection->ulRemoteIPAddress);

	pConnection->ulTotalAllocatedMemory += dwBufferSize + sizeof( LISTENER_BUFFER_READ ) + sizeof( HTTP_REQUEST ) + sizeof( LISTENER_REQUEST );

	return LISTENER_SUCCESS;


failure:

	LISTENER_DBGPRINTF((
		"CreateRequest!CreateRequest() failed err:%d",
		GetLastError() ));

	if ( pPendRequest != NULL )
	{
		if ( pPendRequest->pRequest != NULL )
		{
			LISTENER_FREE(
				pPendRequest->pRequest,
				pPendRequest->ulRequestSize,
				pConnection );
		}

		LISTENER_FREE(
			pPendRequest,
			sizeof( LISTENER_REQUEST ),
			pConnection );
	}

	if ( pBufferRead != NULL )
	{
		if ( pBufferRead->pBuffer != NULL )
		{
			LISTENER_FREE(
				pBufferRead->pBuffer,
				pBufferRead->dwBufferSize,
				pConnection );
		}

		LISTENER_FREE(
			pBufferRead,
			sizeof( LISTENER_BUFFER_READ ),
			pConnection );
	}

	return LISTENER_GARBAGE_COLLECT;

} // CreateRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\listener\listener.h ===
/*++

Copyright ( c ) 1999-1999 Microsoft Corporation

Module Name:

    listener.h
    
Abstract:

    header file.

Author:

    Mauro Ottaviani ( mauroot )       15-Dec-1999

Revision History:

--*/

#include "precomp.h"


//
// fix DBG that might be screwed up by some ntos.h
//

#ifdef DBG

#if DBG
#undef DBG
#define DBG
#else // #ifdef DBG
#undef DBG
#endif // #ifdef DBG

#endif


#include "ulapi9x.h"
#include "precomp9x.h"

#include <winsock2.h>


#define LISTENER_ERROR	 					-1
#define LISTENER_SUCCESS 					0


//
//
// Configurable from user mode.
// These defines may affect listener's performance:
//
//

// recycle and health check every
// LISTENER_WAIT_TIMEOUT seconds
#define LISTENER_WAIT_TIMEOUT		    	120

// close connections inactive for more than
// LISTENER_CONNECTION_TIMEOUT seconds
#define LISTENER_CONNECTION_TIMEOUT			600 

// close connections older than
// LISTENER_CONNECTION_LIFETIME seconds
#define LISTENER_CONNECTION_LIFETIME		1800

/*
#define LISTENER_BUFFER_SCKREAD_SIZE		4096 // 4k
#define LISTENER_HEADERS_GUESSED_SIZE		4096 // 4k
#define LISTENER_BUFFER_VXDWRITE_SIZE		4096 // 4k
#define LISTENER_BUFFER_VXDREAD_SIZE		4096 // 4k
*/

#define LISTENER_BUFFER_SCKREAD_SIZE		8192 // 8k
#define LISTENER_HEADERS_GUESSED_SIZE		8192 // 8k
#define LISTENER_BUFFER_VXDWRITE_SIZE		8192 // 8k
#define LISTENER_BUFFER_VXDREAD_SIZE		8192 // 8k

#define LISTENER_MAX_HEADERS_SIZE			16384 // 16k


//
//
// Defines
//
//

#define LISTENER_SOCKET_FLAGS 				0

#define LISTENER_CNNCTMNGR_EXIT				0
#define LISTENER_CNNCTMNGR_PICKCNNCT		1
#define LISTENER_CNNCTMNGR_FIRSTEVENT		2

#define LISTENER_REQSTMNGR_EXIT				0
#define LISTENER_REQSTMNGR_PICKREQST		1
#define LISTENER_REQSTMNGR_FIRSTEVENT		2

#define LISTENER_SOCKET_READ				0
#define LISTENER_VXD_WRITE					1
#define LISTENER_VXD_READ					2
#define LISTENER_SOCKET_WRITE				3
#define LISTENER_CONNECTION_EVENTS			4




//
// Debug defines
//


#ifdef DBG



#define LISTENER_ASSERT(exp)\
	if (!(exp))\
	{\
		printf(\
			"Assertion failed: \""#exp"\" line #%d, Exiting...\n",\
			__LINE__ );\
		exit(TRUE);\
	}

#define LISTENER_DBGPRINTF(exp)\
	{printf exp; printf( " - line #%d.\n", __LINE__ ); fflush(stdout); }

#define LISTENER_STR_PARSE_STATE(x)\
	(\
	x==ParseVerbState?"ParseVerbState":\
	x==ParseUrlState?"ParseUrlState":\
	x==ParseVersionState?"ParseVersionState":\
	x==ParseHeadersState?"ParseHeadersState":\
	x==ParseCookState?"ParseCookState":\
	x==ParseEntityBodyState?"ParseEntityBodyState":\
	x==ParseTrailerState?"ParseTrailerState":\
	x==ParseDoneState?"ParseDoneState":\
	x==ParseErrorState?"ParseErrorState":\
	"ParseUNDEFINEDState"\
	)

#define LISTENER_STR_UL_ERROR(x)\
	(\
	x==UlError?"UlError":\
	x==UlErrorVerb?"UlErrorVerb":\
	x==UlErrorUrl?"UlErrorUrl":\
	x==UlErrorHeader?"UlErrorHeader":\
	x==UlErrorHost?"UlErrorHost":\
	x==UlErrorCRLF?"UlErrorCRLF":\
	x==UlErrorNum?"UlErrorNum":\
	x==UlErrorVersion?"UlErrorVersion":\
	x==UlErrorUnavailable?"UlErrorUnavailable":\
	x==UlErrorNotFound?"UlErrorNotFound":\
	x==UlErrorContentLength?"UlErrorContentLength":\
	x==UlErrorEntityTooLarge?"UlErrorEntityTooLarge":\
	x==UlErrorNotImplemented?"UlErrorNotImplemented":\
	"UlErrorUNDEFINED"\
	)

// I don't really need this get rid of it as soon as possible

#define LISTENER_DBGPRINTBUFFERS(x)\
	{ UCHAR a, *pB, pchData[16384]; DWORD i,j,k=0;\
	LIST_ENTRY *pList; LISTENER_BUFFER_READ *pBufferReadT;\
	pList = x->BufferReadHead.Flink;\
    while ( pList != &x->BufferReadHead )\
    { pBufferReadT = CONTAINING_RECORD( pList, LISTENER_BUFFER_READ, List );\
	pList = pList->Flink; pB=pBufferReadT->pBuffer;\
	for ( j=0,i=pBufferReadT->dwBytesParsed;\
	i<pBufferReadT->dwBytesReceived; i++,j++,pchData[j]=0 ) {\
	a='.'; if ( pB[i]>=32 ) a = pB[i];\
	if (i>=pBufferReadT->dwBytesReceived) a = '*'; pchData[j] = a; }\
	LISTENER_DBGPRINTF(("OnSocketRead!#%02d a%08X s%02d r%02d p%02d [%s]",\
	k++, pB, pBufferReadT->dwBufferSize, pBufferReadT->dwBytesReceived,\
	pBufferReadT->dwBytesParsed, pchData )); } }\



#else // #ifdef DBG


#define LISTENER_ASSERT(exp)\
	((void)0)

#define LISTENER_DBGPRINTF(exp)\
	((void)0)

#define LISTENER_STR_PARSE_STATE(x)\
	((void)0)

#define LISTENER_STR_UL_ERROR(x)\
	((void)0)

#define LISTENER_DBGPRINTBUFFERS(x)\
	((void)0)



#endif // #ifdef DBG



#define LISTENER_ALLOCATE( type, ptr, size, pconnection )\
\
	LISTENER_DBGPRINTF((\
		"LISTENER_ALLOCATE!attempting %d bytes memory allocation (%08X) (total:%d)",\
		size, ptr, pconnection != NULL ? pconnection->ulTotalAllocatedMemory : -1 ));\
\
	ptr = (type) malloc( size );\
\
	if ( ptr != NULL )\
	{\
		memset( ptr , 0, size );\
\
		if ( pconnection != NULL )\
		{\
			pconnection->ulTotalAllocatedMemory += size;\
		}\
		else\
		{\
			LISTENER_DBGPRINTF((\
				"LISTENER_FREE!Connection is NULL (WARNING)" ));\
		}\
\
		LISTENER_DBGPRINTF((\
			"LISTENER_ALLOCATE!%d bytes allocated in %08X (total:%d)",\
			size, ptr, pconnection != NULL ? pconnection->ulTotalAllocatedMemory : -1 ));\
	}

#define LISTENER_FREE( ptr, size, pconnection )\
\
	LISTENER_DBGPRINTF((\
		"LISTENER_FREE!freeing %d bytes of memory (%08X) (total:%d)",\
		size, ptr, pconnection != NULL ? pconnection->ulTotalAllocatedMemory : -1 ));\
\
	if ( ptr!= NULL )\
	{\
		free( ptr );\
		ptr = NULL;\
\
		if ( pconnection != NULL )\
		{\
			pconnection->ulTotalAllocatedMemory -= size;\
		}\
		else\
		{\
			LISTENER_DBGPRINTF((\
				"LISTENER_FREE!Connection is NULL (WARNING)" ));\
		}\
\
		LISTENER_DBGPRINTF((\
			"LISTENER_FREE!%d bytes freed (total:%d)",\
			size, pconnection != NULL ? pconnection->ulTotalAllocatedMemory : -1 ));\
	}\
	else\
	{\
		LISTENER_DBGPRINTF((\
			"LISTENER_FREE!Pointer is NULL (WARNING)" ));\
	}


typedef struct _LISTENER_BUFFER_READ
{
	LIST_ENTRY List;
	PUCHAR pBuffer;
	DWORD dwBufferSize;
	DWORD dwBytesReceived;
	DWORD dwBytesParsed;

	//
	// we need one overlapped structure per buffer to track IO with the vxd
	//

	OVERLAPPED Overlapped;

} LISTENER_BUFFER_READ, *PLISTENER_BUFFER_READ;

typedef struct _LISTENER_BUFFER_WRITE
{
	LIST_ENTRY List;
	PUCHAR pBuffer;
	BOOL bBufferSent;
	DWORD dwBufferSize;
	DWORD dwBytesSent;

	//
	// we need one overlapped structure per buffer to track IO with sockets
	//

	OVERLAPPED Overlapped;
	OVERLAPPED OverlappedResponse;

} LISTENER_BUFFER_WRITE, *PLISTENER_BUFFER_WRITE;

typedef enum _LISTENER_RESPONSE_RECEIVE_STATUS
{
	ResponseReceiveStatusUndefined,

	ResponseReceiveStatusInitialized,
	ResponseReceiveStatusReceivingHeaders,
	ResponseReceiveStatusReceivingBody,
	ResponseReceiveStatusCompleted,

	ResponseReceiveStatusMaximum,

} LISTENER_RESPONSE_RECEIVE_STATUS;

typedef enum _LISTENER_REQUEST_SEND_STATUS
{
	RequestSendStatusUndefined,

	RequestSendStatusInitialized,
	RequestSendStatusSendingHeaders,
	RequestSendStatusSendingBody,
	RequestSendStatusDone,
	RequestSendStatusCompleted,

	RequestSendStatusMaximum,

} LISTENER_REQUEST_SEND_STATUS;

typedef struct _LISTENER_REQUEST
{
	LIST_ENTRY List;

	// Head for a List of LISTENER_BUFFER_READ structures. These are buffers
	// used to incrementally receive a single fragmented HTTP Request.
	// dwTotalBufferReadSize is the total size allocated for the buffers in
	// the list. every time we allocate/free a buffer the size is updated.
	// we are going to use this to control memory usage.

	// when RequestSendStatus == RequestSendStatusSendingHeaders
	// the first buffer in the list contains
	// the serialized version of the HTTP Request headers
	// to be sent by UlSendHttpRequestHeaders()
	
	// after the call to UlSendHttpRequestHeaders() completes,
	// it will be OnVxdWriteStatusIO == RequestSendStatusSendingBody
	// so the buffer will be used to contain
	// the serialized version of the HTTP Response headers
	// as received from UlReceiveHttpResponseHeaders()

	LIST_ENTRY BufferReadHead;

	// Head for a List of LISTENER_BUFFER_WRITE structures. These are buffers
	// used to incrementally send a single fragmented HTTP Response.
	
	LIST_ENTRY BufferWriteHead;

	// We need to start several async writes at the same time, so we
	// will use the same event handle but we need one single overlapped
	// structure per request.

	OVERLAPPED OverlappedBOF;
	OVERLAPPED OverlappedEOF;
	LISTENER_REQUEST_SEND_STATUS RequestSendStatus;

	OVERLAPPED OverlappedResponseBOF;
	LISTENER_RESPONSE_RECEIVE_STATUS ResponseReceiveStatus;

	// The following will be set to TRUE for all requests that fail in the
	// listener. The Response will be a standard very short non conifgurable
	// HTTP response and will be formatted based on the value of the local
	// pRequest->ErrorCode.

	BOOL bFormatResponseBasedOnErrorCode;
	BOOL bKeepAlive;
	BOOL bDoneReadingFromVxd;
	BOOL bDoneWritingToVxd;
	BOOL bDoneWritingToSocket;

	UCHAR *pReqBodyChunk;
	DWORD ulReqBodyChunkSize;

	// the HTTP_REQUEST structure contains a record
	// UL_HTTP_REQUEST_ID RequestId
	// that we will use as well to read/write request/responses

	HTTP_REQUEST *pRequest;
	DWORD ulRequestSize;

	UCHAR *pRequestHeadersBuffer;
	ULONG ulRequestHeadersBufferSize;

	UL_HTTP_RESPONSE *pUlResponse;
	DWORD ulUlResponseSize;

	ULONGLONG ResponseContentLength;

} LISTENER_REQUEST, *PLISTENER_REQUEST;


typedef struct _LISTENER_CONNECTION
{
	LIST_ENTRY List;

	// Head for a List of LISTENER_REQUEST structures

	LIST_ENTRY PendRequestHead;

	// connected socket
	
    SOCKET socket;
    ULONG ulRemoteIPAddress; // DDCCBBAA -> AA.BB.CC.DD
	
	// total memory allocated to this connection

	ULONG ulTotalAllocatedMemory;

	// Used for connection lifetime:
	// this is the time that the connection was established.
	// after this timeout expires the client is required
	// to close this one and open another connection.

	FILETIME sCreated;

	// Used for connection timeout:
	// this is the time that the the last WSARecv()/WSASend() call was
	// placed on the socket.
	// after this timeout expires the client is considered
	// disconnected and is required to open another connection
	// to continue I/O.

	FILETIME sLastUsed;

	// these are also on a per-connection basis

	BOOL bKeepAlive;
	BOOL bGarbageCollect;
	DWORD dwEventIndex;
	OVERLAPPED pOverlapped[LISTENER_CONNECTION_EVENTS];

} LISTENER_CONNECTION, *PLISTENER_CONNECTION;


//
//
// Global Variables Shared with the ConnectionsManager
//
//

HANDLE
	hAccept,
	hUpdate,
	hExitSM;

// This global variable is used by the Main thread to pass new connected
// sockets to the ConnectionsManager thread.

SOCKET gAcceptSocket;
ULONG gLocalIPAdress, gRemoteIPAddress, ulPort;



//
//
// Prototypes:
//
//



// Implemented in "structs.c"

VOID
UlpFreeHttpRequest(
	PHTTP_REQUEST pRequest,
	LISTENER_CONNECTION *pConnection );

VOID
UlpFreeUlHttpResponse(
	PUL_HTTP_RESPONSE pUlResponse,
	LISTENER_CONNECTION *pConnection );

VOID
BufferReadCleanup(
	LISTENER_BUFFER_READ *pBufferRead,
	LISTENER_CONNECTION *pConnection );

VOID
BufferWriteCleanup(
	LISTENER_BUFFER_WRITE *pBufferWrite,
	LISTENER_CONNECTION *pConnection );

VOID
RequestCleanup(
	LISTENER_REQUEST *pPendRequest,
	LISTENER_CONNECTION *pConnection );

VOID
ConnectionCleanup(
	LISTENER_CONNECTION *pConnection );

ULONGLONG
ContentLengthFromHeaders(
	PUL_HEADER_VALUE pHeaders );



// Implemented in "httputil.c"

VOID
SendQuickHttpResponse(
	SOCKET socket,
	BOOL bClose,
	DWORD ErrorCode );

BOOL
IsKeepAlive(
	HTTP_REQUEST *pRequest );

VOID
FixUlHttpResponse(
	UL_HTTP_RESPONSE *pUlResponse );

DWORD
ResponseFormat(
	UL_HTTP_RESPONSE *pUlResponse,
	HTTP_REQUEST *pRequest,
	UCHAR *pEntityBodyFirstChunk,
	DWORD dwEntityBodyFirstChunkSize,
	UCHAR *pBuffer,
	DWORD dwBufferSize );

DWORD
ResponseFormat(
	UL_HTTP_RESPONSE *pUlResponse,
	HTTP_REQUEST *pRequest,
	UCHAR *pEntityBodyFirstChunk,
	DWORD dwEntityBodyFirstChunkSize,
	UCHAR *pBuffer,
	DWORD dwBufferSize );



// Implemented in "connmngr.c"

DWORD
WINAPI
ConnectionsManager(
	LPVOID lpParam );



// Implemented in "listener.c"

VOID
__cdecl
main(
	int argc,
	char *argv[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\chat\server\server.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	server.c

Abstract:

	SERVER - sample char server for skeleton.vxd.

Author:

    Mauro Ottaviani (mauroot)       21-Aug-1999

Revision History:

--*/


#include "..\chat.h"


typedef struct _CHAT_CLIENT_LIST
{
	struct _CHAT_CLIENT_LIST
			*pNext;
	ULONG	dwSize;
	ULONG	dwS1;
	WCHAR	pStr[1];
}
CHAT_CLIENT_LIST, *PCHAT_CLIENT_LIST;


VOID
WINAPI
__stdcall
Subscriber( LPVOID lpParam );


URIHANDLE
	hUlPub = UL_INVALID_URIHANDLE,
	hUlSub = UL_INVALID_URIHANDLE;

HANDLE
	hExitThread = NULL,
	hPubThread = NULL;

CRITICAL_SECTION
	cs;

PCHAT_CLIENT_LIST
	pRoot = NULL;


VOID
__cdecl
main( int argc, char *argv[] )
{
	ULONG result;
	DWORD dwThreadId, dwWhich;
	OVERLAPPED Overlapped;

	result = UlInitialize( 0L );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(SERVER/PUB) UlInitialize() failed. result:%u\n", result );
		goto cleanup;
	}

	result = UlRegisterUri( &hUlPub, UL_INVALID_URIHANDLE, CHAT_PUB_URI, 0L );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(SERVER/PUB) UlRegisterUri() failed. result:%u\n", result );
		goto cleanup;
	}

	result = UlRegisterUri( &hUlSub, UL_INVALID_URIHANDLE, CHAT_SUB_URI, 0L );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(SERVER/PUB) UlRegisterUri() failed. result:%u\n", result );
		goto cleanup;
	}

	InitializeCriticalSection( &cs );

	hExitThread = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( hExitThread == NULL ) goto cleanup;

	hPubThread = CreateThread(
								( LPSECURITY_ATTRIBUTES ) NULL,
								( DWORD ) 0,
								( LPTHREAD_START_ROUTINE ) Subscriber,
								( LPVOID ) 0,
								( DWORD ) 0,
								&dwThreadId );

	if ( hPubThread == NULL ) goto cleanup;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	while ( TRUE )
	{
		PCHAT_CLIENT_LIST *ppScan, pTemp;
		BYTE pBuffer[CHAT_RCV_BUFFER_SIZE];
		ULONG ulCount;

		printf( "(SERVER/PUB) Calling UlReceiveMessage...\n" );

		result = UlReceiveMessage(
									hUlPub,
									pBuffer,
									CHAT_RCV_BUFFER_SIZE,
									&ulCount,
									NULL,
									&Overlapped );

		if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
		{
			break;
		}

		dwWhich = WaitForSingleObject( Overlapped.hEvent, INFINITE );

		if ( dwWhich == WAIT_OBJECT_0 )
		{
			// Braodcast the message to all the Registered URIs
			
			EnterCriticalSection( &cs );

			ppScan = &pRoot;

			while ( ( pTemp = *ppScan ) != NULL )
			{
				DWORD dwWhich;
				ULONG ulSize = ulCount;

				printf( "(SERVER/PUB) Calling UlSendMessage...\n" );
				
				result = UlSendMessage(
										hUlPub,
										NULL,
										pTemp->pStr,
										pBuffer,
										ulSize,
										&ulCount,
										&Overlapped );

				if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
				{
					printf( "(SERVER/PUB) UlSendMessage() failed. result:%u. Deleting URI:", result );
					{ ULONG i; for ( i=0; (CHAR)pTemp->pStr[i]!='\0'; i++ ) printf( "%c", (CHAR)(pTemp->pStr[i]) ); printf( "\n" ); }
				}
				else
				{
					dwWhich = WaitForSingleObject( Overlapped.hEvent, CHAT_PUB_SERVER_TIMEOUT );

					if ( dwWhich == WAIT_OBJECT_0 )
					{
						printf( "(SERVER/PUB) Published on URI:" );
						{ ULONG i; for ( i=0; (CHAR)pTemp->pStr[i]!='\0'; i++ ) printf( "%c", (CHAR)(pTemp->pStr[i]) ); printf( "\n" ); }
						ppScan = &((*ppScan)->pNext);
						continue;
					}
					else
					{
						printf( "(SERVER/PUB) UlSendMessage() failed. result:%u. Deleting URI:", result );
						{ ULONG i; for ( i=0; (CHAR)pTemp->pStr[i]!='\0'; i++ ) printf( "%c", (CHAR)(pTemp->pStr[i]) ); printf( "\n" ); }
					}
				}

				*ppScan = pTemp->pNext;
				free( pTemp );
			}

			LeaveCriticalSection( &cs );
		}
		else
		{
			break;
		}
    }

cleanup:

	result = UlUnregisterUri( hUlPub );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(SERVER/PUB) UlUnregisterUri() failed. result:%u\n", result );
	}

	SetEvent( hExitThread );

	WaitForSingleObject( hPubThread, CHAT_PUB_SERVER_TIMEOUT );

	UlTerminate();

	return;
}


VOID
WINAPI
__stdcall
Subscriber( LPVOID lpParam )
{
	HANDLE lpHandles[CHAT_EVENTS_SIZE];
	OVERLAPPED Overlapped;
	BYTE pBuffer[CHAT_BUFFER_SIZE];
	ULONG result, dwWhich, dwSize, ulCount;
	PCHAT_CLIENT_LIST pTemp;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	lpHandles[CHAT_EVENTS_EXIT] = hExitThread;
	lpHandles[CHAT_EVENTS_SUB] = Overlapped.hEvent;

	while ( TRUE )
	{
		result = UlReceiveMessage(
									hUlSub,
									pBuffer,
									CHAT_BUFFER_SIZE,
									&ulCount,
									NULL,
									&Overlapped );

		if ( result != ERROR_IO_PENDING && result != ERROR_SUCCESS )
		{
			break;
		}

		dwWhich = WaitForMultipleObjects( CHAT_EVENTS_SIZE, lpHandles, FALSE, INFINITE );

		if ( dwWhich - WAIT_OBJECT_0 == CHAT_EVENTS_PUB )
		{
			// Insert new client

			EnterCriticalSection( &cs );

			// TODO: check if the URI is already there.

			dwSize = sizeof( CHAT_CLIENT_LIST ) - 4 + ulCount;
			pTemp = ( PCHAT_CLIENT_LIST ) malloc( dwSize );
			pTemp->pNext = pRoot;
			pTemp->dwSize = dwSize;
			pTemp->dwS1 = ulCount;
			if ( ulCount != 0 ) memcpy( (BYTE*) pTemp->pStr, pBuffer, ulCount );
			pRoot = pTemp;

			printf( "(SERVER/SUB) new client URI:" );
			{ ULONG i; for ( i=0; (CHAR)pRoot->pStr[i]!='\0'; i++ ) printf( "%c", (CHAR)(pRoot->pStr[i]) ); printf( "\n" ); }
			
			LeaveCriticalSection( &cs );

			continue;
		}
		else
		{
			break;
		}
	}

	result = UlUnregisterUri( hUlSub );

	if ( result != ERROR_SUCCESS )
	{
		printf( "(SERVER/SUB) UlUnregisterUri() failed. result:%u\n", result );
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\cmd\cmd.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	cmd.h

Abstract:

	CMD - command line send and receive

Author:

    Mauro Ottaviani (mauroot)       20-Aug-1999

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "ioctl.h"
#include "ulapi9x.h"

#define BREAKPOINT { _asm int 03h }

#define CMD_BUFFER_SIZE 2048
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\cmd\rcv\rcv.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	rcv.c

Abstract:

	RECEIVE - Receives a message using skeleton.vxd.

Author:

    Mauro Ottaviani (mauroot)       21-Aug-1999

Revision History:

--*/


#include "..\cmd.h"

#define STATUS_RCV	0
#define STATUS_PRN	1
#define STATUS_WAIT	2
#define STATUS_EXIT	3

URIHANDLE
	hUl = UL_INVALID_URIHANDLE;

WCHAR
	pUri[CMD_BUFFER_SIZE];

VOID
__cdecl
main( int argc, char *argv[] )
{
	ULONG ulState, result, ulSize, ulCount;
	DWORD dwWhich, dwTimeout, dwBufferSize;
	CHAR pBuffer[CMD_BUFFER_SIZE];
	OVERLAPPED Overlapped;

	if ( argc != 4 )
	{
		printf( "Microsoft (R) Receive (ul) Version 1.00 (NT)\nCopyright (C) Microsoft Corp 1999. All rights reserved.\nusage: rcv uri timeout buffersize\n" );
		return;
	}

	for ( ulCount = 0; argv[1][ulCount] != '\0'; ulCount++ ) pUri[ulCount] = argv[1][ulCount];
	pUri[ulCount] = 0;
	ulSize = sizeof( WCHAR ) * ( ulCount + 1 );

	dwTimeout = atoi( argv[2] );
	if ( dwTimeout == 0 ) dwTimeout = INFINITE;

	dwBufferSize = atoi( argv[3] );
	if ( dwBufferSize < 0 || dwBufferSize>CMD_BUFFER_SIZE ) dwBufferSize = 10;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	//
	// UlInitialize
	//

	result = UlInitialize( 0L );
	printf( "(RCV) UlInitialize() returns %u\n", result );
	if ( result != ERROR_SUCCESS ) goto myexit;

	//
	// UlRegisterUri
	//

	result = UlRegisterUri( &hUl, UL_INVALID_URIHANDLE, pUri, 0L );
	printf( "(RCV) UlRegisterUri() returns %u hUl:%08X\n", result, hUl );

	if ( result != ERROR_SUCCESS ) goto myexit;

	ulState = STATUS_RCV;

	while ( ulState != STATUS_EXIT )
	{
		switch ( ulState )
		{
		
		case STATUS_RCV:
		
			memset( pBuffer, 0, CMD_BUFFER_SIZE );

			ResetEvent( Overlapped.hEvent );

			result = UlReceiveMessage(
										hUl,
										pBuffer,
										dwBufferSize,
										&ulCount,
										NULL,
										&Overlapped );

			printf( "(RCV) UlReceiveMessage( %u ) returns %u\n", dwBufferSize, result );

			//
			// Update State
			//
			
			if ( result == ERROR_SUCCESS )
			{
				ulState = STATUS_PRN;
			}
			else if ( result == ERROR_IO_PENDING )
			{
				ulState = STATUS_WAIT;
			}
			else
			{
				ulState = STATUS_EXIT;
			}

			break;


		case STATUS_PRN:
		
			pBuffer[ulCount] = '\0';
			printf( "(RCV) Message received( %u, %u, \"%s\" )\n", ulCount, Overlapped.InternalHigh, pBuffer );

			//
			// Update State
			//
			
			ulState = STATUS_RCV;

			break;


		case STATUS_WAIT:
		
			//
			// WaitForSingleObject
			//

			dwWhich = WaitForSingleObject( Overlapped.hEvent, dwTimeout );
			printf( "(RCV) WaitForSingleObject() returns %u\n", dwWhich );

			//
			// Update State
			//
			
			if ( dwWhich == WAIT_OBJECT_0 )
			{
				ulState = STATUS_PRN;
			}
			else if ( dwWhich != WAIT_TIMEOUT )
			{
				ulState = STATUS_EXIT;
			}

			break;
		}
	}

myexit:

	//
	// UlTerminate
	//

	UlTerminate();
	printf( "(RCV) UlTerminate()\n" );

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\buffer.cpp ===
// Buffer.cpp : Implementation of CBuffer
#include "stdafx.h"
#include "Ulvxdobj.h"
#include "Buffer.h"

/////////////////////////////////////////////////////////////////////////////
// CBuffer


STDMETHODIMP CBuffer::malloc()
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CBuffer::free()
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CBuffer::get_StringValue(BSTR *pVal)
{
	// TODO: Add your implementation code here

    if(m_pBuffer == NULL) {
        *pVal = SysAllocString(L"");
    } else {
        WCHAR * ptr = (WCHAR *)m_pBuffer;
        *pVal = ::SysAllocString(ptr);
    }

	return S_OK;
}

STDMETHODIMP CBuffer::put_StringValue(BSTR newVal)
{
	// TODO: Add your implementation code here

    int length = wcslen(newVal);

    if( m_pBuffer != NULL ) {
        delete [] m_pBuffer;
        m_pBuffer = NULL;
    }


    m_dwBufferLength = (length+1)*sizeof(WCHAR);

    m_pBuffer = new BYTE[m_dwBufferLength];

    if(m_pBuffer == NULL )
        return STATUS_NO_MEMORY;

    memcpy((void *)m_pBuffer,(const void *)newVal, m_dwBufferLength );

	return S_OK;
}

STDMETHODIMP CBuffer::get_BufferSize(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwBufferLength;

	return S_OK;
}

STDMETHODIMP CBuffer::put_BufferSize(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_dwBufferLength = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\buffer.h ===
// Buffer.h : Declaration of the CBuffer

#ifndef __BUFFER_H_
#define __BUFFER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBuffer
class ATL_NO_VTABLE CBuffer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBuffer, &CLSID_Buffer>,
	public IDispatchImpl<IBuffer, &IID_IBuffer, &LIBID_ULVXDOBJLib>
{
public:
	CBuffer()
	{
        m_dwBufferLength = 0;
        m_pBuffer = NULL;

	}

DECLARE_REGISTRY_RESOURCEID(IDR_BUFFER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBuffer)
	COM_INTERFACE_ENTRY(IBuffer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IBuffer
public:
	STDMETHOD(get_BufferSize)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_BufferSize)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_StringValue)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_StringValue)(/*[in]*/ BSTR newVal);
	STDMETHOD(free)();
	STDMETHOD(malloc)();
private:
	DWORD m_dwBufferLength;
	BYTE * m_pBuffer;
};

#endif //__BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\overlapped.cpp ===
// Overlapped.cpp : Implementation of COverlapped
#include "stdafx.h"
#include "Ulvxdobj.h"
#include "Overlapped.h"

/////////////////////////////////////////////////////////////////////////////
// COverlapped


STDMETHODIMP COverlapped::get_Offset(DWORD *pVal)
{
	// TODO: Add your implementation code here

    m_Offset = m_Overlapped.Offset;
    *pVal = m_Offset;
	return S_OK;
}

STDMETHODIMP COverlapped::put_Offset(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_Offset = newVal;
    m_Overlapped.Offset = m_Offset;

	return S_OK;
}

STDMETHODIMP COverlapped::get_OffsetHigh(DWORD *pVal)
{
	// TODO: Add your implementation code here

    m_OffsetHigh = m_Overlapped.OffsetHigh;
    *pVal = m_OffsetHigh;
	return S_OK;
}

STDMETHODIMP COverlapped::put_OffsetHigh(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_OffsetHigh = newVal;
    m_Overlapped.OffsetHigh = m_OffsetHigh;
	return S_OK;
}


STDMETHODIMP COverlapped::get_Handle(DWORD *pVal)
{
	// TODO: Add your implementation code here

    m_hEvent = m_Overlapped.hEvent;
    *pVal = (DWORD)m_hEvent;
	return S_OK;
}

STDMETHODIMP COverlapped::put_Handle(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_hEvent = (HANDLE) newVal;
    m_Overlapped.hEvent = m_hEvent;
	return S_OK;
}

STDMETHODIMP COverlapped::get_Internal(ULONG_PTR *pVal)
{
	// TODO: Add your implementation code here

    Internal = m_Overlapped.Internal;
    *pVal = Internal;
	return S_OK;
}

STDMETHODIMP COverlapped::put_Internal(ULONG_PTR newVal)
{
	// TODO: Add your implementation code here

    Internal = newVal;
    m_Overlapped.Internal = Internal;
	return S_OK;
}


STDMETHODIMP COverlapped::get_InternalHigh(ULONG_PTR *pVal)
{
	// TODO: Add your implementation code here

    InternalHigh = m_Overlapped.InternalHigh;
    *pVal = InternalHigh;
	return S_OK;
}

STDMETHODIMP COverlapped::put_InternalHigh(ULONG_PTR newVal)
{
	// TODO: Add your implementation code here

    InternalHigh = newVal;
    m_Overlapped.InternalHigh = InternalHigh;
	return S_OK;
}

STDMETHODIMP COverlapped::new_ManualResetEvent(BOOL InitialState)
{
	// TODO: Add your implementation code here

    m_hEvent = CreateEvent( NULL, TRUE, InitialState, NULL );
    m_Overlapped.hEvent = m_hEvent;
	return S_OK;
}

STDMETHODIMP COverlapped::new_AutoResetEvent(BOOL InitialState)
{
	// TODO: Add your implementation code here

    m_hEvent = CreateEvent( NULL, FALSE, InitialState, NULL );
    m_Overlapped.hEvent = m_hEvent;

	return S_OK;
}

STDMETHODIMP COverlapped::TerminateEvent()
{
	// TODO: Add your implementation code here

    if(m_hEvent != NULL )
        CloseHandle( m_Overlapped.hEvent );

	return S_OK;
}

STDMETHODIMP COverlapped::ResetEvent()
{
	// TODO: Add your implementation code here

    ::ResetEvent(m_Overlapped.hEvent );
	return S_OK;
}

STDMETHODIMP COverlapped::get_IsReceive(BOOL *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_IsReceive;
	return S_OK;
}

STDMETHODIMP COverlapped::put_IsReceive(BOOL newVal)
{
	// TODO: Add your implementation code here

    m_IsReceive = newVal;
	return S_OK;
}

STDMETHODIMP COverlapped::get_pOverlapped(DWORD **pVal)
{
	// TODO: Add your implementation code here

    *pVal = (DWORD *)&m_Overlapped;
	return S_OK;
}

STDMETHODIMP COverlapped::put_pOverlapped(DWORD * newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\cmd\snd\snd.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	snd.c

Abstract:

	SEND - Sends a message using skeleton.vxd.

Author:

    Mauro Ottaviani (mauroot)       21-Aug-1999

Revision History:

--*/


#include "..\cmd.h"


WCHAR
	pUri[CMD_BUFFER_SIZE];

VOID
__cdecl
main( int argc, char *argv[] )
{
	ULONG result, ulSize, ulCount;
	DWORD dwWhich, dwTimeout;
	CHAR pBuffer[CMD_BUFFER_SIZE];
	OVERLAPPED Overlapped;

	if ( argc != 3 )
	{
		printf( "Microsoft (R) Send (ul) Version 1.00 (NT)\nCopyright (C) Microsoft Corp 1999. All rights reserved.\nusage: snd uri timeout\n" );
		return;
	}

	for ( ulCount = 0; argv[1][ulCount] != '\0'; ulCount++ ) pUri[ulCount] = argv[1][ulCount];
	pUri[ulCount] = 0;
	ulSize = sizeof( WCHAR ) * ( ulCount + 1 );

	dwTimeout = atoi( argv[2] );
	if ( dwTimeout == 0 ) dwTimeout = INFINITE;

	memset( &Overlapped, sizeof( Overlapped ), 0 );
	Overlapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	//
	// UlInitialize
	//

	result = UlInitialize( 0L );
	printf( "(SND) UlInitialize() returns %u\n", result );
	if ( result != ERROR_SUCCESS ) goto myexit;

	while ( TRUE )
	{
		dwWhich = WAIT_OBJECT_0;

		gets( pBuffer );
		ulSize = atoi( pBuffer );
		if ( ulSize == 0 ) goto myexit;

		for ( ulCount = 0; ulCount<ulSize; ulCount++ ) pBuffer[ulCount] = '0'+((CHAR)(ulCount%10));
		pBuffer[ulSize] = '\0';
		printf( "(SND) Sending message...\n", ulSize, pBuffer );

		result = UlSendMessage(
								UL_INVALID_URIHANDLE,
								NULL,
								pUri,
								(BYTE*) pBuffer,
								ulSize,
								&ulCount,
								&Overlapped );

		printf( "(SND) UlSendMessage(%u) returns %u ulCount:%u\n", ulSize, result, ulCount );

		if ( result == ERROR_IO_PENDING )
		{
			//
			// WaitForSingleObject
			//

			dwWhich = WaitForSingleObject( Overlapped.hEvent, dwTimeout );
			printf( "(SND) WaitForSingleObject() returns %u\n", dwWhich );
		}
		else if ( result != ERROR_SUCCESS )
		{
			printf( "(SND) ERROR exiting...\n" );
			goto myexit;
		}

		if ( dwWhich == WAIT_OBJECT_0 )
		{
			printf( "(SND) Message sent( %u, \"%s\" )\n", ulSize, pBuffer );
		}
	}

	//
	// UlTerminate
	//

myexit:

	UlTerminate();
	printf( "(SND) UlTerminate()\n" );

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\overlapped.h ===
// Overlapped.h : Declaration of the COverlapped

#ifndef __OVERLAPPED_H_
#define __OVERLAPPED_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COverlapped
class ATL_NO_VTABLE COverlapped : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<COverlapped, &CLSID_Overlapped>,
	public IDispatchImpl<IOverlapped, &IID_IOverlapped, &LIBID_ULVXDOBJLib>
{
public:
	COverlapped()
	{
        m_hEvent = NULL;
        Internal = 0;
        InternalHigh = 0;
        m_Offset = 0;
        m_OffsetHigh = 0;
        m_IsReceive = FALSE;
        memset((void *)&m_Overlapped,0, sizeof(m_Overlapped));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_OVERLAPPED)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COverlapped)
	COM_INTERFACE_ENTRY(IOverlapped)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IOverlapped
public:
	STDMETHOD(get_pOverlapped)(/*[out, retval]*/ DWORD **pVal);
	STDMETHOD(put_pOverlapped)(/*[in]*/ DWORD * newVal);
	STDMETHOD(get_IsReceive)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_IsReceive)(/*[in]*/ BOOL newVal);
	STDMETHOD(ResetEvent)();
	STDMETHOD(TerminateEvent)();
	STDMETHOD(new_AutoResetEvent)(BOOL InitialState);
	STDMETHOD(new_ManualResetEvent)(BOOL InitialState);
	STDMETHOD(get_InternalHigh)(/*[out, retval]*/ ULONG_PTR *pVal);
	STDMETHOD(put_InternalHigh)(/*[in]*/ ULONG_PTR newVal);
	STDMETHOD(get_Internal)(/*[out, retval]*/ ULONG_PTR *pVal);
	STDMETHOD(put_Internal)(/*[in]*/ ULONG_PTR newVal);
	STDMETHOD(get_Handle)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_Handle)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_OffsetHigh)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_OffsetHigh)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_Offset)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_Offset)(/*[in]*/ DWORD newVal);
private:
	BOOL m_IsReceive;
	ULONG_PTR InternalHigh;
	ULONG_PTR Internal;
	HANDLE m_hEvent;
	DWORD m_OffsetHigh;
	DWORD m_Offset;
	OVERLAPPED m_Overlapped;
};

#endif //__OVERLAPPED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ulvxdobj.rc
//
#define IDS_PROJNAME                    100
#define IDR_WIN32HANDLE                 101
#define IDR_VXDCONTROL                  102
#define IDR_OVERLAPPED                  103
#define IDR_BUFFER                      104
#define IDR_ULAPI                       105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\ulapi.h ===
// ULApi.h : Declaration of the CULApi

#ifndef __ULAPI_H_
#define __ULAPI_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CULApi
class ATL_NO_VTABLE CULApi : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CULApi, &CLSID_ULApi>,
	public IDispatchImpl<IULApi, &IID_IULApi, &LIBID_ULVXDOBJLib>
{
public:
    DWORD _dwSignature;

	CULApi()
	{
        _dwSignature = 'cdxv';

	    //DWORD m_dwReadBufferSize;
        m_dwReadBufferSize = 16;

	    //OVERLAPPED m_ReceiveOverlapped;
        memset((void *)&m_ReceiveOverlapped,0,sizeof(OVERLAPPED));

	    //BSTR m_szData;
        m_szData = ::SysAllocString(NULL);

	    //DWORD m_dwBytesReceived;
        m_dwBytesReceived = 0;

	    //OVERLAPPED m_Overlapped;
        memset((void *)&m_Overlapped,0,sizeof(OVERLAPPED));

	    //DWORD m_dwLastError;
        m_dwLastError = ERROR_SUCCESS;

	    //HANDLE m_Handle;
        m_Handle = NULL;
    #ifdef _SAFEARRAY_USE
        m_pSafeArray = NULL;

        m_pSafeArray = SafeArrayCreateVector(
                    VT_UI1,
                    0,
                    m_dwReadBufferSize);
    #else
        m_wchar_buffer = new WCHAR[m_dwReadBufferSize];
        memset((void *)m_wchar_buffer, 0, sizeof(m_wchar_buffer));
    #endif

    }

DECLARE_REGISTRY_RESOURCEID(IDR_ULAPI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CULApi)
	COM_INTERFACE_ENTRY(IULApi)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IULApi
public:
	STDMETHOD(WaitForCompletion)(IOverlapped * pOverlapped, DWORD dwTimeout);
	STDMETHOD(DebugPrint)(BSTR szString);
	STDMETHOD(get_ReadBufferSize)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_ReadBufferSize)(/*[in]*/ DWORD newVal);
	STDMETHOD(UnregisterUri)(IWin32Handle * pUriHandle);
	STDMETHOD(unloadVXD)();
	STDMETHOD(WaitForReceiveCompletion)(DWORD dwTimeout);
	STDMETHOD(new_ReceiveOverlapped)(DWORD dwOffset, DWORD dwOffsetHigh);
	STDMETHOD(get_Data)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Data)(/*[in]*/ BSTR newVal);
	DWORD m_dwBytesRemaining;
	STDMETHOD(get_BytesRemaining)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_BytesRemaining)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_BytesReceived)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_BytesReceived)(/*[in]*/ DWORD newVal);
	STDMETHOD(ReceiveString)(IWin32Handle * pUriHandle, IOverlapped * pOverlapped);
	STDMETHOD(Test)(/*[in,out, size_is(dwBufferSize) , length_is(*dwBytesRead)]*/ BYTE * pArray, /*[in]*/ DWORD dwBufferSize, /*[in, out]*/ DWORD * dwBytesRead);
	STDMETHOD(WaitForSendCompletion)(DWORD dwTimeout);
	STDMETHOD(new_Overlapped)(DWORD dwOffset, DWORD dwOffsetHigh);
	STDMETHOD(SendString)(IWin32Handle * pUriHandle, IOverlapped * pOverlapped, BSTR szSourceSuffix, BSTR szTargetUri, BSTR szData);
	STDMETHOD(get_LastError)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_LastError)(/*[in]*/ DWORD newVal);
	STDMETHOD(RegisterUri)(BSTR szUri, IWin32Handle * pParentUri, DWORD dwFlags, /*[out]*/ IWin32Handle ** pVal);
	STDMETHOD(LoadVXD)();
private:
	WCHAR * m_wchar_buffer;
	SAFEARRAY * m_pSafeArray;
	DWORD m_dwReadBufferSize;
	OVERLAPPED m_ReceiveOverlapped;
	BSTR m_szData;
	DWORD m_dwBytesReceived;
	OVERLAPPED m_Overlapped;
	DWORD m_dwLastError;
	HANDLE m_Handle;
};

#endif //__ULAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8291B2F1_AC2D_11D3_BBFF_00C04FC2D5D5__INCLUDED_)
#define AFX_STDAFX_H__8291B2F1_AC2D_11D3_BBFF_00C04FC2D5D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8291B2F1_AC2D_11D3_BBFF_00C04FC2D5D5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\ulapi.cpp ===
// ULApi.cpp : Implementation of CULApi


#include "stdafx.h"
#include "Ulvxdobj.h"
#include "ULApi.h"
#include "Ulvxdobj.h"
#include "win32handle.h"

#include "ulapi9x.h"
#include <wchar.h>

/*
#include <stdio.h>
#include <stdlib.h>
#include <ioctl.h>
#include <errors.h>
#include <structs.h>
*/
//#include <structs.h>
/////////////////////////////////////////////////////////////////////////////
// CULApi

#define CLEAR_ERROR() { m_dwLastError = 0; }

STDMETHODIMP CULApi::LoadVXD()
{
	// TODO: Add your implementation code here

    //DebugBreak();

    m_dwLastError = UlInitialize(0);

	return S_OK;
}

STDMETHODIMP CULApi::RegisterUri(
                                BSTR szUri, 
                                IWin32Handle * pParentUri,
                                DWORD ulFlags, 
                                IWin32Handle **ppRetVal)
{
	// TODO: Add your implementation code here
    BOOL bOK = FALSE;
    CWin32Handle * pWin32Handle = NULL;
    HRESULT Result;
    LPWSTR pUri = NULL;

    DWORD hParentUri = -1, hUriHandle = -1;

    //USES_CONVERSION;

    //pParentUri->get_UriHandle(&hParentUri);
    hParentUri = NULL; // pParentUri->URIHandle();


    CLEAR_ERROR()


    m_dwLastError = UlRegisterUri(
                                    &hUriHandle,
                                    hParentUri,
                                    (PWSTR)szUri,
                                    ulFlags);
	if ( m_dwLastError == ERROR_SUCCESS )
	{
        pWin32Handle = new CComObject<CWin32Handle>;

        if( pWin32Handle == NULL )
            return E_OUTOFMEMORY;

        Result = pWin32Handle->_InternalQueryInterface(
                                    IID_IWin32Handle, 
                                    (PVOID*)ppRetVal);

        if (FAILED(Result))
            return E_FAIL;

        pWin32Handle->put_URIHandle(hUriHandle);
	}


	return S_OK;
}

STDMETHODIMP CULApi::get_LastError(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwLastError;
	return S_OK;
}

STDMETHODIMP CULApi::put_LastError(DWORD newVal)
{
	// TODO: Add your implementation code here
    m_dwLastError = newVal;
	return S_OK;
}

STDMETHODIMP CULApi::SendString(IWin32Handle *pUriHandle, IOverlapped * pOverlapped, BSTR szSourceSuffix, BSTR szTargetUri, BSTR szData)
{
	// TODO: Add your implementation code here

	ULONG ulTargetUriLength;
    ULONG  dwBytesSent  = 0;
    BYTE * pData = NULL;

    BOOL bOK = FALSE;

    OVERLAPPED Overlapped, * lpOverlappedStruct = NULL;

    DWORD hUriHandle = -1;
    DWORD ulBytesToSend = 0;

    CLEAR_ERROR();
	ulTargetUriLength = ( szTargetUri == NULL ) ? 0 : wcslen( szTargetUri );

    pUriHandle->get_URIHandle(&hUriHandle);

    ulBytesToSend = (wcslen(szData) + 1)*sizeof(WCHAR); // for UNICODE

#define MALLOC_DATA_TO_SEND
#ifndef MALLOC_DATA_TO_SEND
    pData = (unsigned char *)szData;
#else
    pData = new BYTE[ulBytesToSend];

    memcpy((void *)pData, (void *)szData, ulBytesToSend);
#endif

    if(pOverlapped != NULL ) {
         
        pOverlapped->ResetEvent();
        //
        // Read in values from the overlapped object
        // into our overlapped structure
        //
        pOverlapped->get_Offset(&Overlapped.Offset);
        pOverlapped->get_OffsetHigh(&Overlapped.OffsetHigh);
        pOverlapped->get_Internal(&Overlapped.Internal);
        pOverlapped->get_InternalHigh(&Overlapped.InternalHigh);
        pOverlapped->get_Handle((LPDWORD)&Overlapped.hEvent);

        lpOverlappedStruct = &Overlapped;
    } else {
	    lpOverlappedStruct = NULL;
    }


    USES_CONVERSION;

    WCHAR szOutput[1024];
    WCHAR * szPtr = NULL;

    int strlen = wcslen(szData);

    szPtr = szData;

    if( strlen > 1020 ) {
        szPtr = L"<trunc>";
    }

    swprintf(szOutput,L"%.8x (%s) length = %d\n" , szData, szPtr, strlen );

    OutputDebugString("Sending data ...\n");
    OutputDebugString(OLE2T(szOutput));
    

    //DebugBreak();

    m_dwLastError = 
                    UlSendMessage(
                        hUriHandle, // IN URIHANDLE hUriHandle,
                        (PWSTR) szSourceSuffix, //IN PWSTR pSourceSuffix OPTIONAL,
                        szTargetUri, // IN PWSTR pTargetUri,
                        pData, // IN PVOID pData,
                        ulBytesToSend, // IN ULONG ulBytesToSend,
                        &dwBytesSent, // OUT PULONG pBytesSent OPTIONAL,
                        lpOverlappedStruct //IN OVERLAPPED *pOverlapped OPTIONAL
                        );


    //
    // Update values from our overlapped structure
    // into the IOverlapped interface 
    //
    pOverlapped->put_Offset(Overlapped.Offset);
    pOverlapped->put_OffsetHigh(Overlapped.OffsetHigh);
    pOverlapped->put_Internal(Overlapped.Internal);
    pOverlapped->put_InternalHigh(Overlapped.InternalHigh);
    pOverlapped->put_Handle((DWORD)Overlapped.hEvent);


    return S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
}

STDMETHODIMP CULApi::new_Overlapped(DWORD dwOffset, DWORD dwOffsetHigh)
{
	// TODO: Add your implementation code here

    m_Overlapped.Offset = dwOffset;
    m_Overlapped.OffsetHigh = dwOffsetHigh;

    m_Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

	return S_OK;
}

STDMETHODIMP CULApi::WaitForSendCompletion(DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = S_OK;

    CLEAR_ERROR();

    DWORD dwResult =
        WaitForSingleObject( m_Overlapped.hEvent, dwTimeout);

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;
        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        //hResult = HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        //hResult = HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}

STDMETHODIMP CULApi::Test(BYTE *pArray, DWORD dwBufferSize, DWORD * dwBytesRead)
{
	// TODO: Add your implementation code here

    int i = 0;
    CHAR szString[256];
    //+DebugBreak();

    DWORD dwSize = (dwBufferSize > 10 ) ? (dwBufferSize - 5 ) : dwBufferSize;

    for( i = 0; i < (int) dwSize; i++ ) {
        pArray[i] = 'a';
    }

    *dwBytesRead = dwSize;

    sprintf( szString, "dwBufferSize = %d, dwBytesRead = %d\n", dwBufferSize, *dwBytesRead );
    OutputDebugString(szString);

	return S_OK;
}

STDMETHODIMP CULApi::ReceiveString(IWin32Handle *pUriHandle, IOverlapped * pOverlapped)
{
	// TODO: Add your implementation code here

    DWORD hUriHandle = -1;
    DWORD ulBufferSize = 16;
    //SAFEARRAY * m_pSafeArray;
    BYTE * pData = NULL;
    BOOL bOK = FALSE;
    HRESULT hr;
    int i;
    CHAR * szTemp = NULL;
    CHAR szDbg[1024];
    WCHAR szOutput[1024];


    USES_CONVERSION;

    CLEAR_ERROR();
    pUriHandle->get_URIHandle(&hUriHandle);

    OVERLAPPED Overlapped, *pOverlappedStruct = NULL;

#ifdef _SAFEARRAY_USE 
    //
    // get the pointer to the internal buffer
    // the SafeArray is holding
    //
    hr = SafeArrayAccessData(
                            m_pSafeArray,
                            (VOID HUGEP **) &pData );
	
    memset( (void *) pData, 0, m_dwReadBufferSize );

    if(FAILED(hr))  {
        return hr;
    }
#else
    pData = (BYTE *) m_wchar_buffer;
    memset( (void *) pData, 0, m_dwReadBufferSize*sizeof(WCHAR) );
#endif

    if(pOverlapped != NULL ) {
        pOverlappedStruct = &Overlapped;
        pOverlapped->ResetEvent();
        //
        // Read in values from the overlapped object
        // into our overlapped structure
        //
        pOverlapped->get_Offset(&Overlapped.Offset);
        pOverlapped->get_OffsetHigh(&Overlapped.OffsetHigh);
        pOverlapped->get_Internal(&Overlapped.Internal);
        pOverlapped->get_InternalHigh(&Overlapped.InternalHigh);
        pOverlapped->get_Handle((LPDWORD)&Overlapped.hEvent);
    } else {
	    pOverlappedStruct = NULL;
    }

    m_dwLastError = UlReceiveMessage(
                                hUriHandle,
                                pData,
                                m_dwReadBufferSize,
                                &m_dwBytesReceived,
                                &m_dwBytesRemaining,
                                pOverlappedStruct);

    
    //
    // Update values from our overlapped structure
    // into the IOverlapped interface 
    //
    if((pOverlapped!=NULL) && (pOverlappedStruct != NULL)) {
        pOverlapped->put_Offset(Overlapped.Offset);
        pOverlapped->put_OffsetHigh(Overlapped.OffsetHigh);
        pOverlapped->put_Internal(Overlapped.Internal);
        pOverlapped->put_InternalHigh(Overlapped.InternalHigh);
        pOverlapped->put_Handle((DWORD)Overlapped.hEvent);
    }

	if ( m_dwLastError != ERROR_SUCCESS )
	{
		goto done;
    } 

    szTemp = szDbg;

    for(i = 0; i < (int)m_dwBytesReceived; i++ ) {
        szTemp += sprintf( szTemp, "%.2X ", pData[i] );
    }

    OutputDebugString("***(");
    OutputDebugString(szDbg);

    OutputDebugString(")***\n");

#ifdef _SAFEARRAY_USE
    if( m_szData != NULL ) {
        SysFreeString(m_szData);
    }

    /*
    hr = BstrFromVector(
                        m_pSafeArray,
                        &m_szData);
    */

    m_szData = SysAllocStringByteLen(
                                    (LPCSTR) pData,
                                    m_dwBytesReceived);

    //if( FAILED(hr)) {
    if( m_szData == NULL) {
    	m_dwLastError = GetLastError();
    } else
        m_dwLastError = ERROR_SUCCESS;

    OutputDebugString("Received data ... ");
    
    swprintf(szOutput,
                L"%.8x (%s) length = %d\n" , 
                m_szData, 
                m_szData,
                wcslen(m_szData));

    OutputDebugString(OLE2T(szOutput));
#else

    OutputDebugString("Received data ... ");
    
    swprintf(szOutput,
                L"%.8x (%s) length = %d\n" , 
                m_wchar_buffer, 
                m_wchar_buffer,
                wcslen(m_wchar_buffer));

    OutputDebugString(OLE2T(szOutput));
#endif
	
done:
    
    //if(FAILED(SafeArrayUnaccessData(m_pSafeArray))) {
    //    m_dwLastError = GetLastError();
    //}

	return S_OK;
}

STDMETHODIMP CULApi::get_BytesReceived(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwBytesReceived;
	return S_OK;
}

STDMETHODIMP CULApi::put_BytesReceived(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_dwBytesReceived = newVal;
	return S_OK;
}

STDMETHODIMP CULApi::get_BytesRemaining(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwBytesRemaining;
	return S_OK;
}

STDMETHODIMP CULApi::put_BytesRemaining(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_dwBytesRemaining = newVal;
	return S_OK;
}

STDMETHODIMP CULApi::get_Data(BSTR *pVal)
{
	// TODO: Add your implementation code here

    WCHAR szDebug[1024];
    USES_CONVERSION;
#ifdef _SAFEARRAY_USE


    *pVal = m_szData;
#else
    *pVal = ::SysAllocString(m_wchar_buffer);

    swprintf( szDebug, L"get_data(): %s (%d)\n",
                    m_wchar_buffer, wcslen(m_wchar_buffer));

#endif

    OutputDebugString(OLE2T(szDebug));
	
    return S_OK;
}

STDMETHODIMP CULApi::put_Data(BSTR newVal)
{
	// TODO: Add your implementation code here

    m_szData = newVal;
	return S_OK;
}

STDMETHODIMP CULApi::new_ReceiveOverlapped(DWORD dwOffset, DWORD dwOffsetHigh)
{
	// TODO: Add your implementation code here

    m_ReceiveOverlapped.Offset = dwOffset;
    m_ReceiveOverlapped.OffsetHigh = dwOffsetHigh;

    m_ReceiveOverlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
	return S_OK;
}

STDMETHODIMP CULApi::WaitForReceiveCompletion(DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = E_FAIL;

    USES_CONVERSION;
    CLEAR_ERROR();
     DWORD dwResult =
        WaitForSingleObject( m_ReceiveOverlapped.hEvent, dwTimeout);

    OutputDebugString("WaitForReceiveCompletion\n");
    WCHAR szOutput[1024];

    //DebugBreak();

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;

        hResult = BstrFromVector(
                            m_pSafeArray,
                            &m_szData);

        if( FAILED(hResult)) {
    	    m_dwLastError = GetLastError();
            break;
        } else
            m_dwLastError = ERROR_SUCCESS;

        OutputDebugString("Received data ... ");
        swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_szData, m_szData, 
            wcslen(m_szData) );
        OutputDebugString(OLE2T(szOutput));
        //DebugBreak();

        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}

STDMETHODIMP CULApi::unloadVXD()
{
	// TODO: Add your implementation code here

    OutputDebugString("+ unloadVXD\n");
    CLEAR_ERROR();

    UlTerminate();

    OutputDebugString("- unloadVXD\n");
    
	return S_OK;
}

STDMETHODIMP CULApi::UnregisterUri(IWin32Handle *pUriHandle)
{
	// TODO: Add your implementation code here

    CLEAR_ERROR();

    DWORD hUriHandle = -1;

    pUriHandle->get_URIHandle(&hUriHandle);
	
	m_dwLastError = UlUnregisterUri(hUriHandle);

	return S_OK;
}


STDMETHODIMP CULApi::get_ReadBufferSize(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwReadBufferSize;
	return S_OK;
}

STDMETHODIMP CULApi::put_ReadBufferSize(DWORD newVal)
{
	// TODO: Add your implementation code here
#ifdef _SAFEARRAY_USE
    m_dwReadBufferSize = newVal;

    if( m_pSafeArray != NULL ) {
        HRESULT hr = SafeArrayDestroy(m_pSafeArray);
        m_pSafeArray = NULL;
    }

    m_pSafeArray = SafeArrayCreateVector(
                VT_UI1,
                0,
                m_dwReadBufferSize);
#else
    
    m_dwReadBufferSize = newVal;

    if( m_wchar_buffer != NULL ) {
        delete m_wchar_buffer;
        m_wchar_buffer = NULL;
    }

    m_wchar_buffer = new WCHAR[m_dwReadBufferSize];

#endif

	return S_OK;
}

STDMETHODIMP CULApi::DebugPrint(BSTR szString)
{
	// TODO: Add your implementation code here
    WCHAR szOutput[1024];

    USES_CONVERSION;

    DWORD dwProcessId = GetCurrentProcessId();
    HANDLE hProcess = GetCurrentProcess();
    swprintf(szOutput, L"** [%.8x] ** : %s\n", dwProcessId, szString );
    
    OutputDebugString(OLE2T(szOutput));

	return S_OK;
}

STDMETHODIMP CULApi::WaitForCompletion(IOverlapped *pOverlapped, DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = E_FAIL;

    USES_CONVERSION;
    CLEAR_ERROR();

    HANDLE hEvent = NULL;
    pOverlapped->get_Handle((LPDWORD)&hEvent);

     DWORD dwResult =
        WaitForSingleObject( hEvent, dwTimeout);

    OutputDebugString("WaitForCompletion\n");
    WCHAR szOutput[1024];

    BOOL fIsReceive = FALSE;
    
    pOverlapped->get_IsReceive(&fIsReceive);

    //DebugBreak();

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;

        if( fIsReceive ) {
#ifdef _SAFEARRAY_USE
            hResult = BstrFromVector(
                                m_pSafeArray,
                                &m_szData);

            if( FAILED(hResult)) {
    	        m_dwLastError = GetLastError();
                break;
            } else
                m_dwLastError = ERROR_SUCCESS;

            OutputDebugString("Received data ... ");
            swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_szData, m_szData,
                wcslen(m_szData));
            OutputDebugString(OLE2T(szOutput));
#else
            OutputDebugString("Received data ... ");
            swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_wchar_buffer,
                m_wchar_buffer, wcslen(m_wchar_buffer));
            OutputDebugString(OLE2T(szOutput));

#endif
            //DebugBreak();
        }

        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\ulvxdobj.cpp ===
// ulvxdobj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ulvxdobjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ulvxdobj.h"

#include "ulvxdobj_i.c"
#include "Win32Handle.h"
#include "vxdcontrol.h"
#include "Overlapped.h"
#include "Buffer.h"
#include "ULApi.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Win32Handle, CWin32Handle)
OBJECT_ENTRY(CLSID_vxdcontrol, Cvxdcontrol)
OBJECT_ENTRY(CLSID_Overlapped, COverlapped)
OBJECT_ENTRY(CLSID_Buffer, CBuffer)
OBJECT_ENTRY(CLSID_ULApi, CULApi)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ULVXDOBJLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\win32handle.cpp ===
// Win32Handle.cpp : Implementation of CWin32Handle
#include "stdafx.h"
#include "Ulvxdobj.h"
#include "Win32Handle.h"

/////////////////////////////////////////////////////////////////////////////
// CWin32Handle


STDMETHODIMP CWin32Handle::get_URIHandle(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_UriHandle;
	return S_OK;
}

STDMETHODIMP CWin32Handle::put_URIHandle(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_UriHandle = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\vxdcontrol.cpp ===
// vxdcontrol.cpp : Implementation of Cvxdcontrol
#include "stdafx.h"
#include "Ulvxdobj.h"
#include "vxdcontrol.h"
#include "win32handle.h"

#include "ulapi9x.h"
#include <wchar.h>

/*
#include <stdio.h>
#include <stdlib.h>
#include "precomp.h"
#include "httptypes.h"
#include "structs.h"
#include "ioctl.h"
#include "errors.h"
*/
/////////////////////////////////////////////////////////////////////////////
// Cvxdcontrol

#define CLEAR_ERROR() { m_dwLastError = 0; }

STDMETHODIMP Cvxdcontrol::LoadVXD()
{
	// TODO: Add your implementation code here

    //DebugBreak();

	m_Handle =
	CreateFileA(
        "\\\\.\\" "ul.vxd", // BSTR szFile, 
		0, // dwDesiredAccess,
		0, // dwShareMode, 
		NULL,
		0, // dwCreationDisposition,
		FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED, //  DWORD dwFlagsAndAttributes, 
		NULL // HANDLE hTemplateFile 
        );

    if(m_Handle == INVALID_HANDLE_VALUE ) {
        m_dwLastError = GetLastError();
        return HRESULT_FROM_WIN32(m_dwLastError);
        //return E_FAIL;
    }

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::RegisterUri(
                                BSTR szUri, 
                                IWin32Handle * pParentUri,
                                DWORD ulFlags, 
                                IWin32Handle **ppRetVal)
{
	// TODO: Add your implementation code here
    IN_IOCTL_UL_REGISTER_URI InIoctl;
    OUT_IOCTL_UL_REGISTER_URI OutIoctl;
    BOOL bOK = FALSE;
    CWin32Handle * pWin32Handle = NULL;
    HRESULT Result;
    LONG ulUriToRegisterLength;
    LPWSTR pUri = NULL;

    DWORD hParentUri;

    //USES_CONVERSION;

    //pParentUri->get_UriHandle(&hParentUri);
    hParentUri = NULL; // pParentUri->URIHandle();

    //pUri = szUri;

    ulUriToRegisterLength = ( szUri == NULL ) ? 0 : wcslen( szUri );

	InIoctl.dwSize = sizeof( IN_IOCTL_UL_REGISTER_URI );
	InIoctl.hParentUri = hParentUri;
	InIoctl.ulFlags = ulFlags;
	InIoctl.ulUriToRegisterLength = ulUriToRegisterLength;

    int numbytes = sizeof( WCHAR ) * ( ulUriToRegisterLength + 1 );
	
    InIoctl.pUriToRegister = ( WCHAR* ) malloc( numbytes );
    
    memset((void *)InIoctl.pUriToRegister, 0, numbytes );

	wcscpy( InIoctl.pUriToRegister, szUri ); 

    CLEAR_ERROR()

	bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_REGISTER_URI,
		&InIoctl,
		sizeof( IN_IOCTL_UL_REGISTER_URI ),
		&OutIoctl,
		sizeof( OUT_IOCTL_UL_REGISTER_URI ),
		NULL,
		NULL );

	if ( !bOK )
	{
        m_dwLastError = GetLastError();
		return S_OK;
	}

    pWin32Handle = new CComObject<CWin32Handle>;

    if( pWin32Handle == NULL )
        return E_OUTOFMEMORY;

    Result = pWin32Handle->_InternalQueryInterface(IID_IWin32Handle, (PVOID*)ppRetVal);

    if (FAILED(Result))
        return E_FAIL;

    //ppRetVal->UriHandle = OutIoctl.hUriHandle;
    pWin32Handle->put_URIHandle(OutIoctl.hUriHandle);

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::get_LastError(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwLastError;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::put_LastError(DWORD newVal)
{
	// TODO: Add your implementation code here
    m_dwLastError = newVal;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::SendString(IWin32Handle *pUriHandle, IOverlapped * pOverlapped, BSTR szSourceSuffix, BSTR szTargetUri, BSTR szData)
{
	// TODO: Add your implementation code here

	ULONG ulTargetUriLength;
    ULONG  dwBytesSent  = 0;
	IN_IOCTL_UL_SEND_MESSAGE InIoctl;
    BOOL bOK = FALSE;

    OVERLAPPED Overlapped;

    DWORD hUriHandle = -1;
    DWORD ulBytesToSend = 0;

    CLEAR_ERROR();
	ulTargetUriLength = ( szTargetUri == NULL ) ? 0 : wcslen( szTargetUri );

    pUriHandle->get_URIHandle(&hUriHandle);

    InIoctl.dwSize = sizeof( IN_IOCTL_UL_SEND_MESSAGE );
	InIoctl.hUriHandle = hUriHandle;

    ulBytesToSend = (wcslen(szData) + 1)*sizeof(WCHAR); // for UNICODE

#define MALLOC_DATA_TO_SEND
#ifndef MALLOC_DATA_TO_SEND
    InIoctl.pData = (unsigned char *)szData;
#else
    InIoctl.pData = new BYTE[ulBytesToSend];

    memcpy((void *)InIoctl.pData, (void *)szData, ulBytesToSend);
#endif

	InIoctl.ulBytesToSend = ulBytesToSend;
	InIoctl.pBytesSent = &dwBytesSent;

    if(pOverlapped != NULL ) {

#ifdef USE_OVERLAPPED_HACK
	    InIoctl.pOverlapped = &Overlapped;
        pOverlapped->ResetEvent();
        //
        // Read in values from the overlapped object
        // into our overlapped structure
        //
        pOverlapped->get_Offset(&Overlapped.Offset);
        pOverlapped->get_OffsetHigh(&Overlapped.OffsetHigh);
        pOverlapped->get_Internal(&Overlapped.Internal);
        pOverlapped->get_InternalHigh(&Overlapped.InternalHigh);
        pOverlapped->get_Handle((LPDWORD)&Overlapped.hEvent);
#else
        OVERLAPPED * pOverlappedStruct = NULL;
        pOverlapped->get_pOverlapped((DWORD **) &pOverlappedStruct);
	    InIoctl.pOverlapped = pOverlappedStruct;
#endif

    } else {
	    InIoctl.pOverlapped = NULL;
    }
	InIoctl.ulTargetUriLength = ulTargetUriLength;

    int numbytes = sizeof( WCHAR ) * ( ulTargetUriLength + 1 );
	InIoctl.pTargetUri = ( WCHAR* ) malloc( numbytes );
    memset((void *)InIoctl.pTargetUri , 0, numbytes );
	wcscpy( InIoctl.pTargetUri, szTargetUri ); // this terminates the string with a \0\0

    

    USES_CONVERSION;

    WCHAR szOutput[1024];
    WCHAR * szPtr = NULL;

    int strlen = wcslen(szData);

    szPtr = szData;

    if( strlen > 1020 ) {
        szPtr = L"<trunc>";
    }

    swprintf(szOutput,L"%.8x (%s) length = %d\n" , szData, szPtr, strlen );

    OutputDebugString("Sending data ...\n");
    OutputDebugString(OLE2T(szOutput));
    

    //DebugBreak();

	bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_SEND_MESSAGE,
		&InIoctl,
		sizeof( IN_IOCTL_UL_SEND_MESSAGE ),
		NULL,
		0,
		NULL,
		NULL );

#ifdef USE_OVERLAPPED_HACK
    //
    // Update values from our overlapped structure
    // into the IOverlapped interface 
    //
    pOverlapped->put_Offset(Overlapped.Offset);
    pOverlapped->put_OffsetHigh(Overlapped.OffsetHigh);
    pOverlapped->put_Internal(Overlapped.Internal);
    pOverlapped->put_InternalHigh(Overlapped.InternalHigh);
    pOverlapped->put_Handle((DWORD)Overlapped.hEvent);
#endif

	if ( bOK )
	{
        m_dwLastError = ERROR_SUCCESS;
    	return S_OK;
	}

	m_dwLastError = GetLastError();

    return S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
}

STDMETHODIMP Cvxdcontrol::new_Overlapped(DWORD dwOffset, DWORD dwOffsetHigh)
{
	// TODO: Add your implementation code here

    m_Overlapped.Offset = dwOffset;
    m_Overlapped.OffsetHigh = dwOffsetHigh;

    m_Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::WaitForSendCompletion(DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = S_OK;

    CLEAR_ERROR();

    DWORD dwResult =
        WaitForSingleObject( m_Overlapped.hEvent, dwTimeout);

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;
        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        //hResult = HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        //hResult = HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}

STDMETHODIMP Cvxdcontrol::Test(BYTE *pArray, DWORD dwBufferSize, DWORD * dwBytesRead)
{
	// TODO: Add your implementation code here

    int i = 0;
    CHAR szString[256];
    //+DebugBreak();

    DWORD dwSize = (dwBufferSize > 10 ) ? (dwBufferSize - 5 ) : dwBufferSize;

    for( i = 0; i < (int) dwSize; i++ ) {
        pArray[i] = 'a';
    }

    *dwBytesRead = dwSize;

    sprintf( szString, "dwBufferSize = %d, dwBytesRead = %d\n", dwBufferSize, *dwBytesRead );
    OutputDebugString(szString);

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::ReceiveString(IWin32Handle *pUriHandle, IOverlapped * pOverlapped)
{
	// TODO: Add your implementation code here
	IN_IOCTL_UL_RECEIVE_MESSAGE InIoctl;
    DWORD hUriHandle = -1;
    DWORD ulBufferSize = 16;
    //SAFEARRAY * m_pSafeArray;
    BYTE * pData = NULL;
    BOOL bOK = FALSE;
    HRESULT hr;
    int i;
    CHAR * szTemp = NULL;
    CHAR szDbg[1024];
    WCHAR szOutput[1024];


    USES_CONVERSION;

    CLEAR_ERROR();
    pUriHandle->get_URIHandle(&hUriHandle);

    OVERLAPPED Overlapped;

#ifdef _SAFEARRAY_USE 
    //
    // get the pointer to the internal buffer
    // the SafeArray is holding
    //
    hr = SafeArrayAccessData(
                            m_pSafeArray,
                            (VOID HUGEP **) &pData );
	
    memset( (void *) pData, 0, m_dwReadBufferSize );

    if(FAILED(hr))  {
        return hr;
    }
#else
    pData = (BYTE *) m_wchar_buffer;
    memset( (void *) pData, 0, m_dwReadBufferSize*sizeof(WCHAR) );
#endif

	InIoctl.dwSize = sizeof( IN_IOCTL_UL_RECEIVE_MESSAGE );
	InIoctl.hUriHandle = hUriHandle;
	InIoctl.pData = pData;
	InIoctl.ulBufferSize = m_dwReadBufferSize;
	InIoctl.pBytesReceived = &m_dwBytesReceived;
	InIoctl.pBytesRemaining = &m_dwBytesRemaining;
	
    //InIoctl.pOverlapped = &m_ReceiveOverlapped;

    //ResetEvent(m_ReceiveOverlapped.hEvent);

    if(pOverlapped != NULL ) {

#ifdef USE_OVERLAPPED_HACK

	    InIoctl.pOverlapped = &Overlapped;
        pOverlapped->ResetEvent();
        //
        // Read in values from the overlapped object
        // into our overlapped structure
        //
        pOverlapped->get_Offset(&Overlapped.Offset);
        pOverlapped->get_OffsetHigh(&Overlapped.OffsetHigh);
        pOverlapped->get_Internal(&Overlapped.Internal);
        pOverlapped->get_InternalHigh(&Overlapped.InternalHigh);
        pOverlapped->get_Handle((LPDWORD)&Overlapped.hEvent);
#else
        OVERLAPPED * pOverlappedStruct = NULL;
        pOverlapped->get_pOverlapped(((DWORD **) &pOverlappedStruct));
	    InIoctl.pOverlapped = pOverlappedStruct;
#endif
    } else {
	    InIoctl.pOverlapped = NULL;
    }

    bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_RECEIVE_MESSAGE,
		&InIoctl,
		sizeof( IN_IOCTL_UL_RECEIVE_MESSAGE ),
		NULL,
		0,
		NULL,
		NULL );

#ifdef USE_OVERLAPPED_HACK
    //
    // Update values from our overlapped structure
    // into the IOverlapped interface 
    //
    pOverlapped->put_Offset(Overlapped.Offset);
    pOverlapped->put_OffsetHigh(Overlapped.OffsetHigh);
    pOverlapped->put_Internal(Overlapped.Internal);
    pOverlapped->put_InternalHigh(Overlapped.InternalHigh);
    pOverlapped->put_Handle((DWORD)Overlapped.hEvent);

#endif

	if ( !bOK )
	{
    	m_dwLastError = GetLastError();
		goto done;
    } else
        m_dwLastError = ERROR_SUCCESS;

    szTemp = szDbg;

    for(i = 0; i < (int)m_dwBytesReceived; i++ ) {
        szTemp += sprintf( szTemp, "%.2X ", pData[i] );
    }

    OutputDebugString("***(");
    OutputDebugString(szDbg);

    OutputDebugString(")***\n");

#ifdef _SAFEARRAY_USE
    if( m_szData != NULL ) {
        SysFreeString(m_szData);
    }

    /*
    hr = BstrFromVector(
                        m_pSafeArray,
                        &m_szData);
    */

    m_szData = SysAllocStringByteLen(
                                    (LPCSTR) pData,
                                    m_dwBytesReceived);

    //if( FAILED(hr)) {
    if( m_szData == NULL) {
    	m_dwLastError = GetLastError();
    } else
        m_dwLastError = ERROR_SUCCESS;

    OutputDebugString("Received data ... ");
    
    swprintf(szOutput,
                L"%.8x (%s) length = %d\n" , 
                m_szData, 
                m_szData,
                wcslen(m_szData));

    OutputDebugString(OLE2T(szOutput));
#else

    OutputDebugString("Received data ... ");
    
    swprintf(szOutput,
                L"%.8x (%s) length = %d\n" , 
                m_wchar_buffer, 
                m_wchar_buffer,
                wcslen(m_wchar_buffer));

    OutputDebugString(OLE2T(szOutput));
#endif
	
done:
    
    //if(FAILED(SafeArrayUnaccessData(m_pSafeArray))) {
    //    m_dwLastError = GetLastError();
    //}

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::get_BytesReceived(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwBytesReceived;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::put_BytesReceived(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_dwBytesReceived = newVal;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::get_BytesRemaining(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwBytesRemaining;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::put_BytesRemaining(DWORD newVal)
{
	// TODO: Add your implementation code here

    m_dwBytesRemaining = newVal;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::get_Data(BSTR *pVal)
{
	// TODO: Add your implementation code here

    WCHAR szDebug[1024];
    USES_CONVERSION;
#ifdef _SAFEARRAY_USE


    *pVal = m_szData;
#else
    *pVal = ::SysAllocString(m_wchar_buffer);

    swprintf( szDebug, L"get_data(): %s (%d)\n",
                    m_wchar_buffer, wcslen(m_wchar_buffer));

#endif

    OutputDebugString(OLE2T(szDebug));
	
    return S_OK;
}

STDMETHODIMP Cvxdcontrol::put_Data(BSTR newVal)
{
	// TODO: Add your implementation code here

    m_szData = newVal;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::new_ReceiveOverlapped(DWORD dwOffset, DWORD dwOffsetHigh)
{
	// TODO: Add your implementation code here

    m_ReceiveOverlapped.Offset = dwOffset;
    m_ReceiveOverlapped.OffsetHigh = dwOffsetHigh;

    m_ReceiveOverlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::WaitForReceiveCompletion(DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = E_FAIL;

    USES_CONVERSION;
    CLEAR_ERROR();
     DWORD dwResult =
        WaitForSingleObject( m_ReceiveOverlapped.hEvent, dwTimeout);

    OutputDebugString("WaitForReceiveCompletion\n");
    WCHAR szOutput[1024];

    //DebugBreak();

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;

        hResult = BstrFromVector(
                            m_pSafeArray,
                            &m_szData);

        if( FAILED(hResult)) {
    	    m_dwLastError = GetLastError();
            break;
        } else
            m_dwLastError = ERROR_SUCCESS;

        OutputDebugString("Received data ... ");
        swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_szData, m_szData, 
            wcslen(m_szData) );
        OutputDebugString(OLE2T(szOutput));
        //DebugBreak();

        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}

STDMETHODIMP Cvxdcontrol::unloadVXD()
{
	// TODO: Add your implementation code here

    OutputDebugString("+ unloadVXD\n");
    CLEAR_ERROR();

    if(!CloseHandle(m_Handle)) {
        OutputDebugString("CloseHandle() returned\n");
        m_dwLastError = GetLastError();
    }

    OutputDebugString("- unloadVXD\n");
    
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::UnregisterUri(IWin32Handle *pUriHandle)
{
	// TODO: Add your implementation code here

    CLEAR_ERROR();

    DWORD hUriHandle = -1;

    pUriHandle->get_URIHandle(&hUriHandle);
	
    BOOL bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_UNREGISTER_URI,
		&hUriHandle,
		0,
		NULL,
		0,
		NULL,
		NULL );

	if ( bOK )
	{
		m_dwLastError = ERROR_SUCCESS;
	}

	m_dwLastError = GetLastError();

	return S_OK;
}


STDMETHODIMP Cvxdcontrol::get_ReadBufferSize(DWORD *pVal)
{
	// TODO: Add your implementation code here

    *pVal = m_dwReadBufferSize;
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::put_ReadBufferSize(DWORD newVal)
{
	// TODO: Add your implementation code here
#ifdef _SAFEARRAY_USE
    m_dwReadBufferSize = newVal;

    if( m_pSafeArray != NULL ) {
        HRESULT hr = SafeArrayDestroy(m_pSafeArray);
        m_pSafeArray = NULL;
    }

    m_pSafeArray = SafeArrayCreateVector(
                VT_UI1,
                0,
                m_dwReadBufferSize);
#else
    
    m_dwReadBufferSize = newVal;

    if( m_wchar_buffer != NULL ) {
        delete m_wchar_buffer;
        m_wchar_buffer = NULL;
    }

    m_wchar_buffer = new WCHAR[m_dwReadBufferSize];

#endif

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::DebugPrint(BSTR szString)
{
	// TODO: Add your implementation code here
    WCHAR szOutput[1024];

    USES_CONVERSION;

    DWORD dwProcessId = GetCurrentProcessId();
    HANDLE hProcess = GetCurrentProcess();
    swprintf(szOutput, L"** [%.8x] ** : %s\n", dwProcessId, szString );
    
    OutputDebugString(OLE2T(szOutput));

	return S_OK;
}

STDMETHODIMP Cvxdcontrol::WaitForCompletion(IOverlapped *pOverlapped, DWORD dwTimeout)
{
	// TODO: Add your implementation code here

    HRESULT hResult = E_FAIL;

    USES_CONVERSION;
    CLEAR_ERROR();

    HANDLE hEvent = NULL;
    pOverlapped->get_Handle((LPDWORD)&hEvent);

     DWORD dwResult =
        WaitForSingleObject( hEvent, dwTimeout);

    OutputDebugString("WaitForCompletion\n");
    WCHAR szOutput[1024];

    BOOL fIsReceive = FALSE;
    
    pOverlapped->get_IsReceive(&fIsReceive);

    //DebugBreak();

    switch(dwResult) {

    case WAIT_OBJECT_0:
        m_dwLastError = ERROR_SUCCESS;

        if( fIsReceive ) {
#ifdef _SAFEARRAY_USE
            hResult = BstrFromVector(
                                m_pSafeArray,
                                &m_szData);

            if( FAILED(hResult)) {
    	        m_dwLastError = GetLastError();
                break;
            } else
                m_dwLastError = ERROR_SUCCESS;

            OutputDebugString("Received data ... ");
            swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_szData, m_szData,
                wcslen(m_szData));
            OutputDebugString(OLE2T(szOutput));
#else
            OutputDebugString("Received data ... ");
            swprintf(szOutput,L"%.8x (%s) length = %d\n" , m_wchar_buffer,
                m_wchar_buffer, wcslen(m_wchar_buffer));
            OutputDebugString(OLE2T(szOutput));

#endif
            //DebugBreak();
        }

        hResult = S_OK;
        break;

    case WAIT_TIMEOUT:
        m_dwLastError = ERROR_TIMEOUT;
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    case WAIT_FAILED:
        m_dwLastError = GetLastError();
        hResult = S_OK; // HRESULT_FROM_WIN32(m_dwLastError);
        break;

    default:
        hResult = E_FAIL;
        break;

    }

	return hResult;
}

STDMETHODIMP Cvxdcontrol::CreateAppPool(IWin32Handle **pAppPool)
{
	// TODO: Add your implementation code here

    HANDLE hAppPoolHandle = NULL;
    CWin32Handle * pWin32Handle = NULL;

	BOOL bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_CREATE_APPPOOL,
		&hAppPoolHandle,
		sizeof( HANDLE ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		m_dwLastError = GetLastError();
        goto done;
	}

    pWin32Handle = new CComObject<CWin32Handle>;

    if( pWin32Handle == NULL )
        return E_OUTOFMEMORY;

    HRESULT Result = pWin32Handle->_InternalQueryInterface(
                                            IID_IWin32Handle, 
                                            (PVOID*)pAppPool);

    if (FAILED(Result))
        return E_FAIL;

    //ppRetVal->UriHandle = OutIoctl.hUriHandle;
    pAppPool->put_URIHandle((DWORD)hAppPoolHandle);

done:
	return S_OK;
}

STDMETHODIMP Cvxdcontrol::CloseAppPool(IWin32Handle *pAppPool)
{
	// TODO: Add your implementation code here

    HANDLE pHandle = NULL;

    if( pAppPool != NULL ) {
        pAppPool->get_URIHandle((DWORD *)&pHandle);
    }

	BOOL bOK =
	DeviceIoControl(
		m_Handle,
		IOCTL_UL_CLOSE_APPPOOL,
		pHandle,
		sizeof( HANDLE ),
		NULL,
		0,
		NULL,
		NULL );

	if ( !bOK )
	{
		m_dwLastError = GetLastError();
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\vxdcontrol.h ===
// vxdcontrol.h : Declaration of the Cvxdcontrol

#ifndef __VXDCONTROL_H_
#define __VXDCONTROL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Cvxdcontrol
class ATL_NO_VTABLE Cvxdcontrol : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Cvxdcontrol, &CLSID_vxdcontrol>,
	public IDispatchImpl<Ivxdcontrol, &IID_Ivxdcontrol, &LIBID_ULVXDOBJLib>
{
public:
    DWORD _dwSignature;

	Cvxdcontrol()
	{
        _dwSignature = 'cdxv';

	    //DWORD m_dwReadBufferSize;
        m_dwReadBufferSize = 16;

	    //OVERLAPPED m_ReceiveOverlapped;
        memset((void *)&m_ReceiveOverlapped,0,sizeof(OVERLAPPED));

	    //BSTR m_szData;
        m_szData = ::SysAllocString(NULL);

	    //DWORD m_dwBytesReceived;
        m_dwBytesReceived = 0;

	    //OVERLAPPED m_Overlapped;
        memset((void *)&m_Overlapped,0,sizeof(OVERLAPPED));

	    //DWORD m_dwLastError;
        m_dwLastError = ERROR_SUCCESS;

	    //HANDLE m_Handle;
        m_Handle = NULL;
#ifdef _SAFEARRAY_USE
        m_pSafeArray = NULL;

        m_pSafeArray = SafeArrayCreateVector(
                    VT_UI1,
                    0,
                    m_dwReadBufferSize);
#else
        m_wchar_buffer = new WCHAR[m_dwReadBufferSize];
        memset((void *)m_wchar_buffer, 0, sizeof(m_wchar_buffer));
#endif


	}

DECLARE_REGISTRY_RESOURCEID(IDR_VXDCONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Cvxdcontrol)
	COM_INTERFACE_ENTRY(Ivxdcontrol)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Ivxdcontrol
public:
	STDMETHOD(CloseAppPool)(IWin32Handle * pAppPool);
	STDMETHOD(CreateAppPool)(/*[out,retval]*/ IWin32Handle ** pAppPool);
	STDMETHOD(WaitForCompletion)(IOverlapped * pOverlapped, DWORD dwTimeout);
	STDMETHOD(DebugPrint)(BSTR szString);
	STDMETHOD(get_ReadBufferSize)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_ReadBufferSize)(/*[in]*/ DWORD newVal);
	STDMETHOD(UnregisterUri)(IWin32Handle * pUriHandle);
	STDMETHOD(unloadVXD)();
	STDMETHOD(WaitForReceiveCompletion)(DWORD dwTimeout);
	STDMETHOD(new_ReceiveOverlapped)(DWORD dwOffset, DWORD dwOffsetHigh);
	STDMETHOD(get_Data)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Data)(/*[in]*/ BSTR newVal);
	DWORD m_dwBytesRemaining;
	STDMETHOD(get_BytesRemaining)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_BytesRemaining)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_BytesReceived)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_BytesReceived)(/*[in]*/ DWORD newVal);
	STDMETHOD(ReceiveString)(IWin32Handle * pUriHandle, IOverlapped * pOverlapped);
	STDMETHOD(Test)(/*[in,out, size_is(dwBufferSize) , length_is(*dwBytesRead)]*/ BYTE * pArray, /*[in]*/ DWORD dwBufferSize, /*[in, out]*/ DWORD * dwBytesRead);
	STDMETHOD(WaitForSendCompletion)(DWORD dwTimeout);
	STDMETHOD(new_Overlapped)(DWORD dwOffset, DWORD dwOffsetHigh);
	STDMETHOD(SendString)(IWin32Handle * pUriHandle, IOverlapped * pOverlapped, BSTR szSourceSuffix, BSTR szTargetUri, BSTR szData);
	STDMETHOD(get_LastError)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_LastError)(/*[in]*/ DWORD newVal);
	STDMETHOD(RegisterUri)(BSTR szUri, IWin32Handle * pParentUri, DWORD dwFlags, /*[out]*/ IWin32Handle ** pVal);
	STDMETHOD(LoadVXD)();
private:
	WCHAR * m_wchar_buffer;
	SAFEARRAY * m_pSafeArray;
	DWORD m_dwReadBufferSize;
	OVERLAPPED m_ReceiveOverlapped;
	BSTR m_szData;
	DWORD m_dwBytesReceived;
	OVERLAPPED m_Overlapped;
	DWORD m_dwLastError;
	HANDLE m_Handle;
};

#endif //__VXDCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\ulvxdobj\win32handle.h ===
// Win32Handle.h : Declaration of the CWin32Handle

#ifndef __WIN32HANDLE_H_
#define __WIN32HANDLE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWin32Handle
class ATL_NO_VTABLE CWin32Handle : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWin32Handle, &CLSID_Win32Handle>,
	public IDispatchImpl<IWin32Handle, &IID_IWin32Handle, &LIBID_ULVXDOBJLib>
{
public:
	CWin32Handle()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WIN32HANDLE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWin32Handle)
	COM_INTERFACE_ENTRY(IWin32Handle)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWin32Handle
public:
	STDMETHOD(get_URIHandle)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_URIHandle)(/*[in]*/ DWORD newVal);
private:
	HANDLE m_Handle;
    DWORD   m_UriHandle;
};

#endif //__WIN32HANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\sources.inc ===
PROJECT_ROOT=..\..\..\..\..
VXDNAME=UL
!INCLUDE $(PROJECT_ROOT)\PLACE.INC

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=$(_OBJ_DIR)

#LINKER_FLAGS=/map $(LINKER_FLAGS)

SOURCES=

TARGETLIBS=                             \

i386_SOURCES=                           \
        ..\i386\event.asm               \
        ..\i386\memory.asm              \
        ..\i386\misc.asm                \
        ..\i386\startup.asm             \
        ..\i386\debug.c                 \
        ..\i386\vxdmain.c               \

USE_MAPSYM=1
SOURCES_USED=..\sources.inc

INCLUDES=\
	$(INCLUDES);\
	$(BASEDIR)\private\ntos\inc;\
	$(BASEDIR)\public\ddk\inc;\
	$(IISBASEDIR)\inc;\
	$(IISBASEDIR)\ulrtl;\
	$(IISBASEDIR)\ul\win9x\inc;\
	$(IISBASEDIR)\ul\win9x\src\vxd\i386;\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\makefile.inc ===
#
# Get the standard VXD build rules.
#

!INCLUDE $(IISBASEDIR)\UL\WIN9X\INC\VXD.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\memory.asm ===
title   "Memory Utilities"

;++
;
; Copyright (c) 1999-1999 Microsoft Corporation
;
; Module Name:
;
;    memory.asm
;
; Abstract:
;
;    This module contains VXD utility functions for manipulating memory.
;
; Author:
;
;    Keith Moore (keithmo)      03-Aug-1999
;
; Revision History:
;
;--



.386P
include vmm.inc
include vwin32.inc
include debug.inc


;
; The lock/unlock flags passed into _LinPageLock and _LinPageUnlock
;

LOCK_FOR_READ_FLAGS     equ     PAGEMAPGLOBAL
LOCK_FOR_WRITE_FLAGS    equ     PAGEMAPGLOBAL OR PAGEMARKDIRTY
UNLOCK_FLAGS            equ     PAGEMAPGLOBAL
VALIDATE_FLAGS          equ     0


;****************************************************************************
;
; Locked code segment.
;

VxD_LOCKED_CODE_SEG



;****************************************************************************
;
; Routine Description:
;
;     Copy a block of memory with fault protection.
;
; Arguments:
;
;     pSource - Supplies the source address.
;
;     pDestination - Supplies the destination address.
;
;     BytesToCopy - Supplies the number of bytes to copy.
;
;     pBytesCopied - Receives the number of bytes actually copied.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdCopyMemory, PUBLIC, CCALL, ESP

                VxDJmp  _VWIN32_CopyMem

EndProc         VxdCopyMemory



;****************************************************************************
;
; Routine Description:
;
;     Allocate a block from the ring0 heap.
;
; Arguments:
;
;     BufferLength - Supplies the number of bytes to allocate.
;
;     Flags - Supplies zero or more HEAP* flags.
;
; Return Value:
;
;     PVOID - A pointer to the newly allocated block if successful,
;         NULL otherwise.
;
;****************************************************************************
BeginProc       VxdAllocMem, PUBLIC, CCALL, ESP

                VxDJmp  _HeapAllocate

EndProc         VxdAllocMem



;****************************************************************************
;
; Routine Description:
;
;     Free a block to the ring0 heap.
;
; Arguments:
;
;     pBuffer - Supplies the buffer to free.
;
;     Flags - Supplies zero or more HEAP* flags.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       VxdFreeMem, PUBLIC, CCALL, ESP

                VxDJmp  _HeapFree

EndProc         VxdFreeMem



;****************************************************************************
;
; Routine Description:
;
;     Lock the specified buffer for read access.
;
; Arguments:
;
;     pBuffer - Supplies the buffer to lock.
;
;     BufferLength - Supplies the length of the buffer.
;
; Return Value:
;
;     PVOID - Global locked address if successful, NULL otherwise.
;
;****************************************************************************
BeginProc       VxdLockBufferForRead, PUBLIC, CCALL, ESP

ArgVar          pBuffer, DWORD
ArgVar          BufferLength, DWORD

                EnterProc
                SaveReg <ebx, edi, esi>

;
; Snag the parameters from the stack.
;

                mov     eax, pBuffer
                mov     ebx, BufferLength

;
; Short-circuit for NULL buffer or zero length.
;

                or      eax, eax
                jz      vlbfr_NullExit
                or      ebx, ebx
                jz      vlbfr_NullExit

;
; Calculate the starting page number and the number of pages to lock.
;

                movzx   ecx, ax
                and     ch, 0Fh         ; ECX = offset within first page
                mov     esi, ecx        ; save it for later
                add     ebx, ecx
                add     ebx, 0FFFh
                shr     ebx, 12         ; EBX = number of pages to lock
                shr     eax, 12         ; EAX = starting page number

;
; Request VMM to lock the buffer.
;

                VMMCall _LinPageLock, <eax, ebx, LOCK_FOR_READ_FLAGS>
                or      eax, eax
                jz      vlbfr_Failure

                add     eax, esi        ; add offset into first page

;
; Common exit path. Cleanup stack & return.
;

vlbfr_Exit:

                RestoreReg <esi, edi, ebx>
                LeaveProc
                Return

;
; LinPageLock failure.
;

vlbfr_Failure:

                Trace_Out "VxdLockBufferForRead: _LinPageLock failed"
                ; fall through to NULL exit path.

;
; NULL pointer or zero-length buffer.
;

vlbfr_NullExit:

                xor     eax, eax
                jmp     vlbfr_Exit

EndProc         VxdLockBufferForRead



;****************************************************************************
;
; Routine Description:
;
;     Lock the specified buffer for write access.
;
; Arguments:
;
;     pBuffer - Supplies the buffer to lock.
;
;     BufferLength - Supplies the length of the buffer.
;
; Return Value:
;
;     PVOID - Global locked address if successful, NULL otherwise.
;
;****************************************************************************
BeginProc       VxdLockBufferForWrite, PUBLIC, CCALL, ESP

ArgVar          pBuffer, DWORD
ArgVar          BufferLength, DWORD

                EnterProc
                SaveReg <ebx, edi, esi>

;
; Snag the parameters from the stack.
;

                mov     eax, pBuffer
                mov     ebx, BufferLength

;
; Short-circuit for NULL buffer or zero length.
;

                or      eax, eax
                jz      vlbfw_NullExit
                or      ebx, ebx
                jz      vlbfw_NullExit

;
; Calculate the starting page number and the number of pages to lock.
;

                movzx   ecx, ax
                and     ch, 0Fh         ; ECX = offset within first page
                mov     esi, ecx        ; save it for later
                add     ebx, ecx
                add     ebx, 0FFFh
                shr     ebx, 12         ; EBX = number of pages to lock
                shr     eax, 12         ; EAX = starting page number

;
; Request VMM to lock the buffer.
;

                VMMCall _LinPageLock, <eax, ebx, LOCK_FOR_WRITE_FLAGS>
                or      eax, eax
                jz      vlbfw_Failure

                add     eax, esi        ; add offset into first page

;
; Common exit path. Cleanup stack & return.
;

vlbfw_Exit:

                RestoreReg <esi, edi, ebx>
                LeaveProc
                Return

;
; LinPageLock failure.
;

vlbfw_Failure:

                Trace_Out "VxdLockBufferForWrite: _LinPageLock failed"
                ; fall through to NULL exit path.

;
; NULL pointer or zero-length buffer.
;

vlbfw_NullExit:

                xor     eax, eax
                jmp     vlbfw_Exit

EndProc         VxdLockBufferForWrite



;****************************************************************************
;
; Routine Description:
;
;     Unlocks a buffer locked with either VxdLockBufferForRead or
;     VxdLockBufferForWrite.
;
; Arguments:
;
;     pBuffer - Supplies the buffer to unlock. This must be a pointer
;         returned by one of the VxdLockBufferForXxx routines.
;
;     BufferLength - Supplies the length of the buffer.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdUnlockBuffer, PUBLIC, CCALL, ESP

ArgVar          pBuffer, DWORD
ArgVar          BufferLength, DWORD

                EnterProc
                SaveReg <ebx, edi, esi>

;
; Snag the parameters from the stack.
;

                mov     eax, pBuffer
                mov     ebx, BufferLength

;
; Short-circuit for NULL buffer or zero length.
;

                or      eax, eax
                jz      vub_Success
                or      ebx, ebx
                jz      vub_Success

;
; Calculate the starting page number and the number of pages to lock.
;

                movzx   ecx, ax
                and     ch, 0Fh         ; ECX = offset within first page
                add     ebx, ecx
                add     ebx, 0FFFh
                shr     ebx, 12         ; EBX = number of pages to lock
                shr     eax, 12         ; EAX = starting page number

;
; Request VMM to unlock the buffer.
;

                VMMCall _LinPageUnlock, <eax, ebx, UNLOCK_FLAGS>
                or      eax, eax
                jz      vub_Failure

vub_Success:

                mov     eax, 1          ; !0 == success

;
; Common exit path. Cleanup stack & return.
;

vub_Exit:

                RestoreReg <esi, edi, ebx>
                LeaveProc
                Return

;
; LinPageUnlock failure.
;

vub_Failure:

                Trace_Out "VxdUnlockBuffer: _LinPageUnlock failed"
                xor     eax, eax        ; 0 == failure
                jmp     vub_Exit

EndProc         VxdUnlockBuffer



;****************************************************************************
;
; Routine Description:
;
;     Validate the specified buffer for read/write access.
;     (NULL pointer or zero-size Buffer will secceed)
;
; Arguments:
;
;     pBuffer - Supplies the buffer to lock.
;
;     BufferLength - Supplies the length of the buffer.
;
; Return Value:
;
;     PVOID - Global address if successful, NULL otherwise.
;
;****************************************************************************
BeginProc       VxdValidateBuffer, PUBLIC, CCALL, ESP

ArgVar          pBuffer, DWORD
ArgVar          BufferLength, DWORD

                EnterProc
                SaveReg <ebx, edi, esi>

;
; Snag the parameters from the stack.
;

                mov     eax, pBuffer
                mov     ebx, BufferLength

;
; Short-circuit for NULL buffer or zero length.
;

                or      eax, eax
                jz      vvb_Success
                or      ebx, ebx
                jz      vvb_Success

;
; Calculate the starting page number and the number of pages to lock.
;

                movzx   ecx, ax
                and     ch, 0Fh         ; ECX = offset within first page
                mov     edi, ecx        ; save it for later (MauroOt)
                add     ebx, ecx
                add     ebx, 0FFFh
                shr     ebx, 12         ; EBX = number of pages to lock
                mov     esi, ebx        ; save it for later
                shr     eax, 12         ; EAX = starting page number

;
; Request VMM to validate the buffer.
;

                VMMCall _PageCheckLinRange, <eax, ebx, VALIDATE_FLAGS>
                cmp     eax, esi		; success only if the entire buffer is valid
                jnz     vvb_Failure

vvb_Success:

;                mov     eax, 1
                mov     eax, pBuffer


;
; Common exit path. Cleanup stack & return.
;

vvb_Exit:

                RestoreReg <esi, edi, ebx>
                LeaveProc
                Return

;
; _PageCheckLinRange failure.
;

vvb_Failure:

                Trace_Out "VxdValidateBuffer: _PageCheckLinRange failed"
                xor     eax, eax
                jmp     vvb_Exit

EndProc         VxdValidateBuffer 


VXD_LOCKED_CODE_ENDS



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\test\vxd\vxd.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

	vxd.c

Abstract:

	VXD - sample ul.vxd.

Author:

    Mauro Ottaviani (mauroot)       24-Jan-2000

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "ulapi9x.h"


#define URL L"http://abBA/ezZE/HIhi/111222333"
#define URL_SIZE sizeof(URL)
#define URL_LENGTH sizeof(URL)/sizeof(WCHAR)

#define FLUSH_AND_WAIT //{fflush(stdout);Sleep(500);}

#define MAX_APP_POOLS 100
#define MAX_URIS 100

#define swap(x,y) x^=y,y^=x,x^=y
#define swap2(x,y) x=((PVOID)((ULONG)x^(ULONG)y)),y=((PVOID)((ULONG)x^(ULONG)y)),x=((PVOID)((ULONG)x^(ULONG)y))
#define swap_pvoid(x,y) {PVOID t=x;x=y,y=t;}
#define rnd(x,y) ((int)( ((double)x)+(((double)y+1.0)-((double)x))*(((double)rand()) / ((double)RAND_MAX)) ))

// void UnregPools(WCHAR *UriArray[MAX_URI_ARRAY], int UriSize, HANDLE Pools[100], int PoolSize);

VOID
__cdecl
main( int argc, char* argv[] )
{
	SYSTEMTIME ST;                
    GetSystemTime( &ST );

	// srand( (unsigned)(ST.wSecond*ST.wMilliseconds) );

	if ( argc == 4 )
	{
		// start the processes

		int i, wProcesses, wAppPool, wUri;
		char command_line[32];

		wProcesses = atoi(argv[1]);
		wAppPool = atoi(argv[2]);
		wUri = atoi(argv[3]);

		if ( wAppPool >= MAX_APP_POOLS || wUri >= MAX_URIS )
		{
			printf( "you're only allowed up to %d AppPools and %d Uri/AppPool\n", MAX_APP_POOLS, MAX_URIS );
			return;
		}

		sprintf( command_line, "%s %d %d", argv[0], wAppPool, wUri );

		for ( i = 0; i<wProcesses; i++ )
		{
			PROCESS_INFORMATION piProcInfo; 
			STARTUPINFO siStartInfo; 

			// Set up members of STARTUPINFO structure. 

			ZeroMemory( &siStartInfo, sizeof(STARTUPINFO) );
			siStartInfo.cb = sizeof(STARTUPINFO); 

			// Create the child process. 

			printf( "Creating a new process: [%s]\n", command_line );

			CreateProcess(
				NULL,
				command_line,
				NULL,
				NULL,
				TRUE,
				0,
				NULL,
				NULL,
				&siStartInfo,
				&piProcInfo );
		}
	}
	else if ( argc == 3 )
	{
		int wAppPool, wUri;
	    int i, j, k, l, m, n, result=ERROR_SUCCESS;   

		WCHAR url[URL_SIZE];

		HANDLE hAppPool[MAX_APP_POOLS];
		int wShuffle[MAX_APP_POOLS], UriSize[MAX_APP_POOLS];
        WCHAR* Uris[MAX_APP_POOLS][MAX_URIS];

		wAppPool = rnd( 1, atoi(argv[1]) );

		printf( "Calling UlInitialize(0)\n" ); FLUSH_AND_WAIT;
		result = UlInitialize( 0 );

		if ( result != ERROR_SUCCESS )
		{
			printf( "UlInitialize() failed. result:%u\n", result );
			return;
		}

		printf( "~~~~~~ Uri Registration\n" ); FLUSH_AND_WAIT;

		for ( i = 0; i < wAppPool; i++ )
		{
            hAppPool[i] = 0;
			
			printf( "Calling UlCreateAppPool(%08X)\n", &hAppPool[i] ); FLUSH_AND_WAIT;

			result = UlCreateAppPool( &hAppPool[i] );

			if ( result != ERROR_SUCCESS )
			{
				printf( "UlCreateAppPool() failed. result:%u\n", result );
				continue;
			}

			printf( "hAppPool[%d] = %08X\n", i, hAppPool[i] ); FLUSH_AND_WAIT;

			wUri = rnd( 1, atoi(argv[2]) );

	        if ( wUri > MAX_URIS)
	        {
	            wUri = MAX_URIS;
	        }

            UriSize[i] = wUri;

			for ( j = 0; j < wUri; j++ )
			{
				memcpy( url, URL, URL_SIZE);

				// shuffle the uri characters

				for ( k = 0; k<rnd( 1, 5 ); k++ )
				{
					l = rnd( 7, URL_LENGTH  );
					m = rnd( 7, URL_LENGTH  );
			        if ( l != m )
			        {
						swap( url[l], url[m] );
			        }
				}

				// end it at an arbitrary position
				
				url[ rnd( 8, URL_LENGTH ) ] = (WCHAR)0;

				// save a copy for future unregistration

				Uris[i][j] = (WCHAR*) malloc(URL_SIZE);
                memcpy(Uris[i][j], url, URL_SIZE);

				printf( "Calling UlRegisterUri(%08X,%S)\n", hAppPool[i], url ); FLUSH_AND_WAIT;
				result = UlRegisterUri( hAppPool[i], url );

				if ( result != 0 )
				{
					printf( "UlRegisterUri() failed. result:%u\n", result ); FLUSH_AND_WAIT;
					j--;
				}
                
			}            
		}		

        printf( "~~~~~~ Uri Unregistration\n" ); FLUSH_AND_WAIT;

        // UnregPools(Uris, UriSize, hAppPool, PoolSize);

		for ( k = 0; k<wAppPool; k++ )
		{
			wShuffle[k] = k;
		}
		
		// shuffle the Pool Array

		for ( k = 0; k<wAppPool*2; k++ )
		{
	        l = rnd(0, wAppPool-1);
	        m = rnd(0, wAppPool-1);
	        if ( l != m )
	        {
		        swap( wShuffle[l], wShuffle[m] );
	        }
		}

	    for ( n = 0; n < wAppPool; n++ )
	    {
	    	i = wShuffle[n];
	    	
			printf( "hAppPool:%d (Uri#:%d)\n", hAppPool[i], UriSize[i] ); FLUSH_AND_WAIT;
			
			// shuffle the URI array

			for ( k = 0; k<UriSize[i]*2; k++ )
			{
		        l = rnd(0, UriSize[i]-1);
		        m = rnd(0, UriSize[i]-1);
		        if ( l != m )
		        {
			        swap_pvoid( Uris[i][l], Uris[i][m] );
		        }
			}

	        // Unregister all the URIs in the array
	        for ( j = 0; j < UriSize[i]; j++)
	        {
				printf( "Calling UlUnregisterUri(hAppPool[%d]:%08X,Uris[%d]:%S)\n", i, hAppPool[i], j, Uris[i][j] ); FLUSH_AND_WAIT;

	            result = UlUnregisterUri( hAppPool[i], Uris[i][j] );
			    if ( result != ERROR_SUCCESS )
			    {
			    	printf( "UlUnregisterUri() FAILED. result:%u\n", result );
			    }
	        }
		}

		// wait for all processees to end

        Sleep( 5000 );

		printf( "Calling UlTerminate()\n" );

		UlTerminate();
	}
	else
	{
		printf( "Microsoft (R) vxd Version 1.00 (NT)\nCopyright (C) Microsoft Corp 1999. All rights reserved.\nusage: vxd numProcesses maxAppPools maxUris\nexample: vxd 5 10 20\n" );
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\misc.asm ===
title   "Miscellaneous Utilities"

;++
;
; Copyright (c) 1999-1999 Microsoft Corporation
;
; Module Name:
;
;    misc.asm
;
; Abstract:
;
;    This module contains miscellaneous VXD utility functions.
;
; Author:
;
;    Keith Moore (keithmo)      03-Aug-1999
;
; Revision History:
;
;--



.386P
include vmm.inc
include vwin32.inc



;****************************************************************************
;
; Locked code segment.
;

VxD_LOCKED_CODE_SEG



;****************************************************************************
;
; Routine Description:
;
;     Retrieves the ring0 handle for the current thread.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     ULONG - The ring0 handle for the current thread.
;
;****************************************************************************
BeginProc       VxdGetCurrentThread, PUBLIC, CCALL, ESP

                EnterProc
                SaveReg <edi>

;
; Call VMM to get the current thread handle.
;

                VMMCall Get_Cur_Thread_Handle
                mov     eax, edi

;
; Cleanup stack & return.
;

                RestoreReg <edi>
                LeaveProc
                Return

EndProc         VxdGetCurrentThread



;****************************************************************************
;
; Routine Description:
;
;     Retrieves the ring0 handle for the current process.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     ULONG - The ring0 handle for the current process.
;
;****************************************************************************
BeginProc       VxdGetCurrentProcess, PUBLIC, CCALL, ESP

                VxDJmp  VWIN32_GetCurrentProcessHandle

EndProc         VxdGetCurrentProcess



VXD_LOCKED_CODE_ENDS



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\debug.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debug support routines.
    The following functions are exported by this module:

        VxdAssert
        VxdPrintf

Author:

    Keith Moore (keithmo)			30-Dec-1993

Revision History:

    Mauro Ottaviani (mauroot)       17-Aug-1999

--*/

#define NOGDI
#define NOIME
#define NOMCX
#define NONLS
#define NOUSER
#define NOHELP
#define NOSYSPARAMSINFO

#include <windows.h>
#include <vmm.h>

#define MAX_PRINTF_OUTPUT       2048             // characters
#define IS_DIGIT(ch)            (((ch) >= '0') && ((ch) <= '9'))


#ifdef DBG

//
//  Debug output functions.
//

VOID
VxdPrintf(
    CHAR * pszFormat,
    ...
    );

INT
VxdSprintf(
    CHAR * pszStr,
    int max_size,
    CHAR * pszFmt,
    ...
    );

VOID
VxdPrint(
    CHAR * String
    );


VOID
VxdAssert(
    VOID  * Assertion,
    VOID  * FileName,
    DWORD   LineNumber
    );

//
//  Miscellaneous goodies.
//

#define DEBUG_BREAK             { _asm int 3 }
#define DEBUG_OUTPUT(x)         VxdPrint
#define VXD_PRINT(args)			VxdPrintf args
#define VXD_ASSERT(exp)			if (!(exp)) VxdPrintf( "\n*** Assertion failed: %s\n*** Source file %s, line %lu\n\n", (#exp), (__FILE__), ((DWORD) __LINE__ ) )
//#define VXD_REQUIRE				VXD_ASSERT


//
//  Public globals.
//


//
//  Private constants.
//


//
//  Private types.
//


//
//  Private globals.
//

CHAR szPrintfOutput[MAX_PRINTF_OUTPUT];


//
//  Private prototypes.
//

INT
VxdVsprintf(
    CHAR * pszStr,
    int max_size,
    CHAR * pszFmt,
    CHAR * ArgPtr
    );


//
//  Public functions.
//

/*******************************************************************

    NAME:       VxdAssert

    SYNOPSIS:   Called if an assertion fails.  Displays the failed
                assertion, file name, and line number.  Gives the
                user the opportunity to ignore the assertion or
                break into the debugger.

    ENTRY:      Assertion - The text of the failed expression.

                FileName - The containing source file.

                LineNumber - The guilty line number.

    HISTORY:
        KeithMo     30-Dec-1993 Created.

********************************************************************/
VOID
VxdAssert(
    VOID  * Assertion,
    VOID  * FileName,
    DWORD   LineNumber
    )
{
	_asm
	{
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	edi
		push	esi
	}

    VxdPrintf( "\n"
               "*** Assertion failed: %s\n"
               "*** Source file %s, line %lu\n\n",
               Assertion,
               FileName,
               LineNumber );

    DEBUG_BREAK;

	_asm
	{
		pop		esi
		pop		edi
		pop		edx
		pop		ecx
		pop		ebx
		pop		eax
	}

}   // VxdAssert

/*******************************************************************

    NAME:       VxdPrintf

    SYNOPSIS:   Customized debug output routine.

    ENTRY:      Usual printf-style parameters.

    HISTORY:
        KeithMo     30-Dec-1993 Created.

********************************************************************/
VOID
VxdPrintf(
    CHAR * pszFormat,
    ...
    )
{
    va_list ArgList;

	va_start( ArgList, pszFormat );
	VxdVsprintf( szPrintfOutput, MAX_PRINTF_OUTPUT, pszFormat, ArgList );
	va_end( ArgList );

	VxdPrint( szPrintfOutput );

}   // VxdPrintf

/*******************************************************************

    NAME:       VxdSprintf

    SYNOPSIS:   Half-baked sprintf() clone for VxD environment.

    ENTRY:      pszStr - Will receive the formatted string.

                pszFmt - The format, with field specifiers.

                ... - Usual printf()-like parameters.

    RETURNS:    INT - Number of characters stored in *pszStr.

    HISTORY:
        KeithMo     30-Dec-1993 Created.

********************************************************************/
INT
VxdSprintf(
    CHAR * pszStr,
    int max_size,
    CHAR * pszFmt,
    ...
    )
{
    INT     cch;
    va_list ArgPtr;

    va_start( ArgPtr, pszFmt );
    cch = VxdVsprintf( pszStr, max_size, pszFmt, ArgPtr );
    va_end( ArgPtr );

    return( cch );

}   // VxdSprintf

/*******************************************************************

    NAME:       VxdPrint

    SYNOPSIS:   Sends a string to the debugger, if running.

    ENTRY:      String - The string to display.

    HISTORY:
        KeithMo     30-Dec-1993 Created.

********************************************************************/
VOID
VxdPrint(
	CHAR * String
	)
{
	Out_Debug_String( String );

}   // VxdPrint


//
//  Private functions.
//

/*******************************************************************

    NAME:       VxdVsprintf

    SYNOPSIS:   Half-baked vsprintf() clone for VxD environment.

    ENTRY:      pszStr - Will receive the formatted string.

                pszFmt - The format, with field specifiers.

                ArgPtr - Points to the actual printf() arguments.

    RETURNS:    INT - Number of characters stored in *pszStr.

    HISTORY:
        KeithMo     30-Dec-1993 Created.
        MauroOt     17-Aug-1999 Added %S for UNICODE strings (WCHAR*). Removed %P.

********************************************************************/
INT
VxdVsprintf(
    CHAR * pszStr,
    int max_size,
    CHAR * pszFmt,
    CHAR * ArgPtr
    )

{
    CHAR   ch;
    CHAR * pszStrStart;
    INT    fZeroPad;
    INT    cchWidth;

    //
    //  Remember start of output, so we can calc length.
    //

    pszStrStart = pszStr;

    while( ( ch = *pszFmt++ ) != '\0' )
    {
        //
        //  Scan for format specifiers.
        //

        if( ch == '\n' )
        {
            *pszStr++ = '\r';
        }

        if( ch != '%' )
        {
            *pszStr++ = ch;
            continue;
        }

		if ( pszStr > pszStrStart + max_size - 1 ) break;

        //
        //  Got one.
        //

        ch = *pszFmt++;

        //
        //  Initialize attributes for this item.
        //

        fZeroPad = 0;
        cchWidth = 0;

        //
        //  Interpret the field specifiers.
        //

        if( ch == '-' )
        {
            //
            //  Left justification not supported.
            //

            ch = *pszFmt++;
        }

        if( ch == '0' )
        {
            //
            //  Zero padding.
            //

            fZeroPad = 1;
            ch       = *pszFmt++;
        }

        if( ch == '*' )
        {
            //
            //  Retrieve width from next argument.
            //

            cchWidth = va_arg( ArgPtr, INT );
            ch       = *pszFmt++;
        }
        else
        {
            //
            //  Calculate width.
            //

            while( IS_DIGIT(ch) )
            {
                cchWidth = ( cchWidth * 10 ) + ( ch - '0' );
                ch       = *pszFmt++;
            }
        }

        //
        //  Note that we don't support the precision specifiers,
        //  but we do honor the syntax.
        //

        if( ch == '.' )
        {
            ch = *pszFmt++;

            if( ch == '*' )
            {
                (VOID)va_arg( ArgPtr, INT );
                ch = *pszFmt++;
            }
            else
            {
                while( IS_DIGIT(ch) )
                {
                    ch = *pszFmt++;
                }
            }
        }

        //
        //  All numbers are longs.
        //

        if( ch == 'l' )
        {
            ch = *pszFmt++;
        }

        //
        //  Decipher the format specifier.
        //

        if( ( ch == 'd' ) || ( ch == 'u' ) || ( ch == 'x' ) || ( ch == 'X' ) )
        {
            DWORD   ul;
            DWORD   radix;
            CHAR    xbase;
            CHAR  * pszTmp;
            CHAR  * pszEnd;
            INT     cchNum;
            INT     fNegative;

            //
            //  Numeric.  Retrieve the value.
            //

            ul = va_arg( ArgPtr, unsigned long );

            //
            //  If this is a negative number, remember and negate.
            //

            if( ( ch == 'd' ) && ( (long)ul < 0 ) )
            {
                fNegative = 1;
                ul        = (unsigned long)(-(long)ul);
            }
            else
            {
                fNegative = 0;
            }

            //
            //  Remember start of digits.
            //

            pszTmp = pszStr;
            cchNum = 0;

            //
            //  Special goodies for hex conversion.
            //

            radix  = ( ( ch == 'x' ) || ( ch == 'X' ) ) ? 16 : 10;
            xbase  = ( ch == 'x' ) ? 'a' : 'A';

            //
            //  Loop until we're out of digits.
            //

            do
            {
                UINT digit;

                digit  = (UINT)( ul % radix );
                ul    /= radix;

                if( digit > 9 )
                {
                    *pszTmp++ = (CHAR)( digit - 10 + xbase );
                }
                else
                {
                    *pszTmp++ = (CHAR)( digit + '0' );
                }

                cchNum++;

				if ( pszTmp > pszStrStart + max_size - 1 ) break;

            } while( ul > 0 );

            //
            //  Add the negative sign if necessary.
            //

            if( fNegative )
            {
                *pszTmp++ = '-';
                cchNum++;
            }

			if ( pszTmp > pszStrStart + max_size - 1 ) break;

            //
            //  Add any necessary padding.
            //

            while( cchNum < cchWidth )
            {
                *pszTmp++ = fZeroPad ? '0' : ' ';
                cchNum++;

				if ( pszTmp > pszStrStart + max_size - 1 ) break;

            }

            //
            //  Now reverse the digits.
            //

            pszEnd = pszTmp--;

            do
            {
                CHAR tmp;

                tmp     = *pszTmp;
                *pszTmp = *pszStr;
                *pszStr = tmp;

                pszTmp--;
                pszStr++;

				if ( pszStr > pszStrStart + max_size - 1 ) break;

            } while( pszTmp > pszStr );

            pszStr = pszEnd;
        }
        else
        if( ch == 's' )
        {
            CHAR * pszTmp;

            //
            //  Copy the string.
            //

            pszTmp = va_arg( ArgPtr, CHAR * );

            while( *pszTmp )
            {
                *pszStr++ = *pszTmp++;
				if ( pszStr > pszStrStart + max_size - 1 ) break;
            }
        }
        else
        if( ch == 'S' )
        {
            WCHAR * pszTmp;

            //
            //  Copy the UNICODE string.
            //

            pszTmp = va_arg( ArgPtr, WCHAR * );

            while( *pszTmp )
            {
                *pszStr++ = (CHAR)((*pszTmp++)&0x00FF);
				if ( pszStr > pszStrStart + max_size - 1 ) break;
            }
        }
        else
        if( ch == 'c' )
        {
            //
            //  A single character.
            //

            *pszStr++ = (CHAR)va_arg( ArgPtr, INT );
        }
        else
        {
            //
            //  Unknown.  Ideally we should copy the entire
            //  format specifier, including any width & precision
            //  values, but who really cares?
            //

            *pszStr++ = ch;
        }

		if ( pszStr > pszStrStart + max_size - 1 ) break;
    }

    //
    //  Terminate it properly.
    //

	if ( pszStr > pszStrStart + max_size - 7 )
	{
		// move to the end of the string
		
		pszStr = pszStrStart + max_size - 1;

	    *(pszStr-5) = 'T';
	    *(pszStr-4) = 'R';
	    *(pszStr-3) = 'U';
	    *(pszStr-2) = 'N';
	    *(pszStr-1) = 'C';
	}
	
    *pszStr = '\0';

    //
    //  Return the length of the generated string.
    //

    return pszStr - pszStrStart;

}   // VxdVsprintf


#else // #ifdef DBG

//
//  Null debug output functions.
//


//__inline
VOID VxdPrintf( CHAR * pszFormat, ... ) {}
#define DEBUG_BREAK
#define DEBUG_OUTPUT(x)
#define VXD_PRINT(args)
#define VXD_ASSERT(exp)
#define VXD_REQUIRE


#endif // #ifdef DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\event.asm ===
title   "Event Utilities"

;++
;
; Copyright (c) 1999-1999 Microsoft Corporation
;
; Module Name:
;
;    event.asm
;
; Abstract:
;
;    This module contains VXD utility functions for manipulating
;    event objects.
;
; Author:
;
;    Keith Moore (keithmo)      03-Aug-1999
;
; Revision History:
;
;--



.386P
include vmm.inc
include vwin32.inc



;****************************************************************************
;
; Locked code segment.
;

VxD_LOCKED_CODE_SEG



;****************************************************************************
;
; Routine Description:
;
;     Helper routine to invoke callback in the context of the system VM.
;     If we're already running in the system VM, then the callback is
;     simply invoked directly.
;
; Arguments:
;
;     (ESI) - Supplies a pointer to the callback function.
;
;     (EDX) - Supplies a context value for the callback.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       InvokeInSystemVM, PUBLIC

;
; See if we're running in the system VM.
;

                VMMCall Get_Cur_VM_Handle
                mov     eax, ebx
                VMMCall Get_Sys_VM_Handle
                cmp     eax, ebx
                jne     iisv_Schedule

;
; We're in the system VM, so just invoke the callback directly.
;

                jmp     esi

iisv_Schedule:

;
; Need to schedule a VM event so we can set the Win32 event later. Note
; that (EBX) still holds the system VM handle. Also, (ESI) and (EDX)
; should be as they were when this routine was called.
;

                VMMCall Call_VM_Event
                ret

EndProc         InvokeInSystemVM



;****************************************************************************
;
; Routine Description:
;
;     Sets the specified Win32 event object.
;
; Arguments:
;
;     Event - Supplies a pointer to a kernel event as returned by
;         calling OpenVxdHandle() on an event object handle.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdSetWin32Event, PUBLIC, CCALL, ESP

ArgVar          Event, DWORD

                EnterProc
                SaveReg <ebx, edx, esi>

                mov     esi, OFFSET SetWin32EventCallback
                mov     edx, Event
                call    InvokeInSystemVM

;
; Cleanup stack & return.
;

                RestoreReg <esi, edx, ebx>
                LeaveProc
                Return

EndProc         VxdSetWin32Event



;****************************************************************************
;
; Routine Description:
;
;     Callback routine invoked to set the specified Win32 event object.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EDX) - Supplies the callback context value. In this case, it's
;         the event handle to set.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       SetWin32EventCallback, PUBLIC

                mov     eax, edx
                VxDCall _VWin32_SetWin32Event
                mov     eax, 1  ; bugbug
                ret

EndProc         SetWin32EventCallback



;****************************************************************************
;
; Routine Description:
;
;     Resets the specified Win32 event object.
;
; Arguments:
;
;     Event - Supplies a pointer to a kernel event as returned by
;         calling OpenVxdHandle() on an event object handle.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdResetWin32Event, PUBLIC, CCALL, ESP

ArgVar          Event, DWORD

                EnterProc
                SaveReg <ebx, edx, esi>

                mov     esi, OFFSET ResetWin32EventCallback
                mov     edx, Event
                call    InvokeInSystemVM

;
; Cleanup stack & return.
;

                RestoreReg <esi, edx, ebx>
                LeaveProc
                Return

EndProc         VxdResetWin32Event



;****************************************************************************
;
; Routine Description:
;
;     Callback routine invoked to reset the specified Win32 event object.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EDX) - Supplies the callback context value. In this case, it's
;         the event handle to reset.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       ResetWin32EventCallback, PUBLIC

                mov     eax, edx
                VxDCall _VWin32_ResetWin32Event
                mov     eax, 1  ; bugbug
                ret

EndProc         ResetWin32EventCallback



;****************************************************************************
;
; Routine Description:
;
;     Closes the specified Win32 object.
;
; Arguments:
;
;     Object - Supplies a pointer to a kernel object as returned by
;         calling OpenVxdHandle() on a kernel handle.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdCloseHandle, PUBLIC, CCALL, ESP

ArgVar          Object, DWORD

                EnterProc
                SaveReg <ebx, edx, esi>

                mov     esi, OFFSET CloseHandleCallback
                mov     edx, Object
                call    InvokeInSystemVM

;
; Cleanup stack & return.
;

                RestoreReg <esi, edx, ebx>
                LeaveProc
                Return

EndProc         VxdCloseHandle



;****************************************************************************
;
; Routine Description:
;
;     Callback routine invoked to close the specified Win32 object.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EDX) - Supplies the callback context value. In this case, it's
;         the object handle to close.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       CloseHandleCallback, PUBLIC

                mov     eax, edx
                VxDCall _VWin32_CloseVxdHandle
                mov     eax, 1  ; bugbug
                ret

EndProc         CloseHandleCallback



;****************************************************************************
;
; Routine Description:
;
;     Sets and closes the specified Win32 event object.
;
; Arguments:
;
;     Event - Supplies a pointer to a kernel event as returned by
;         calling OpenVxdHandle() on an event object handle.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdSetAndCloseWin32Event, PUBLIC, CCALL, ESP

ArgVar          Event, DWORD

                EnterProc
                SaveReg <ebx, edx, esi>

                mov     esi, OFFSET SetAndCloseWin32EventCallback
                mov     edx, Event
                call    InvokeInSystemVM

;
; Cleanup stack & return.
;

                RestoreReg <esi, edx, ebx>
                LeaveProc
                Return

EndProc         VxdSetAndCloseWin32Event



;****************************************************************************
;
; Routine Description:
;
;     Callback routine invoked to set and close the specified Win32 event
;     object.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EDX) - Supplies the callback context value. In this case, it's
;         the event handle to set and close.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       SetAndCloseWin32EventCallback, PUBLIC

                mov     eax, edx
                VxDCall _VWin32_SetWin32Event

                mov     eax, edx
                VxDCall _VWin32_CloseVxdHandle
                mov     eax, 1  ; bugbug
                ret

EndProc         SetAndCloseWin32EventCallback



;****************************************************************************
;
; Routine Description:
;
;     Closes the specified Win32 object.
;
; Arguments:
;
;     pObject - Supplies the object to close.
;
; Return Value:
;
;     ULONG - !0 if successful, 0 otherwise.
;
;****************************************************************************
BeginProc       VxdCloseObject, PUBLIC, CCALL, ESP

ArgVar          pObject, DWORD

                EnterProc
                SaveReg <ebx, edx, esi>

                mov     esi, OFFSET CloseHandleCallback
                mov     edx, pObject
                call    InvokeInSystemVM

;
; Cleanup stack & return.
;

                RestoreReg <esi, edx, ebx>
                LeaveProc
                Return

EndProc         VxdCloseObject



;****************************************************************************
;
; Routine Description:
;
;     Callback routine invoked to close the specified Win32 object.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EDX) - Supplies the callback context value. In this case, it's
;         the object to close.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       CloseObjectCallback, PUBLIC

                mov     eax, edx
                VxDCall _VWin32_CloseVxdHandle
                mov     eax, 1  ; bugbug
                ret

EndProc         CloseObjectCallback



VXD_LOCKED_CODE_ENDS



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\precompvxd.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for the VXD. It includes all other
    necessary header files.

Author:

    Keith Moore (keithmo)       03-Aug-1999

Revision History:

--*/


#ifndef _PRECOMPVXD_H_
#define _PRECOMPVXD_H_


//
// Documentation macros.
//

#define IN
#define OUT
#define OPTIONAL

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#define _WINNT_
#include <vmm.h>
#undef _WINNT_

#include <debug.h>
#include <vwin32.h>



#define VXDAPI __cdecl


//
// Project include files.
//


//
// Local include files.
//


//
// Utility functions from EVENT.ASM.
//

ULONG
VXDAPI
VxdSetWin32Event(
    IN PVOID pEvent
    );

ULONG
VXDAPI
VxdResetWin32Event(
    IN PVOID pEvent
    );

ULONG
VXDAPI
VxdSetAndCloseWin32Event(
    IN PVOID pEvent
    );

ULONG
VXDAPI
VxdCloseObject(
    IN PVOID pObject
    );


//
// Utility functions from MEMORY.ASM.
//

ULONG
VXDAPI
VxdCopyMemory(
    IN PVOID pSource,
    IN PVOID pDestination,
    IN ULONG BytesToCopy,
    IN PULONG pBytesCopied
    );

PVOID
VXDAPI
VxdAllocMem(
    IN ULONG BufferLength,
    IN ULONG Flags
    );

VOID
VXDAPI
VxdFreeMem(
    IN PVOID pBuffer,
    IN ULONG Flags
    );

PVOID
VXDAPI
VxdLockBufferForRead(
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );

PVOID
VXDAPI
VxdLockBufferForWrite(
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );

VOID
VXDAPI
VxdUnlockBuffer(
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );

PVOID
VXDAPI
VxdValidateBuffer(
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );


//
// Utility functions from MISC.ASM.
//

HANDLE
VXDAPI
VxdGetCurrentThread(
    VOID
    );

HANDLE
VXDAPI
VxdGetCurrentProcess(
    VOID
    );


//
// Utility functions from DEBUG.C.
//

VOID
VxdAssert(
    VOID  * Assertion,
    VOID  * FileName,
    DWORD   LineNumber
    );

INT
VxdSprintf(
    CHAR * pszStr,
    CHAR * pszFmt,
    ...
    );

VOID
VxdPrint(
    CHAR * String
    );

VOID
VxdPrintf(
    CHAR * pszFormat,
    ...
    );


#endif  // _PRECOMPVXD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\startup.asm ===
title   "VXD Startup Code"

;++
;
; Copyright (c) 1999-1999 Microsoft Corporation
;
; Module Name:
;
;    startup.asm
;
; Abstract:
;
;    This module implements VXD startup code.
;
; Author:
;
;    Keith Moore (keithmo)      03-Aug-1999
;
; Revision History:
;
;--



.386P
include vmm.inc
include vwin32.inc
include debug.inc



;
; Declare the VXD header.
;

Declare_Virtual_Device UL, 1, 0, ControlProc, Undefined_Device_ID, Undefined_Init_Order



;****************************************************************************
;
; Locked data segment.
;

VxD_LOCKED_DATA_SEG

;
; Flag indicating that we're already loaded.
;

AlreadyLoaded   db      0

VxD_LOCKED_DATA_ENDS



;****************************************************************************
;
; Locked code segment.
;

VxD_LOCKED_CODE_SEG



;****************************************************************************
;
; Routine Description:
;
;     This is the main dispatch routine for VXD messages. Since messages
;     may be issued at interrupt time, this routine must be in the locked
;     code segment.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EBP) - Supplies a pointer to the client register structure.
;
; Return Value:
;
;     (CY) - Message not handled.
;
;     (NC) - Message handled.
;
;****************************************************************************
BeginProc       ControlProc

                Control_Dispatch Sys_Dynamic_Device_Init, My_Device_Init
                Control_Dispatch Sys_Dynamic_Device_Exit, My_Device_Exit
                Control_Dispatch Destroy_Thread, My_Destroy_Thread
                Control_Dispatch W32_DeviceIoControl, My_DeviceIoControl

                clc
                ret

EndProc         ControlProc

VXD_LOCKED_CODE_ENDS



;****************************************************************************
;
; Pageable code segment.
;

VxD_PAGEABLE_CODE_SEG


;****************************************************************************
;
; Routine Description:
;
;     Performs global driver initialization.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (ESI) - Supplies a pointer to any command-line arguments (?).
;
; Return Value:
;
;     (CY) - Initialization failed.
;
;     (NC) - Initialization completed successfully.
;
;****************************************************************************
BeginProc       My_Device_Init

;
; Ensure we're not already loaded.
;

                mov     eax, OFFSET32 AlreadyLoaded
                mov     dl, byte ptr [eax]
                or      dl, dl
                jnz     mdi_AlreadyLoaded
                inc     byte ptr [eax]

;
; Ensure we're running at least version 4.00 of windows.
;

                VMMCall Get_VMM_Version
                cmp     ax, 400h
                jb      mdi_BadKernelVersion

                VxDCall VWIN32_Get_Version
                jc      mdi_VWin32NotPresent

;
; Now we can let the C code finish the initialization. VxdMain()
; will return TRUE if successful, FALSE otherwise.
;

                cCall   _VxdMain, 1
                or      eax, eax
                jz      mdi_InitializationFailure

;
; Initialization complete.
; Note that the carry has already been cleared (NC).
;

                ret


;
; InitializeVxd returned FALSE, indicating an initialization failure.

mdi_InitializationFailure:
ifdef DEBUG
                Debug_Out "My_Device_Init: InitializeVxd failure."
                jmp     mdi_FatalExit
endif   ; DEBUG


;
; VWIN32 VxD not present.
;

mdi_VWin32NotPresent:
ifdef DEBUG
                Debug_Out "My_Device_Init: VWIN32 VxD not present."
                jmp     mdi_FatalExit
endif   ; DEBUG


;
; Incorrect kernel version.
;

mdi_BadKernelVersion:
ifdef DEBUG
                Debug_Out "My_Device_Init: bad kernel version."
                jmp     mdi_FatalExit
endif   ; DEBUG


;
; VxD already loaded
;

mdi_AlreadyLoaded:
ifdef DEBUG
                Debug_Out "My_Device_Init: VxD re-load attempted."
                jmp     mdi_FatalExit
endif   ; DEBUG


;
; Common exit path for all fatal exits.
;

mdi_FatalExit:

                stc
                ret

EndProc         My_Device_Init



;****************************************************************************
;
; Routine Description:
;
;     Performs global driver termination.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (ESI) - Supplies a pointer to any command-line arguments (?).
;
; Return Value:
;
;     (CY) - Termination failed.
;
;     (NC) - Termination completed successfully.
;
;****************************************************************************
BeginProc       My_Device_Exit

;
; VxdMain() will return TRUE if successful, FALSE otherwise.
;

                cCall   _VxdMain, 0
                or      eax, eax
                jz      mde_Failure

                clc
                ret

mde_Failure:
                stc
                ret

EndProc         My_Device_Exit


;****************************************************************************
;
; Routine Description:
;
;     Invoked whenever a user-mode thread is destroyed.
;
; Arguments:
;
;     (EBX) - Supplies the VM handle of the current virtual machine.
;
;     (EBP) - Supplies a pointer to the client register structure.
;
;     (EDI) - Supplies the thread handle of the terminating thread.
;
; Return Value:
;
;     None.
;
;****************************************************************************
BeginProc       My_Destroy_Thread

                cCall   _VxdThreadTermination, <edi>
                ret

EndProc         My_Destroy_Thread



;****************************************************************************
;
; Routine Description:
;
;     Dispatch routine for VXD services invoked via the Win32
;     DeviceIoControl API.
;
; Arguments:
;
;     (ESI) - Supplies a pointer to a DIOCParams structure defining
;         the parameters. See VWIN32.H for the gory details.
;
; Return Value:
;
;     (EAX) - Win32 completion code, -1 for asynchronous completion.
;
;     (ECX) - 0 (DIOC_GETVERSION only).
;
;****************************************************************************
BeginProc       My_DeviceIoControl

;
; Setup stack frame.
;

                push    ebx
                push    esi
                push    edi

                cCall   _VxdDispatch, <esi>
                xor     ecx, ecx

                pop     edi
                pop     esi
                pop     ebx

                ret

EndProc         My_DeviceIoControl



VxD_PAGEABLE_CODE_ENDS



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\win9x\makefile.inc ===
#
# DO NOT EDIT THIS FILE!!!  Edit ..\makefile.inc instead.
#

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\misc.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the miscellaneous UL routines.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"

ULONG   HttpChars[256];


//
// Private prototypes.
//

NTSTATUS
UlpRestartDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

#define FIXUP_PTR( Type, pUserPtr, pKernelPtr, pOffsetPtr, BufferLength )   \
    (Type) ((PUCHAR)(pUserPtr) + DIFF((PUCHAR)(pOffsetPtr) - (PUCHAR)(pKernelPtr)))


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlULongLongToAscii
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Converts the given ULONGLLONG to an ASCII representation and stores it
    in the given string.

Arguments:

    String - Receives the ASCII representation of the ULONGLONG.

    Value - Supplies the ULONGLONG to convert.

Return Value:

    PSTR - Pointer to the next character in String *after* the converted
        ULONGLONG.

--***************************************************************************/
PSTR
UlULongLongToAscii(
    IN PSTR String,
    IN ULONGLONG Value
    )
{
    PSTR p1;
    PSTR p2;
    CHAR ch;
    ULONG digit;

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = '0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = '0' + (CHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = '\0';
    return String;

}   // UlULongLongToAscii

NTSTATUS
_RtlIntegerToUnicode(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG BufferLength,
    OUT PWSTR String
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = L'0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = L'0' + (WCHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = L'\0';

    return STATUS_SUCCESS;

}   // _RtlIntegerToUnicode

/***************************************************************************++

Routine Description:

    Converts an ansi string to an integer.  fails if any non-digit characters
    appears in the string.  fails on negative numbers, and assumes no preceding
    spaces.

Arguments:

    PUCHAR  pString             the string to convert
    ULONG   Base                the base, must be 10 or 16
    PULONG  pValue              the return value of the converted integer

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAnsiToULongLong(
    PUCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ULONGLONG   Value;
    ULONGLONG   NewValue;

    if (Base != 10 && Base != 16)
        RETURN(STATUS_INVALID_PARAMETER);

    //
    // No preceding space, we already skipped it
    //

    ASSERT(IS_HTTP_LWS(pString[0]) == FALSE);

    Value = 0;

    while (pString[0] != ANSI_NULL)
    {
        if (
            (Base == 10 && IS_HTTP_DIGIT(pString[0]) == FALSE) ||
               (Base == 16 && IS_HTTP_HEX(pString[0]) == FALSE)
            )
        {
            //
            // Not valid , bad!
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (Base == 16)
        {
            if (IS_HTTP_ALPHA(pString[0]))
            {
                NewValue = 16 * Value + (UPCASE_CHAR(pString[0]) - 'A' + 10);
            }
            else
            {
                NewValue = 16 * Value + (pString[0] - '0');
            }
        }
        else
        {
            NewValue = 10 * Value + (pString[0] - '0');
        }

        if (NewValue < Value)
        {
            //
            // Very bad... we overflew
            //

            RETURN(STATUS_SECTION_TOO_BIG);
        }

        Value = NewValue;

        pString += 1;
    }

    *pValue = Value;

    return STATUS_SUCCESS;

}   // UlAnsiToULongLong



/***************************************************************************++

Routine Description:

    Converts a unicode string to an integer.  fails if any non-digit characters
    appear in the string.  fails on negative numbers, and assumes no preceding
    spaces.

Arguments:

    PWCHAR  pString             the string to convert
    ULONG   Base                the base, must be 10 or 16
    PULONG  pValue              the return value of the converted integer

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlUnicodeToULongLong(
    PWCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ULONGLONG   Value;
    ULONGLONG   NewValue;

    if (Base != 10 && Base != 16)
        RETURN(STATUS_INVALID_PARAMETER);

    //
    // No preceding space, we already skipped it
    //

    ASSERT(pString[0] < 128 && IS_HTTP_LWS(pString[0]) == FALSE);

    Value = 0;

    while (pString[0] != UNICODE_NULL)
    {
        if ((Base == 10 &&
                (pString[0] >= 128 || IS_HTTP_DIGIT(pString[0]) == FALSE)) ||
            (Base == 16 &&
                (pString[0] >= 128 || IS_HTTP_HEX(pString[0]) == FALSE)))
        {
            //
            // Not valid , bad!
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (Base == 16)
        {
            if (IS_HTTP_ALPHA(pString[0]))
            {
                NewValue = 16 * Value + (pString[0] - L'A' + 10);
            }
            else
            {
                NewValue = 16 * Value + (pString[0] - L'0');
            }
        }
        else
        {
            NewValue = 10 * Value + (pString[0] - L'0');
        }

        if (NewValue < Value)
        {
            //
            // Very bad... we overflew
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        Value = NewValue;

        pString += 1;
    }

    *pValue = Value;

    return STATUS_SUCCESS;

}   // UlUnicodeToULongLong


//
// Private routines.
//


/*++

Routine Description:

    Routine to initialize the utilitu code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeHttpUtil(
    VOID
    )
{
    ULONG i;

    // Initialize the HttpChars array appropriately.

    for (i = 0; i < 128; i++)
    {
        HttpChars[i] = HTTP_CHAR;
    }

    for (i = 'A'; i <= 'Z'; i++)
    {
        HttpChars[i] |= HTTP_UPCASE;
    }

    for (i = 'a'; i <= 'z'; i++)
    {
        HttpChars[i] |= HTTP_LOCASE;
    }

    for (i = '0'; i <= '9'; i++)
    {
        HttpChars[i] |= (HTTP_DIGIT | HTTP_HEX);
    }


    for (i = 0; i <= 31; i++)
    {
        HttpChars[i] |= HTTP_CTL;
    }

    HttpChars[127] |= HTTP_CTL;

    HttpChars[SP] |= HTTP_LWS;
    HttpChars[HT] |= HTTP_LWS;


    for (i = 'A'; i <= 'F'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    for (i = 'a'; i <= 'f'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    HttpChars['('] |= HTTP_SEPERATOR;
    HttpChars[')'] |= HTTP_SEPERATOR;
    HttpChars['<'] |= HTTP_SEPERATOR;
    HttpChars['>'] |= HTTP_SEPERATOR;
    HttpChars['@'] |= HTTP_SEPERATOR;
    HttpChars[','] |= HTTP_SEPERATOR;
    HttpChars[';'] |= HTTP_SEPERATOR;
    HttpChars[':'] |= HTTP_SEPERATOR;
    HttpChars['\\'] |= HTTP_SEPERATOR;
    HttpChars['"'] |= HTTP_SEPERATOR;
    HttpChars['/'] |= HTTP_SEPERATOR;
    HttpChars['['] |= HTTP_SEPERATOR;
    HttpChars[']'] |= HTTP_SEPERATOR;
    HttpChars['?'] |= HTTP_SEPERATOR;
    HttpChars['='] |= HTTP_SEPERATOR;
    HttpChars['{'] |= HTTP_SEPERATOR;
    HttpChars['}'] |= HTTP_SEPERATOR;
    HttpChars[SP] |= HTTP_SEPERATOR;
    HttpChars[HT] |= HTTP_SEPERATOR;


    //
    // URL "reserved" characters (rfc2396)
    //

    HttpChars[';'] |= URL_LEGAL;
    HttpChars['/'] |= URL_LEGAL;
    HttpChars['\\'] |= URL_LEGAL;
    HttpChars['?'] |= URL_LEGAL;
    HttpChars[':'] |= URL_LEGAL;
    HttpChars['@'] |= URL_LEGAL;
    HttpChars['&'] |= URL_LEGAL;
    HttpChars['='] |= URL_LEGAL;
    HttpChars['+'] |= URL_LEGAL;
    HttpChars['$'] |= URL_LEGAL;
    HttpChars[','] |= URL_LEGAL;


    //
    // URL escape character
    //

    HttpChars['%'] |= URL_LEGAL;

    //
    // URL "mark" characters (rfc2396)
    //

    HttpChars['-'] |= URL_LEGAL;
    HttpChars['_'] |= URL_LEGAL;
    HttpChars['.'] |= URL_LEGAL;
    HttpChars['!'] |= URL_LEGAL;
    HttpChars['~'] |= URL_LEGAL;
    HttpChars['*'] |= URL_LEGAL;
    HttpChars['\''] |= URL_LEGAL;
    HttpChars['('] |= URL_LEGAL;
    HttpChars[')'] |= URL_LEGAL;


    for (i = 0; i < 128; i++)
    {
        if (!IS_HTTP_SEPERATOR(i) && !IS_HTTP_CTL(i))
        {
            HttpChars[i] |= HTTP_TOKEN;
        }
    }

    return STATUS_SUCCESS;
}


//
// constants used by the date formatter
//

const PWSTR pDays[] =
{
   L"Sun", L"Mon", L"Tue", L"Wed", L"Thu", L"Fri", L"Sat"
};

const PWSTR pMonths[] =
{
    L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul",
    L"Aug", L"Sep", L"Oct", L"Nov", L"Dec"
};

__inline
VOID
TwoDigitsToUnicode(
    PWSTR pBuffer,
    ULONG Number
    )
{
    pBuffer[0] = L'0' + (WCHAR)(Number / 10);
    pBuffer[1] = L'0' + (WCHAR)(Number % 10);
}


/***************************************************************************++

Routine Description:

    Converts the given system time to string representation containing
    GMT Formatted String.

Arguments:

    pTime - System time that needs to be converted.

    pBuffer - pointer to string which will contain the GMT time on
        successful return.

    BufferLength - size of pszBuff in bytes

Return Value:

    NTSTATUS

History:

     MuraliK        3-Jan-1995
     paulmcd        4-Mar-1999  copied to ul

--***************************************************************************/

NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    )
{
    NTSTATUS Status;

    ASSERT(pBuffer != NULL);

    if (BufferLength < (HTTP_DATE_COUNT + 1)*sizeof(WCHAR))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //                          0         1         2
    //                          01234567890123456789012345678
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    //
    // write the constants
    //

    pBuffer[3] = L',';
    pBuffer[4] = pBuffer[7] = pBuffer[11] = L' ';
    pBuffer[19] = pBuffer[22] = L':';

    //
    // now the variants
    //

    //
    // 0-based Weekday
    //

    RtlCopyMemory(&(pBuffer[0]), pDays[pTime->Weekday], 3*sizeof(WCHAR));

    TwoDigitsToUnicode(&(pBuffer[5]), pTime->Day);

    //
    // 1-based Month
    //

    RtlCopyMemory(&(pBuffer[8]), pMonths[pTime->Month - 1], 3*sizeof(WCHAR)); // 1-based

    Status = _RtlIntegerToUnicode(pTime->Year, 10, 5, &(pBuffer[12]));
    ASSERT(NT_SUCCESS(Status));

    pBuffer[16] = L' ';

    TwoDigitsToUnicode(&(pBuffer[17]), pTime->Hour);
    TwoDigitsToUnicode(&(pBuffer[20]), pTime->Minute);
    TwoDigitsToUnicode(&(pBuffer[23]), pTime->Second);

    RtlCopyMemory(&(pBuffer[25]), L" GMT", sizeof(L" GMT"));

    return STATUS_SUCCESS;

}   // TimeFieldsToHttpDate

ULONG
_MultiByteToWideCharWin9x(
    ULONG uCodePage,
    ULONG dwFlags,
    PCSTR lpMultiByteStr,
    int cchMultiByte,
    PWSTR lpWideCharStr,
    int cchWideChar
    )
{
    int i;

    //
    // simply add a 0 upper byte, it's supposed to be ascii
    //

    for (i = 0; i < cchMultiByte; ++i)
    {
        if (lpMultiByteStr[i] > 128)
        {
            lpWideCharStr[i] = (WCHAR)('_'); // (WCHAR)(DefaultChar);
        }
        else
        {
            lpWideCharStr[i] = (WCHAR)(lpMultiByteStr[i]);
        }
    }

    return (ULONG)(i);

}   // _MultiByteToWideCharWin9x


/******************************************************************************

Routine Description:

    Copy an HTTP request to a buffer.

Arguments:

    pRequest            - Pointer to this request.
    pBuffer             - Pointer to buffer where we'll copy.
    BufferLength        - Length of pBuffer.
    pEntityBody         - Pointer to entity body of request.
    EntityBodyLength    - Length of entity body.

Return Value:


******************************************************************************/

NTSTATUS
UlpHttpRequestToBufferWin9x(
    PUL_INTERNAL_REQUEST    pRequest,
    PUCHAR                  pKernelBuffer,
    ULONG                   BufferLength,
    PUCHAR                  pEntityBody,
    ULONG                   EntityBodyLength,
    ULONG					ulLocalIPAddress,
    USHORT					ulLocalPort,
    ULONG					ulRemoteIPAddress,
    USHORT					ulRemotePort
    )
{
    PHTTP_REQUEST               pHttpRequest;
    PHTTP_UNKNOWN_HEADER        pUserCurrentUnknownHeader;
    PUCHAR                      pCurrentBufferPtr;
    ULONG                       i;
    ULONG                       BytesCopied;
    ULONG                       HeaderCount = 0;
    PVOID                       pUserBuffer;
    PHTTP_NETWORK_ADDRESS_IPV4  pLocalAddress;
    PHTTP_NETWORK_ADDRESS_IPV4  pRemoteAddress;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_HTTP_REQUEST(pRequest));
    ASSERT(pKernelBuffer != NULL);
    ASSERT(BufferLength > sizeof(HTTP_REQUEST));

	// BUGBUG - this is used for the pointer fixups
	//          don't know what you want to set this to
	// MAUROOT - NULL should be ok.
	
    pUserBuffer = NULL;

    //
    // wipe it clean
    //

    RtlZeroMemory( pKernelBuffer, sizeof(HTTP_REQUEST) );

    //
    // Set up our pointers to the HTTP_REQUEST structure, the
    // header arrays we're going to fill in, and the pointer to
    // where we're going to start filling them in.
    //
    // CODEWORK: Make this transport independent.
    //

    pHttpRequest = (PHTTP_REQUEST)pKernelBuffer;

    pLocalAddress = (PHTTP_NETWORK_ADDRESS_IPV4)( pHttpRequest + 1 );
    pRemoteAddress = pLocalAddress + 1;

    pUserCurrentUnknownHeader = (PHTTP_UNKNOWN_HEADER)( pRemoteAddress + 1 );

    pCurrentBufferPtr = (PUCHAR)(pUserCurrentUnknownHeader +
                                 pRequest->UnknownHeaderCount);

    //
    // Now fill in the HTTP request structure.
    //

    pHttpRequest->ConnectionId  = pRequest->ConnectionId;
    pHttpRequest->RequestId     = pRequest->RequestId;

	// BUGBUG - Don't know where you'll come up with this
	//    pHttpRequest->UrlContext    = pRequest->pConfigGroup->UrlContext;
	// MAUROOT - NULL should be ok.
	pHttpRequest->UrlContext = 0;

    pHttpRequest->Version       = pRequest->Version;
    pHttpRequest->Verb          = pRequest->Verb;
    pHttpRequest->Reason        = pRequest->Reason;


    pHttpRequest->Address.RemoteAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pHttpRequest->Address.RemoteAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pHttpRequest->Address.pRemoteAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pRemoteAddress,
                                        BufferLength
                                        );

    pRemoteAddress->IpAddress = SWAP_LONG( ulRemoteIPAddress );
    pRemoteAddress->Port = SWAP_SHORT( ulRemotePort );


    pHttpRequest->Address.LocalAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pHttpRequest->Address.LocalAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pHttpRequest->Address.pLocalAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pLocalAddress,
                                        BufferLength
                                        );

    pLocalAddress->IpAddress = SWAP_LONG( ulLocalIPAddress );
    pLocalAddress->Port = SWAP_SHORT( ulLocalPort );

    //
    // any raw verb?
    //

    if (pRequest->Verb == HttpVerbUnknown)
    {
        //
        // Need to copy in the raw verb for the client.
        //

        ASSERT(pRequest->RawVerbLength <= 0x7fff);

        pHttpRequest->UnknownVerbLength = (USHORT)(pRequest->RawVerbLength * sizeof(CHAR));
        pHttpRequest->pUnknownVerb = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pKernelBuffer,
                                            pCurrentBufferPtr,
                                            BufferLength
                                            );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pRequest->pRawVerb,
            pRequest->RawVerbLength
            );
    
        pCurrentBufferPtr += pRequest->RawVerbLength;

        //
        // terminate it
        //

        ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);
    }

    //
    // copy the raw url
    //

    ASSERT(pRequest->RawUrl.Length <= 0x7fff);

    pHttpRequest->RawUrlLength = (USHORT)(pRequest->RawUrl.Length * sizeof(CHAR));
    pHttpRequest->pRawUrl = FIXUP_PTR(
                                PSTR,
                                pUserBuffer,
                                pKernelBuffer,
                                pCurrentBufferPtr,
                                BufferLength
                                );

    RtlCopyMemory(
        pCurrentBufferPtr,
        pRequest->RawUrl.pUrl,
        pRequest->RawUrl.Length
        );

    pCurrentBufferPtr += pRequest->RawUrl.Length;

    //
    // terminate it
    //

    ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
    pCurrentBufferPtr += sizeof(CHAR);

    //
    // and now the cooked url sections
    //

    //
    // make sure they are valid
    //

    ASSERT(pRequest->CookedUrl.pUrl != NULL);
    ASSERT(pRequest->CookedUrl.pHost != NULL);
    ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

    //
    // do the full url
    //

    ASSERT(pRequest->CookedUrl.Length <= 0xffff);

    pHttpRequest->CookedUrl.FullUrlLength = (USHORT)(pRequest->CookedUrl.Length);
    pHttpRequest->CookedUrl.pFullUrl = FIXUP_PTR(
                                    PWSTR,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pCurrentBufferPtr,
                                    BufferLength
                                    );

    //
    // and the host
    //

    pHttpRequest->CookedUrl.HostLength = DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pHost)
                                    * sizeof(WCHAR);

    pHttpRequest->CookedUrl.pHost = pHttpRequest->CookedUrl.pFullUrl +
                                DIFF(pRequest->CookedUrl.pHost - pRequest->CookedUrl.pUrl);

    //
    // is there a query string?
    //

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pHttpRequest->CookedUrl.AbsPathLength = DIFF(pRequest->CookedUrl.pQueryString -
                                        pRequest->CookedUrl.pAbsPath) * sizeof(WCHAR);

        pHttpRequest->CookedUrl.pAbsPath = pHttpRequest->CookedUrl.pHost +
                                    (pHttpRequest->CookedUrl.HostLength / sizeof(WCHAR));

        pHttpRequest->CookedUrl.QueryStringLength = (USHORT)(pRequest->CookedUrl.Length) - (
                                            DIFF(
                                                pRequest->CookedUrl.pQueryString -
                                                pRequest->CookedUrl.pUrl
                                                ) * sizeof(WCHAR)
                                            );

        pHttpRequest->CookedUrl.pQueryString = pHttpRequest->CookedUrl.pAbsPath +
                                        (pHttpRequest->CookedUrl.AbsPathLength / sizeof(WCHAR));
    }
    else
    {
        pHttpRequest->CookedUrl.AbsPathLength = (USHORT)(pRequest->CookedUrl.Length) - (
                                        DIFF(
                                            pRequest->CookedUrl.pAbsPath -
                                            pRequest->CookedUrl.pUrl
                                            ) * sizeof(WCHAR)
                                        );

        pHttpRequest->CookedUrl.pAbsPath = pHttpRequest->CookedUrl.pHost +
                                    (pHttpRequest->CookedUrl.HostLength / sizeof(WCHAR));

        pHttpRequest->CookedUrl.QueryStringLength = 0;
        pHttpRequest->CookedUrl.pQueryString = NULL;
    }

    //
    // copy the full url
    //

    RtlCopyMemory(
        pCurrentBufferPtr,
        pRequest->CookedUrl.pUrl,
        pRequest->CookedUrl.Length
        );

    pCurrentBufferPtr += pRequest->CookedUrl.Length;

    //
    // terminate it
    //

    ((PWSTR)pCurrentBufferPtr)[0] = UNICODE_NULL;
    pCurrentBufferPtr += sizeof(WCHAR);


    //
    // no entity body, CODEWORK.
    //

    if (pRequest->ContentLength > 0 || pRequest->Chunked == 1)
    {
        pHttpRequest->MoreEntityBodyExists = 1;
    }
    else
    {
        pHttpRequest->MoreEntityBodyExists = 0;
    }

    pHttpRequest->EntityChunkCount = 0;
    pHttpRequest->pEntityChunks = NULL;

    //
    // Copy in the known headers.
    //
    // Loop through the known header array in the HTTP connection,
    // and copy any that we have.
    //

    for (i = 0; i < HttpHeaderRequestMaximum; i++)
    {
        if (pRequest->Headers[i].Valid == 1)
        {
            //
            // Have a header here we need to copy in.
            //

            ASSERT(pRequest->Headers[i].HeaderLength <= 0x7fff);

            //
            // ok for HeaderLength to be 0 .  we will give usermode a pointer
            // pointing to a NULL string.  RawValueLength will be 0.
            //

            pHttpRequest->Headers.pKnownHeaders[i].RawValueLength =
                (USHORT)(pRequest->Headers[i].HeaderLength * sizeof(CHAR));

            pHttpRequest->Headers.pKnownHeaders[i].pRawValue =
                FIXUP_PTR(
                    PSTR,
                    pUserBuffer,
                    pKernelBuffer,
                    pCurrentBufferPtr,
                    BufferLength
                    );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pRequest->Headers[i].pHeader,
                pRequest->Headers[i].HeaderLength
                );

            pCurrentBufferPtr += pRequest->Headers[i].HeaderLength;

            //
            // terminate it
            //

            ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);

        }
        else
        {
            pHttpRequest->Headers.pKnownHeaders[i].RawValueLength = 0;
            pHttpRequest->Headers.pKnownHeaders[i].pRawValue = NULL;
        }
    }

    //
    // Now loop through the unknown headers, and copy them in.
    //

    pHttpRequest->Headers.UnknownHeaderCount = pRequest->UnknownHeaderCount;

    if (pRequest->UnknownHeaderCount == 0)
    {
        pHttpRequest->Headers.pUnknownHeaders = NULL;
    }
    else
    {
        pHttpRequest->Headers.pUnknownHeaders =
            FIXUP_PTR(
                PHTTP_UNKNOWN_HEADER,
                pUserBuffer,
                pKernelBuffer,
                pUserCurrentUnknownHeader,
                BufferLength
                );
    }

    while (!IsListEmpty(&pRequest->UnknownHeaderList))
    {
        PUL_HTTP_UNKNOWN_HEADER     pUnknownHeader;
        PLIST_ENTRY                 pListEntry;

        pListEntry = RemoveHeadList(&pRequest->UnknownHeaderList);
        pListEntry->Flink = pListEntry->Blink = NULL;

        pUnknownHeader = CONTAINING_RECORD(
                                pListEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );

        HeaderCount++;
        ASSERT(HeaderCount <= pRequest->UnknownHeaderCount);

        //
        // First copy in the header name.
        //

        pUserCurrentUnknownHeader->NameLength = (USHORT)
            pUnknownHeader->HeaderNameLength * sizeof(CHAR);

        pUserCurrentUnknownHeader->pName =
            FIXUP_PTR(
                PSTR,
                pUserBuffer,
                pKernelBuffer,
                pCurrentBufferPtr,
                BufferLength
                );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pUnknownHeader->pHeaderName,
            pUnknownHeader->HeaderNameLength
            );

        pCurrentBufferPtr += pUnknownHeader->HeaderNameLength;

        //
        // terminate it
        //

        ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);

        //
        // Now copy in the header value.
        //

        ASSERT(pUnknownHeader->HeaderValue.HeaderLength <= 0x7fff);

        if (pUnknownHeader->HeaderValue.HeaderLength == 0)
        {
            pUserCurrentUnknownHeader->RawValueLength = 0;
            pUserCurrentUnknownHeader->pRawValue = NULL;
        }
        else
        {

            pUserCurrentUnknownHeader->RawValueLength =
                (USHORT)(pUnknownHeader->HeaderValue.HeaderLength * sizeof(CHAR));

            pUserCurrentUnknownHeader->pRawValue =
                FIXUP_PTR(
                    PSTR,
                    pUserBuffer,
                    pKernelBuffer,
                    pCurrentBufferPtr,
                    BufferLength
                    );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pUnknownHeader->HeaderValue.pHeader,
                pUnknownHeader->HeaderValue.HeaderLength
                );

            pCurrentBufferPtr += pUnknownHeader->HeaderValue.HeaderLength;

            //
            // terminate it
            //

            ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);

        }

        //
        // skip to the next header
        //

        pUserCurrentUnknownHeader++;

        //
        // Free the unknown header structure now, as well as the pointer
        // (if needed).
        //

        if (pUnknownHeader->HeaderValue.OurBuffer == 1)
        {
            UL_FREE_POOL(
                pUnknownHeader->HeaderValue.pHeader,
                UL_KNOWN_HEADER_POOL_TAG
                );

            pUnknownHeader->HeaderValue.OurBuffer = 0;
        }

        UL_FREE_POOL( pUnknownHeader, UL_UNKNOWN_HEADER_POOL_TAG );
    }

    //
    // no more unknown headers exist
    //

    pRequest->UnknownHeaderCount = 0;

    //
    // Make sure we didn't use too much
    //

    ASSERT(DIFF(pCurrentBufferPtr - pKernelBuffer) <= BufferLength);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\kdebug.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug-specific declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG

//
// Initialization/termination functions.
//

VOID
UlDbgInitializeDebugData(
    VOID
    );

VOID
UlDbgTerminateDebugData(
    VOID
    );

//
// Driver entry/exit notifications.
//

VOID
UlDbgEnterDriver(
    IN PSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgLeaveDriver(
    IN PSTR pFunctionName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_ENTER_DRIVER( function, pirp )                                   \
    UlDbgEnterDriver(                                                       \
        (function),                                                         \
        (pirp),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_LEAVE_DRIVER( function )                                         \
    UlDbgLeaveDriver(                                                       \
        (function),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// An instrumented resource.
//

#define MAX_RESOURCE_NAME_LENGTH    64

typedef struct _UL_ERESOURCE
{
    //
    // The actual resource.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    ERESOURCE Resource;

    //
    // Links onto the global resource list.
    //

    LIST_ENTRY GlobalResourceListEntry;

    //
    // Pointer to the thread that owns this lock exclusively.
    //

    PETHREAD pExclusiveOwner;

    //
    // Statistics.
    //

    LONG ExclusiveCount;
    LONG SharedCount;
    LONG ReleaseCount;

    //
    // The name of the resource, for display purposes.
    //

    UCHAR ResourceName[MAX_RESOURCE_NAME_LENGTH];

} UL_ERESOURCE, *PUL_ERESOURCE;

NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    );

BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    );

#define UlInitializeResource( resource, name, param )                       \
    UlDbgInitializeResource(                                                \
        (resource),                                                         \
        (name),                                                             \
        (ULONG_PTR)(param),                                                 \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlDeleteResource( resource )                                        \
    UlDbgDeleteResource(                                                    \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceExclusive( resource, wait )                        \
    UlDbgAcquireResourceExclusive(                                          \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceShared( resource, wait )                           \
    UlDbgAcquireResourceShared(                                             \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseResource( resource )                                       \
    UlDbgReleaseResource(                                                   \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->Resource.SystemResourcesList.Flink != NULL)


//
// An instrumented spinlock.
//

typedef struct _UL_SPIN_LOCK    // SpinLock
{
    //
    // The actual lock.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    KSPIN_LOCK KSpinLock;

    //
    // The name of the spinlock, for display purposes.
    //

    PSTR pSpinLockName;

    //
    // Pointer to the thread that owns this lock.
    //

    PETHREAD pOwnerThread;

    //
    // Statistics.
    //

    PSTR pLastAcquireFileName;
    PSTR pLastReleaseFileName;
    USHORT LastAcquireLineNumber;
    USHORT LastReleaseLineNumber;
    ULONG OwnerProcessor;
    LONG Acquisitions;
    LONG Releases;
    LONG AcquisitionsAtDpcLevel;
    LONG ReleasesFromDpcLevel;
    LONG Spare;

} UL_SPIN_LOCK, *PUL_SPIN_LOCK;

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock )                               \
    &((pLock)->KSpinLock)

VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pSpinLockName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    );

BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    );

#define UlInitializeSpinLock( spinlock, name )                              \
    UlDbgInitializeSpinLock(                                                \
        (spinlock),                                                         \
        (name),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    UlDbgAcquireSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    UlDbgReleaseSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    UlDbgAcquireSpinLockAtDpcLevel(                                         \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    UlDbgReleaseSpinLockFromDpcLevel(                                       \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// Debug spew control.
// If you change or add a flag, please update the FlagTable
// in ul\test\dll\tul.c.
//

#undef IF_DEBUG
#define IF_DEBUG(a) if ( (UL_DEBUG_ ## a & g_UlDebug) != 0 )

#define UL_DEBUG_OPEN_CLOSE                 0x00000001
#define UL_DEBUG_SEND_RESPONSE              0x00000002
#define UL_DEBUG_SEND_BUFFER                0x00000004
#define UL_DEBUG_TDI                        0x00000008

#define UL_DEBUG_FILE_CACHE                 0x00000010
#define UL_DEBUG_CONFIG_GROUP_FNC           0x00000020
#define UL_DEBUG_CONFIG_GROUP_TREE          0x00000040
#define UL_DEBUG_REFCOUNT                   0x00000080

#define UL_DEBUG_HTTP_IO                    0x00000100
#define UL_DEBUG_ROUTING                    0x00000200
#define UL_DEBUG_URI_CACHE                  0x00000400
#define UL_DEBUG_PARSER                     0x00000800

#define UL_DEBUG_SITE                       0x00001000
#define UL_DEBUG_WORK_ITEM                  0x00002000

#define UL_DEBUG_PARSER2                    0x80000000

#define DEBUG


//
// Tracing.
//

#define UlTrace(a, _b_)                                                     \
    do                                                                      \
    {                                                                       \
        IF_DEBUG(##a)                                                       \
        {                                                                   \
            DbgPrint _b_ ;                                                  \
        }                                                                   \
    } while (FALSE)


//
// Debug pool allocator.
//

PVOID
UlDbgAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreePool (
    IN PVOID pPointer,
    IN ULONG Tag
    );

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    UlDbgAllocatePool(                                                      \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    UlDbgFreePool(                                                          \
        (ptr),                                                              \
        (tag)                                                               \
        )

//
// Exception filter.
//

LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_EXCEPTION_FILTER()                                               \
    UlDbgExceptionFilter(                                                   \
        GetExceptionInformation(),                                          \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )


//
// Invalid completion routine for catching incomplete IRP contexts.
//

VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Error handlers.
//

NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define RETURN(status)                                                      \
    return UlDbgStatus(                                                     \
                (status),                                                   \
                __FILE__,                                                   \
                __LINE__                                                    \
                )

#define CHECK_STATUS(status)                                                \
    UlDbgStatus(                                                            \
        (status),                                                           \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

//
// Random structure dumpers.
//

VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PSTR pName
    );

VOID
UlDbgDumpHttpConnection(
    IN struct _HTTP_CONNECTION *pConnection,
    IN PSTR pName
    );


//
// IO wrappers.
//

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateIrp( stack, quota )                                       \
    UlDbgAllocateIrp(                                                       \
        (stack),                                                            \
        (quota),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeIrp( pirp )                                                   \
    UlDbgFreeIrp(                                                           \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCallDriver( pdevice, pirp )                                       \
    UlDbgCallDriver(                                                        \
        (pdevice),                                                          \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCompleteRequest( pirp, boost )                                    \
    UlDbgCompleteRequest(                                                   \
        (pirp),                                                             \
        (boost),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#else   // !DBG

//
// Disable all of the above.
//

#define UL_ENTER_DRIVER( function, pirp )
#define UL_LEAVE_DRIVER( function )

#define UL_ERESOURCE ERESOURCE
#define PUL_ERESOURCE PERESOURCE

#define UlInitializeResource( resource, name, param )                       \
    ExInitializeResource( (resource) )

#define UlDeleteResource( resource )                                        \
    ExDeleteResource( (resource) )

#define UlAcquireResourceExclusive( resource, wait )                        \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusive( (resource), (wait) );                   \
    } while (FALSE)

#define UlAcquireResourceShared( resource, wait )                           \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceShared( (resource), (wait) );                      \
    } while (FALSE)

#define UlReleaseResource( resource )                                       \
    do                                                                      \
    {                                                                       \
        ExReleaseResource( (resource) );                                    \
        KeLeaveCriticalRegion();                                            \
    } while (FALSE)

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->SystemResourcesList.Flink != NULL)

#define UL_SPIN_LOCK KSPIN_LOCK
#define PUL_SPIN_LOCK PKSPIN_LOCK

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock ) (pLock)

#define UlInitializeSpinLock( spinlock, name )                              \
    KeInitializeSpinLock( (spinlock) )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    KeAcquireSpinLock( (spinlock), (oldirql) )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    KeReleaseSpinLock( (spinlock), (oldirql) )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    KeAcquireSpinLockAtDpcLevel( (spinlock) )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    KeReleaseSpinLockFromDpcLevel( (spinlock) )

#undef IF_DEBUG
#define IF_DEBUG(a) if (FALSE)
#define DEBUG if ( FALSE )

#define UlTrace(a, _b_)

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    ExAllocatePoolWithTag(                                                  \
        (type),                                                             \
        (len),                                                              \
        (tag)                                                               \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    MyFreePoolWithTag(                                                      \
        (ptr),                                                              \
        (tag)                                                               \
        )

#define UL_EXCEPTION_FILTER() EXCEPTION_EXECUTE_HANDLER

#define RETURN(status) return (status)
#define CHECK_STATUS(Status)

#define UlAllocateIrp( stack, quota )                                       \
    IoAllocateIrp( (stack), (quota) )

#define UlFreeIrp( pirp )                                                   \
    IoFreeIrp( (pirp) )

#define UlCallDriver( pdevice, pirp )                                       \
    IoCallDriver( (pdevice), (pirp) )

#define UlCompleteRequest( pirp, boost )                                    \
    IoCompleteRequest( (pirp), (boost) )

#endif  // DBG

// BUGBUG: ALIGN_UP(PVOID) won't work, it needs to be the type of the first entry of the
// following data (paulmcd 4/29/99)

#define UL_ALLOCATE_STRUCT_WITH_SPACE(pt,ot,cb,t)   \
    (ot *)(UL_ALLOCATE_POOL(pt,ALIGN_UP(sizeof(ot),PVOID)+(cb),t))

#define UL_ALLOCATE_STRUCT(pt,ot,t)                 \
    (ot *)(UL_ALLOCATE_POOL(pt,sizeof(ot),t))

#define UL_ALLOCATE_ARRAY(pt,et,c,t)                \
    (et *)(UL_ALLOCATE_POOL(pt,sizeof(et)*(c),t))

#define UL_FREE_POOL_WITH_SIG(a,t)                  \
    do {                                            \
        (a)->Signature = MAKE_FREE_TAG(t);          \
        UL_FREE_POOL(a,t);                          \
        (a) = NULL;                                 \
    } while (0)

#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\httptypes.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    httptypes.h

Abstract:

    The definition of HTTP specific types

Author:

    Henry Sanders (henrysa)     July-1998 started

Revision History:

    Paul McDaniel (paulmcd)     3-March-1999 massive updates / rewrite

--*/


#ifndef _HTTPTYPES_H_
#define _HTTPTYPES_H_

#define VERSION_SIZE            (sizeof("HTTP/1.1") - 1)

//
// the largest name that can fit as an knownheader (3 ULONGLONG's)
//
#define MAX_KNOWN_HEADER_SIZE   24

#define CR          0x0D
#define LF          0x0A
#define SP          0x20
#define HT          0x09

#define CRLF_SIZE   2
#define CRLF        0x0A0D          // Reversed for endian switch
#define LFLF        0x0A0A

#define UPCASE_CHAR(c)  ((c) & 0xdf)

#define MAX_PORT_LENGTH     5  // 2^16 = 65536 = 5 chars = 5 bytes

//
//                         255  .  255  .  255  .  255  :   port
//
#define MAX_ADDRESS_LENGTH  3 + 1 + 3 + 1 + 3 + 1 + 3 + 1 + MAX_PORT_LENGTH

#define HTTP_DATE_COUNT 29

//
// Response constants
//


//
// parser error returns, these need to match the order of
// UL_HTTP_ERROR_ENTRY ErrorTable[] in httprcv.c
//

typedef enum _UL_HTTP_ERROR
{
    UlError,
    UlErrorVerb,
    UlErrorUrl,
    UlErrorHeader,
    UlErrorHost,
    UlErrorCRLF,
    UlErrorNum,
    UlErrorVersion,
    UlErrorUnavailable,
    UlErrorNotFound,
    UlErrorContentLength,
    UlErrorEntityTooLarge,
    UlErrorNotImplemented

} UL_HTTP_ERROR;


//
// The enum type for our parse state.
//
// note:  the order of the enum values are important as code
// uses < and > operators for comparison. keep the order the exact
// order the parse moves through.
//

typedef enum _PARSE_STATE
{
    ParseVerbState,
    ParseUrlState,
    ParseVersionState,
    ParseHeadersState,
    ParseCookState,
    ParseEntityBodyState,
    ParseTrailerState,

    ParseDoneState,
    ParseErrorState

} PARSE_STATE, *PPARSE_STATE;

//
// Structure we use for tracking headers from incoming requests. The pointer
// points into a buffer we received from the transport, unless the OurBuffer
// flag is set, which indicates we had to allocate a buffer and copy the header
// due to multiple occurences of the header or a continuation line.
//
typedef struct _UL_HTTP_HEADER
{
    PUCHAR      pHeader;

    ULONG       HeaderLength;

    ULONG       OurBuffer:1;
    ULONG       Valid:1;
    ULONG       Encoded:1;

} UL_HTTP_HEADER, *PUL_HTTP_HEADER;

//
// Structure we use for tracking unknown headers. These structures are
// dyanmically allocated when we see an unknown header.
//
typedef struct _UL_HTTP_UNKNOWN_HEADER
{
    LIST_ENTRY      List;
    ULONG           HeaderNameLength;
    PUCHAR          pHeaderName;
    UL_HTTP_HEADER  HeaderValue;

} UL_HTTP_UNKNOWN_HEADER, *PUL_HTTP_UNKNOWN_HEADER;

//
// forward delcarations
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;


//
// Structure we use for a copy of the data from the transport's buffer.
//

#define IS_VALID_REQUEST_BUFFER(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_REQUEST_BUFFER_POOL_TAG))

#define GET_REQUEST_BUFFER_POS(pRequestBuffer) \
    (pRequestBuffer->pBuffer + pRequestBuffer->ParsedBytes)

#define UNPARSED_BUFFER_BYTES(pRequestBuffer) \
    (pRequestBuffer->UsedBytes - pRequestBuffer->ParsedBytes)

typedef struct _UL_REQUEST_BUFFER
{
    //
    // NonPagedPool
    //

    //
    // UL_REQUEST_BUFFER_POOL_TAG
    //
    ULONG               Signature;

    //
    // for linking on the pConnection->BufferHead
    //
    LIST_ENTRY          ListEntry;

    //
    // the connection
    //
    PUL_HTTP_CONNECTION    pConnection;

    //
    // for queue'ing
    //
    UL_WORK_ITEM        WorkItem;

    //
    // how many bytes are stored
    //
    ULONG               UsedBytes;

    //
    // how many bytes are allocated from the pool
    //
    ULONG               AllocBytes;

    //
    // how many bytes have been consumed by the parser
    //
    ULONG               ParsedBytes;

    //
    // the sequence number
    //
    ULONG               BufferNumber;

    //
    // whether or not this was specially allocated (for large requests)
    //
    ULONG               JumboBuffer : 1;

    //
    // the actual buffer space (inline)
    //
    UCHAR               pBuffer[0];

} UL_REQUEST_BUFFER, *PUL_REQUEST_BUFFER;

//
// Structure used for tracking an HTTP connection, which may represent
// either a real TCP connection or a virtual MUX connection.
//

#define IS_VALID_HTTP_CONNECTION(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == HTTP_CONNECTION_POOL_TAG) && ((pObject)->RefCount > 0))

typedef struct _HTTP_CONNECTION
{

    //
    // NonPagedPool
    //

    //
    // HTTP_CONNECTION_POOL_TAG
    //
    ULONG               Signature;

    //
    // Opaque ID for this connection.
    //
    HTTP_CONNECTION_ID  ConnectionId;

    //
    // to perform the destructor at lower irql
    //
    UL_WORK_ITEM        WorkItem;

    //
    // Reference count of this connection.
    //
    LONG                RefCount;

    //
    // sequence number for the next HTTP_REQUEST that comes in.
    //
    ULONG               NextRecvNumber;

    //
    // sequence number for the next buffer received from TDI
    //
    ULONG               NextBufferNumber;

    //
    // sequence number for the next buffer to parse
    //
    ULONG               NextBufferToParse;

    //
    // Associated TDI connection
    //
    PUL_CONNECTION      pConnection;

    //
    // The current request being parsed
    //
    PUL_INTERNAL_REQUEST       pRequest;

    //
    // to synchro UlpHandleRequest
    //
    UL_ERESOURCE        Resource;

    //
    // links all buffered transport packets
    //
    LIST_ENTRY          BufferHead;

    //
    // links to app pool process binding structures
    //
    LIST_ENTRY          BindingHead;

    //
    // the current buffer (from BufferHead) that we are parsing
    //
    PUL_REQUEST_BUFFER  pCurrentBuffer;

    //
    // set if a protocol token span buffers
    //
    ULONG               NeedMoreData : 1;

    //
    // set if the ul connection has been destroyed
    //
    ULONG               UlconnDestroyed : 1;

    //
    // set if we have dispatched a request and
    // are now waiting for the response
    //
    ULONG               WaitingForResponse : 1;

    //
    // Spinlock used to protect the following IRP list and disconnect flag.
    //

    UL_SPIN_LOCK DisconnectSpinLock;

    //
    // List of pending "wait for disconnect" IRPs.
    //

    LIST_ENTRY WaitForDisconnectIrpListHead;

    //
    // Flag set after the underlying network connection has been
    // disconnected.
    //

    BOOLEAN DisconnectFlag;

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} HTTP_CONNECTION, *PHTTP_CONNECTION;


//
// forward decl for cgroup.h which is not included yet
//

typedef struct _UL_URL_CONFIG_GROUP_INFO *PUL_URL_CONFIG_GROUP_INFO;


#define IS_VALID_HTTP_REQUEST(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_INTERNAL_REQUEST_POOL_TAG) && ((pObject)->RefCount > 0))

typedef struct _UL_INTERNAL_REQUEST
{

    //
    // NonPagedPool
    //

    //
    // HTTP_REQUEST_POOL_TAG
    //
    ULONG               Signature;

    //
    // Reference count
    //
    LONG                RefCount;

    //
    // Opaque ID for this object
    //
    HTTP_REQUEST_ID  RequestId;

    //
    // Opaque ID for the connection
    //
    HTTP_CONNECTION_ID ConnectionId;

    //
    // The connection (soft-link)
    //
    PUL_HTTP_CONNECTION    pHttpConn;

    //
    // A work item, used to queue processing
    //
    UL_WORK_ITEM        WorkItem;

    //
    // the resource for the app pool we queue the request on,
    // null if not queued
    //
    PUL_NONPAGED_RESOURCE pAppPoolResource;

    //
    // to queue it on the app pool
    //
    LIST_ENTRY          AppPoolEntry;

    //
    // points to the cgroup info (OPTIONAL)
    //
    PUL_URL_CONFIG_GROUP_INFO pConfigGroup;

    //
    // this request's sequence number on the connection
    //
    ULONG               RecvNumber;

    //
    // Current state of our parsing effort.
    //
    PARSE_STATE         ParseState;

    //
    // If there was an error parsing the code is put here.
    // ParseState is set to ParseErrorState
    //
    UL_HTTP_ERROR       ErrorCode;

    //
    // Total bytes needed for this request, includes string terminators
    //
    ULONG               TotalRequestSize;

    //
    // Number of 'unknown' headers we have.
    //
    ULONG               UnknownHeaderCount;

    //
    // Verb of this request.
    //
    HTTP_VERB        Verb;

    //
    // Pointer to raw verb, valid if Verb == UnknownVerb.
    //
    PUCHAR              pRawVerb;

    //
    // byte length of pRawVerb.
    //
    ULONG               RawVerbLength;

    struct
    {

        //
        // The raw URL.
        //
        PUCHAR          pUrl;

        //
        // the below 2 pointers point into RawUrl.pUrl
        //

        //
        // host part (OPTIONAL)
        //
        PUCHAR          pHost;
        //
        // points to the abs_path part
        //
        PUCHAR          pAbsPath;

        //
        //
        //

        //
        // The byte length of the RawUrl.pUrl.
        //
        ULONG           Length;

    } RawUrl;

    struct
    {

        //
        // The canonicalized, fully qualified URL.
        //
        PWSTR           pUrl;

        //
        // the below 3 pointers point into CookedUrl.pUrl
        //

        //
        // points to the host part
        //
        PWSTR           pHost;
        //
        // points to the abs_path part
        //
        PWSTR           pAbsPath;
        //
        // points to the query string (OPTIONAL)
        //
        PWSTR           pQueryString;

        //
        //
        //

        //
        // the byte length of CookedUrl.pUrl
        //
        ULONG           Length;
        //
        // the hash of CookedUrl.pUrl
        //
        ULONG           Hash;

    } CookedUrl;

    //
    // HTTP Version of current request.
    //
    HTTP_VERSION     Version;

    //
    // Array of known headers.
    //
    UL_HTTP_HEADER      Headers[HttpHeaderRequestMaximum];


    //
    // List of headers we don't know about.
    //
    LIST_ENTRY          UnknownHeaderList;

    //
    // The reason the driver didn't serve the response (CacheMiss?)
    //
    HTTP_REQUEST_REASON   Reason;

    //
    // the content length (OPTIONAL)
    //
    ULONGLONG           ContentLength;

    //
    // How many bytes are left to parse in the current chunk
    // (probably in pCurrentBuffer)
    //
    ULONGLONG           ChunkBytesToParse;

    //
    // How many bytes TOTAL were parsed
    //
    ULONGLONG           ChunkBytesParsed;

    //
    // How many bytes are left in pChunkBuffer (the current chunk)
    // for reading by user mode
    //
    ULONGLONG           ChunkBytesToRead;

    //
    // How many TOTAL bytes have been read by user mode
    //
    ULONGLONG           ChunkBytesRead;


    //
    // is this chunk-encoded?
    //
    ULONG               Chunked:1;

    //
    // parsed the first chunk?
    //
    ULONG               ParsedFirstChunk:1;

    //
    // has a response has been sent
    //
    ULONG               SentResponse:1;

    //
    // points to the buffer where protocol header data started.
    //
    PUL_REQUEST_BUFFER  pHeaderBuffer;

    //
    // the last buffer containing header data
    //
    PUL_REQUEST_BUFFER  pLastHeaderBuffer;


    //
    // CODEWORK:  we might be able to use the connection resource for
    // synchronizing access
    //


    //
    // to protect the below 2 lists
    //
    UL_ERESOURCE        Resource;

    //
    // a list of IRP(s) trying to read entity body
    //
    LIST_ENTRY          IrpHead;

    //
    // points to the buffer where we are reading/parsing body chunk(s)
    //
    PUL_REQUEST_BUFFER  pChunkBuffer;

    //
    // the current location we are reading body chunk from, points into
    // pChunkBuffer
    //
    PUCHAR              pChunkLocation;

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} UL_INTERNAL_REQUEST, *PUL_INTERNAL_REQUEST;


#endif // _HTTPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\win9x\src\vxd\i386\vxdmain.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    vxdmain.c

Abstract:

    This module implements a VXD.

Author:

    Keith Moore (keithmo)			03-Aug-1999

Revision History:

    Mauro Ottaviani (mauroot)       26-Aug-1999

	- Implemented support for ul.sys funtionality under Win9x

    Mauro Ottaviani (mauroot)       21-Jan-1999

	- Major rearchitecture in order to support an API closer to the one
	  in ul.sys. This will make the implementation of the managed API simpler
	  and will allow more code sharing, basically:
	  introduction of AppPools and support for the Request/Response model.


CODEWORK:
	use more detailed values to be set in
	Overlapped.Internal for async error returning

--*/

#pragma intrinsic( memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen )

// don't switch order for these two #includes
#include <precompvxd.h>
#include <vxdinfo.h>

#include <string.h>

#define MIN(a,b) ( ((a) > (b)) ? (b) : (a) )
#define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )

#define UL_VXD_UNLOADED		0
#define UL_VXD_LOADED		1

#define UL_PROCESS_HANDLE	0
#define UL_THREAD_HANDLE	1


//
// fix DBG that might be screwed up by some ntos.h
//

#ifdef DBG

#if DBG
#undef DBG
#define DBG
#else // #ifdef DBG
#undef DBG
#endif // #ifdef DBG

#endif

//
// debug defines
//

#ifdef DBG

#define VXD_ASSERT(exp)			if (!(exp)) VXD_PRINTF(( "\n*** Assertion failed: %s\n*** Source file %s, line %lu\n\n", (#exp), (__FILE__), ((DWORD) __LINE__  ) ))
#define VXD_PRINTF(exp)			VxdPrintf exp
#define BREAKPOINT 				{ _asm int 03h }
#define VAL(pV) 				(((pV)==NULL)?-1:*(pV))

#else // #ifdef DBG

#define VXD_ASSERT(exp)
#define VXD_PRINTF(exp)
#define BREAKPOINT
#define VAL(pV)

#endif // #ifdef DBG

//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//

#pragma VxD_PAGEABLE_DATA_SEG

LIST_ENTRY
	GlobalProcessListRoot,
	GlobalUriListRoot;

UL_HTTP_REQUEST_ID
	RequestIdNext;

HANDLE
	GlobalhProcess = NULL,
	GlobalhThread = NULL;


//
// Public functions.
//

#pragma VxD_PAGEABLE_CODE_SEG



/***************************************************************************++

Routine Description:

	Returns the ring0 handle to a ring3 event.
	
Arguments:

	hEvent: the ring3 event handle.
	
Return Value:

	the ring0 event handle.
	
--***************************************************************************/

__inline HANDLE
__cdecl
UlVWIN32OpenVxDHandle(
	HANDLE hEvent )
{
	PVOID hr0Event;

	//
	// the VWIN32OpenVxDHandle() call will thrash ecx, so I'll save it myself
	//

	{ _asm push ecx };
	
	hr0Event = VWIN32OpenVxDHandle( (ULONG) hEvent, OPENVXD_TYPE_EVENT );

	//
	// and restore it
	//

	{ _asm pop ecx };

	return (HANDLE) hr0Event;

} // UlVWIN32OpenVxDHandle


/***************************************************************************++

Routine Description:

	Used only for debugging purpouses, dumps all the IRP/INFO.
	
Arguments:

	None.
	
Return Value:

	None.
	
--***************************************************************************/

__inline VOID
__cdecl
UlDumpIrpInfo(
	PUL_IRP_LIST pIrp
	)
{
	VXD_PRINTF(( "pIrp->List = %08X\n", pIrp->List ));
	VXD_PRINTF(( "pIrp->hProcess = %08X\n", pIrp->hProcess ));
	VXD_PRINTF(( "pIrp->hThread = %08X\n", pIrp->hThread ));
	VXD_PRINTF(( "pIrp->hr0Event = %08X\n", pIrp->hr0Event ));
	VXD_PRINTF(( "pIrp->pRequestId = %08X[%016X]\n", pIrp->pRequestId, VAL(pIrp->pRequestId) ));
	VXD_PRINTF(( "pIrp->pData = %08X\n", pIrp->pData ));
	VXD_PRINTF(( "pIrp->ulBytesToTransfer = %d\n", pIrp->ulBytesToTransfer ));
	VXD_PRINTF(( "pIrp->ulBytesTransferred = %d\n", pIrp->ulBytesTransferred ));
	VXD_PRINTF(( "pIrp->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pIrp->pOverlapped,
		pIrp->pOverlapped->Internal,
		pIrp->pOverlapped->InternalHigh,
		pIrp->pOverlapped->Offset,
		pIrp->pOverlapped->OffsetHigh,
		pIrp->pOverlapped->hEvent ));

	return;
}




/***************************************************************************++

Routine Description:

	Used only for debugging purpouses, dumps all the URI/INFO info on the
	processees currently using the device driver.
	
Arguments:

	None.
	
Return Value:

	None.
	
--***************************************************************************/

__inline VOID
__cdecl
UlDumpProcessInfo(
	VOID
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList,
		*pRequestIrpList, *pResponseIrpList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;
	PUL_IRP_LIST pRequestIrp, pResponseIrp;

	VXD_PRINTF(( "UlDumpProcessInfo()\n" ));

	pProcessList = GlobalProcessListRoot.Flink;

	while ( pProcessList != &GlobalProcessListRoot )
	{
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		pProcessList = pProcessList->Flink;

		VXD_PRINTF(( "(Dump) pProcess:%08X hProcess:%08X hAppPoolNext:%08X\n", pProcess, pProcess->hProcess, pProcess->hAppPoolNext ));

		pAppPoolList = pProcess->AppPoolList.Flink;

		while ( pAppPoolList != &pProcess->AppPoolList )
		{
		    pAppPool =
		    CONTAINING_RECORD(
				pAppPoolList,
				UL_APPPOOL_LIST,
				List );

			pAppPoolList = pAppPoolList->Flink;

			VXD_PRINTF(( "(Dump) +-+ pAppPool:%08X hAppPool:%08X\n", pAppPool, pAppPool->hAppPool ));

			pUriList = pAppPool->UriList.Flink;
			pRequestList = pAppPool->RequestList.Flink;

			while ( pUriList != &pAppPool->UriList )
			{
			    pUri =
			    CONTAINING_RECORD(
					pUriList,
					UL_URI_LIST,
					List );

				pUriList = pUriList->Flink;

				VXD_PRINTF(( "(Dump)   +-+ pUri:%08X ulUriId:%08X pUri:%d:[%S]\n", pUri, pUri->ulUriId, pUri->ulUriLength, pUri->pUri ));
			}

			while ( pRequestList != &pAppPool->RequestList )
			{
			    pRequest =
			    CONTAINING_RECORD(
					pRequestList,
					UL_REQUEST_LIST,
					List );

				pRequestList = pRequestList->Flink;

				VXD_PRINTF(( "(Dump)   +-+ pRequest:%08X RequestId:%016X ulUriId:%08X", pRequest, pRequest->RequestId, pRequest->ulUriId ));
				VXD_PRINTF(( " QHS:%1X", pRequest->ulRequestHeadersSent ));
				VXD_PRINTF(( " QIT:%1X", pRequest->ulRequestIrpType ));
				VXD_PRINTF(( " SHS:%1X", pRequest->ulResponseHeadersSent ));
				VXD_PRINTF(( " SIT:%1X", pRequest->ulResponseIrpType ));
				VXD_PRINTF(( "\n" ));

				pRequestIrpList = pRequest->RequestIrpList.Flink;
				pResponseIrpList = pRequest->ResponseIrpList.Flink;

				while ( pRequestIrpList != &pRequest->RequestIrpList )
				{
				    pRequestIrp =
				    CONTAINING_RECORD(
						pRequestIrpList,
						UL_IRP_LIST,
						List );

					pRequestIrpList = pRequestIrpList->Flink;

					VXD_PRINTF(( "(Dump)     +-+ pRequestIrpList:%08X hProcess:%08X hThread:%08X hr0Event:%08X\n", pRequestIrpList, pRequestIrp->hProcess, pRequestIrp->hThread, pRequestIrp->hr0Event ));
				}

				while ( pResponseIrpList != &pRequest->ResponseIrpList )
				{
				    pResponseIrp =
				    CONTAINING_RECORD(
						pResponseIrpList,
						UL_IRP_LIST,
						List );

					pResponseIrpList = pResponseIrpList->Flink;

					VXD_PRINTF(( "(Dump)     +-+ pResponseIrpList:%08X hProcess:%08X hThread:%08X hr0Event:%08X\n", pResponseIrpList, pResponseIrp->hProcess, pResponseIrp->hThread, pResponseIrp->hr0Event ));
				}
			}
		}
	}

	return;
}




/***************************************************************************++

Routine Description:

    Find the pointer to the PUL_PROCESS_LIST structure containing information
    on a Process, the handle to the process.
    
Arguments:

	hProcess: the handle to the process.
	
Return Value:

	PUL_PROCESS_LIST - The pointer to the UL_PROCESS_LIST structure,
		NULL otherwise.

--***************************************************************************/

__inline PLIST_ENTRY
UlFindProcessInfo(
	HANDLE hProcess
	)
{
	LIST_ENTRY *pProcessList;
	PUL_PROCESS_LIST pProcess;

	VXD_PRINTF(( " UlFindProcessInfo() hProcess:%08X\n", hProcess ));

	pProcessList = GlobalProcessListRoot.Flink;

	while ( pProcessList != &GlobalProcessListRoot )
	{
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		if ( pProcess->hProcess == hProcess )
		{
			VXD_PRINTF(( "pProcessList found, returning %08X\n", pProcessList ));
			
			return pProcessList;
		}

		pProcessList = pProcessList->Flink;
	}

	VXD_PRINTF(( "pProcessList NOT found, returning NULL\n" ));

	return NULL;
}




/***************************************************************************++

Routine Description:

    Find the pointer to the PUL_REQUEST_LIST structure containing information
    on a Request, given a pointer pAppPool to a UL_APPPOOL_LIST structure as
    created by UlCreateAppPool and a RequestId.
    
Arguments:

	pAppPool: the pointer to the AppPool
	RequestId: the RequestId
	
Return Value:

	PUL_URI_LIST - The pointer to the UL_URI_LIST structure,
		NULL otherwise.

--***************************************************************************/

__inline PLIST_ENTRY
UlFindRequestInfoByAppPoolAndRequestId(
	PUL_APPPOOL_LIST pAppPool,
	UL_HTTP_REQUEST_ID RequestId
	)
{
	LIST_ENTRY *pAppPoolList, *pRequestList;
	PUL_REQUEST_LIST pRequest;

	VXD_PRINTF(( "UlFindRequestInfoByRequestId() pAppPool:%08X RequestId:%016X\n", pAppPool, RequestId ));

	if ( pAppPool != NULL )
	{
		// I know in which AppPool to look for

		pRequestList = pAppPool->RequestList.Flink;

		while ( pRequestList != &pAppPool->RequestList )
		{
		    pRequest =
		    CONTAINING_RECORD(
				pRequestList,
				UL_REQUEST_LIST,
				List );

			if ( RequestId == pRequest->RequestId )
			{
				VXD_PRINTF(( "pRequestList found, returning %08X\n", pRequestList ));

				return pRequestList;
			}

			pRequestList = pRequestList->Flink;
		}
	}

	VXD_PRINTF(( "pRequestList NOT found, returning NULL\n" ));

	return NULL;
}




/***************************************************************************++

Routine Description:

    Find the pointer to the PUL_REQUEST_LIST structure containing information
    on a Request, given a (OPTIONAL) pointer pAppPool to a UL_APPPOOL_LIST
    structure as created by UlCreateAppPool and a RequestId.

    CODEWORK:
    make this more performant the basic idea is to hide some opaque pointer
    to the UL_REQUEST_LIST structure in the RequestId.
    
Arguments:

	pAppPool: the pointer to the AppPool (if known)
	RequestId: the RequestId
	
Return Value:

	PUL_URI_LIST - The pointer to the UL_URI_LIST structure,
		NULL otherwise.

--***************************************************************************/

__inline PLIST_ENTRY
UlFindRequestInfoByRequestId(
	UL_HTTP_REQUEST_ID RequestId
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;
	PUL_PROCESS_LIST pProcess;

	pProcessList = GlobalProcessListRoot.Flink;

	while ( pProcessList != &GlobalProcessListRoot )
	{
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		pProcessList = pProcessList->Flink;

		pAppPoolList = pProcess->AppPoolList.Flink;

		while ( pAppPoolList != &pProcess->AppPoolList )
		{
		    pAppPool =
		    CONTAINING_RECORD(
				pAppPoolList,
				UL_APPPOOL_LIST,
				List );

			pAppPoolList = pAppPoolList->Flink;

			if ( ( pRequestList = UlFindRequestInfoByAppPoolAndRequestId( pAppPool, RequestId ) ) != NULL )
			{
				VXD_PRINTF(( "pRequestList found, returning %08X\n", pRequestList ));
				
				return pRequestList;
			}
		}
	}

	VXD_PRINTF(( "pRequestList NOT found, returning NULL\n" ));

	return NULL;
}




/***************************************************************************++

Routine Description:

    Find the pointer to the PUL_URI_LIST structure containing information
    on a Uri, given a Uri handle as returned by UlRegisterUri.
    
Arguments:

	hUri: the Uri handle as returned by UlRegisterUri
	
Return Value:

	PUL_URI_LIST - The pointer to the UL_URI_LIST structure,
		NULL otherwise.

--***************************************************************************/

__inline PLIST_ENTRY
UlFindAppPoolInfoByHandle(
	HANDLE hAppPool
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;

	VXD_PRINTF(( "UlFindAppPoolInfoByHandle() hAppPool:%08X\n", hAppPool ));

	// The handle to the Uri has to be owned by the current process!.

	pProcessList = UlFindProcessInfo( GlobalhProcess );

	if ( !IsListEmpty( pProcessList ) )
	{
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		pAppPoolList = pProcess->AppPoolList.Flink;

		while ( pAppPoolList != &pProcess->AppPoolList )
		{
		    pAppPool =
		    CONTAINING_RECORD(
				pAppPoolList,
				UL_APPPOOL_LIST,
				List );

			if ( hAppPool == pAppPool->hAppPool )
			{
				VXD_PRINTF(( "pAppPoolList found, returning %08X\n", pAppPoolList ));
				
				return pAppPoolList;
			}

			pAppPoolList = pAppPoolList->Flink;
		}
	}

	VXD_PRINTF(( "pAppPoolList NOT found, returning NULL\n" ));

	return NULL;
}




/***************************************************************************++

Routine Description:

    Find the pointer to the PUL_URI_LIST structure containing information
    on a Uri, given a string containing the Uri.
    
Arguments:

	pTargetUri: pointer to a null terminated lowercase UNICODE string.
	ulUriLength: length of the Uri string.

Return Value:

	PUL_URI_LIST - The pointer to the UL_URI_LIST structure,
		NULL otherwise.

--***************************************************************************/

__inline PLIST_ENTRY
UlFindUriInfoByUri(
	WCHAR* pTargetUri,
	ULONG ulUriLength
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pUriList, *pSavedUriList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;
	PUL_URI_LIST pUri;

	ULONG ulMax = 0;
	int wResult;

	VXD_PRINTF(( "UlFindUriInfoByUri() pTargetUri:%08X[%S]\n", pTargetUri, pTargetUri ));

	pSavedUriList = NULL;

	pProcessList = GlobalProcessListRoot.Flink;

	while ( pProcessList != &GlobalProcessListRoot )
	{
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		pAppPoolList = pProcess->AppPoolList.Flink;

		while ( pAppPoolList != &pProcess->AppPoolList )
		{
		    pAppPool =
		    CONTAINING_RECORD(
				pAppPoolList,
				UL_APPPOOL_LIST,
				List );

			pUriList = pAppPool->UriList.Flink;

			while ( pUriList != &pAppPool->UriList )
			{
			    pUri =
			    CONTAINING_RECORD(
					pUriList,
					UL_URI_LIST,
					List );

				if ( pUri->ulUriLength > ulMax && pUri->ulUriLength <= ulUriLength )
				{
					// Prefix matching would be '<=', but I need to order to do LONGEST prefix matching.
					// I assume that the URIs are already lower-cased by user mode

					wResult = memcmp( pTargetUri, pUri->pUri, pUri->ulUriLength * sizeof(WCHAR) );

					VXD_PRINTF(( "(UlFindUriInfoByUri) Comparing %S to %S (%d) returns %d\n", pTargetUri, pUri->pUri, pUri->ulUriLength, wResult ));

					if ( wResult == 0 )
					{
						ulMax = pUri->ulUriLength;

						pSavedUriList = pUriList;

						break;
					}
					else if ( wResult > 0 )
					{
						break;
					}
				}

				pUriList = pUriList->Flink;
			}

			pAppPoolList = pAppPoolList->Flink;
		}

		pProcessList = pProcessList->Flink;
	}

	VXD_PRINTF(( "returning pSavedUriList:%08X\n", pSavedUriList ));

	return pSavedUriList;
}




/***************************************************************************++

Routine Description:

    Clean-up pending I/O, unlock the memory, set the events and free
    the memory.
    
Arguments:

    pIrp - Pointer to the UL_IRP_LIST structure to be cleand-up.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupIrp(
	UL_IRP_LIST *pIrp,
	ULONG ulStatus
	)
{
	BOOL bOK;
	
	VXD_PRINTF(( "UlCleanupIrp() pIrp:%08X\n", pIrp ));

	if ( pIrp != NULL )
	{
		if ( pIrp->ulBytesToTransfer != 0 )
		{
			// Unlock the Data Buffer memory

			VXD_PRINTF(( "(UlCleanupIrp) Unlocking %d bytes starting from %08X\n", pIrp->ulBytesToTransfer, pIrp->pData ));

			VxdUnlockBuffer( pIrp->pData, pIrp->ulBytesToTransfer );
		}

		// Signal the Event in the Overlapped Structure.
		// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever fail.
		// there's not much to do if it fails anyway...

		VXD_PRINTF(( "(UlCleanupIrp) Setting hEvent %08X\n", pIrp->hr0Event ));

		bOK = VxdSetAndCloseWin32Event( (PVOID) pIrp->hr0Event );
		VXD_ASSERT( bOK == TRUE );

		//
		// Update and unlock the memory containing the information on the OVERLAPPED structure
		//

		pIrp->pOverlapped->InternalHigh = pIrp->ulBytesTransferred;
		pIrp->pOverlapped->Internal = ulStatus;

		VXD_PRINTF(( "(UlCleanupIrp) Unlocking Overlapped = %08X (%d,%d,%d,%d,%08X)\n",
			pIrp->pOverlapped,
			pIrp->pOverlapped->Internal,
			pIrp->pOverlapped->InternalHigh,
			pIrp->pOverlapped->Offset,
			pIrp->pOverlapped->OffsetHigh,
			pIrp->pOverlapped->hEvent ));

		VxdUnlockBuffer( (PVOID) pIrp->pOverlapped, sizeof(OVERLAPPED) );

		// Free the memory allocated for the IRP

		VxdFreeMem( pIrp, 0L );
	}

	return;
}




/***************************************************************************++

Routine Description:

    Clean-up Uri information and cancel all pending I/Os.
    
Arguments:

    pUri - Pointer to the UL_URI_LIST structure to be cleand-up.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupRequest(
	UL_REQUEST_LIST *pRequest
	)
{
	LIST_ENTRY *pRequestIrpList, *pResponseIrpList;
	PUL_IRP_LIST pRequestIrp, pResponseIrp;

	VXD_PRINTF(( "UlCleanupRequest() pRequest:%08X\n", pRequest ));

	if ( pRequest != NULL )
	{
		pRequestIrpList = pRequest->RequestIrpList.Flink;
		pResponseIrpList = pRequest->ResponseIrpList.Flink;

		while ( pRequestIrpList != &pRequest->RequestIrpList )
		{
		    pRequestIrp =
		    CONTAINING_RECORD(
				pRequestIrpList,
				UL_IRP_LIST,
				List );

			pRequestIrpList = pRequestIrpList->Flink;

			RemoveEntryList( &pRequestIrp->List );

			UlCleanupIrp( pRequestIrp, ERROR_CANCELLED );
		}

		while ( pResponseIrpList != &pRequest->ResponseIrpList )
		{
		    pResponseIrp =
		    CONTAINING_RECORD(
				pResponseIrpList,
				UL_IRP_LIST,
				List );

			pResponseIrpList = pResponseIrpList->Flink;

			RemoveEntryList( &pResponseIrp->List );

			UlCleanupIrp( pResponseIrp, ERROR_CANCELLED );
		}

		VxdFreeMem( pRequest, 0L );
	}

	return;
}




/***************************************************************************++

Routine Description:

    Clean-up pending I/Os for a Process or a Thread.
    
Arguments:

    pProcess - Pointer to the UL_PROCESS_LIST structure to be cleand-up.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupUri(
	PUL_URI_LIST pUri
	)
{
	VXD_PRINTF(( "UlCleanupUri() pUri:%08X\n", pUri ));

    if ( pUri != NULL )
    {
		VxdFreeMem( pUri, 0L );
	}

	return;
}




/***************************************************************************++

Routine Description:

    Clean-up Uri information and cancel all pending I/Os.
    
Arguments:

    pUri - Pointer to the UL_URI_LIST structure to be cleand-up.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupAppPool(
	PUL_APPPOOL_LIST pAppPool
	)
{
	LIST_ENTRY *pRequestList, *pUriList;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;

	VXD_PRINTF(( "UlCleanupAppPool() pAppPool:%08X\n", pAppPool ));

	if ( pAppPool != NULL )
	{
		pUriList = pAppPool->UriList.Flink;
		pRequestList = pAppPool->RequestList.Flink;

		while ( pUriList != &pAppPool->UriList )
		{
		    pUri =
		    CONTAINING_RECORD(
				pUriList,
				UL_URI_LIST,
				List );

			pUriList = pUriList->Flink;

			RemoveEntryList( &pUri->List );
			RemoveEntryList( &pUri->GlobalList );

			UlCleanupUri( pUri );
		}

		while ( pRequestList != &pAppPool->RequestList )
		{
		    pRequest =
		    CONTAINING_RECORD(
				pRequestList,
				UL_REQUEST_LIST,
				List );

			pRequestList = pRequestList->Flink;

			RemoveEntryList( &pRequest->List );

			UlCleanupRequest( pRequest );
		}

		VxdFreeMem( pAppPool, 0L );
	}

	return;
}




/***************************************************************************++

Routine Description:

    Clean-up Uri information and cancel all pending I/Os.
    
Arguments:

    pUri - Pointer to the UL_URI_LIST structure to be cleand-up.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupByUriId(
	LIST_ENTRY *pAppPoolList,
	ULONG ulUriId
	)
{
	LIST_ENTRY *pRequestList, *pUriList, *pRequestIrpList, *pResponseIrpList;
	PUL_APPPOOL_LIST pAppPool;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;
	PUL_IRP_LIST pRequestIrp, pResponseIrp;

	VXD_PRINTF(( "UlCleanupByUriId() pAppPoolList:%08X ulUriId:%08X\n", pAppPoolList, ulUriId ));

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	pUriList = pAppPool->UriList.Flink;
	pRequestList = pAppPool->RequestList.Flink;

	while ( pUriList != &pAppPool->UriList )
	{
	    pUri =
	    CONTAINING_RECORD(
			pUriList,
			UL_URI_LIST,
			List );

		pUriList = pUriList->Flink;

		if ( ulUriId == UL_CLEAN_ALL || ulUriId == pUri->ulUriId )
		{
			RemoveEntryList( &pUri->List );

			VxdFreeMem( pUri, 0L );
		}
	}

	while ( pRequestList != &pAppPool->RequestList )
	{
	    pRequest =
	    CONTAINING_RECORD(
			pRequestList,
			UL_REQUEST_LIST,
			List );

		pRequestList = pRequestList->Flink;

		if ( ulUriId == pRequest->ulUriId )
		{
			pRequestIrpList = pRequest->RequestIrpList.Flink;
			pResponseIrpList = pRequest->ResponseIrpList.Flink;

			while ( pRequestIrpList != &pRequest->RequestIrpList )
			{
			    pRequestIrp =
			    CONTAINING_RECORD(
					pRequestIrpList,
					UL_IRP_LIST,
					List );

				pRequestIrpList = pRequestIrpList->Flink;

				RemoveEntryList( &pRequestIrp->List );

				UlCleanupIrp( pRequestIrp, ERROR_CANCELLED );
			}

			while ( pResponseIrpList != &pRequest->ResponseIrpList )
			{
			    pResponseIrp =
			    CONTAINING_RECORD(
					pResponseIrpList,
					UL_IRP_LIST,
					List );

				pResponseIrpList = pResponseIrpList->Flink;

				RemoveEntryList( &pResponseIrp->List );

				UlCleanupIrp( pResponseIrp, ERROR_CANCELLED );
			}

			RemoveEntryList( &pRequest->List );

			VxdFreeMem( pRequest, 0L );
		}
	}

	return;
}




/***************************************************************************++

Routine Description:

    Clean-up pending I/Os for a Process or a Thread.
    
Arguments:

    hHandle - Supplies the handle to the Process or Thread.

	bType - hHandle handle type:
        UL_PROCESS_HANDLE:  Process
        UL_THREAD_HANDLE:   Thread

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupIrpsByHandle(
	HANDLE hHandle,
	ULONG bType
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList, *pRequestIrpList, *pResponseIrpList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;
	PUL_IRP_LIST pRequestIrp, pResponseIrp;

	VXD_PRINTF(( "UlCleanupIrpsByHandle() hHandle:%08X\n", hHandle ));

	if ( bType == UL_PROCESS_HANDLE || bType == UL_THREAD_HANDLE )
	{
		pProcessList = GlobalProcessListRoot.Flink;

		while ( pProcessList != &GlobalProcessListRoot )
		{
		    pProcess =
		    CONTAINING_RECORD(
				pProcessList,
				UL_PROCESS_LIST,
				List );

			pProcessList = pProcessList->Flink;

			pAppPoolList = pProcess->AppPoolList.Flink;

			while ( pAppPoolList != &pProcess->AppPoolList )
			{
			    pAppPool =
			    CONTAINING_RECORD(
					pAppPoolList,
					UL_APPPOOL_LIST,
					List );

				pAppPoolList = pAppPoolList->Flink;

				pUriList = pAppPool->UriList.Flink;
				pRequestList = pAppPool->RequestList.Flink;

				while ( pUriList != &pAppPool->UriList )
				{
				    pUri =
				    CONTAINING_RECORD(
						pUriList,
						UL_URI_LIST,
						List );

					pUriList = pUriList->Flink;
				}

				while ( pRequestList != &pAppPool->RequestList )
				{
				    pRequest =
				    CONTAINING_RECORD(
						pRequestList,
						UL_REQUEST_LIST,
						List );

					pRequestList = pRequestList->Flink;

					pRequestIrpList = pRequest->RequestIrpList.Flink;
					pResponseIrpList = pRequest->ResponseIrpList.Flink;

					while ( pRequestIrpList != &pRequest->RequestIrpList )
					{
					    pRequestIrp =
					    CONTAINING_RECORD(
							pRequestIrpList,
							UL_IRP_LIST,
							List );

						pRequestIrpList = pRequestIrpList->Flink;

						if ( hHandle == ( bType==UL_PROCESS_HANDLE ? pRequestIrp->hProcess : pRequestIrp->hThread ) )
						{
							RemoveEntryList( &pRequestIrp->List );

							UlCleanupIrp( pRequestIrp, ERROR_CANCELLED );
						}
					}

					while ( pResponseIrpList != &pRequest->ResponseIrpList )
					{
					    pResponseIrp =
					    CONTAINING_RECORD(
							pResponseIrpList,
							UL_IRP_LIST,
							List );

						pResponseIrpList = pResponseIrpList->Flink;

						if ( hHandle == ( bType==UL_PROCESS_HANDLE ? pResponseIrp->hProcess : pResponseIrp->hThread ) )
						{
							RemoveEntryList( &pResponseIrp->List );

							UlCleanupIrp( pResponseIrp, ERROR_CANCELLED );
						}
					}
				}
			}
		}
	}

	return;
}



/***************************************************************************++

Routine Description:

    Clean-up pending I/Os for a Process or a Thread, cleans:
    	all pended IRPs for other processes
    
Arguments:

    pProcess - pointer to UL_PROCESS_LIST record

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupProcessInfo(
	PUL_PROCESS_LIST pProcess
	)
{
	LIST_ENTRY *pAppPoolList, *pRequestList, *pUriList;
	PUL_APPPOOL_LIST pAppPool;
	PUL_URI_LIST pUri;

	VXD_PRINTF(( "UlCleanupProcessInfo() pProcess:%08X\n", pProcess ));

    if ( pProcess != NULL )
    {
		pAppPoolList = pProcess->AppPoolList.Flink;

		while ( pAppPoolList != &pProcess->AppPoolList )
		{
		    pAppPool =
		    CONTAINING_RECORD(
				pAppPoolList,
				UL_APPPOOL_LIST,
				List );

			pAppPoolList = pAppPoolList->Flink;

			RemoveEntryList( &pAppPool->List );

			UlCleanupAppPool( pAppPool );
		}

		UlCleanupIrpsByHandle( pProcess->hProcess, UL_PROCESS_HANDLE );

		VxdFreeMem( pProcess, 0L );
	}

	return;
}


/***************************************************************************++

Routine Description:

    Clean-up after a process, cleans:
    	all AppPools
    	all Uris
    	all Requests
    	the UL_PROCESS_LIST record.
    
Arguments:

    hProcess - Supplies the handle to the Process.

Return Value:

    None.

--***************************************************************************/

__inline VOID
__cdecl
UlCleanupProcessInfoByHandle(
    IN HANDLE hProcess
    )
{
	LIST_ENTRY *pProcessList;
	PUL_PROCESS_LIST pProcess;

	VXD_PRINTF(( "UlCleanupProcessInfoByHandle() hProcess:%08X\n", hProcess ));

	// Find the pProcess RECORD and clean-up
	// cleans all the IRPs QUEUEs URIs APPPOOLs and the ProcessInfo)

	pProcessList = UlFindProcessInfo( hProcess );

    if ( pProcessList != NULL )
    {
	    pProcess =
	    CONTAINING_RECORD(
			pProcessList,
			UL_PROCESS_LIST,
			List );

		VXD_PRINTF(( "pProcess:%08X\n", pProcess ));

		RemoveEntryList( pProcessList );

		UlCleanupProcessInfo( pProcess );
	}

	return;
}




/***************************************************************************++

Routine Description:

    Performs global VXD initialization/termination.

Arguments:

    Reason - Supplies a reason code for the initialization/termination:

         0 - The VXD is being unloaded.
         1 - The VXD is being loaded.

Return Value:

    1 on success 0 on error

--***************************************************************************/

ULONG
__cdecl
VxdMain(
    IN ULONG Reason
    )
{
	VXD_PRINTF(( "VxdMain() Reason:%d\n", Reason ));
	
	if ( Reason == UL_VXD_LOADED ) // The VXD is being loaded.
	{
		InitializeListHead( &GlobalProcessListRoot );
		InitializeListHead( &GlobalUriListRoot );
		RequestIdNext = 1;

		return 1;
	}
	else if ( Reason == UL_VXD_UNLOADED ) // The VXD is being unloaded.
	{
		if ( !IsListEmpty( &GlobalProcessListRoot ) || !IsListEmpty( &GlobalUriListRoot ) ) // Should NEVER occur - There's records in memory
		{
			VXD_PRINTF(( "Should NEVER occur - There's records in memory - &GlobalProcessListRoot:%08X &GlobalUriListRoot:%08X\n", &GlobalProcessListRoot, &GlobalUriListRoot ));
			return 0;
		}

		return 1;
	}

	// Should NEVER occur - invalid Reason

	VXD_PRINTF(( "Should NEVER occur - VxdMain() called with invalid Reason = %u\n", Reason ));

    return 0;

}   // VxdMain




/***************************************************************************++

Routine Description:

    Notification that a user-mode thread is being destroyed.

Arguments:

    hThread - Supplies the ring-0 handle of the thread being destroyed.

Return Value:

    None.

--***************************************************************************/

VOID
__cdecl
VxdThreadTermination(
    IN HANDLE hThread
    )
{
	VXD_PRINTF(( "VxdThreadTermination() hThread:%08X\n", hThread ));

	UlCleanupIrpsByHandle( hThread, UL_THREAD_HANDLE );
	
	return;

}   // VxdThreadTermination




/***************************************************************************++

Routine Description:

    Performs kernel mode UlInitialize().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlInitialize(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pProcessList;
	PUL_PROCESS_LIST pProcess;

	VXD_PRINTF(( "VxdUlInitialize() pParameters:%08X\n", pParameters ));

	/*
	VXD_PRINTF(( "pParameters->lpvInBuffer = %08X\n", pParameters->lpvInBuffer ));
	VXD_PRINTF(( "pParameters->lpvOutBuffer = %08X\n", pParameters->lpvOutBuffer ));
	VXD_PRINTF(( "FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED = %08X\n", FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED ));

	if ( pParameters->cbInBuffer != 0 || pParameters->cbOutBuffer != 0 || pParameters->lpcbBytesReturned != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}
	*/

	// CODEWORK: we may want to add some flag validation
	// to see how the driver gets loaded (from ulapi.c):

	// hDevice =
	//	 CreateFileA(
	//		 "\\\\.\\" VXD_NAME,
	//		 0,
	//		 0,
	//		 NULL,
	//		 0,
	//		 FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_OVERLAPPED,
	//		 NULL );

	pProcessList = UlFindProcessInfo( GlobalhProcess );

	if ( pProcessList != NULL )
	{
		VXD_PRINTF(( "VxdUlInitialize() was already called\n" ));
		return UL_ERROR_NOT_READY;
	}

	pProcess = ( PUL_PROCESS_LIST ) VxdAllocMem( sizeof( UL_PROCESS_LIST ), 0L );
	if ( pProcess == NULL )
	{
		VXD_PRINTF(( "Error allocating memory\n" ));
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	VXD_PRINTF(( "New pProcess created in %08X\n", pProcess ));

    InsertTailList( &GlobalProcessListRoot, &pProcess->List );
	InitializeListHead( &pProcess->AppPoolList );
	pProcess->hProcess = GlobalhProcess;
	pProcess->hAppPoolNext = (HANDLE)1;

	return UL_ERROR_SUCCESS;
}




/***************************************************************************++

Routine Description:

    Performs kernel mode UlTerminate().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlTerminate(
    IN PDIOCPARAMETERS pParameters
    )
{
	VXD_PRINTF(( "VxdUlTerminate() pParameters:%08X\n", pParameters ));
	
	UlCleanupProcessInfoByHandle( GlobalhProcess );

	return UL_ERROR_SUCCESS;
}




/***************************************************************************++

Routine Description:

    Performs kernel mode UlCreateAppPool().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlCreateAppPool(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pProcessList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE *phAppPoolHandle = (HANDLE*) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pParameters->cbInBuffer != sizeof(HANDLE) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( phAppPoolHandle == NULL || VxdValidateBuffer( phAppPoolHandle, sizeof(HANDLE) ) == NULL )
	{
		VXD_PRINTF(( "Invalid input data:%08X\n", phAppPoolHandle ));
		return UL_ERROR_INVALID_DATA;
	}

	*phAppPoolHandle = (HANDLE) INVALID_HANDLE_VALUE;

	pProcessList = UlFindProcessInfo( GlobalhProcess );

	if ( pProcessList == NULL )
	{
		VXD_PRINTF(( "VxdUlInitialize() wasn't called\n" ));
		return UL_ERROR_NOT_READY;
	}

    pProcess =
    CONTAINING_RECORD(
		pProcessList,
		UL_PROCESS_LIST,
		List );

	pAppPool = ( PUL_APPPOOL_LIST ) VxdAllocMem( sizeof( UL_APPPOOL_LIST ), 0L );
	if ( pAppPool == NULL )
	{
		VXD_PRINTF(( "Error allocating memory\n" ));
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	VXD_PRINTF(( "New pAppPool created in %08X\n", pAppPool ));

	// CODEWORK: try some optimization hiding data in RequestId that can
	// possibly optimize access to the right UL_REQUEST_LIST structure in
	// O(1) constant time.
	// ((ULARGE_INTEGER*)&pAppPool->RequestIdNext)->HighPart = (ULONG) pAppPool;
	// ((ULARGE_INTEGER*)&pAppPool->RequestIdNext)->LowPart = 0;

    InsertTailList( &pProcess->AppPoolList, &pAppPool->List );
	InitializeListHead( &pAppPool->UriList );
	InitializeListHead( &pAppPool->RequestList );
	pAppPool->hAppPool = *phAppPoolHandle = (HANDLE)(((ULONG) pProcess->hAppPoolNext)++);
	pAppPool->ulUriIdNext = 1;
	
	return UL_ERROR_SUCCESS;

} // VxdUlCreateAppPool




/***************************************************************************++

Routine Description:

    Performs kernel mode UlCloseAppPool().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlCloseAppPool(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pAppPoolList;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE *phAppPoolHandle = (HANDLE*) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pParameters->cbInBuffer != sizeof(HANDLE) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( phAppPoolHandle == NULL || VxdValidateBuffer( phAppPoolHandle, sizeof(HANDLE) ) == NULL )
	{
		VXD_PRINTF(( "Invalid input data:%08X\n", phAppPoolHandle ));
		return UL_ERROR_INVALID_DATA;
	}

	pAppPoolList = UlFindAppPoolInfoByHandle( *phAppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	pAppPoolList = pAppPoolList->Flink;

	RemoveEntryList( &pAppPool->List );

	UlCleanupAppPool( pAppPool );
	
	return UL_ERROR_SUCCESS;

} // VxdUlCloseAppPool




/***************************************************************************++

Routine Description:

    Performs kernel mode UlRegisterUri().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlRegisterUri(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pSavedUriList, *pGlobalUriList,
		*pSavedAppPoolList;
	PUL_PROCESS_LIST pProcess;
	PUL_APPPOOL_LIST pAppPool;
	PUL_URI_LIST pGUri, pUri;

	int wResult, wSameSize, wSizeToCompare;
	ULONG ulBytesToAllocate, ulBytesToCopy, ulBytesCopied;
	BOOL bOK;
	PWSTR pLockedUri = NULL;

	PIN_IOCTL_UL_REGISTER_URI pInIoctl = ( PIN_IOCTL_UL_REGISTER_URI ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->ulSize != sizeof( IN_IOCTL_UL_REGISTER_URI ) || pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_REGISTER_URI ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_REGISTER_URI ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	VXD_PRINTF(( "pInIoctl->hAppPoolHandle = %08X\n", pInIoctl->hAppPoolHandle ));
	VXD_PRINTF(( "pInIoctl->ulUriToRegisterLength = %08X\n", pInIoctl->ulUriToRegisterLength ));
	VXD_PRINTF(( "pInIoctl->pUriToRegister = %08X\n", pInIoctl->pUriToRegister ));

	if ( pInIoctl->pUriToRegister == NULL ) // allow: pInIoctl->ulUriToRegisterLength == 0
	{
		VXD_PRINTF(( "Invalid input data: pUriToRegister is NULL\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	// CODEWORK: Check if the Uri is reasonable.

	if ( VxdValidateBuffer( pInIoctl->pUriToRegister, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) ) == NULL )
	{
		VXD_PRINTF(( "Invalid buffer: pBuffer:%08X ulSize:%u\n", pInIoctl->pUriToRegister, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Lock URI

	if ( pInIoctl->ulUriToRegisterLength != 0 )
	{
		pLockedUri = VxdLockBufferForRead( pInIoctl->pUriToRegister, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) );
		if ( pLockedUri == NULL )
		{
			return UL_ERROR_VXDLOCKMEM_FAILED;
		}
	}
	
	VXD_PRINTF(( "pInIoctl->pUriToRegister = %08X (pLockedUri:%08X[%S]))\n", pInIoctl->pUriToRegister, pLockedUri, pLockedUri ));

	// Find out where to put this uri registration in order to do fast longest
	// prefix matching (we'll check if the Uri is not ALREADY registered as well)

	pSavedAppPoolList = UlFindAppPoolInfoByHandle( pInIoctl->hAppPoolHandle );

	if ( pSavedAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pSavedAppPoolList,
		UL_APPPOOL_LIST,
		List );

	VXD_PRINTF(( "pAppPool:%08X\n", pAppPool ));

	// best guess for the Uri position in the AppPoolUriList
	
	pSavedUriList = &pAppPool->UriList;
	pUri = NULL;

	pGlobalUriList = GlobalUriListRoot.Flink;

	while ( pGlobalUriList != &GlobalUriListRoot )
	{
	    pGUri =
	    CONTAINING_RECORD(
			pGlobalUriList,
			UL_URI_LIST,
			GlobalList );

		if ( pSavedAppPoolList == pGUri->pAppPoolList )
		{
			// Save this info for later (if this Uri is OK,
			// this is where it should go)

			pSavedUriList = &pGUri->List;
			pUri = pGUri;
		}

		wSizeToCompare = MIN( pInIoctl->ulUriToRegisterLength, pGUri->ulUriLength );
		wSameSize = pInIoctl->ulUriToRegisterLength - pGUri->ulUriLength;
		wResult = memcmp( pLockedUri, pGUri->pUri, wSizeToCompare * sizeof(WCHAR) );

		// VXD_PRINTF(( "(VxdUlRegisterUri) Comparing first %d bytes of %S to %S returns %d\n", wSizeToCompare, pLockedUri, pUri->pUri, wResult ));

		if ( wResult == 0 )
		{
			if ( wSameSize == 0 )
			{
				VXD_PRINTF(( "Uri Already registered:[%S] pAppPool:%08X pUri:%08X)\n", pLockedUri, pAppPool, pGUri ));
				VxdUnlockBuffer( pLockedUri, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) );
				return UL_ERROR_URI_REGISTERED;
			}
			else if ( wSameSize > 0 )
			{
				break;
			}
		}
		else if ( wResult > 0 )
		{
			break;
		}

		pGlobalUriList = pGlobalUriList->Flink;
	}

	// handle special cases:

	if ( pGlobalUriList == &GlobalUriListRoot )
	{
		// uri global list empty
		// (don't care, already pSavedUriList == pSavedUriList->Flink) or
		// globally (and locally to the apppool) smallest uri
		
		pSavedUriList = &pAppPool->UriList;
	}
	else
	{
		// if this is not the end of the global list, then we found a uri
		// smaller than this one, but if this is not in the same app pool
		// then we need to insert this AFTER the saved uri from the right
		// app pool. (clear enough?)
		
	    if ( pGUri != pUri )
		{
			pSavedUriList = pSavedUriList->Flink;
		}
	}

	// finally we know where to put the Uri, put it there:

	VXD_PRINTF(( "Uri goes into pSavedAppPoolList:%08X pGlobalUriList:%08X pSavedUriList:%08X \n", pSavedAppPoolList, pGlobalUriList, pSavedUriList ));

	ulBytesToAllocate = sizeof( UL_URI_LIST ) - sizeof(WCHAR*) + ( pInIoctl->ulUriToRegisterLength + 1 ) * sizeof(WCHAR);
	ulBytesToCopy = sizeof(WCHAR) * pInIoctl->ulUriToRegisterLength;

	pUri = ( PUL_URI_LIST ) VxdAllocMem( ulBytesToAllocate, 0L );
	if ( pUri == NULL )
	{
		VXD_PRINTF(( "Error allocating memory\n" ));
		VxdUnlockBuffer( pLockedUri, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) );
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	VXD_PRINTF(( "New pUri created in %08X\n", pUri ));

    InsertTailList( pSavedUriList, &pUri->List );
    InsertTailList( pGlobalUriList, &pUri->GlobalList );
	pUri->ulUriId = pAppPool->ulUriIdNext++;
	pUri->pAppPoolList = pSavedAppPoolList;
	pUri->ulUriLength = pInIoctl->ulUriToRegisterLength;

	// Copy Uri Unicode string
	// bugbug: I'm assuming VxdCopyMemory() will not ever fail.
	// The source and destination memory is validated.

	bOK = VxdCopyMemory( pLockedUri, pUri->pUri, ulBytesToCopy, &ulBytesCopied );
	VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

	VXD_PRINTF(( "Registered ulUriId:%08X Uri:[%S]\n", pUri->ulUriId, pUri->pUri ));

	VxdUnlockBuffer( pLockedUri, pInIoctl->ulUriToRegisterLength * sizeof(WCHAR) );

	return UL_ERROR_SUCCESS;

} // VxdUlRegisterUri




/***************************************************************************++

Routine Description:

    Performs kernel mode UlUnregisterUri().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlUnregisterUri(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pAppPoolList, *pUriList, *pSavedUriList;
	PUL_APPPOOL_LIST pAppPool;
	PUL_URI_LIST pUri;

	int wResult, wSameSize, wSizeToCompare;
	PWSTR pLockedUri = NULL;

	PIN_IOCTL_UL_UNREGISTER_URI pInIoctl = ( PIN_IOCTL_UL_UNREGISTER_URI ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->ulSize != sizeof( IN_IOCTL_UL_UNREGISTER_URI ) || pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_UNREGISTER_URI ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_UNREGISTER_URI ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	VXD_PRINTF(( "pInIoctl->hAppPoolHandle = %08X\n", pInIoctl->hAppPoolHandle ));
	VXD_PRINTF(( "pInIoctl->ulUriToUnregisterLength = %08X\n", pInIoctl->ulUriToUnregisterLength ));
	VXD_PRINTF(( "pInIoctl->pUriToUnregister = %08X\n", pInIoctl->pUriToUnregister ));

	if ( pInIoctl->pUriToUnregister == NULL ) // allow: pInIoctl->ulUriToUnregisterLength == 0
	{
		VXD_PRINTF(( "Invalid input data: pUriToUnregister is NULL\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	// CODEWORK: Check if the Uri is reasonable.

	if ( VxdValidateBuffer( pInIoctl->pUriToUnregister, pInIoctl->ulUriToUnregisterLength * sizeof(WCHAR) ) == NULL )
	{
		VXD_PRINTF(( "Invalid buffer: pBuffer:%08X ulSize:%u\n", pInIoctl->pUriToUnregister, pInIoctl->ulUriToUnregisterLength * sizeof(WCHAR) ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Lock URI

	if ( pInIoctl->ulUriToUnregisterLength != 0 )
	{
		pLockedUri = VxdLockBufferForRead( pInIoctl->pUriToUnregister, pInIoctl->ulUriToUnregisterLength * sizeof(WCHAR) );
		if ( pLockedUri == NULL )
		{
			return UL_ERROR_VXDLOCKMEM_FAILED;
		}
	}

	VXD_PRINTF(( "pInIoctl->pUriToUnregister = %08X (pLockedUri:%08X[%S]))\n", pInIoctl->pUriToUnregister, pLockedUri, pLockedUri ));

	pAppPoolList = UlFindAppPoolInfoByHandle( pInIoctl->hAppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	VXD_PRINTF(( "pAppPool:%08X\n", pAppPool ));

	pSavedUriList = NULL;
	pUriList = pAppPool->UriList.Flink;

	while ( pUriList != &pAppPool->UriList )
	{
	    pUri =
	    CONTAINING_RECORD(
			pUriList,
			UL_URI_LIST,
			List );

		wSizeToCompare = MIN( pInIoctl->ulUriToUnregisterLength, pUri->ulUriLength );
		wSameSize = pInIoctl->ulUriToUnregisterLength - pUri->ulUriLength;
		wResult = memcmp( pLockedUri, pUri->pUri, wSizeToCompare * sizeof(WCHAR) );

		// VXD_PRINTF(( "(VxdUlRegisterUri) Comparing first %d bytes of %S to %S returns %d\n", wSizeToCompare, pLockedUri, pUri->pUri, wResult ));

		if ( wResult == 0 )
		{
			if ( wSameSize == 0 )
			{
				pSavedUriList = pUriList;
				
				break;
			}
			else if ( wSameSize > 0 )
			{
				break;
			}
		}
		else if ( wResult > 0 )
		{
			break;
		}

		pUriList = pUriList->Flink;
	}

	VxdUnlockBuffer( pLockedUri, pInIoctl->ulUriToUnregisterLength * sizeof(WCHAR) );

	if ( pSavedUriList == NULL )
	{
		VXD_PRINTF(( "Uri to unregister NOT Found\n" ));
		return UL_ERROR_HANDLE_NOT_FOUND;
	}

	pUri =
	CONTAINING_RECORD(
		pSavedUriList,
		UL_URI_LIST,
		List );

	RemoveEntryList( &pUri->List );
	RemoveEntryList( &pUri->GlobalList );

	UlCleanupUri( pUri );

	return UL_ERROR_SUCCESS;

} // VxdUlUnregisterUri




/***************************************************************************++

Routine Description:

    Performs kernel mode UlUnregisterAll().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlUnregisterAll(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pAppPoolList, *pRequestList, *pUriList;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE *phAppPoolHandle = (HANDLE*) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pParameters->cbInBuffer != sizeof(HANDLE) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( phAppPoolHandle == NULL || VxdValidateBuffer( phAppPoolHandle, sizeof(HANDLE) ) == NULL )
	{
		VXD_PRINTF(( "Invalid input data:%08X\n", phAppPoolHandle ));
		return UL_ERROR_INVALID_DATA;
	}

	pAppPoolList = UlFindAppPoolInfoByHandle( *phAppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	pUriList = pAppPool->UriList.Flink;
	pRequestList = pAppPool->RequestList.Flink;

	while ( pUriList != &pAppPool->UriList )
	{
	    pUri =
	    CONTAINING_RECORD(
			pUriList,
			UL_URI_LIST,
			List );

		pUriList = pUriList->Flink;

		RemoveEntryList( &pUri->List );
		RemoveEntryList( &pUri->GlobalList );

		UlCleanupUri( pUri );
	}

	while ( pRequestList != &pAppPool->RequestList )
	{
	    pRequest =
	    CONTAINING_RECORD(
			pRequestList,
			UL_REQUEST_LIST,
			List );

		pRequestList = pRequestList->Flink;

		RemoveEntryList( &pRequest->List );

		UlCleanupRequest( pRequest );
	}
	
	return UL_ERROR_SUCCESS;

} // VxdUlUnregisterAll




/***************************************************************************++

Routine Description:

    Performs kernel mode UlSendHttpRequestHeaders().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlSendHttpRequestHeaders(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pRequestIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest, pSavedRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;
	UL_HTTP_REQUEST_ID *pLockedRequestId = NULL;

	PIN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS pInIoctl = ( PIN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_HEADERS ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pRequestId == NULL )
	{
		VXD_PRINTF(( "A valid pointer for pRequestId must be provided\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	// we need to make sure that the buffer size pInIoctl->pRequestBuffer
	// is at least as big as a UL_HTTP_REQUEST.

	if ( pInIoctl->RequestBufferLength < sizeof(UL_HTTP_REQUEST) )
	{
		VXD_PRINTF(( "The buffer needs to be at least %d bytes (sizeof(UL_HTTP_REQUEST))\n", sizeof(UL_HTTP_REQUEST) ));
		return UL_ERROR_NO_SYSTEM_RESOURCES;
	}

	if ( VxdValidateBuffer( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesSent != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pRequestId, sizeof( UL_HTTP_REQUEST_ID ) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->ulTargetUriLength = %d\n", pInIoctl->ulTargetUriLength ));
	VXD_PRINTF(( "pInIoctl->pTargetUri = %08X[%S]\n", pInIoctl->pTargetUri, pInIoctl->pTargetUri ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pRequestId = %08X[%016X]\n", pInIoctl->pRequestId, VAL(pInIoctl->pRequestId) ));
	VXD_PRINTF(( "pInIoctl->pRequestBuffer = %08X\n", pInIoctl->pRequestBuffer ));
	VXD_PRINTF(( "pInIoctl->RequestBufferLength = %d\n", pInIoctl->RequestBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent) ));
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// ok, data validation is now really complete, search for the recipient
	// for this message based on the TargetUri.

	pUriList = UlFindUriInfoByUri( pInIoctl->pTargetUri, pInIoctl->ulTargetUriLength );

	if ( pUriList == NULL )
	{
		// This SendMessage has no recipient, return and error saying that the
		// receipient is not there.
		 
 		VXD_PRINTF(( "This SendMessage has no recipient\n" ));
		return UL_ERROR_NO_TARGET_URI;
	}

    pUri =
    CONTAINING_RECORD(
		pUriList,
		UL_URI_LIST,
		List );

	pAppPoolList = pUri->pAppPoolList;
	
    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	// Complete all the possible pending I/O (and update the IRP).
	// such pending IRPs might be there if somebody had previously called
	// VxdUlReceiveHttpRequestHeaders() via UlReceiveHttpRequestHeaders()
	// and, in this case, would be waiting for a request to come in
	// so this one request would be the one to complete such request.

	pSavedRequest = NULL;
	pRequestList = pAppPool->RequestList.Flink;

	while ( pRequestList != &pAppPool->RequestList )
	{
		pRequest =
	    CONTAINING_RECORD(
			pRequestList,
			UL_REQUEST_LIST,
			List );
			
		pRequestList = pRequestList->Flink;

		if ( !pRequest->ulRequestHeadersSent && !IsListEmpty( &pRequest->RequestIrpList ) && pRequest->ulRequestIrpType == UlIrpReceive && IsListEmpty( &pRequest->ResponseIrpList ) )
		{
			pSavedRequest = pRequest;
			break;
		}
	}

	ulBytesToCopy = pInIoctl->RequestBufferLength;
	ulBytesCopied = 0L;

	if ( pSavedRequest != NULL )
	{
		//
		// if somebody alread received the request heders I complete the IRP
		//

		pRequest = pSavedRequest;

		pRequestIrp =
	    CONTAINING_RECORD(
			pRequest->RequestIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlReceiveHttpRequestHeaders() IRP\n" ));

		UlDumpIrpInfo( pRequestIrp );

		VXD_ASSERT( pRequest->ulRequestHeadersSending == TRUE && pRequestIrp->ulBytesTransferred == 0 );

		if ( pRequestIrp->ulBytesToTransfer >= ulBytesToCopy )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( (PBYTE)pInIoctl->pRequestBuffer, pRequestIrp->pData, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, (PBYTE)pInIoctl->pRequestBuffer, pRequestIrp->pData ));

			pRequestIrp->ulBytesTransferred = ulBytesCopied;
			pSavedRequest->ulRequestHeadersSent = TRUE;

			// resetting RequestId overwritten by VxdCopyMemory()
			
			((PUL_HTTP_REQUEST)pRequestIrp->pData)->RequestId = pRequest->RequestId;

			// all the data was transferred, IO completed synchronously

			pInIoctl->pOverlapped->InternalHigh = ulBytesCopied;
			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			// Signal the Event in the Overlapped Structure, just in case
			// they're not checking for return code.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever
			// fail. there's not much we can do if it fails anyway...

			VXD_PRINTF(( "Signaling hEvent %08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );
		}

		//
		// Set the RequestId
		//

		VXD_PRINTF(( "Setting pRequestId:%08X to %016X\n", pInIoctl->pRequestId, pRequest->RequestId ));
		*pInIoctl->pRequestId = pRequest->RequestId;

		//
		// Unqueue the pending IRP and clean it up
		//

		RemoveEntryList( &pRequestIrp->List );

		if ( ulBytesCopied < ulBytesToCopy )
		{
			// If the Receive Buffer is NOT large enough we need to fail the IO
			// and set information on the size of the buffer that needs to be
			// allocated to fit all the data to be sent.

			//
			// set the size of data pending in the overlapped structure
			// and complete asyncronously
			//

			pRequestIrp->ulBytesTransferred = ulBytesToCopy;
			UlCleanupIrp( pRequestIrp, UL_ERROR_NO_SYSTEM_RESOURCES );
		}
		else
		{
			//
			// the buffer was big enough: succes
			//

			UlCleanupIrp( pRequestIrp, ERROR_SUCCESS );
		}

		// Set the number of bytes transferred

		if ( pInIoctl->pBytesSent != NULL )
		{
			*pInIoctl->pBytesSent = ulBytesCopied;
		}

		if ( ulBytesCopied == ulBytesToCopy )
		{
			// the I/O completed succesfully and all data was transferred, so

			return UL_ERROR_SUCCESS;
		}
	}
	else
	{
		// create a new Request object in the AppPool and stick it at the head of
		// the list so it will be found quickly

		pRequest = ( PUL_REQUEST_LIST ) VxdAllocMem( sizeof( UL_REQUEST_LIST ) , 0L );
		if ( pRequest == NULL )
		{
			return UL_ERROR_VXDALLOCMEM_FAILED;
		}

		VXD_PRINTF(( "New pRequest created in %08X\n", pRequest ));

		// and insert the new record in the list

	    InsertTailList( &pAppPool->RequestList, &pRequest->List );
		InitializeListHead( &pRequest->RequestIrpList );
		InitializeListHead( &pRequest->ResponseIrpList );
		pRequest->RequestId = *pInIoctl->pRequestId = RequestIdNext++;
		pRequest->ulUriId = pUri->ulUriId; // CODEWORK: not sure if this is useful info
		pRequest->ulRequestHeadersSending = TRUE;
		pRequest->ulResponseHeadersSending = FALSE;
		pRequest->ulRequestHeadersSent = FALSE;
		pRequest->ulResponseHeadersSent = FALSE;
		pRequest->ulRequestIrpType = UlIrpSend;
		pRequest->ulResponseIrpType = UlIrpEmpty;

		*pInIoctl->pRequestId = pRequest->RequestId;
		VXD_PRINTF(( "Setting pRequestId:%08X to %016X\n", pInIoctl->pRequestId, pRequest->RequestId ));
	}

	//
	// Pend the uncompleted Send at the end of the Irp-Request
	//

	VXD_PRINTF(( "This VxdUlSendHttpRequestHeaders() is going to be pended...\n" ));

	// Memory has already been validated
	// The following memory locks include validation again

	pLockedData = VxdLockBufferForRead( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength );
	if ( pLockedData == NULL )
	{
		goto SendHttpRequestHeadersCleanup;
	}

	pLockedRequestId = VxdLockBufferForWrite( pInIoctl->pRequestId, sizeof( UL_HTTP_REQUEST_ID ) );
	if ( pLockedRequestId == NULL )
	{
		goto SendHttpRequestHeadersCleanup;
	}


	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto SendHttpRequestHeadersCleanup;
	}

	pRequestIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pRequestIrp == NULL )
	{
		goto SendHttpRequestHeadersCleanup;
	}

	VXD_PRINTF(( "New pRequestIrp created in %08X\n", pRequestIrp ));

	// once all memory locks completed successfully we can update the data
	// structures 

    InsertTailList( &pRequest->RequestIrpList, &pRequestIrp->List );
	pRequestIrp->hProcess = GlobalhProcess;
	pRequestIrp->hThread = GlobalhThread;
	pRequestIrp->hr0Event = hr0Event;
	pRequestIrp->pOverlapped = pLockedOverlapped;
	pRequestIrp->pData = pLockedData;
	pRequestIrp->ulBytesToTransfer = ulBytesToCopy;
	pRequestIrp->ulBytesTransferred = ulBytesCopied;
	pRequestIrp->pRequestId = pLockedRequestId;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	UlDumpIrpInfo( pRequestIrp );

	return UL_ERROR_IO_PENDING;


SendHttpRequestHeadersCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->RequestBufferLength );
	}

	if ( pLockedRequestId != NULL )
	{
		VxdUnlockBuffer( pLockedRequestId, sizeof(UL_HTTP_REQUEST_ID) );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pRequestIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlSendHttpRequestHeaders()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlSendHttpRequestEntityBody().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlSendHttpRequestEntityBody(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pRequestIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied, ulTotalBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY pInIoctl = ( PIN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	if ( pInIoctl->RequestBufferLength != 0 && pInIoctl->pRequestBuffer != NULL )
	{
		//
		// we don't validate if this is a end of request body
		//

		if ( VxdValidateBuffer( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}

		if ( pInIoctl->pBytesSent != NULL )
		{
			if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
			{
				return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
			}
		}
	}
	else if ( pInIoctl->RequestBufferLength != 0 || pInIoctl->pRequestBuffer != NULL )
	{
		VXD_PRINTF(( "Invalid input buffer, \n" ));
		return UL_ERROR_INVALID_PARAMETER;
	}
	
	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pRequestBuffer = %08X\n", pInIoctl->pRequestBuffer ));
	VXD_PRINTF(( "pInIoctl->RequestBufferLength = %d\n", pInIoctl->RequestBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent) ));
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByRequestId( pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this request
	
	if ( !pRequest->ulRequestHeadersSending )
	{
		VXD_PRINTF(( "Can't send the body if Request headers were not sent" ));
		return UL_ERROR_BAD_COMMAND;
	}

	ulTotalBytesCopied = 0L;

	pInIoctl->pOverlapped->InternalHigh = 0;
	pInIoctl->pOverlapped->Internal = ERROR_IO_PENDING;

	while ( !IsListEmpty( &pRequest->RequestIrpList )
		&& pRequest->ulRequestIrpType == UlIrpReceive )
	{
		//
		// walk the request IRP list and complete all the pending receives
		// that we can.
		//

		pRequestIrp =
	    CONTAINING_RECORD(
			pRequest->RequestIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlReceiveHttpRequestEntityBody() IRP\n" ));

		UlDumpIrpInfo( pRequestIrp );

		//
		// If the IRP Receive Buffer is not large enough just transfer all the
		// data/ that we can fit and keep completing IRPs in this fashion
		// until we have data to send. When all Receive IRPs are completed
		// if there's more data to send we will pend the IO.
		//

		ulBytesCopied = 0L;
		ulBytesToCopy = MIN( pInIoctl->RequestBufferLength - ulTotalBytesCopied, pRequestIrp->ulBytesToTransfer - pRequestIrp->ulBytesTransferred );

		if ( ulBytesToCopy > 0 )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( (PBYTE)pInIoctl->pRequestBuffer + ulBytesCopied, pRequestIrp->pData + pRequestIrp->ulBytesTransferred, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, (PBYTE)pInIoctl->pRequestBuffer + ulBytesCopied, pRequestIrp->pData + pRequestIrp->ulBytesTransferred ));

			ulTotalBytesCopied += ulBytesCopied;
			pRequestIrp->ulBytesTransferred += ulBytesCopied;
		}

		//
		// update/set information on the data transferred in the
		// pBytesSent parameter supplied and in the overlapped structure
		//

		if ( pInIoctl->pBytesSent != NULL )
		{
			*(pInIoctl->pBytesSent) = ulTotalBytesCopied;
		}

		pInIoctl->pOverlapped->InternalHigh = ulTotalBytesCopied;

		//
		// this receive IRP will be completed anyway
		// (even if not all the buffer was filled with data)
		// unqueue the pending IRP and clean it up
		//

		RemoveEntryList( &pRequestIrp->List );

		if ( pRequestIrp->ulBytesToTransfer == 0
			&& pInIoctl->RequestBufferLength != 0 )
		{
			//
			// input is zero length buffer, we only return
			// how much data is pending and return and error
			//

			pRequestIrp->ulBytesTransferred = pInIoctl->RequestBufferLength - ulTotalBytesCopied;
			UlCleanupIrp( pRequestIrp, UL_ERROR_INSUFFICIENT_BUFFER );
		}
		else
		{
			UlCleanupIrp( pRequestIrp, ERROR_SUCCESS );
		}

		//
		// check to see if we sent all the data that we need to
		//

		if ( ulBytesCopied >= pInIoctl->RequestBufferLength )
		{
			//
			// all the data was transferred (if I had multiple 0-bytes
			// receives, I complete only the first one)
			//

			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			if ( pInIoctl->RequestBufferLength == 0 )
			{
				//
				// this means this is the final call, since the Send I/O was a 0-bytes
				// we completed sending the request entity body
				//

				VXD_PRINTF(( "Request complete\n" ));
			}

			//
			// Signal the Event in the Overlapped Structure.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever fail.
			// there's not much to do if it fails anyway...
			//

			VXD_PRINTF(( "Signaling hEvent:%08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );

			return UL_ERROR_SUCCESS;
		}

	} // while

	//
	// Pend the uncompleted Send at the end of the Irp-Request
	//

	VXD_PRINTF(( "This VxdUlSendHttpRequestEntityBody() is going to be pended...\n" ));

	//
	// Memory has already been validated
	// The following memory locks include validation again
	//

	if ( pInIoctl->RequestBufferLength != 0 && pInIoctl->pRequestBuffer != NULL )
	{
		pLockedData = VxdLockBufferForRead( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength );
		if ( pLockedData == NULL )
		{
			goto SendHttpRequestEntityBodyCleanup;
		}
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto SendHttpRequestEntityBodyCleanup;
	}

	pRequestIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pRequestIrp == NULL )
	{
		goto SendHttpRequestEntityBodyCleanup;
	}

	VXD_PRINTF(( "New pRequestIrp created in %08X\n", pRequestIrp ));

	// once all memory locks completed successfully we can update the data
	// structures 

    InsertTailList( &pRequest->RequestIrpList, &pRequestIrp->List );
	pRequestIrp->hProcess = GlobalhProcess;
	pRequestIrp->hThread = GlobalhThread;
	pRequestIrp->hr0Event = hr0Event;
	pRequestIrp->pOverlapped = pLockedOverlapped;
	pRequestIrp->pData = pLockedData;
	pRequestIrp->ulBytesToTransfer = pInIoctl->RequestBufferLength;
	pRequestIrp->ulBytesTransferred = ulTotalBytesCopied;
	pRequestIrp->pRequestId = NULL;

	pRequest->ulRequestIrpType = UlIrpSend;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	UlDumpIrpInfo( pRequestIrp );

	return UL_ERROR_IO_PENDING;


SendHttpRequestEntityBodyCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->RequestBufferLength );
	}
	
	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pRequestIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlSendHttpRequestEntityBody()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlReceiveHttpRequestHeaders().
	UL.SYS: UlReceiveHttpRequest()

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlReceiveHttpRequestHeaders(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pRequestIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest, pSavedRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS pInIoctl = ( PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	// we need to make sure that the buffer size pInIoctl->pRequestBuffer
	// is at least as big as a UL_HTTP_REQUEST.

	if ( pInIoctl->RequestBufferLength < sizeof(UL_HTTP_REQUEST) )
	{
		VXD_PRINTF(( "The buffer needs to be at least %d bytes (sizeof(UL_HTTP_REQUEST))\n", sizeof(UL_HTTP_REQUEST) ));
		return UL_ERROR_NO_SYSTEM_RESOURCES;
	}

	if ( VxdValidateBuffer( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesReturned != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesReturned, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->AppPoolHandle = %08X\n", pInIoctl->AppPoolHandle ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pRequestBuffer = %08X\n", pInIoctl->pRequestBuffer ));
	VXD_PRINTF(( "pInIoctl->RequestBufferLength = %d\n", pInIoctl->RequestBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesReturned = %08X[%d]\n", pInIoctl->pBytesReturned, VAL(pInIoctl->pBytesReturned)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_APPPOOL_LIST structure (based on the AppPoolHandle)

	pAppPoolList = UlFindAppPoolInfoByHandle( pInIoctl->AppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	pUriList = pAppPool->UriList.Flink;

	if ( IsListEmpty( pUriList ) )
	{
		VXD_PRINTF(( "Can't call UlReceiveHttpRequestHeaders() if no Uri was registered\n" ));
		return UL_ERROR_NOT_READY;
	}

    pUri =
    CONTAINING_RECORD(
		pUriList,
		UL_URI_LIST,
		List );


	// ok, data validation is now really complete,if this is the first call to
	// VxdUlReceiveHttpRequestHeaders() the specified RequestId will be null:

	// UL_IS_NULL_ID( pInIoctl->pRequestId )
	// in this case we have to look for the first pending Request (if any)
	// and passing it to this Receive I/O;
	
	// if the specified RequestId is not null:

	// !UL_IS_NULL_ID( pInIoctl->pRequestId )
	// in this case VxdUlReceiveHttpRequestHeaders() was already called and
	// failed due to insufficient buffer size (STATUS_INSUFFICIENT_RESOURCES)
	// ((PUL_HTTP_REQUEST) pInIoctl->pRequestBuffer)->RequestId was updated
	// and set to (the now specified) pInIoctl->pRequestId.

	// first thing we do is to look for the first request that:
	// !pRequest->ulRequestHeadersSent
	// - is still waiting for the headers to be sent
	// &&
	// !IsListEmpty( &pRequest->RequestIrpList )
	// - has some pending data in the RequestIrpList
	// &&
	// pRequest->ulRequestIrpType == UlIrpSend
	// - the pending data is waiting to be received
	// &&
	// IsListEmpty( &pRequest->ResponseIrpList )
	// - has no pending data in the ResponseIrpList
	// &&
	//		UL_IS_NULL_ID( pInIoctl->pRequestId )
	//		- don't care about RequestId
	//		||
	//		pRequest->RequestId == *pInIoctl->pRequestId
	//		- if specified RequestId must match

	pSavedRequest = NULL;
	pRequestList = pAppPool->RequestList.Flink;

	while ( pRequestList != &pAppPool->RequestList )
	{
		pRequest =
	    CONTAINING_RECORD(
			pRequestList,
			UL_REQUEST_LIST,
			List );
			
		pRequestList = pRequestList->Flink;

		if ( !pRequest->ulRequestHeadersSent && !IsListEmpty( &pRequest->RequestIrpList ) && pRequest->ulRequestIrpType == UlIrpSend && IsListEmpty( &pRequest->ResponseIrpList ) )
		{
			if ( UL_IS_NULL_ID( &pInIoctl->RequestId ) || pRequest->RequestId == pInIoctl->RequestId )
			{
				pSavedRequest = pRequest;
				break;
			}
		}
	}

	ulBytesToCopy = pInIoctl->RequestBufferLength;
	ulBytesCopied = 0L;

	if ( pSavedRequest != NULL )
	{
		//
		// if somebody alread sent the request heders I complete the IRP
		//
		
		pRequest = pSavedRequest;

		pRequestIrp =
	    CONTAINING_RECORD(
			pRequest->RequestIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlSendHttpRequestHeaders() IRP\n" ));

		UlDumpIrpInfo( pRequestIrp );

		VXD_ASSERT( pRequest->ulRequestHeadersSending == TRUE && pRequestIrp->ulBytesTransferred == 0 );
		VXD_ASSERT( pInIoctl->RequestId == 0 || pInIoctl->RequestId == *pRequestIrp->pRequestId );

		// we found a pended VxdUlSendHttpRequestHeaders() see if we have
		// enough space in this receive buffer for the pending request

		ulBytesToCopy = pRequestIrp->ulBytesToTransfer;

		if ( pInIoctl->RequestBufferLength >= ulBytesToCopy )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( pRequestIrp->pData, (PBYTE)pInIoctl->pRequestBuffer, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, pRequestIrp->pData, (PBYTE)pInIoctl->pRequestBuffer ));

			pRequestIrp->ulBytesTransferred = ulBytesCopied;
			pSavedRequest->ulRequestHeadersSent = TRUE;

			// all the data was transferred, IO completed synchronously

			pInIoctl->pOverlapped->InternalHigh = ulBytesCopied;
			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			// Signal the Event in the Overlapped Structure, just in case
			// they're not checking for return code.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever
			// fail. there's not much we can do if it fails anyway...

			VXD_PRINTF(( "Signaling hEvent %08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );
		}

		// copy the RequestId

		((PUL_HTTP_REQUEST)pInIoctl->pRequestBuffer)->RequestId = pRequest->RequestId;

		if ( ulBytesCopied < ulBytesToCopy )
		{
			// If the Receive Buffer is NOT large enough we need to fail the IO
			// and set information on the size of the buffer that needs to be
			// allocated to fit all the data to be sent.

			// the I/O didn't complete succesfully because the buffer was too
			// small, return an error and leave the IRP pending

			if ( pInIoctl->pBytesReturned != NULL )
			{
				*pInIoctl->pBytesReturned = ulBytesToCopy;
			}

			return UL_ERROR_NO_SYSTEM_RESOURCES;
		}

		// Set the number of bytes transferred

		if ( pInIoctl->pBytesReturned != NULL )
		{
			*pInIoctl->pBytesReturned = ulBytesCopied;
		}

		// Unqueue the pending IRP and clean it up

		RemoveEntryList( &pRequestIrp->List );

		UlCleanupIrp( pRequestIrp, ERROR_SUCCESS );

		// the I/O completed succesfully and all data was transferred, so
			
		return UL_ERROR_SUCCESS;
	}
	else
	{
		// if we didn't find any pending I/O and a RequestId was specifies, we
		// need to fail the I/O because the request was stolen by someother call
		
		if ( !UL_IS_NULL_ID( &pInIoctl->RequestId ) )
		{
			VXD_PRINTF(( "Invalid RequestId\n" ));
			return UL_ERROR_INVALID_HANDLE;
		}

		// if not we create a new Request object in the AppPool and stick it
		// at the head of the list so it will be found quickly

		pRequest = ( PUL_REQUEST_LIST ) VxdAllocMem( sizeof( UL_REQUEST_LIST ) , 0L );
		if ( pRequest == NULL )
		{
			return UL_ERROR_VXDALLOCMEM_FAILED;
		}

		VXD_PRINTF(( "New pRequest created in %08X\n", pRequest ));

		// and insert the new record in the list

	    InsertTailList( &pAppPool->RequestList, &pRequest->List );
		InitializeListHead( &pRequest->RequestIrpList );
		InitializeListHead( &pRequest->ResponseIrpList );
		pRequest->RequestId = RequestIdNext++;
		pRequest->ulUriId = pUri->ulUriId; // CODEWORK: not sure if this is useful info
		pRequest->ulRequestHeadersSending = TRUE;
		pRequest->ulResponseHeadersSending = FALSE;
		pRequest->ulRequestHeadersSent = FALSE;
		pRequest->ulResponseHeadersSent = FALSE;
		pRequest->ulRequestIrpType = UlIrpReceive;
		pRequest->ulResponseIrpType = UlIrpEmpty;
	}

	//
	// Pend the uncompleted Receive at the end of the Irp-Request
	//

	VXD_PRINTF(( "This VxdUlReceiveHttpRequestHeaders() is going to be pended...\n" ));

	// Memory has already been validated
	// The following memory locks include validation again

	pLockedData = VxdLockBufferForRead( pInIoctl->pRequestBuffer, pInIoctl->RequestBufferLength );
	if ( pLockedData == NULL )
	{
		goto ReceiveHttpRequestHeadersCleanup;
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto ReceiveHttpRequestHeadersCleanup;
	}

	pRequestIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pRequestIrp == NULL )
	{
		goto ReceiveHttpRequestHeadersCleanup;
	}

	VXD_PRINTF(( "New pRequestIrp created in %08X\n", pRequestIrp ));

	// once all memory locks completed successfully we can update the data
	// structures 

    InsertTailList( &pRequest->RequestIrpList, &pRequestIrp->List );
	pRequestIrp->hProcess = GlobalhProcess;
	pRequestIrp->hThread = GlobalhThread;
	pRequestIrp->hr0Event = hr0Event;
	pRequestIrp->pOverlapped = pLockedOverlapped;
	pRequestIrp->pData = pLockedData;
	pRequestIrp->ulBytesToTransfer = ulBytesToCopy;
	pRequestIrp->ulBytesTransferred = ulBytesCopied;
	pRequestIrp->pRequestId = NULL;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	((PUL_HTTP_REQUEST)pInIoctl->pRequestBuffer)->RequestId = pRequest->RequestId;

	UlDumpIrpInfo( pRequestIrp );

	return UL_ERROR_IO_PENDING;


ReceiveHttpRequestHeadersCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->RequestBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pRequestIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlReceiveHttpRequestHeaders()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlReceiveHttpRequestEntityBody().
	UL.SYS: UlReceiveEntityBody()
	
Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlReceiveHttpRequestEntityBody(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pRequestIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied, ulTotalBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY pInIoctl = ( PIN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	if ( VxdValidateBuffer( pInIoctl->pEntityBuffer, pInIoctl->EntityBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesReturned != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesReturned, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->AppPoolHandle = %08X\n", pInIoctl->AppPoolHandle ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pEntityBuffer = %08X\n", pInIoctl->pEntityBuffer ));
	VXD_PRINTF(( "pInIoctl->EntityBufferLength = %d\n", pInIoctl->EntityBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesReturned = %08X[%d]\n", pInIoctl->pBytesReturned, VAL(pInIoctl->pBytesReturned)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_APPPOOL_LIST structure (based on the AppPoolHandle)

	pAppPoolList = UlFindAppPoolInfoByHandle( pInIoctl->AppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByAppPoolAndRequestId( pAppPool, pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this request

	if ( !pRequest->ulRequestHeadersSending || !pRequest->ulRequestHeadersSent )
	{
		VXD_PRINTF(( "Can't send the body if Request headers were not sent" ));
		return UL_ERROR_BAD_COMMAND;
	}

	ulTotalBytesCopied = 0L;

	pInIoctl->pOverlapped->InternalHigh = 0;
	pInIoctl->pOverlapped->Internal = ERROR_IO_PENDING;

	if ( !IsListEmpty( &pRequest->RequestIrpList )
		&& pRequest->ulRequestIrpType == UlIrpSend )
	{
		pRequestIrp =
	    CONTAINING_RECORD(
			pRequest->RequestIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlSendHttpRequestEntityBody() IRP\n" ));

		UlDumpIrpInfo( pRequestIrp );

		ulBytesCopied = 0L;
		ulBytesToCopy = MIN( pInIoctl->EntityBufferLength - ulTotalBytesCopied, pRequestIrp->ulBytesToTransfer - pRequestIrp->ulBytesTransferred );

		if ( ulBytesToCopy > 0 )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( pRequestIrp->pData + pRequestIrp->ulBytesTransferred, (PBYTE)pInIoctl->pEntityBuffer, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, pRequestIrp->pData + pRequestIrp->ulBytesTransferred, (PBYTE)pInIoctl->pEntityBuffer ));

			ulTotalBytesCopied += ulBytesCopied;
			pRequestIrp->ulBytesTransferred += ulBytesCopied;
		}

		if ( pInIoctl->EntityBufferLength == 0 )
		{
			//
			// input is zero length buffer, we only return
			// how much data is pending and return and error
			//

			*(pInIoctl->pBytesReturned) = pRequestIrp->ulBytesToTransfer - pRequestIrp->ulBytesTransferred;

			return UL_ERROR_INSUFFICIENT_BUFFER;
		}

		// update/set information on the data transferred in the
		// pBytesSent parameter supplied and in the overlapped structure
		//

		if ( pInIoctl->pBytesReturned != NULL )
		{
			*(pInIoctl->pBytesReturned) = ulTotalBytesCopied;
		}

		pInIoctl->pOverlapped->InternalHigh = ulTotalBytesCopied;

		//
		// check for IRP completion
		//
		
		if ( pRequestIrp->ulBytesToTransfer == pRequestIrp->ulBytesTransferred )
		{
			// Unqueue the pending IRP and clean it up

			RemoveEntryList( &pRequestIrp->List );

			UlCleanupIrp( pRequestIrp, ERROR_SUCCESS );
		}

		pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

		// Signal the Event in the Overlapped Structure.
		// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever fail.
		// there's not much to do if it fails anyway...

		VXD_PRINTF(( "Signaling hEvent:%08X\n", hr0Event ));

		bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
		VXD_ASSERT( bOK == TRUE );

		if ( pRequestIrp->ulBytesToTransfer == 0
			&& pRequestIrp->ulBytesTransferred == 0 )
		{
			//
			// this means this is the final call, since the IRP was a 0-bytes
			//

			VXD_PRINTF(( "Request Entity Body send is complete\n" ));
		}

		return UL_ERROR_SUCCESS;

	} // if

	//
	// Pend the uncompleted Send at the end of the Irp-Request
	//

	VXD_PRINTF(( "This VxdUlReceiveHttpRequestEntityBody() is going to be pended...\n" ));

	//
	// Memory has already been validated
	// The following memory locks include validation again
	//

	pLockedData = VxdLockBufferForRead( pInIoctl->pEntityBuffer, pInIoctl->EntityBufferLength );
	if ( pLockedData == NULL )
	{
		goto ReceiveHttpRequestEntityBodyCleanup;
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto ReceiveHttpRequestEntityBodyCleanup;
	}

	pRequestIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pRequestIrp == NULL )
	{
		goto ReceiveHttpRequestEntityBodyCleanup;
	}

	VXD_PRINTF(( "New pRequestIrp created in %08X\n", pRequestIrp ));

	//
	// once all memory locks completed successfully we can update the data
	// structures 
	//

    InsertTailList( &pRequest->RequestIrpList, &pRequestIrp->List );
	pRequestIrp->hProcess = GlobalhProcess;
	pRequestIrp->hThread = GlobalhThread;
	pRequestIrp->hr0Event = hr0Event;
	pRequestIrp->pOverlapped = pLockedOverlapped;
	pRequestIrp->pData = pLockedData;
	pRequestIrp->ulBytesToTransfer = pInIoctl->EntityBufferLength;
	pRequestIrp->ulBytesTransferred = ulTotalBytesCopied;
	pRequestIrp->pRequestId = NULL;

	pRequest->ulRequestIrpType = UlIrpReceive;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	UlDumpIrpInfo( pRequestIrp );

	return UL_ERROR_IO_PENDING;


ReceiveHttpRequestEntityBodyCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->EntityBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pRequestIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlReceiveHttpRequestEntityBody()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlSendHttpResponseHeaders().
	UL.SYS: UlSendHttpResponse()

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlSendHttpResponseHeaders(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList;
	PUL_IRP_LIST pResponseIrp;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS pInIoctl = ( PIN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	// we need to make sure that the buffer size pInIoctl->pResponseBuffer
	// is at least as big as a UL_HTTP_RESPONSE.

	if ( pInIoctl->ResponseBufferLength < sizeof(UL_HTTP_RESPONSE) )
	{
		VXD_PRINTF(( "The buffer needs to be at least %d bytes (sizeof(UL_HTTP_RESPONSE))\n", sizeof(UL_HTTP_RESPONSE) ));
		return UL_ERROR_NO_SYSTEM_RESOURCES;
	}

	if ( VxdValidateBuffer( pInIoctl->pResponseBuffer, pInIoctl->ResponseBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesSent != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->AppPoolHandle = %08X\n", pInIoctl->AppPoolHandle ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pResponseBuffer = %08X\n", pInIoctl->pResponseBuffer ));
	VXD_PRINTF(( "pInIoctl->ResponseBufferLength = %d\n", pInIoctl->ResponseBufferLength ));
	VXD_PRINTF(( "pInIoctl->EntityChunkCount = %d\n", pInIoctl->EntityChunkCount ));
	VXD_PRINTF(( "pInIoctl->pEntityChunks = %d\n", pInIoctl->pEntityChunks ));
	VXD_PRINTF(( "pInIoctl->pCachePolicy = %d\n", pInIoctl->pCachePolicy ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_APPPOOL_LIST structure (based on the AppPoolHandle)

	pAppPoolList = UlFindAppPoolInfoByHandle( pInIoctl->AppPoolHandle );

	if ( pAppPoolList == NULL )
	{
		VXD_PRINTF(( "VxdUlCreateAppPool() didn't return this handle\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

    pAppPool =
    CONTAINING_RECORD(
		pAppPoolList,
		UL_APPPOOL_LIST,
		List );

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByAppPoolAndRequestId( pAppPool, pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this request

	if ( pRequest->ulResponseHeadersSent || ( !IsListEmpty( &pRequest->ResponseIrpList ) && pRequest->ulResponseIrpType != UlIrpReceive ) )
	{
		VXD_PRINTF(( "Response headers were already sent" ));
		return UL_ERROR_BAD_COMMAND;
	}
	
	ulBytesToCopy = pInIoctl->ResponseBufferLength;
	ulBytesCopied = 0L;

	if ( !IsListEmpty( &pRequest->ResponseIrpList )
		&& pRequest->ulResponseIrpType == UlIrpReceive )
	{
		//
		// if somebody alread received the response heders I complete the IRP
		//

		pResponseIrp =
	    CONTAINING_RECORD(
			pRequest->ResponseIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlReceiveHttpResponseHeaders() IRP\n" ));

		UlDumpIrpInfo( pResponseIrp );

		VXD_ASSERT( pResponseIrp->ulBytesTransferred == 0 );

		if ( pResponseIrp->ulBytesToTransfer >= ulBytesToCopy )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( (PBYTE)pInIoctl->pResponseBuffer, pResponseIrp->pData, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesCopied == ulBytesToCopy );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, (PBYTE)pInIoctl->pResponseBuffer, pResponseIrp->pData ));

			pResponseIrp->ulBytesTransferred = ulBytesCopied;
			pRequest->ulResponseHeadersSent = TRUE;

			// all the data was transferred, IO completed synchronously

			pInIoctl->pOverlapped->InternalHigh = ulBytesCopied;
			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			// Signal the Event in the Overlapped Structure, just in case
			// they're not checking for return code.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever
			// fail. there's not much we can do if it fails anyway...

			VXD_PRINTF(( "Signaling hEvent %08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );
		}

		//
		// Unqueue the pending IRP and clean it up
		//

		RemoveEntryList( &pResponseIrp->List );

		if ( ulBytesCopied < ulBytesToCopy )
		{
			// If the Receive Buffer is NOT large enough we need to fail the IO
			// and set information on the size of the buffer that needs to be
			// allocated to fit all the data to be sent.

			//
			// set the size of data pending in the overlapped structure
			// and complete asyncronously
			//

			pResponseIrp->ulBytesTransferred = ulBytesToCopy;
			UlCleanupIrp( pResponseIrp, UL_ERROR_NO_SYSTEM_RESOURCES );
		}
		else
		{
			//
			// the buffer was big enough: succes
			//

			UlCleanupIrp( pResponseIrp, ERROR_SUCCESS );
		}

		// Set the number of bytes transferred

		if ( pInIoctl->pBytesSent != NULL )
		{
			*pInIoctl->pBytesSent = ulBytesCopied;
		}

		if ( ulBytesCopied == ulBytesToCopy )
		{
			// the I/O completed succesfully and all data was transferred, so

			return UL_ERROR_SUCCESS;
		}

	} // if

	//
	// Pend the uncompleted Receive at the end of the Irp-Response
	//

	VXD_PRINTF(( "This VxdUlSendHttpResponseHeaders() is going to be pended...\n" ));

	// Memory has already been validated
	// The following memory locks include validation again

	pLockedData = VxdLockBufferForRead( pInIoctl->pResponseBuffer, pInIoctl->ResponseBufferLength );
	if ( pLockedData == NULL )
	{
		goto SendHttpResponseHeadersCleanup;
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto SendHttpResponseHeadersCleanup;
	}

	pResponseIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pResponseIrp == NULL )
	{
		goto SendHttpResponseHeadersCleanup;
	}

	VXD_PRINTF(( "New pResponseIrp created in %08X\n", pResponseIrp ));

	// once all memory locks completed successfully we can update the data
	// structures 

    InsertTailList( &pRequest->ResponseIrpList, &pResponseIrp->List );
	pResponseIrp->hProcess = GlobalhProcess;
	pResponseIrp->hThread = GlobalhThread;
	pResponseIrp->hr0Event = hr0Event;
	pResponseIrp->pOverlapped = pLockedOverlapped;
	pResponseIrp->pData = pLockedData;
	pResponseIrp->ulBytesToTransfer = pInIoctl->ResponseBufferLength;
	pResponseIrp->ulBytesTransferred = ulBytesCopied;
	pResponseIrp->pRequestId = NULL;

	pRequest->ulResponseHeadersSending = TRUE;
	pRequest->ulResponseIrpType = UlIrpSend;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	UlDumpIrpInfo( pResponseIrp );

	return UL_ERROR_IO_PENDING;


SendHttpResponseHeadersCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->ResponseBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pResponseIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlSendHttpResponseHeaders()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlSendHttpResponseEntityBody().
	UL.SYS: UlSendEntityBody()

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlSendHttpResponseEntityBody(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pResponseIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied, ulTotalBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PUL_DATA_CHUNK pEntityChunks;
	PBYTE pResponseBuffer;
	ULONG ResponseBufferLength;

	PIN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY pInIoctl = ( PIN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	if ( pInIoctl->EntityChunkCount > 1 ) // Multiple chunks not supported 0 is supported for end of response
	{
		VXD_PRINTF(( "Multiple chunks are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	pResponseBuffer = NULL;
	ResponseBufferLength = 0;

	if ( pInIoctl->pEntityChunks != NULL && pInIoctl->EntityChunkCount == 1 )
	{
		//
		// we don't validate if this is a end of response body
		//

		if ( VxdValidateBuffer( pInIoctl->pEntityChunks, sizeof(UL_DATA_CHUNK) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}

		pEntityChunks = (PUL_DATA_CHUNK) pInIoctl->pEntityChunks;

		if ( pEntityChunks->DataChunkType != UlDataChunkFromMemory )
		{
			VXD_PRINTF(( "Chunks other than FromMemory are not supported\n" ));
			return UL_ERROR_NOT_IMPLEMENTED;
		}

		pResponseBuffer = pEntityChunks->FromMemory.pBuffer;
		ResponseBufferLength = pEntityChunks->FromMemory.BufferLength;

		if ( ResponseBufferLength == 0 || pResponseBuffer == NULL )
		{
			VXD_PRINTF(( "Invalid input buffer\n" ));
			return UL_ERROR_INVALID_PARAMETER;
		}

		if ( VxdValidateBuffer( pResponseBuffer, ResponseBufferLength ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}
	else if ( pInIoctl->EntityChunkCount != 0 || pInIoctl->pEntityChunks != NULL )
	{
		VXD_PRINTF(( "Invalid input buffer\n" ));
		return UL_ERROR_INVALID_PARAMETER;
	}

	if ( pInIoctl->pBytesSent != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->EntityChunkCount = %d\n", pInIoctl->EntityChunkCount ));
	VXD_PRINTF(( "pInIoctl->pEntityChunks = %08X\n", pInIoctl->pEntityChunks ));
	VXD_PRINTF(( "pInIoctl==pResponseBuffer = %08X\n", pResponseBuffer ));
	VXD_PRINTF(( "pInIoctl==ResponseBufferLength = %d\n", ResponseBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByRequestId( pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this response

	if ( !pRequest->ulResponseHeadersSending )
	{
		VXD_PRINTF(( "Can't send the body if Response headers were not sent" ));
		return UL_ERROR_BAD_COMMAND;
	}

	//
	// this is a send, and we're trying to send entity body.
	// this send will complete ONLY when ALL the data will be transferred.
	// we will walk the list of pending receives, complete all the ones that
	// we can with the data available until:
	// 1) we have no more data to send:
	//   a) complete the last receive in which data was transferred
	//   b) complete the send
	// 2) we have no more receives to complete:
	//   a) pend the send with the data remaining
	//
	// special cased will be 0 bytes pending receives and 0 bytes sends:
	// if we have a 0 bytes pending receive and have more than 0 bytes
	// to send we will complete the receive
	// if we have a 0 bytes send, this will complete only the first receive
	//

	ulTotalBytesCopied = 0L;

	pInIoctl->pOverlapped->InternalHigh = 0;
	pInIoctl->pOverlapped->Internal = ERROR_IO_PENDING;

	while ( !IsListEmpty( &pRequest->ResponseIrpList )
		&& pRequest->ulResponseIrpType == UlIrpReceive )
	{
		//
		// walk the response IRP list and complete all the pending receives
		// that we can.
		//

		pResponseIrp =
	    CONTAINING_RECORD(
			pRequest->ResponseIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlReceiveHttpResponseEntityBody() IRP\n" ));

		UlDumpIrpInfo( pResponseIrp );

		//
		// If the IRP Receive Buffer is not large enough just transfer all the
		// data/ that we can fit and keep completing IRPs in this fashion
		// until we have data to send. When all Receive IRPs are completed
		// if there's more data to send we will pend the IO.
		//

		ulBytesCopied = 0L;
		ulBytesToCopy = MIN( ResponseBufferLength - ulTotalBytesCopied, pResponseIrp->ulBytesToTransfer - pResponseIrp->ulBytesTransferred );

		if ( ulBytesToCopy > 0 )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( pResponseBuffer + ulBytesCopied, pResponseIrp->pData + pResponseIrp->ulBytesTransferred, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, pResponseBuffer + ulBytesCopied, pResponseIrp->pData + pResponseIrp->ulBytesTransferred ));

			ulTotalBytesCopied += ulBytesCopied;
			pResponseIrp->ulBytesTransferred += ulBytesCopied;
		}

		//
		// update/set information on the data transferred in the
		// pBytesSent parameter supplied and in the overlapped structure
		//

		if ( pInIoctl->pBytesSent != NULL )
		{
			*(pInIoctl->pBytesSent) = ulTotalBytesCopied;
		}

		pInIoctl->pOverlapped->InternalHigh = ulTotalBytesCopied;

		//
		// this receive IRP will be completed anyway
		// (even if not all the buffer was filled with data)
		// unqueue the pending IRP and clean it up
		//

		RemoveEntryList( &pResponseIrp->List );

		if ( pResponseIrp->ulBytesToTransfer == 0
			&& ResponseBufferLength != 0 )
		{
			//
			// input is zero length buffer, we only return
			// how much data is pending and return and error
			//

			pResponseIrp->ulBytesTransferred = ResponseBufferLength - ulTotalBytesCopied;
			UlCleanupIrp( pResponseIrp, UL_ERROR_INSUFFICIENT_BUFFER );
		}
		else
		{
			UlCleanupIrp( pResponseIrp, ERROR_SUCCESS );
		}

		//
		// check to see if we sent all the data that we need to
		//

		if ( ulBytesCopied >= ResponseBufferLength )
		{
			//
			// all the data was transferred (if I had multiple 0-bytes
			// receives, I complete only the first one)
			//

			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			if ( ResponseBufferLength == 0 )
			{
				//
				// this means this is the final call, since the Send IO was a 0-bytes
				// we can free all the request informations cause it's complete now
				//

				VXD_PRINTF(( "Request&Response complete, cleaning up\n" ));

				RemoveEntryList( &pRequest->List );

				UlCleanupRequest( pRequest );
			}

			// Signal the Event in the Overlapped Structure.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever fail.
			// there's not much to do if it fails anyway...

			VXD_PRINTF(( "Signaling hEvent:%08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );

			return UL_ERROR_SUCCESS;
		}

	} // while


	//
	// Pend the uncompleted Send at the end of the Irp-Request
	//

	VXD_PRINTF(( "This VxdUlSendHttpResponseEntityBody() is going to be pended...\n" ));

	//
	// Memory has already been validated
	// The following memory locks include validation again
	//

	if ( pResponseBuffer != NULL )
	{
		pLockedData = VxdLockBufferForRead( pResponseBuffer, ResponseBufferLength );
		if ( pLockedData == NULL )
		{
			goto SendHttpResponseEntityBodyCleanup;
		}
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto SendHttpResponseEntityBodyCleanup;
	}

	pResponseIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pResponseIrp == NULL )
	{
		goto SendHttpResponseEntityBodyCleanup;
	}

	VXD_PRINTF(( "New pResponseIrp created in %08X\n", pResponseIrp ));

	//
	// once all memory locks completed successfully we can update the data
	// structures 
	//

    InsertTailList( &pRequest->ResponseIrpList, &pResponseIrp->List );
	pResponseIrp->hProcess = GlobalhProcess;
	pResponseIrp->hThread = GlobalhThread;
	pResponseIrp->hr0Event = hr0Event;
	pResponseIrp->pOverlapped = pLockedOverlapped;
	pResponseIrp->pData = pLockedData;
	pResponseIrp->ulBytesToTransfer = ResponseBufferLength;
	pResponseIrp->ulBytesTransferred = ulTotalBytesCopied;
	pResponseIrp->pRequestId = NULL;

	pRequest->ulResponseIrpType = UlIrpSend;

	UlDumpIrpInfo( pResponseIrp );

	return UL_ERROR_IO_PENDING;


SendHttpResponseEntityBodyCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, ResponseBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pResponseIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlSendHttpResponseEntityBody()




/***************************************************************************++

Routine Description:

    Performs kernel mode UlReceiveHttpResponseHeaders().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlReceiveHttpResponseHeaders(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pRequestList;
	PUL_IRP_LIST pResponseIrp;
	PUL_REQUEST_LIST pRequest;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS pInIoctl = ( PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	// we need to make sure that the buffer size pInIoctl->pResponseBuffer
	// is at least as big as a UL_HTTP_RESPONSE.

	if ( pInIoctl->ResponseBufferLength < sizeof(UL_HTTP_RESPONSE) )
	{
		VXD_PRINTF(( "The buffer needs to be at least %d bytes (sizeof(UL_HTTP_RESPONSE))\n", sizeof(UL_HTTP_RESPONSE) ));
		return UL_ERROR_NO_SYSTEM_RESOURCES;
	}

	if ( VxdValidateBuffer( pInIoctl->pResponseBuffer, pInIoctl->ResponseBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesSent != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pResponseBuffer = %08X\n", pInIoctl->pResponseBuffer ));
	VXD_PRINTF(( "pInIoctl->ResponseBufferLength = %08X\n", pInIoctl->ResponseBufferLength ));
	VXD_PRINTF(( "pInIoctl->EntityChunkCount = %d\n", pInIoctl->EntityChunkCount ));
	VXD_PRINTF(( "pInIoctl->pEntityChunks = %d\n", pInIoctl->pEntityChunks ));
	VXD_PRINTF(( "pInIoctl->pCachePolicy = %d\n", pInIoctl->pCachePolicy ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByRequestId( pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this request

	if ( pRequest->ulResponseHeadersSent || ( !IsListEmpty( &pRequest->ResponseIrpList ) && pRequest->ulResponseIrpType != UlIrpSend) )
	{
		VXD_PRINTF(( "Response headers were already received" ));
		return UL_ERROR_BAD_COMMAND;
	}
	
	ulBytesToCopy = 0L;
	ulBytesCopied = 0L;

	if ( !IsListEmpty( &pRequest->ResponseIrpList )
		&& pRequest->ulResponseIrpType == UlIrpSend )
	{
		//
		// if somebody alread sent the response heders I complete the IRP
		//

		pResponseIrp =
	    CONTAINING_RECORD(
			pRequest->ResponseIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlSendHttpResponseHeaders() IRP\n" ));

		UlDumpIrpInfo( pResponseIrp );

		VXD_ASSERT( pResponseIrp->ulBytesTransferred == 0 );

		ulBytesToCopy = pResponseIrp->ulBytesToTransfer;

		if ( pInIoctl->ResponseBufferLength >= ulBytesToCopy )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( pResponseIrp->pData, (PBYTE)pInIoctl->pResponseBuffer, pInIoctl->ResponseBufferLength, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesCopied == pInIoctl->ResponseBufferLength );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, pInIoctl->ResponseBufferLength, pResponseIrp->pData, (PBYTE)pInIoctl->pResponseBuffer ));

			pResponseIrp->ulBytesTransferred = ulBytesCopied;
			pRequest->ulResponseHeadersSent = TRUE;

			// all the data was transferred, IO completed synchronously

			pInIoctl->pOverlapped->InternalHigh = ulBytesCopied;
			pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

			// Signal the Event in the Overlapped Structure, just in case
			// they're not checking for return code.
			// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever
			// fail. there's not much we can do if it fails anyway...

			VXD_PRINTF(( "Signaling hEvent %08X\n", hr0Event ));

			bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
			VXD_ASSERT( bOK == TRUE );
		}

		if ( ulBytesCopied < ulBytesToCopy )
		{
			// If the Receive Buffer is NOT large enough we need to fail the IO
			// and set information on the size of the buffer that needs to be
			// allocated to fit all the data to be sent.

			// the I/O didn't complete succesfully because the buffer was too
			// small, return an error and leave the IRP pending

			if ( pInIoctl->pBytesSent != NULL )
			{
				*pInIoctl->pBytesSent = ulBytesToCopy;
			}

			return UL_ERROR_NO_SYSTEM_RESOURCES;
		}

		// Set the number of bytes transferred

		if ( pInIoctl->pBytesSent != NULL )
		{
			*pInIoctl->pBytesSent = ulBytesCopied;
		}

		// Unqueue the pending IRP and clean it up

		RemoveEntryList( &pResponseIrp->List );

		UlCleanupIrp( pResponseIrp, ERROR_SUCCESS );

		// the I/O completed succesfully and all data was transferred, so
			
		return UL_ERROR_SUCCESS;

	} // if

	//
	// Pend the uncompleted Receive at the end of the Irp-Response
	//

	VXD_PRINTF(( "This VxdUlReceiveHttpResponseHeaders() is going to be pended...\n" ));

	// Memory has already been validated
	// The following memory locks include validation again

	pLockedData = VxdLockBufferForRead( pInIoctl->pResponseBuffer, pInIoctl->ResponseBufferLength );
	if ( pLockedData == NULL )
	{
		goto ReceiveHttpResponseHeadersCleanup;
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto ReceiveHttpResponseHeadersCleanup;
	}

	pResponseIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pResponseIrp == NULL )
	{
		goto ReceiveHttpResponseHeadersCleanup;
	}

	VXD_PRINTF(( "New pResponseIrp created in %08X\n", pResponseIrp ));

	// once all memory locks completed successfully we can update the data
	// structures 

    InsertTailList( &pRequest->ResponseIrpList, &pResponseIrp->List );
	pResponseIrp->hProcess = GlobalhProcess;
	pResponseIrp->hThread = GlobalhThread;
	pResponseIrp->hr0Event = hr0Event;
	pResponseIrp->pOverlapped = pLockedOverlapped;
	pResponseIrp->pData = pLockedData;
	pResponseIrp->ulBytesToTransfer = pInIoctl->ResponseBufferLength;
	pResponseIrp->ulBytesTransferred = ulBytesCopied;
	pResponseIrp->pRequestId = NULL;

	pRequest->ulResponseHeadersSending = TRUE;
	pRequest->ulResponseIrpType = UlIrpReceive;

	pLockedOverlapped->InternalHigh = 0;
	pLockedOverlapped->Internal = ERROR_IO_PENDING;

	UlDumpIrpInfo( pResponseIrp );

	return UL_ERROR_IO_PENDING;


ReceiveHttpResponseHeadersCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->ResponseBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pResponseIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlReceiveHttpResponseHeaders()





/***************************************************************************++

Routine Description:

    Performs kernel mode UlReceiveHttpResponseEntityBody().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlReceiveHttpResponseEntityBody(
	IN PDIOCPARAMETERS pParameters
	)
{
	LIST_ENTRY *pProcessList, *pAppPoolList, *pRequestList, *pUriList;
	PUL_IRP_LIST pResponseIrp;
	PUL_URI_LIST pUri;
	PUL_REQUEST_LIST pRequest;
	PUL_APPPOOL_LIST pAppPool;

	HANDLE hr0Event;
	ULONG ulBytesToCopy, ulBytesCopied, ulTotalBytesCopied;
	BOOL bOK;

	BYTE *pLockedData = NULL;
	OVERLAPPED *pLockedOverlapped = NULL;

	PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY pInIoctl = ( PIN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pInIoctl == NULL )
	{
		VXD_PRINTF(( "Invalid input data: pParameters->lpvInBuffer is NULL" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( VxdValidateBuffer( pInIoctl, sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ) ) == NULL )
	{
		VXD_PRINTF(( "Invalid InIoctl buffer\n" ));
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pParameters->cbInBuffer != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ) || pInIoctl->ulSize != sizeof( IN_IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY ) || pParameters->lpvOutBuffer != 0 || pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pInIoctl->pOverlapped == NULL ) // Sync operation not supported
	{
		VXD_PRINTF(( "Sync operations are not supported\n" ));
		return UL_ERROR_NOT_IMPLEMENTED;
	}

	hr0Event = UlVWIN32OpenVxDHandle( pInIoctl->pOverlapped->hEvent );
	if ( hr0Event == NULL ) // Invalid Event Handle
	{
		VXD_PRINTF(( "Invalid Event Handle pOverlapped:%08X hEvent:%08X\n", pInIoctl->pOverlapped, pInIoctl->pOverlapped->hEvent ));
		return UL_ERROR_INVALID_HANDLE;
	}

	// Memory pointers and buffer validation

	if ( VxdValidateBuffer( pInIoctl->pEntityBuffer, pInIoctl->EntityBufferLength ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	if ( pInIoctl->pBytesSent != NULL )
	{
		if ( VxdValidateBuffer( pInIoctl->pBytesSent, sizeof(ULONG) ) == NULL )
		{
			return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
		}
	}

	if ( VxdValidateBuffer( pInIoctl->pOverlapped, sizeof(OVERLAPPED) ) == NULL )
	{
		return UL_ERROR_VXDVALIDATEBUFFER_FAILED;
	}

	// Some debug tracing output.

	VXD_PRINTF(( "pInIoctl->ulSize = %d\n", pInIoctl->ulSize ));
	VXD_PRINTF(( "pInIoctl->RequestId = %016X\n", pInIoctl->RequestId ));
	VXD_PRINTF(( "pInIoctl->Flags = %08X\n", pInIoctl->Flags ));
	VXD_PRINTF(( "pInIoctl->pEntityBuffer = %08X\n", pInIoctl->pEntityBuffer ));
	VXD_PRINTF(( "pInIoctl->EntityBufferLength = %d\n", pInIoctl->EntityBufferLength ));
	VXD_PRINTF(( "pInIoctl->pBytesSent = %08X[%d]\n", pInIoctl->pBytesSent, VAL(pInIoctl->pBytesSent)) );
	VXD_PRINTF(( "pInIoctl->pOverlapped = %08X (%d,%d,%d,%d,%08X)\n",
		pInIoctl->pOverlapped,
		pInIoctl->pOverlapped->Internal,
		pInIoctl->pOverlapped->InternalHigh,
		pInIoctl->pOverlapped->Offset,
		pInIoctl->pOverlapped->OffsetHigh,
		pInIoctl->pOverlapped->hEvent ));

	// data, is valid. we will just double check if process who is sending the
	// data has correctly called UlInitialize() previously.
	// CODEWORK: this check is just a sanity check and is quite expensive so
	// consider avoiding it.

	pProcessList = UlFindProcessInfo( GlobalhProcess );
	if ( pProcessList == NULL ) // Should NEVER occur - Sender didn't call UlInitialize().
	{
		VXD_PRINTF(( "Should NEVER occur: current Process (%08X) didn't call UlInitialize()\n", GlobalhProcess ));
		return UL_ERROR_NOT_READY;
	}

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByRequestId( pInIoctl->RequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	// check for consistency of the state of this response

	if ( !pRequest->ulResponseHeadersSending )
	{
		VXD_PRINTF(( "Can't send the body if Response headers were not sent" ));
		return UL_ERROR_BAD_COMMAND;
	}

	//
	// this is a receive, and we're trying to receive entity body.
	// this receive will complete sync when there is at least one
	// pending send in the queue.
	// we will walk see if there is one pending send, complete it and:
	// 1) ...:
	// 2) ...:
	//
	// special cased will be 0 bytes receives and 0 bytes pending sends:
	// if we have a 0 bytes receive
	// if we have a 0 bytes pending send
	//

	ulTotalBytesCopied = 0L;

	pInIoctl->pOverlapped->InternalHigh = 0;
	pInIoctl->pOverlapped->Internal = ERROR_IO_PENDING;

	if ( !IsListEmpty( &pRequest->ResponseIrpList )
		&& pRequest->ulResponseIrpType == UlIrpSend )
	{
		pResponseIrp =
	    CONTAINING_RECORD(
			pRequest->ResponseIrpList.Flink,
			UL_IRP_LIST,
			List );

		VXD_PRINTF(( "Completing VxdUlSendHttpResponseEntityBody() IRP\n" ));

		UlDumpIrpInfo( pResponseIrp );

		ulBytesCopied = 0L;
		ulBytesToCopy = MIN( pInIoctl->EntityBufferLength - ulTotalBytesCopied, pResponseIrp->ulBytesToTransfer - pResponseIrp->ulBytesTransferred );

		if ( ulBytesToCopy > 0 )
		{
			// copy memory. bugbug: I'm assuming VxdCopyMemory() will not ever fail.
			// (source memory is validated and the destination memory is locked)

			bOK = VxdCopyMemory( pResponseIrp->pData + pResponseIrp->ulBytesTransferred, (PBYTE)pInIoctl->pEntityBuffer, ulBytesToCopy, &ulBytesCopied );
			VXD_ASSERT( bOK == TRUE && ulBytesToCopy == ulBytesCopied );

			VXD_PRINTF(( "Copied %d bytes (out of %d) of memory from %08X to %08X\n", ulBytesCopied, ulBytesToCopy, pResponseIrp->pData + pResponseIrp->ulBytesTransferred, (PBYTE)pInIoctl->pEntityBuffer ));

			ulTotalBytesCopied += ulBytesCopied;
			pResponseIrp->ulBytesTransferred += ulBytesCopied;
		}

		if ( pInIoctl->EntityBufferLength == 0 )
		{
			//
			// input is zero length buffer, we only return
			// how much data is pending and return and error
			//

			*(pInIoctl->pBytesSent) = pResponseIrp->ulBytesToTransfer - pResponseIrp->ulBytesTransferred;

			return UL_ERROR_INSUFFICIENT_BUFFER;
		}

		//
		// update/set information on the data transferred in the
		// pBytesSent parameter supplied and in the overlapped structure
		//

		if ( pInIoctl->pBytesSent != NULL )
		{
			*(pInIoctl->pBytesSent) = ulTotalBytesCopied;
		}

		pInIoctl->pOverlapped->InternalHigh = ulTotalBytesCopied;

		//
		// check for IRP completion
		//
		
		if ( pResponseIrp->ulBytesToTransfer == pResponseIrp->ulBytesTransferred )
		{
			// Unqueue the pending IRP and clean it up

			RemoveEntryList( &pResponseIrp->List );

			UlCleanupIrp( pResponseIrp, ERROR_SUCCESS );
		}

		pInIoctl->pOverlapped->Internal = ERROR_SUCCESS;

		// Signal the Event in the Overlapped Structure.
		// bugbug: I'm assuming VxdSetAndCloseWin32Event() will not ever fail.
		// there's not much to do if it fails anyway...

		VXD_PRINTF(( "Signaling hEvent:%08X\n", hr0Event ));

		bOK = VxdSetAndCloseWin32Event( (PVOID) hr0Event );
		VXD_ASSERT( bOK == TRUE );

		if ( pResponseIrp->ulBytesToTransfer == 0
			&& pResponseIrp->ulBytesTransferred == 0 )
		{
			//
			// this means this is the final call, since the IRP was a 0-bytes
			// we can free all the request informations cause it's complete now
			//

			VXD_PRINTF(( "Request complete, cleaning up\n" ));

			RemoveEntryList( &pRequest->List );

			UlCleanupRequest( pRequest );
		}

		return UL_ERROR_SUCCESS;

	} // if

	//
	// Pend the uncompleted Send at the end of the Irp-Response
	//

	VXD_PRINTF(( "This VxdUlReceiveHttpResponseEntityBody() is going to be pended...\n" ));

	//
	// Memory has already been validated
	// The following memory locks include validation again
	//

	pLockedData = VxdLockBufferForRead( pInIoctl->pEntityBuffer, pInIoctl->EntityBufferLength );
	if ( pLockedData == NULL )
	{
		goto ReceiveHttpResponseEntityBodyCleanup;
	}

	pLockedOverlapped = VxdLockBufferForWrite( pInIoctl->pOverlapped, sizeof(OVERLAPPED) );
	if ( pLockedOverlapped == NULL )
	{
		goto ReceiveHttpResponseEntityBodyCleanup;
	}

	pResponseIrp = ( PUL_IRP_LIST ) VxdAllocMem( sizeof( UL_IRP_LIST ) , 0L );
	if ( pResponseIrp == NULL )
	{
		goto ReceiveHttpResponseEntityBodyCleanup;
	}

	VXD_PRINTF(( "New pResponseIrp created in %08X\n", pResponseIrp ));

	//
	// once all memory locks completed successfully we can update the data
	// structures 
	//

    InsertTailList( &pRequest->ResponseIrpList, &pResponseIrp->List );
	pResponseIrp->hProcess = GlobalhProcess;
	pResponseIrp->hThread = GlobalhThread;
	pResponseIrp->hr0Event = hr0Event;
	pResponseIrp->pOverlapped = pLockedOverlapped;
	pResponseIrp->pData = pLockedData;
	pResponseIrp->ulBytesToTransfer = pInIoctl->EntityBufferLength;
	pResponseIrp->ulBytesTransferred = ulTotalBytesCopied;
	pResponseIrp->pRequestId = NULL;

	pRequest->ulResponseIrpType = UlIrpReceive;

	UlDumpIrpInfo( pResponseIrp );

	return UL_ERROR_IO_PENDING;


ReceiveHttpResponseEntityBodyCleanup:

	//
	// unlock and free memory
	//

	if ( pLockedData != NULL )
	{
		VxdUnlockBuffer( pLockedData, pInIoctl->EntityBufferLength );
	}

	if ( pLockedOverlapped != NULL )
	{
		VxdUnlockBuffer( pLockedOverlapped, sizeof(OVERLAPPED) );
	}

	if ( pResponseIrp == NULL )
	{
		return UL_ERROR_VXDALLOCMEM_FAILED;
	}

	return UL_ERROR_VXDLOCKMEM_FAILED;

} // VxdUlReceiveHttpResponseEntityBody()





/***************************************************************************++

Routine Description:

    Performs kernel mode UlCancelRequest().

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    UL_ERROR_SUCCESS on success, other error codes, as appropriate, on error

--***************************************************************************/

__inline ULONG
__cdecl
VxdUlCancelRequest(
    IN PDIOCPARAMETERS pParameters
    )
{
	LIST_ENTRY *pAppPoolList, *pRequestList, *pUriList;
	PUL_REQUEST_LIST pRequest;
	PUL_URI_LIST pUri;
	PUL_APPPOOL_LIST pAppPool;

	UL_HTTP_REQUEST_ID *pRequestId = (UL_HTTP_REQUEST_ID*) pParameters->lpvInBuffer;

	// Input data validation.

	if ( pParameters->cbInBuffer != sizeof(UL_HTTP_REQUEST_ID)
		|| pParameters->lpvOutBuffer != 0
		|| pParameters->cbOutBuffer != 0 )
	{
		VXD_PRINTF(( "Invalid input data: wrong version\n" ));
		return UL_ERROR_INVALID_DATA;
	}

	if ( pRequestId == NULL
		|| VxdValidateBuffer( pRequestId, sizeof(UL_HTTP_REQUEST_ID) ) == NULL )
	{
		VXD_PRINTF(( "Invalid input data:%08X\n", pRequestId ));
		return UL_ERROR_INVALID_DATA;
	}

	// search for the UL_REQUEST_LIST structure (based on the RequestId)

	pRequestList = UlFindRequestInfoByRequestId( *pRequestId );

	if ( pRequestList == NULL )
	{
		VXD_PRINTF(( "Invalid RequestId" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	pRequest =
    CONTAINING_RECORD(
		pRequestList,
		UL_REQUEST_LIST,
		List );

	RemoveEntryList( &pRequest->List );

	UlCleanupRequest( pRequest );

	return UL_ERROR_SUCCESS;

} // VxdUlCancelRequest




/***************************************************************************++

Routine Description:

    Generic IOCTL dispatch routine.

Arguments:

    pParameters - Supplies a pointer to a DIOCPARAMETERS structure
        defining the parameters passed to DeviceIoControl().

Return Value:

    ULONG - Win32 completion status, -1 for asynchronous completion.

--***************************************************************************/

ULONG
__cdecl
VxdDispatch(
    IN PDIOCPARAMETERS pParameters
    )
{
	ULONG ulStatus;

	// update global variables, since everytime an API gets called we execute
	// this code, we are sure that these variables have always the correct
	// value
	
	GlobalhProcess = (HANDLE)pParameters->tagProcess; // VxdGetCurrentProcess();
	GlobalhThread = VxdGetCurrentThread();

	if ( pParameters == NULL )
	{
		VXD_PRINTF(( "pParameters is NULL\n" ));
		return UL_ERROR_INVALID_HANDLE;
	}

	VXD_PRINTF(( "VxdDispatch() pParameters:%08X hProcess:%08X hThread:%08X\n", pParameters, GlobalhProcess, GlobalhThread ));

	switch ( pParameters->dwIoControlCode )
	{
		case DIOC_GETVERSION:
			VXD_PRINTF(( "[ %08X : %08X ] : DIOC_GETVERSION\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlInitialize( pParameters );
			break;

		case DIOC_CLOSEHANDLE:
			VXD_PRINTF(( "[ %08X : %08X ] : DIOC_CLOSEHANDLE\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlTerminate( pParameters );
			break;

		case IOCTL_UL_CREATE_APPPOOL:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_CREATE_APPPOOL\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlCreateAppPool( pParameters );
			break;

		case IOCTL_UL_CLOSE_APPPOOL:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_CLOSE_APPPOOL\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlCloseAppPool( pParameters );
			break;

		case IOCTL_UL_REGISTER_URI:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_REGISTER_URI\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlRegisterUri( pParameters );
			break;

		case IOCTL_UL_UNREGISTER_URI:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_UNREGISTER_URI\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlUnregisterUri( pParameters );
			break;

		case IOCTL_UL_UNREGISTER_ALL:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_UNREGISTER_ALL\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlUnregisterAll( pParameters );
			break;

		case IOCTL_UL_SEND_HTTP_REQUEST_HEADERS:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_SEND_HTTP_REQUEST_HEADERS\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlSendHttpRequestHeaders( pParameters );
			break;

		case IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlSendHttpRequestEntityBody( pParameters );
			break;

		case IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlReceiveHttpRequestHeaders( pParameters );
			break;

		case IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlReceiveHttpRequestEntityBody( pParameters );
			break;

		case IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlSendHttpResponseHeaders( pParameters );
			break;

		case IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlSendHttpResponseEntityBody( pParameters );
			break;

		case IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlReceiveHttpResponseHeaders( pParameters );
			break;

		case IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlReceiveHttpResponseEntityBody( pParameters );
			break;

		case IOCTL_UL_CANCEL_REQUEST:
			VXD_PRINTF(( "[ %08X : %08X ] : IOCTL_UL_CANCEL_REQUEST\n", GlobalhProcess, GlobalhThread ));
			ulStatus = VxdUlCancelRequest( pParameters );
			break;

		default:
			VXD_PRINTF(( "[ %08X : %08X ] : UNKNOWN ( %08X )\n", GlobalhProcess, GlobalhThread, pParameters->dwIoControlCode ));
			ulStatus = UL_ERROR_BAD_COMMAND;
			break;
	}

	VXD_PRINTF(( "-----------------------\nVxdDispatch() returning %u\n", ulStatus ));
	UlDumpProcessInfo();
	VXD_PRINTF(( "-----------------------\n\n\n\n" ));

	return ulStatus;

}   // VxdDispatch


/*

typedef struct DIOCParams
{
	DWORD Internal1
	DWORD VMHandle
	DWORD Internal2
	DWORD dwIoControlCode
	DWORD lpvInBuffer
	DWORD cbInBuffer
	DWORD lpvOutBuffer
	DWORD cbOutBuffer
	DWORD lpcbBytesReturned
	DWORD lpOverlapped
	DWORD hDevice
	DWORD tagProcess

} DIOCPARAMETERS;

VXD_PRINTF(( "pParameters->Internal1:%08X\n", pParameters->Internal1 ));
VXD_PRINTF(( "pParameters->Internal2:%08X\n", pParameters->Internal2 ));
VXD_PRINTF(( "pParameters->VMHandle:%08X\n", pParameters->VMHandle ));
VXD_PRINTF(( "pParameters->hDevice:%08X\n", pParameters->hDevice ));
VXD_PRINTF(( "pParameters->tagProcess:%08X\n", pParameters->tagProcess ));

HANDLE
VXDINLINE
MyVxdGetCurrentThread( VOID )
{
	HANDLE result;

	_asm push edi // SaveReg <edi>
	VMMCall(Get_Cur_Thread_Handle);
	_asm mov result, edi
	_asm pop edi // RestoreReg <edi>

	return result;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\extcrap.h ===
//
// this header contains a bunch of junk we need to build
// parse.c
//

#ifndef _EXTCRAP_H_
#define _EXTCRAP_H_

/* thrdpool.h */
//
// Pointer to a thread pool worker function.
//

typedef
VOID
(*PUL_WORK_ROUTINE)(
    IN struct _UL_WORK_ITEM * pWorkItem
    );


//
// A work item. A work item may only appear on the work queue once.
//

typedef struct _UL_WORK_ITEM    // WorkItem
{
    LIST_ENTRY QueueListEntry;
    PUL_WORK_ROUTINE pWorkRoutine;

} UL_WORK_ITEM, *PUL_WORK_ITEM;

/* engine.h */
typedef enum _UL_CONN_HDR
{
    ConnHdrNone,
    ConnHdrClose,
    ConnHdrKeepAlive,

    ConnHdrMax
} UL_CONN_HDR;


/* config .h */
//
// Define the additional formal and actual parameters used for the
// various Reference/Dereference functions when reference debugging
// is enabled.
//

#if REFERENCE_DEBUG
#define REFERENCE_DEBUG_FORMAL_PARAMS ,PSTR pFileName,USHORT LineNumber
#define REFERENCE_DEBUG_ACTUAL_PARAMS ,(PSTR)__FILE__,(USHORT)__LINE__
#else   // !REFERENCE_DEBUG
#define REFERENCE_DEBUG_FORMAL_PARAMS
#define REFERENCE_DEBUG_ACTUAL_PARAMS
#endif  // REFERENCE_DEBUG

//
// Pool tags.
//

#if USE_FREE_POOL_WITH_TAG
#define MAKE_TAG(tag)   ( (ULONG)(tag) | PROTECTED_POOL )
#define MyFreePoolWithTag(a,t) ExFreePoolWithTag(a,t)
#else   // !USE_FREE_POOL_WITH_TAG
#define MAKE_TAG(tag)   ( (ULONG)(tag) )
#define MyFreePoolWithTag(a,t) ExFreePool(a)
#endif  // USE_FREE_POOL_WITH_TAG

#define MAKE_FREE_TAG(Tag)  (((Tag) & 0xffffff00) | (ULONG)'x')
#define IS_VALID_TAG(Tag)   (((Tag) & 0x0000ffff) == 'lU' )


// actual tags
#define UL_INTERNAL_REQUEST_POOL_TAG        MAKE_TAG( 'RHlU' )
#define UL_KNOWN_HEADER_POOL_TAG            MAKE_TAG( 'VHlU' )
#define UL_UNKNOWN_HEADER_POOL_TAG          MAKE_TAG( 'HUlU' )
#define URL_POOL_TAG                        MAKE_TAG( 'LUlU' )


/* made 'em up just for this file */
//
// pointers to things we don't care about
//
typedef struct _UL_NONPAGED_RESOURCE * PUL_NONPAGED_RESOURCE;
typedef struct _UL_URL_CONFIG_GROUP_INFO * PUL_URL_CONFIG_GROUP_INFO;

typedef struct _UL_CONNECTION * PUL_CONNECTION;

typedef struct _IRP * PIRP;

typedef struct _UL_CONNECTION * PUL_CONNECTION;

/* proc.h */
NTSTATUS
UlAnsiToULongLong(
    PUCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    );

/* ultdi.h */
VOID
UlLocalAddressFromConnection(
    IN  PUL_CONNECTION pConnection,
    OUT PTA_IP_ADDRESS  pAddress
    );


//
// externs
//

extern ULONG g_UlDebug;

#endif // _EXTCRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\parse.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       27-Apr-1998

Revision History:

    Paul McDaniel (paulmcd)       3-March-1998  finished up

--*/


#include "precomp.h"
#include "parsep.h"
#include "rcvhdrs.h"


//
// The fast verb translation table
//

FAST_VERB_ENTRY FastVerbTable[] =
{
    CREATE_FAST_VERB_ENTRY(GET),
    CREATE_FAST_VERB_ENTRY(PUT),
    CREATE_FAST_VERB_ENTRY(HEAD),
    CREATE_FAST_VERB_ENTRY(POST),
    CREATE_FAST_VERB_ENTRY(DELETE),
    CREATE_FAST_VERB_ENTRY(TRACE),
    CREATE_FAST_VERB_ENTRY(TRACK),
    CREATE_FAST_VERB_ENTRY(OPTIONS),
    CREATE_FAST_VERB_ENTRY(MOVE),
    CREATE_FAST_VERB_ENTRY(COPY),
    CREATE_FAST_VERB_ENTRY(MKCOL),
    CREATE_FAST_VERB_ENTRY(LOCK)
};


//
// The long verb translation table. All verbs more than 7 characters long
// belong in this table.
//

LONG_VERB_ENTRY LongVerbTable[] =
{
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH)
};


//
// The header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
// for nice perf, group unused headers low in the sub-sort order
//
// it's important that the header name is <= 24 characters (3 ULONGLONG's).
//
// response headers are in here also for ResponseHeaderMap.  their handler
// is NULL and they must be at the end of the sort order for that letter.
//

HEADER_MAP_ENTRY HeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(Accept:,
                            HttpHeaderAccept,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Accept-Language:,
                            HttpHeaderAcceptLanguage,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Accept-Encoding:,
                            HttpHeaderAcceptEncoding,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Accept-Charset:,
                            HttpHeaderAcceptCharset,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Authorization:,
                            HttpHeaderAuthorization,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Allow:,
                            HttpHeaderAllow,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Accept-Ranges:,
                            HttpHeaderAcceptRanges,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Age:,
                            HttpHeaderAge,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Connection:,
                            HttpHeaderConnection,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Cache-Control:,
                            HttpHeaderCacheControl,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Cookie:,
                            HttpHeaderCookie,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Length:,
                            HttpHeaderContentLength,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Type:,
                            HttpHeaderContentType,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Encoding:,
                            HttpHeaderContentEncoding,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Language:,
                            HttpHeaderContentLanguage,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Location:,
                            HttpHeaderContentLocation,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-MD5:,
                            HttpHeaderContentMd5,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Content-Range:,
                            HttpHeaderContentRange,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Date:,
                            HttpHeaderDate,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(ETag:,
                            HttpHeaderEtag,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Expect:,
                            HttpHeaderExpect,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Expires:,
                            HttpHeaderExpires,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(From:,
                            HttpHeaderFrom,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Host:,
                            HttpHeaderHost,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(If-Modified-Since:,
                            HttpHeaderIfModifiedSince,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(If-None-Match:,
                            HttpHeaderIfNoneMatch,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(If-Match:,
                            HttpHeaderIfMatch,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(If-Unmodified-Since:,
                            HttpHeaderIfUnmodifiedSince,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(If-Range:,
                            HttpHeaderIfRange,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Last-Modified:,
                            HttpHeaderLastModified,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Location:,
                            HttpHeaderLocation,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Max-Forwards:,
                            HttpHeaderMaxForwards,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Pragma:,
                            HttpHeaderPragma,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Proxy-Authorization:,
                            HttpHeaderProxyAuthorization,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Proxy-Authenticate:,
                            HttpHeaderProxyAuthenticate,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Referer:,
                            HttpHeaderReferer,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Range:,
                            HttpHeaderRange,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Retry-After:,
                            HttpHeaderRetryAfter,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Server:,
                            HttpHeaderServer,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Set-Cookie:,
                            HttpHeaderSetCookie,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Trailer:,
                            HttpHeaderTrailer,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Transfer-Encoding:,
                            HttpHeaderTransferEncoding,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(TE:,
                            HttpHeaderTe,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Upgrade:,
                            HttpHeaderUpgrade,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(User-Agent:,
                            HttpHeaderUserAgent,
                            SingleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Via:,
                            HttpHeaderVia,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(Vary:,
                            HttpHeaderVary,
                            NULL),
    CREATE_HEADER_MAP_ENTRY(Warning:,
                            HttpHeaderWarning,
                            MultipleHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(WWW-Authenticate:,
                            HttpHeaderWwwAuthenticate,
                            NULL)
};

ULONG ResponseHeaderMap[HttpHeaderMaximum];


//
// The header index table. This is initialized by the init code.
//

HEADER_INDEX_ENTRY  HeaderIndexTable[NUMBER_HEADER_INDICIES];

#define NUMBER_FAST_VERB_ENTRIES    (sizeof(FastVerbTable)/sizeof(FAST_VERB_ENTRY))
#define NUMBER_LONG_VERB_ENTRIES    (sizeof(LongVerbTable)/sizeof(LONG_VERB_ENTRY))
#define NUMBER_HEADER_MAP_ENTRIES   (sizeof(HeaderMapTable)/sizeof(HEADER_MAP_ENTRY))

const char DefaultChar = '_';


ULONG
GenerateDateHeader(
    OUT PUCHAR pBuffer
    );


/*++

Routine Description:

    A utility routine to find a token. We take an input pointer, skip any
    preceding LWS, then scan the token until we find either LWS or a CRLF
    pair.

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    TokenLength     - Where to return the length of the token.

Return Value:

    A pointer to the token we found, as well as the length, or NULL if we
    don't find a delimited token.

--*/
PUCHAR
FindWSToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *pTokenLength
    )
{
    PUCHAR  pTokenStart;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First, skip any preceding LWS.
    //

    while (BufferLength > 0 && IS_HTTP_LWS(*pBuffer))
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, fail.
    if (BufferLength == 0)
    {
        return NULL;
    }

    pTokenStart = pBuffer;

    // Now skip over the token, until we see either LWS or a CR or LF.
    while (BufferLength != 0 &&
           (*pBuffer != CR &&
            *pBuffer != SP &&
            *pBuffer != LF &&
            *pBuffer != HT)
           )
    {
        pBuffer++;
        BufferLength--;
    }

    // See why we stopped.
    if (BufferLength == 0)
    {
        // Ran out of buffer before end of token.
        return NULL;
    }

    // Success. Set the token length and return the start of the token.
    *pTokenLength = DIFF(pBuffer - pTokenStart);
    return pTokenStart;

}   // FindWSToken

/*++

Routine Description:

    The slower way to look up a verb. We find the verb in the request and then
    look for it in the LongVerbTable. If it's not found, we'll return
    UnknownVerb. If it can't be parsed we return UnparsedVerb. Otherwise
    we return the verb type.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by pHttpRequest.
    pVerb               - Where we return a pointer to the verb, if it's an
                            unknown ver.
    ppVerbLength        - Where we return the length of the verb
    pBytesTaken         - The total length consumed, including the length of
                            the verb plus preceding & 1 trailing whitespace.

Return Value:

    The verb we found, or the appropriate error.

--*/
NTSTATUS
LookupVerb(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    )
{
    ULONG       TokenLength;
    PUCHAR      pToken;
    PUCHAR      pTempRequest;
    ULONG       TempLength;
    ULONG       i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    // Since we may have gotten here due to a extraneous CRLF pair, skip
    // any of those now. Need to use a temporary variable since
    // the original input pointer and length are used below.

    pTempRequest = pHttpRequest;
    TempLength = HttpRequestLength;

    while ( TempLength != 0 &&
            ((*pTempRequest == CR) || (*pTempRequest == LF)) )
    {
        pTempRequest++;
        TempLength--;
    }

    // First find the verb.

    pToken = FindWSToken(pTempRequest, TempLength, &TokenLength);

    if (pToken == NULL)
    {
        // Didn't find it, let's get more buffer
        //
        pRequest->Verb = HttpVerbUnparsed;

        *pBytesTaken = 0;

        return STATUS_SUCCESS;
    }

    // Make sure we stopped because of a SP.

    if (*(pToken + TokenLength) != SP)
    {
        // Bad verb section!
        //
        pRequest->Verb = HttpVerbInvalid;

        pRequest->ErrorCode = UlErrorVerb;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!LookupVerb(pRequest = %p) ERROR: no space after verb\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Otherwise, we found one, so update bytes taken and look up up in
    // the table.

    *pBytesTaken = DIFF(pToken - pHttpRequest) + TokenLength + 1;

    for (i = 0; i < NUMBER_LONG_VERB_ENTRIES; i++)
    {
        if (LongVerbTable[i].RawVerbLength == TokenLength &&
            RtlEqualMemory(pToken, LongVerbTable[i].RawVerb, TokenLength))
        {
            // Found it.
            //
            pRequest->Verb = LongVerbTable[i].TranslatedVerb;
            return STATUS_SUCCESS;
        }
    }

    // The only other things this could be are an unknown verb or a very
    // small 0.9 request. Since 0.9 requests can only be GETs, check that
    // now.

    if (HttpRequestLength >= (sizeof("GET ") - 1))
    {
        if (RtlEqualMemory(pHttpRequest, "GET ", sizeof("GET ") - 1))
        {
            // This is a GET request.
            //
            pRequest->Verb = HttpVerbGET;
            return STATUS_SUCCESS;
        }
    }

    //
    // If we got here, we searched the table and didn't find it.
    //

    //
    // It's a raw verb
    //

    pRequest->Verb              = HttpVerbUnknown;
    pRequest->pRawVerb          = pToken;
    pRequest->RawVerbLength     = TokenLength;

    //
    // include room for the terminator
    //

    pRequest->TotalRequestSize += (TokenLength + 1) * sizeof(WCHAR);

    return STATUS_SUCCESS;

}   // LookupVerb


/*++

Routine Description:

    A utility routine to parse an absolute URL in a URL string. When this
    is called we already have loaded the entire url into RawUrl.pUrl and
    know that it start with "http".

    this functions job is to set RawUrl.pHost + RawUrl.pAbsPath.

Arguments:

    pRequest        - Pointer to the HTTP_REQUEST

Return Value:

    NTSTATUS

Author:

    Henry Sanders ()                        1998
    Paul McDaniel (paulmcd)                 6-Mar-1999

--*/
NTSTATUS
ParseFullUrl(
    IN  PUL_INTERNAL_REQUEST   pRequest
    )
{
    PUCHAR  pURL;
    ULONG   UrlLength;
    PUCHAR  pUrlStart;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pURL = pRequest->RawUrl.pUrl;
    UrlLength = pRequest->RawUrl.Length;

    //
    // When we're called, we know that the start of the URL must point at
    // an absolute scheme prefix. Adjust for that now.
    //

    pUrlStart = pURL + HTTP_PREFIX_SIZE;
    UrlLength -= HTTP_PREFIX_SIZE;

    //
    // Now check the second half of the absolute URL prefix. We use the larger
    // of the two possible prefix length here to do the check, because even if
    // it's the smaller of the two we'll need the extra bytes after the prefix
    // anyway for the host name.
    //

    if (UrlLength < HTTP_PREFIX2_SIZE)
    {
        pRequest->ErrorCode = UlErrorUrl;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseFullUrl(pRequest = %p) ERROR: no room for URL scheme name\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( (*(PULONG)pUrlStart & HTTP_PREFIX1_MASK) == HTTP_PREFIX1)
    {
        // Valid absolute URL.
        pUrlStart += HTTP_PREFIX1_SIZE;
        UrlLength -= HTTP_PREFIX1_SIZE;
    }
    else
    {
        if ( (*(PULONG)pUrlStart & HTTP_PREFIX2_MASK) == HTTP_PREFIX2)
        {
            // Valid absolute URL.
            pUrlStart += HTTP_PREFIX2_SIZE;
            UrlLength -= HTTP_PREFIX2_SIZE;
        }
        else
        {
            pRequest->ErrorCode = UlErrorUrl;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!ParseFullUrl(pRequest = %p) ERROR: invalid URL scheme name\n",
                        pRequest
                        ));

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    //
    // OK, we've got a valid absolute URL, and we've skipped over
    // the prefix part of it. Save a pointer to the host, and
    // search the host string until we find the trailing slash,
    // which signifies the end of the host/start of the absolute
    // path.
    //

    pRequest->RawUrl.pHost = pUrlStart;

    //
    // scan the host looking for the terminator
    //

    while (UrlLength > 0 && pUrlStart[0] != '/')
    {
        pUrlStart++;
        UrlLength--;
    }

    if (UrlLength == 0)
    {
        //
        // Ran out of buffer, can't happen, we get the full url passed in
        //

        pRequest->ErrorCode = UlErrorUrl;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseFullUrl(pRequest = %p) ERROR: end of host name not found\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Otherwise, pUrlStart points to the start of the absolute path portion.
    //

    pRequest->RawUrl.pAbsPath = pUrlStart;

    return STATUS_SUCCESS;

}   // ParseFullUrl

/*++

Routine Description:

    Look up a header that we don't have in our fast lookup table. This
    could be because it's a header we don't understand, or because we
    couldn't use the fast lookup table due to insufficient buffer length.
    The latter reason is uncommon, but we'll check the input table anyway
    if we're given one. If we find a header match in our mapping table,
    we'll call the header handler. Otherwise we'll try to allocate an
    unknown header element, fill it in and chain it on the http connection.

Arguments:

    pHttpConn           - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderMap          - Pointer to start of an array of header map entries
                            (may be NULL).
    HeaderMapCount      - Number of entries in array pointed to by pHeaderMap.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/
NTSTATUS
LookupHeader(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    IN  PHEADER_MAP_ENTRY   pHeaderMap,
    IN  ULONG               HeaderMapCount,
    OUT ULONG  *            pBytesTaken
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           CurrentOffset;
    ULONG           HeaderNameLength;
    ULONG           i;
    ULONG           BytesTaken;
    ULONG           HeaderValueLength;
    UCHAR           CurrentChar;
    BOOLEAN         EncodedWord;

    PUL_HTTP_UNKNOWN_HEADER     pUnknownHeader;
    PLIST_ENTRY                 pListStart;
    PLIST_ENTRY                 pCurrentListEntry;
    ULONG                       OldHeaderLength;
    PUCHAR                      pHeaderValue;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First, let's find the terminating : of the header name, if there is one.
    // This will also give us the length of the header, which we can then
    // use to search the header map table if we have one.
    //

    for (CurrentOffset = 0; CurrentOffset < HttpRequestLength; CurrentOffset++)
    {
        CurrentChar = *(pHttpRequest + CurrentOffset);

        if (CurrentChar == ':')
        {
            // We've found the end of the header.
            break;
        }
        else
        {
            if (!IS_HTTP_TOKEN(CurrentChar))
            {
                // Uh-oh, this isn't a valid header. What do we do now?
                //
                pRequest->ErrorCode = UlErrorHeader;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "ul!LookupHeader(pRequest = %p) CurrentChar = 0x%x\n"
                            "    ERROR: invalid header char\n",
                            pRequest,
                            CurrentChar
                            ));

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }
        }

    }

    // Find out why we got out. If the current offset is less than the
    // header length, we got out because we found the :.

    if (CurrentOffset < HttpRequestLength)
    {
        // Found the terminator.
        CurrentOffset++;            // Update to point beyond termintor.
        HeaderNameLength = CurrentOffset;
    }
    else
    {
        // Didn't find the :, need more.
        //
        *pBytesTaken = 0;
        goto end;
    }

    // See if we have a header map array we need to search.
    //
    if (pHeaderMap != NULL)
    {
        // We do have an array to search.
        for (i = 0; i < HeaderMapCount; i++)
        {
            ASSERT(pHeaderMap->pHandler != NULL);

            if (HeaderNameLength == pHeaderMap->HeaderLength &&
                _strnicmp(
                    (const char *)(pHttpRequest),
                    (const char *)(pHeaderMap->Header.HeaderChar),
                    HeaderNameLength
                    ) == 0  &&
                pHeaderMap->pHandler != NULL)
            {
                // This header matches. Call the handling function for it.
                Status = (*(pHeaderMap->pHandler))(
                                pRequest,
                                pHttpRequest + HeaderNameLength,
                                HttpRequestLength - HeaderNameLength,
                                pHeaderMap->HeaderID,
                                &BytesTaken
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    goto end;

                // If the handler consumed a non-zero number of bytes, it
                // worked, so return that number plus the header length.

                //
                // BUGBUG - it might be possible for a header handler to
                // encounter an error, for example being unable to
                // allocate memory, or a bad syntax in some header. We
                // need a more sophisticated method to detect this than
                // just checking bytes taken.
                //

                if (BytesTaken != 0)
                {
                    *pBytesTaken = HeaderNameLength + BytesTaken;
                    goto end;
                }

                // Otherwise he didn't take anything, so return 0.
                // we need more buffer
                //
                *pBytesTaken = 0;
                goto end;
            }

            pHeaderMap++;
        }
    }

    // OK, at this point either we had no header map array or none of them
    // matched. We have an unknown header. Just make sure this header is
    // terminated and save a pointer to it.

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pRequest,
                    pHttpRequest + HeaderNameLength,
                    HttpRequestLength - HeaderNameLength,
                    &EncodedWord,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken == 0)
    {
        *pBytesTaken = 0;
        goto end;
    }

    //
    // Strip of the trailing CRLF from the header value length
    //

    HeaderValueLength = BytesTaken - CRLF_SIZE;

    pHeaderValue = pHttpRequest + HeaderNameLength;

    //
    // skip any preceding LWS.
    //

    while ( HeaderValueLength > 0 && IS_HTTP_LWS(*pHeaderValue) )
    {
        pHeaderValue++;
        HeaderValueLength--;
    }

    // Have an unknown header. Search our list of unknown headers,
    // and if we've already seen one instance of this header add this
    // on. Otherwise allocate an unknown header structure and set it
    // to point at this header.

    pListStart = &pRequest->UnknownHeaderList;

    for (pCurrentListEntry = pRequest->UnknownHeaderList.Flink;
         pCurrentListEntry != pListStart;
         pCurrentListEntry = pCurrentListEntry->Flink
        )
    {
        pUnknownHeader = CONTAINING_RECORD(
                            pCurrentListEntry,
                            UL_HTTP_UNKNOWN_HEADER,
                            List
                            );

        //
        // somehow HeaderNameLength includes the ':' character,
        // which is not the case of pUnknownHeader->HeaderNameLength.
        //
        // so we need to adjust for this here
        //

        if ((HeaderNameLength-1) == pUnknownHeader->HeaderNameLength &&
            _strnicmp(
                (const char *)(pHttpRequest),
                (const char *)(pUnknownHeader->pHeaderName),
                (HeaderNameLength-1)
                ) == 0)
        {
            // This header matches.

            OldHeaderLength = pUnknownHeader->HeaderValue.HeaderLength;

            Status = AppendHeaderValue(
                            &pUnknownHeader->HeaderValue,
                            pHeaderValue,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // encoded?
            //

            pUnknownHeader->HeaderValue.Encoded = EncodedWord ? 1 : 0;

            //
            // Successfully appended it. Update the total request
            // length for the length added.  no need to add 1 for
            // the terminator, just add our new char count.
            //

            pRequest->TotalRequestSize +=
                (pUnknownHeader->HeaderValue.HeaderLength
                    - OldHeaderLength) * sizeof(WCHAR);

            //
            // don't subtract for the ':' character, as that character
            // was "taken"
            //

            *pBytesTaken = HeaderNameLength + BytesTaken;
            goto end;

        }   // if (headermatch)

    }   // for (walk list)

    //
    // Didn't find a match. Allocate a new unknown header structure, set
    // it up and add it to the list.
    //

    pUnknownHeader = UL_ALLOCATE_STRUCT(
                            NonPagedPool,
                            UL_HTTP_UNKNOWN_HEADER,
                            UL_UNKNOWN_HEADER_POOL_TAG
                            );

    if (pUnknownHeader == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // subtract the : from the header name length
    //

    pUnknownHeader->HeaderNameLength = HeaderNameLength - 1;
    pUnknownHeader->pHeaderName = pHttpRequest;

    //
    // header value
    //

    pUnknownHeader->HeaderValue.HeaderLength = HeaderValueLength;
    pUnknownHeader->HeaderValue.pHeader = pHeaderValue;

    //
    // null terminate our copy, the terminating CRLF gives
    // us space for this
    //

    pHeaderValue[HeaderValueLength] = ANSI_NULL;

    //
    // flags
    //

    pUnknownHeader->HeaderValue.OurBuffer = 0;
    pUnknownHeader->HeaderValue.Valid = 1;
    pUnknownHeader->HeaderValue.Encoded = EncodedWord ? 1 : 0;

    InsertTailList(&pRequest->UnknownHeaderList, &pUnknownHeader->List);

    pRequest->UnknownHeaderCount++;

    //
    // subtract 1 for the ':' and add space for the 2 terminiators
    //

    pRequest->TotalRequestSize +=
        ((HeaderNameLength - 1 + 1) + HeaderValueLength + 1) * sizeof(WCHAR);


    *pBytesTaken = HeaderNameLength + BytesTaken;

end:
    return Status;

}   // LookupHeader



/*++

Routine Description:

    The routine to parse an individual header. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header in our lookup table. We try first the fast way, and then
    try again the slow way in case there wasn't quite enough data the first
    time.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/

NTSTATUS
ParseHeader(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG  *            pBytesTaken
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               i;
    ULONG               j;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    UCHAR               c;
    PHEADER_MAP_ENTRY   pCurrentHeaderMap;
    ULONG               HeaderMapCount;
    PUL_HTTP_HEADER     pFoundHeader;
    BOOLEAN             SmallHeader = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(HttpRequestLength >= CRLF_SIZE);

    c = *pHttpRequest;

    // message-headers start with field-name [= token]
    //
    if (IS_HTTP_TOKEN(c) == FALSE)
    {
        pRequest->ErrorCode = UlErrorHeader;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseHeader(pRequest = %p) c = 0x%x ERROR: invalid header char\n",
                    pRequest,
                    c
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Does the header start with an alpha?
    //
    if (IS_HTTP_ALPHA(c))
    {
        // Uppercase the character, and find the appropriate set of header map
        // entries.
        //
        c = UPCASE_CHAR(c);

        c -= 'A';

        pCurrentHeaderMap = HeaderIndexTable[c].pHeaderMap;
        HeaderMapCount = HeaderIndexTable[c].Count;

        // Loop through all the header map entries that might match
        // this header, and check them. The count will be 0 if there
        // are no entries that might match and we'll skip the loop.

        for (i = 0; i < HeaderMapCount; i++)
        {

            ASSERT(pCurrentHeaderMap->pHandler != NULL);

            // If we have enough bytes to do the fast check, do it.
            // Otherwise skip this. We may skip a valid match, but if
            // so we'll catch it later.

            if (HttpRequestLength >= pCurrentHeaderMap->MinBytesNeeded)
            {
                for (j = 0; j < pCurrentHeaderMap->ArrayCount; j++)
                {
                    Temp = *(PULONGLONG)(pHttpRequest +
                                            (j * sizeof(ULONGLONG)));

                    if ((Temp & pCurrentHeaderMap->HeaderMask[j]) !=
                        pCurrentHeaderMap->Header.HeaderLong[j] )
                    {
                        break;
                    }
                }

                // See why we exited out.
                if (j == pCurrentHeaderMap->ArrayCount &&
                    pCurrentHeaderMap->pHandler != NULL)
                {
                    // Exited because we found a match. Call the
                    // handler for this header to take cake of this.

                    Status = (*(pCurrentHeaderMap->pHandler))(
                                    pRequest,
                                    pHttpRequest +
                                     pCurrentHeaderMap->HeaderLength,
                                    HttpRequestLength -
                                     pCurrentHeaderMap->HeaderLength,
                                    pCurrentHeaderMap->HeaderID,
                                    &BytesTaken
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;

                    // If the handler consumed a non-zero number of
                    // bytes, it worked, so return that number plus
                    // the header length.


                    if (BytesTaken != 0)
                    {
                        *pBytesTaken = pCurrentHeaderMap->HeaderLength +
                                            BytesTaken;
                        goto end;
                    }

                    // Otherwise need more buffer
                    //
                    *pBytesTaken = 0;
                    goto end;
                }

                // If we get here, we exited out early because a match
                // failed, so keep going.
            }
            else if (SmallHeader == FALSE)
            {
                //
                // Remember that we didn't check a header map entry
                // because the bytes in the buffer was not LONGLONG
                // aligned
                //
                SmallHeader = TRUE;
            }

            // Either didn't match or didn't have enough bytes for the
            // check. In either case, check the next header map entry.

            pCurrentHeaderMap++;
        }

        // Got all the way through the appropriate header map entries
        // without a match. This could be because we're dealing with a
        // header we don't know about or because it's a header we
        // care about that was too small to do the fast check. The
        // latter case should be very rare, but we still need to
        // handle it.

        // Update the current header map pointer to point back to the
        // first of the possibles. If there were no possibles,
        // the pointer will be NULL and the HeaderMapCount 0, so it'll
        // stay NULL. Otherwise the subtraction will back it up the
        // appropriate amount.

        if (SmallHeader)
        {
            pCurrentHeaderMap -= HeaderMapCount;
        }
        else
        {
            pCurrentHeaderMap = NULL;
            HeaderMapCount = 0;
        }

    }
    else
    {
        pCurrentHeaderMap = NULL;
        HeaderMapCount = 0;
    }

    // At this point either the header starts with a non-alphabetic
    // character or we don't have a set of header map entries for it.

    Status = LookupHeader(
                    pRequest,
                    pHttpRequest,
                    HttpRequestLength,
                    pCurrentHeaderMap,
                    HeaderMapCount,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    // Lookup header returns the total bytes taken, including the header name
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // ParseHeader

NTSTATUS
ParseHeaders(
    PUL_INTERNAL_REQUEST pRequest,
    PUCHAR pBuffer,
    ULONG BufferLength,
    PULONG pBytesTaken
    )
{
    NTSTATUS Status;
    ULONG BytesTaken;

    *pBytesTaken = 0;

    //
    // loop over all headers
    //

    while (BufferLength >= CRLF_SIZE)
    {

        //
        // If this is an empty header, we're done with this stage
        //

        if (*(PUSHORT)pBuffer == CRLF ||
            *(PUSHORT)pBuffer == LFLF)
        {

            //
            // consume it
            //

            pBuffer += CRLF_SIZE;
            *pBytesTaken += CRLF_SIZE;
            BufferLength -= CRLF_SIZE;

            Status = STATUS_SUCCESS;
            goto end;
        }

        // Otherwise call our header parse routine to deal with this.

        Status = ParseHeader(
                        pRequest,
                        pBuffer,
                        BufferLength,
                        &BytesTaken
                        );

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // If no bytes were consumed, the header must be incomplete, so
        // bail out until we get more data on this connection.
        //

        if (BytesTaken == 0)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // Otherwise we parsed a header, so update and continue.
        //

        pBuffer += BytesTaken;
        *pBytesTaken += BytesTaken;
        BufferLength -= BytesTaken;

    }

    //
    // we only get here if we didn't see the CRLF headers terminator
    //
    // we need more data
    //

    Status = STATUS_MORE_PROCESSING_REQUIRED;

end:

    return Status;

}    // ParseHeaders

NTSTATUS
ParseChunkLength(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesTaken,
    OUT PULONGLONG pChunkLength
    )
{
    NTSTATUS Status;
    PUCHAR  pToken;
    UCHAR   SaveChar;
    ULONG   TokenLength;
    BOOLEAN Encoded;
    ULONG   BytesTaken;
    ULONG   TotalBytesTaken = 0;

    ASSERT(pBytesTaken != NULL);
    ASSERT(pChunkLength != NULL);

    //
    // 2 cases:
    //
    //  1) the first chunk where the length follows the headers
    //  2) subsequent chunks where the length follows a previous chunk
    //
    // in case 1 pBuffer will point straight to the chunk length.
    //
    // in case 2 pBuffer will point to the CRLF that terminated the previous
    // chunk, this needs to be consumed, skipped, and then the chunk length
    // read.

    //
    // BUGBUG: need to handle chunk-extensions embedded in the length field
    //


    //
    // if we are case 2 (see above)
    //

    if (pRequest->ParsedFirstChunk == 1)
    {
        //
        // make sure there is enough space first
        //

        if (BufferLength < CRLF_SIZE)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // now it better be a terminator
        //

        if (*(PUSHORT)pBuffer != CRLF &&
            *(PUSHORT)pBuffer != LFLF)
        {
            UlTrace(PARSER, (
                "ul!ParseChunkLength(pRequest = %p) ERROR: No CRLF at the end of chunk-data\n",
                pRequest
                ));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        //
        // update our book-keeping
        //

        pBuffer += CRLF_SIZE;
        TotalBytesTaken += CRLF_SIZE;
        BufferLength -= CRLF_SIZE;
    }

    pToken = FindWSToken(pBuffer, BufferLength, &TokenLength);
    if (pToken == NULL)
    {
        //
        // not enough buffer
        //

        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;

    }

    //
    // Was there any token ?
    //

    if (TokenLength == 0)
    {
        UlTrace(PARSER, (
            "ul!ParseChunkLength(pRequest = %p) ERROR: No length!\n",
            pRequest
            ));

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Add the bytes consumed by FindWSToken
    // (the token bytes plus preceding bytes)
    //

    TotalBytesTaken += DIFF((pToken + TokenLength) - pBuffer);

    //
    // and find the end
    //

    Status = FindHeaderEnd(
                    pRequest,
                    pToken + TokenLength,
                    BufferLength - DIFF((pToken + TokenLength) - pBuffer),
                    &Encoded,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken == 0)
    {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;
    }

    TotalBytesTaken += BytesTaken;

    //
    // now update the HTTP_REQUEST
    //

    SaveChar = pToken[TokenLength];
    pToken[TokenLength] = ANSI_NULL;

    Status = UlAnsiToULongLong(
                    pToken,
                    16,                             // Base
                    pChunkLength
                    );

    pToken[TokenLength] = SaveChar;

    //
    // Did the number conversion fail ?
    //

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (Status == STATUS_SECTION_TOO_BIG)
        {
            pRequest->ErrorCode = UlErrorEntityTooLarge;
        }
        else
        {
            pRequest->ErrorCode = UlErrorNum;
        }

        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseChunkLength(pRequest = %p) ERROR: didn't grok chunk length\n",
                    pRequest
                    ));

        goto end;
    }

    //
    // all done, return the bytes consumed
    //

    *pBytesTaken = TotalBytesTaken;

end:

    RETURN(Status);

}   // ParseChunkLength

/*++

Routine Description:

    This is the core HTTP protocol request engine. It takes a stream of bytes
    and parses them as an HTTP request.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by HttpRequest.

Return Value:

    Status of parse attempt.

--*/
NTSTATUS
ParseHttp(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG               *pBytesTaken
    )

{
    ULONG           OriginalBufferLength;
    ULONG           TokenLength;
    ULONG           CurrentBytesTaken;
    ULONG           TotalBytesTaken;
    ULONG           i;
    NTSTATUS        ReturnStatus;
    PUCHAR          pStart;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_HTTP_REQUEST( pRequest ) );

    ReturnStatus = STATUS_SUCCESS;
    TotalBytesTaken = 0;

    //
    // remember the original buffer length
    //

    OriginalBufferLength = HttpRequestLength;

    //
    // put this label here to allow for a manual re-pump of the
    // parser.  this is currently used for 0.9 requests.
    //

parse_it:

    //
    // what state are we in ?
    //

    switch (pRequest->ParseState)
    {
    case ParseVerbState:

        // Look through the fast verb table for the verb. We can only do
        // this if the input data is big enough.
        if (HttpRequestLength >= sizeof(ULONGLONG))
        {
            ULONGLONG   RawInputVerb;

            RawInputVerb = *(ULONGLONG *)pHttpRequest;

            // Loop through the fast verb table, looking for the verb.
            for (i = 0; i < NUMBER_FAST_VERB_ENTRIES;i++)
            {
                // Mask out the raw input verb and compare against this
                // entry.

                if ((RawInputVerb & FastVerbTable[i].RawVerbMask) ==
                    FastVerbTable[i].RawVerb.LongLong)
                {
                    // It matched. Save the translated verb from the
                    // table, update the request pointer and length,
                    // switch states and get out.

                    pRequest->Verb = FastVerbTable[i].TranslatedVerb;
                    CurrentBytesTaken = FastVerbTable[i].RawVerbLength;

                    pRequest->ParseState = ParseUrlState;
                    break;
                }
            }
        }

        if (pRequest->ParseState != ParseUrlState)
        {
            // Didn't switch states yet, because we haven't found the
            // verb yet. This could be because a) the incoming request
            // was too small to allow us to use our fast lookup (which
            // might be OK in an HTTP/0.9 request), or b) the incoming
            // verb is a PROPFIND or such that is too big to fit into
            // our fast find table, or c) this is an unknown verb. In
            // any of these cases call our slower verb parser to try
            // again.

            ReturnStatus = LookupVerb(
                                pRequest,
                                pHttpRequest,
                                HttpRequestLength,
                                &CurrentBytesTaken
                                );

            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            if (CurrentBytesTaken == 0)
            {
                ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                goto end;
            }

            //
            // we finished parsing the custom verb
            //

            pRequest->ParseState = ParseUrlState;

        }

        //
        // now fall through to ParseUrlState
        //

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

    case ParseUrlState:

        //
        // We're parsing the URL. pHTTPRequest points to the incoming URL,
        // HttpRequestLength is the length of this request that is left.
        //

        //
        // Find the WS terminating the URL.
        //

        pRequest->RawUrl.pUrl = FindWSToken(
                                    pHttpRequest,
                                    HttpRequestLength,
                                    &TokenLength
                                    );

        if (pRequest->RawUrl.pUrl == NULL)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // Bytes taken includes WS in front of URL
        //
        CurrentBytesTaken = DIFF(pRequest->RawUrl.pUrl - pHttpRequest) + TokenLength;

        //
        // set url length
        //

        pRequest->RawUrl.Length = TokenLength;

        //
        // Now, let's see if this is an absolute URL.
        //

        // BUGBUG: this is not case-insens.

        if (pRequest->RawUrl.Length >= HTTP_PREFIX_SIZE &&
            (*(PULONG)(pRequest->RawUrl.pUrl) & HTTP_PREFIX_MASK) ==
                HTTP_PREFIX)
        {
            //
            // It is.  let's parse it and find the host.
            //

            ReturnStatus = ParseFullUrl(pRequest);
            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;
        }
        else
        {
            pRequest->RawUrl.pHost  = NULL;
            pRequest->RawUrl.pAbsPath = pRequest->RawUrl.pUrl;
        }

        //
        // count the space it needs in the user's buffer, including terminator.
        //

        pRequest->TotalRequestSize +=
            (pRequest->RawUrl.Length + 1) * sizeof(WCHAR);

        //
        // adjust our book keeping vars
        //

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;

        TotalBytesTaken += CurrentBytesTaken;

        //
        // fall through to parsing the version.
        //

        pRequest->ParseState = ParseVersionState;

    case ParseVersionState:

        //
        // skip lws
        //

        pStart = pHttpRequest;

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // is this a 0.9 request (no version) ?
        //

        if (HttpRequestLength >= CRLF_SIZE)
        {
            if (*(PUSHORT)(pHttpRequest) == CRLF ||
                *(PUSHORT)(pHttpRequest) == LFLF)
            {
                // This IS a 0.9 request. No need to go any further,
                // since by definition there are no more headers.
                // Just update things and get out.

                TotalBytesTaken += DIFF(pHttpRequest - pStart) + CRLF_SIZE;

                HTTP_SET_VERSION(pRequest->Version, 0, 9);

                //
                // set the state to CookState so that we parse the url
                //

                pRequest->ParseState = ParseCookState;

                //
                // manually restart the parse switch, we changed the
                // parse state
                //

                goto parse_it;
            }
        }

        //
        // do we have enough buffer to strcmp the version?
        //

        if (HttpRequestLength < MIN_VERSION_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // let's compare it
        //

        if (*(PULONGLONG)pHttpRequest == HTTP_11_VERSION)
        {
            HTTP_SET_VERSION(pRequest->Version, 1, 1);
        }
        else
        {
            if (*(PULONGLONG)pHttpRequest == HTTP_10_VERSION)
            {
                HTTP_SET_VERSION(pRequest->Version, 1, 0);
            }
            else
            {
                // BUGBUG for now this is OK. In the future need to add code
                // to check the major version number and handle as a 1.1
                // request if we can.

                pRequest->ErrorCode = UlErrorVersion;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "ul!ParseHttp(pRequest = %p) ERROR: unknown HTTP version\n",
                            pRequest
                            ));


                ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

        }

        HttpRequestLength -= MIN_VERSION_SIZE;
        pHttpRequest += MIN_VERSION_SIZE;

        //
        // skip lws
        //

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // Make sure we're terminated on this line.
        //

        if (HttpRequestLength < CRLF_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        if (*(PUSHORT)pHttpRequest != CRLF && *(PUSHORT)pHttpRequest != LFLF)
        {
            // Might want to be more liberal, and see if there's space
            // after the version. This also could be a sub-version withing
            // HTTP/1.1, ie HTTP/1.11 or something like that.

            pRequest->ErrorCode = UlErrorVersion;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!ParseHttp(pRequest = %p) ERROR: HTTP version not terminated right\n",
                        pRequest
                        ));

            ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        pHttpRequest += CRLF_SIZE;
        HttpRequestLength -= CRLF_SIZE;

        TotalBytesTaken += DIFF(pHttpRequest - pStart);

        pRequest->ParseState = ParseHeadersState;

    case ParseHeadersState:

        ReturnStatus = ParseHeaders(
                            pRequest,
                            pHttpRequest,
                            HttpRequestLength,
                            &CurrentBytesTaken
                            );

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

        if (NT_SUCCESS(ReturnStatus) == FALSE)
            goto end;

        //
        // fall through, this is the only way to get here, we never return pending
        // in this state
        //

        pRequest->ParseState = ParseCookState;

    case ParseCookState:

        //
        // time for post processing.  cook it up!
        //

        {
            //
            // First cook up the url, unicode it + such.
            //

            ReturnStatus = UlpCookUrl(pRequest);
            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            //
            // mark if we are chunk encoded
            //

            if (pRequest->Headers[HttpHeaderTransferEncoding].Valid == 1)
            {
                ASSERT(pRequest->Headers[HttpHeaderTransferEncoding].pHeader != NULL);

                //
                // CODEWORK, there can be more than 1 encoding
                //

                if (_stricmp(
                        (const char *)(
                            pRequest->Headers[HttpHeaderTransferEncoding].pHeader
                            ),
                        "chunked"
                        ) == 0)
                {
                    pRequest->Chunked = 1;
                }
                else
                {
                    //
                    // CODEWORK: temp hack for bug#352
                    //

                    UlTrace(PARSER, (
                                "ul!ParseHttp(pRequest = %p)"
                                    " ERROR: unknown Transfer-Encoding!\n",
                                pRequest
                                ));

                    pRequest->ErrorCode = UlErrorNotImplemented;
                    pRequest->ParseState = ParseErrorState;

                    ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto end;
                }
            }

            //
            // Now let's decode the content length header
            //

            if (pRequest->Headers[HttpHeaderContentLength].Valid == 1)
            {
                ASSERT(pRequest->Headers[HttpHeaderContentLength].pHeader != NULL);

                ReturnStatus = UlAnsiToULongLong(
                                    pRequest->Headers[HttpHeaderContentLength].pHeader,
                                    10,
                                    &pRequest->ContentLength
                                    );

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                {
                    if (ReturnStatus == STATUS_SECTION_TOO_BIG)
                    {
                        pRequest->ErrorCode = UlErrorEntityTooLarge;
                    }
                    else
                    {
                        pRequest->ErrorCode = UlErrorNum;
                    }

                    pRequest->ParseState = ParseErrorState;

                    UlTrace(PARSER, (
                                "ul!ParseHttp(pRequest = %p) ERROR: couldn't decode Content-Length\n",
                                pRequest
                                ));

                    goto end;
                }

                if (pRequest->Chunked == 0)
                {
                    //
                    // prime the first (and only) chunk size
                    //

                    pRequest->ChunkBytesToParse = pRequest->ContentLength;
                    pRequest->ChunkBytesToRead = pRequest->ContentLength;
                }

            }

        }

        pRequest->ParseState = ParseEntityBodyState;

        //
        // fall through
        //

    case ParseEntityBodyState:

        //
        // the only parsing we do here is chunk length calculation,
        // and that is not necessary if we have no more bytes to parse
        //

        if (pRequest->ChunkBytesToParse == 0)
        {
            //
            // no more bytes left to parse, let's see if there are any
            // more in the request
            //

            if (pRequest->Chunked == 1)
            {

                //
                // the request is chunk encoded
                //

                //
                // attempt to read the size of the next chunk
                //

                ReturnStatus = ParseChunkLength(
                                    pRequest,
                                    pHttpRequest,
                                    HttpRequestLength,
                                    &CurrentBytesTaken,
                                    &(pRequest->ChunkBytesToParse)
                                    );

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                    goto end;

                //
                // Otherwise we parsed it, so update and continue.
                //

                pHttpRequest += CurrentBytesTaken;
                TotalBytesTaken += CurrentBytesTaken;
                HttpRequestLength -= CurrentBytesTaken;

                //
                // was this the first chunk?
                //

                if (pRequest->ParsedFirstChunk == 0)
                {
                    //
                    // Prime the reader, let it read the first chunk
                    // even though we haven't quite parsed it yet....
                    //

                    pRequest->ChunkBytesToRead = pRequest->ChunkBytesToParse;

                    pRequest->ParsedFirstChunk = 1;

                }

                //
                // is this the last chunk (denoted with a 0 byte chunk)?
                //

                if (pRequest->ChunkBytesToParse == 0)
                {
                    //
                    // time to parse the trailer
                    //

                    pRequest->ParseState = ParseTrailerState;

                }

            }
            else    // if (pRequest->Chunked == 1)
            {
                //
                // not chunk-encoded , all done
                //

                pRequest->ParseState = ParseDoneState;
            }

        }   // if (pRequest->ChunkBytesToParse == 0)

        //
        // looks all good
        //

        if (pRequest->ParseState != ParseTrailerState)
        {
            break;
        }


    case ParseTrailerState:

        //
        // parse any existing trailer
        //
        // ParseHeaders will bail immediately if CRLF is
        // next in the buffer (no trailer)
        //

        ReturnStatus = ParseHeaders(
                            pRequest,
                            pHttpRequest,
                            HttpRequestLength,
                            &CurrentBytesTaken
                            );

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

        if (NT_SUCCESS(ReturnStatus) == FALSE)
            goto end;

        //
        // all done
        //

        pRequest->ParseState = ParseDoneState;

        break;

    default:
        //
        // this should never happen!
        //
        ASSERT(FALSE);
        break;

    }   // switch (pRequest->ParseState)

end:
    *pBytesTaken = TotalBytesTaken;

    if (ReturnStatus == STATUS_MORE_PROCESSING_REQUIRED &&
        TotalBytesTaken == OriginalBufferLength)
    {
        //
        // convert this to success, we consumed the entire buffer
        //

        ReturnStatus = STATUS_SUCCESS;
    }

    UlTrace(PARSER, (
        "ul!ParseHttp returning 0x%x, (%p)->ParseState = %d, bytesTaken = %d\n",
        ReturnStatus,
        pRequest,
        pRequest->ParseState,
        TotalBytesTaken
        ));

    return ReturnStatus;
}   // ParseHttp

/*++

Routine Description:

    Routine to initialize the parse code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeParser(
    VOID
    )
{
    ULONG               i;
    ULONG               j;
    PHEADER_MAP_ENTRY   pHeaderMap;
    PHEADER_INDEX_ENTRY pHeaderIndex;
    UCHAR               c;

    //
    // Make sure the entire table starts life as zero
    //
    RtlZeroMemory(&HeaderIndexTable, sizeof(HeaderIndexTable));

    for (i = 0; i < NUMBER_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &HeaderMapTable[i];

        //
        // Map the header to upper-case.
        //

        for (j = 0 ; j < pHeaderMap->HeaderLength ; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];

            if ((c >= 'a') && (c <= 'z'))
            {
                pHeaderMap->Header.HeaderChar[j] = c - ('a' - 'A');
            }
        }

        //
        // response headers are hidden in here, leave them untouched
        // at the end of a letter-run.
        //

        if (pHeaderMap->pHandler != NULL)
        {
            c = pHeaderMap->Header.HeaderChar[0];
            pHeaderIndex = &HeaderIndexTable[c - 'A'];

            if (pHeaderIndex->pHeaderMap == NULL)
            {
                pHeaderIndex->pHeaderMap = pHeaderMap;
                pHeaderIndex->Count = 1;
            }
            else
            {
                pHeaderIndex->Count++;
            }
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] = CREATE_HEADER_MASK(
                                            pHeaderMap->HeaderLength,
                                            sizeof(ULONGLONG) * (j+1)
                                            );
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

        //
        // setup the mapping from header id to map table index
        //

        ResponseHeaderMap[pHeaderMap->HeaderID] = i;

    }

    return STATUS_SUCCESS;

}   // InitializeParser


ULONG
UlpFormatPort(
    OUT PWSTR pString,
    IN ULONG Port
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;
    ULONG length;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Fast-path common ports. While we're at it, special case port 0,
    // which is definitely not common, but handling it specially makes
    // the general conversion code a bit simpler.
    //

    switch (Port)
    {
    case 0:
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 1;

    case 80:
        *pString++ = L'8';
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 2;

    case 443:
        *pString++ = L'4';
        *pString++ = L'4';
        *pString++ = L'3';
        *pString = UNICODE_NULL;
        return 3;
    }

    //
    // Pull the least signifigant digits off the port value and store them
    // into the pString. Note that this will store the digits in reverse
    // order.
    //

    p1 = p2 = pString;

    while (Port != 0)
    {
        digit = Port % 10;
        Port = Port / 10;

        *p1++ = L'0' + (WCHAR)digit;
    }

    length = DIFF(p1 - pString);

    //
    // Reverse the digits in the pString.
    //

    *p1-- = UNICODE_NULL;

    while (p1 > p2)
    {
        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;
    }

    return length;

}   // UlpFormatPort


NTSTATUS
UlpCookUrl(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS    Status;
    PUCHAR      pHost;
    ULONG       HostLength;
    PUCHAR      pAbsPath;
    ULONG       AbsPathLength;
    ULONG       UrlLength;
    ULONG       PortLength;
    ULONG       LengthCopied;
    PWSTR       pUrl = NULL;
    PWSTR       pCurrent;
    ULONG       Index;
    BOOLEAN     PortInUrl;
    CHAR        IpAddressString[MAX_ADDRESS_LENGTH+1];
    USHORT      IpPortNum;
    BOOLEAN     HostFromTransport = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // We must have already parsed the entire headers + such
    //

    if (pRequest->ParseState < ParseCookState)
        return STATUS_INVALID_DEVICE_STATE;

    //
    // better have an absolute url .
    //

    if (pRequest->RawUrl.pAbsPath[0] != '/')
    {

        //
        // allow * for Verb = OPTIONS
        //

        if (pRequest->RawUrl.pAbsPath[0] == '*' &&
            pRequest->Verb == HttpVerbOPTIONS)
        {
            // ok
        }
        else
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    }

    //
    // collect the host + abspath sections
    //

    if (pRequest->RawUrl.pHost != NULL)
    {
        pHost = pRequest->RawUrl.pHost;
        HostLength = DIFF(pRequest->RawUrl.pAbsPath - pRequest->RawUrl.pHost);

        pAbsPath = pRequest->RawUrl.pAbsPath;
        AbsPathLength = pRequest->RawUrl.Length - DIFF(pAbsPath - pRequest->RawUrl.pUrl);

    }
    else
    {
        pHost = NULL;
        HostLength = 0;

        pAbsPath = pRequest->RawUrl.pAbsPath;
        AbsPathLength = pRequest->RawUrl.Length;
    }

    //
    // found a host yet?
    //

    if (pHost == NULL)
    {
        //
        // do we have a host header?
        //

        if (pRequest->Headers[HttpHeaderHost].pHeader != NULL )
        {

            pHost       = pRequest->Headers[HttpHeaderHost].pHeader;
            HostLength  = pRequest->Headers[HttpHeaderHost].HeaderLength;

        }
        else
        {
            TA_IP_ADDRESS   RawAddress = { 0 };
            ULONG           CharCopied;
            ULONG           IpAddress;

            //
            // first, if this was a 1.1 client, it's an invalid request
            // to not have a host header, fail it.
            //

            if (HTTP_EQUAL_VERSION(pRequest->Version, 1, 1))
            {
                pRequest->ErrorCode = UlErrorHost;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "ul!UlpCookUrl(pRequest = %p) ERROR: 1.1 request w/o host header\n",
                            pRequest
                            ));

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

            //
            // get the ip address from the transport
			//

			/*
            UlLocalAddressFromConnection(
                pRequest->pHttpConn->pConnection,
                &RawAddress
                );

            IpPortNum = SWAP_SHORT(RawAddress.Address[0].Address[0].sin_port);
            IpAddress = SWAP_LONG(RawAddress.Address[0].Address[0].in_addr);
            */

			IpAddress = SWAP_LONG( (ULONG) (pRequest->ConnectionId >> 32) );
			IpPortNum = SWAP_SHORT( (USHORT) (pRequest->ConnectionId & 0x000000FF) );


            //
            // format it into a string
            //

            pHost = (PUCHAR)(IpAddressString);

            HostLength = sprintf(
                                IpAddressString,
                                "%d.%d.%d.%d:%d",
                                (UCHAR)(IpAddress >> 24),
                                (UCHAR)(IpAddress >> 16),
                                (UCHAR)(IpAddress >> 8),
                                (UCHAR)(IpAddress >> 0),
                                IpPortNum
                                );

            ASSERT(HostLength < sizeof(IpAddressString) - 1);

            HostFromTransport = TRUE;
            PortInUrl = TRUE;

        }

    }

    if (HostFromTransport == FALSE)
    {

        //
        // is there a port # already there ?
        //

        Index = HostLength;

        while (Index > 0)
        {
            Index -= 1;

            if (pHost[Index] == ':')
                break;

        }

        if (Index == 0)
        {
            TA_IP_ADDRESS   RawAddress = { 0 };

            PortInUrl = FALSE;

            //
            // no port number, get the port number from the transport
            //
            // we could simply assume port 80 at this point, but some
            // browsers don't sent the port number in the host header
            // even when their supposed to
            //

			/*
            UlLocalAddressFromConnection(
                pRequest->pHttpConn->pConnection,
                &RawAddress
                );

            IpPortNum = SWAP_SHORT(RawAddress.Address[0].Address[0].sin_port);
            */

			IpPortNum = SWAP_SHORT( (USHORT) (pRequest->ConnectionId & 0x000000FF) );
        }
        else
        {
            PortInUrl = TRUE;
        }
    }

    UrlLength = (HTTP_PREFIX_SIZE+HTTP_PREFIX2_SIZE) +
                HostLength +
                (sizeof(":")-1) +
                MAX_PORT_LENGTH +
                AbsPathLength;

    UrlLength *= sizeof(WCHAR);

    //
    // allocate a new buffer to hold this guy
    //

    pUrl = UL_ALLOCATE_ARRAY(
                NonPagedPool,
                WCHAR,
                (UrlLength/sizeof(WCHAR)) + 1,
                URL_POOL_TAG
                );

    if (pUrl == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pRequest->CookedUrl.pUrl = pCurrent = pUrl;

    //
    // compute the scheme
    //

    if (FALSE)
    {
        //
        // yep, ssl
        //

        // CODEWORK

        // copy the NULL for the hash function to work
        //
        RtlCopyMemory(pCurrent, L"https://", sizeof(L"https://"));

        pRequest->CookedUrl.Hash     = HashStringW(pCurrent, 0);

        pCurrent                    += (sizeof(L"https://")-sizeof(WCHAR)) / sizeof(WCHAR);
        pRequest->CookedUrl.Length   = (sizeof(L"https://")-sizeof(WCHAR));

    }
    else
    {
        //
        // not ssl
        //

        RtlCopyMemory(pCurrent, L"http://", sizeof(L"http://"));

        pRequest->CookedUrl.Hash     = HashStringW(pCurrent, 0);

        pCurrent                    += (sizeof(L"http://")-sizeof(WCHAR)) / sizeof(WCHAR);
        pRequest->CookedUrl.Length   = (sizeof(L"http://")-sizeof(WCHAR));

    }

    //
    // assemble the rest of the url
    //

    //
    // host
    //

    Status = UlpCleanAndCopyUrl(
                    HostName,
                    pCurrent,
                    pHost,
                    HostLength,
                    &LengthCopied,
                    NULL,
                    &pRequest->CookedUrl.Hash
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pRequest->CookedUrl.pHost   = pCurrent;
    pRequest->CookedUrl.Length += LengthCopied;

    pCurrent += LengthCopied / sizeof(WCHAR);


    //
    // port
    //


    if (PortInUrl == FALSE)
    {
        *pCurrent = L':';

        PortLength = UlpFormatPort( pCurrent+1, IpPortNum ) + 1;

        //
        // update the running hash
        //
        pRequest->CookedUrl.Hash = HashStringW(pCurrent, pRequest->CookedUrl.Hash);

        pCurrent += PortLength;

        //
        // swprintf returns char not byte count
        //

        pRequest->CookedUrl.Length += PortLength * sizeof(WCHAR);

    }


    // abs_path
    //
    Status = UlpCleanAndCopyUrl(
                    AbsPath,
                    pCurrent,
                    pAbsPath,
                    AbsPathLength,
                    &LengthCopied,
                    &pRequest->CookedUrl.pQueryString,
                    &pRequest->CookedUrl.Hash
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pRequest->CookedUrl.pAbsPath = pCurrent;
    pRequest->CookedUrl.Length  += LengthCopied;

    ASSERT(pRequest->CookedUrl.Length <= UrlLength);

    //
    // Update pRequest, include space for the terminator
    //

    pRequest->TotalRequestSize += pRequest->CookedUrl.Length + sizeof(WCHAR);

    //
    // let's just make sure the hash is the right value
    //
    ASSERT(pRequest->CookedUrl.Hash == HashStringW(pRequest->CookedUrl.pUrl, 0));

    //
    // Scramble it
    //

    pRequest->CookedUrl.Hash = HashScramble(pRequest->CookedUrl.Hash);

    ASSERT(pRequest->CookedUrl.pHost != NULL);
    ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

    //
    // validate the host part of the url
    //

    pCurrent = wcschr(pRequest->CookedUrl.pHost, L':');

    //
    // Check for :
    //
    //      No colon ||
    //
    //      no hostname ||
    //
    //      No colon in the host OR no port number.
    //

    if (pCurrent == NULL ||
        pCurrent == pRequest->CookedUrl.pHost ||
        pCurrent >= (pRequest->CookedUrl.pAbsPath-1))
    {
        //
        // bad.  no colon for the port.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // skip the colon
    //

    pCurrent += 1;

    //
    // now make sure the port number is in good shape
    //

    while (pCurrent < pRequest->CookedUrl.pAbsPath)
    {
        if (IS_HTTP_DIGIT(pCurrent[0]) == FALSE)
        {
            //
            // bad.  non digit.
            //
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
        pCurrent += 1;
    }

    Status = STATUS_SUCCESS;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pUrl != NULL)
        {
            UL_FREE_POOL(pUrl, URL_POOL_TAG);
            RtlZeroMemory(&pRequest->CookedUrl, sizeof(pRequest->CookedUrl));
        }

        //
        // has a specific error code been set?
        //

        if (pRequest->ErrorCode == UlError)
        {
            pRequest->ErrorCode = UlErrorUrl;
            pRequest->ParseState = ParseErrorState;
        }

        UlTrace(PARSER, (
                    "ul!UlpCookUrl(pRequest = %p) ERROR: unhappy. Status = 0x%x\n",
                    pRequest,
                    Status
                    ));
    }

    return Status;

}   // UlpCookUrl

NTSTATUS
Unescape(
    IN  PUCHAR pChar,
    OUT PUCHAR pOutChar
    )

{
    UCHAR Result, Digit;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (pChar[0] != '%' ||
        IS_HTTP_HEX(pChar[1]) == FALSE ||
        IS_HTTP_HEX(pChar[2]) == FALSE)
    {
        UlTrace(PARSER, (
                    "ul!Unescape( %c%c%c ) not HTTP_HEX format\n",
                    pChar[0],
                    pChar[1],
                    pChar[2]
                    ));

        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined
    //

    // uppercase #1
    //
    if (IS_HTTP_ALPHA(pChar[1]))
        Digit = UPCASE_CHAR(pChar[1]);
    else
        Digit = pChar[1];

    Result = ((Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0')) << 4;

    // uppercase #2
    //
    if (IS_HTTP_ALPHA(pChar[2]))
        Digit = UPCASE_CHAR(pChar[2]);
    else
        Digit = pChar[2];

    Result |= (Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0');

    *pOutChar = Result;

    return STATUS_SUCCESS;

}   // Unescape


NTSTATUS
PopChar(
    IN URL_PART UrlPart,
    IN PUCHAR pChar,
    OUT WCHAR * pUnicodeChar,
    OUT PULONG pCharToSkip
    )
{
    NTSTATUS Status;
    WCHAR   UnicodeChar;
    UCHAR   Char;
    UCHAR   Trail1;
    UCHAR   Trail2;
    ULONG   CharToSkip;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // validate it as a valid url character
    //

    if (IS_URL_TOKEN(pChar[0]) == FALSE)
    {
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

        UlTrace(PARSER, (
                    "ul!PopChar(pChar = %p) first char isn't URL token\n",
                    pChar
                    ));

        goto end;
    }

    //
    // need to unescape ?
    //
    // can't decode the query string.  that would be lossy decodeing
    // as '=' and '&' characters might be encoded, but have meaning
    // to the usermode parser.
    //

    if (UrlPart != QueryString && pChar[0] == '%')
    {
        Status = Unescape(pChar, &Char);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;
        CharToSkip = 3;
    }
    else
    {
        Char = pChar[0];
        CharToSkip = 1;
    }

    //
    // convert to unicode, checking for utf8 .
    //
    // 3 byte runs are the largest we can have.  16 bits in UCS-2 =
    // 3 bytes of (4+4,2+6,2+6) where it's code + char.
    // for a total of 6+6+4 char bits = 16 bits.
    //

    //
    // NOTE: we'll only bother to decode utf if it was escaped
    // thus the (CharToSkip == 3)
    //
    if ((CharToSkip == 3) && ((Char & 0xf0) == 0xe0))
    {
        // 3 byte run
        //

        // Unescape the next 2 trail bytes
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        Status = Unescape(pChar+CharToSkip, &Trail2);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE ||
            IS_UTF8_TRAILBYTE(Trail2) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            UlTrace(PARSER, (
                        "ul!PopChar( 0x%x 0x%x ) bad trail bytes\n",
                        Trail1,
                        Trail2
                        ));

            goto end;
        }

        // handle three byte case
        // 1110xxxx 10xxxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x0f) << 12) |
                                ((Trail1 & 0x3f) << 6) |
                                (Trail2 & 0x3f));

    }
    else if ((CharToSkip == 3) && ((Char & 0xe0) == 0xc0))
    {
        // 2 byte run
        //

        // Unescape the next 1 trail byte
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            UlTrace(PARSER, (
                        "ul!PopChar( 0x%x ) bad trail byte\n",
                        Trail1
                        ));

            goto end;
        }

        // handle two byte case
        // 110xxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x0f) << 6) |
                                (Trail1 & 0x3f));

    }

    // now this can either be unescaped high-bit (bad)
    // or escaped high-bit.  (also bad)
    //
    // thus not checking CharToSkip
    //

    else if ((Char & 0x80) == 0x80)
    {
        // high bit set !  bad utf!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

        UlTrace(PARSER, (
                    "ul!PopChar( 0x%x ) ERROR: high bit set! bad utf!\n",
                    Char
                    ));

        goto end;

    }
    //
    // Normal character (again either escaped or unescaped)
    //
    else
    {
        //
        // Simple conversion to unicode, it's 7-bit ascii.
        //

        UnicodeChar = (USHORT)Char;
    }

    //
    // turn backslashes into forward slashes
    //

    if (UnicodeChar == L'\\')
    {
        UnicodeChar = L'/';
    }
    else if (UnicodeChar == 0)
    {
        //
        // we pop'd a NULL.  bad!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;
    }

    *pCharToSkip  = CharToSkip;
    *pUnicodeChar = UnicodeChar;

    Status = STATUS_SUCCESS;

end:
    return Status;

}   // PopChar


//
// PAULMCD(2/99): stolen from iisrtl\string.cxx and incorporated
// and added more comments
//

//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000

//
// Private globals
//

//
// this table says what to do based on the current state and the current
// character
//
ULONG  pActionTable[16] =
{
    //
    // state 0 = fresh, seen nothing exciting yet
    //
    ACTION_EMIT_CH,         // other = emit it                      state = 0
    ACTION_EMIT_CH,         // "."   = emit it                      state = 0
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_EMIT_CH,         // "/"   = we saw the "/", emit it      state = 1

    //
    // state 1 = we saw a "/" !
    //
    ACTION_EMIT_CH,         // other = emit it,                     state = 0
    ACTION_NOTHING,         // "."   = eat it,                      state = 2
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = extra slash, eat it,         state = 1

    //
    // state 2 = we saw a "/" and ate a "." !
    //
    ACTION_EMIT_DOT_CH,     // other = emit the dot we ate.         state = 0
    ACTION_NOTHING,         // "."   = eat it, a ..                 state = 3
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = we ate a "/./", swallow it   state = 1

    //
    // state 3 = we saw a "/" and ate a ".." !
    //
    ACTION_EMIT_DOT_DOT_CH, // other = emit the "..".               state = 0
    ACTION_EMIT_DOT_DOT_CH, // "."   = 3 dots, emit the ".."        state = 0
    ACTION_BACKUP,          // EOS   = we have a "/..\0", backup!   state = 4
    ACTION_BACKUP           // "/"   = we have a "/../", backup!    state = 1
};

//
// this table says which newstate to be in given the current state and the
// character we saw
//
ULONG  pNextStateTable[16] =
{
    // state 0
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    //  state 1
    0 ,              // other
    2 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 2
    0 ,             // other
    3 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 3
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1               // "\"
};

//
// this says how to index into pNextStateTable given our current state.
//
// since max states = 4, we calculate the index by multiplying with 4.
//
#define IndexFromState( st)   ( (st) * 4)




/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode
    computes the case insensitive hash

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
UlpCleanAndCopyUrl(
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    )
{
    NTSTATUS Status;
    PWSTR   pDest;
    PUCHAR  pChar;
    ULONG   CharToSkip;
    UCHAR   Char;
    BOOLEAN HashValid;
    ULONG   UrlHash;
    ULONG   BytesCopied;
    PWSTR   pQueryString;
    ULONG   StateIndex;
    WCHAR   UnicodeChar;
    BOOLEAN MakeCanonical;

    //
    // Sanity check.
    //

    PAGED_CODE();

//
// a cool local helper macro
//

#define EMIT_CHAR(ch)                                   \
    do {                                                \
        pDest[0] = (ch);                                \
        pDest += 1;                                     \
        BytesCopied += 2;                               \
        if (HashValid)                                  \
            UrlHash = HashCharW((ch), UrlHash);         \
    } while (0)


    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    HashValid = TRUE;
    UrlHash = *pUrlHash;

    StateIndex = 0;

    MakeCanonical = (UrlPart == AbsPath) ? TRUE : FALSE;

    while (SourceLength > 0)
    {
        //
        // advance !  it's at the top of the loop to enable ANSI_NULL to
        // come through ONCE
        //

        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        //
        // well?  have we hit the end?
        //

        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
        }
        else
        {
            //
            // Nope.  Peek briefly to see if we hit the query string
            //

            if (UrlPart == AbsPath && pChar[0] == '?')
            {
                ASSERT(pQueryString == NULL);

                //
                // remember it's location
                //

                pQueryString = pDest;

                //
                // let it fall through ONCE to the canonical
                // in order to handle a trailing "/.." like
                // "http://foobar:80/foo/bar/..?v=1&v2"
                //

                UnicodeChar = L'?';
                CharToSkip = 1;

                //
                // now we are cleaning the query string
                //

                UrlPart = QueryString;
            }
            else
            {
                //
                // grab the next char
                //

                Status = PopChar(UrlPart, pChar, &UnicodeChar, &CharToSkip);
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
            }
        }

        if (MakeCanonical)
        {
            //
            // now use the state machine to make it canonical .
            //

            //
            // from the old value of StateIndex, figure out our new base StateIndex
            //
            StateIndex = IndexFromState(pNextStateTable[StateIndex]);

            //
            // did we just hit the query string?  this will only happen once
            // that we take this branch after hitting it, as we stop
            // processing after hitting it.
            //

            if (UrlPart == QueryString)
            {
                //
                // treat this just like we hit a NULL, EOS.
                //

                StateIndex += 2;
            }
            else
            {
                //
                // otherwise based the new state off of the char we
                // just popped.
                //

                switch (UnicodeChar)
                {
                case UNICODE_NULL:      StateIndex += 2;    break;
                case L'.':              StateIndex += 1;    break;
                case L'/':              StateIndex += 3;    break;
                default:                StateIndex += 0;    break;
                }
            }

        }
        else
        {
            StateIndex = (UnicodeChar == UNICODE_NULL) ? 2 : 0;
        }

        //
        //  Perform the action associated with the state.
        //

        switch (pActionTable[StateIndex])
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_CH:

            EMIT_CHAR(UnicodeChar);

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest currently points 1 past the last '/'.  backup over it and
            // find the preceding '/', set pDest to 1 past that one.
            //

            //
            // backup to the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest[0] == L'/');

            //
            // are we at the start of the string?  that's bad, can't go back!
            //

            if (pDest == pDestination)
            {
                ASSERT(BytesCopied == 0);

                UlTrace(PARSER, (
                            "ul!UlpCleanAndCopyUrl() Can't back up for ..\n"
                            ));

                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                goto end;
            }

            //
            // back up over the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest > pDestination);

            //
            // now find the previous slash
            //

            while (pDest > pDestination && pDest[0] != L'/')
            {
                pDest       -= 1;
                BytesCopied -= 2;
            }

            //
            // we already have a slash, so don't have to store 1.
            //

            ASSERT(pDest[0] == L'/');

            //
            // simply skip it, as if we had emitted it just now
            //

            pDest       += 1;
            BytesCopied += 2;

            //
            // mark our running hash invalid
            //

            HashValid = FALSE;

            break;

        default:
            ASSERT(!"UL!UlpCleanAndCopyUrl: Invalid action code in state table!");
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        //
        // Just hit the query string ?
        //

        if (MakeCanonical && UrlPart == QueryString)
        {
            //
            // Stop canonical processing
            //

            MakeCanonical = FALSE;

            //
            // Need to emit the '?', it wasn't emitted above
            //

            ASSERT(pActionTable[StateIndex] != ACTION_EMIT_CH);

            EMIT_CHAR(L'?');

        }

    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;

    //
    // need to recompute the hash?
    //
    if (HashValid == FALSE)
    {
        //
        // this can happen if we had to backtrack due to /../
        //

        UrlHash = HashStringW(pDestination, *pUrlHash);
    }

    *pUrlHash = UrlHash;
    *pBytesCopied = BytesCopied;
    if (ppQueryString != NULL)
    {
        *ppQueryString = pQueryString;
    }

    Status = STATUS_SUCCESS;


end:
    return Status;

}   // UlpCleanAndCopyUrl



/***************************************************************************++

Routine Description:

    Figures out how big the fixed headers are. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    pResponse - the response containing the headers

Return Values:

    The number of bytes in the fixed headers.

--***************************************************************************/
ULONG
UlComputeFixedHeaderSize(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pResponse
    )
{
    ULONG HeaderLength;
    ULONG i;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if ((pResponse == NULL) || HTTP_EQUAL_VERSION(Version, 0, 9)) {
        return 0;
    }

    HeaderLength = 0;

    HeaderLength += VERSION_SIZE +                              // HTTP-Version
                    1 +                                         // SP
                    3 +                                         // Status-Code
                    1 +                                         // SP
                    pResponse->ReasonLength / sizeof(WCHAR) +   // Reason-Phrase
                    CRLF_SIZE;                                  // CRLF


    //
    // Loop through the known headers.
    //

    for (i = 0; i < HttpHeaderResponseMaximum; ++i)
    {
        USHORT RawValueLength = pResponse->Headers.pKnownHeaders[i].RawValueLength;

        // skip some headers we'll generate
        if ((i == HttpHeaderDate) || (i == HttpHeaderConnection)) {
            continue;
        }

        if (RawValueLength > 0)
        {
            HeaderLength += HeaderMapTable[
                                ResponseHeaderMap[i]
                                ].HeaderLength +                // Header-Name
                            1 +                                 // SP
                            RawValueLength / sizeof(WCHAR) +    // Header-Value
                            CRLF_SIZE;                          // CRLF

        }
    }

    //
    // Include default headers we may need to generate for the application.
    //

    if (pResponse->Headers.pKnownHeaders[HttpHeaderServer].RawValueLength == 0)
    {
        HeaderLength += HeaderMapTable[
                            ResponseHeaderMap[HttpHeaderServer]
                            ].HeaderLength +                // Header-Name
                        1 +                                 // SP
                        DEFAULT_SERVER_HDR_LENGTH +         // Header-Value
                        CRLF_SIZE;                          // CRLF
    }

    //
    // And the unknown headers (this might throw an exception).
    //

    pUnknownHeaders = pResponse->Headers.pUnknownHeaders;

    if (pUnknownHeaders != NULL)
    {
        for (i = 0 ; i < pResponse->Headers.UnknownHeaderCount; ++i)
        {
            USHORT Length;

            if (pUnknownHeaders[i].NameLength > 0)
            {
                HeaderLength += pUnknownHeaders[i].NameLength /
                                    sizeof(WCHAR) +     // Header-Name
                                1 +                     // ':'
                                1 +                     // SP
                                pUnknownHeaders[i].RawValueLength /
                                    sizeof(WCHAR) +     // Header-Value
                                CRLF_SIZE;              // CRLF

            }
        }
    }


    return HeaderLength;

}   // UlComputeFixedHeaderSize


/***************************************************************************++

Routine Description:

    Figures out how big the variable headers are. Variable headers include
    Date and Connection.

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    ConnHeader  - Tells us which connection header to generate

Return Values:

    The number of bytes in the fixed headers.

--***************************************************************************/
ULONG
UlComputeVariableHeaderSize(
    IN UL_CONN_HDR ConnHeader
    )
{
    ULONG Length;
    PHEADER_MAP_ENTRY pEntry;

    Length = 0;

    //
    // Date: header
    //
    pEntry = &(HeaderMapTable[ResponseHeaderMap[HttpHeaderDate]]);
    Length += pEntry->HeaderLength;     // header name
    Length += 1;                        // SP
    Length += DATE_HDR_LENGTH;          // header value
    Length += CRLF_SIZE;                // CRLF

    //
    // Connection: header
    //
    pEntry = &(HeaderMapTable[ResponseHeaderMap[HttpHeaderConnection]]);

    switch (ConnHeader) {
    case ConnHdrNone:
        // no header
        break;

    case ConnHdrClose:
        Length += pEntry->HeaderLength;
        Length += 1;
        Length += CONN_CLOSE_HDR_LENGTH;
        Length += CRLF_SIZE;
        break;

    case ConnHdrKeepAlive:
        Length += pEntry->HeaderLength;
        Length += 1;
        Length += CONN_KEEPALIVE_HDR_LENGTH;
        Length += CRLF_SIZE;
        break;

    default:
        ASSERT( ConnHeader < ConnHdrMax );
        break;
    }

    //
    // final CRLF
    //
    Length += CRLF_SIZE;

    return Length;

}   // UlComputeVariableHeaderSize


/***************************************************************************++

Routine Description:

    Generates the varaible part of the header, including Date:, Connection:,
    and final CRLF.

Arguments:

    ConnHeader      - tells us what Connection: value to send
    BufferLength    - length of pBuffer
    pBuffer         - generate the headers here
    pBytesCopied    - gets the number of bytes generated

--***************************************************************************/
VOID
UlGenerateVariableHeaders(
    IN UL_CONN_HDR ConnHeader,
    IN ULONG BufferLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied
    )
{
    PHEADER_MAP_ENTRY pEntry;
    PUCHAR pStartBuffer;
    PUCHAR pCloseHeaderValue;
    ULONG CloseHeaderValueLength;
    ULONG BytesCopied;

    ASSERT( pBuffer );
    ASSERT( pBytesCopied );
    ASSERT( BufferLength >= UlComputeVariableHeaderSize(ConnHeader) );

    pStartBuffer = pBuffer;

    //
    // generate Date: header
    //
    pEntry = &(HeaderMapTable[ResponseHeaderMap[HttpHeaderDate]]);

    RtlCopyMemory(
        pBuffer,
        pEntry->MixedCaseHeader,
        pEntry->HeaderLength
        );

    pBuffer += pEntry->HeaderLength;

    pBuffer[0] = SP;
    pBuffer += 1;

    BytesCopied = GenerateDateHeader( pBuffer );

    pBuffer += BytesCopied;

    ((PUSHORT)pBuffer)[0] = CRLF;
    pBuffer += sizeof(USHORT);

    //
    // generate Connection: header
    //
    switch (ConnHeader) {
    case ConnHdrNone:
        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;

    case ConnHdrClose:
        pCloseHeaderValue = CONN_CLOSE_HDR;
        CloseHeaderValueLength = CONN_CLOSE_HDR_LENGTH;
        break;

    case ConnHdrKeepAlive:
        pCloseHeaderValue = CONN_KEEPALIVE_HDR;
        CloseHeaderValueLength = CONN_KEEPALIVE_HDR_LENGTH;
        break;

    default:
        ASSERT(ConnHeader < ConnHdrMax);

        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;
    }

    if (pCloseHeaderValue != NULL) {
        pEntry = &(HeaderMapTable[ResponseHeaderMap[HttpHeaderConnection]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        RtlCopyMemory(
            pBuffer,
            pCloseHeaderValue,
            CloseHeaderValueLength
            );

        pBuffer += CloseHeaderValueLength;

        ((PUSHORT)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }

    //
    // generate final CRLF
    //
    ((PUSHORT)pBuffer)[0] = CRLF;
    pBuffer += sizeof(USHORT);

    //
    // make sure we didn't use too much
    //
    BytesCopied = DIFF(pBuffer - pStartBuffer);
    *pBytesCopied = BytesCopied;

    ASSERT( BytesCopied <= BufferLength );
}



ULONG
_WideCharToMultiByte(
    ULONG uCodePage,
    ULONG dwFlags,
    PCWSTR lpWideCharStr,
    int cchWideChar,
    PSTR lpMultiByteStr,
    int cchMultiByte,
    PCSTR lpDefaultChar,
    BOOLEAN *lpfUsedDefaultChar
    )
{
    int i;

    //
    // simply strip the upper byte, it's supposed to be ascii already
    //

    for (i = 0; i < cchWideChar; ++i)
    {
        if ((lpWideCharStr[i] & 0xff00) != 0 || IS_HTTP_CTL(lpWideCharStr[i]))
        {
            lpMultiByteStr[0] = *lpDefaultChar;
        }
        else
        {
            lpMultiByteStr[0] = (UCHAR)(lpWideCharStr[i]);
        }
        lpMultiByteStr += 1;
    }

    return (ULONG)(i);

}   // _WideCharToMultiByte

ULONG
_MultiByteToWideChar(
    ULONG uCodePage,
    ULONG dwFlags,
    PCSTR lpMultiByteStr,
    int cchMultiByte,
    PWSTR lpWideCharStr,
    int cchWideChar
    )
{
    int i;

    //
    // simply add a 0 upper byte, it's supposed to be ascii
    //

    for (i = 0; i < cchMultiByte; ++i)
    {
        if (lpMultiByteStr[i] > 128)
        {
            lpWideCharStr[i] = (WCHAR)(DefaultChar);
        }
        else
        {
            lpWideCharStr[i] = (WCHAR)(lpMultiByteStr[i]);
        }
    }

    return (ULONG)(i);

}   // _MultiByteToWideChar


/***************************************************************************++

Routine Description:

    Generates the fixed part of the header. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    Version         - the http version for the status line
    pResponse       - the user specified response
    BufferLength    - length of pBuffer
    pBuffer         - generate the headers here
    pBytesCopied    - gets the number of bytes generated

--***************************************************************************/
VOID
UlGenerateFixedHeaders(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pResponse,
    IN ULONG BufferLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied
    )
{
    PUCHAR                  pStartBuffer;
    PUCHAR                  pEndOfNumber;
    ULONG                   BytesCopied;
    ULONG                   i;
    PHTTP_UNKNOWN_HEADER    pUnknownHeaders;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pResponse != NULL);
    ASSERT(pBuffer != NULL && BufferLength > 0);
    ASSERT(pBytesCopied != NULL);

    pStartBuffer = pBuffer;

    //
    // Build the response headers.
    //

    if (HTTP_NOT_EQUAL_VERSION(Version, 0, 9))
    {
        //
        // Always send back 1.1 in the response.
        //

        RtlCopyMemory(pBuffer, "HTTP/1.1 ", sizeof("HTTP/1.1 ") - 1);
        pBuffer += sizeof("HTTP/1.1 ") - 1;

        //
        // Status code.
        //

        pBuffer[0] = '0' + ((pResponse->StatusCode / 100) % 10);
        pBuffer[1] = '0' + ((pResponse->StatusCode / 10)  % 10);
        pBuffer[2] = '0' + ((pResponse->StatusCode / 1)   % 10);
        pBuffer[3] = SP;

        pBuffer += 4;

        //
        // Copy the reason, converting from widechar.
        //

        RtlCopyMemory(
            pBuffer,
            pResponse->pReason,
            pResponse->ReasonLength
            );

        pBuffer += pResponse->ReasonLength;

        //
        // Terminate with the CRLF.
        //

        ((PUSHORT)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);

        //
        // Loop through the known headers.
        //

        for (i = 0; i < HttpHeaderResponseMaximum; ++i)
        {
            // skip some headers we'll generate
            if ((i == HttpHeaderDate) || (i == HttpHeaderConnection)) {
                continue;
            }

            if (pResponse->Headers.pKnownHeaders[i].RawValueLength > 0)
            {
                PHEADER_MAP_ENTRY pEntry;

                pEntry = &(HeaderMapTable[ResponseHeaderMap[i]]);

                RtlCopyMemory(
                    pBuffer,
                    pEntry->MixedCaseHeader,
                    pEntry->HeaderLength
                    );

                pBuffer += pEntry->HeaderLength;

                pBuffer[0] = SP;
                pBuffer += 1;

                RtlCopyMemory(
                    pBuffer,
                    pResponse->Headers.pKnownHeaders[i].pRawValue,
                    pResponse->Headers.pKnownHeaders[i].RawValueLength
                    );
                    
                pBuffer += pResponse->Headers.pKnownHeaders[i].RawValueLength;

                ((PUSHORT)pBuffer)[0] = CRLF;
                pBuffer += sizeof(USHORT);
            }
        }

        //
        // Append some default headers if not provided by the application.
        //

        if (pResponse->Headers.pKnownHeaders[HttpHeaderServer].RawValueLength == 0)
        {
            PHEADER_MAP_ENTRY pEntry;

            pEntry = &(HeaderMapTable[ResponseHeaderMap[HttpHeaderServer]]);

            RtlCopyMemory(
                pBuffer,
                pEntry->MixedCaseHeader,
                pEntry->HeaderLength
                );

            pBuffer += pEntry->HeaderLength;

            pBuffer[0] = SP;
            pBuffer += 1;

            RtlCopyMemory(
                pBuffer,
                DEFAULT_SERVER_HDR,
                DEFAULT_SERVER_HDR_LENGTH
                );

            pBuffer += DEFAULT_SERVER_HDR_LENGTH;

            ((PUSHORT)pBuffer)[0] = CRLF;
            pBuffer += sizeof(USHORT);
        }

        //
        // And now the unknown headers (this might throw an exception).
        //

        pUnknownHeaders = pResponse->Headers.pUnknownHeaders;
        if (pUnknownHeaders != NULL)
        {
            for (i = 0 ; i < pResponse->Headers.UnknownHeaderCount; ++i)
            {
                if (pUnknownHeaders[i].NameLength > 0)
                {

                    RtlCopyMemory(
                        pBuffer,
                        pUnknownHeaders[i].pName,
                        pUnknownHeaders[i].NameLength
                        );

                    pBuffer += pUnknownHeaders[i].NameLength;

                    *pBuffer++ = ':';
                    *pBuffer++ = SP;

                    RtlCopyMemory(
                        pBuffer,
                        pUnknownHeaders[i].pRawValue,
                        pUnknownHeaders[i].RawValueLength
                        );

                    pBuffer += pUnknownHeaders[i].RawValueLength;

                    ((PUSHORT)pBuffer)[0] = CRLF;
                    pBuffer += sizeof(USHORT);

                }   // if (pUnknownHeaders[i].NameLength > 0)

            }

        }   // if (pUnknownHeaders != NULL)


        *pBytesCopied = DIFF(pBuffer - pStartBuffer);

    }   // if (Version > UlHttpVersion09)

    else
    {
        *pBytesCopied = 0;
    }

    //
    // Ensure we didn't use too much.
    //

    ASSERT(DIFF(pBuffer - pStartBuffer) <= BufferLength);

}   // UlGenerateFixedHeaders


PSTR Weekdays[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
PSTR Months[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

ULONG
GenerateDateHeader(
    OUT PUCHAR pBuffer
    )
{
    LARGE_INTEGER systemTime;
    TIME_FIELDS timeFields;
    int length;

    //
    // CODEWORK: Cache this stuff, don't regenerate on EVERY request.
    //

    KeQuerySystemTime( &systemTime );
    RtlTimeToTimeFields( &systemTime, &timeFields );

    length = sprintf(
                 pBuffer,
                 "%s, %02d %s %04d %02d:%02d:%02d GMT",
                 Weekdays[timeFields.Weekday],
                 timeFields.Day,
                 Months[timeFields.Month - 1],
                 timeFields.Year,
                 timeFields.Hour,
                 timeFields.Minute,
                 timeFields.Second
                 );

    ASSERT( length <= DATE_HDR_LENGTH );

    return (ULONG)length;

}   // GenerateDateHeader
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\misc.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    misc.h

Abstract:

    This module contains miscellaneous constants & declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998
    Henry Sanders (henrysa)     17-Jun-1998 Merge with old httputil.h
    Paul McDaniel (paulmcd)     30-Mar-1999 added refcounted eresource

Revision History:

--*/



#ifndef _MISC_H_
#define _MISC_H_


extern  ULONG   HttpChars[256];

#define HTTP_CHAR           0x001
#define HTTP_UPCASE         0x002
#define HTTP_LOCASE         0x004
#define HTTP_ALPHA          (HTTP_UPCASE | HTTP_LOCASE)
#define HTTP_DIGIT          0x008
#define HTTP_CTL            0x010
#define HTTP_LWS            0x020
#define HTTP_HEX            0x040
#define HTTP_SEPERATOR      0x080
#define HTTP_TOKEN          0x100

#define URL_LEGAL           0x200
#define URL_TOKEN           (HTTP_ALPHA | HTTP_DIGIT | URL_LEGAL)

#define IS_HTTP_UPCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_LOCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_ALPHA(c)        (HttpChars[(UCHAR)(c)] & HTTP_ALPHA)
#define IS_HTTP_DIGIT(c)        (HttpChars[(UCHAR)(c)] & HTTP_DIGIT)
#define IS_HTTP_HEX(c)          (HttpChars[(UCHAR)(c)] & HTTP_HEX)
#define IS_HTTP_CTL(c)          (HttpChars[(UCHAR)(c)] & HTTP_CTL)
#define IS_HTTP_LWS(c)          (HttpChars[(UCHAR)(c)] & HTTP_LWS)
#define IS_HTTP_SEPERATOR(c)    (HttpChars[(UCHAR)(c)] & HTTP_SEPERATOR)
#define IS_HTTP_TOKEN(c)        (HttpChars[(UCHAR)(c)] & HTTP_TOKEN)
#define IS_URL_TOKEN(c)         (HttpChars[(UCHAR)(c)] & URL_TOKEN)

NTSTATUS
InitializeHttpUtil(
    VOID
    );


//
// Our presumed cache-line size.
//

#define CACHE_LINE_SIZE 32


//
// Alignment macros.
//

#define ROUND_UP( val, pow2 )                                               \
    ( ( (ULONG_PTR)(val) + (pow2) - 1 ) & ~( (pow2) - 1 ) )


//
// Calculate the dimension of an array.
//

#define DIMENSION(x) ( sizeof(x) / sizeof(x[0]) )

//
// nice MIN/MAX macros
//

#define MIN(a,b) ( ((a) > (b)) ? (b) : (a) )
#define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )

//
// Macros for swapping the bytes in a long and a short.
//

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))

#define SWAP_LONG(l)    _byteswap_ulong((unsigned long)l)
#define SWAP_SHORT(s)   _byteswap_ushort((unsigned short)s)
#else

#define SWAP_LONG(l)                                \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

#define SWAP_SHORT(s)                               \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )

#endif
//
// Context values stored in PFILE_OBJECT->FsContext2 to identify a handle
// as either a control channel or an app pool.
//

#define UL_CONTROL_CHANNEL_CONTEXT      ((PVOID)'LRTC')
#define UL_CONTROL_CHANNEL_CONTEXT_X    ((PVOID)'rtcX')
#define UL_APP_POOL_CONTEXT             ((PVOID)'PPPA')
#define UL_APP_POOL_CONTEXT_X           ((PVOID)'ppaX')

#define IS_CONTROL_CHANNEL( pFileObject )                                   \
    ( (pFileObject)->FsContext2 == UL_CONTROL_CHANNEL_CONTEXT )

#define MARK_VALID_CONTROL_CHANNEL( pFileObject )                           \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT )

#define MARK_INVALID_CONTROL_CHANNEL( pFileObject )                         \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT_X )

#define GET_CONTROL_CHANNEL( pFileObject )                                  \
    ((PUL_CONTROL_CHANNEL)((pFileObject)->FsContext))

#define GET_PP_CONTROL_CHANNEL( pFileObject )                               \
    ((PUL_CONTROL_CHANNEL *)&((pFileObject)->FsContext))

#define IS_APP_POOL( pFileObject )                                          \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT )

#define IS_EX_APP_POOL( pFileObject )                                          \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT_X )

#define MARK_VALID_APP_POOL( pFileObject )                                  \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT )

#define MARK_INVALID_APP_POOL( pFileObject )                                \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT_X )

#define GET_APP_POOL_PROCESS( pFileObject )                                 \
    ((PUL_APP_POOL_PROCESS)((pFileObject)->FsContext))

#define GET_PP_APP_POOL_PROCESS( pFileObject )                              \
    ((PUL_APP_POOL_PROCESS *)&((pFileObject)->FsContext))

#define IS_VALID_UL_NONPAGED_RESOURCE(pResource)                            \
    (((pResource) != NULL) &&                                               \
     ((pResource)->Signature == UL_NONPAGED_RESOURCE_SIGNATURE) &&          \
     ((pResource)->RefCount > 0))

typedef struct _UL_NONPAGED_RESOURCE
{
    //
    // NonPagedPool
    //

    SINGLE_LIST_ENTRY   LookasideEntry;     // must be first, links
                                            // into the lookaside list

    ULONG               Signature;          // UL_NONPAGED_RESOURCE_SIGNATURE

    LONG                RefCount;           // the reference count

    UL_ERESOURCE        Resource;           // the actual resource

} UL_NONPAGED_RESOURCE, * PUL_NONPAGED_RESOURCE;

#define UL_NONPAGED_RESOURCE_SIGNATURE      ((ULONG)'RNLU')
#define UL_NONPAGED_RESOURCE_SIGNATURE_X    MAKE_FREE_SIGNATURE(UL_NONPAGED_RESOURCE_SIGNATURE)


PUL_NONPAGED_RESOURCE
UlResourceNew(
    );

VOID
UlReferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_RESOURCE( pres )                                          \
    UlReferenceResource(                                                    \
        (pres)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_RESOURCE( pres )                                        \
    UlDereferenceResource(                                                  \
        (pres)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

PVOID
UlResourceAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlResourceFreePool(
    IN PVOID pBuffer
    );



//
// Miscellaneous validators.
//

#define IS_VALID_DEVICE_OBJECT( pDeviceObject )                             \
    ( ((pDeviceObject) != NULL) &&                                          \
      ((pDeviceObject)->Type == IO_TYPE_DEVICE) &&                          \
      ((pDeviceObject)->Size == sizeof(DEVICE_OBJECT)) )

#define IS_VALID_FILE_OBJECT( pFileObject )                                 \
    ( ((pFileObject) != NULL) &&                                            \
      ((pFileObject)->Type == IO_TYPE_FILE) &&                              \
      ((pFileObject)->Size == sizeof(FILE_OBJECT)) )

#define IS_VALID_IRP( pIrp )                                                \
    ( ((pIrp) != NULL) &&                                                   \
      ((pIrp)->Type == IO_TYPE_IRP) &&                                      \
      ((pIrp)->Size == IoSizeOfIrp((pIrp)->StackCount)) )



NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    );


#endif  // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\precomp.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the master header file for ULRTL. It includes all other
    necessary header files for ULRTL.
    It should be able to include everything we need for UL AND Win32.

Author:

    Keith Moore (keithmo)       18-Jan-1999

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


//
// System include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef RPL_MASK

#include <ntosp.h>
#include <zwapi.h>
#include <ntddtcp.h>
#include <ipexport.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <tcpinfo.h>

#include <stdio.h>
#include <stdlib.h>

//
// Project include files.
//

#include <iisdef.h>
#include <httpdef.h>
#include <httprtl.h>

//
// Local include files.
//

// this stuff needs to be moved to top level headers.
#include "extcrap.h"

// include win32 stuff

#undef DEBUG

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#ifdef TARGET_UMODE

#include "udebug.h"

#undef ASSERT
#define ASSERT(x)

#undef PAGED_CODE
#define PAGED_CODE()

#define KeQuerySystemTime(x) GetSystemTimeAsFileTime((LPFILETIME)(x))
#define Swap(x,y) x^=y,y^=x,x^=y
#define RtlTimeToTimeFields(x,y) FileTimeToSystemTime( ((FILETIME*)(x)), ((SYSTEMTIME*)(y))),\
		Swap(((TIME_FIELDS*)(y))->Weekday,((TIME_FIELDS*)(y))->Milliseconds),\
		Swap(((TIME_FIELDS*)(y))->Milliseconds,((TIME_FIELDS*)(y))->Second),\
		Swap(((TIME_FIELDS*)(y))->Second,((TIME_FIELDS*)(y))->Minute),\
		Swap(((TIME_FIELDS*)(y))->Minute,((TIME_FIELDS*)(y))->Hour),\
		Swap(((TIME_FIELDS*)(y))->Hour,((TIME_FIELDS*)(y))->Hour)

//#define UlLocalAddressFromConnection(x, y)


#else // TARGET_UMODE

#include "kdebug.h"

#endif // TARGET_UMODE


#include "httptypes.h"
#include "misc.h"
#include "_hashfn.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\sources.inc ===
!INCLUDE ..\..\..\PLACE.INC

TARGETTYPE=LIBRARY
TARGETPATH=$(IISBASEDIR)\LIB\$(_OBJ_DIR)

INCLUDES=..;                            \
         $(INCLUDES);                   \
         $(BASEDIR)\public\ddk\inc;     \
         $(BASE_INC_PATH);              \
         $(NET_INC_PATH);               \
         $(IISBASEDIR)\iisrearc\inc

SOURCES=                        \
        ..\parse.c              \
        ..\rcvhdrs.c            \
        ..\misc.c               \

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\rcvhdrs.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    rcvhdrs.h

Abstract:

    Contains definitions for rcvhdrs.c .

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#ifndef _RCVHDRS_H_
#define _RCVHDRS_H_

NTSTATUS
MultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID,
    OUT ULONG  *            pBytesTaken
    );

NTSTATUS
SingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID,
    OUT ULONG  *            pBytesTaken
    );

NTSTATUS
FindHeaderEnd(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT BOOLEAN *               pEncodedWord,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
AppendHeaderValue(
    IN  PUL_HTTP_HEADER     pHttpHeader,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength
    );

#endif  // _RCVHDRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\parsep.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    parsep.h

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       04-May-1998

Revision History:

--*/

#ifndef _PARSEP_H_
#define _PARSEP_H_


#define MIN_VERSION_SIZE    (sizeof("HTTP/1.1") - 1)

#define MAX_VERB_LENGTH     (sizeof("PROPPATCH"))

#define HTTP_11_VERSION 0x312e312f50545448
#define HTTP_10_VERSION 0x302e312f50545448

#define UPCASE_MASK ((ULONGLONG)0xdfdfdfdfdfdfdfdf)

#define MAX_HEADER_LONG_COUNT   3
#define MAX_HEADER_LENGTH       (MAX_HEADER_LONG_COUNT * sizeof(ULONGLONG))

#define NUMBER_HEADER_INDICIES  26


//
// Default Server: header if none provided by the application.
//

#define DEFAULT_SERVER_HDR          "Microsoft-IIS/UL"
#define DEFAULT_SERVER_HDR_LENGTH   (sizeof(DEFAULT_SERVER_HDR) - sizeof(CHAR))


//
// Size of a Date: value if we need to generate it ourselves.
//

#define DATE_HDR_LENGTH (sizeof("Thu, 26 Aug 1999 17:14:02 GMT") - sizeof(CHAR))

//
// Size of Connection: header values
//

#define CONN_CLOSE_HDR              "close"
#define CONN_CLOSE_HDR_LENGTH       (sizeof(CONN_CLOSE_HDR) - sizeof(CHAR))

#define CONN_KEEPALIVE_HDR          "keep-alive"
#define CONN_KEEPALIVE_HDR_LENGTH   (sizeof(CONN_KEEPALIVE_HDR) - sizeof(CHAR))

//
// These are backwards because of little endian.
//

#define HTTP_PREFIX         'PTTH'
#define HTTP_PREFIX_SIZE    4
#define HTTP_PREFIX_MASK    0xdfdfdfdf

#define HTTP_PREFIX1        '\0//:'
#define HTTP_PREFIX1_SIZE   3
#define HTTP_PREFIX1_MASK   0x00ffffff

#define HTTP_PREFIX2        '//:S'
#define HTTP_PREFIX2_SIZE   4
#define HTTP_PREFIX2_MASK   0xffffffdf


typedef NTSTATUS (*PFN_HEADER_HANDLER)(
                        PUL_INTERNAL_REQUEST     pRequest,
                        PUCHAR            pHttpRequest,
                        ULONG             HttpRequestLength,
                        HTTP_HEADER_ID    HeaderID,
                        ULONG  *          pBytesTaken
                        );


//
// Structure of the fast verb lookup table. The table consists of a series of
// entries where each entry contains an HTTP verb represented as a ulonglong,
// a mask to use for comparing that verb, the length of the verb and the
// translated id.
//

typedef struct _FAST_VERB_ENTRY
{
    union
    {
        UCHAR       Char[sizeof(ULONGLONG)+1];
        ULONGLONG   LongLong;
    }           RawVerb;
    ULONGLONG   RawVerbMask;
    ULONG       RawVerbLength;
    HTTP_VERB   TranslatedVerb;

} FAST_VERB_ENTRY, *PFAST_VERB_ENTRY;


//
// Stucture of the all verb lookup table. This table holds all verbs that
// we understand, including those that are too long to fit in the fast
// verb table.
//

typedef struct _LONG_VERB_ENTRY
{
    ULONG       RawVerbLength;
    UCHAR       RawVerb[MAX_VERB_LENGTH];
    HTTP_VERB   TranslatedVerb;

} LONG_VERB_ENTRY, *PLONG_VERB_ENTRY;


//
// Structure for a header map entry. Each header map entry contains a
// verb and a series of masks to use in checking that verb.
//

typedef struct _HEADER_MAP_ENTRY
{
    ULONG               HeaderLength;
    ULONG               ArrayCount;
    ULONG               MinBytesNeeded;
    union
    {
        UCHAR               HeaderChar[MAX_HEADER_LENGTH];
        ULONGLONG           HeaderLong[MAX_HEADER_LONG_COUNT];
    }                   Header;
    ULONGLONG           HeaderMask[MAX_HEADER_LONG_COUNT];
    UCHAR               MixedCaseHeader[MAX_HEADER_LENGTH];

    HTTP_HEADER_ID      HeaderID;
    PFN_HEADER_HANDLER  pHandler;

}  HEADER_MAP_ENTRY, *PHEADER_MAP_ENTRY;


//
// Structure for a header index table entry.
//

typedef struct _HEADER_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    ULONG               Count;

} HEADER_INDEX_ENTRY, *PHEADER_INDEX_ENTRY;


//
// A (complex) macro to create a mask for a header map entry,
// given the header length and the mask offset (in bytes). This
// mask will need to be touched up for non-alphabetic characters.
//

#define CREATE_HEADER_MASK(hlength, maskoffset) \
    ((hlength) > (maskoffset) ? UPCASE_MASK : \
        (((maskoffset) - (hlength)) >= 8 ? 0 : \
        (UPCASE_MASK >> ( ((maskoffset) - (hlength)) * (ULONGLONG)8))))


//
// Macro for creating header map entries. The mask entries are created
// by the init code.
//

#define CREATE_HEADER_MAP_ENTRY(header, ID, handler) { \
    \
    sizeof(#header) - 1, \
    ((sizeof(#header) - 1) / 8) + \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1), \
    (((sizeof(#header) - 1) / 8) + \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1)) * 8, \
    { #header }, \
    { 0, 0, 0}, \
    { #header }, \
    ID, \
    handler, \
    }


//
// Macro for defining fast verb table entries. Note that we don't subtrace 1
// from the various sizeof occurences because we'd just have to add it back
// in to account for the seperating space.
//

#define CREATE_FAST_VERB_ENTRY(verb)    { {#verb " "}, \
                                                (0xffffffffffffffff >> \
                                                ((8 - (sizeof(#verb))) * 8)), \
                                                (sizeof(#verb)), HttpVerb##verb }


//
// Macro for defining all verb table entries.
//

#define CREATE_LONG_VERB_ENTRY(verb)    { sizeof(#verb) - 1, \
                                             #verb,\
                                             HttpVerb##verb }

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)


NTSTATUS
CheckForAbsoluteUrl(
    IN  PUL_INTERNAL_REQUEST   pRequest,
    IN  PUCHAR          pURL,
    IN  ULONG           URLLength,
    IN  PUCHAR *        pHostPtr,
    IN  ULONG  *        BytesTaken
    );

NTSTATUS
LookupVerb(
    IN  PUL_INTERNAL_REQUEST   pRequest,
    IN  PUCHAR          pHttpRequest,
    IN  ULONG           HttpRequestLength,
    OUT ULONG  *        pBytesTaken
    );

NTSTATUS
ParseHeader(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG  *            pBytesTaken
    );


NTSTATUS
LookupHeader(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    IN  PHEADER_MAP_ENTRY   pCurrentHeaderMap,
    IN  ULONG               HeaderMapCount,
    OUT ULONG  *            pBytesTaken
    );

typedef enum _URL_PART
{
    Scheme,
    HostName,
    AbsPath,
    QueryString

} URL_PART;

NTSTATUS
UlpCleanAndCopyUrl(
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    );

// Call this only after the entire request has been parsed
//
NTSTATUS
UlpCookUrl(
    IN  PUL_INTERNAL_REQUEST       pRequest
    );


#endif // _PARSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\precomp9x.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    precomp9x.h

Abstract:

	just some stuff specific to ulrtlu.lib used by the listener in win9x

Author:

    Mauro Ottaviani (mauroot)       27-Jan-2000

Revision History:

--*/


#ifndef _PRECOMP9X_H_
#define _PRECOMP9X_H_


//
// System include files.
//

// user must have included precomp.h already: #include <precomp.h>

NTSTATUS
InitializeParser(
    VOID
    );

NTSTATUS
ParseHttp(
    IN  PHTTP_REQUEST       pRequest,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG               *pBytesTaken
    );

NTSTATUS
UlpHttpRequestToBufferWin9x(
    PHTTP_REQUEST           pRequest,
    PUCHAR                  pKernelBuffer,
    ULONG                   BufferLength,
    PUCHAR                  pEntityBody,
    ULONG                   EntityBodyLength,
    ULONG					ulLocalIPAddress,
    USHORT					ulLocalPort,
    ULONG					ulRemoteIPAddress,
    USHORT					ulRemotePort
    );

#endif  // _PRECOMP9X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\rcvhdrs.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    rcvhdrs.c

Abstract:

    Contains all of the per header handling code for received headers.

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#include    "precomp.h"
#include    "rcvhdrs.h"

/*++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a header.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    TokenLength     - Where to return the length of the token.

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--*/
NTSTATUS
FindHeaderEnd(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    OUT BOOLEAN *           pEncodedWord,
    OUT ULONG  *            pBytesTaken
    )
{
    UCHAR       CurrentChar;
    ULONG       CurrentOffset;
    BOOLEAN     HaveCR;
    BOOLEAN     HaveHeader;
    BOOLEAN     HaveEQ;
    BOOLEAN     HaveEncodedWord;

    // Important this is above the label (and our of the for loop)
    // to support goto repeats
    //
    CurrentOffset = 0;

    HaveEncodedWord = FALSE;

look_for_crlf:

    HaveCR = FALSE;
    HaveEQ = FALSE;
    HaveHeader = FALSE;

    //
    // While we still have data, loop through looking for a CRLF or LFLF pair.
    //

    for (; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);

        //
        // If this character is a CR or LF, we may be done.
        //
        if (CurrentChar == CR || CurrentChar == LF)
        {
            // If we've already seen a CR (or LF) immediately preceding this,
            // see if this is a LF to terminate the line.

            if (HaveCR)
            {
                if (CurrentChar == LF)
                {
                    // It is a LF, so we're done.

                    HaveHeader = TRUE;

                    break;
                }

                // Otherwise, we have a non LF after a CR (or LF). The only
                // character this could be is a CR, since we're inside
                // the if statement. This could be the start of a CRLF
                // sequence, if this is some bizarre LFCRLF or CRCRLF
                // sort of thing. Anyway, we don't want to set HaveCR
                // to false here.

                ASSERT(CurrentChar == CR);

                //
                // paulmcd:  this seems wacked.  bizarre enough to fail
                //

                pRequest->ErrorCode = UlErrorCRLF;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "ul!FindHeaderEnd(pRequest = %p, pHeader = %p)\n"
                            "    ERROR: don't like to see CRCR\n",
                            pRequest,
                            pHeader
                            ));
                
                
                return STATUS_INVALID_DEVICE_REQUEST;

            }
            else
            {
                // Otherwise, we haven't seen the start of the terminating pair
                // yet, so remember that we now have.

                HaveCR = TRUE;
            }
        }
        else if (HaveCR)
        {
            //
            // it's illegal to have CR|LF and non trailing LF.
            //

            pRequest->ErrorCode = UlErrorCRLF;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!FindHeaderEnd(pRequest = %p, pHeader = %p)\n"
                        "    ERROR: it's illegal to have CR|LF and non trailing LF.\n",
                        pRequest,
                        pHeader
                        ));
            
            return STATUS_INVALID_DEVICE_REQUEST;
        }
        else if (HaveEncodedWord == FALSE)
        {
            // Were looking to see if we have any =? ?= encoded words
            // according to rfc2047.  we'll decode them later in a
            // second pass.  thus were not so strict here on format,
            // this is simply a hint for perf.
            //
            if (CurrentChar == '=')
            {
                HaveEQ = TRUE;
            }
            else if (CurrentChar == '?')
            {
                if (HaveEQ)
                    HaveEncodedWord = TRUE;
            }
            else
                HaveEQ = FALSE;
        }


    }

    // If we found the termination OK, return the length of the value.
    //
    if (HaveHeader)
    {
        ASSERT(CurrentOffset < HeaderLength);

        // ok, we found a CRLF or LFLF, peek ahead 1 char to
        // handle header value continuation
        //

        // Skip the LF
        //
        CurrentOffset += 1;

        if (CurrentOffset == HeaderLength)
        {
            // not enough buffer to check, need more
            //
            *pBytesTaken = 0;
            return STATUS_SUCCESS;
        }

        CurrentChar = *(pHeader + CurrentOffset);

        // is this a second line of the same header value?  check for continuation
        //
        if (IS_HTTP_LWS(CurrentChar))
        {
            ASSERT(pHeader[CurrentOffset-1] == LF);
            ASSERT(CurrentOffset >= 2);

            // Replace the CRLF|LFLF with SPSP
            //
            pHeader[CurrentOffset-1] = SP;
            pHeader[CurrentOffset-2] = SP;

            // Skip this WS char
            //
            CurrentOffset += 1;

            // Find the real end of the header value
            //
            goto look_for_crlf;
        }

        // All done!
        //
        *pEncodedWord = HaveEncodedWord;
        *pBytesTaken = CurrentOffset;
        return STATUS_SUCCESS;
    }

    // Did not find the end of a header, let's get more buffer..
    //
    *pBytesTaken = 0;
    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Append a header value to an existing HTTP_HEADER entry, allocating
    a buffer and copying the existing buffer.

Arguments:

    pHttpHeader     - Pointer to HTTP_HEADER structure to append to.
    pHeader         - Pointer header to be appended.
    HeaderLength    - Length of data pointed to by pHeader.

Return Value:

    TRUE if we succeed, FALSE otherwise.

--*/
NTSTATUS
AppendHeaderValue(
    PUL_HTTP_HEADER pHttpHeader,
    PUCHAR          pHeader,
    ULONG           HeaderLength
    )
{
    PUCHAR          pNewHeader, pOldHeader;
    ULONG           OldHeaderLength;


    OldHeaderLength = pHttpHeader->HeaderLength;

    pNewHeader = UL_ALLOCATE_ARRAY(
                        NonPagedPool,
                        UCHAR,
                        OldHeaderLength + HeaderLength + sizeof(", "), // sizeof gives space
                                                                       // for the NULL
                        UL_KNOWN_HEADER_POOL_TAG
                        );

    if (pNewHeader == NULL)
    {
        // Had a failure.
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the old data into the new header.
    //
    RtlCopyMemory(pNewHeader, pHttpHeader->pHeader, OldHeaderLength);

    // And copy in the new data as well, seperated by a comma.
    //
    *(pNewHeader + OldHeaderLength) = ',';
    *(pNewHeader + OldHeaderLength + 1) = ' ';
    OldHeaderLength += sizeof(", ") - 1;

    RtlCopyMemory( pNewHeader + OldHeaderLength, pHeader, HeaderLength);

    // Now replace the existing header.
    //
    pOldHeader = pHttpHeader->pHeader;
    pHttpHeader->HeaderLength = OldHeaderLength + HeaderLength;
    pHttpHeader->pHeader = pNewHeader;

    // If the old header was our buffer, free it too.
    //
    if (pHttpHeader->OurBuffer)
    {
        UL_FREE_POOL( pOldHeader, UL_KNOWN_HEADER_POOL_TAG );
    }

    pHttpHeader->OurBuffer = 1;

    //
    // null terminate it
    //

    pHttpHeader->pHeader[pHttpHeader->HeaderLength] = ANSI_NULL;

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  this does not allow multiple header
    values to exist for this header.  use MultipleHeaderHandler for 
    handling that by appending the values together (CSV) .

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
SingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID,
    OUT ULONG  *            pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    ULONG       HeaderValueLength;
    BOOLEAN     EncodedWord;

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pRequest, 
                    pHeader, 
                    HeaderLength, 
                    &EncodedWord, 
                    &BytesTaken
                    );
                    
    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken > 0)
    {
        // Strip of the trailing CRLF from the header value length
        //
        HeaderValueLength = BytesTaken - CRLF_SIZE;

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // Was it encoded at all?
        //
        
        pRequest->Headers[HeaderID].Encoded = EncodedWord ? 1 : 0;

        // do we have an existing header?
        //
        if (pRequest->Headers[HeaderID].Valid == 0)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->Headers[HeaderID].Valid = 1;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(WCHAR);

        }
        else
        {
            //
            // uh oh.  Have an existing header, fail the request.
            //

            pRequest->ErrorCode = UlErrorHeader;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!SingleHeaderHandler(pRequest = %p, pHeader = %p)\n"
                        "    ERROR: multiple headers not allowed.\n",
                        pRequest,
                        pHeader
                        ));
            
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // SingleHeaderHandler

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  this function handles multiple 
    headers with the same name, and appends the values together seperated
    by commas.

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
MultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST       pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID,
    OUT ULONG  *            pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    ULONG       HeaderValueLength;
    BOOLEAN     EncodedWord;

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pRequest, 
                    pHeader, 
                    HeaderLength, 
                    &EncodedWord, 
                    &BytesTaken
                    );
                    
    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken > 0)
    {
        // Strip of the trailing CRLF from the header value length
        //
        HeaderValueLength = BytesTaken - CRLF_SIZE;

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // Was it encoded at all?
        //
        
        pRequest->Headers[HeaderID].Encoded = EncodedWord ? 1 : 0;

        // do we have an existing header?
        //
        if (pRequest->Headers[HeaderID].Valid == 0)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->Headers[HeaderID].Valid = 1;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(WCHAR);

        }
        else
        {
            ULONG OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pRequest->Headers[HeaderID].HeaderLength;

            Status = AppendHeaderValue(
                            &pRequest->Headers[HeaderID],
                            pHeader,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Update total request length for the amount we just added.
            // space for the terminator is already in there
            //

            pRequest->TotalRequestSize +=
                (pRequest->Headers[HeaderID].HeaderLength - OldHeaderLength) * 
                    sizeof(WCHAR);

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // MultipleHeaderHandler
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\udebug.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug-specific declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


// #if DBG
#if 0

//
// Initialization/termination functions.
//

VOID
UlDbgInitializeDebugData(
    VOID
    );

VOID
UlDbgTerminateDebugData(
    VOID
    );

//
// Driver entry/exit notifications.
//

VOID
UlDbgEnterDriver(
    IN PSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgLeaveDriver(
    IN PSTR pFunctionName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_ENTER_DRIVER( function, pirp )                                   \
    UlDbgEnterDriver(                                                       \
        (function),                                                         \
        (pirp),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_LEAVE_DRIVER( function )                                         \
    UlDbgLeaveDriver(                                                       \
        (function),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// An instrumented resource.
//

#define MAX_RESOURCE_NAME_LENGTH    64

typedef struct _UL_ERESOURCE
{
    //
    // The actual resource.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    ERESOURCE Resource;

    //
    // Links onto the global resource list.
    //

    LIST_ENTRY GlobalResourceListEntry;

    //
    // Pointer to the thread that owns this lock exclusively.
    //

    PETHREAD pExclusiveOwner;

    //
    // Statistics.
    //

    LONG ExclusiveCount;
    LONG SharedCount;
    LONG ReleaseCount;

    //
    // The name of the resource, for display purposes.
    //

    UCHAR ResourceName[MAX_RESOURCE_NAME_LENGTH];

} UL_ERESOURCE, *PUL_ERESOURCE;

NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    );

BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    );

#define UlInitializeResource( resource, name, param )                       \
    UlDbgInitializeResource(                                                \
        (resource),                                                         \
        (name),                                                             \
        (ULONG_PTR)(param),                                                 \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlDeleteResource( resource )                                        \
    UlDbgDeleteResource(                                                    \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceExclusive( resource, wait )                        \
    UlDbgAcquireResourceExclusive(                                          \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceShared( resource, wait )                           \
    UlDbgAcquireResourceShared(                                             \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseResource( resource )                                       \
    UlDbgReleaseResource(                                                   \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->Resource.SystemResourcesList.Flink != NULL)


//
// An instrumented spinlock.
//

typedef struct _UL_SPIN_LOCK    // SpinLock
{
    //
    // The actual lock.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    KSPIN_LOCK KSpinLock;

    //
    // The name of the spinlock, for display purposes.
    //

    PSTR pSpinLockName;

    //
    // Pointer to the thread that owns this lock.
    //

    PETHREAD pOwnerThread;

    //
    // Statistics.
    //

    PSTR pLastAcquireFileName;
    PSTR pLastReleaseFileName;
    USHORT LastAcquireLineNumber;
    USHORT LastReleaseLineNumber;
    ULONG OwnerProcessor;
    LONG Acquisitions;
    LONG Releases;
    LONG AcquisitionsAtDpcLevel;
    LONG ReleasesFromDpcLevel;
    LONG Spare;

} UL_SPIN_LOCK, *PUL_SPIN_LOCK;

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock )                               \
    &((pLock)->KSpinLock)

VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pSpinLockName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    );

BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    );

#define UlInitializeSpinLock( spinlock, name )                              \
    UlDbgInitializeSpinLock(                                                \
        (spinlock),                                                         \
        (name),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    UlDbgAcquireSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    UlDbgReleaseSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    UlDbgAcquireSpinLockAtDpcLevel(                                         \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    UlDbgReleaseSpinLockFromDpcLevel(                                       \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// Debug spew control.
// If you change or add a flag, please update the FlagTable
// in ul\test\dll\tul.c.
//

#undef IF_DEBUG
#define IF_DEBUG(a) if ( (UL_DEBUG_ ## a & g_UlDebug) != 0 )

#define UL_DEBUG_OPEN_CLOSE                 0x00000001
#define UL_DEBUG_SEND_RESPONSE              0x00000002
#define UL_DEBUG_SEND_BUFFER                0x00000004
#define UL_DEBUG_TDI                        0x00000008

#define UL_DEBUG_FILE_CACHE                 0x00000010
#define UL_DEBUG_CONFIG_GROUP_FNC           0x00000020
#define UL_DEBUG_CONFIG_GROUP_TREE          0x00000040
#define UL_DEBUG_REFCOUNT                   0x00000080

#define UL_DEBUG_HTTP_IO                    0x00000100
#define UL_DEBUG_ROUTING                    0x00000200
#define UL_DEBUG_URI_CACHE                  0x00000400
#define UL_DEBUG_PARSER                     0x00000800

#define UL_DEBUG_SITE                       0x00001000
#define UL_DEBUG_WORK_ITEM                  0x00002000

#define UL_DEBUG_PARSER2                    0x80000000

#define DEBUG


//
// Tracing.
//

#define UlTrace(a, _b_)                                                     \
    do                                                                      \
    {                                                                       \
        IF_DEBUG(##a)                                                       \
        {                                                                   \
            DbgPrint _b_ ;                                                  \
        }                                                                   \
    } while (FALSE)


//
// Debug pool allocator.
//

PVOID
UlDbgAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreePool (
    IN PVOID pPointer,
    IN ULONG Tag
    );

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    UlDbgAllocatePool(                                                      \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    UlDbgFreePool(                                                          \
        (ptr),                                                              \
        (tag)                                                               \
        )

//
// Exception filter.
//

LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_EXCEPTION_FILTER()                                               \
    UlDbgExceptionFilter(                                                   \
        GetExceptionInformation(),                                          \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )


//
// Invalid completion routine for catching incomplete IRP contexts.
//

VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Error handlers.
//

NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define RETURN(status)                                                      \
    return UlDbgStatus(                                                     \
                (status),                                                   \
                __FILE__,                                                   \
                __LINE__                                                    \
                )

#define CHECK_STATUS(status)                                                \
    UlDbgStatus(                                                            \
        (status),                                                           \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

//
// Random structure dumpers.
//

VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PSTR pName
    );

VOID
UlDbgDumpHttpConnection(
    IN struct _HTTP_CONNECTION *pConnection,
    IN PSTR pName
    );


//
// IO wrappers.
//

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateIrp( stack, quota )                                       \
    UlDbgAllocateIrp(                                                       \
        (stack),                                                            \
        (quota),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeIrp( pirp )                                                   \
    UlDbgFreeIrp(                                                           \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCallDriver( pdevice, pirp )                                       \
    UlDbgCallDriver(                                                        \
        (pdevice),                                                          \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCompleteRequest( pirp, boost )                                    \
    UlDbgCompleteRequest(                                                   \
        (pirp),                                                             \
        (boost),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#else   // !DBG

//
// Disable all of the above.
//

#define UL_ENTER_DRIVER( function, pirp )
#define UL_LEAVE_DRIVER( function )

#define UL_ERESOURCE ERESOURCE
#define PUL_ERESOURCE PERESOURCE

#define UlInitializeResource( resource, name, param )                       \
    ExInitializeResource( (resource) )

#define UlDeleteResource( resource )                                        \
    ExDeleteResource( (resource) )

#define UlAcquireResourceExclusive( resource, wait )                        \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusive( (resource), (wait) );                   \
    } while (FALSE)

#define UlAcquireResourceShared( resource, wait )                           \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceShared( (resource), (wait) );                      \
    } while (FALSE)

#define UlReleaseResource( resource )                                       \
    do                                                                      \
    {                                                                       \
        ExReleaseResource( (resource) );                                    \
        KeLeaveCriticalRegion();                                            \
    } while (FALSE)

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->SystemResourcesList.Flink != NULL)

#define UL_SPIN_LOCK KSPIN_LOCK
#define PUL_SPIN_LOCK PKSPIN_LOCK

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock ) (pLock)

#define UlInitializeSpinLock( spinlock, name )                              \
    KeInitializeSpinLock( (spinlock) )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    KeAcquireSpinLock( (spinlock), (oldirql) )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    KeReleaseSpinLock( (spinlock), (oldirql) )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    KeAcquireSpinLockAtDpcLevel( (spinlock) )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    KeReleaseSpinLockFromDpcLevel( (spinlock) )

#undef IF_DEBUG
#define IF_DEBUG(a) if (FALSE)
#define DEBUG if ( FALSE )

#define UlTrace(a, _b_)                                                     \
    // do {printf _b_; printf( " - line #%d.\n", __LINE__ ); } while(0)

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
	HeapAlloc( GetProcessHeap(), 0 , (len) )

#define UL_FREE_POOL( ptr, tag )                                            \
	HeapFree( GetProcessHeap(), 0 , (ptr) )

#define UL_EXCEPTION_FILTER() EXCEPTION_EXECUTE_HANDLER

#define RETURN(status) return (status)
#define CHECK_STATUS(Status)

#define UlAllocateIrp( stack, quota )                                       \
    IoAllocateIrp( (stack), (quota) )

#define UlFreeIrp( pirp )                                                   \
    IoFreeIrp( (pirp) )

#define UlCallDriver( pdevice, pirp )                                       \
    IoCallDriver( (pdevice), (pirp) )

#define UlCompleteRequest( pirp, boost )                                    \
    IoCompleteRequest( (pirp), (boost) )



#endif  // DBG

// BUGBUG: ALIGN_UP(PVOID) won't work, it needs to be the type of the first entry of the
// following data (paulmcd 4/29/99)

#define UL_ALLOCATE_STRUCT_WITH_SPACE(pt,ot,cb,t)   \
    (ot *)(UL_ALLOCATE_POOL(pt,ALIGN_UP(sizeof(ot),PVOID)+(cb),t))

#define UL_ALLOCATE_STRUCT(pt,ot,t)                 \
    (ot *)(UL_ALLOCATE_POOL(pt,sizeof(ot),t))

#define UL_ALLOCATE_ARRAY(pt,et,c,t)                \
    (et *)(UL_ALLOCATE_POOL(pt,sizeof(et)*(c),t))

#define UL_FREE_POOL_WITH_SIG(a,t)                  \
    do {                                            \
        (a)->Signature = MAKE_FREE_TAG(t);          \
        UL_FREE_POOL(a,t);                          \
        (a) = NULL;                                 \
    } while (0)

#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ulrtl\_hashfn.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKHash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

        Paul McDaniel (paulmcd)     Feb-05-1999     Trimmed for kernel mode
                                                    and C (not C++)

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKHash applies this internally
// to all hash signatures for exactly this reason.

__inline ULONG
HashScramble(ULONG dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const ULONG RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const ULONG RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKHash.

__inline ULONG
HashStringA(
    const char* psz,
    ULONG       dwHash)
{
    for (  ;  *psz;  ++psz)
        dwHash = 37 * dwHash  +  *psz;

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  *pwsz;

    return dwHash;
}

__inline ULONG
HashCharW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    Hash = 37 * Hash + UnicodeChar;
    return Hash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKHash.
// Note: this is not really adequate for MBCS strings.

__inline ULONG
HashStringNoCaseA(
    const char* psz,
    ULONG       dwHash)
{
    for (  ;  *psz;  ++psz)
        dwHash = 37 * dwHash  +  (*psz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringNoCaseW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  (*pwsz & 0xFFDF);

    return dwHash;
}

__inline ULONG
HashCharNoCaseW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    Hash = 37 * Hash + (UnicodeChar & 0xFFDF);
    return Hash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
//
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
//
//     inline ULONG Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
//
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     ULONG Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           37 * Hash(rFoo.m_ch)  +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKHash.

__inline ULONG
HashBlob(
    PUCHAR      pb,
    ULONG       cb,
    ULONG       dwHash)
{
    while (cb-- > 0)
        dwHash = 37 * dwHash  +  *pb++;

    return dwHash;
}


// ======= <snip>
//
//  paulmcd: a bunch snipped due to use of overloading, not allowed in C
//
// ======= <snip>

__inline ULONG HashFloat(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        ULONG dw;
    } u;
    u.f = f;
    return u.dw;
}

__inline ULONG HashDouble(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        ULONG  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * 37  +  u.dw[1];
}

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\common\makefile.inc ===
CDROOT=$(_NTTREE)\inetsrv
SymbolsROOT=$(_NTTREE)\symbols\inetsrv\dll

copyfile:
!ifdef _NTTREE
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	if not exist "$(SymbolsROOT)" mkdir $(SymbolsROOT)

#       copy wwwroot
	xcopy /verifdy ..\wwwroot $(CDROOT)\wwwroot
	rd /s /q $(CDROOT)\wwwroot\iissamp\homepage
	rename $(CDROOT)\wwwroot\iissamp\hp homepage
	rename $(CDROOT)\wwwroot\iissamp\homepage\tms themes

#       copy admin samples stuff
	xcopy /verifdy ..\admsamp          $(CDROOT)\admsamp

#       copy html admin stuff over
	xcopy /verifdy ..\htmla $(CDROOT)\htmla

#	copy iisdoc stuff
#	xcopy /verifdy ..\help\relnotes    $(CDROOT)\help\relnotes
#	xcopy /verifdy ..\help\iisnts\htm\sdk          $(CDROOT)\help\sdk
#	xcopy /verifdy ..\help\iisnts\htm\mm           $(CDROOT)\help\mm
	echo f |xcopy /verifdy ..\help\pwsw95\misc\tips.dat    $(CDROOT)\help\tips.dat
	-del $(CDROOT)\help\common\DialogLayout.class
	-del $(CDROOT)\help\common\ElementList.class
	-del $(CDROOT)\help\common\IndexPanel.class
	-del $(CDROOT)\help\common\RelatedDialog.class
	-del $(CDROOT)\help\common\SitemapParser.class
	-del $(CDROOT)\help\common\TreeCanvas.class
	xcopy /verifdy ..\help\common                  $(CDROOT)\help\common
	rename $(CDROOT)\help\common\DialogLa.class DialogLayout.class
	rename $(CDROOT)\help\common\ElementL.class ElementList.class
	rename $(CDROOT)\help\common\IndexPan.class IndexPanel.class
	rename $(CDROOT)\help\common\RelatedD.class RelatedDialog.class
	rename $(CDROOT)\help\common\SiteMapP.class SitemapParser.class
	rename $(CDROOT)\help\common\TreeCanv.class TreeCanvas.class
	
	xcopy /verifd ..\help\fonts                   $(CDROOT)\help\fonts
	xcopy /verifd ..\help\htmldocs                $(CDROOT)\help\htmldocs
	xcopy /verifd ..\help\iisnts\htm\admsamp      $(CDROOT)\help\admsamp
	xcopy         ..\help\default.htm             $(CDROOT)\help
	xcopy /verifd ..\help\iisnts\htm\core    $(CDROOT)\help\NTS\ismcore\core
	xcopy /verifd ..\help\iisnts\misc        $(CDROOT)\help\NTS\ismcore\misc
	xcopy         ..\help\iisnts\default.htm $(CDROOT)\help\NTS\ismcore
	xcopy /verifd ..\help\iisntw\htm\core    $(CDROOT)\help\NTW\ismcore\core
	xcopy /verifd ..\help\iisntw\misc        $(CDROOT)\help\NTW\ismcore\misc
	xcopy         ..\help\iisntw\default.htm $(CDROOT)\help\NTW\ismcore
#	xcopy /verifd ..\help\pwsw95\htm\core    $(CDROOT)\help\W95\pwmcore\core
	xcopy /verifd ..\help\pwsw95\misc        $(CDROOT)\help\W95\pwmcore\misc

	del                                   $(CDROOT)\help\W95\pwmcore\misc\tips.dat
	xcopy         ..\help\pwsw95\default.htm $(CDROOT)\help\W95\pwmcore
	xcopy /verifdy ..\help\iisnts\htm\asp      $(CDROOT)\help\asp
	xcopy /verifdy ..\help\iisnts\htm\tutorial $(CDROOT)\help\tutorial

#       copy custom error stuff over
	xcopy /verifd ..\custerr $(CDROOT)\custerr

	xcopy /verifdy ..\help\iisnts\winhelp $(CDROOT)\help\ismhelp
	xcopy /verifdy ..\help\pwsw95\winhelp $(CDROOT)\help\pwmhelp
	xcopy /verifdy ..\help\iisntw\htm\tour    $(CDROOT)\htmla\tour
	xcopy /verifdy ..\help\iisntw\bin    $(CDROOT)\help

#       copy over files which will go into winnt\help
	xcopy /verifdy ..\help\iisnts\htmlhelp $(CDROOT)\help\help\nts
	xcopy /verifdy ..\help\iisntw\htmlhelp $(CDROOT)\help\help\ntw

#	copy wolfpack ( clustering )stuff
#	xcopy /ry $(TARGET_DIRECTORY)\wp\regcladm.exe $(CDROOT)

#       copy aspjava files
	rd /s /q $(CDROOT)\AspJava
	xcopy /dy /i /r ..\aspjava\*.* $(CDROOT)\AspJava

#	copy sdk stuff
	xcopy /verifdy ..\sdksamp     $(CDROOT)\iissamp\sdk

#       copy new iis5 SSE docs
	xcopy /verifdy ..\help\sse     $(CDROOT)\help\sse

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\directives.inc ===
<%
' Support multiple character sets.
Session.Codepage = 65001
Response.Charset = "UTF-8"

Response.CacheControl = "no-cache"

'HTTP/1.0 Compatibility
Response.AddHeader "Pragma", "no-cache"

Response.Expires = 0

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iifixpth.inc ===
<%

'The physical directory may not currently
'exist in the metabase, so we have
'to find the closest parent associated with
'the dir and read the properties.

'assumes the following are defined:
' currentobj 
' path
' dirkeytype

Dim fpbaseobj, fpnewname, fpnewobj

if (Session("vtype") = "dir") then

	fpbaseobj = path

	if err = 0 then 
		'set the KeyType if it isn't already set...
		if currentobj.KeyType = "" then
			currentobj.KeyType = dirkeyType
			currentobj.SetInfo		
			Set currentobj=GetObject(currentobj.ADsPath)
		end if
	else
		Do While err <> 0	
		
			'response.write currentobj.ADsPath
			'we need clear our path not found error..	
			err = 0
			
			'and cyle through the fpbaseobj till we find the next whack,
			'building up the path in new name as we go		
			Do Until Right(fpbaseobj,1) = "/"
				fpnewname = Right(fpbaseobj,1) & fpnewname 		
				fpbaseobj = Mid(fpbaseobj,1,Len(fpbaseobj)-1)
			Loop
		
			'add the whack to the beginning of the path...
			fpnewname = "/" & fpnewname 	
			'response.write "<!-- " & fpnewname & "-->"
			
			'lop off the last whack...		
			fpbaseobj = Mid(fpbaseobj,1,Len(fpbaseobj)-1)			
			
			'and try to set the object again...		
			Set currentobj=GetObject(fpbaseobj)
			Response.write ""

		Loop

		'lop off the first whack...		
		fpnewname = Mid(fpnewname,2)	
		'Response.write currentobj.ADsPath & "<BR>"
		'Response.write dirkeytype & "<BR>"
		'Response.write fpnewname			& "<BR>"
		Set fpnewobj=currentobj.Create(dirkeyType, fpnewname)
		fpnewobj.SetInfo
		'response.write fpnewobj.ADsPath
		Set currentobj=GetObject(fpnewobj.ADsPath)	
	end if	
end if

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiaspstr.inc ===
<%
' iiaspstr.inc

' Function:		sJSLiteral
' Arguments:	String s [in]
' Return:		String
'
' Utility function to fix problems that can happen when using an ASP string
' variable as a JavaScript string literal. If the string variables may contain
' embeded single or double quotes (', ") or back slashes (\) then sJSLiteral
' should be used to escape these invalid characters
'

Const iSingleQuote = 39
Const iDoubleQuote = 34
Const sBackSlash = "\"

Dim sLiterals
sLiterals = Array( sBackSlash, "" & Chr(iSingleQuote), "" & Chr(iDoubleQuote) )

Function sJSLiteral( s )
    Dim i, pos, length, sNew
    
    length = Len(s)
    pos = 0
    sNew = s
    For i = LBound(sLiterals) To UBound(sLiterals)
        Do
            pos = InStr(pos + 1, sNew, CStr(sLiterals(i)), 0)
            If pos > 0 Then
                sNew = Left(sNew, pos - 1) & sBackSlash & CStr(sLiterals(i)) & Right(sNew, length - pos)
                length = Len(sNew)
                pos = pos + 1
            End If
        Loop Until pos = 0
    Next
    
    sJSLiteral = sNew
End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iihding.inc ===
<%
function heading(colwidth,thestring,sortstr)
	dim writeStr, listSort
	listSort = Session("ListSort")
	writeStr = "<TD VALIGN='bottom' WIDTH = " & colwidth & " BORDERCOLOR=" & Session("BGCOLOR") & " BORDERCOLORDARK='#FFFFFF' BORDERCOLORLIGHT='#000000'"
	if listSort and (sortstr <> "") then
	
		if Session("hasDHTML") then
			writeStr = writeStr & " OnCLick=" & quote & "parent.head.sortList('" & sortstr & "');" & quote
			writeStr = writeStr & " style='cursor: hand;'"
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)
			writeStr = writeStr & thestring		
		else
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)				
			writeStr = writeStr &  "<A HREF = " & quote & "javascript:parent.head.sortList('"& sortstr & "');" & quote & ">" & thestring & "</A>"
		end if
	else
		writeStr = writeStr & ">"
		writeStr = writeStr & sFont("","","",True)
		writeStr = writeStr & thestring
	end if
	writeStr = writeStr & "</TD>"
		
	heading = writeStr
end function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iibind.inc ===
<% 

function getBinding(bindstr)

	Dim one, two, ia, ip, hn
	
	one=Instr(bindstr,":")
	two=Instr((one+1),bindstr,":")
	
	ia=Mid(bindstr,1,(one-1))
	ip=Mid(bindstr,(one+1),((two-one)-1))
	hn=Mid(bindstr,(two+1))

	
	getBinding=Array(ia,ip,hn)
end function

' Boolean value used only by iivs.asp (Web sites)
Dim multibind

' Included in iivs.asp (web) and iifvs.asp (ftp)
'
' function writeBinding
'
' Writes out the controls that display the service/sites IP and Port information.
' This function is shared by both web and ftp sites
'
' DEFAULTPORT 				- defined differently by iivs.asp and iifvs.asp
' currentobj				- initialized in iivs.asp and iifvs.asp
' Session("vtype") = "svc" 	- indicates that we are looking at the master properties
'
function writeBinding(fieldname,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly)
	On Error Resume Next 
	
	' Common binding declarations - Web and Ftp sites
	Dim aBinding, Binding, host, ipport, ipaddress, readonly

	' Secure binding definitions - Ftp sites only
	Dim aSecBinding, SecBinding, secport, j

	' Get the bindings from our current object and set any defaults if necessary
	aBinding=currentobj.ServerBindings

	if Session("vtype") = "svc" then
		multibind = false
		readonly = true
		Binding=split(aBinding(0),":")		
	else
		if aBinding(0) <> "" then
			multibind=(UBound(aBinding)>0)
			readonly = multibind
			Binding=split(aBinding(0),":")
		else
			readonly=false
			aBinding(0)=":" & DEFAULTPORT & ":"
			Binding=split(aBinding(0),":")
		end if
	end if

	' Write out the binding for a specific fieldname
	if fieldname="Host" then
		host=Binding(2)
		if readonly then
			writeBinding=host & inputbox(err,"hidden","hdnHost",host,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)				
		else
			writeBinding=inputbox(err,"hidden","hdnHost",host,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)
		end if

	elseif fieldname="IPPort" then
		ipport=Binding(1)

		if readonly then
			if ipport="" then
				ipport=DEFAULTPORT
			end if			
			writeBinding=ipport & inputbox(err,"hidden","hdnPort",ipport,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)				
		else			
			writeBinding=inputbox(err,"TEXT","hdnPort",ipport,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)
		end if

	elseif fieldname="IPAddress" then
		ipaddress=Binding(0)
		if ipaddress="" then
			ipaddress=L_ALLUNASSIGNED_TEXT
		end if			
		if readonly then								
			writeBinding=ipaddress & inputbox(err,"hidden","hdnIPA",ipaddress,fieldsize,onchangeproc,onfocusproc, onblurproc,True,adminonly,False)				
		else
			writeBinding=inputbox(err,"TEXT","hdnIPA",ipaddress,fieldsize,onchangeproc,onfocusproc, onblurproc,True,adminonly,False)
		end if

	elseif fieldname="SecureBinding" then
		' This only applies to Web sites
		secPort=""
		aSecBinding=currentobj.SecureBindings
		if aSecBinding(0) <> "" then 
		arraybound=UBound(aSecBinding)			
		for j=0 to arraybound
			SecBinding=split(aSecBinding(0),":")
			if SecBinding(0)=Binding(0) then
				secPort=SecBinding(1)
				exit for
			end if
		Next
		end if 

		if readonly then
			writeBinding=secPort & inputbox(err,"hidden","hdnSecBinding",secPort,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)
		else
			writeBinding=inputbox(err,"TEXT","hdnSecBinding",secPort,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly,False)
		end if 

	end if
end function

 %>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\date.inc ===
<%

' Use these constants as parameters to the UIDateFormat constructor to
' determine the format used in getDate()
Const DATEFORMAT_LONG = 0
Const DATEFORMAT_SHORT = 1

%>

<SCRIPT LANGUAGE="JavaScript">

MONTHS = new Array()
MONTHS[0] = "<%= L_JAN_TEXT %>";
MONTHS[1] = "<%= L_FEB_TEXT %>";
MONTHS[2] = "<%= L_MAR_TEXT %>";
MONTHS[3] = "<%= L_APR_TEXT %>";
MONTHS[4] = "<%= L_MAY_TEXT %>";
MONTHS[5] = "<%= L_JUN_TEXT %>";
MONTHS[6] = "<%= L_JUL_TEXT %>";
MONTHS[7] = "<%= L_AUG_TEXT %>";
MONTHS[8] = "<%= L_SEP_TEXT %>";
MONTHS[9] = "<%= L_OCT_TEXT %>";
MONTHS[10] = "<%= L_NOV_TEXT %>";
MONTHS[11] = "<%= L_DEC_TEXT %>";

DAYS = new Array()
DAYS[0] = "<%= L_SUN_TEXT %>";
DAYS[1] = "<%= L_MON_TEXT %>";
DAYS[2] = "<%= L_TUE_TEXT %>";
DAYS[3] = "<%= L_WED_TEXT %>";
DAYS[4] = "<%= L_THU_TEXT %>";
DAYS[5] = "<%= L_FRI_TEXT %>";
DAYS[6] = "<%= L_SAT_TEXT %>";

DAYTIME = new Array()
DAYTIME[0] = "<%= L_MORNING_TEXT %>"
DAYTIME[1] = "<%= L_AFTERNOON_TEXT %>"

// UIDateFormat
//
// Date conversion class. To use: create a UIDateFormat object
// with a flag indicating the type of date formatting desired
// (DATEFORMAT_LONG or DATEFORMAT_SHORT) and use the getDate()
// and getTime() methods to return a locale formatted date.
function UIDateFormat( fDateFormat )
{
	// Public interface - use these methods to display localized dates.
	// Both methods take a single JavaScript Date object as a parameter.
	this.getDate = uidGetDate;
	this.getTime = uidGetTime;

	// Implementation
	this.iDaytimeIndex = 0;
	this.strTimeFormat = "<%= L_TIME_FORMAT_TEXT %>";

	// strDate format can be changed to point to the long or short
	// date format as needed by the particular page.
	if( fDateFormat == <%= DATEFORMAT_LONG %> )
	{
		this.strDateFormat = "<%= L_DATE_LONGFORMAT_TEXT %>";
	}
	else
	{
		this.strDateFormat = "<%= L_DATE_SHORTFORMAT_TEXT %>";
	}
	this.strTimeTokens = "hHms";
	this.strDateTokens = "dMy";
	
	// helper methods
	this.uidTimeStringPartFromToken = uidTimeStringPartFromToken;
	this.uidDateStringPartFromToken = uidDateStringPartFromToken;
}

// getNeutralDateString
//
// Global utility function. Formats a date into a neutral format m/d/yyyy.
// This shouldn't be displayed, but rather used to save the date
// part in a format that doesn't lose any information.
function getNeutralDateString( date )
{
	var theYear = date.getYear();
	if( theYear < 1000 )
	{
		theYear += 1900;
	}
	var theMonth = date.getMonth() + 1;

	return "" + theMonth + "/" + date.getDate() + "/" + theYear;
}

// uidGetDate
//
// Returns the date part of the string. Called through UIDate.getDate().
// Make a single pass through the date format string, extracting format
// tokens. Uses uidDateStringPartFromToken() to interpret found tokens.
//
// date - the date value being translated
function uidGetDate( date )
{
	var strOut = "";
	var i = 0, j = 0;
	var nFormatStrLen = this.strDateFormat.length;
	var c;
	var nTokenType = -1;

	for( i = 0; i < nFormatStrLen; i++ )
	{
		c = this.strDateFormat.charAt(i);
		nTokenType = this.strDateTokens.indexOf( c );
		if(  nTokenType != -1 )
		{
			// We found a token
			
			// Move to the next position after the current token.
			for( j = i + 1; j < nFormatStrLen; j++ )
			{
				if( c != this.strDateFormat.charAt(j) )
				{
					break;
				}
			}
			strOut += this.uidDateStringPartFromToken( date, nTokenType, j - i );
			i = j - 1;
		}
		else if( c == "'" )
		{
			// Interpret characters between single quotes as multichar literals

			// Skip over characters between the single quotes
			for( j = i + 1; j < nFormatStrLen; j++ )
			{
				if( c == this.strDateFormat.charAt(j) )
				{
					break;
				}
			}
			strOut += this.strDateFormat.substring( i + 1, j );
			i = j;
		}
		else
		{
			// literal character not quote delimited.
			strOut += c;
		}
	}
	return strOut;
}

// uidDateStringPartFromToken
//
// Returns a string representing the localized value of the date part
// indicated by nTokenType.
//
// date - the javascript date value being translated
// nTokenType - position in token string - "dMy"
// nTokenChars - number of characters comprising the token
function uidDateStringPartFromToken( date, nTokenType, nTokenChars )
{
	var strOut = "";
	var datePart;

	if( nTokenType == 0 )
	{
		// Days
		if( nTokenChars > 2 )
		{
			// The day of the week
			strOut += DAYS[date.getDay()];
		}
		else
		{
			// The day of the month
			datePart = date.getDate();
			if( datePart < 10 && nTokenChars == 2 )
			{
				strOut += "0";
			}
			strOut += datePart;
		}
	}
	else if( nTokenType == 1 )
	{
		// Months
		datePart = date.getMonth();
		if( nTokenChars > 2 )
		{
			// Month as string
			strOut += MONTHS[datePart];
		}
		else
		{
			// Month as integer
			datePart++;
			if( datePart < 10 && nTokenChars == 2 )
			{
				strOut += "0";
			}
			strOut += datePart;
		}
	}
	else if( nTokenType == 2 )
	{
		// Year
		
		// Get the full year as a workaround for JavaScript bogusness.
		datePart = date.getYear();
		if( datePart < 1000 )
		{
			datePart += 1900;
		}
		strOut += datePart;
		if( nTokenChars < 4 )
		{
			// two digit year
			strOut = strOut.substring( 2, 4 );
		}
	}
	return strOut;
}

// uidGetTime
// Converts the date into a time string. Call through UIDate.getTime( date )
//
// date - the javascript date value being translated
function uidGetTime( date )
{
	var strOut = "";
	var i = 0, j = 0;
	var nFormatStrLen = this.strTimeFormat.length;
	var c;
	var nTokenType = -1;
	var nDaytimeStart = -1;
	var nDaytimeLen = 0;

	for( i = 0; i < nFormatStrLen; i++ )
	{
		c = this.strTimeFormat.charAt(i);
		nTokenType = this.strTimeTokens.indexOf( c );
		if(  nTokenType != -1 )
		{
			// We found a token
			j = i + 1;
			if( c == this.strTimeFormat.charAt(j) )
			{
				// double token
				j++;
			}
			strOut += this.uidTimeStringPartFromToken( date, nTokenType, j - i );
			
			// skip the token
			i = j - 1;
		}
		else if( c == 't' )
		{
			// This is the daytime designation. Since we may not yet know
			// if it's morning or afternoon, save the current position in
			// the string, and the number of t's. Just dump the t's back
			// into the string, we'll replace them later when we know
			// what time of the day it is.
			nDaytimeStart = strOut.length;
			nDaytimeLen = 0;
			// It would be nice to do-while, but 3.0 browsers choke on it
			while( c == this.strTimeFormat.charAt(i + nDaytimeLen) )
			{
				nDaytimeLen++;
				strOut += c;
			}

			// skip the token
			i += (nDaytimeLen - 1);
		}
		else
		{
			strOut += c;
		}
	}

	// Insert the daytime designation into the string, if we found one
	if( nDaytimeStart != -1 )
	{
		strOut = 	strOut.substring( 0, nDaytimeStart ) +
					DAYTIME[this.iDaytimeIndex] +
					strOut.substring( nDaytimeStart + nDaytimeLen );
	}
	return strOut;
}

// uidTimeStringPartFromToken
//
// Returns the time string value indicted by nTokenType
//
// date - the date value being translated
// nTokenType - the position in the token string
// nTokenChars - the number of consecutive tokens in the format string
function uidTimeStringPartFromToken( date, nTokenType, nTokenChars )
{
	var strOut = "";
	var timePart;

	if( nTokenType <= 1 )
	{
		// Use the hour indicator to determine whether it's AM/PM and
		// determine if we need to reparse
		timePart = date.getHours();
		if( timePart < 12 )
		{
			this.iDaytimeIndex = 0;
		}
		else
		{
			this.iDaytimeIndex = 1;
		}
		
		if( nTokenType == 0 )
		{
			// Using 12 hour clock
			if( timePart > 12 )
			{
				timePart -= 12;
			}
		}
	}
	else if( nTokenType == 2 )
	{
		timePart = date.getMinutes();
	}
	else if( nTokenType == 3 )
	{
		timePart = date.getSeconds();
	}

	if( nTokenChars > 1 && timePart < 10 )
	{
		strOut = "0";
	}

	strOut += timePart;
	return strOut;
}

</SCRIPT>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iisetfnt.inc ===
<%


if Session("FONTSCALE") = "" then
	Session("FONTSCALE") = 1
end if
if Session("FONTFACE") = "" then
	Session("FONTFACE") = "Helv"
end if
if Session("FONTPOINT") = "" then
	Session("FONTPOINT") = 1	
end if
if Session("BrowserVScalePct") = "" then
	Session("BrowserVScalePct") = 100
end if
if Session("BrowserHScalePct") = "" then
	Session("BrowserHScalePct") = 100
end if

Function sFont(iSize,sFace,sColor,bScale)
	Dim sOutputStr

	sOutputStr = "<FONT"
	if sFace <> "" then
			sOutputStr = sOutputStr & " FACE='" & sFace & "'"
	else
			sOutputStr = sOutputStr & " FACE='" & Session("FONTFACE") & "'"
	end if 

	if iSize = "" then
		iSize = cInt(Session("FONTPOINT"))
	end if
	if bScale then
		iSize = cInt(iSize * Session("FONTSCALE"))
	end if
	sOutputStr = sOutputStr & " SIZE=" & iSize
	if sColor <> "" then
			sOutputStr = sOutputStr & " COLOR=" & sColor
	end if
	
	sOutputStr = sOutputStr & ">"

	sFont = sOutputStr
End Function



Function iVScale(iSize)
	iVScale = iScale(iSize,"BrowserVScalePct")
End Function

Function iHScale(iSize)
	iHScale = iScale(iSize,"BrowserHScalePct")
End Function


Function iScale(iSize,direction)
	if iSize <> 0 then
		iScale = cInt((Session(direction) * iSize)/100)
	else
		iScale = iSize	
	end if
End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiset.inc ===
<% 

dim quote,isAdmin,disabletextstart,disableintstart,disabletextend
dim bUpdateGlobal

bUpdateGlobal = true

quote=chr(34)

disabletextstart= "<TABLE BORDER=1  BORDERCOLORLIGHT=" & quote & "#000000" & quote & " BORDERCOLORMEDIUM=" & quote & "#000000" & quote & " BORDERCOLORDARK=" & quote & "Gray" & quote & "><TR><TD BGCOLOR=" & quote & "#C0C0C0" & quote & " BORDERCOLOR=" & quote & "#C0C0C0" & quote & " BORDERCOLORLIGHT=" & quote & "#C0C0C0" & quote & " BORDERCOLORMEDIUM=" & quote & "#C0C0C0" & quote & " BORDERCOLORDARK=" & quote & "#C0C0C0" & quote & "WIDTH=300>"
disableintstart= "<TABLE BORDER=1  BORDERCOLORLIGHT=" & quote & "#000000" & quote & " BORDERCOLORMEDIUM=" & quote & "#000000" & quote & " BORDERCOLORDARK=" & quote & "Gray" & quote & "><TR><TD BGCOLOR=" & quote & "#C0C0C0" & quote & " BORDERCOLOR=" & quote & "#C0C0C0" & quote & " BORDERCOLORLIGHT=" & quote & "#C0C0C0" & quote & " BORDERCOLORMEDIUM=" & quote & "#C0C0C0" & quote & " BORDERCOLORDARK=" & quote & "#C0C0C0" & quote & "WIDTH=75>"
disabletextend="</TD></TR></TABLE>"

isAdmin=Session("isAdmin")

function checkboxmask(fieldname, fieldmask, onclickproc, adminonly)
	On Error Resume Next 
	Dim val
	
	if mid(fieldname,1,1)="!" then
		fieldname=mid(fieldname,2) 
		val=not (currentobj.Get(fieldname) and fieldmask)
	else
		val=(currentobj.Get(fieldname) and fieldmask)
	end if

	checkboxmask = writeCheckboxVal(err, val, fieldname, fieldmask, onclickproc, adminonly)
end function

function checkbox(fieldname, onclickproc, adminonly)
	On Error Resume Next 
	Dim val

	if mid(fieldname,1,1)="!" then
		fieldname=mid(fieldname,2) 
		val=not currentobj.Get(fieldname)
	else
		val=currentobj.Get(fieldname)
	end if
	
	checkbox = checkboxVal(err,val,"chk" & fieldname,onclickproc,adminonly)

end function

function checkboxVal(err, val, fieldname, onclickproc, adminonly)
	On Error Resume Next 
	checkboxVal = writeCheckboxVal(err, val, fieldname, "", onclickproc, adminonly)
end function

function writeCheckboxVal(err, val, fieldname,fieldmask, onclickproc, adminonly)
	On Error Resume Next 
	Dim outputStr

	if err <> 0 then
		outputStr="<INPUT NAME='" & fieldname & "' TYPE='CHECKBOX'>"
		alertuser fieldname	
	else
		if (not adminonly) or isAdmin then
			if val then
				outputStr="<INPUT NAME='" & fieldname & "' TYPE='CHECKBOX' CHECKED"
			else
				outputStr="<INPUT NAME='" & fieldname & "' TYPE='CHECKBOX' "
			end if
			
			if fieldmask <> "" then				
				outputStr = outputStr & " VALUE=" & fieldmask 
			end if
						
			outputStr = outputStr & " OnClick=" & quote
			if bUpdateGlobal then
				outputStr = outputStr & "top.title.Global.updated=true;"
			end if

			if onclickproc <> "" then				
				outputStr = outputStr & onclickproc & quote & ">"
			else
				outputStr = outputStr & quote & ">"
			end if
		else
			if Session("hasDHTML") then
				if val then
					outputStr="<INPUT NAME='" & fieldname & "' TYPE='CHECKBOX' CHECKED DISABLED>"
				else
					outputStr="<INPUT NAME='" & fieldname & "' TYPE='CHECKBOX' CHECKED DISABLED>"
				end if				
			else
				
				if val then
					outputStr="<IMG ALIGN=middle SRC=" & quote & "images/checkon.gif" & quote & ">"
				else
					outputStr="<IMG ALIGN=middle SRC=" & quote & "images/checkoff.gif" & quote & ">"
				end if
			end if
		end if 
	end if
	writeCheckboxVal = outputStr	
end function


function printoption(selected, text, adminonly)
	'On Error Resume Next 
	if selected then
		printoption="<OPTION SELECTED>" & text
	else
		if (isadmin or not adminonly) then			
			printoption="<OPTION>" & text
		end if
	end if

end function



function getoption(fieldname,value, adminonly)
	'On Error Resume Next 
	Dim val
	val=currentobj.Get(fieldname)
	if err <> 0 then
		val = False
		alertuser fieldname			
	end if
	getoption = printoption((value=val),value,adminonly)
end function


function radio(fieldname,value, onclickproc, adminonly)
	On Error Resume Next 
	Dim val
	val=currentobj.Get(fieldname)
	if err <> 0 then
		radio=(printradio(fieldname, False,onclickproc,adminonly)) 
		alertuser "rdo" & fieldname	
	else
			if (typename(val)="Boolean") then
					output=printradio(fieldname, (val=value),onclickproc,adminonly)		
			else
				if mid(value,1,1)="!" then
					output=printradio(fieldname, (val <> mid(value,2)),onclickproc,adminonly)		
				else
					output=printradio(fieldname, (val=value),onclickproc,adminonly)
				end if
			end if 
		radio=output
	end if
end function

function printradio(fieldname, checked, onclickproc,adminonly)
	Dim output, chkstr
	
	if checked then
		chkstr="CHECKED"
	else
		chkstr=""
	end if 
	
	if ((not adminonly) or isAdmin) then
		output="<INPUT NAME=" & quote & "rdo" & fieldname & quote & " TYPE=" & quote & "RADIO" & quote & " " & chkstr
		output=output & " OnClick=" & quote

		if bUpdateGlobal then
			output = output & "top.title.Global.updated=true;"
		end if
		
		if onclickproc <> "" then
			printradio=output & onclickproc & quote & ">"
		else
			printradio=output & quote & ">"
		end if
	else
		if checked then
			printradio="<IMG SRC=" & quote & "images/radioon.gif" & quote & ">"
		else
			printradio="<IMG SRC=" & quote & "images/radiooff.gif" & quote & ">"
		end if
	end if 

end function

function text(fieldname,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly)
	On Error Resume Next 
	Dim val
	val=currentobj.Get(fieldname)
	text=inputbox(err,"text",fieldname,val,fieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,false)
end function

function pword(fieldname,fieldsize,onchangeproc,onfocusproc, onblurproc,hidden,adminonly)
	On Error Resume Next 
	Dim val
	val=currentobj.Get(fieldname)
	if ((not adminonly) or isAdmin) then
		pword=inputbox(err,"password",fieldname,val,fieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,false)
	else
		pword=disabletextstart & "*******" & disabletextend
	end if
	
end function

function writehidden(fieldname)
	On Error Resume Next 
	writehidden=inputbox(0,"hidden",fieldname,currentobj.Get(fieldname),"","","","",false,false,false)
end function

function inputbox(err,fieldtype,fieldname,val,fieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,readonly)
	inputbox = writeinputbox(err,fieldtype,fieldname,val,fieldsize,"",onchangeproc,onfocusproc,onblurproc,hidden,adminonly,readonly,false) 
end function

function inputboxfixed(err,fieldtype,fieldname,val,fieldsize,maxfieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,readonly)
	inputboxfixed = writeinputbox(err,fieldtype,fieldname,val,fieldsize,maxfieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,readonly,false) 
end function

function disabledbox(err,fieldtype,fieldname,val,fieldsize,maxfieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly)
	disabledbox = writeinputbox(err,fieldtype,fieldname,val,fieldsize,maxfieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,false,true)
end function

function writeinputbox(err,fieldtype,fieldname,val,fieldsize,maxfieldsize,onchangeproc,onfocusproc,onblurproc,hidden,adminonly,readonly,disabled)
	On Error Resume Next 
	Dim textstr
	if err <> 0 then
		textstr="<INPUT TYPE=" & quote & fieldtype & quote & " NAME=" & quote & fieldname & quote & " SIZE=" & fieldsize & ">"
		alertuser fieldname	
	else
		if ((not adminonly) or isAdmin) then
			textstr="<INPUT TYPE=" & quote & fieldtype & quote
			textstr=textstr & " NAME=" & quote & fieldname & quote
			if fieldsize <> "" then
				textstr = textstr & " SIZE = " & (Session("BrowserTBScalePct") * fieldsize/100)
			else
			end if 
			if maxfieldsize <> "" then
				textstr=textstr & " MAXLENGTH=" & maxfieldsize
			else
			end if 			
			textstr=textstr & " VALUE=" &  quote & val & quote
			textstr=textstr & " OnChange=" & quote
			
			if bUpdateGlobal then
				textstr = textstr & "top.title.Global.updated=true;"
			end if
			
			if onchangeproc <> "" then
				textstr=textstr & onchangeproc & quote
			else
				textstr=textstr & quote
			end if
			if onfocusproc <> "" then
				textstr=textstr & " OnFocus=" & quote & onfocusproc & quote
			end if
			if onblurproc <> "" then
				textstr=textstr & " OnBlur=" & quote & onblurproc & quote
			end if			
			if readonly then
				textstr=textstr & " READONLY"
			end if
			if disabled then
				textstr=textstr & " DISABLED"
			end if
			if Session("hasStyles") then 
				textstr=textstr & Session("DEFINPUTSTYLE")
			end if 
			textstr=textstr & ">"			
			if hidden then
				textstr=textstr & " <INPUT TYPE=" & quote & "hidden" & quote & " NAME=" & quote & "hdn" & fieldname & quote & " VALUE=" &  quote & val & quote & ">"
			end if			
		else	
		
			if Session("hasDHTML") then
					textstr="<INPUT TYPE=" & quote & fieldtype & quote & " NAME=" & quote & fieldname & quote & " SIZE=" & fieldsize & " VALUE='" & val & "' DISABLED FACE=" & quote & Session("FONTFACE") & quote & ">"
			else
				if val = "" then
					val  = "&nbsp;"
				else
					if len(val) > 50 then
						val = Left(val,50) & "..."
					end if
				end if
				if fieldsize < 15 then
					textstr=disableintstart & "<FONT FACE='" & Session("FONTFACE") & "' SIZE='" & Session("FONTPOINT") & "'>"& val  & "</FONT>" & disabletextend			
				else
					textstr=disabletextstart & "<FONT FACE='" & Session("FONTFACE") & "' SIZE='" & Session("FONTPOINT") & "'>"& val  & "</FONT>" & disabletextend
				end if
			end if
		end if			
	end if
	writeinputbox=textstr
	
end function

function writeSelect(selName, size, onChange, isMultiSel)
	dim textstr
	textstr = "<SELECT NAME='" & selName & "'"
	if size <> "" then	
		textstr = textstr & " Size='" & size & "'"		
	end if
	if onChange <> "" then
		textstr = textstr & " OnChange='" & onChange & "'"	
	end if
	if isMultiSel then
		textstr = textstr & " MULTIPLE"
	end if
	if Session("hasStyles") then 
			textstr=textstr & Session("DEFINPUTSTYLE")
	end if 
	textstr = textstr & ">"
	
	writeSelect = textstr
	
end function

function minVal(thisval, min)
	if thisval < min then
		thisval = min
	end if
	minVal = thisval
end function

Sub alertuser(fieldname)
	'Response.Write "<SCRIPT>alert(" & quote & "Could not retrieve a value for " & fieldname & ". (" & err & ":" & err.description & ")" & quote & ");</SCRIPT>"
	Response.Write "<FONT COLOR=red><B>*</B></FONT>"
End Sub

 %>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iito.inc ===
<HTML>

<!--#include file="default.str"-->
<!--#include file="iito.str"-->
<!--#include file="iisetfnt.inc"-->

<HEAD>
	<TITLE></TITLE>
</HEAD>

<SCRIPT LANGUAGE="JavaScript">
	parentdoc = top.location.href;
	if (parentdoc.indexOf("pop") != -1)
	{
		top.opener.top.location.href = "iis.asp?Session=none";
		top.location.href="iipopcl.asp";
	}
	else
	{
		if (self.location.href != top.location.href)
		{
			top.location.href = "iis.asp?Session=none";
		}
	}
</SCRIPT>
<BODY>
<FONT FACE='<%= L_DEFTEXTFONT_TEXT %>' SIZE='<%= L_DEFFONTPOINT %>'>
<%=  L_TIMEOUTMSG_TEXT %>
<P>
<%= L_TIMEOUTREFRESH_TEXT %>
</FONT>
</BODY>
</HTML>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iilogext.inc ===
<!--#include file="iilogext.str"-->
<%
Const EXTCUSTOMLOGPATH = "IIS://localhost/Logging/Custom Logging"
Const EXTCUSTOMLOGKEYTYPE = "IISCustomLogModule"

Const NOEVENT = ""
Const ALLOWOPERATORS = False
Const ADMINONLY = True
Const LAST = True
Const NOTLAST = False
Const LINES = True
Const NOLINES = False
Const INDENTSIZE = 4
Const MIDDLE = "middle"
Const TOP = "top"
Const BOTTOM = "bottom"

dim PANELBGCOLOR
PANELBGCOLOR= "#FFFFFF"

if not Session("IsIE") then 
	PANELBGCOLOR= "#FFFFFF"
end if


if Session("stype") = "www" then
	ExtSvcPath = EXTW3SVCPATH
else
	ExtSvcPath = EXTMSFTPSVCPATH
end if

dim vAlignText
if Session("IsIE") then
	vAlignText = "ALIGN="  & TOP
else
	vAlignText = "ALIGN="  & MIDDLE
end if

'On Error Resume Next 

function writeTreeItem(fldName,fldMask,onClick,AdminOnly,fldLabel,isLast,drawLines, depth)
	dim outputStr
	outputStr = chr(13) & "<TR>"
	outputStr = outputStr & "<TD VALIGN='middle' HEIGHT=20>" & sFont("","","",True)
	drawLines = drawLines and (depth > 0)
	outputStr = outputStr & treeLines(isLast, depth, drawLines)
	if fldMask <> 0 then
		outputStr = outputStr & checkboxmask(fldName,fldMask,onClick,AdminOnly)
	else
		outputStr = outputStr & "<IMG SRC='images/logicon.gif' HSPACE = 3 >"
	end if
	outputStr = outputStr & fldLabel		
	outputStr = outputStr & "</FONT></TD></TR>"
	
	writeTreeItem = outputStr
end function

function treeLines(isLast, depth, drawLines)
	dim outputStr
	outputStr ="<IMG SRC='images/space.gif' WIDTH=" & (depth * INDENTSIZE) & " HEIGHT=10 BORDER=0 VSPACE=0>"
	'drawLines = false
	if drawLines then
		outputStr = outputStr & "<IMG SRC='" 
		if isLast then
			outputStr = outputStr & "images/treelinesl.gif"
		else
			outputStr = outputStr & "images/treelines.gif"
		end if
	
		outputStr = outputStr & "' HEIGHT = 22 WIDTH=16 VSPACE = 0 HSPACE = 0 " & vAlignText & ">"
	end if
	treeLines = outputStr
	
end function

%>
<FORM NAME="extuserform">

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH = 100% BGCOLOR="<%= PANELBGCOLOR %>">
<% 

mainExtLogging

'this keeps all our vars local to these routines...
Sub mainExtLogging
'	On Error Resume Next
	Dim objExtCustomLogging, objExtCustomModule, objExtSVC, foundit, service

	Set objExtSVC = GetObject(EXTSVCPATH)
	Set objExtCustomLogging = GetObject(EXTCUSTOMLOGPATH)
	
	For Each objExtCustomModule In objExtCustomLogging
		foundit = false
		for each service in objExtCustomModule.LogCustomPropertyServicesString	
				if (UCase(service) = UCase(objExtSVC.Name)) then
					foundit = true
					exit for
				end if
		next
		if foundit then
			writeCustomLogItem objExtCustomModule, objExtSVC, 0, not LAST
		end if
	Next
End Sub

Sub writeCustomLogItem(thisCustomLoggingObj, objExtSVC, depth, isLast)
'	On Error Resume Next
	Dim objCustomProp, ThisProp, PropCount, objExtAttributes

	if thisCustomLoggingObj.KeyType = EXTCUSTOMLOGKEYTYPE  then
		'Response.write thisCustomLoggingObj.Name & "<BR>"
		'Response.write thisCustomLoggingObj.LogCustomPropertyID & "<BR>"
		
		Set objExtAttributes = objExtSVC.getPropertyAttribObj(thisCustomLoggingObj.LogCustomPropertyID)
	
		Response.write writeTreeItem(objExtAttributes.PropName,thisCustomLoggingObj.LogCustomPropertyMask,NOEVENT,ALLOWOPERATORS,thisCustomLoggingObj.LogCustomPropertyName,isLast,LINES, depth)
		ThisProp = 1
		PropCount = 0
		
		'Do a quick count, so we'll know when we get to the last item...
		For Each objCustomProp In thisCustomLoggingObj
			PropCount = PropCount + 1
		Next		

		For Each objCustomProp In thisCustomLoggingObj
			writeCustomLogItem objCustomProp, objExtSVC, (depth + 5), (ThisProp = PropCount)
			ThisProp = ThisProp + 1			
		Next
	end if
end Sub
%>
	

</TABLE>	
</FORM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\jsbrowser\iihding.inc ===
<%
function heading(colwidth,thestring,sortstr)
	dim writeStr, listSort
	listSort = Session("ListSort")
	writeStr = "<TD VALIGN='bottom' WIDTH = " & colwidth & " BORDERCOLOR=" & Session("BGCOLOR") & " BORDERCOLORDARK='#FFFFFF' BORDERCOLORLIGHT='#000000'"
	if listSort and (sortstr <> "") then
	
		if Session("hasDHTML") then
			writeStr = writeStr & " OnCLick=" & quote & "parent.head.sortList('" & sortstr & "');" & quote
			writeStr = writeStr & " style='cursor: hand;'"
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)
			writeStr = writeStr & thestring		
		else
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)				
			writeStr = writeStr &  "<A HREF = " & quote & "javascript:parent.head.sortList('"& sortstr & "');" & quote & ">" & thestring & "</A>"
		end if
	else
		writeStr = writeStr & ">"
		writeStr = writeStr & sFont("","","",True)
		writeStr = writeStr & thestring
	end if
	writeStr = writeStr & "</TD>"
		
	heading = writeStr
end function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiwiz.inc ===
<%

' iiwiz.inc

' generic page names... each wizard must have a NONE and a WELCOME.
Const NONE = 0
Const WELCOME = 1

Const ENABLED = True

Const SCRIPT = "<SCRIPT LANGUAGE='JavaScript'>"
Const CLOSESCRIPT = "</SCRIPT>"
%>

<!--#include file="iisetfnt.inc"-->
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\jsbrowser\iisetfnt.inc ===
<%


if Session("FONTSCALE") = "" then
	Session("FONTSCALE") = 1
end if
if Session("FONTFACE") = "" then
	Session("FONTFACE") = "Helv"
end if
if Session("FONTPOINT") = "" then
	Session("FONTPOINT") = 1	
end if
if Session("BrowserVScalePct") = "" then
	Session("BrowserVScalePct") = 100
end if
if Session("BrowserHScalePct") = "" then
	Session("BrowserHScalePct") = 100
end if

Function sFont(iSize,sFace,sColor,bScale)
	Dim sOutputStr

	sOutputStr = "<FONT"
	if sFace <> "" then
			sOutputStr = sOutputStr & " FACE='" & sFace & "'"
	else
			sOutputStr = sOutputStr & " FACE='" & Session("FONTFACE") & "'"
	end if 

	if iSize = "" then
		iSize = cInt(Session("FONTPOINT"))
	end if
	if bScale then
		iSize = cInt(iSize * Session("FONTSCALE"))
	end if
	sOutputStr = sOutputStr & " SIZE=" & iSize
	if sColor <> "" then
			sOutputStr = sOutputStr & " COLOR=" & sColor
	end if
	
	sOutputStr = sOutputStr & ">"

	sFont = sOutputStr
End Function



Function iVScale(iSize)
	iVScale = iScale(iSize,"BrowserVScalePct")
End Function

Function iHScale(iSize)
	iHScale = iScale(iSize,"BrowserHScalePct")
End Function


Function iScale(iSize,direction)
	if iSize <> 0 then
		iScale = cInt((Session(direction) * iSize)/100)
	else
		iScale = iSize	
	end if
End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iijsfuncs.inc ===
<% ' General depository for frequently used javascript functions ******* %>


<% ' ******* Any localizable strings needed for these functions will appear in iijsfuncs.str ******* %>
<!--#include file="iijsfuncs.str"-->

<% ' ******* Pops open a new dialog of specified height, with or without an ok/cancel/help toolbar ******* %>
<% ' ******* hideTools is optional ******* %>

	function popBox(title, width, height, filename, hideTools){
		thefile=(filename + ".asp");
		thefile="iipop.asp?pg="+thefile;
		if (hideTools)
		{
			thefile += "&tools=no";
		}			
		

		//Store the window object in our Global variables, so it may be refered to from the parent window...
		top.title.Global.popwindow=window.open(thefile,title,"toolbar=no,scrollbars=yes,directories=no,menubar=no,width="+width+",height="+height);

		//pop it into a local var for reference here...
		popbox = top.title.Global.popwindow;

		//corrects for bug in ie where the window opener property wasn't being set.
		if(popbox !=null){
			if (popbox.opener==null){
				popbox.opener=self;
			}
		}

		//corrects for a bug where if the window is opened, and then re-opened, it stays in the back.
		//however, this errors in IE3, so we are special casing it. IE3 will have the less desirable
		//behavior of remaining in the background.

		<% if Session("isIE") and Session("browserver") < 4 then %>
			<% ' no focus... browser doesn't suppor it %>
		<% else %>		
			popbox.focus();
		<% end if %>
		
	}

<% ' ******* Basic Crop function based on string length ******* %>

	function crop(thestring,size){
		sLen = thestring.length
		if (sLen > size)
			{
			thestring = thestring.substring(0,size) + "...";
			}
		else{
			for (var i = sLen ; i < size; i++) {
				thestring = thestring + "&nbsp;"
			}			
		}
		return thestring;
	}

<% ' ******* Quick function to provide alternate text if there is no value to the main display string. ******* %>
	function displayVal(dispstr, altstr){
		if (dispstr == ""){
			dispstr = altstr;
		}
		return dispstr;
	}

	
<% ' ******* Basic Numeric checker that displays a dialog. Strings are located in iijsfunc.str ******* %>
	
	function isNum(txtcntrl,min,max) {
		str=txtcntrl.value;
		
		minval = min-1;
		maxval = max+1;
	
		for (var i=0; i < str.length; i++) {
  			num = parseInt(str.substring(i,i+1));
			if (isNaN(num)){				
			   alert("<%= L_ENTERINT %>");
				txtcntrl.value = txtcntrl.defaultValue;
				return false;
  			}			
	 	}
		num = str;
		
		if (min != ""){	
			if (num < min) {
				alert('<%= L_GREATERTHAN %>');
				txtcntrl.value = txtcntrl.defaultValue;
				return false;
			}
		}
		
		if (max != ""){
			if (num > max) {
				alert('<%= L_LESSTHAN %>');
				txtcntrl.value = txtcntrl.defaultValue;
				return false;
			}		
		}
		return true;
	}
	
<% ' ******* Disables controls if the browser is DHTML compatible ******* %>
	function setCntrlState(mState,mControl){
		<% if Session("hasDHTML") then %>
			mControl.disabled = ! mState;
		<% end if %>
	}
	

<% ' ******* Search for a string in a string  ******* %>
<% ' ******* I just don't like jscripts substring method... **** %>
	function bAnyInStr(sToSearch, sToFind)
	{
		for (i=0;i < sToFind.length;i++)
		{
			if (sToSearch.indexOf(sToFind.substring(i,i+1)) > -1)
			{
				return true;
			}
		}
		return false;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iijsls.inc ===
<% ' General depository for frequently used javascript functions for our "list control" ******* %>

<!--#include file="iijsls.str"-->

<%
' Main listFunction object, to allow other frames to access global functions, 
' and to serve as a data cache. This will be instantiated in the list script.
%>
function listFuncs(sortby, specSort, mainframe){
	//general
	this.sel = -1;
	this.lastSel = 0;	
	this.bHasList = true;
	this.noupdate = false;
	this.sortAsc = true;
	
	//functions
	this.addItem=addItem;
	this.delItem=delItem;
	this.moveItem=moveItem;
	this.sortList = sortList;
	this.reSort = reSort;				
	this.writeList=buildListForm;
	this.SetListVals=SetListVals;
	this.writeCol = writeCol;
	this.loadList = loadList;
	
	//specifics
	this.sortby = sortby;
	this.specSort =specSort;		
	this.mainframe = mainframe;
}

<% ' ******* Sets the current selection ******* %>
	
	function setLastSel(id)
	{
		for (var i=0; i < cachedList.length; i++)
		{
			if (cachedList[i].id == id)
			{
				listFunc.sel = i;
				return;
			}
		}
	}

<% ' ******* Used throughout the list "controls" to write out a table cell. ******* %>
<% ' ******* a, the align parameter, is optional ******* %>
		
	function writeCol(colspan,w,str,a)
	{
		var writestr = "<TD";
		if (colspan != "")
		{
			writestr += " COLSPAN = " + colspan
		}
		if (w != "")
		{
			writestr += " WIDTH = " + w;
		}
		if (a != "")
		{
			writestr += " ALIGN = " + a;
		}							
		writestr += "><%= sFont("","","",True) %>" + str + "</FONT></TD>";

		return writestr;	
	}	
	
<% '***** This is the sortOrder function that allows heading to be sorted by string values, rather than numerically... **** %>
	function sortOrder(a,b)
		{
		<%
			' a and b are automatically passed in by the JScript array sort function
			' In this case, they are array items which contain custom objects. The
			' listFunc.sortby is set in the call to sortList, which is executed when
			' the user clicks a heading. The entry points are in the files labled ii*hd.asp 
			' (ie, iiacsshd.asp, etc.) The sortby property will contain the name of the 
			' property on the object to sort by, for example filename or date...
			
			'listFunc is required in order for this to work properly...
		%>		
		
		if (listFunc != null)
		{
			if (listFunc.specSort != "")
			{
				astr = a[listFunc.specSort] + a[listFunc.sortby];
				bstr = b[listFunc.specSort] + b[listFunc.sortby];
			}
			else
			{
				astr = a[listFunc.sortby];
				bstr = b[listFunc.sortby];
			}
			
			if (!isNaN(astr))
			{
				astr = astr.toString();
				bstr = bstr.toString();
				
			}
			
			lcastr = astr.toLowerCase();
			lcbstr = bstr.toLowerCase();
			
			if (lcastr < lcbstr)
			{
				retval = -1;
			}
			else
			{
				if (lcastr > lcbstr)
				{
					retval =  1;
				}
				else
				{
					retval =  0;
				}
			}
			if (!listFunc.sortAsc)
			{
				retval = retval * -1;
			}
			return retval;						
		}
	}
			
<% '***** Sort routine called by headings  ***** %>
<% '***** This requires the sortOrder function ***** %>
	function sortList(sortby)
	{		
		if (listFunc != null)
		{		
			i= listFunc.sel;
			if (i != -1)
			{
				lastsel = cachedList[i].id
			}

			if (sortby != listFunc.sortby)
				{
				listFunc.sortby = sortby;
				listFunc.sortAsc = true;
				}
			else
				{
				listFunc.sortAsc = !listFunc.sortAsc;
				}
	
			var num = parseFloat(cachedList[sortby]);
			if (isNaN(num))
				{
				cachedList.sort(sortOrder);
				}
			else
				{ 
				cachedList.sort(numOrder);
				}
				
			if (i != -1)
			{			
				setLastSel(lastsel);				
			}
			loadList();
		}
	}


<% '**** List Resorting function *** %>
	function reSort()
	{
		//set our sortAsc so we aren't just reversing the list...
		listFunc.sortAsc = !listFunc.sortAsc;
		sortList(listFunc.sortby);
	}

<% '**** List Delete function *** %>	
		function delItem(){
		
		if (listFunc.sel >= 0)
		{
			listFunc.noupdate = true;		
			i=eval(listFunc.sel);
			
			cachedList[i].deleted=true;
			cachedList[i].updated=true;
			 i=i-1;
			
			<% 'run through the list to find the Next non-deleted item %>
			for (var j=i; j >=0; j--) {
				if (cachedList[j].deleted){
				}
				else{
					break			
				}
			}	
			listFunc.sel=j;
			loadList();			
		}
		else{
			alert("<%= L_SELECTITEM_TEXT %>");
		}
	}
	
<% '**** List Delete function *** %>		

	function initParam(paramVal,defaultVal)
	{
		if (paramVal == null)
		{
			return defaultVal;
		}
		return paramVal;
	}
	
	function addItem()
	{
		var i=cachedList.length;
		listFunc.noupdate = true;		
		cachedList[i]=new listObj(i);
		cachedList[i].newitem=true;
		cachedList[i].updated=true;
		listFunc.sel=i;
		loadList();
	}
	
	function moveItem(dir){
		sel = eval(listFunc.sel);
		if (sel > -1){
			if (!cachedList[sel].deleted){
				if ((sel + dir >= 0) && (sel + dir < (cachedList.length))){				
					cachedList[sel].id += dir;
					cachedList[sel].updated = true;
					sel += dir;
					cachedList[sel].id -= dir;
				
					listFunc.sel = sel;
					cachedList.sort(sortOrder);
					loadList();
				}
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiwizsec.inc ===
<%

' iiwiznew.inc

'Page 1 - Welcome

'Page 5 - FINISH
Const FINISH = 5

'Page 2
Const HOW = 2

'Page 3
Const TEMPLATE = 3
' end

'Page 4
'Const ACL = 4
'Const L_ACL = "Windows NT Directory and File Permissions"
'Const L_ACL_DESC = "Windows NT directory and file permissions should match your site's web security settings."
'Const L_NOTONFAT = "If the site you are configuring maps to a FAT partition, directory and file permissions do not apply."
'Const L_RECOMMENDED = "The recommended Windows NT directory and file permissions for your site are:"
'Const L_NOCHANGEACLS = "You want your directory and file permissions unaltered."
'Const L_ADDACLS = "You want to leave your current directory and file permissionsintact, and add any additional permissions that are necessary for web access."
'Const L_REPLACEACLS = "You want to replace all directory and file permissions."

'Remove
'Const RECOMMENDEDACLS1 = "Everyone can Read files"
'Const RECOMMENDEDACLS2 = "Administrators can Read and Write files"


'Page 4
Const SUMMARY = 4
Const INDENT = "&nbsp;&nbsp;"

Dim L_RETURN
L_RETURN = chr(13)

Dim LAST
LAST = 4

Const INHERITVALS = 0
Const TEMPLATEVALS = 1

Const REPALCEACLS = 0
Const ADDACLS = 1
Const NOACLS = 2

CANRESTART = FALSE

Const ADS_PROPERTY_CLEAR = 1

' Node types
Const SITE = 0
Const VDIR = 1
Const DIR = 2


Const SWEB = "Web"
Const SFTP = "FTP"
Const IIS = "IIs"

Const SDIR = "Directory"
Const SVDIR = "VirtualDir"
Const SSITE = "Server"
Const SCOMP = "Computer"

Dim SERVICES
SERVICES = Array(SWEB, SFTP)

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiwiznew.inc ===
<%

' iiwiznew.inc

'Page 1 - Welcome

'Page 7 - FINISH
Const FINISH = 7

'Page 2
Const SITETYPE = 2

'Page 3
Const NODENAME = 3

'Page 4
Const BINDINGS = 4
Const WEBTCPDEFAULT = 80
Const FTPTCPDEFAULT = 21
Const SSLDEFAULT = 443

'Page 5
Const PATHNAME = 5

'Page 6
Const ACCESSPERMS = 6

Dim LAST
LAST = 6

Const SITE = 0
Const VDIR = 1
Const DIR = 2
Const WEB = 0
Const FTP = 1

Const SWEB = "Web"
Const SFTP = "FTP"
Const IIS = "IIs"

Const SDIR = "Directory"
Const SVDIR = "VirtualDir"
Const SSITE = "Server"
Const SCOMP = "Computer"
Const SVC = "Service"

Const W3SVC = "W3SVC"
Const FTPSVC = "MSFTPSVC"
Const COMP = "COMP"

Const IISCOMPUTER = "IIsComputer"
Const BASEPATH = "IIS://localhost/"
Const ROOT = "/ROOT"

'This determines whether we set access perms or call the perm wizard...
Const COMPLETE = True

Const CANRESTART = False

Dim NODETYPES
NODETYPES = Array("server","vdir","dir")

Dim SITETYPES
SITETYPES = Array(SWEB, SFTP)

' The site type identifiers used by the cache are different from
' those used here. ICK!
Dim CACHE_SITETYPES
CACHE_SITETYPES = Array( "www", "ftp" )

Dim SERVICES
SERVICES = Array(W3SVC,FTPSVC)
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\publish\jsbrowser\iihding.inc ===
<%
function heading(colwidth,thestring,sortstr)
	dim writeStr, listSort
	listSort = Session("ListSort")
	writeStr = "<TD VALIGN='bottom' WIDTH = " & colwidth & " BORDERCOLOR=" & Session("BGCOLOR") & " BORDERCOLORDARK='#FFFFFF' BORDERCOLORLIGHT='#000000'"
	if listSort and (sortstr <> "") then
	
		if Session("hasDHTML") then
			writeStr = writeStr & " OnCLick=" & quote & "parent.head.sortList('" & sortstr & "');" & quote
			writeStr = writeStr & " style='cursor: hand;'"
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)
			writeStr = writeStr & thestring		
		else
			writeStr = writeStr & ">"
			writeStr = writeStr & sFont("","","",True)				
			writeStr = writeStr &  "<A HREF = " & quote & "javascript:parent.head.sortList('"& sortstr & "');" & quote & ">" & thestring & "</A>"
		end if
	else
		writeStr = writeStr & ">"
		writeStr = writeStr & sFont("","","",True)
		writeStr = writeStr & thestring
	end if
	writeStr = writeStr & "</TD>"
		
	heading = writeStr
end function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiwizbtns.inc ===
<tr>
	<td colspan = 2 align="right">

		<script language="JavaScript">
			var iNextPage = <%= iNextPage %>
			var iPrevPage = <%= iPrevPage %>
		
			function setNav(iNewNextPage)
			{
				iNextPage = iNewNextPage
			}
		</script>

		<%= sFont("","","",True) %>
		
		
		<% if iThisPage > LAST then %>		
			<% if CANRESTART then %>
						<input type="BUTTON" value="&lt; <%= L_RESTART_TEXT %>" onclick="document.userform.iThisPage.value = 0;document.userform.submit();">			
			<% else %>
						<input type="BUTTON" value="&lt; <%= L_BACK_TEXT %>" DISABLED>			
			<% end if %>
			
		<% else %>
			<% if iThisPage > WELCOME then %>
						<input type="BUTTON" value="&lt; <%= L_BACK_TEXT %>" onclick="prevPage();">
			<% else %>
						<input type="BUTTON" value="&lt; <%= L_BACK_TEXT %>" DISABLED>
			<% end if %>
		<% end if %>


		<% if iThisPage = LAST then %>
					<input type="BUTTON" value=" <%= L_FINISH_TEXT %>" onclick="nextPage();">
		<% else %>
			<% if iNextPage <= LAST then %>
						<input type="BUTTON" value="<%= L_NEXT_TEXT %> &gt;" onclick="nextPage();">
			<% else %>
						<input type="BUTTON" value="<%= L_NEXT_TEXT %> &gt;" DISABLED>
			<% end if %>
		<% end if %>

		<% if iThisPage > LAST then %>
			<input type="BUTTON" value="<%= L_CLOSE_TEXT %>" onclick="top.window.close();">		
		<% else %>
			<input type="BUTTON" value="<%= L_CANCEL_TEXT %>" onclick="top.window.close();">
		<% end if %>	
		<input type="hidden" name="iThisPage" value="<%= Request("iThisPage") %>">	
		<IMG SRC="images/Space.gif" WIDTH=4 HEIGHT=1 BORDER=0>
		
		</FONT>
		
		<SCRIPT LANGUAGE="JavaScript">

			function nextPage()
			{			
				if (bNextPageOk())
				{
					document.userform.iThisPage.value = iNextPage;
					document.userform.submit();
				}
			}
			
			function prevPage()
			{			
				document.userform.iThisPage.value = iPrevPage;
				document.userform.submit();
			}
			
		</SCRIPT>
	</td>
</tr>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\publish\localize.inc ===
<!-- VSS generated file data
$Modtime: 10/24/97 12:47p $
$Revision: 14 $
$Workfile: localize.inc $
-->
<%
'--------------------------------------------------------------------
'                     Localization variables
'
' For the Publishing Wizard, welcome.asp, finish.inc, myfiles.asp
' and files in JSBrowser need to be localized.
'--------------------------------------------------------------------

'------------Text from welcome.asp-----------

	Dim bckSlash, colon, semiColon, period, locPubWiz, locFile, _
	locDescription, locPath, locPubFiles, locWelcomeInstr1, locWelcomeInstr2,_
	locChooseAddrad, locChooseRemoverad, locChooseRefreshrad, locChooseUpdaterad, _
	locChooseWhatDo, locInvalidPath, locPathRequired, locAddInstr1, _
	locAddInstr2, locAddInstr3, locAddBrowsebtn, locAddAddbtn, locAddRemovebtn, _
	locRemoveInstr1, locRefreshInstr1, locChangeInstr1, locChangeUpdatebtn, _
	locWarning
	
	bckSlash = chr(92)
	colon = chr(58)
	semiColon = chr(59)
	period = chr(46)
	locPubWiz ="Publishing Wizard"
	locPath = "Path:"
	locFile = "File:"
	locDescription = "Description:"
	locPubFiles = "Published Files:"
	locWelcomeInstr1 = "The publishing wizard helps you publish files quickly" + _
		 				" and easily."
	locWelcomeInstr2 = " To begin publishing, click on the wizard."
	locWarning = "The Home Page Wizard must be run once before using the Publishing Wizard. " + _
				"If you have already run the Home Page Wizard, click F5 to refresh this page."
	locChooseWhatDo = "What do you want to do?"
	locChooseAddrad = "Add a file to the published list"
	locChooseRemoverad = "Remove from the list of published files"
	locChooseRefreshrad = "Refresh published files from their originals"
	locChooseUpdaterad = "Change a file description"
	locInvalidPath = "Invalid File Path."
	locPathRequired = "A file path is required."
	locAddInstr1 = "To publish a file, type the full path and description below."
	locAddInstr2 = "Click the Add button to display the files in the list below.<br>" + _
					"Select a file and click Remove to remove a file from the list."
	locAddInstr3 = "Files to publish:"
	locAddBrowsebtn = "Browse"
	locAddAddbtn = "Add"
	locAddRemovebtn = "Remove"
	locRemoveInstr1 = "To remove a file from the published list, select the file and click Next."
	locRefreshInstr1 = "To refresh a file from the published list, select the file and click Next."
	locChangeInstr1 = "To edit a file description, select the file from the list, edit the description text, and click Update." + _
						" When you have finished updating descriptions, click Next."
	locChangeUpdatebtn = "Update"
	
	'----------Text from finish.inc--------------
	
	Dim locProb, locSolu, locRemProb1, locRemSolu1, locRemProb2, locRemSolu2, _
	locRemProb3, locRemResult, locInsProb1a, locInsProb1b, locInsSolu1, _
	locInsProb2a, locInsProb2b, locInsSolu2, locInsProb3, locInsSolu3, locInsProb4, locInsSolu4, _
	locInsProb5a, locInsProb5b, locInsSolu5, locInsResult, locRefProb1, _
	locRefSolu1, locRefProb2, locRefSolu2, locRefProb3, locRefSolu3, _
	locRefProb4, locRefSolu4, locRefProb5, locRefSolu5, locRefResult, _
	locUpdProb1, locUpdSolu1, locUpdResult, locUnexpectProb, locUnexpectSolu, _
	locFail, locPass, locDrvUnk, locDrvRem, locDrvNet, locDrvCD, locDrvRAM, _
	locRemSolu3
	
	
	
	locProb = "Problem:<BR>"
	locSolu = "<P>Solution:<BR>"
	locFail = "Fail"
	locPass = "Pass"
	locDrvUnk = "Unknown"
	locDrvRem = "Removable"
	locDrvNet = "Network"
	locDrvCD = "CD-ROM"
	locDrvRAM = "RAM Disk"
	
	locRemProb1 = "There are no files in WebPub to delete."
	locRemSolu1 = "No additional action is necessary."
	locRemProb2 = " was not available to delete."
	locRemSolu2 = "No additional action was necessary."
	locRemProb3 = " is not in \Webpub."
	locRemSolu3 = "No additional action is necessary."
	locRemResult = "The following files were deleted:<BR>"
	
	locInsProb1a = " could not be copied because "
	locInsProb1b = " could not be found."
	locInsSolu1 = "Check the path or Drive letter."
	locInsProb2a = " could not be copied because "
	locInsProb2b = " is a network share."
	locInsSolu2 = "Copy the file to a local fixed drive."
	locInsProb3 = " could not be copied because a file by that name already exists in \Webpub."
	locInsSolu3 = "Delete, move or rename the file in \WebPub."
	locInsProb4 = " could not be found."
	locInsSolu4 = "Check the file path."
	locInsProb5a = " could not be copied because "
	locInsProb5b = " drives cannot be utilized."
	locInsSolu5 = "Copy the file to a local fixed drive."
	locInsResult = "The following files were added:<br>"
	
	locRefProb1 = "There are no files in WebPub to refresh."
	locRefSolu1 = "Add files to \Webpub."
	locRefProb2 = " was not refreshed because the only know copy exists in \Webpub."
	locRefSolu2 = "Move the file to a new directory, then add it using the Publishing Wizard."
	locRefProb3 = " could not be refreshed because it was not in \Webpub."
	locRefSolu3 = "Add the file to \Webpub using the Publishing Wizard."
	locRefProb4 = " could not be refreshed because the source file was not at "
	locRefSolu4 = " must be deleted using the Wizard, then add the source file again from "
	locRefProb5 = "There is no record of "
	locRefSolu5 = "Add the source file using the Publishing Wizard."
	locRefResult = "The following files were refreshed:<br>"
	
	locUpdProb1 = " was not updated because it could not be found in \Webpub."
	locUpdSolu1 = " should be added using the Publishing Wizard."
	locUpdResult = "The following files were updated:<br>"
	
	locUnexpectProb = "An unexpected error occured."
	locUnexpectSolu = "Please restart the Publishing Wizard."
	

	Const locFileIsPublished	= "A file by that name already exists in \Webpub."
	Const locFileDoesNotExist = "The file could not be found."		
	%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\iiwizfncs.inc ===
<%
Const BOLD = True
Const STYLE = "color:black;font-size:9pt;font-family:"

Dim quote
quote = chr(34)

'***************generic wizard global vars***************
Dim sSystemFontSize, iThisPage, iNextPage, iPrevPage
sSystemFontSize = "SMALL"
iThisPage = CInt(Request("iThisPage"))
if iThisPage = 0 then
	iThisPage = 1
end if
iNextPage = iThisPage + 1
iPrevPage = iThisPage - 1

'***************generic wizard functions***************
Function sStaticText(sDesc,BOLD)
	Dim sOutputStr
	sOutputStr = "<TR><TD VALIGN='top' COLSPAN = 2>"
	sOutputStr = sOutputStr  & sFont("","","",True)
	if BOLD then
		sOutputStr = sOutputStr & "<B>"
	end if
	sOutputStr = sOutputStr & sDesc
	sOutputStr = sOutputStr & "<P>"
	sOutputStr = sOutputStr & "</FONT>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sStaticText = sOutputStr
End Function

Function sTextBox(sName, sDesc, iSize, onBlur)
	Dim sOutputStr
	sOutputStr = sTextBoxwChange(sName, sDesc, iSize, onBlur,"")
	sTextBox = sOutputStr
End Function

Function sTextBoxwChange(sName, sDesc, iSize, onBlur,onChange)
	Dim sOutputStr
	sOutputStr = sTextBoxwDefault(sName, sDesc, iSize, onBlur, onChange, "")
	sTextBoxwChange = sOutputStr
End Function

Function sTextBoxwDefault(sName, sDesc, iSize, onBlur, onChange, sDefault)
	Dim sOutputStr
	Dim sValue

	' Don't let default overwrite persisted info
	sValue = Request(sName)
	if sValue = "" then
		sValue = sDefault
	end if

	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr  & sFont("","","",True)
	sOutputStr = sOutputStr & sDesc & "<BR>"
	sOutputStr = sOutputStr & "<INPUT NAME=" & quote & sName & quote & " VALUE=" & quote & sValue & quote
	sOutputStr = sOutputStr & " SIZE = " & (Session("BrowserTBScalePct") * iSize/100)
	if onBlur <> "" then
		sOutputStr = sOutputStr & " onBlur=" & quote & onBlur & quote	
	end if
	if onChange <> "" then
		sOutputStr = sOutputStr & " onChange=" & quote & onChange & quote	
	end if	
	if Session("hasStyles") then 
		sOutputStr = sOutputStr & Session("DEFINPUTSTYLE")
	end if
	sOutputStr = sOutputStr & "><P>"
	sOutputStr = sOutputStr & "</FONT>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sTextBoxwDefault = sOutputStr
End Function

Function sHidden(sName, sValue)
	Dim sOutputStr
	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr & "<INPUT TYPE='hidden' NAME=" & quote & sName & quote & " VALUE=" & quote  & sValue & quote & "><P>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sHidden = sOutputStr
End Function

Function sCheckBox(sName, sDesc)
	Dim sOutputStr
	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr & sFont("","","",True)
	sOutputStr = sOutputStr & "<INPUT TYPE='checkbox' NAME=" & quote & sName & quote
	if Request(sName) <> "" then
		sOutputStr = sOutputStr & " CHECKED "
	end if
	sOutputStr = sOutputStr & ">&nbsp;" & sDesc & "<BR>"
	sOutputStr = sOutputStr & "</FONT>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sCheckBox = sOutputStr
End Function

Function sRadio(sName, sVal, sDesc, sDefault, onClick)
	Dim sOutputStr, lastval
	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr & sFont("","","",True)
	sOutputStr = sOutputStr & "<INPUT TYPE='radio' NAME=" & quote & sName & quote
	sOutputStr = sOutputStr & " VALUE=" & quote & sVal & quote
	
	lastval = Request(sName)
	if isNumeric(lastval) then
		lastval = cInt(lastval)
	else
		lastval = sDefault
	end if
	
	if lastval = sVal then
		sOutputStr = sOutputStr & " CHECKED"
	end if
	if onClick <> "" then
		sOutputStr = sOutputStr & " OnClick=" & quote & onClick & quote
	end if
	sOutputStr = sOutputStr & "></TD><TD VALIGN='middle'>"
	sOutputStr = sOutputStr & sFont("","","",True)
	sOutputStr = sOutputStr & sDesc & "<BR>"
	sOutputStr = sOutputStr & "</FONT>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sRadio = sOutputStr
End Function


Function sSelect(sName, iSize, onChange, bMultiple)
	Dim sOutputStr
	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr  & sFont("","","",True)
	sOutputStr = sOutputStr & "<SELECT NAME=" & quote & sName & quote & " SIZE = " & iSize
	if onChange <> "" then
		sOutputStr = sOutputStr & " onChange=" & quote & onChange & quote	
	end if
	if bMultiple then
		sOutputStr = sOutputStr & " MULTIPLE"	
	end if
	if Session("hasStyles") then 
		sOutputStr = sOutputStr & " style=" & quote & STYLE & Session("FONTFACE") & quote	
	end if
	sOutputStr = sOutputStr & ">"
	sSelect = sOutputStr
End Function

Function closeSelect()
	Dim sOutputStr
	sOutputStr = "</SELECT></TD></TR>"	
	closeSelect = sOutputStr	
End Function

Function sOption(sCaption,sValue, bIsSelected)
	Dim sOutputStr
	sOutputStr = sOutputStr & "<OPTION"
	if sValue <> "" then
		sOutputStr = sOutputStr & " VALUE=" & quote & sValue & quote
	end if
	if bIsSelected then
		sOutputStr = sOutputStr & " SELECTED"		
	end if
	sOutputStr = sOutputStr & ">" & sCaption
	sOutputStr = sOutputStr & "</OPTION>"
	sOption = sOutputStr
End Function

Function sTextArea(sName, sDesc, sText, iRows, iCols, bEnabled)
	Dim sOutputStr
	sOutputStr = "<TR><TD VALIGN='top'>"
	sOutputStr = sOutputStr  & sFont("","","",True)
	sOutputStr = sOutputStr & sDesc & "<BR>"
	sOutputStr = sOutputStr & "<TEXTAREA NAME=" & quote & sName & quote & " ROWS = " & iRows & " COLS = " & iCols
	sOutputStr = sOutputStr & " WRAP=VIRTUAL"	
	if Session("hasStyles") then 
		sOutputStr = sOutputStr & " style=" & quote & STYLE & Session("FONTFACE") & quote
	end if
	sOutputStr = sOutputStr & ">"
	sOutputStr = sOutputStr & sText	
	sOutputStr = sOutputStr & "</TEXTAREA>"
	sOutputStr = sOutputStr & "</FONT>"
	sOutputStr = sOutputStr & "</TD></TR>"

	sTextArea = sOutputStr
End Function

Function sSpace(iNumRows)
	Dim sOutputStr
	sOutputStr = ""
	For i = 0 to iNumRows
		sOutputStr = "<TR><TD VALIGN='top'>"
		sOutputStr = sOutputStr  & sFont("","","",True)
		sOutputStr = sOutputStr & "&nbsp;"
		sOutputStr = sOutputStr & "</FONT>"
		sOutputStr = sOutputStr & "</TD></TR>"
	Next
	sSpace = sOutputStr
End Function


%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\publish\finish.inc ===
<!-- VSS generated file data
$Modtime: 10/22/97 4:35p $
$Revision: 29 $
$Workfile: finish.inc $
-->
<%
'--------------------------------------------------------------------
' Functions and Subs to complete Publisher Wizard actions on publish.mdb
' and \\Inetpub\webpub
'--------------------------------------------------------------------
Function AddAttrib(BigStr, SmallStr, Attrib)
	Dim leftStr, rightStr
	BigStr = Trim(BigStr)
	SmallStr = Trim(SmallStr)
	Attrib = Trim(Attrib)
	leftStr = Left(BigStr, instr(instr(BigStr, SmallStr), BigStr, semiColon) -1)
	rightStr = Right(BigStr, len(BigStr) - instr(instr(BigStr, SmallStr), BigStr, semiColon))
	AddAttrib = leftStr + " " + Attrib + semiColon + rightStr
End Function

Function GetG()
	Dim root, g
	root = server.mappath(bckSlash)
	root = Trim(Left(root, instrRev(root, bckSlash)))
	root = root + "webpub"
	g = FileSystem.GetAbsolutePathName(root)
	g = g + bckSlash
	GetG = g
End Function

Sub remFiles(sFilesToDelete)
	Dim strRec, strDelSQL, g, rs, i, objparam, word, comma
	
	if 0 then
		resetVar
	end if
	
	'lara's vars
	Dim aFilesToDelete, item, aFileItem, success, thisErr
	Dim FileName, FileDesc, FilePath, PublishedFilePath, oPublishedFile
	success = False
	aFilesToDelete = split(sFilesToDelete,";")
	For Each FileName in aFilesToDelete
		if FileName <> "" then		
			g = GetG()
			PublishedFilePath = g + FileName			
			thisErr = PathOK(PublishedFilePath,False)
			if thisErr = "" then
				cm.CommandText = "DELETE FROM FileList WHERE FileList.FileName = ? "
				set objparam=cm.createparameter(, 200, , 255)
				cm.parameters.append objparam
					Set oPublishedFile = FileSystem.GetFile(PublishedFilePath)
					If oPublishedFile.attributes and 1 Then
						oPublishedFile.attributes = oPublishedFile.attributes - 1
					End If
					
					FileSystem.DeleteFile PublishedFilePath
				
					'Run delete sequence
						cm.parameters(0) = FileName
						set rs = cm.Execute
						success = True
					showNames = FileName + " " + showNames
			end if
		end if	
	Next
	If success Then
		ShowNames = locRemResult + ShowNames
	End If
	resetVar
End Sub

Sub insertFiles
	Dim FileName, FilePath, FileDesc, g, objparam
	Dim rs, strFull, filespec, isFile
	dim aFullStr, item, thisErr, aFileItem, success
			
	strFull = Myinfo.strFull
	success = False
	if strFull <> "" then
		cm.CommandText = "INSERT INTO FileList (FileName, FileDescription, FilePath)VALUES(?, ?, ?)"
		set objparam=cm.createparameter(, 200, , 255)
		cm.parameters.append objparam
		set objparam=cm.createparameter(, 200, , 255)
		cm.parameters.append objparam
		set objparam=cm.createparameter(, 200, , 255)
		cm.parameters.append objparam
		
		aFullStr = split(strFull,";")
		for each item in aFullStr
			if instr(item,"INSERT") then
				aFileItem = split(item,"|")
				FileName = aFileItem(0)						
				FileDesc = aFileItem(1)
				FilePath = aFileItem(2)
				thisErr = PathOK(FilePath,True)
				if thisErr = "" then
					g = GetG()
					FileSystem.CopyFile FilePath, g
					filespec = g & FileName
					Set f = FileSystem.GetFile(filespec)
						If f.attributes and 2 Then
							f.attributes = f.attributes - 2
						End If
						If f.attributes and 4 Then
							f.attributes = f.attributes - 4
						End If
						If not f.attributes and 1 Then
							f.attributes = f.attributes + 1
						End If
					'Run Insert statement
						cm.parameters(0) = FileName
						cm.parameters(1) = FileDesc
						cm.parameters(2) = FilePath
						set rs = cm.Execute
						success = True
						showNames = showNames & " " & FileName
				else
					negComment1 = negComment1 & thisErr
				end if
			end if		
		next
	end if
	
	If success then
		showNames = locInsResult & showNames
	End If
	resetVar

End Sub

Function GetDriveType(FilePath)
	Dim driveName,oDrive, drvType
	drvType = ""
	if FileSystem.DriveExists(FilePath) then
		driveName = FileSystem.GetDriveName(FilePath)
		Set oDrive = FileSystem.GetDrive(driveName)
	 	Select Case oDrive.DriveType
			Case 0 'Unknown
				drvType = locDrvUnk		
	   		Case 1 'Removable
				drvType = locDrvRem
			Case 3 'Network
				drvType = locDrvNet
			Case 4 'CD-ROM
				drvType = locDrvCD
			Case 5 'RAM Disk
				drvType = locDrvRAM
			Case 2 'Fixed
    	End Select		
	else
		drvType = locDrvUnk
	end if		
	GetDriveType = drvType					
End Function

Function pathOK(FilePath,ChkWebPub)
	Dim drvType,isFile,g, FileName,ChkPath, errstr
	errstr = ""
	drvType = GetDriveType(FilePath)
	if drvType <> "" then
		isFile = FileSystem.FileExists(FilePath) 'does new file really exist
		If isFile Then
			if ChkWebPub then
				g = GetG()
				FileName = FileSystem.GetFileName(FilePath)
				ChkPath = g + FileName 
				isFile = FileSystem.FileExists(ChkPath)
				If isFile Then 'new file is not already in webpub
					errStr = locProb + FileName + locFileIsPublished			
				end if
			end if
		else
			errStr = locProb + FileName + locFileDoesNotExist
		end if	
	else
		errStr = locProb + FileName + locInsProb5a + drvType + locInsProb5b + locSolu + locInsSolu5
	end if
	pathOK = errStr
End Function


Sub refreshFiles(sFilesToRefresh)
	
	Dim strFull, astrFull, item
	Dim aFileItem, FileName, FilePath
	Dim success, thisErr, g, PublishedFilePath, PublishedFile
	success = False
	
	strFull = Myinfo.strFull
	astrFull = split(Myinfo.strFull,";")

	for each item in astrFull		

		if item <> "" then
			aFileItem = split(item,"|")	
			FileName = aFileItem(0)
			FilePath = aFileItem(2)

			if InStr(sFilesToRefresh,FileName) <> 0 then
				thisErr = PathOK(FilePath,False)
				if thisErr = "" then
					g = GetG()
					PublishedFilePath = g + FileName		
					if FileSystem.FileExists(PublishedFilePath) then
						Set PublishedFile = FileSystem.GetFile(PublishedFilePath)
						If PublishedFile.attributes and 1 Then
							PublishedFile.attributes = PublishedFile.attributes - 1
						End If
					end if
						FileSystem.CopyFile FilePath, g
						If PublishedFile.attributes and 2 Then
							PublishedFile.attributes = PublishedFile.attributes - 2
						End If
						If PublishedFile.attributes and 4 Then
							PublishedFile.attributes = PublishedFile.attributes - 4
						End If
						If not PublishedFile.attributes and 1 Then
							'set file to read only						
							PublishedFile.attributes = PublishedFile.attributes + 1 
						End If
						success = True
						showNames = FileName + " " + showNames
				end if
			end if
		end if
	next
	If success then
		ShowNames = locRefResult + ShowNames
	End If
	resetVar
End Sub


Sub updFiles
	Dim objparam
	Dim strFull, astrFull, item, aFileInfo, FileName, FileDesc, FilePath
	Dim thiserr, success
	success = False
	
	strFull = Myinfo.strFull
	astrFull = split(strFull,";") 

	cm.CommandText = "UPDATE FileList SET FileDescription = ? WHERE FileName = ?"
	set objparam=cm.createparameter(, 200, , 255)
	cm.parameters.append objparam
	set objparam=cm.createparameter(, 200, , 255)
	cm.parameters.append objparam	
	
	For each item in astrFull 
		if inStr(item,"UPDATE") then
			aFileInfo = split(item,"|")
			FileName = aFileInfo(0)
			FileDesc = aFileInfo(1)
			FilePath = aFileInfo(2)
			thiserr = pathOK(FilePath, False)
			if thiserr = "" then
				cm.parameters(0) = FileDesc
				cm.parameters(1) = FileName
				cm.Execute
				success = True			
				ShowNames = ShowNames & FileName
			end if
		end if
	next
	if success then							
		ShowNames = locUpdResult & ShowNames
	End If
	resetVar
End Sub

If Err.number <> 0 then
	negComment1 = locProb + locUnexpectProb + locSolu + locUnexpectSolu
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\publish\welcome.inc ===
<!-- VSS generated file data
$Modtime: 10/24/97 12:56p $
$Revision: 26 $
$Workfile: welcome.inc $
--> 	
<%
'--------------------------------------------------------------------
' Functions and Subs to syncronize Publisher Wizard with publish.mdb
' and \Inetpub\Webpub directory
'--------------------------------------------------------------------

Sub setConnObj
	Dim strProvider, conn
	strProvider="DRIVER=Microsoft Access Driver (*.mdb); DBQ=" & Server.MapPath("\iisadmin") & "\publish\publish.mdb;"
	Set conn = Server.CreateObject("ADODB.Connection")
    	conn.open strProvider,"",""
	Set cm = Server.CreateObject("ADODB.Command")
	cm.ActiveConnection = conn
	cm.CommandType = 1
End Sub

Sub ChkRunWiz
	If runWiz = "-1" Then
		noCache = ""
		wizWarning = ""
		wizButton = ""
		wizFormPic = "<INPUT TYPE=IMAGE SRC='../website/merlin.gif'>"
		wizPic = ""
		noCache = ""
		Response.Clear
	Else 
		noCache = "<META HTTP-EQUIV='Expires' CONTENT='0'>"
		wizWarning = "<FONT COLOR=RED FACE='VERDANA, ARIAL, HELVETICA' SIZE='-1'><STRONG>" + _
					locWarning + "</STRONG></FONT>"
		wizButton = "<FONT FACE='VERDANA, ARIAL, HELVETICA' SIZE='-2'><STRONG>" + _
  					"<FORM METHOD=POST ACTION='.." + bckSlash + "website" + bckSlash + "default.asp'>" + _
    				"<INPUT TYPE=SUBMIT VALUE='Home Page Wizard' >" + _
					"</FORM></STRONG></FONT>"
		wizFormPic = ""
		wizPic = "<IMG SRC='../website/merlin.gif'>"
		locWelcomeInstr2 = ""
	End If
End Sub

Sub readPublish  'Read all files in publish.mdb
	Dim rs, i, r
	cm.CommandText = "SELECT FileList.FileName, FileList.FileDescription, FileList.FilePath FROM FileList ORDER BY FileList.FileName"
	Set rs = cm.Execute
	If Not rs.EOF Then
		rs.MoveFirst
	End If
	Do While Not rs.EOF
		r = r + 1
		rs.movenext
	Loop
	If Not rs.BOF Then
		rs.movefirst
	End If
		For i = 1 to r
			If not rs.EOF Then
			pubMdbList1 = pubMdbList1 + rs.Fields("FileName").Value + semiColon
			rs.movenext
			End If			
		Next
End Sub

Sub setSystemObj 'Set File System Object
	Dim root, g, sc
	root = server.mappath(bckSlash)
	root = Trim(Left(root, instrRev(root, bckSlash)))
	root = root + "webpub"
	Set FileSystem=CreateObject("Scripting.FileSystemObject")
	g = FileSystem.GetAbsolutePathName(root)
	g = g + bckSlash
	Set f=FileSystem.GetFolder(g)
End Sub

Sub readWebPub 'Read all file names in WebPub
	Dim fc, fl
	Set fc = f.Files
	For Each fl in fc
		isFiles= isFiles + 1
		webDirList1 = webDirList1 + fl.name + semiColon
	Next
End Sub

Sub addNewFiles 'Add new files in webpub to publish.mdb
	Dim i, rs, posFile, filespec, webFileName, webDirList, pubMdbList, _
	objparam, g, root
	
	webDirList = webDirList1
	pubMdbList = PubMdbList1
	
			root = server.mappath(bckSlash)
			root = Trim(Left(root, instrRev(root, bckSlash)))
			root = root + "webpub"
			Set FileSystem=CreateObject("Scripting.FileSystemObject")
			g = FileSystem.GetAbsolutePathName(root)
			g = g + bckSlash
			
	For i = 1 to isFiles
		If webDirList <> "" Then
			webFileName = Trim(Mid(webDirList, 1 , instr(webDirList, semiColon)))
			webFileName = Left(webFileName, instr(webFileName, semiColon)-1)
		End If
			
		If pubMdbList = "" Then
			cm.CommandText = "INSERT INTO FileList (FileName, FileDescription, FilePath)VALUES(?, ?, ?)"
			set objparam=cm.createparameter(, 200, , 255, webFileName)
			cm.parameters.append objparam
			set objparam=cm.createparameter(, 200, , 255, "")
			cm.parameters.append objparam
			set objparam=cm.createparameter(, 200, , 255, g + webFileName)
			cm.parameters.append objparam
			Set rs = cm.Execute
		End If
			
		If pubMdbList <> "" Then
			posFile=instr(Ucase(pubMdbList), Ucase(webFileName))
			If posFile = 0 Then
				cm.CommandText = "INSERT INTO FileList (FileName, FileDescription, FilePath)VALUES(?, ?, ?)"
				set objparam=cm.createparameter(, 200, , 255, webFileName)
				cm.parameters.append objparam
				set objparam=cm.createparameter(, 200, , 255, "")
				cm.parameters.append objparam
				set objparam=cm.createparameter(, 200, , 255, g + webFileName)
				cm.parameters.append objparam
				Set rs = cm.Execute
				filespec = g + webFileName
				Set f = FileSystem.GetFile(filespec)
				If f.attributes and 2 Then
				f.attributes = f.attributes - 2
				End If
				If f.attributes and 4 Then
					f.attributes = f.attributes - 4
				End If
				If not f.attributes and 1 Then
					f.attributes = f.attributes + 1 'set file to read only
				End If
			End If
		End If
			
		If webDirList <> "" Then
			webDirList = Trim(Right(webDirList, len(webDirList) - len(webFileName)-1))
		End If
	Next
End Sub 

Sub removeFiles 'Remove files not in webpub from publish.mdb
	Dim i, webDirList, pubMdbList, pubFileName, posFile, rs, r

	webDirList = webDirList1
	pubMdbList = PubMdbList1
	
	cm.CommandText = "SELECT FileList.FileName, FileList.FileDescription, FileList.FilePath FROM FileList ORDER BY FileList.FileName"
	cm.CommandType = 1
	Set rs = cm.Execute
	If Not rs.EOF Then
		rs.MoveFirst
	End If
	Do While Not rs.EOF
		r = r + 1
		rs.movenext
	Loop
		
	For i = 0 to r
	
		If pubMdbList <>"" Then
			pubFileName = Trim(Mid(pubMdbList, 1 , instr(pubMdbList, semiColon)))
			pubFileName = Left(pubFileName, instr(pubFileName, semiColon)-1)
			posFile=instr(Ucase(webDirList), Ucase(pubFileName))
			If posFile = 0 Then
				cm.CommandText = "DELETE FROM FileList WHERE FileList.FileName = " + "'" + pubFileName + "'"
				Set rs = cm.Execute
			End If
			pubMdbList = Trim(Right(pubMdbList, len(pubMdbList) - len(pubFileName)-1))
		End If
	Next
End Sub

Sub updateStrings   'Create updated content strings
	Dim rs, r, i
	cm.CommandText = "SELECT FileList.FileName, FileList.FileDescription, FileList.FilePath FROM FileList ORDER BY FileList.FileName"
	cm.CommandType = 1
	Set rs = cm.Execute
	If Not rs.EOF Then
		rs.MoveFirst
	End If
	Do While Not rs.EOF
		r = r + 1
		rs.movenext
	Loop
	If Not rs.BOF Then
		rs.MoveFirst
	End If			
		For i = 1 to r
			If not rs.EOF Then
			strDisplay1 = strDisplay1 + rs.Fields("FileName").Value +  " " + rs.Fields("FileDescription").Value + semiColon
			strFull1 = strFull1 & rs.Fields("FileName").Value  &  "|" & rs.Fields("FileDescription").Value & "|" & rs.Fields("FilePath").Value & "|" & semiColon
			rs.movenext
			End If
		Next
		
	Myinfo.strDisplay = strDisplay1
	Myinfo.strFull = strFull1
	Myinfo.NumRecords = r		
End Sub

Sub sendUser  'Send user to page contingent on webpub content
If dropStr = "" Then
	If isFiles = 0 then 'no files in webpub
		action="Add"
		Myinfo.publish = 0
	End If
	If isFiles => 1 then 'files in webpub
		action="Choose"
		Myinfo.publish = -1
	End If
End If
	
End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\abo_enum\enumkeys.cpp ===
/*******************************************
*
* EnumKeys.CPP
*
* This is a simple program to enumerate keys
*
********************************************/


#define STRICT
#define INITGUID

#include <WINDOWS.H>
#include <OLE2.H>
#include <coguid.h>

#include <stdio.h>
#include <stdlib.h>

#include "iadmw.h"
#include "iiscnfg.h"

int main (int argc, char *argv[])
{

	IMSAdminBase *pcAdmCom = NULL;   //interface pointer

	HRESULT hresError = 0;

	DWORD EnumIndex;
	TCHAR ChildKeyName [512];
	TCHAR EnumPath[512];
	DWORD ConvertResult = 0;

	DWORD Count;
	char Tempstr [256];

	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;
	OLECHAR rgchMachineName[MAX_PATH];
	
	//fill the structure for CoGetClassObject
	csiMachineName.pAuthInfo = NULL;
	csiMachineName.dwReserved1 = 0;
	csiMachineName.dwReserved2 = 0;
	pcsiParam = &csiMachineName;

	if (argc < 2 || argc > 3)
	{
		puts ("ERROR! Wrong number of parameters");
		puts ("    You must supply at least the machine name\n");
        return -1;
	}

	strcpy (Tempstr, argv[1]);
	for (int i = 0; Tempstr[i] != '\0'; i++)
			rgchMachineName[i] = (OLECHAR) (Tempstr[i]);

	rgchMachineName[i] = 0;

	csiMachineName.pwszName = rgchMachineName;

	// Initialize COM
    hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		printf ("ERROR: CoInitialize Failed! Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		printf ("ERROR: CoGetClassObject Failed! Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}
	else
	{
		hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);
		if (FAILED(hresError)) 
		{
			printf ("ERROR: CreateInstance Failed! Error: %d (%#x)\n", hresError, hresError);
			pcsfFactory->Release();
		    return hresError;
		}
		pcsfFactory->Release();
	}


	// Initialize the path to a null string
	EnumPath [0] = 0;

	if (argc != 3)
	{
		// Set up a default path.
		ConvertResult = MultiByteToWideChar( 
						CP_ACP,
						0, //flags
						"/",
						1,
						EnumPath,
						256); 
		// Null Terminate the string
		EnumPath [1] = 0;
	}
	else 
	{	// Convert the name of the path passed in as a command line arg to unicode.
		ConvertResult = MultiByteToWideChar( 
						CP_ACP,
						0, //flags
						argv[2],
						strlen (argv[2]),
						EnumPath,
						256); 
		// Null Terminate the string
		EnumPath [strlen(argv[2])] = 0;
	}

	if (ConvertResult == 0)
	{
		printf ("ERROR: Could not convert path! GetLastError: %d (%#x)\n", GetLastError(), GetLastError());
        return hresError;
	}

	wprintf (TEXT("Enumerating Path: %s\n\n"), EnumPath);

	// Enumerate the data
	hresError = 0;
	for (EnumIndex = 0; ; EnumIndex ++)
	{
		hresError = pcAdmCom -> EnumKeys (
			METADATA_MASTER_ROOT_HANDLE,
			EnumPath,
			ChildKeyName,
			EnumIndex);
		if (hresError != 0) break;

		wprintf (TEXT("[%s]\n"), ChildKeyName);
	}

	if ((hresError != 0 ) && (hresError != 0x80070103))
	{
		printf ("EnumIndex: %d \n", EnumIndex);
		printf ("EnumKeys return code: %d (%#x)\n", hresError, hresError);
	}

	Count = pcAdmCom->Release();

	if (Count != 0)
	{
		printf ("ERROR: Release does not return 0! Count: %d (%#x)\n", Count, Count);
        return hresError;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\publish\jsbrowser\iisetfnt.inc ===
<%


if Session("FONTSCALE") = "" then
	Session("FONTSCALE") = 1
end if
if Session("FONTFACE") = "" then
	Session("FONTFACE") = "Helv"
end if
if Session("FONTPOINT") = "" then
	Session("FONTPOINT") = 1	
end if
if Session("BrowserVScalePct") = "" then
	Session("BrowserVScalePct") = 100
end if
if Session("BrowserHScalePct") = "" then
	Session("BrowserHScalePct") = 100
end if

Function sFont(iSize,sFace,sColor,bScale)
	Dim sOutputStr

	sOutputStr = "<FONT"
	if sFace <> "" then
			sOutputStr = sOutputStr & " FACE=" & sFace
	else
			sOutputStr = sOutputStr & " FACE=" & Session("FONTFACE")
	end if 

	if iSize = "" then
		iSize = cInt(Session("FONTPOINT"))
	end if
	if bScale then
		iSize = cInt(iSize * Session("FONTSCALE"))
	end if
	sOutputStr = sOutputStr & " SIZE=" & iSize
	if sColor <> "" then
			sOutputStr = sOutputStr & " COLOR=" & sColor
	end if
	
	sOutputStr = sOutputStr & ">"

	sFont = sOutputStr
End Function



Function iVScale(iSize)
	iVScale = iScale(iSize,"BrowserVScalePct")
End Function

Function iHScale(iSize)
	iHScale = iScale(iSize,"BrowserHScalePct")
End Function


Function iScale(iSize,direction)
	if iSize <> 0 then
		iScale = cInt((Session(direction) * iSize)/100)
	else
		iScale = iSize	
	end if
End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\website\myinfo.inc ===
<%
'				*****************  Wizard
 If Request.Form("theme") <> "" Then
	myinfo.Theme = Request.Form("Theme")
 End If

 If Request.Form("guestbook") <> "" Then
	myinfo.Guestbook = Request.Form("guestbook")
 End If

 If Request.Form("messages") <> "" Then
	myinfo.Messages = Request.Form("messages")
 End If

'				*****************  Template

 Sub variableAssignments
	If request.Form("basics") <> "" Then
	    If request.Form("Theme") <> "" Then
		    myinfo.Theme = request.Form("Theme")
		    Theme = myinfo.Theme
	    End If
	End If

	If request.Form("contents") <> "" Then
        If Request.Form("guestbook") <> "" Then
	        myinfo.Guestbook = Request.Form("guestbook")
		Else
			myinfo.Guestbook = "0"
        End If

        If Request.Form("messages") <> "" Then
	        myinfo.Messages = Request.Form("messages")
		Else
			myinfo.Messages = "0"
        End If

        myinfo.Title = request.Form("title")
	    myinfo.faxPhone = request.Form("faxPhone")
        myinfo.Address1 = request.Form("Address1")
        myinfo.Address2 = request.Form("Address2")
        myinfo.Address3 = request.Form("Address3")
        myinfo.Address4 = request.Form("Address4")
	    myinfo.Department = request.Form("Department")
	    myinfo.Phone = request.Form("Phone")
	    myinfo.Email = request.Form("Email")
        myinfo.Name = request.Form("Name")
        myinfo.Heading1 = request.Form("Heading1")
        myinfo.Words1 = request.Form("Words1")
        myinfo.Heading2 = request.Form("Heading2")
        myinfo.Words2 = request.Form("Words2")
        myinfo.Heading3 = request.Form("Heading3")
        myinfo.Words3 = request.Form("Words3")
        myinfo.Heading4 = request.Form("Heading4")
        myinfo.Words4 = request.Form("Words4")
	End If
 End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\website\t_theme.inc ===
<!--
	$Date: 11/24/97 11:59a $
	$ModTime: $
	$Revision: 1 $
	$Workfile: t_theme.inc $
-->
<%
 If myinfo.Theme <> "" Then
	If myinfo.Theme = "gunmetal" Then
%>
<!--#include virtual ="/iissamples/homepage/themes/gunmetal/setup.inc"-->
<%
	ElseIf myinfo.Theme = "looseleaf" Then
%>
<!--#include virtual ="/iissamples/homepage/themes/looseleaf/setup.inc"-->
<%
	ElseIf myinfo.Theme = "journal" Then
%>
<!--#include virtual ="/iissamples/homepage/themes/journal/setup.inc"-->

<%
	End If
 End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\abo_vdir\create_vdir.cpp ===
/*******************************************
*
* CREATE_VDIR.CPP
*
* This is a really simple example of how to create a vdir using the 
* IMSAdminBase interface
*
********************************************/


#define STRICT
#define INITGUID

#include <WINDOWS.H>
#include <OLE2.H>
#include <coguid.h>
#include <winerror.h>
#include <stdio.h>
#include <stdlib.h>

#include "iadmw.h"
#include "iiscnfg.h"


// Just to make this a REALLY simplistic (to the point of being useless) sample,
// we'll just #define the data and paths we will be using.

// Note that all vroots of a new server must go under the root node of the
// virtual server.  In the following statements, the virtual server (1) is 
// "/lm/w3svc/1".  The new vroot will go underneath "/lm/w3svc/1/root"

// Also note that these strings are UNICODE
#define NEW_VROOT_PATH  TEXT("newvroot")
#define NEW_VROOT_PARENT TEXT("/lm/w3svc/1/root")
#define NEW_VROOT_FULLPATH TEXT("/lm/w3svc/1/root/newvroot")
#define NEW_VROOT_DIRECTORY TEXT("C:\\TEMP")




int main (int argc, char *argv[])
{
	IMSAdminBase *pcAdmCom = NULL;   // COM interface pointer
	HRESULT hresError = 0;  // Holds the errors returned by the IMSAdminBase api calls
	DWORD dwRefCount;  // Holds the refcount of the IMSAdminBase object (don't really need it).

	DWORD dwResult = 0;

	METADATA_HANDLE hmdParentHandle;  // This is the handle to the parent object of our new vdir
	METADATA_HANDLE hmdChildHandle;  // This is the handle to the parent object of our new vdir

	if (argc < 2)
	{
		puts ("Usage: Create_vdir <machine name>\n  Ex: Create_Vdir adamston1\n\n");
		return -1;
	}

	printf ("We will be adding a new VRoot path in the metabase. \n"
		"  Machine Name: %s\n"
		"  Path: %s\n"
		"  Full Path: %s/%s\n",
		argv[1],
		NEW_VROOT_PATH,
		NEW_VROOT_PARENT,
		NEW_VROOT_PATH);

	// These are required for creating a COM object
	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;

	// fill the structure for CoGetClassObject
	csiMachineName.pAuthInfo = NULL;
	csiMachineName.dwReserved1 = 0;
	csiMachineName.dwReserved2 = 0;
	pcsiParam = &csiMachineName;



	// Allocate memory for the machine name
	csiMachineName.pwszName = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (strlen (argv[1]) + 1) * sizeof (WCHAR) );
	if (csiMachineName.pwszName == NULL)
	{
		printf ("Error allocating memory for MachineName\n");
		return E_OUTOFMEMORY;
	}

	// Convert Machine Name from ASCII to Unicode
	dwResult = MultiByteToWideChar (
		CP_ACP,
		0,
		argv[1],
		strlen (argv[1]) + 1,
		csiMachineName.pwszName,
		strlen (argv[1]) + 1);

	if (dwResult == 0)
	{
		printf ("Error converting Machine Name to UNICODE\n");
		return E_INVALIDARG;
	}


	// Initialize COM
    hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		printf ("ERROR: CoInitialize Failed! Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		printf ("ERROR: CoGetClassObject Failed! Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}
	else
	{
		hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);
		if (FAILED(hresError)) 
		{
			printf ("ERROR: CreateInstance Failed! Error: %d (%#x)\n", hresError, hresError);
			pcsfFactory->Release();
		    return hresError;
		}
		pcsfFactory->Release();
	}


/***********************************************/
/* Important Section */

	// Open the path to the parent object
	hresError = pcAdmCom->OpenKey (
			METADATA_MASTER_ROOT_HANDLE,
			NEW_VROOT_PARENT,
			METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
			1000,
			&hmdParentHandle);

	if (FAILED(hresError)) 
	{
		printf ("ERROR: Could not open the Parent Handle! Error: %d (%#x)\n", hresError, hresError);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("Path to parent successfully opened\n");


	/***********************************/
	/* Add the new Key for the VROOT */
	hresError = pcAdmCom->AddKey (
		hmdParentHandle,
		NEW_VROOT_PATH);


    if (FAILED(hresError))
	{
		printf ("ERROR: AddKey Failed! Error: %d (%#x)\n", hresError, hresError);
		hresError = pcAdmCom->CloseKey(hmdParentHandle);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("New Child successfully added\n");

	// Close the handle to the parent and open a new one to the child.
	// Technically, this isn't required, but when the handle is open at the parent, no other
	// metabase client can access that part of the tree or subsequent child.  We will open
	// the child key because it is lower in the metabase and doesn't conflict with as many
	// other paths.
	hresError = pcAdmCom->CloseKey(hmdParentHandle);
	if (FAILED(hresError)) 
	{
		printf ("ERROR: Could not close the Parent Handle! Error: %d (%#x)\n", hresError, hresError);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	hresError = pcAdmCom->OpenKey (
			METADATA_MASTER_ROOT_HANDLE,
			NEW_VROOT_FULLPATH,
			METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
			1000,
			&hmdChildHandle);

	if (FAILED(hresError)) 
	{
		printf ("ERROR: Could not open the Child Handle! Error: %d (%#x)\n", hresError, hresError);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("Path to child successfully opened\n");

	/***********************************/
	/* Now, the vroot needs a few properties set at the new path in order */
	/* for it to work properly.  These properties are MD_VR_PATH, MD_KEY_TYPE */
	/* and MD_ACCESSPERM. */

	METADATA_RECORD mdrNewVrootData;

	// First, add the MD_VR_PATH - this is required to associate the vroot with a specific
	// directory on the filesystem
	mdrNewVrootData.dwMDIdentifier = MD_VR_PATH;

	// The inheritible attribute means that paths that are created underneath this
	// path will retain the property from the parent node unless overwritten at the 
	// new child node.
	mdrNewVrootData.dwMDAttributes = METADATA_INHERIT;
	mdrNewVrootData.dwMDUserType = IIS_MD_UT_FILE;
	mdrNewVrootData.dwMDDataType = STRING_METADATA;

	// Now, create the string. - UNICODE
	mdrNewVrootData.pbMDData = (PBYTE) NEW_VROOT_DIRECTORY;
	mdrNewVrootData.dwMDDataLen = (wcslen (NEW_VROOT_DIRECTORY) + 1) * sizeof (WCHAR);
	mdrNewVrootData.dwMDDataTag = 0;  // datatag is a reserved field.

	// Now, set the property at the new path in the metabase.
	hresError = pcAdmCom->SetData (
		hmdChildHandle,
		TEXT ("/"),
		&mdrNewVrootData);

	
    if (FAILED(hresError))
	{
		printf ("ERROR: Setting the VR Path Failed! Error: %d (%#x)\n", hresError, hresError);
		hresError = pcAdmCom->CloseKey(hmdChildHandle);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("Successfully set the vrpath\n");



	/***********************************/
	// Second, add the MD_KEY_TYPE - this indicates what type of key we are creating - 
	// The vroot type is IISWebVirtualDir
	mdrNewVrootData.dwMDIdentifier = MD_KEY_TYPE;

	// The inheritible attribute means that paths that are created underneath this
	// path will retain the property from the parent node unless overwritten at the 
	// new child node.
	mdrNewVrootData.dwMDAttributes = METADATA_INHERIT;
	mdrNewVrootData.dwMDUserType = IIS_MD_UT_FILE;
	mdrNewVrootData.dwMDDataType = STRING_METADATA;

	// Now, create the string. - UNICODE
	mdrNewVrootData.pbMDData = (PBYTE) TEXT("IIsWebVirtualDir");
	mdrNewVrootData.dwMDDataLen = (wcslen (TEXT("IIsWebVirtualDir")) + 1) * sizeof (WCHAR);
	mdrNewVrootData.dwMDDataTag = 0;  // datatag is a reserved field.

	// Now, set the property at the new path in the metabase.
	hresError = pcAdmCom->SetData (
		hmdChildHandle,
		TEXT ("/"),
		&mdrNewVrootData);

	
    if (FAILED(hresError))
	{
		printf ("ERROR: Setting the Keytype Failed! Error: %d (%#x)\n", hresError, hresError);
		hresError = pcAdmCom->CloseKey(hmdChildHandle);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("Successfully set the Keytype \n");


	/***********************************/
	// Now, add the MD_ACCESS_PERM - this tells whether we should read, write or
	// execute files within the directory.  For now, we will simply add
	// READ permissions.
	mdrNewVrootData.dwMDIdentifier = MD_ACCESS_PERM;

	// The inheritible attribute means that paths that are created underneath this
	// path will retain the property from the parent node unless overwritten at the 
	// new child node.
	mdrNewVrootData.dwMDAttributes = METADATA_INHERIT;
	mdrNewVrootData.dwMDUserType = IIS_MD_UT_FILE;
	mdrNewVrootData.dwMDDataType = DWORD_METADATA;

	// Now, create the access perm
	DWORD dwAccessPerm = 1; // 1 is read only
	mdrNewVrootData.pbMDData = (PBYTE) &dwAccessPerm;
	mdrNewVrootData.dwMDDataLen = sizeof (DWORD);
	mdrNewVrootData.dwMDDataTag = 0;  // datatag is a reserved field.

	// Now, set the property at the new path in the metabase.
	hresError = pcAdmCom->SetData (
		hmdChildHandle,
		TEXT ("/"),
		&mdrNewVrootData);

	
    if (FAILED(hresError))
	{
		printf ("ERROR: Setting the accessperm failed! Error: %d (%#x)\n", hresError, hresError);
		hresError = pcAdmCom->CloseKey(hmdChildHandle);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("Successfully set the accessperm\n");

	/************************************************/
	// We're done!!!  Just clean up.
	hresError = pcAdmCom->CloseKey(hmdChildHandle);
	if (FAILED(hresError)) 
	{
		printf ("ERROR: Could not close the Child Handle! Error: %d (%#x)\n", hresError, hresError);
		dwRefCount = pcAdmCom->Release();
	    return hresError;
	}

	printf ("\nYou Have successfully installed a new VRoot at %S\n", NEW_VROOT_FULLPATH);

	// Release the object
	dwRefCount = pcAdmCom->Release();

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\adminextn.cpp ===
// AdminExtn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AdminExtnps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include <iadmext.h>

#include "AdminExtn.h"

#include "AdminExtn_i.c"


#include "SimpleExtn.h"
#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ & IIS_MD_ #defines 


#include "AdmSink.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SimpleExtn, CSimpleExtn)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ADMINEXTNLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\website\themes.inc ===
<%
'	$Date: 11/24/97 12:17p $
'	$ModTime: $
'	$Revision: 2 $
'	$Workfile: themes.inc $

 Sub ShowFolderList(folderspec)
    Dim fs, f, f1, fc, s
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFolder(folderspec)
	Set fc = f.SubFolders
	s = "<OPTION VALUE=""" & """ SELECTED>Select your theme!"
    For Each f1 in fc
		s = s & "<OPTION NAME=" & """Theme""" & " VALUE=""" & f1.name 
		If myinfo.Theme = f1.name Then
			s = s & """ SELECTED>" & f1.name
		Else
			s = s & """>" & f1.name
		End If
	Next
	s = s & "</SELECT>"
    response.write s
 End Sub

 If myinfo.ranWizard <> "" Then
	'response.write "<FONT Size='-1'><A HREF = " & """#""" & " onClick = """ & HelpWindow("Style") & """>Template Style</A></FONT><BR>"_
 	'&
	response.write "<SELECT NAME='theme' Language='VBSCRIPT' ONCHANGE='Submit'>" 
 Else
	response.write "<H5>You can choose from the following templates to personalize your home page.</H5><BR><blockquote>"_
	& "<SELECT NAME='theme' Size=3>"
 End If
 call ShowFolderList(Server.MapPath("/iissamples/homepage/themes"))
 If myinfo.ranWizard <> "" Then 
	response.write "</blockquote>"
 End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\htmla\website\tempsubs.inc ===
<!--
	$Date: 10/07/97 9:59a $
	$ModTime: $
	$Revision: 18 $
	$Workfile: tempsubs.inc $
-->
<%
 Function HelpWindow(name)
	DIM strWindow
	strWindow =  "window.open'/Iisadmin/Tour/iiwzhlp.htm#" & name & "','help','height=200,width=400,scrollbars'"
	HelpWindow = strWindow
 End Function
'				*********************** ranWizard check
Sub Template_ranWizardCheck
	If myinfo.ranWizard <> "" Then
 	 If myinfo.ranWizard = 0 Then
	   ranWizard = "False"
	 ElseIf myinfo.ranWizard = "-1" Then
	   ranWizard = "True"
	 End If
	Else
	 ranWizard = "False"
 	 myinfo.ranWizard = 0
	End If
End Sub
'				******************* GENERIC CONTENTS  *************
'				*********************	MESSAGING/LINKS
' window.open("iiwzhlp.htm","IIS Wizard Help","width=400,height=300,resizable=no,scrollbars=yes")
 Sub Template_page_messaging
    response.write "<Span ID=header><FONT face='Verdana' size='-2'>"_
    & "Check these boxes to include a <A HREF = " & """#""" & " onClick = """ & HelpWindow("GuestBook") & """>guest book or a drop box</a><BR>"_
	& "<INPUT TYPE='checkbox' NAME='Guestbook' VALUE='-1'"
	    If myinfo.Guestbook = "-1" Then
		    response.write " CHECKED "
	    End If
    response.write " >Guest Book<BR>"_
    & "<INPUT TYPE='checkbox' NAME='Messages' VALUE='-1'"
	    If myinfo.Messages = "-1" Then
		    response.write " CHECKED "
	    End If
    response.write ">Drop box<BR></FONT></SPAN>"
 End Sub
'				************************ favorite links
  Sub Template_page_links
	response.write "<Span ID=header><FONT face='Verdana' size='-2'>"_
	& "<IFRAME NAME='linksFrame' WIDTH='200' HEIGHT='220' FRAMEBORDER=0 SRC='urlform.asp'>"_
	& "<FRAME NAME='linksFrame' WIDTH='200' HEIGHT='220' FRAMEBORDER=0 SRC='urlform.asp'>"_
	& "</IFRAME></FONT></SPAN>"
 End Sub
'               ************************* title / main contents

 Sub Template_title
	response.write "<SPAN ID=header><FONT face='Verdana' size='-2'>"
	If myinfo.title <> "" Then
	  response.write "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Title") & """>This is the title for your home page</A><BR>"_
	  & "<H1>" & myinfo.Title & "</H1><BR>"_
	  & "You can change the title below.<BR>"
	Else
		  response.write "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Title") & """>Enter a title for your home page.</A><BR>"
	End If
	response.write "<INPUT NAME=title TYPE=text style='color:black;font-family:verdana;font-size:10pt;' size=38 maxlength=39 Value="""_
    & myinfo.Title & """></FONT></SPAN>"
 End Sub

'					********************** main page contents
 Sub Template_Address
    response.write "<SPAN ID='title'><Font Face='Verdana' Size='-2'>"_
	& "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Department") & """>Type your department or division name here.</A><BR>"_
	& "<INPUT NAME='Department' TYPE='text' size=38 maxlength=39 "_
	& "VALUE="""_
	& myinfo.Department & """><BR><A HREF = " & """#""" & " onClick = """ & HelpWindow("Address") & """>Type your address here.</A><BR>"
	DIM number
	number = 1
	For number = 1 to 4
		response.write "<INPUT NAME = 'address" & number & "' TYPE = 'text'"_
		& " size=43 style='color:black;font-family:verdana;font-size:10pt;' maxlength=60 VALUE=""" & MyInfo("Address" & number) & """><BR>"
	Next
 End Sub

 Sub Template_Phone
	response.write "<SPAN ID='title'><Font Face='Verdana' Size='-2'>"_
		& "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Phone") & """>Phone number</A><BR>"_
		& "<INPUT NAME = 'Phone' TYPE = 'text' size=20  style='color:black;font-family:verdana;font-size:10pt;' maxlength=30 "_
		& "VALUE="""_
		& myinfo.Phone & """><BR></Font></Span>"
 End Sub

 Sub Template_Email
	response.write "<SPAN ID=header><FONT face='Verdana' size='-2'>"_
	& "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Email") & """>Email</A></Font></Span><BR>"_
	& "<INPUT NAME = 'Email'  style='color:black;font-family:verdana;font-size:10pt;' TYPE = 'text'"_
	& " size=38 maxlength=60 VALUE="""_
	& myinfo.Email
	response.write """><BR>"
 End Sub

 Sub Template_Name
	response.write "<SPAN ID=header><FONT face='Verdana' size='-2'>"_
	& "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Name") & """>Name<A></Font></Span><BR>"_
	& "<INPUT NAME = 'Name' TYPE = 'text' size=38  style='color:black;font-family:verdana;font-size:10pt;' maxlength=50 VALUE=""" & myinfo.Name & """>"
 End Sub

 Sub Template_faxPhone
	response.write "<FONT face='Verdana' size='-2'>"_
	& "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Fax") & """>Fax number:</A></FONT><BR>"_
	& "<IMG SRC='space.gif' Width='20' Height='1'>"_
	& "<INPUT TYPE=text NAME='faxPhone' size=20  style='color:black;font-family:verdana;font-size:10pt;' maxlength=30 VALUE="""_
	& myinfo.faxPhone &""">"
 End Sub

'					***********************	Page Words
 Function Template_Heading()
	Dim strHeading, number
	strHeading = ""
	number = 1
	For number = 1 to 4
		If number = 1 Then
			strHeading = strHeading & "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Heading") & """>Type a heading for the following paragraph</A>."
		Else
			strHeading = strHeading & "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Heading") & """>Type an additional heading here</A>."
		End If	
		strHeading = strHeading & "</FONT><BR><INPUT NAME = 'Heading" & number & "' TYPE = 'TEXT' size=43 maxlength=43 VALUE=""" & myinfo("Heading" & number)
		strHeading = strHeading & """ style='color:black; font-family:verdana;font-size:10pt;font-weight:bold'>&#10;&#13;"
		strHeading = strHeading & "<BR><FONT style='font-family:verdana;font-size:10pt'>"
		If number = 1 Then
			strHeading = strHeading & "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Paragraph") & """>Type a paragraph about yourself, about something you are interested in, or your job</A>."
		Else
			strHeading = strHeading & "<A HREF = " & """#""" & " onClick = """ & HelpWindow("Paragraph") & """>Type additional information here</A>."
		End If
		strHeading = strHeading & "</FONT><BR><TEXTAREA NAME ='Words" & number & "' WRAP=PHYSICAL ROWS=4 COLS=44 style='font-family:verdana;font-size:10pt'>"& myinfo("Words" & number) & "</TEXTAREA><BR>"
	Next
	Template_Heading = strHeading
 End Function

'				*************************			form data submission
 Sub Template_Theme_onClick
	document.HPWiz.Submit
	document.Template.Submit
 End Sub

 Sub Template_addLink
	document.urlUpdate.Submit
 End Sub

  Sub urlArray
	response.write "<TR><TD><SPAN ID=header><Font Face='Verdana' Size='-2'>"_				   
	& "<SELECT NAME='urlEdit' MULTIPLE SIZE = 5  style='color:black;font-family:verdana;font-size:10pt;'>"
	Dim urlList(), urlWordsList()
	intID = 0
	For i = 0 to myinfo.intUrl
		If myinfo("urlWords" & i) = "null" or myinfo("url" & i) = "http://" or myinfo("url" & i) = ""  THEN
			myinfo("url" & i) = "null"
			myinfo("urlWords" & i) = "null"
		Else
			Redim Preserve urlList(intID), urlWordsList(intID)
			urlList(intID) = Myinfo("url" & i)
				urlWordsList(intID) = Myinfo("urlWords" & i)
			response.write "<OPTION NAME='remove' VALUE=""" & i & """>" & " " & urlWordsList(intID)
			intID = intID + 1
		END IF
	Next
	If intID <> "" Then
		response.write "</SELECT></FONT></TD></TR><TR><TD Valign=top align=left>" &_
		"<INPUT type=submit NAME='removeLink' VALUE='remove link'>"_
		& "</Font></Span></TD></TR>"
	End If
 End Sub

 Sub addLink
		If myinfo.inturl <> "" Then
			i = 1 + myinfo.intUrl
			myinfo("url" & i) = Request.Form("url")
			If request.Form("urlWords") <> "" Then
				myinfo("urlWords" & i) = request.Form("urlWords")
			Else
				myinfo("urlWords" & i) = request.Form("url")
			End If
			myinfo.intUrl = i
		Else
			myinfo.url1 = request.Form("url")
			If request.Form("urlWords") <> "" Then
				myinfo.urlWords1 = request.Form("urlWords")
			Else
				myinfo.urlWords1 = request.Form("url")
			End If
			myinfo.inturl = 1
		End If
 End Sub


 Sub removeLink
	i = Request.Form("urlEdit")						'link to remove
	myinfo("url" & i) = "null"
	myinfo("urlWords" & i) = "null"
 End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\adminextn_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Aug 17 10:21:10 1998
 */
/* Compiler settings for C:\curwork\beta\AdminExtn\AdminExtn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ISimpleExtn = {0x44235DA6,0x35F5,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const IID IID_IAdmSink = {0x44235DA8,0x35F5,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const IID LIBID_ADMINEXTNLib = {0x44235D9A,0x35F5,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const CLSID CLSID_SimpleExtn = {0x44235DA7,0x35F5,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const CLSID CLSID_AdmSink = {0x44235DA9,0x35F5,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\admsink.h ===
// AdmSink.h : Declaration of the CAdmSink

#ifndef __ADMSINK_H_
#define __ADMSINK_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAdmSink
class ATL_NO_VTABLE CAdmSink : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IMSAdminBaseSink
{
public:
	CAdmSink()
	{
	}


DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdmSink)
	COM_INTERFACE_ENTRY(IMSAdminBaseSink)
END_COM_MAP()

	// IMSAdminBaseSinkinterface
	HRESULT STDMETHODCALLTYPE SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

	HRESULT STDMETHODCALLTYPE ShutdownNotify( void);
public:

	HANDLE m_hLogFile;
};

#endif //__ADMSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\adminextn.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Aug 17 10:21:10 1998
 */
/* Compiler settings for C:\curwork\beta\AdminExtn\AdminExtn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __AdminExtn_h__
#define __AdminExtn_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISimpleExtn_FWD_DEFINED__
#define __ISimpleExtn_FWD_DEFINED__
typedef interface ISimpleExtn ISimpleExtn;
#endif 	/* __ISimpleExtn_FWD_DEFINED__ */


#ifndef __IAdmSink_FWD_DEFINED__
#define __IAdmSink_FWD_DEFINED__
typedef interface IAdmSink IAdmSink;
#endif 	/* __IAdmSink_FWD_DEFINED__ */


#ifndef __SimpleExtn_FWD_DEFINED__
#define __SimpleExtn_FWD_DEFINED__

#ifdef __cplusplus
typedef class SimpleExtn SimpleExtn;
#else
typedef struct SimpleExtn SimpleExtn;
#endif /* __cplusplus */

#endif 	/* __SimpleExtn_FWD_DEFINED__ */


#ifndef __AdmSink_FWD_DEFINED__
#define __AdmSink_FWD_DEFINED__

#ifdef __cplusplus
typedef class AdmSink AdmSink;
#else
typedef struct AdmSink AdmSink;
#endif /* __cplusplus */

#endif 	/* __AdmSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISimpleExtn_INTERFACE_DEFINED__
#define __ISimpleExtn_INTERFACE_DEFINED__

/* interface ISimpleExtn */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISimpleExtn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44235DA6-35F5-11D2-B605-00C04FB6F3A1")
    ISimpleExtn : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISimpleExtnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleExtn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleExtn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleExtn __RPC_FAR * This);
        
        END_INTERFACE
    } ISimpleExtnVtbl;

    interface ISimpleExtn
    {
        CONST_VTBL struct ISimpleExtnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleExtn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleExtn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleExtn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISimpleExtn_INTERFACE_DEFINED__ */


#ifndef __IAdmSink_INTERFACE_DEFINED__
#define __IAdmSink_INTERFACE_DEFINED__

/* interface IAdmSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAdmSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44235DA8-35F5-11D2-B605-00C04FB6F3A1")
    IAdmSink : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAdmSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAdmSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAdmSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAdmSink __RPC_FAR * This);
        
        END_INTERFACE
    } IAdmSinkVtbl;

    interface IAdmSink
    {
        CONST_VTBL struct IAdmSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdmSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdmSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdmSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAdmSink_INTERFACE_DEFINED__ */



#ifndef __ADMINEXTNLib_LIBRARY_DEFINED__
#define __ADMINEXTNLib_LIBRARY_DEFINED__

/* library ADMINEXTNLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ADMINEXTNLib;

EXTERN_C const CLSID CLSID_SimpleExtn;

#ifdef __cplusplus

class DECLSPEC_UUID("44235DA7-35F5-11D2-B605-00C04FB6F3A1")
SimpleExtn;
#endif

EXTERN_C const CLSID CLSID_AdmSink;

#ifdef __cplusplus

class DECLSPEC_UUID("44235DA9-35F5-11D2-B605-00C04FB6F3A1")
AdmSink;
#endif
#endif /* __ADMINEXTNLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\admsink.cpp ===
// AdmSink.cpp : Implementation of CAdmSink
#include "stdafx.h"
#include "AdminExtn.h"

#include <iadmw.h>
#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ & IIS_MD_ #defines 

#include "AdmSink.h"
HRESULT WriteLogRecord (HANDLE hLogFile, CHAR *pszRecord);
/////////////////////////////////////////////////////////////////////////////
// CAdmSink


HRESULT STDMETHODCALLTYPE
CAdmSink::ShutdownNotify(void)
{
 	CHAR pszErrStr [256];

    strcpy (pszErrStr, "*************************Callback! Shutdown!\n");
	WriteLogRecord (m_hLogFile, pszErrStr);
    return (0);
}

HRESULT STDMETHODCALLTYPE
CAdmSink::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
	DWORD i = 0;
	DWORD j = 0;

	CHAR pszErrStr [256];
	CHAR pszChangeType [80];

 return (0);
    sprintf (pszErrStr, "Callback! NumRecords: %u\n", dwMDNumElements);
	WriteLogRecord (m_hLogFile, pszErrStr);

    for (i = 0; i < dwMDNumElements; i++)
	{
		// Make a simple, semi-human readable callback string
		strcpy (pszChangeType, "     ");
		if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT)
			pszChangeType [0] = 'D';
		if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT)
			pszChangeType [1] = 'A';
		if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_SET_DATA)
			pszChangeType [2] = 's';
		if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_DELETE_DATA)
			pszChangeType [3] = 'd';
		if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_RENAME_OBJECT)
			pszChangeType [4] = 'R';

		sprintf(pszErrStr, "Change Type = %s (%#x), Path = %S\n", 
					pszChangeType, 
					pcoChangeList[i].dwMDChangeType, 
					pcoChangeList[i].pszMDPath);
		WriteLogRecord (m_hLogFile, pszErrStr);


        if (pcoChangeList[i].dwMDChangeType & MD_CHANGE_TYPE_SET_DATA)
		{
			strcpy (pszErrStr,"  Data IDs:\n");
			WriteLogRecord (m_hLogFile, pszErrStr);

			for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j ++)
			{
				sprintf (pszErrStr, "  %u (%#x)\n", 
					pcoChangeList[i].pdwMDDataIDs [j], 
					pcoChangeList[i].pdwMDDataIDs [j]);
				WriteLogRecord (m_hLogFile, pszErrStr);
			}
		}
    }

	WriteLogRecord (m_hLogFile, "****************************\n");

    return (0);
}

HRESULT WriteLogRecord (HANDLE hLogFile, CHAR *pszRecord)
{
	BOOL bWriteResult;
	DWORD dwNumBytesWritten;

	HRESULT hresFinal = ERROR_SUCCESS;

	bWriteResult = WriteFile (
					hLogFile,
					(PBYTE)pszRecord,
					strlen (pszRecord),
					&dwNumBytesWritten,
					NULL);

	if (!bWriteResult)
		hresFinal = HRESULT_FROM_WIN32 (GetLastError());

	return hresFinal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AdminExtn.rc
//
#define IDS_PROJNAME                    100
#define IDR_SIMPLEEXTN                  101
#define IDR_ADMSINK                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\simpleextn.h ===
// SimpleExtn.h : Declaration of the CSimpleExtn

#ifndef __SIMPLEEXTN_H_
#define __SIMPLEEXTN_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimpleExtn
class ATL_NO_VTABLE CSimpleExtn : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSimpleExtn, &CLSID_SimpleExtn>,
	public IADMEXT
{
public:
	CSimpleExtn()
	{
		m_bConnectionEstablished= FALSE;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SIMPLEEXTN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSimpleExtn)
	COM_INTERFACE_ENTRY(IADMEXT)
END_COM_MAP()

	// IADMEXT interface
	STDMETHOD (Initialize)(void);
	STDMETHOD (EnumDcomCLSIDs)( CLSID *pclsidDcom, DWORD dwEnumIndex);
	STDMETHOD (Terminate)( void );
public:

private:
		CComPtr <IUnknown>			m_pUnk; 
		CComPtr<IUnknown>			m_pSink;  //pointer to 
		DWORD						m_dwCookie;
		BOOL						m_bConnectionEstablished;
		HANDLE						m_hLogFile;
};

#endif //__SIMPLEEXTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\simpleextn.cpp ===
// SimpleExtn.cpp : Implementation of CSimpleExtn
#include "stdafx.h"
#include "AdminExtn.h"

#include <iadmext.h>
#include "SimpleExtn.h"

#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ & IIS_MD_ #defines 
#include "AdmSink.h"

#define ADMEXT_MAX_FILE_LENGTH 256
/////////////////////////////////////////////////////////////////////////////
// CSimpleExtn

STDMETHODIMP CSimpleExtn::Initialize(void)
{
	//  CLSID_MSAdminBase
	// Create CAdmSink object
	// Get interface pointer to IID_IMSAdminBase
	// Find ConnectionPoint 
	// call atlAdvise
	HRESULT hr;
	CHAR szLogFileName [ADMEXT_MAX_FILE_LENGTH] = "C:\\Temp\\TestAdmExtn.Log";

	//Get an interface pointer to IISAdmin server
	hr = CoCreateInstance (
			CLSID_MSAdminBase,
			NULL,
			CLSCTX_ALL,
			IID_IUnknown,
			reinterpret_cast<void**> (&m_pUnk)
			);

	if(hr!=S_OK)
	{
		return hr;
	}

	// create a log file.
	m_hLogFile = CreateFile (
					szLogFileName,
					GENERIC_WRITE,
					FILE_SHARE_READ, // share out for read access only
					NULL, // no security
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL); // no template file


	//Create CAdmSink Object and initialize it with log file handle

	CComObject<CAdmSink> *pCAdmSink;

	hr= CComObject<CAdmSink>::CreateInstance( &pCAdmSink);
	
	if (FAILED (hr) )
		return hr;
	pCAdmSink->m_hLogFile=m_hLogFile;

	hr = pCAdmSink->QueryInterface ( IID_IMSAdminBaseSink, 
					reinterpret_cast<void**> (&m_pSink)
					);

	if(SUCCEEDED(hr))
	{
		hr = AtlAdvise (
				m_pUnk, 
				m_pSink, 
				IID_IMSAdminBaseSink, 
				&m_dwCookie);
		if (hr == S_OK)
			m_bConnectionEstablished = TRUE;
		else
			m_bConnectionEstablished = FALSE;
	}
							
	return 0;
}


STDMETHODIMP CSimpleExtn::EnumDcomCLSIDs( CLSID *pclsidDcom, DWORD dwEnumIndex)
{
	// return CLSID_SimpleExtn to register it into iis metabase
	if (dwEnumIndex==0)
	{
		*pclsidDcom=CLSID_SimpleExtn;
		return S_OK;
	}
	else
		return HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS);
}


STDMETHODIMP CSimpleExtn::Terminate(void)
{
	//call AtlUnAdvice() to disconnect notification connection
	//Since pSink is smart pointer, I do not need to call release() function
	if ( m_bConnectionEstablished == TRUE )
		AtlUnadvise (m_pUnk, IID_IMSAdminBaseSink , m_dwCookie);
	CloseHandle(m_hLogFile);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adminextn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__44235D9D_35F5_11D2_B605_00C04FB6F3A1__INCLUDED_)
#define AFX_STDAFX_H__44235D9D_35F5_11D2_B605_00C04FB6F3A1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__44235D9D_35F5_11D2_B605_00C04FB6F3A1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adsutil\adsutil.cpp ===
/***********************************************************************
File: adsutil.cpp
Description: this is the main program for adsutil
***********************************************************************/

#include "clsCommand.h"
#include <shellapi.h>	// CommandLineToArgvW


int __cdecl main(/*int argc,char *argv[]*/)
{	// The reason why the main() function looks so simple goes kinda
	// like this: I've made a class for every command in ADSUTIL, and
	// each has a function for parsing the command line and a function
	// for doing the actual ADSI work. There's a parent class to all of
	// these called clsCommand, which has its own command line parser
	// and executor, just like all the other classes. clsCommand contains
	// an object of each ADSUTIL command class. clsCommand::ParseCommandLine
	// does a bit of initial work, decides which ADSUTIL command has
	// been entered, and passes off to the ParseCommandLine function belonging
	// to the appropriate ADSUTIL command class. The same is done with the
	// Execute function.
	
	int iResult = 0;
	HRESULT hresError = 0;
	clsCommand TheCommand;

	// gets the command line
	char *lpCmdLine = GetCommandLine();

	// Parses the command line
	iResult = TheCommand.ParseCommandLine(lpCmdLine);
	lpCmdLine = NULL;
	if (iResult == 0)
	{	// Initializes COM
		hresError = CoInitialize (NULL);
		if (hresError != ERROR_SUCCESS)
		{	printf("CoInitialize Failed!\n");
			return 1;
		}
		
		// Executes the actual ADSI work
		iResult = TheCommand.Execute();

		// Uninitializes COM
		CoUninitialize();
	}
	return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adsutil\execute.cpp ===
/***********************************************************************
File: execute.cpp
Description: this thing holds all the Execute functions for all the classes

***********************************************************************/


#include "clsCommand.h"
#include  "iiisext.h"
#include <fstream.h>

int clsCommand::Execute()
{	// Common startup code

	HRESULT hresError = 0;
	int iResult = 0;

	// Class selection
	switch (indicator)
	{	case CMD_ENUM:	// ENUM
		{	iResult = objEnum.Execute();
			break;
		}
		case CMD_ENUMALL:	// ENUM_ALL
		{	iResult = objEnum.Execute();
			break;
		}
		case CMD_SET:	// SET
		{	iResult = objSet.Execute();
			break;
		}
		case CMD_CREATE:	// CREATE
		case CMD_CREATEVDIR:	// CREATE_VDIR
		case CMD_CREATEVSERV:	// CREATE_VSERV
		{	iResult = objCreate.Execute();	
			break;
		}
		case CMD_DELETE:	// DELETE
		{	iResult = objDelete.Execute();	
			break;
		}
		case CMD_GET:	// GET
		{	iResult = objGet.Execute();
			break;
		}
		case CMD_COPY:	// COPY
		case CMD_MOVE:	// MOVE
		{	iResult = objCopyMove.Execute(indicator);
			break;
		}
		case CMD_STARTSERVER:	// START_SERVER
		case CMD_STOPSERVER:	// STOP_SERVER
		case CMD_PAUSESERVER:	// PAUSE_SERVER
		case CMD_CONTINUESERVER:	// CONTINUE_SERVER
		{	iResult = objServerCommand.Execute(indicator);
			break;
		}
		case CMD_FIND:	// FIND
		{	iResult = objFind.Execute();	
			break;
		}
		case CMD_APPCREATEINPROC:	// APPCREATEINPROC
		case CMD_APPCREATEOUTPROC:	// APPCREATEOUTPROC
		case CMD_APPDELETE:	// APPDELETE
		case CMD_APPUNLOAD:	// APPUNLOAD
		case CMD_APPGETSTATUS:	// APPGETSTATUS
		{	iResult = objApp.Execute(indicator);	
			break;
		}
		case CMD_HELP:	// HELP
		{	iResult = objHelp.Execute();	
			break;
		}
		case CMD_SCRIPT:	// SCRIPT
		{	iResult = objScript.Execute();
			break;
		}
		case CMD_APPEND:	// APPEND
		{	iResult = objAppend.Execute();
			break;
		}
		case CMD_REMOVE:
		{	iResult = objRemove.Execute();
			break;
		}
		default:
		{	printf("This command is not supported.\n");
			iResult = 1;
			break;
		}
	}

	// Common cleanup code

	return iResult;
}
//************************************************************
// handles all the Application specific functions
int clsAPP::Execute(int TheCommand)
{	HRESULT hresError = 0;
	int iResult = 0;

	BSTR SuccessMsg;
	BSTR FailureMsg;
	DWORD dwStatus = 0;

	IISApp *pApp = NULL;

// Debug
	IDispatch *pDisp = NULL;
	DISPID dispid;
	OLECHAR* olestrFuncName = L"AppGetStatus";

	hresError = ADsGetObject(Path, IID_IDispatch, (void**) &pDisp);
	if (hresError != ERROR_SUCCESS)
	{
		printf ("Could not get the dispatch interface\n");
	}
// End Debug

	hresError = ADsGetObject(Path, IID_IISApp, (void **) &pApp);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
	}
	else
	{	switch (TheCommand)
		{	case CMD_APPCREATEINPROC:	// creates an in process application
				{	hresError = pApp->AppCreate(true);
				SuccessMsg = SysAllocString(L"Application Created.");
				FailureMsg = SysAllocString(L"Error trying to CREATE the application");
				break;
			}
			case CMD_APPCREATEOUTPROC:	// creates an out of process application
			{	hresError = pApp->AppCreate(false);
				SuccessMsg = SysAllocString(L"Application Created.");
				FailureMsg = SysAllocString(L"Error trying to CREATE the application");
				break;
			}
			case CMD_APPDELETE:	// deletes an application
			{	hresError = pApp->AppDelete();
				SuccessMsg = SysAllocString(L"Application Deleted.");
				FailureMsg = SysAllocString(L"Error trying to DELETE the application");
				break;
			}
			case CMD_APPUNLOAD:	// unloads an application
			{	hresError = pApp->AppUnLoad();
				SuccessMsg = SysAllocString(L"Application Unloaded.");
				FailureMsg = SysAllocString(L"Error trying to UNLOAD the application");
				break;
			}
			case CMD_APPGETSTATUS:	// gets the status of an application
			{	hresError = pApp->AppGetStatus(&dwStatus);
				FailureMsg = SysAllocString(L"Error trying to retrieve the application STATUS");

				if (pDisp)
				{
					printf ("\nCalling AppGetStatus using the IDispatchInterface\n");
					hresError = pDisp->GetIDsOfNames (
									IID_NULL,
									&olestrFuncName,
									1,
									GetUserDefaultLCID(),
									&dispid);

					printf ("Result of calling GetIDsOfNames for AppGetStatus: %u (%#x)\n",
								hresError,
								hresError);
					printf ("Disp ID For AppGetStatus: %u\n",
								dispid);

					ULONG ulValue = -1;
					ULONG *pulValue = &ulValue;
					//ULONG *pulValue = NULL;
					VARIANTARG varg;
					VariantInit (&varg);
					varg.vt = VT_BYREF | VT_UI4;
					varg.pulVal = pulValue;

					DISPPARAMS param;
					param.cArgs = 1;
					param.rgvarg = &varg;
					param.cNamedArgs = 0;
					param.rgdispidNamedArgs = NULL;

					VARIANT *pVarResult = NULL;
					EXCEPINFO *pExcepInfo = NULL;
					UINT *puArgErr = NULL;

					printf ("ulValue prior to Invoke: %u (%#x)\n",
							ulValue,
							ulValue);

					hresError = pDisp->Invoke (
								dispid,
								IID_NULL,
								GetUserDefaultLCID(),
								DISPATCH_METHOD,
								&param,
								pVarResult,
								pExcepInfo,
								puArgErr);

					printf ("result of calling Invoke:\n"
							"  hresError: %u (%#x)\n"
							"  pVarResult: %#x\n"
							"  pExcepInfo: %#x\n"
							"  puArgErr: %#x\n",
							hresError, hresError,
							pVarResult,
							pExcepInfo,
							puArgErr);

					printf ("Value of argument pulValue:\n"
							"  pulValue address: %u (%#x)\n"
							"  ulValue address: %u (%#x)\n"
							"  ulValue value: %u (%#x)\n",
							pulValue, pulValue,
							&ulValue, &ulValue,
							ulValue, ulValue);
				}

				break;
			}
		}
		if (hresError == ERROR_SUCCESS)
		{	if (TheCommand == 20)
				printf("Application status: %u\n", dwStatus);
			else
				printf("%S\n", SuccessMsg);
			iResult = 0;
		}
		else
		{	printf("%S: %S\n", FailureMsg, Path);
			iResult = 1;
		}
	}
	pApp->Release();
	SysFreeString(Path);
	return iResult;
}
//************************************************************
// this appends a value to a LIST type property
int clsAPPEND::Execute()
{	int iResult = 0;
	HRESULT hresError = 0;

	BSTR Type;

	VARIANT varOld;		// Holds the array of old values
	VARIANT *OldValues;	// the old values
	
//	BSTR Value;			// Value to append

	VARIANT varNew;		// Holds the array of new values
	SAFEARRAY FAR* NewArray;	// the array of new values
	SAFEARRAYBOUND NewArrayBound[1];
	VARIANT *NewValues = NULL;	// the new values
	NewArrayBound[0].lLbound = 0;

	IADs *pADs = NULL;
	IISBaseObject *pBaseObject = NULL;
	
	hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}
	else
	{	hresError = ADsGetObject(Path, IID_IISBaseObject, (void **) &pBaseObject);
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not get the base object.\n");
			pADs->Release();
			iResult = 1;
			goto xit;
		}
	}
	// You can find IsSet and GetProperty in common.cpp
	if ((IsSet(pBaseObject, Path, Property) == 1))// && (PROP_OK == IsSpecialProperty(Property)))
	{	GetProperty(pADs, Property, &varOld, &Type);
		if (_wcsicmp(Type, L"list"))
		{//	***** Converts from any type to a list, then appends *****
			
			VARIANT varbstr;
			hresError = VariantChangeType(&varbstr, &varOld, 0, VT_BSTR);
			
			// Build the new array
			NewArrayBound[0].cElements = 2;
			NewArray = SafeArrayCreate(VT_VARIANT, 1, NewArrayBound);
			if (NewArray == NULL)
			{	iResult = 1;
				goto xit;
			}
			varNew.vt = VT_ARRAY|VT_VARIANT;
			varNew.parray = NewArray;
			NewValues[0].bstrVal = SysAllocString(varbstr.bstrVal);
			// Put the value to append into the new array
			NewValues[1].bstrVal = SysAllocString(Value);
		}
		else
		{//	***** appends an item to a list *****
			// Build the new array
			NewArrayBound[0].cElements = varOld.parray->rgsabound[0].cElements + 1;
			NewArray = SafeArrayCreate(VT_VARIANT, 1, NewArrayBound);
			if (NewArray == NULL)
			{	iResult = 1;
				goto xit;
			}
			varNew.vt = VT_ARRAY|VT_VARIANT;
			varNew.parray = NewArray;

			// Get a handle on the data for both arrays
			OldValues = (VARIANT*) varOld.parray->pvData;
			NewValues = (VARIANT*) varNew.parray->pvData;

			// Put all the old values into the new array
			for (unsigned long l = 0; l < varOld.parray->rgsabound[0].cElements; l++)
			{	NewValues[l].vt = VT_BSTR;
				NewValues[l].bstrVal = SysAllocString(OldValues[l].bstrVal);
			}
			// Put the value to append into the new array
			NewValues[varOld.parray->rgsabound[0].cElements].bstrVal = SysAllocString(Value);
		}
	}
	else
	{//	***** does a normal SET for an empty property *****
		varNew.vt = VT_BSTR;
		varNew.bstrVal = SysAllocString(Value);
	}

	// Put the new property
	hresError = pADs->Put(Property, varNew);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not set \"%S\" to ", Property);
		PrintVariant(varNew);
		printf("\n");
		iResult = 1;
	}
	else
	{	hresError = pADs->SetInfo();
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not commit changes to the metabase.");
			iResult = 1;
		}
		else
		{	printf("%-32S: (%S) ", Property, Type);
			PrintVariant(varNew);
			printf("\n");
			iResult = 0;
		}
	}
	pBaseObject->Release();
	pADs->Release();
xit:
	SysFreeString(Path);
	SysFreeString(Property);
	SysFreeString(Value);
	return iResult;
}
//************************************************************
// copies/moves an object in the metabase to some other point
// in the same metabase
int clsCOPY_MOVE::Execute(int TheCommand)
{	HRESULT hresError = 0;
	int iResult = 0;

	BSTR SuccessMsg;

	IADsContainer *pADsContainer = NULL;
	IDispatch *pDispatch = NULL;

	// refer to clsCOPY_MOVE::ParseCommand for an explanation
	// of ParentPath, SrcPath, and DstPath.
	hresError = ADsGetObject(ParentPath, IID_IADsContainer, (void **) &pADsContainer);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get the base object");
		iResult = 1;
		goto xit;
	}

	switch (TheCommand)
	{
		case CMD_COPY:	// copies object located at SrcPath to DstPath
		{	hresError = pADsContainer->CopyHere(SrcPath, DstPath, &pDispatch);
			SuccessMsg = SysAllocString(L"Copied");
			break;
		}

		case CMD_MOVE: // moves object located at SrcPath to DstPath
		{	hresError = pADsContainer->MoveHere(SrcPath, DstPath, &pDispatch);
			SuccessMsg = SysAllocString(L"Moved");
			break;
		}
	}// switch TheCommand
	
	if (hresError == ERROR_SUCCESS)
	{	printf("%S from %S to %S\n", SuccessMsg, SrcPath, DstPath);
		pDispatch->Release();
		iResult = 0;
	}
	else
	{	printf("Error %x\n", hresError);
		iResult = 1;
	}
xit:
	pADsContainer->Release();
	SysFreeString(ParentPath);
	SysFreeString(DstPath);
	SysFreeString(SrcPath);
	return iResult;
}
//************************************************************
// this creates just about anything you want
int clsCREATE::Execute()
{	HRESULT hresError = 0;
	int iResult = 0;

	IADsContainer *pADsContainer = NULL;
	IDispatch *pDispatch;
	IADs *pADs = NULL;

	// Gets the container
	hresError = ADsGetObject(Path, IID_IADsContainer, (void **) &pADsContainer);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}

	// Creates the object
	hresError = pADsContainer->Create(Type, Property, &pDispatch);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not create %S\n", Property);
		iResult = 1;
		pADsContainer->Release();
		goto xit;
	}

	// nabs up the Dispatch
	hresError = pDispatch->QueryInterface(IID_IADs, (void **) &pADs);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with QueryInterface.\n");
		iResult = 1;
		pADsContainer->Release();
		pADs->Release();
		goto xit;
	}

	// commits the changes
	hresError = pADs->SetInfo();
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not update the metabase.\n");
		iResult = 1;
		pADsContainer->Release();
		pDispatch->Release();
		pADs->Release();
		goto xit;
	}
	else
	{	printf("created \"%S\"\n", Property);
		iResult = 0;
	}

	pADsContainer->Release();
	pDispatch->Release();
	pADs->Release();
xit:
	SysFreeString(Path);
//	SysFreeString(Property);
	SysFreeString(Type);
	return iResult;
}
//************************************************************
// deletes a path or clears a property in the metabase
int clsDELETE::Execute()
{	HRESULT hresError = 0;
	int iResult = 0;
	DWORD ConvertResult = 0;

	IADs *pADs = NULL;
	IADsContainer *pADsContainer = NULL;

	// this determines if the full path is pointing to a path or a property
	hresError = ADsGetObject(PathProperty, IID_IADs, (void **) &pADs);
	if (hresError != ERROR_SUCCESS)	// Delete a property
	{	hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not open the object with ADsGetObject.\n");
			iResult =  1;
		}
		else
		{	VARIANT vProp;
			VariantInit(&vProp);
			hresError = pADs->PutEx(1, Property, vProp); // 1 = Clear
			if (hresError != ERROR_SUCCESS)
			{	printf("Error deleting the object: %S\n", PathProperty);
				iResult = 1;
			}
			else
			{	printf("deleted property \"%S\"\n", Property);
				iResult = 0;
			}
			VariantClear(&vProp);
		}
	}
	else	// Delete a path
	{	pADs->Release();
		hresError = ADsGetObject(Path, IID_IADsContainer, (void **) &pADsContainer);
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not open the object with ADsGetObject\n");
			iResult = 1;
		}
		else
		{	hresError = pADsContainer->Delete(L"IIsObject", Property);
			if (hresError != ERROR_SUCCESS)
			{	printf("Error deleting the object: %S\n", PathProperty);
				iResult = 1;
			}
			else
			{	printf("deleted path \"%S\"\n", PathProperty);
				iResult = 0;
			}
			pADsContainer->Release();
		}
	}
	SysFreeString(Path);
//	SysFreeString(Property);
	SysFreeString(PathProperty);
	return iResult;
}
//************************************************************
// This enumerates the properties (optional, mandatory, set, or unset)
// within a specified path. Will recurse if ENUM_ALL is used
int clsENUM::Execute()
{	HRESULT hresError = 0;
	int iResult = 0;

	unsigned long l;
	unsigned long NumberReturned = 1;

	IADs *pADs = NULL;
	IADsClass *pADsClass = NULL;
	IISBaseObject *pBaseObject = NULL;
	IDispatch *pDispatch = NULL;
	IEnumVARIANT *pEnumVariant = NULL;
	IADsContainer *pADsContainer = NULL;
	// if the PathOnlyOption is false
	if (PathOnlyOption == false)
	{	// Gets the path as an IADs object
		hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not open the object with ADsGetObject.\n");
			iResult = 1;
			goto xit;
		}
		
		// Nabs up the schema
		BSTR bstrSchema;
		hresError = pADs->get_Schema(&bstrSchema);
		if (hresError != ERROR_SUCCESS)
		{	printf("Couldn't get the schema.\n");
			iResult = 1;
			pADs->Release();
			goto xit;
		}
		// gets the Class from the schema
		hresError = ADsGetObject(bstrSchema, IID_IADsClass, (void **) &pADsClass);
		if (hresError != ERROR_SUCCESS)
		{	printf("Couldn't get the object's schema.\n");
			iResult = 1;
			pADs->Release();
			goto xit;
		}
		// gets the BaseObject from pADs
		hresError = pADs->QueryInterface(IID_IISBaseObject, (void **) &pBaseObject);
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not get the base object.\n");
			iResult = 1;
			pADs->Release();
			pADsClass->Release();
			goto xit;
		}
		// some miscellaneous dumps for stuff i use for one line
		VARIANT varProperties;
		SAFEARRAY *PropertyArray;
		VARIANT *varProperty;
		long LowerBound;
		unsigned long UpperBound;
		BSTR Type;
		VARIANT Value;
		VariantInit(&Value);
	//******** Enumerates the mandatory properties
		VariantInit(&varProperties);
		
		// puts the mandatory properties into a Variant temporarily
		hresError = pADsClass->get_MandatoryProperties(&varProperties);
		if (hresError != ERROR_SUCCESS)
		{	printf("Couldn't get the object's mandatory properties.\n");
		}
		else
		{	// Takes the temporary Variant array and makes it a SafeArray
			PropertyArray = varProperties.parray;
			// Calculates the bounds just for style
			LowerBound = PropertyArray->rgsabound[0].lLbound;
			UpperBound = PropertyArray->rgsabound[0].cElements;
			// Creates the official property array
			varProperty = (VARIANT*) PropertyArray->pvData;
			// for each property

			for (l = LowerBound; l < UpperBound; l++)
			{	if (((IsSet(pBaseObject, Path, varProperty[l].bstrVal) == 1) || (AllDataOption == true)) && (PROP_OK == IsSpecialProperty(varProperty[l].bstrVal)))
				{	GetProperty(pADs, varProperty[l].bstrVal, &Value, &Type);
					printf("%-32S: (%S) ", varProperty[l].bstrVal, Type);
					PrintVariant(Value);
					printf("\n");
				}
			}
		}
		VariantClear(&varProperties);
	//******** and repeat for Optional properties
		VariantInit(&varProperties);
		hresError = pADsClass->get_OptionalProperties(&varProperties);
		if (hresError != ERROR_SUCCESS)
		{	printf("Couldn't get the object's optional properties.\n");
		}
		else
		{	PropertyArray = varProperties.parray;
			LowerBound = PropertyArray->rgsabound[0].lLbound;
			UpperBound = PropertyArray->rgsabound[0].cElements;
			varProperty = (VARIANT*) PropertyArray->pvData;

			for (l = LowerBound; l < UpperBound; l++)
			{
				if (((IsSet(pBaseObject, Path, varProperty[l].bstrVal) == 1) || (AllDataOption == true)) && (PROP_OK == IsSpecialProperty(varProperty[l].bstrVal)))
				{
					GetProperty(pADs, varProperty[l].bstrVal, &Value, &Type);
					printf("%-32S: (%S) ", varProperty[l].bstrVal, Type);
					PrintVariant(Value);
					printf("\n");
				}

			}

			VariantClear(&varProperties);
		}
		pADs->Release();
		pADsClass->Release();
		pBaseObject->Release();
	}	// if !PathOnlyOption
//******** Enumerate the child nodes and recurse if requested

	// Gets the container
	hresError = ADsGetObject(Path, IID_IADsContainer, (void **) &pADsContainer);
	if (hresError != ERROR_SUCCESS)
	{	iResult = 1;
		goto xit;
	}

	// builds the enumerator
	hresError = ADsBuildEnumerator(pADsContainer, &pEnumVariant);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not build the enumerator.\n");
		iResult = 1;
		pADsContainer->Release();
		goto xit;
	}
	
	VARIANT varChildren;
	
	// while ADsEnumerateNext returns child nodes
	while (NumberReturned > 0)
	{	VariantInit(&varChildren);
		
		// get some child nodes
		hresError = ADsEnumerateNext(pEnumVariant, 1, &varChildren, &NumberReturned);
		if (hresError == ERROR_SUCCESS)
		{
			// for each child node returned
			for (l = 0; l < NumberReturned; l++)
			{	
				// gets the IDispatch equivalent of the child node
				pDispatch = varChildren.pdispVal;

				// gets the IADs equivalent of the child node
				hresError = pDispatch->QueryInterface(IID_IADs, (void **) &pADs);
				if (hresError != ERROR_SUCCESS)
				{	printf("Could not open the object with QueryInterface.\n");
					iResult = 1;
					pDispatch->Release();
					goto xit;
				}

				// gets the path string from the child node
				// and assigns it to the Path data member of clsENUM
				hresError = pADs->get_ADsPath(&Path);
				if (hresError != ERROR_SUCCESS)
				{	printf("Could not get ADsPath.\n");
					iResult = 1;
					goto xit;
				}

				// print out the child node's path
				printf("[%S]\n", wcschr(Path + 7, '/'));

				// if the command was ENUM_ALL then
				if (Recurse == true)
				{	iResult = Execute(); // calls itself, Path has already been modified
				}

				// more cleanup
				pADs->Release();
				pDispatch->Release();

			}// for l

		}// if hreserror

	}// while numberreturned

	pADsContainer->Release();
	pEnumVariant->Release();
xit:
	SysFreeString(Path);
	return iResult;
}
//************************************************************
// The user specifies a property within a path, and all child paths
// that have the same property set are returned. If the property
// in a path does not exist or is not set, then it's skipped.
int clsFIND::Execute()
{	HRESULT hresError;
	int iResult = 0;

	VARIANT pvPaths;
	IISBaseObject *pBaseObject = NULL;
	SAFEARRAY *PathArray;
	VARIANT *varPath;
	unsigned long l;

	hresError = ADsGetObject(Path, IID_IISBaseObject, (void **) &pBaseObject);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get the base object");
		iResult = 1;
		goto xit;
	}

	VariantInit(&pvPaths);
	hresError = pBaseObject->GetDataPaths(Property, 0, &pvPaths);
	if (hresError == ERROR_SUCCESS)
	{	printf("Property %S was found at:\n", Property);
		PathArray = pvPaths.parray;
		varPath = (VARIANT*) PathArray->pvData;
		for (l = 0; l < PathArray->rgsabound[0].cElements; l++)
		{	printf("  %S\n", varPath[l].bstrVal);
		}
		iResult = 0;
	}
	else
	{	VariantClear(&pvPaths);
		VariantInit(&pvPaths);
		hresError = pBaseObject->GetDataPaths(Property, 1, &pvPaths);
		if (hresError == ERROR_SUCCESS)
		{	printf("Property %S was found at:\n", Property);
			PathArray = pvPaths.parray;
			varPath = (VARIANT*) PathArray->pvData;
			for (l = 0; l < PathArray->rgsabound[0].cElements; l++)
			{	printf("  %S\n", varPath[l].bstrVal);
			}
			iResult = 0;
		}
		else
		{	printf("Error trying to get a path list (GetDataPaths Failed): %S\n", Path);
			iResult = 1;
		}
	}
xit:
	VariantClear(&pvPaths);
	pBaseObject->Release();
	SysFreeString(Path);
	SysFreeString(Property);
	return iResult;
}
//************************************************************
// Gets the value of a specified property in a specified path
int clsGET::Execute()
{	int iResult = 0;
	BSTR Type;
	VARIANT Value;

	// Get the object specified by adspath
	IADs *pADs = NULL;
	HRESULT hresError = 0;
	IISBaseObject *pBaseObject = NULL;

	hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}

	hresError = ADsGetObject(Path, IID_IISBaseObject, (void **) &pBaseObject);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get the base object.\n");
		iResult = 1;
		pADs->Release();
		goto xit;
	}
	// You can find IsSet and GetProperty in common.cpp
	if ((IsSet(pBaseObject, Path, Property) == 1))// && (PROP_OK == IsSpecialProperty(Property)))
	{	GetProperty(pADs, Property, &Value, &Type);
		printf("%-32S: (%S) ", Property, Type);
		PrintVariant(Value);
		printf("\n");
		VariantClear(&Value);
		SysFreeString(Type);
	}
	else
	{	printf("The property \"%S\" is not set at this node.\n", Property);
	}

	pBaseObject->Release();
	pADs->Release();
xit:
	SysFreeString(Path);
//	SysFreeString(Property);
	return iResult;
}
//************************************************************
int clsHELP::Execute()
{	printf("\n");
	printf("Usage:\n");
	printf("      ADSUTIL.EXE [-s:<server>] <cmd> [<path> [<value>]]\n");
	printf("Description:\n");
	printf("IIS K2 administration utility that enables the manipulation of the metabase with ADSI parameters.\n");
	printf(" adsutil.exe GET    path                   - display chosen parameter\n");
	printf(" adsutil.exe DELETE path                   - delete given path or property\n");
	printf(" adsutil.exe SET    path value ...         - assign the new value\n");
	printf(" adsutil.exe CREATE path [KeyType]         - create given path and assigns it to the given KeyType\n");
	printf(" adsutil.exe ENUM   path [\"/P\" | \"/A\"] - enumerate all properties for given path\n");
	printf("\n");
	printf(" adsutil.exe APPCREATEINPROC  w3svc/1/root - Create an in-proc application\n");
	printf(" adsutil.exe APPCREATEOUTPROC w3svc/1/root - Create an in-proc application\n");
	printf(" adsutil.exe APPDELETE        w3svc/1/root - Delete the application if there is one\n");
	printf(" adsutil.exe APPUNLOAD        w3svc/1/root - Unload an application from w3svc runtime lookup table.\n");
	printf(" adsutil.exe APPGETSTATUS     w3svc/1/root - Get the status of the application\n");
	printf("\n");
	printf("Extended ADSUTIL Commands:\n");
	printf(" adsutil.exe APPEND          path value - Append a value to a LIST type property\n");
	printf(" adsutil.exe REMOVE          path value - Remove a value from a LIST type property\n");
	printf(" adsutil.exe FIND            path - find the paths where the given property is set\n");
	printf(" adsutil.exe CREATE_VDIR     path - create given path as a Virtual Directory\n");
	printf(" adsutil.exe CREATE_VSERV    path - create given path as a Virtual Server\n");
	printf(" adsutil.exe START_SERVER    path - starts the given web site\n");
	printf(" adsutil.exe STOP_SERVER     path - stops the given web site\n");
	printf(" adsutil.exe PAUSE_SERVER    path - pauses the given web site\n");
	printf(" adsutil.exe CONTINUE_SERVER path - continues the given web site\n");
	printf(" adsutil.exe ENUM_ALL        path [\"/P\" | \"/A\"] - enumerate all properties for the given path and all subpaths\n");
	printf(" adsutil.exe SCRIPT          file - reads given file as a script\n");
	printf("\n");
	printf("\n");
	printf("Samples\n");
	printf("  adsutil.exe GET W3SVC/1/ServerBindings\n");
	printf("  adsutil.exe SET W3SVC/1/ServerBindings \":81:\"\n");
	printf("  adsutil.exe CREATE W3SVC/1/Root/MyVdir \"IIsWebVirtualDir\"\n");
	printf("  adsutil.exe START_SERVER W3SVC/1\n");
	printf("  adsutil.exe ENUM W3SVC /P \n");
	printf("  adsutil.exe ENUM W3SVC /A \n");
	printf("  adsutil.exe -s:MyServer GET w3svc/1/ServerComment\n");
	printf("  adsutil.exe SCRIPT C:\"myscript.txt \n");
	return 0;
}
//************************************************************
// this removes an item from a LIST type property
int clsREMOVE::Execute()
{	int iResult = 0;
	HRESULT hresError = 0;

	BSTR Type;

	VARIANT varOld;		// Holds the array of old values
	VARIANT *OldValues;	// the old values
	
//	BSTR Value;			// Value to append

	VARIANT varNew;		// Holds the array of new values
	SAFEARRAY FAR* NewArray;	// the array of new values
	SAFEARRAYBOUND NewArrayBound[1];
	VARIANT *NewValues;	// the new values
	NewArrayBound[0].lLbound = 0;

	IADs *pADs = NULL;
	IISBaseObject *pBaseObject = NULL;

	hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}

	hresError = ADsGetObject(Path, IID_IISBaseObject, (void **) &pBaseObject);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get the base object.\n");
		iResult = 1;
		goto xit;
	}

	// You can find IsSet and GetProperty in common.cpp
	if ((IsSet(pBaseObject, Path, Property) == 1))// && (PROP_OK == IsSpecialProperty(Property)))
	{	GetProperty(pADs, Property, &varOld, &Type);
		if (_wcsicmp(Type, L"list"))
		{//	***** Does a normal DELETE *****
		}
		else
		{//	***** appends an item to a list *****
			// Build the new array
			NewArrayBound[0].cElements = varOld.parray->rgsabound[0].cElements - 1;
			NewArray = SafeArrayCreate(VT_VARIANT, 1, NewArrayBound);
			if (NewArray == NULL)
			{
				iResult = 1;
				goto xit;
			}
			varNew.vt = VT_ARRAY|VT_VARIANT;
			varNew.parray = NewArray;

			// Get a handle on the data for both arrays
			OldValues = (VARIANT*) varOld.parray->pvData;
			NewValues = (VARIANT*) varNew.parray->pvData;

			// Put all the old values into the new array
			int skip = 0;
			for (unsigned long l = 0; l < varOld.parray->rgsabound[0].cElements; l++)
			{	if (_wcsicmp(OldValues[l].bstrVal, Value))
				{	NewValues[l - skip].vt = VT_BSTR;
					NewValues[l - skip].bstrVal = SysAllocString(OldValues[l].bstrVal);
				}
				else
				{	skip++;
				}
			}
		}
	}
	else
	{	printf("Property \"%S\" is not set at this node.\n", Property);
		iResult = 1;
		goto xit;
	}

	// Put the new property
	hresError = pADs->Put(Property, varNew);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not set \"%S\" to ", Property);
		PrintVariant(varNew);
		printf("\n");
		iResult = 1;
	}
	else
	{	hresError = pADs->SetInfo();
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not commit changes to the metabase.");
			iResult = 1;
		}
		else
		{	printf("%-32S: (%S) ", Property, Type);
			PrintVariant(varNew);
			printf("\n");
			iResult = 0;
		}
	}
xit:
	pADs->Release();
	pBaseObject->Release();
	SysFreeString(Path);
	SysFreeString(Property);
	SysFreeString(Value);
	return iResult;
}
//************************************************************
// This reads the specified text file, executing each line
// as an ADSUTIL command line. Looks a lot like main()
int clsSCRIPT::Execute()
{	int iResult = 0;
	clsCommand *ScriptCommand = new clsCommand();
	char *NewLine = NULL;
	int LineLength = 480;
	char *CurrentLine = new char[LineLength];

	// Open the script file if it exists
	ifstream *fin = new ifstream(FileName, ios::nocreate, filebuf::openprot);
	if (NULL == fin)
	{	printf("Could not open %S\n", FileName);
		iResult = 1;
		goto xit;
	}

	fin->getline(CurrentLine, LineLength);

	// while not end of file
	while (!fin->eof())
	{	// append "adsutil " to the beginning of each line
		// this acts as the first parameter in a normal
		// command line
		NewLine = new char[strlen(CurrentLine) + 9];
		strcpy(NewLine, "adsutil ");
		strcpy(NewLine + strlen(NewLine), CurrentLine);
//		printf("\n");
//		printf(NewLine);
//		printf("\n");
		// the usual ParseCommandLine and Execute
		iResult = ScriptCommand->ParseCommandLine(NewLine);
		delete[] NewLine;
		if ((0 == iResult) && (ScriptCommand->GetIndicator() != CMD_HELP))
		{	iResult = ScriptCommand->Execute();
		}
		// Read the next line
		delete[] CurrentLine;
		CurrentLine = new char[LineLength];
		fin->getline(CurrentLine, LineLength, '\n');
		CurrentLine[strlen(CurrentLine)] =  '\0';
	}
	fin->close();
	delete[] CurrentLine;
	delete ScriptCommand;
xit:
	return iResult;
}
//************************************************************
// This thing handles the starting, stopping, pausing, and continuation of servers
int clsSERVER_COMMAND::Execute(int TheCommand)
{	char *SuccessMsg;
	char *ErrorMsg;

	HRESULT hresError = 0;
	int iResult = 0;
	int iExitCode = 0;
	DWORD ConvertResult = 0;

	IADsServiceOperations *pADs = NULL;

	// Get the object specified by adspath
	hresError = ADsGetObject(Path, IID_IADsServiceOperations, (void **) &pADs);

	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}

	// remind me to change TheCommand from a function argument to a data member
	switch (TheCommand)
	{	case CMD_STARTSERVER:	// START_SERVER
		{	SuccessMsg = "Server successfully started.";
			ErrorMsg = "Error trying to start the server.";
			hresError = pADs->Start();
			break;
		}
		case CMD_STOPSERVER:	// STOP_SERVER
		{	SuccessMsg = "Server successfully stopped.";
			ErrorMsg = "Error trying to stop the server.";
			hresError = pADs->Stop();
			break;
		}
		case CMD_PAUSESERVER:	// PAUSE_SERVER
		{	SuccessMsg = "Server successfully paused.";
			ErrorMsg = "Error trying to pause the server.";
			hresError = pADs->Pause();
			break;
		}
		case CMD_CONTINUESERVER:	// CONTINUE_SERVER
		{	SuccessMsg = "Server successfully continued.";
			ErrorMsg = "Error trying to continue the server.";
			hresError = pADs->Continue();
			break;
		}
	}

	if (hresError != ERROR_SUCCESS)
	{	printf(ErrorMsg);
		printf("\n");
		iResult = 1;
	}
	else
	{	printf(SuccessMsg);
		printf("\n");
		iResult = 0;
	}
xit:
	SysFreeString(Path);
	pADs->Release();

	return iResult;
}
//************************************************************
// this sets a property
int clsSET::Execute()
{	HRESULT hresError = 0;
	int iResult = 0;

	BSTR Type;
	IADs *pADs = NULL;

	VARIANT varValues;
	VariantInit(&varValues);
	if (PROP_OK != IsSpecialProperty(Property))
	{	printf("%S can not be set at this time.\n", Property);
		iResult = 1;
		goto xit;
	}
	// Builds the Variant of value(s) needed for the Put function
	if (1 == ValueCount)
	{	varValues.vt = VT_BSTR;
		varValues.bstrVal = SysAllocString(Values[0]);
		Type = SysAllocString(L"STRING");
	}
	else
	{	SAFEARRAY FAR* psa;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = ValueCount;

		psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
		if (psa == NULL)
		{	iResult = 1;
			goto xit;
		}
		
		varValues.vt = VT_ARRAY|VT_VARIANT;
		varValues.parray = psa;

		VARIANT *varValueArray;
		varValueArray = (VARIANT*) varValues.parray->pvData;
		for (int i = 0; i < ValueCount; i++)
		{	varValueArray[i].vt = VT_BSTR;
			varValueArray[i].bstrVal = SysAllocString(Values[i]);
		}
		Type = SysAllocString(L"LIST");
	}

	// Get the object specified by adspath
	hresError = ADsGetObject(Path, IID_IADs, (void **) &pADs);

	if (hresError != ERROR_SUCCESS)
	{	printf("Could not open the object with ADsGetObject.\n");
		iResult = 1;
		goto xit;
	}

	hresError = pADs->Put(Property, varValues);

	if (hresError != ERROR_SUCCESS)
	{	printf("Could not set \"%S\" to ", Property);
		PrintVariant(varValues);
		printf("\n");
		iResult = 1;
	}
	else
	{	hresError = pADs->SetInfo();
		if (hresError != ERROR_SUCCESS)
		{	printf("Could not commit changes to the metabase.");
			iResult = 1;
		}
		else
		{	printf("%-32S: (%S) ", Property, Type);
			PrintVariant(varValues);
			printf("\n");
			iResult = 0;
		}
	}
	pADs->Release();
xit:
	VariantClear(&varValues);
	SysFreeString(Path);
//	SysFreeString(Property);
	delete Values;
	return iResult;
}
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adsutil\parsecommand.cpp ===
/***********************************************************************
File: parsecommand.cpp
does all the command line parsing
***********************************************************************/

#include "clsCommand.h"

#include <shellapi.h>

//*************************************************
int clsCommand::ParseCommandLine(char *lpCmdLine)
{	int iResult = 0;
	//*************************
	// Convert the command line to a WCHAR array
	WCHAR **args;	// holds the command line array
	int argc = 0;	// command line parameter count
	DWORD ConvertResult = 0;
	clsServer *TargetServer = new clsServer();
	WCHAR *wcsTemp;
	wcsTemp = (WCHAR*) HeapAlloc (GetProcessHeap(), 0, sizeof (WCHAR) * (strlen(lpCmdLine)+ 1));
	if (wcsTemp == NULL)
	{	printf("Failed to allocate memory for argw\n");
		return 1;
	}	
	ConvertResult = MultiByteToWideChar(CP_ACP, 0, lpCmdLine, strlen (lpCmdLine) + 1, wcsTemp, strlen (lpCmdLine) + 1);
	if (!ConvertResult)
	{	printf("Unicode path conversion failed.\n");
		HeapFree(GetProcessHeap(), 0, wcsTemp);
		return 1;
	}
	args = CommandLineToArgvW(wcsTemp, &argc);
	//***************************
	// Convert the WCHAR array to a BSTR array
	BSTR *argw = new BSTR[argc];

	
	int skip = 0;
	int OldArgC = argc;
	for (int i = 0; i < OldArgC; i++)
	{	// if this parameter starts with -s: then
		if (!_wcsnicmp(args[i], L"-s:",3))
		{	BSTR NewName = SysAllocString(args[i] + 3);	
			TargetServer->SetName(NewName);
			skip++;
			argc--;
		}
		//  insert more reasons to skip parameters here
		else
		{	argw[i - skip] = SysAllocString(args[i]);
		}
	}
	//**************************
	// Prefixing the path parameters with IIS:// and the machine name
	switch (argc)
	{	case 1:
		{	argw[1] = SysAllocString(L"HELP");
			break;
		}
		case 2:
		{	break;
		}
		default:
		{	if (_wcsicmp(argw[1], L"script"))
			{	TargetServer->CompletePath(&argw[2]);
			}
		}
	}

	//****************************************************
	// Decides which command was entered and calls the appropriate ParseCommandLine routine
	if (!_wcsicmp(argw[1], L"enum"))
	{	indicator = CMD_ENUM;
		objEnum.Recurse = false;
		objEnum.TargetServer = TargetServer;
		iResult = objEnum.ParseCommandLine(argc, argw);
	}
	else if ((!_wcsicmp(argw[1], L"enumall")) || (!_wcsicmp(argw[1], L"enum_all")))
	{	indicator = CMD_ENUMALL;
		objEnum.Recurse = true;
		objEnum.TargetServer = TargetServer;
		iResult = objEnum.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"set"))
	{	indicator = CMD_SET;
		iResult = objSet.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"create"))
	{	indicator = CMD_CREATE;
		iResult = objCreate.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"create_vdir"))
	{	indicator = CMD_CREATEVDIR;
		argw[3] = SysAllocString(L"IIsWebVirtualDir");
		iResult = objCreate.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"create_vserv"))
	{	indicator = CMD_CREATEVSERV;
		argw[3] = SysAllocString(L"IIsWebServer");
		iResult = objCreate.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"delete"))
	{	indicator = CMD_DELETE;
		iResult = objDelete.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"get"))
	{	indicator = CMD_GET;
		iResult = objGet.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"copy"))
	{	TargetServer->CompletePath(&argw[3]);
		iResult = objCopyMove.ParseCommandLine(argc, argw);
		indicator = CMD_COPY;
	}
	else if (!_wcsicmp(argw[1], L"move"))
	{	TargetServer->CompletePath(&argw[3]);
		iResult = objCopyMove.ParseCommandLine(argc, argw);
		indicator = CMD_MOVE;
	}
	else if ((!_wcsicmp(argw[1], L"start_server")) || (!_wcsicmp(argw[1], L"startserver")))
	{	indicator = CMD_STARTSERVER;
		iResult = objServerCommand.ParseCommandLine(argc, argw);
	}
	else if ((!_wcsicmp(argw[1], L"stop_server")) || (!_wcsicmp(argw[1], L"stopserver")))
	{	indicator = CMD_STOPSERVER;
		iResult = objServerCommand.ParseCommandLine(argc, argw);
	}
	else if ((!_wcsicmp(argw[1], L"pause_server")) || (!_wcsicmp(argw[1], L"pauseserver")))
	{	indicator = CMD_PAUSESERVER;
		iResult = objServerCommand.ParseCommandLine(argc, argw);
	}
	else if ((!_wcsicmp(argw[1], L"continue_server")) || (!_wcsicmp(argw[1], L"continueserver")))
	{	indicator = CMD_CONTINUESERVER;
		iResult = objServerCommand.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"find"))
	{	indicator = CMD_FIND;
		iResult = objFind.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"appcreateinproc"))
	{	indicator = CMD_APPCREATEINPROC;
		iResult = objApp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"appcreateoutproc"))
	{	indicator = CMD_APPCREATEOUTPROC;
		iResult = objApp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"appdelete"))
	{	indicator = CMD_APPDELETE;
		iResult = objApp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"appunload"))
	{	indicator = CMD_APPUNLOAD;
		iResult = objApp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"appgetstatus"))
	{	indicator = CMD_APPGETSTATUS;
		iResult = objApp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"help"))
	{	indicator = CMD_HELP;
		iResult = objHelp.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"script"))
	{	indicator = CMD_SCRIPT;
		iResult = objScript.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"append"))
	{	indicator = CMD_APPEND;
		iResult = objAppend.ParseCommandLine(argc, argw);
	}
	else if (!_wcsicmp(argw[1], L"remove"))
	{	indicator = CMD_REMOVE;
		iResult = objRemove.ParseCommandLine(argc, argw);
	}
	else
	{	indicator = CMD_NOTSUPPORTED;
		printf("Sorry, but %S is not supported.\n", argw[1]);
		return 1;
	}

	return iResult;
}
//*************************************************
int clsAPP::ParseCommandLine(int argc,BSTR args[])
{	switch (argc)
	{	case 2:
		{	printf("Proper syntax: APPCREATEINPROC|APPCREATEOUTPROC|APPDELETE|APPUNLOAD|APPGETSTATUS Path\n");
			return 1;
			break;
		}
		case 3:	// Path
		default:
		{	Path = args[2];
			break;
		}
	}
	return 0;
}
//*************************************************
int clsAPPEND::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		case 3:
		{	printf("Proper syntax: APPEND Path Value\n");
			iResult = 1;
			break;
		}
		case 4:	// Path and Value
		default:	// This equates to 4 or more
		{	// No way to distinguish the path from the value
			iResult = IsProperty(args[2], &Path, &Property);
			Value = SysAllocString(args[3]);
			iResult = 0;
			break;
		}
	}
	return iResult;
}
//*************************************************
int clsCOPY_MOVE::ParseCommandLine(int argc,BSTR args[])
{	int iResult	= 0;
	switch (argc)
	{	case 2:
		case 3:
		{	printf("Proper syntax: COPY|MOVE Source Destination\n");
			return 1;
			break;
		}
		case 4:	// SrcPath and DstPath
		default:
		{	// here's where it gets really complicated. the CopyHere and 
			// MoveHere functions (execute.cpp) require three paths:
			// Source:	This is the path to the object you're copying
			// Desitnation:	This is the path to the place you want to copy
			//				the Souce object to.
			// Parent:	This is the most immediately common parent to
			//			both the Source and the Destination. For example,
			//			the Parent path of "IIS://localhost/w3svc/1/Root/vdira"
			//			and "IIS://localhost/w3svc/2/Root/vdirb" is
			//			"IIS://localhost/w3svc". The leftovers of both paths
			//			after the Parent is extracted becomes the Source
			//			("w3svc/1/Root/vdira") and the Destination
			//			("w3svc/1/Root/vdirb")
			
			unsigned int i;

			// stores the breakoff point between
			// the Parent and the Souce/Destination
			unsigned int fee;

			if ((wcslen(args[2])) <= (wcslen(args[3])))
			{	for (i = 1; i <= wcslen(args[2]); i++)
				{	if (!_wcsnicmp(args[2], args[3], i))
					{	if (args[2][i] == '/')
							fee = i;
					}	
					else 
					{	break;
					}
				}
			}
			else
			{	for (i = 1; i <= wcslen(args[3]); i++)
				{	if (!_wcsnicmp(args[2], args[3], i))
					{	if (args[3][i] == '/')
							fee = i;
					}
					else
					{	break;
					}
				}
			}
			args[2][fee] = '\0'; // breaks the Parent off
			ParentPath = SysAllocString(args[2]);
			SrcPath = SysAllocString(args[2] + fee + 1);
			DstPath = SysAllocString(args[3] + fee + 1);
			break;
		}
	}
	return iResult;
}
//*************************************************
int clsCREATE::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		{	printf("Proper syntax: CREATE Path [Type]\n");
			return 1;
			break;
		}
		case 3:
		{	iResult = IsProperty(args[2], &Path, &Property);
			Type = L"IIsObject";
			break;
		}
		case 4:
		default:
		{	iResult = IsProperty(args[2], &Path, &Property);
			Type = args[3];
			break;
		}
	}
	return 0;
}
//*************************************************
int clsDELETE::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		{	printf("Proper syntax: DELETE Path\n");
			return 1;
			break;
		}
		case 3:	// Path
		default:
		{	PathProperty = args[2];
			iResult = IsProperty(PathProperty, &Path, &Property);
			break;
		}
	}
	return iResult;
}
//*************************************************
int clsENUM::ParseCommandLine(int argc,BSTR args[])
{	switch (argc)
	{	case 2:
		{	Path = SysAllocString(L"");
			TargetServer->CompletePath(&Path);
			PathOnlyOption = false;
			AllDataOption = false;
			break;
		}
		case 3: // Path or /P or /A
		{	Path = SysAllocString(args[2]);
			PathOnlyOption = false;
			AllDataOption = false;
			break;
		}
		case 4:	// Path and (/P or /A)
		{	if (!wcscmp(_wcsupr(args[2]),L"/P"))
			{	printf("the Path parameter must follow the Command\n");
				break;
			}	// case "/P"
			else if (!wcscmp(_wcsupr(args[2]),L"/A"))
			{	printf("the Path parameter must follow the Command\n");
			}	// case "/A"
			else
			{	Path = SysAllocString(args[2]);
				if (!wcscmp(_wcsupr(args[3]),L"/P"))
				{	PathOnlyOption = true;
					AllDataOption = false;
					break;
				}	// case "/P"
				else if (!wcscmp(_wcsupr(args[3]),L"/A"))
				{	PathOnlyOption = false;
					AllDataOption = true;
				}	// case "/A"
			}	// case else
			break;
		}
		default:	// no parameters
		{	printf("Syntax: ENUM|ENUM_ALL Path [/A|/P]");
			return 1;
			break;
		}
	}	// switch (argc)
	return 0;
}
//*************************************************
int clsFIND::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		{	printf("Proper syntax: FIND Path\n");
			return 1;
			break;
		}
		case 3:	// Path
		default:
		{	iResult = IsProperty(args[2], &Path, &Property);
			Found = false;
			break;
		}
	}
	return iResult;
}
//*************************************************
int clsGET::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		{	printf("Proper syntax: GET Path\n");
			return 1;
			break;
		}
		case 3:	// Path
		default:
		{	iResult = IsProperty(args[2], &Path, &Property);
 			break;
		}
	}
	return iResult;
}
//*************************************************
int clsHELP::ParseCommandLine(int argc,BSTR args[])
{	return 0;
}
//*************************************************
int clsREMOVE::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		case 3:
		{	printf("Proper syntax: REMOVE Path Value\n");
			iResult = 1;
			break;
		}
		case 4:	// Path and Value
		default:	// This equates to 4 or more
		{	// No way to distinguish the path from the value
			iResult = IsProperty(args[2], &Path, &Property);
			Value = SysAllocString(args[3]);
			iResult = 0;
			break;
		}
	}
	return iResult;
}
//*************************************************
int clsSCRIPT::ParseCommandLine(int argc, BSTR args[])
{	switch (argc)
	{	case 3:
		{	HRESULT hresError = 0;
			FileName = new char[wcslen(args[2])];
			hresError = WideCharToMultiByte(
				CP_ACP, 
				0, 
				args[2], 
				wcslen(args[2]) + 1, 
				FileName, 
				wcslen(args[2]) + 1,
				0,
				0);
			break;
		}
		default:
		{	printf("Proper syntax: SCRIPT File\n");
			return 1;
			break;
		}
	}

	return 0;
}
//*************************************************
int clsSERVER_COMMAND::ParseCommandLine(int argc,BSTR args[])
{	switch (argc)
	{	case 2:
		{	printf("Proper syntax: STARTSERVER|STOPSERVER|PAUSESERVER|CONTINUESERVER Path\n");
			return 1;
			break;
		}
		case 3:	// Path
		default:
		{	Path = args[2];
			break;
		}
	}
	return 0;
}
//*************************************************
int clsSET::ParseCommandLine(int argc,BSTR args[])
{	int iResult = 0;
	switch (argc)
	{	case 2:
		case 3:
		{	printf("Proper syntax: SET Path Value\n");
			iResult = 1;
			break;
		}
		case 4:	// Path and Value
		default:	// This equates to 4 or more
		{	// No way to distinguish the path from the value
			iResult = IsProperty(args[2], &Path, &Property);
			ValueCount = argc - 3;
			Values = new BSTR[ValueCount];
			for (int i = 3; i < argc; i++)
			{	Values[i - 3] = SysAllocString(args[i]);
			}
			iResult = 0;
			break;
		}
	}
	return iResult;
}
//*************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adsutil\common.cpp ===
/***********************************************************************
File: common.cpp
Description: this is where all the global functions go.
***********************************************************************/

#include "clsCommand.h"


// Separates the property from the path
int IsProperty(BSTR FullPath, BSTR *AbsolutePath, BSTR *Property)
{
	WCHAR *pdest; // temp pointer to the last slash in the string
	DWORD dwSizeOfFullPath;

	dwSizeOfFullPath = wcslen (FullPath);

	*AbsolutePath = SysAllocString(FullPath);

	// trim a trailing slash if it exists.
	if ((*AbsolutePath)[dwSizeOfFullPath] == '/')
		(*AbsolutePath)[dwSizeOfFullPath] = '\0'; 


	pdest = wcsrchr(*AbsolutePath, '/');

	// Check to see if a '/' actually exists - if not there is a SERIOUS error
	if (pdest == NULL)
	{	printf ("FATAL ERROR: No slash found in the full path\n");
		return 1;
	}
	else
	{	*Property = pdest + 1; // +1 skips the slash and copies from then on.
		*pdest = L'\0'; // terminate the Absolute path
	}

	return 0;
}
// Checks to see if a Property is actually set or just has a default value
/*
	// if you want to use this function, add this code
	IISBaseObject *pBaseObject = NULL;
	hresError = ADsGetObject(Path, IID_IISBaseObject, (void **) &pBaseObject);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get the base object\n");
		return 1;
	}
*/
int IsSet(IISBaseObject *pBaseObject, BSTR Path, BSTR Property)
{	// 0 = Not set
	// 1 = set

	HRESULT hresError = 0;
	int iResult = 0;
	SAFEARRAY *PathArray;
	VARIANT *varPath;

	VARIANT pvPaths;
	VariantInit(&pvPaths);
	hresError = pBaseObject->GetDataPaths(Property, 0, &pvPaths);
	if (hresError == ERROR_SUCCESS)
	{	PathArray = pvPaths.parray;
		varPath = (VARIANT*) PathArray->pvData;
		if (varPath->vt == VT_BSTR)
		{	if (!_wcsicmp(varPath->bstrVal, Path))
			{	iResult = 1;
			}
		}
	}
	else
	{	VariantClear(&pvPaths);
		VariantInit(&pvPaths);
		hresError = pBaseObject->GetDataPaths(Property, 1, &pvPaths);
		if (hresError == ERROR_SUCCESS)
		{	PathArray = pvPaths.parray;
			varPath = (VARIANT*) PathArray->pvData;
			if (varPath->vt == VT_BSTR)
			{	if (!_wcsicmp(varPath->bstrVal, Path))
				{	iResult = 1;
				}
			}
		}
	}
	VariantClear(&pvPaths);
	VariantClear(varPath);
	return iResult;
}

int IsSpecialProperty(BSTR bstrProperty)
{	int iResult = PROP_OK;
	if	((!_wcsicmp(bstrProperty, L"mimemap")) ||
		(!_wcsicmp(bstrProperty, L"set")) ||
		(!_wcsicmp(bstrProperty, L"servercommand")) ||
		(!_wcsicmp(bstrProperty, L"accessperm")) ||
		(!_wcsicmp(bstrProperty, L"set")) ||
		(!_wcsicmp(bstrProperty, L"vrpath")) ||
		(!_wcsicmp(bstrProperty, L"authorization")))
	{	iResult = PROP_SKIP;
	}
	else
	{	iResult = PROP_OK;
	}
	return iResult;
}

// Does some of the grunt work for getting the value of a property
void GetProperty(IADs *pADs, BSTR bstrProperty, VARIANT *varValue, BSTR *bstrType)
{	HRESULT hresError = 0;
//	IADs *pADs = NULL;
	VARIANT varTempValue;
	VariantInit(&varTempValue);


	hresError = pADs->Get(bstrProperty, &varTempValue);
	if (hresError != ERROR_SUCCESS)
	{	printf("Could not get %S\n", bstrProperty);
		return;
	}
	else
	{	switch (varTempValue.vt)
		{	case VT_EMPTY:
			{	*bstrType = SysAllocString(L"EMPTY");
				break;
			}
			case VT_NULL:
			{	*bstrType = SysAllocString(L"NULL");
				break;
			}
			case VT_I4:
			{	*bstrType = SysAllocString(L"INTEGER");
				hresError = VariantChangeType(varValue, &varTempValue, 0, VT_BSTR);
			break;
				}
			case VT_BSTR:
			{	*bstrType = SysAllocString(L"STRING");
				*varValue = varTempValue;
				break;
			}
			case VT_BOOL:
			{	*bstrType = SysAllocString(L"BOOLEAN");
				if (varTempValue.boolVal == 0)
				{	varValue->vt = VT_BSTR;
					varValue->bstrVal = SysAllocString(L"False");
				}
				else
				{	varValue->vt = VT_BSTR;
					varValue->bstrVal = SysAllocString(L"True");
				}
				break;
			}
			case VT_ARRAY|VT_VARIANT:	// SafeArray of Variants
			{	
				
				*varValue = varTempValue;
				*bstrType = SysAllocString(L"LIST");
				break;
			}
			case VT_DISPATCH:
			{	if (!_wcsicmp(bstrProperty, L"ipsecurity"))
				{	SAFEARRAY FAR* psa;
					SAFEARRAYBOUND rgsabound[1];
					rgsabound[0].lLbound = 0;
					rgsabound[0].cElements = 5;

					psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
					if (psa == NULL)
					{	goto xit;
					}
					
					varValue->vt = VT_ARRAY|VT_VARIANT;
					varValue->parray = psa;

					VARIANT *varValueArray;
					varValueArray = (VARIANT*) varValue->parray->pvData;
					// Set the values
					IISIPSecurity *pIPSecurity = NULL;
					hresError = varTempValue.pdispVal->QueryInterface(IID_IISIPSecurity, (void **) &pIPSecurity);
					if (hresError != ERROR_SUCCESS)
					{	goto xit;
					}
					hresError = pIPSecurity->get_IPDeny(&varValueArray[0]);
					hresError = pIPSecurity->get_IPGrant(&varValueArray[1]);
					hresError = pIPSecurity->get_DomainDeny(&varValueArray[2]);
					hresError = pIPSecurity->get_DomainGrant(&varValueArray[3]);
					short GrantByDefault = false;
					hresError = pIPSecurity->get_GrantByDefault(&GrantByDefault);
					pIPSecurity->Release();
					varValueArray[4].vt = VT_BSTR;
					if (GrantByDefault)
						varValueArray[4].bstrVal = SysAllocString(L"False");
					else
						varValueArray[4].bstrVal = SysAllocString(L"True");
					*bstrType = SysAllocString(L"IPSec");

				}
				else
				{
				}
				break;
			}
			default:
			{	break;
			}
		}
	}
xit:
	VariantClear(&varTempValue);
	return;
}



void PrintVariant(VARIANT varInput)
{	switch (varInput.vt)
	{	case VT_ARRAY|VT_VARIANT:
		{	
			printf("\n");
			printf("   ");
			SAFEARRAY FAR * varArray;
			SAFEARRAYBOUND rgsabound[100];
			rgsabound[0].lLbound = varInput.parray->rgsabound[0].lLbound;
			rgsabound[0].cElements = varInput.parray->rgsabound[0].cElements;
			varArray = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
			varArray =varInput.parray;
							
			VARIANT *varArrayData;
			varArrayData = (VARIANT*) varArray->pvData;
			for (unsigned long m = varArray->rgsabound[0].lLbound; m < varArray->rgsabound[0].cElements; m++)
			{	
				varArrayData[m].vt= VT_BSTR;
				//PrintVariant(varArrayData[m]);
				//if (m < varArray->rgsabound[0].cElements - 1)
				//	printf(",");
			}

		SafeArrayDestroy(varArray); 
		break;
		}
	
	 case VT_ARRAY|VT_BSTR: 
		{	printf("\n");
			printf("   ");
			VARIANT *varArray = (VARIANT*) varInput.parray->pvData;
			for (unsigned long m = 0; m < varInput.parray->rgsabound[0].cElements; m++)
			{	printf("\"%S\"", varArray[m]);
				if (m < varInput.parray->rgsabound[0].cElements - 1)
					printf(",");
			}
			VariantClear(varArray);
			break;
		}
		
		case VT_BSTR:
		{
			printf("%S", varInput.bstrVal);
			break;
		}
		default:
		{	printf("%x", varInput.vt);
			break;
		}
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\adsutil\clscommand.h ===
/***********************************************************************
File: clsCommand.h
Description: class definitions and global constants
***********************************************************************/

#define INITGUID
#define INC_OLE2

#include <WINDOWS.H>
#include <WINBASE.H>
#include <OLE2.H>
#include  <coguid.h>

#include <stdio.h>
#include <stdlib.h>

#include <iads.h>
#include <activeds.h>
#include "iiis.h"
#include "mddefw.h"
#include <comdef.h>
#include <string.h>

//* Global functions ***********************
int IsProperty(BSTR, BSTR *, BSTR *);
void GetProperty(IADs *, BSTR, VARIANT *, BSTR *);
int IsSet(IISBaseObject *, BSTR, BSTR);
void PrintVariant(VARIANT);
HRESULT PrintVariantArray(VARIANT);
int IsSpecialProperty(BSTR);
//* Global constants ***********************
const int PROP_OK = 0;
const int PROP_SPECIAL = 1;
const int PROP_SKIP = 2;

const int CMD_NOTSUPPORTED = 0;
const int CMD_ENUM = 1;
const int CMD_ENUMALL = 2;
const int CMD_SET = 3;
const int CMD_CREATE = 4;
const int CMD_CREATEVDIR = 5;
const int CMD_CREATEVSERV = 6;
const int CMD_DELETE = 7;
const int CMD_GET = 8;
const int CMD_COPY = 9;
const int CMD_MOVE = 10;
const int CMD_STARTSERVER = 11;
const int CMD_STOPSERVER = 12;
const int CMD_PAUSESERVER = 13;
const int CMD_CONTINUESERVER = 14;
const int CMD_FIND = 15;
const int CMD_APPCREATEINPROC = 16;
const int CMD_APPCREATEOUTPROC = 17;
const int CMD_APPDELETE = 18;
const int CMD_APPUNLOAD = 19;
const int CMD_APPGETSTATUS = 20;
const int CMD_HELP = 21;
const int CMD_SCRIPT = 22;
const int CMD_APPEND = 23;
const int CMD_REMOVE = 24;
//*************************************************
// this class should be used as a descriptor for
// the server specified in the -s: switch
class clsServer
{	private:
		BSTR bstrName;
	public:
		clsServer()
		{	bstrName = SysAllocString(L"localhost");
		}
		BSTR GetName(){ return bstrName; }
		void SetName(BSTR bstrNewName)
		{	SysFreeString(bstrName);
			bstrName = SysAllocString(bstrNewName);
			return;
		}
		// Your usual path will be something like "w3svc/1/blah", this function
		// just adds "IIS://" and the server name to the beginning of a path
		void CompletePath(BSTR *OldPath)
		{	int newlen = wcslen(*OldPath) + wcslen(bstrName) + 6;
			WCHAR *NewPath = (WCHAR*) HeapAlloc (GetProcessHeap(), 0, sizeof (WCHAR) * (newlen + 1));
			wcscpy(NewPath, L"IIS://");
			wcscpy(NewPath + wcslen(NewPath), bstrName);	
			if (wcslen(*OldPath) > 1)
			{	if (_wcsnicmp(*OldPath, L"/", 1))
				{	wcscpy(NewPath + wcslen(NewPath), L"/");
				}
				wcscpy(NewPath + wcslen(NewPath), *OldPath);	
			}
			SysFreeString(*OldPath);
			*OldPath = SysAllocString(NewPath);
			return;
		}
};
//*************************************************
// These are the ADSUTIL classes, they
// handle all the primary functionality.

class clsENUM
{	private:
		BSTR Path;
		bool PathOnlyOption;
		bool AllDataOption;
	public:
		bool Recurse;
		clsServer *TargetServer;
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsSET
{	private:
		BSTR Path;
		BSTR Property;
		BSTR *Values;
		int ValueCount;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsCREATE
{	private:
		BSTR Path;
		BSTR Property;
		BSTR Type;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsDELETE
{	private:
		BSTR PathProperty;
		BSTR Path;
		BSTR Property;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsGET
{	private:
		BSTR Path;
		BSTR Property;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsCOPY_MOVE
{	private:
		BSTR SrcPath;
		BSTR DstPath;
	public:
		BSTR ParentPath;
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute(int);
};

class clsSERVER_COMMAND
{	private:
		BSTR Path;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute(int);
};

class clsFIND
{	private:
		BSTR Path;
		BSTR Property;
		bool Found;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsAPP
{	private:
		BSTR Path;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute(int);
};

class clsHELP
{	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsAPPEND
{	private:
		BSTR Path;
		BSTR Property;
		BSTR Value;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};

class clsREMOVE
{	private:
		BSTR Path;
		BSTR Property;
		BSTR Value;
	public:
		int ParseCommandLine(int argc,BSTR args[]);
		int Execute();
};
//*****************************************
// This basically acts as another main() function--
// reads lines out of a text file and then just
// mimics what main() does.
class clsSCRIPT
{	private:
		char *FileName;
	public:
		int ParseCommandLine(int argc, BSTR args[]);
		int Execute();
};

// This is just the container for all the ADSUTIL classes
class clsCommand
{	private:
		int indicator;
//		static union
//		{
			clsENUM objEnum;
			clsSET objSet;
			clsCREATE objCreate;
			clsDELETE objDelete;
			clsGET objGet;
			clsCOPY_MOVE objCopyMove;
			clsSERVER_COMMAND objServerCommand;
			clsFIND objFind;
			clsAPP objApp;
			clsHELP	objHelp;
			clsSCRIPT objScript;
			clsAPPEND objAppend;
			clsREMOVE objRemove;
//		};
	public:
		int GetIndicator(){	return indicator; };
		int ParseCommandLine(char *);
		int Execute();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\mtbsmon\mtbs.cpp ===
// mtbs.cpp
#define _WIN32_DCOM
#define INITGUID 
#include "iadmw.h"    // COM Interface header 
#include "iiscnfg.h"  // MD_ & IIS_MD_ #defines 

#include <conio.h>
#include <stdio.h>

class CSink : public IMSAdminBaseSink
{
public:
	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void** ppv);

	// IMSAdminBaseSink
	HRESULT STDMETHODCALLTYPE ShutdownNotify( void);
	HRESULT STDMETHODCALLTYPE SinkNotify( DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeList[]); 

	CSink() : m_cRef(0) {  }
	~CSink() { }

private:
	long m_cRef;
};

ULONG CSink::AddRef()
{
	return ++m_cRef;
}

ULONG CSink::Release()
{
	if(--m_cRef != 0)
		return m_cRef;
	delete this;
	return 0;
}

HRESULT CSink::QueryInterface(REFIID riid, void** ppv)
{
	if(riid == IID_IUnknown)
	{
		*ppv = (IUnknown*)this;
	}
	else if(riid == IID_IMSAdminBaseSink )
	{
		*ppv = (IMSAdminBaseSink*)this;
	}
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

HRESULT CSink::ShutdownNotify()
{
	
	printf( "CSink::ShutdownNotify is  called\n");
	return S_OK;
}

HRESULT CSink::SinkNotify( DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeList[])
{
 DWORD i, j;	
	

	printf( "CSink::SinkNotify is called\n");

	for (i=0; i<dwMDNumElements; i++)
	{
		

		wprintf(L"path: %s\n",pcoChangeList[i].pszMDPath);
		
		switch(pcoChangeList[i].dwMDChangeType)
		{
			case MD_CHANGE_TYPE_ADD_OBJECT:
				printf("ChangeType: MD_CHANGE_TYPE_ADD_OBJECT");
				break;
			case MD_CHANGE_TYPE_DELETE_DATA:
				printf("ChangeType: MD_CHANGE_TYPE_DELETE_DATA\n");
				break;
			case MD_CHANGE_TYPE_DELETE_OBJECT:
				printf("ChangeType: MD_CHANGE_TYPE_DELETE_OBJECT\n");
				break;
			case MD_CHANGE_TYPE_RENAME_OBJECT:
				printf("ChangeType: MD_CHANGE_TYPE_RENAME_OBJECT\n");
				break;
			case MD_CHANGE_TYPE_SET_DATA:
				printf("ChangeType: MD_CHANGE_TYPE_SET_DATA\n");
				break;
		}

		printf("\t Metabase Identifier list\n");
		for (j=0; j<pcoChangeList[i].dwMDNumDataIDs; j++)
		{
			printf("\t\t%u (%#x)\n",pcoChangeList[i].pdwMDDataIDs[j],pcoChangeList[i].pdwMDDataIDs[j]);
		}


	}
	return S_OK;
}

class InitOLE
{
public:
	InitOLE()
		{CoInitializeEx(NULL, COINIT_MULTITHREADED);}
	 ~InitOLE()
		{CoUninitialize(); }
};
InitOLE _initOLE;


void main()
{
	HRESULT hr;
	

	IConnectionPointContainer* pConnectionPointContainer;
	printf("Client: Calling CoCreateInstance()\n");
	hr=CoCreateInstance(
			CLSID_MSAdminBase, 
			NULL, 
			CLSCTX_ALL, 
			IID_IConnectionPointContainer, 
			(void**)&pConnectionPointContainer
			);


	if(FAILED(hr))
	{
		printf("Failed to get IConnectionPointContainer interface pointer\n");
		return ;
	}	

	IConnectionPoint* pConnectionPoint;
	hr = pConnectionPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnectionPoint);
	if(FAILED(hr))
	{
		printf("Failed to get IConnectionPoint interface pointer\n");
		pConnectionPointContainer->Release();
		return ;
	}

	//establish event notification with iis metabase
	CSink* mySink = new CSink;
	DWORD dwCookie;
	hr=pConnectionPoint->Advise((IUnknown*)mySink, &dwCookie);
	printf("CLIENT CALLED ADVISE\n");


	printf("Press any key to exit\n");
	_getch();

	//Unadvise will call mySink's Release() function 
	//and delete mySink Object. So DO NOT call delete mySink
	hr=pConnectionPoint->Unadvise(dwCookie);
	pConnectionPoint->Release();
	pConnectionPointContainer->Release();


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\simpleadsutil\simpleadsutil.cpp ===
// SimpleAdsutil.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "initguid.h"
#include "activeds.h"
#include <stdio.h>

#define MAX_BUFF_LEN 512


HRESULT EnumCommand (const char szADsPath[] );
HRESULT GetCommand (const char szADsPath[]);
HRESULT SetCommand (const char szADsPath[], const char szValue[]);

//helper functions
BOOL SplitNameAndPath(const char szPathAndName[], char szPath[], char szName[]);
void DisplayContents(IADsContainer* pADsCont, int iIndent);
HRESULT PrintVariant(VARIANT var);
HRESULT PrintVariantArray( VARIANT var );
void Usage();




// initialize COM  before  main and uninitialize COM after main

struct InitOLE
{
	InitOLE()
		{CoInitializeEx(NULL, COINIT_MULTITHREADED);}
	 ~InitOLE()
		{CoUninitialize(); }
};
InitOLE _initOLE;


int main(int argc, char* argv[])
{
	//parse command arg to take corresponding action
	//legitigate commands are
	// enum for enumerate 
	// get for get ADS property
	// set for set ADS property

	if (argc <3)
	{
		Usage();
		return 0;
	}

	if (stricmp(argv[1], "ENUM")==0)
		EnumCommand( argv[2]);
	else if ( stricmp(argv[1], "GET")==0)
		GetCommand(argv[2]);
	else if( stricmp(argv[1], "SET")==0)
	{
		if (argc != 4)
		{
			printf("Incorrect number of argument for set command!\n");
			Usage();
		}
		else
		{
			SetCommand(argv[2], argv[3]);
		}
	}
	else
		Usage();
	
	return 0;
}



//description
//
HRESULT EnumCommand (const char szADsPath[] )
{
  
	char szFullPath[MAX_BUFF_LEN];
	CComPtr<IADsContainer> pADsCont;
	HRESULT hr;

	strcpy(szFullPath, "IIS://Localhost/");
	strcat(szFullPath, szADsPath);
	hr=ADsGetObject(CComBSTR(szFullPath),
					IID_IADsContainer,
					(void**)&pADsCont);
	if (FAILED(hr))
	{
		printf("ADsGetObject() failed when try to obtain " \
				"IID_IADsContainer interface pointer.\n");
	    return E_FAIL;
	}

	DisplayContents( pADsCont,  0);

	return S_OK;

}

// Description:
// Retriev the ADS property 

HRESULT GetCommand (const char szADsPathandName[])
{
	char  szPropName[MAX_BUFF_LEN], szPropPath[MAX_BUFF_LEN];
	CComPtr<IADs> pADs;
	CComVariant vntValue;
	HRESULT hr;
	char szErr[MAX_BUFF_LEN];

	if(!SplitNameAndPath(szADsPathandName, szPropPath, szPropName))
	{
		sprintf(szErr, "Invalid ADS path!\n");
		goto error;
	}

	hr = ADsGetObject(CComBSTR(szPropPath), IID_IADs, (void**)&pADs);	
	if ( FAILED(hr) )
	{
		sprintf( szErr, "ADsGetObject Failed. HRESULT is %#X\n", hr );
		goto error;
	}

	hr = pADs->Get( CComBSTR(szPropName), &vntValue );
	if (FAILED(hr))
	{
		sprintf(szErr,"property %s does not exist on %s\n", szPropName, szPropPath);
		goto error;
	}

	//print property value

	printf("%s: ", szPropName);
	PrintVariant(vntValue);

    return S_OK;

error:
	printf("%s", szErr);
	return hr;
}


// Description
// Set ADS property
HRESULT SetCommand (const char szADsPathandName[], const char szValue[])
{
	char  szPropName[MAX_BUFF_LEN], szPropPath[MAX_BUFF_LEN];
	CComPtr<IADs> pADs;
	CComPtr<IADsProperty> pADsProperty;
	CComBSTR bstrSchema;
	CComBSTR bstrPropType;
	int cPropType;
	CComVariant vntPropValue;
	HRESULT hr;
	char szErr[MAX_BUFF_LEN]={'\0'};
	
	SplitNameAndPath(szADsPathandName, szPropPath, szPropName);
	
	//Get Schema to find out the value type
	bstrSchema.Append("IIS://Localhost/schema/");
	bstrSchema.Append(szPropName);
	hr = ADsGetObject(bstrSchema, IID_IADsProperty, (void**) &pADsProperty);
	if (FAILED(hr))
	{
		sprintf(szErr, "ADsGetObject() failed. Property %s may not exist!\n",szPropName);
		goto error;

	}

	hr = pADsProperty->get_Syntax(&bstrPropType);
	if (FAILED(hr))
	{
		sprintf(szErr, "IADsProperty->get_SynTax() failed\n");
		goto error;

	}
	
	if (_wcsicmp(bstrPropType, L"INTEGER")==0)
	{
		cPropType=VT_I4;
	}
	else if (_wcsicmp(bstrPropType, L"BOOLEAN")==0)
	{
		cPropType=VT_BOOL;
	}
	else if (_wcsicmp(bstrPropType, L"STRING")==0)
	{
		cPropType=VT_BSTR;
	}
	else if (_wcsicmp(bstrPropType, L"LIST")==0)
	{
		cPropType=VT_VARIANT+VT_ARRAY;
	}
	else
	{
		sprintf(szErr,"the property data type is not handled!\n");
		goto error;
	}
	
	if (cPropType != VT_VARIANT+VT_ARRAY)
	{
		vntPropValue=szValue;
		hr = vntPropValue.ChangeType(cPropType);
	}
	else
	{
		//BuildVariantArray(&vntPropValue, szValue);
		SAFEARRAY* psa;
		SAFEARRAYBOUND bounds= {1,0};
		VARIANT* pvntValue;
		psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
		hr = SafeArrayAccessData(psa, (void**) &pvntValue);
		pvntValue->vt= VT_BSTR;
		pvntValue->bstrVal = CComBSTR(szValue).Copy();
		hr = SafeArrayUnaccessData(psa);
		vntPropValue.vt=cPropType;
		vntPropValue.parray=psa;
	}

	hr = ADsGetObject(CComBSTR(szPropPath), IID_IADs, (void**) &pADs);
    hr = pADs->Put(CComBSTR(szPropName), vntPropValue);
	if (FAILED(hr))
	{
		sprintf(szErr, "Could not set the value to metabase!\n");
		goto error;
	}

	pADs->SetInfo();
	return S_OK;
error:
	printf("%s", szErr);
	return hr;
}



void DisplayContents(IADsContainer* pADsCont, int iIndent)
{
	CComQIPtr<IADs,&IID_IADs>pADs;
	IADsContainer* pADsCntner;
	IEnumVARIANT* pEnum;
	CComVariant rgvElement;
	unsigned long cFetched;
	CComBSTR rgvName, rgvClass;
	HRESULT hr;
	char szSpace[MAX_BUFF_LEN];

	

	//set indent string
	memset((void*)szSpace, ' ', MAX_BUFF_LEN);
	szSpace[iIndent]='\0';

	//build enumerator
	hr=ADsBuildEnumerator(pADsCont, &pEnum);
	if(FAILED(hr))
		return;
	
	do{
		hr=ADsEnumerateNext(pEnum, 1, &rgvElement, &cFetched);
	
		if(hr==S_OK )
		{
			if(rgvElement.vt== VT_DISPATCH)
			{
			 pADs=rgvElement.pdispVal;
			 pADs->get_Name(&rgvName);
			 pADs->get_Class(&rgvClass);
			 //printf out
			 printf("%s",szSpace);
			 wprintf(L"%s(%s)\n", rgvName,rgvClass);

			 HRESULT hres=pADs->QueryInterface(IID_IADsContainer, (void**)&pADsCntner);
			 if(SUCCEEDED(hres))
			 {
				 DisplayContents(pADsCntner,iIndent+3 );
				 pADsCntner->Release();
			 }
			}
		}
		else
			break;
		

	}while(1);
	
	ADsFreeEnumerator(pEnum);
}


BOOL SplitNameAndPath(const char szPathAndName[], char szPath[], char szName[])
{
	char  *pSepPos; 
	
	if (strlen(szPathAndName) > MAX_BUFF_LEN)
	{
		printf("Argument is too long!\n");
		return FALSE;
	}

	strcpy(szPath, "IIS://Localhost/");
	strcat(szPath, szPathAndName);

	
	pSepPos=strrchr(szPath, '/');
	
	if (pSepPos ==NULL)	
		return FALSE;

	strcpy(szName, pSepPos+1);
	*pSepPos= '\0';

	return TRUE;
}

HRESULT 
PrintVariant( 
    VARIANT varPropData 
    ) 
{ 
    HRESULT hr; 
    BSTR bstrValue; 
 
    switch (varPropData.vt) { 
    case VT_I4: 
        printf("%d", varPropData.lVal); 
        break; 
    case VT_BSTR: 
        printf("%S", varPropData.bstrVal); 
        break; 
 
    case VT_BOOL: 
        printf("%d", V_BOOL(&varPropData)); 
        break; 
 
    case (VT_ARRAY | VT_VARIANT): 
        PrintVariantArray(varPropData); 
        break; 
 
    case VT_DATE: 
        hr = VarBstrFromDate( 
                 varPropData.date, 
                 LOCALE_SYSTEM_DEFAULT, 
                 LOCALE_NOUSEROVERRIDE, 
                 &bstrValue 
                 ); 
        printf("%S", bstrValue); 
        break; 
 
    default: 
        printf("Data type is %d\n", varPropData.vt); 
        break; 
 
    } 
    printf("\n"); 
    return(S_OK); 
} 
 
 
HRESULT 
PrintVariantArray( 
    VARIANT var 
    ) 
{ 
    LONG dwSLBound = 0; 
    LONG dwSUBound = 0; 
    VARIANT v; 
    LONG i; 
    HRESULT hr = S_OK; 
 
    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) { 
        return(E_FAIL); 
    } 
 
    // 
    // Check that there is only one dimension in this array 
    // 
 
    if ((V_ARRAY(&var))->cDims != 1) { 
        hr = E_FAIL; 
		goto error;
    } 
    // 
    // Check that there is atleast one element in this array 
    // 
 
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){ 
        hr = E_FAIL; 
		goto error;
    } 
 
    // 
    // We know that this is a valid single dimension array 
    // 
 
    hr = SafeArrayGetLBound(V_ARRAY(&var), 
                            1, 
                            (long FAR *)&dwSLBound 
                            ); 
    if (FAILED(hr)) goto error; 
 
    hr = SafeArrayGetUBound(V_ARRAY(&var), 
                            1, 
                            (long FAR *)&dwSUBound 
                            ); 
    if (FAILED(hr)) goto error; 
 
    for (i = dwSLBound; i <= dwSUBound; i++) { 
        VariantInit(&v); 
        hr = SafeArrayGetElement(V_ARRAY(&var), 
                                (long FAR *)&i, 
                                &v 
                                ); 
        if (FAILED(hr)) { 
            continue; 
        } 
        if (i < dwSUBound) { 
            printf("%S, ", v.bstrVal); 
        } else { 
            printf("%S", v.bstrVal); 
        } 
    } 
    return(S_OK); 
 
error: 
    return(hr); 
} 

//print out the usage info

void Usage()
{
	printf("Usage: SimpleAdsutil.exe <enum|get|set> <adspath> [propValue] \n\n");
	printf("Samples:\n");
	printf("\tSimpleAdsutil.exe enum w3svc/1/root\n");
	printf("\tSimpleAdsutil.exe get w3svc/1/ServerBindings\n");
	printf("\tSimpleAdsutil.exe set w3svc/1/root/path d:\\n");
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\simpleadsutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__EDEFB287_28D8_11D2_BEC2_204C4F4F5020__INCLUDED_)
#define AFX_STDAFX_H__EDEFB287_28D8_11D2_BEC2_204C4F4F5020__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override

extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EDEFB287_28D8_11D2_BEC2_204C4F4F5020__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\admin\simpleadsutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\base64.c ===
HTTPAUTH.C
/*++ 
 
Copyright 1996-1997 Microsoft Corporation 
 
Module Name: 
 
    httpauth.c 
 
Abstract: 
 
    Handles authentication sequence ( Basic & SSPI ) 
 
History: 
 
    Created     15-Feb-1996 
 
 
Revision History: 
 
--*/ 
 
/************************************************************ 
 *    Include Headers 
 ************************************************************/ 
 
#include <windows.h> 
#include <rpc.h> 
#include <winsock.h> 
#include <lm.h> 
 
#include <stdio.h> 
#include <stdarg.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h> 
#include <fcntl.h> 
 
#define SECURITY_WIN32 
#include "sspi.h" 
#include "issperr.h" 
 
 
// declaration for this module 
 
#include "httpauth.h" 
 
#define SEC_SUCCESS(Status) ((Status) >= 0) 
#define STATUS_SUCCESS 0 
 
 
// Target name for the security package 
 
#define TOKEN_SOURCE_NAME       "InetSvcs" 
 
 
// general purpose dynamic buffer structure 
 
typedef struct _BUFFER { 
    PBYTE pBuf; 
    DWORD cLen; 
} BUFFER ; 
 
 
// structure storing the state of the authentication sequence 
 
typedef struct _AUTH_SEQ { 
    BOOL _fNewConversation; 
    CredHandle _hcred; 
    BOOL _fHaveCredHandle; 
    DWORD _cbMaxToken; 
    BOOL _fHaveCtxtHandle; 
    struct _SecHandle  _hctxt; 
    BOOL _fUUEncodeData; 
} AUTH_SEQ; 
 
// entry points in the security DLL 
 
typedef struct _SEC_FUNC { 
    FREE_CREDENTIALS_HANDLE_FN pFreeCredentialsHandle; 
    ACQUIRE_CREDENTIALS_HANDLE_FN pAcquireCredentialsHandle; 
    QUERY_SECURITY_PACKAGE_INFO_FN pQuerySecurityPackageInfo;   // A 
    FREE_CONTEXT_BUFFER_FN pFreeContextBuffer; 
    INITIALIZE_SECURITY_CONTEXT_FN pInitializeSecurityContext;  // A 
    COMPLETE_AUTH_TOKEN_FN pCompleteAuthToken; 
    ENUMERATE_SECURITY_PACKAGES_FN pEnumerateSecurityPackages;  // A 
} SEC_FUNC; 
 
// local functions 
 
BOOL CrackUserAndDomain( 
    CHAR *   pszDomainAndUser, 
    CHAR * * ppszUser, 
    CHAR * * ppszDomain 
    ); 
 
BOOL AuthConverse( 
    AUTH_SEQ *pAS, 
    VOID   * pBuffIn, 
    DWORD    cbBuffIn, 
    BUFFER * pbuffOut, 
    DWORD  * pcbBuffOut, 
    BOOL   * pfNeedMoreData, 
    CHAR   * pszPackage, 
    CHAR   * pszUser, 
    CHAR   * pszPassword 
    ); 
 
BOOL AuthInit( AUTH_SEQ *pAS ); 
 
void AuthTerminate( AUTH_SEQ *pAS ); 
 
 
// uuencode/decode routines declaration 
// used to code the authentication blob 
 
BOOL uudecode(char   * bufcoded, 
              BUFFER * pbuffdecoded, 
              DWORD  * pcbDecoded ); 
BOOL uuencode( BYTE *   bufin, 
               DWORD    nbytes, 
               BUFFER * pbuffEncoded ); 
 
 
/************************************************************ 
 *    Globals for this module 
 ************************************************************/ 
 
static BOOL g_fAuth = FALSE; 
static BOOL g_fBasic = FALSE; 
static AUTH_SEQ g_Auth; 
static HINSTANCE g_hSecLib = NULL; 
static SEC_FUNC sfProcs; 
 
 
/************************************************************ 
 *    Helper functions 
 ************************************************************/ 
 
BOOL BufferInit( BUFFER *pB ) 
{ 
    pB->pBuf = NULL; 
    pB->cLen = 0; 
 
    return TRUE; 
} 
 
 
void BufferTerminate( BUFFER *pB ) 
{ 
    if ( pB->pBuf != NULL ) 
    { 
        free( pB->pBuf ); 
        pB->pBuf = NULL; 
        pB->cLen = 0; 
    } 
} 
 
 
PBYTE BufferQueryPtr( BUFFER * pB ) 
{ 
    return pB->pBuf; 
} 
 
 
BOOL BufferResize( BUFFER *pB, DWORD cNewL ) 
{ 
    PBYTE pN; 
    if ( cNewL > pB->cLen ) 
    { 
        pN = malloc( cNewL ); 
        if ( pB->pBuf ) 
        { 
            memcpy( pN, pB->pBuf, pB->cLen ); 
            free( pB->pBuf ); 
        } 
        pB->pBuf = pN; 
        pB->cLen = cNewL; 
    } 
 
    return TRUE; 
} 
 
 
/************************************************************ 
 *    Authentication functions 
 ************************************************************/ 
 
 
BOOL  
InitAuthorizationHeader( 
    ) 
/*++ 
 
 Routine Description: 
 
    Initialize the authentication package 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
    OSVERSIONINFO   VerInfo; 
    UCHAR lpszDLL[MAX_PATH]; 
 
    // 
    //  Find out which security DLL to use, depending on  
    //  whether we are on NT or Win95 
    // 
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); 
    if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong 
    { 
        return FALSE; 
    } 
 
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) 
    { 
        strcpy (lpszDLL, "security.dll" ); 
    } 
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) 
    { 
        strcpy (lpszDLL, "secur32.dll" ); 
    } 
    else 
    { 
        return FALSE; 
    } 
 
    // 
    //  Load Security DLL 
    // 
 
    g_hSecLib = LoadLibrary (lpszDLL); 
    if (g_hSecLib == NULL) 
    { 
        return FALSE; 
    } 
 
    // Get all entry points we care about 
 
    sfProcs.pFreeCredentialsHandle  
            = (FREE_CREDENTIALS_HANDLE_FN) GetProcAddress(  
                    g_hSecLib,  
                    "FreeCredentialsHandle" ); 
 
    sfProcs.pQuerySecurityPackageInfo  
            = (QUERY_SECURITY_PACKAGE_INFO_FN) GetProcAddress(  
                    g_hSecLib,  
                    "QuerySecurityPackageInfoA" ); 
 
    sfProcs.pAcquireCredentialsHandle  
            = (ACQUIRE_CREDENTIALS_HANDLE_FN) GetProcAddress( 
                    g_hSecLib,  
                    "AcquireCredentialsHandleA" ); 
 
    sfProcs.pFreeContextBuffer  
            = (FREE_CONTEXT_BUFFER_FN) GetProcAddress(  
                    g_hSecLib,  
                    "FreeContextBuffer" ); 
 
    sfProcs.pInitializeSecurityContext 
            = (INITIALIZE_SECURITY_CONTEXT_FN) GetProcAddress(  
                    g_hSecLib,  
                    "InitializeSecurityContextA" ); 
 
    sfProcs.pCompleteAuthToken  
            = (COMPLETE_AUTH_TOKEN_FN) GetProcAddress(  
                    g_hSecLib,  
                    "CompleteAuthToken" ); 
 
    sfProcs.pEnumerateSecurityPackages  
            = (ENUMERATE_SECURITY_PACKAGES_FN) GetProcAddress(  
                    g_hSecLib,  
                    "EnumerateSecurityPackagesA" ); 
 
    if ( sfProcs.pFreeCredentialsHandle == NULL 
            || sfProcs.pQuerySecurityPackageInfo == NULL 
            || sfProcs.pAcquireCredentialsHandle == NULL 
            || sfProcs.pFreeContextBuffer == NULL 
            || sfProcs.pInitializeSecurityContext == NULL  
            || sfProcs.pEnumerateSecurityPackages == NULL ) 
    { 
        FreeLibrary( g_hSecLib ); 
        g_hSecLib = NULL; 
        return FALSE; 
    } 
 
    g_fAuth = g_fBasic = FALSE; 
  
    return TRUE; 
} 
 
 
void  
TerminateAuthorizationHeader( 
    ) 
/*++ 
 
 Routine Description: 
 
    Terminate the authentication package 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    None 
 
--*/ 
{ 
    if ( g_fAuth ) 
    { 
        AuthTerminate( &g_Auth ); 
        g_fAuth = FALSE; 
    } 
 
    g_fBasic = FALSE; 
 
    if ( g_hSecLib != NULL ) 
    { 
        FreeLibrary( g_hSecLib ); 
        g_hSecLib = NULL; 
    } 
} 
 
 
BOOL  
IsInAuthorizationSequence( 
    ) 
/*++ 
 
 Routine Description: 
 
    Indicates if in authentication sequence 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
    return g_fAuth || g_fBasic; 
} 
 
 
BOOL  
ValidateAuthenticationMethods(  
    PSTR pszMet, 
    PSTR pszPreferedMet ) 
/*++ 
 
 Routine Description: 
 
    Filter the supplied authentication list for supported 
    methods ( Basic and all local security packages ) 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    Returns TRUE if at least one authentication method supported, 
    otherwise FALSE is returned. 
 
--*/ 
{ 
    PSecPkgInfo pSec; 
    ULONG cSec, iS; 
    BOOL fValid; 
    PSTR p,t; 
    SECURITY_STATUS ss; 
 
 
    // access local security packages list 
 
    if ( (ss = sfProcs.pEnumerateSecurityPackages( &cSec, &pSec ))  
            == STATUS_SUCCESS ) 
    { 
        for ( t = p = pszMet ; *p ; ) 
        { 
            // Valid methods are "Basic" and all security packages 
 
            if ( !_stricmp( p , "Basic" ) ) 
                fValid = TRUE; 
            else for ( iS = 0 ; iS < cSec ; ++iS ) 
                if ( !_stricmp( pSec[iS].Name, p ) ) 
                    break; 
 
            if ( fValid ) 
            { 
                if ( t != p ) 
                    memmove( t, p, strlen(p)+1 ); 
                p += strlen( p ) + 1; 
                t += strlen( t ) + 1; 
            } 
        } 
        *t = '\0'; 
    } 
 
    // check for prefered method 
 
    if ( pszPreferedMet != NULL ) 
    { 
        PSTR pP; 
 
        for ( pP = strtok( pszPreferedMet, "," ) ; 
                pP != NULL ; 
                pP = strtok( NULL, "," ) ) 
        { 
            // scan list of validated methods for the current 
            // prefered method 
 
            for ( p = pszMet ; *p ; ) 
            { 
                if ( !_stricmp( pP, p ) ) 
                { 
                    memmove( pszMet, p, strlen(p) + 1 ); 
                    return TRUE; 
                } 
                p += strlen( p ) + 1; 
            } 
        } 
 
        // no method in the prefered method list is supported 
 
        return FALSE; 
    } 
 
    // no prefered method list supplied 
 
    return *pszMet ? TRUE : FALSE; 
} 
 
 
BOOL 
AddAuthorizationHeader( 
    PSTR pch,        
    PSTR pchSchemes, 
    PSTR pchAuthData, 
    PSTR pchUserName, 
    PSTR pchPassword, 
    BOOL *pfNeedMoreData 
    ) 
/*++ 
 
 Routine Description: 
 
    Generates an authentication header to be sent to the server. 
    An authentication sequence will be initiated if none is in 
    use and at least one of the authentication scheme specified 
    in pchSchemes is recognized. 
    Otherwise the current authentication sequence will proceed. 
 
 Arguments: 
 
    pch                 where to append authentication header 
    pchSchemes          list of null-delimited authentication methods 
    pchAuthData         incoming blob from server 
    pchUserName         user name ( possibly prefixed with domain ) 
    pchPassword         password 
    pfNeedMoreData      Out: TRUE if authentication sequence to continue 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
    CHAR   achUserAndPass[256]; 
    BUFFER buff; 
    BOOL fSt = TRUE; 
    DWORD cbOut; 
 
 
    BufferInit( &buff ); 
 
    while ( *pchSchemes ) 
    { 
        if ( !stricmp( pchSchemes, "Basic" )) 
        { 
            // if already in authentication sequence, it failed. 
 
            if ( g_fBasic ) 
            { 
                SetLastError( ERROR_ACCESS_DENIED ); 
                fSt = FALSE; 
                break; 
            } 
 
            strcpy( achUserAndPass, pchUserName ); 
            strcat( achUserAndPass, ":" ); 
            strcat( achUserAndPass, pchPassword ); 
 
            uuencode( (BYTE *) achUserAndPass, 
                      strlen( achUserAndPass ), 
                      &buff ); 
            strcat( pch, "Authorization: " ); 
            strcat( pch, "Basic " ); 
            strcat( pch, BufferQueryPtr( &buff )); 
            strcat( pch, "\r\n"); 
            g_fBasic = TRUE; 
            break; 
        } 
        else  
        { 
            // SSPI package ( assuming methods list have been validated ) 
 
            if ( !g_fAuth ) 
            { 
                if ( !AuthInit( &g_Auth ) ) 
                { 
                    fSt = FALSE; 
                    goto ex; 
                } 
            } 
            else if ( pchAuthData == NULL || *pchAuthData == '\0' ) 
            { 
                // no blob while in authentication sequence : it failed 
 
                SetLastError( ERROR_ACCESS_DENIED ); 
                fSt = FALSE; 
                break; 
            } 
 
            if ( !AuthConverse( &g_Auth, 
                  (void *) pchAuthData, 
                  0, 
                  &buff, 
                  &cbOut, 
                  pfNeedMoreData, 
                  pchSchemes, 
                  pchUserName, 
                  pchPassword )) 
            { 
                fSt = FALSE; 
                goto ex; 
            } 
 
            strcat( pch, "Authorization: " ); 
            strcat( pch, pchSchemes ); 
            strcat( pch, " " ); 
            strcat( pch, (CHAR *) BufferQueryPtr( &buff ) ); 
            strcat( pch, "\r\n" ); 
            break; 
        } 
 
        pchSchemes += strlen(pchSchemes) + 1; 
    } 
ex: 
    BufferTerminate( &buff ); 
 
    return fSt; 
} 
 
 
BOOL  
AuthInit(  
    AUTH_SEQ *pAS ) 
/*++ 
 
 Routine Description: 
 
    Initialize a SSP authentication sequence 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
    pAS->_fNewConversation = TRUE; 
    pAS->_fHaveCredHandle = FALSE; 
    pAS->_fHaveCtxtHandle = FALSE; 
    pAS->_fUUEncodeData = TRUE; 
 
    g_fAuth = TRUE; 
 
    return TRUE; 
} 
 
 
void  
AuthTerminate(  
    AUTH_SEQ *pAS ) 
/*++ 
 
 Routine Description: 
 
    Terminate a SSP authentication sequence 
 
 Arguments: 
 
    None 
 
 Return Value: 
 
    None 
 
--*/ 
{ 
    if ( pAS->_fHaveCredHandle ) 
        sfProcs.pFreeCredentialsHandle( &pAS->_hcred ); 
 
    pAS->_fHaveCredHandle = FALSE; 
    pAS->_fHaveCtxtHandle = FALSE; 
} 
 
 
BOOL  
AuthConverse( 
    AUTH_SEQ *pAS, 
    VOID   * pBuffIn, 
    DWORD    cbBuffIn, 
    BUFFER * pbuffOut, 
    DWORD  * pcbBuffOut, 
    BOOL   * pfNeedMoreData, 
    CHAR   * pszPackage, 
    CHAR   * pszUser, 
    CHAR   * pszPassword 
    ) 
/*++ 
 
Routine Description: 
 
    Initiates or continues a previously initiated authentication conversation 
 
    Client calls this first to get the negotiation message which 
    it then sends to the server.  The server calls this with the 
    client result and sends back the result.  The conversation 
    continues until *pfNeedMoreData is FALSE. 
 
    On the first call, pszPackage must point to the zero terminated 
    authentication package name to be used and pszUser and pszPassword 
    should point to the user name and password to authenticated with 
    on the client side (server side will always be NULL). 
 
Arguments: 
 
    pBuffIn - Points to SSP message received from the 
        client.  If UUENCODE is used, then this must point to a 
        zero terminated uuencoded string (except for the first call). 
    cbBuffIn - Number of bytes in pBuffIn or zero if pBuffIn points to a 
        zero terminated, uuencoded string. 
    pbuffOut - If *pfDone is not set to TRUE, this buffer contains the data 
        that should be sent to the other side.  If this is zero, then no 
        data needs to be sent. 
    pcbBuffOut - Number of bytes in pbuffOut 
    pfNeedMoreData - Set to TRUE while this side of the conversation is 
        expecting more data from the remote side. 
    pszPackage - On the first call points to a zero terminate string indicating 
        the security package to use 
    pszUser - Specifies user or domain\user the first time the client calls 
        this method (client side only) 
    pszPassword - Specifies the password for pszUser the first time the 
        client calls this method (client side only) 
 
Return Value: 
 
    TRUE if successful, FALSE otherwise (call GetLastError).  Access is 
    denied if FALSE is returned and GetLastError is ERROR_ACCESS_DENIED. 
 
--*/ 
{ 
    SECURITY_STATUS       ss; 
    TimeStamp             Lifetime; 
    SecBufferDesc         OutBuffDesc; 
    SecBuffer             OutSecBuff; 
    SecBufferDesc         InBuffDesc; 
    SecBuffer             InSecBuff; 
    ULONG                 ContextAttributes; 
    BUFFER                buffData; 
    BUFFER                buff; 
    BOOL                  fSt; 
    BOOL                  fReply; 
 
    BufferInit( &buffData ); 
    BufferInit( &buff ); 
 
    // 
    //  Decode the data if there's something to decode 
    // 
 
    if ( pAS->_fUUEncodeData && pBuffIn ) 
    { 
        if ( !uudecode( (CHAR *) pBuffIn, 
                        &buffData, 
                        &cbBuffIn )) 
        { 
            fSt = FALSE; 
            goto ex; 
        } 
 
        pBuffIn = BufferQueryPtr( &buffData ); 
    } 
 
    // 
    //  If this is a new conversation, then we need to get the credential 
    //  handle and find out the maximum token size 
    // 
 
    if ( pAS->_fNewConversation ) 
    { 
        SecPkgInfo *              pspkg; 
        SEC_WINNT_AUTH_IDENTITY   AuthIdentity; 
        SEC_WINNT_AUTH_IDENTITY * pAuthIdentity; 
        CHAR *                    pszDomain = NULL; 
        CHAR                      szDomainAndUser[DNLEN+UNLEN+2]; 
 
 
        // 
        //  fill out the authentication information 
        // 
 
        if ( ((pszUser != NULL) || 
              (pszPassword != NULL)) ) 
        { 
            pAuthIdentity = &AuthIdentity; 
 
            // 
            //  Break out the domain from the username if one was specified 
            // 
 
            if ( pszUser != NULL ) 
            { 
                strcpy( szDomainAndUser, pszUser ); 
                if ( !CrackUserAndDomain( szDomainAndUser, 
                                          &pszUser, 
                                          &pszDomain )) 
                { 
                    return FALSE; 
                } 
            } 
 
            memset( &AuthIdentity, 
                    0, 
                    sizeof( AuthIdentity )); 
 
            if ( pszUser != NULL ) 
            { 
                AuthIdentity.User       = (unsigned char *) pszUser; 
                AuthIdentity.UserLength = strlen( pszUser ); 
            } 
 
            if ( pszPassword != NULL ) 
            { 
                AuthIdentity.Password       = (unsigned char *) pszPassword; 
                AuthIdentity.PasswordLength = strlen( pszPassword ); 
            } 
 
            if ( pszDomain != NULL ) 
            { 
                AuthIdentity.Domain       = (unsigned char *) pszDomain; 
                AuthIdentity.DomainLength = strlen( pszDomain ); 
            } 
 
            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI; 
        } 
        else 
        { 
            pAuthIdentity = NULL; 
        } 
 
        ss = sfProcs.pAcquireCredentialsHandle( NULL,    // New principal 
                                       pszPackage,       // Package name 
                                       SECPKG_CRED_OUTBOUND, 
                                       NULL,             // Logon ID 
                                       pAuthIdentity,    // Auth Data 
                                       NULL,             // Get key func 
                                       NULL,             // Get key arg 
                                       &pAS->_hcred, 
                                       &Lifetime ); 
 
        // 
        //  Need to determine the max token size for this package 
        // 
 
        if ( ss == STATUS_SUCCESS ) 
        { 
            pAS->_fHaveCredHandle = TRUE; 
            ss = sfProcs.pQuerySecurityPackageInfo(  
                        (char *) pszPackage, 
                        &pspkg ); 
        } 
 
        if ( ss != STATUS_SUCCESS ) 
        { 
            SetLastError( ss ); 
            return FALSE; 
        } 
 
        pAS->_cbMaxToken = pspkg->cbMaxToken; 
 
        sfProcs.pFreeContextBuffer( pspkg ); 
 
    } 
 
    // 
    //  Prepare our output buffer.  We use a temporary buffer because 
    //  the real output buffer will most likely need to be uuencoded 
    // 
 
    if ( !BufferResize( &buff, pAS->_cbMaxToken )) 
    { 
        fSt = FALSE; 
        goto ex; 
    } 
 
    OutBuffDesc.ulVersion = 0; 
    OutBuffDesc.cBuffers  = 1; 
    OutBuffDesc.pBuffers  = &OutSecBuff; 
 
    OutSecBuff.cbBuffer   = pAS->_cbMaxToken; 
    OutSecBuff.BufferType = SECBUFFER_TOKEN; 
    OutSecBuff.pvBuffer   = BufferQueryPtr( &buff ); 
 
    // 
    //  Prepare our Input buffer - Note the server is expecting the client's 
    //  negotiation packet on the first call 
    // 
 
    if ( pBuffIn ) 
    { 
        InBuffDesc.ulVersion = 0; 
        InBuffDesc.cBuffers  = 1; 
        InBuffDesc.pBuffers  = &InSecBuff; 
 
        InSecBuff.cbBuffer   = cbBuffIn; 
        InSecBuff.BufferType = SECBUFFER_TOKEN; 
        InSecBuff.pvBuffer   = pBuffIn; 
    } 
 
    { 
        // 
        //  will return success when its done but we still 
        //  need to send the out buffer if there are bytes to send 
        // 
 
        ss = sfProcs.pInitializeSecurityContext(  
                                        &pAS->_hcred, 
                                        pAS->_fNewConversation ? NULL : 
                                                &pAS->_hctxt, 
                                        TOKEN_SOURCE_NAME, 
                                        0, 
                                        0, 
                                        SECURITY_NATIVE_DREP, 
                                        pAS->_fNewConversation ? NULL : 
                                                &InBuffDesc, 
                                        0, 
                                        &pAS->_hctxt, 
                                        &OutBuffDesc, 
                                        &ContextAttributes, 
                                        &Lifetime ); 
    } 
 
    if ( !SEC_SUCCESS( ss ) ) 
    { 
        if ( ss == SEC_E_LOGON_DENIED ) 
            ss = ERROR_LOGON_FAILURE; 
 
        SetLastError( ss ); 
        fSt = FALSE; 
        goto ex; 
    } 
 
    pAS->_fHaveCtxtHandle = TRUE; 
 
    // 
    //  Now we just need to complete the token (if requested) and prepare 
    //  it for shipping to the other side if needed 
    // 
 
    fReply = !!OutSecBuff.cbBuffer; 
 
    if ( (ss == SEC_I_COMPLETE_NEEDED) || 
         (ss == SEC_I_COMPLETE_AND_CONTINUE) ) 
    { 
        if ( sfProcs.pCompleteAuthToken != NULL ) 
        { 
            ss = sfProcs.pCompleteAuthToken( &pAS->_hctxt, 
                                    &OutBuffDesc ); 
 
            if ( !SEC_SUCCESS( ss )) 
            { 
                fSt = FALSE; 
                goto ex; 
            } 
        } 
        else 
        { 
            // if not supported 
 
            fSt = FALSE; 
            goto ex; 
        } 
    } 
 
    // 
    //  Format or copy to the output buffer if we need to reply 
    // 
 
    if ( fReply ) 
    { 
        if ( pAS->_fUUEncodeData ) 
        { 
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer, 
                            OutSecBuff.cbBuffer, 
                            pbuffOut )) 
            { 
                fSt = FALSE; 
                goto ex; 
            } 
 
            *pcbBuffOut = strlen( (CHAR *) BufferQueryPtr(pbuffOut) ); 
        } 
        else 
        { 
            if ( !BufferResize( pbuffOut, OutSecBuff.cbBuffer )) 
            { 
                fSt = FALSE; 
                goto ex; 
            } 
 
            memcpy( BufferQueryPtr(pbuffOut), 
                    OutSecBuff.pvBuffer, 
                    OutSecBuff.cbBuffer ); 
 
            *pcbBuffOut = OutSecBuff.cbBuffer; 
        } 
    } 
 
    if ( pAS->_fNewConversation ) 
        pAS->_fNewConversation = FALSE; 
 
    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) || 
                       (ss == SEC_I_COMPLETE_AND_CONTINUE)); 
 
    fSt = TRUE; 
 
ex: 
    BufferTerminate( &buffData ); 
    BufferTerminate( &buff ); 
 
    return fSt; 
} 
 
 
BOOL CrackUserAndDomain( 
    CHAR *   pszDomainAndUser, 
    CHAR * * ppszUser, 
    CHAR * * ppszDomain 
    ) 
/*++ 
 
Routine Description: 
 
    Given a user name potentially in the form domain\user, zero terminates 
    the domain name and returns pointers to the domain name and the user name 
 
Arguments: 
 
    pszDomainAndUser - Pointer to user name or domain and user name 
    ppszUser - Receives pointer to user portion of name 
    ppszDomain - Receives pointer to domain portion of name 
 
Return Value: 
 
    TRUE if successful, FALSE otherwise (call GetLastError) 
 
--*/ 
{ 
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1]; 
    DWORD cbN; 
 
    // 
    //  Crack the name into domain/user components. 
    // 
 
    *ppszDomain = pszDomainAndUser; 
    *ppszUser   = strpbrk( pszDomainAndUser, "/\\" ); 
 
    if( *ppszUser == NULL ) 
    { 
        // 
        //  No domain name specified, just the username so we assume the 
        //  user is on the local machine 
        // 
 
        if ( !*szDefaultDomain ) 
        { 
            cbN = sizeof(szDefaultDomain); 
            GetComputerName( szDefaultDomain, &cbN ); 
        } 
 
        *ppszDomain = szDefaultDomain; 
        *ppszUser   = pszDomainAndUser; 
    } 
    else 
    { 
        // 
        //  Both domain & user specified, skip delimiter. 
        // 
 
        **ppszUser = '\0'; 
        (*ppszUser)++; 
 
        if( ( **ppszUser == '\0' ) || 
            ( **ppszUser == '\\' ) || 
            ( **ppszUser == '/' ) ) 
        { 
            // 
            //  Name is of one of the following (invalid) forms: 
            // 
            //      "domain\" 
            //      "domain\\..." 
            //      "domain/..." 
            // 
 
            SetLastError( ERROR_INVALID_PARAMETER ); 
            return FALSE; 
        } 
    } 
 
    return TRUE; 
} 
 
 
/************************************************************ 
 *    uuencode/decode functions 
 ************************************************************/ 
 
// 
//  Taken from NCSA HTTP and wwwlib. 
// 
//  NOTE: These conform to RFC1113, which is slightly different then the Unix 
//        uuencode and uudecode! 
// 
 
const int pr2six[256]={ 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63, 
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9, 
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27, 
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64, 
    64,64,64,64,64,64,64,64,64,64,64,64,64 
}; 
 
char six2pr[64] = { 
    'A','B','C','D','E','F','G','H','I','J','K','L','M', 
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z', 
    'a','b','c','d','e','f','g','h','i','j','k','l','m', 
    'n','o','p','q','r','s','t','u','v','w','x','y','z', 
    '0','1','2','3','4','5','6','7','8','9','+','/' 
}; 
 
 
BOOL  
uudecode( 
    char   * bufcoded, 
    BUFFER * pbuffdecoded, 
    DWORD  * pcbDecoded ) 
/*++ 
 
 Routine Description: 
 
    uudecode a string of data 
 
 Arguments: 
 
    bufcoded            pointer to uuencoded data 
    pbuffdecoded        pointer to output BUFFER structure 
    pcbDecoded          number of decode bytes 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
    int nbytesdecoded; 
    char *bufin = bufcoded; 
    unsigned char *bufout; 
    int nprbytes; 
 
    /* Strip leading whitespace. */ 
 
    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++; 
 
    /* Figure out how many characters are in the input buffer. 
     * If this would decode into more bytes than would fit into 
     * the output buffer, adjust the number of input bytes downwards. 
     */ 
    bufin = bufcoded; 
    while(pr2six[*(bufin++)] <= 63); 
    nprbytes = bufin - bufcoded - 1; 
    nbytesdecoded = ((nprbytes+3)/4) * 3; 
 
    if ( !BufferResize( pbuffdecoded, nbytesdecoded + 4 )) 
        return FALSE; 
 
    if ( pcbDecoded ) 
        *pcbDecoded = nbytesdecoded; 
 
    bufout = (unsigned char *) BufferQueryPtr(pbuffdecoded); 
 
    bufin = bufcoded; 
 
    while (nprbytes > 0) { 
        *(bufout++) = 

(unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4); 
        *(bufout++) = 
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2); 
        *(bufout++) = 
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]); 
        bufin += 4; 
        nprbytes -= 4; 
    } 
 
    if(nprbytes & 03) { 
        if(pr2six[bufin[-2]] > 63) 
            nbytesdecoded -= 2; 
        else 
            nbytesdecoded -= 1; 
    } 
 
    ((CHAR *)BufferQueryPtr(pbuffdecoded))[nbytesdecoded] = '\0'; 
 
    return TRUE; 
} 
 
 
BOOL  
uuencode(  
    BYTE *   bufin, 
    DWORD    nbytes, 
    BUFFER * pbuffEncoded ) 
/*++ 
 
 Routine Description: 
 
    uuencode a string of data 
 
 Arguments: 
 
    bufin           pointer to data to encode 
    nbytes          number of bytes to encode 
    pbuffEncoded    pointer to output BUFFER structure 
 
 Return Value: 
 
    Returns TRUE is successful; otherwise FALSE is returned. 
 
--*/ 
{ 
   unsigned char *outptr; 
   unsigned int i; 
 
   // 
   //  Resize the buffer to 133% of the incoming data 
   // 
 
   if ( !BufferResize( pbuffEncoded, nbytes + ((nbytes + 3) / 3) + 4)) 
        return FALSE; 
 
   outptr = (unsigned char *) BufferQueryPtr(pbuffEncoded); 
 
   for (i=0; i<nbytes; i += 3) { 
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */ 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/ 
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/ 
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */ 
 
      bufin += 3; 
   } 
 
   /* If nbytes was not a multiple of 3, then we have encoded too 
    * many characters.  Adjust appropriately. 
    */ 
   if(i == nbytes+1) { 
      /* There were only 2 bytes in that last group */ 
      outptr[-1] = '='; 
   } else if(i == nbytes+2) { 
      /* There was only 1 byte in that last group */ 
      outptr[-1] = '='; 
      outptr[-2] = '='; 
   } 
 
   *outptr = '\0'; 
 
   return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( Crypto )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( Crypto ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\crypto_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 09:15:48 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\Crypto\source\Crypto.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ISimpleCrypt = {0x9E617656,0x36AE,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const IID LIBID_CRYPTOLib = {0x9E617648,0x36AE,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


const CLSID CLSID_SimpleCrypt = {0x9E617657,0x36AE,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\crypto.cpp ===
// Crypto.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Cryptops.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Crypto.h"

#include "Crypto_i.c"
#include "SimpleCrypt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SimpleCrypt, CSimpleCrypt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CRYPTOLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Crypto.rc
//
#define IDS_PROJNAME                    100
#define IDR_SIMPLECRYPT                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\crypto.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 09:15:48 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\Crypto\source\Crypto.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Crypto_h__
#define __Crypto_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISimpleCrypt_FWD_DEFINED__
#define __ISimpleCrypt_FWD_DEFINED__
typedef interface ISimpleCrypt ISimpleCrypt;
#endif 	/* __ISimpleCrypt_FWD_DEFINED__ */


#ifndef __SimpleCrypt_FWD_DEFINED__
#define __SimpleCrypt_FWD_DEFINED__

#ifdef __cplusplus
typedef class SimpleCrypt SimpleCrypt;
#else
typedef struct SimpleCrypt SimpleCrypt;
#endif /* __cplusplus */

#endif 	/* __SimpleCrypt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISimpleCrypt_INTERFACE_DEFINED__
#define __ISimpleCrypt_INTERFACE_DEFINED__

/* interface ISimpleCrypt */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISimpleCrypt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E617656-36AE-11D2-B605-00C04FB6F3A1")
    ISimpleCrypt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR bstrData,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR bstrEncrypted,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleCryptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleCrypt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleCrypt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Encrypt )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrData,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Decrypt )( 
            ISimpleCrypt __RPC_FAR * This,
            /* [in] */ BSTR bstrEncrypted,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } ISimpleCryptVtbl;

    interface ISimpleCrypt
    {
        CONST_VTBL struct ISimpleCryptVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleCrypt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleCrypt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleCrypt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleCrypt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISimpleCrypt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISimpleCrypt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISimpleCrypt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISimpleCrypt_Encrypt(This,bstrData,bstrKey,pVal)	\
    (This)->lpVtbl -> Encrypt(This,bstrData,bstrKey,pVal)

#define ISimpleCrypt_Decrypt(This,bstrEncrypted,bstrKey,pVal)	\
    (This)->lpVtbl -> Decrypt(This,bstrEncrypted,bstrKey,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISimpleCrypt_Encrypt_Proxy( 
    ISimpleCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrData,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISimpleCrypt_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISimpleCrypt_Decrypt_Proxy( 
    ISimpleCrypt __RPC_FAR * This,
    /* [in] */ BSTR bstrEncrypted,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ISimpleCrypt_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleCrypt_INTERFACE_DEFINED__ */



#ifndef __CRYPTOLib_LIBRARY_DEFINED__
#define __CRYPTOLib_LIBRARY_DEFINED__

/* library CRYPTOLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CRYPTOLib;

EXTERN_C const CLSID CLSID_SimpleCrypt;

#ifdef __cplusplus

class DECLSPEC_UUID("9E617657-36AE-11D2-B605-00C04FB6F3A1")
SimpleCrypt;
#endif
#endif /* __CRYPTOLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\crypto_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 09:15:48 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\Crypto\source\Crypto.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "Crypto.h"

#define TYPE_FORMAT_STRING_SIZE   57                                
#define PROC_FORMAT_STRING_SIZE   97                                

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISimpleCrypt, ver. 0.0,
   GUID={0x9E617656,0x36AE,0x11D2,{0xB6,0x05,0x00,0xC0,0x4F,0xB6,0xF3,0xA1}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISimpleCrypt_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short ISimpleCrypt_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    48
    };

static const MIDL_SERVER_INFO ISimpleCrypt_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISimpleCrypt_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISimpleCrypt_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISimpleCrypt_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _ISimpleCryptProxyVtbl = 
{
    &ISimpleCrypt_ProxyInfo,
    &IID_ISimpleCrypt,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISimpleCrypt::Encrypt */ ,
    (void *)-1 /* ISimpleCrypt::Decrypt */
};


static const PRPC_STUB_FUNCTION ISimpleCrypt_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISimpleCryptStubVtbl =
{
    &IID_ISimpleCrypt,
    &ISimpleCrypt_ServerInfo,
    9,
    &ISimpleCrypt_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows NT 5.0 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Encrypt */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrData */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 26 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 28 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKey */

/* 30 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 32 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 34 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter pVal */

/* 36 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 40 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Decrypt */

/* 48 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 56 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
/* 62 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 64 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 66 */	NdrFcShort( 0x1 ),	/* 1 */
/* 68 */	NdrFcShort( 0x2 ),	/* 2 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrEncrypted */

/* 72 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 74 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 76 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKey */

/* 78 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 82 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter pVal */

/* 84 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 86 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 88 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x4 ),	/* 4 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x6 ),	/* Offset= 6 (46) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (18) */
/* 46 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (42) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _Crypto_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISimpleCryptProxyVtbl,
    0
};

const CInterfaceStubVtbl * _Crypto_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISimpleCryptStubVtbl,
    0
};

PCInterfaceName const _Crypto_InterfaceNamesList[] = 
{
    "ISimpleCrypt",
    0
};

const IID *  _Crypto_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _Crypto_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _Crypto, pIID, n)

int __stdcall _Crypto_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_Crypto_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo Crypto_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _Crypto_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _Crypto_StubVtblList,
    (const PCInterfaceName * ) & _Crypto_InterfaceNamesList,
    (const IID ** ) & _Crypto_BaseIIDList,
    & _Crypto_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\simplecrypt.cpp ===
// SimpleCrypt.cpp : Implementation of CSimpleCrypt
#include "stdafx.h"
#include "Crypto.h"
#include "SimpleCrypt.h"


/////////////////////////////////////////////////////////////////////////////
// CSimpleCrypt
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSimpleCrypt::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = {&IID_ISimpleCrypt,};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;

    return S_FALSE;
}

///////////////////////////////////////
//The method encrypt bstrData and put the hex respresentation
// of encrypted data in pVal
////////////////////////////////////////
STDMETHODIMP CSimpleCrypt::Encrypt(BSTR bstrData, BSTR bstrKey, BSTR *pVal)
{
	USES_CONVERSION;
	BYTE* pbData;
	DWORD dwDataLen;
	TCHAR str[256];
	DWORD dwErr;


	// Initialize Key
	
	if (InitKeys(bstrKey))
	{
		wsprintf(str, "InitKey failed!");
		Error(str, IID_ISimpleCrypt);
		return E_FAIL;
	}
	
	//Encrypt Data
	
	dwDataLen = CComBSTR(bstrData).Length();
	pbData = (BYTE*) malloc(dwDataLen+1);
	lstrcpy((char*)pbData,W2A(bstrData));
	if (!CryptEncrypt(m_hKey, 0, TRUE , 0, pbData, &dwDataLen, dwDataLen+1))
	{
		dwErr =GetLastError();
		wsprintf(str, "CryptEncrypt failed!");
		Error(str, IID_ISimpleCrypt);
		return E_FAIL;
	}

	//Return  to HEX representation
	ToHex(pbData, dwDataLen, pVal);

	return S_OK;
}


/////////////////////////////////////////////////////
// the method takes hex representation of encrypted data
// first convert it to binary representation and decrypt it, 
// finally return the decrypted data
/////////////////////////////////////////////////////
STDMETHODIMP CSimpleCrypt::Decrypt(BSTR bstrEncrypted, BSTR bstrKey, BSTR *pVal)
{

	USES_CONVERSION;
	BYTE* pbData;
	DWORD dwDataLen;
	TCHAR str[256];
	DWORD dwErr;

	// initialize Key
	
	if (InitKeys(bstrKey))
	{
		wsprintf(str, "InitKey failed!");
		Error(str, IID_ISimpleCrypt);
		return E_FAIL;
	}
	
	// convert bstrEncrypted to binary representation

	CComBSTR bstrTmp(bstrEncrypted);
	dwDataLen =bstrTmp.Length() /2;
	pbData = (BYTE*) malloc(dwDataLen +1);
	if (pbData == NULL)
	{
		return E_OUTOFMEMORY;
	}

	if (!ToBinary(bstrTmp, pbData, dwDataLen))
	{
		free(pbData);
		wsprintf(str, "ToBinary() failed!");
		Error(str, IID_ISimpleCrypt);
		return E_FAIL;
	}

	// decrypt
	
	if(!CryptDecrypt (m_hKey, 0, TRUE, 0, pbData, &dwDataLen))
	{
		free(pbData);
		dwErr =GetLastError();
		wsprintf(str, "CryptDecrypt failed!");
		Error(str, IID_ISimpleCrypt);
		return E_FAIL;
	}

	// convert the decrypted data to BSTR

	*pVal = CComBSTR(dwDataLen+1, (LPCSTR)pbData).Copy();
	return S_OK;
}


HRESULT CSimpleCrypt::FinalConstruct()
{
	DWORD dwErr = 0;
	TCHAR str[256];
	
	// initialize member variables

	m_dwKeySize =0;
	m_hKey		=NULL;
	m_hKeyHash	=NULL;
	m_hProv		=NULL;

	
	if (!CryptAcquireContext(&m_hProv, 
							NULL,
                            NULL, 
                            PROV_RSA_FULL, 
                            0))
	{
		dwErr = GetLastError();
		if (dwErr == NTE_BAD_KEYSET)
		{
			dwErr=0;
			if (!CryptAcquireContext(&m_hProv, 
								NULL,
								NULL, 
								PROV_RSA_FULL, 
								CRYPT_NEWKEYSET))
			{
				dwErr = GetLastError();
				wsprintf(str, "CryptAcquireContext failed! Error.Number is %x", dwErr);
				Error(str, IID_ISimpleCrypt);
				return E_FAIL;
		
			}
		}
		else
		{
				wsprintf(str, "Could not create Key Set! GetLastError %x", dwErr);
				Error(str, IID_ISimpleCrypt);
				return E_FAIL;

		}

	}

	return dwErr;
}

HRESULT CSimpleCrypt::FinalRelease()
{
	// clean up  handles 
    if (m_hKeyHash != NULL) CryptDestroyHash(m_hKeyHash);
    if (m_hKey != NULL) CryptDestroyKey(m_hKey);
    if (m_hProv!=NULL)    CryptReleaseContext(m_hProv, 0);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
DWORD CSimpleCrypt::InitKeys(BSTR bstrKey)
{

    // clean up any old handles first
    if (m_hKeyHash != NULL) CryptDestroyHash(m_hKeyHash);
    if (m_hKey != NULL) CryptDestroyKey(m_hKey);

    // generate a new key from key material provided in m_bstrKey
    // this requires making a hash first, we'll use md5
    if (!CryptCreateHash(m_hProv,CALG_MD5,0,0,&m_hKeyHash))
        return GetLastError();
	
	CComBSTR bstrTmp(bstrKey);
	if (bstrTmp.Length() == 0)
		return ERROR_INVALID_DATA;

    if (!CryptHashData(m_hKeyHash,(LPBYTE)bstrTmp.m_str,bstrTmp.Length()*2,0))
        return GetLastError();

    if (!CryptDeriveKey(m_hProv,CALG_RC4,m_hKeyHash,0,&m_hKey))
        return GetLastError();

    return ERROR_SUCCESS;
}


void CSimpleCrypt::ToHex(BYTE* pbData, DWORD dwDataLen, BSTR* pHexRep)
{
	DWORD i;
	CComBSTR bstrHex;
	char strTmp[16];
	for (i =0; i < dwDataLen; i++)
	{
		sprintf(strTmp,"%02x", pbData[i]);
		bstrHex.Append(strTmp);
	}
	*pHexRep = bstrHex.Copy();
	return ;
}

BOOL CSimpleCrypt::ToBinary(CComBSTR bstrHexRep, BYTE* pbData, DWORD dwDataLen)
{
	DWORD i, j;
	BYTE  hi, lo;
	
	if (bstrHexRep.Length() > dwDataLen*2 )
		return FALSE;


	for (i=0, j=0; i < bstrHexRep.Length(); j++, i=i+2)
	{
		hi=(BYTE)bstrHexRep[i];
		if(!ToBinary(hi))
			return FALSE;
		lo=(BYTE)bstrHexRep[i+1];
		if(!ToBinary(lo))
			return FALSE;
		
		pbData[j] = (hi<<4) + lo;
	}

	return TRUE;

}

/////////////////////////////
BOOL CSimpleCrypt::ToBinary(BYTE& hexVal)
{
	if (hexVal >='0' && hexVal <='9')
		hexVal=hexVal-'0';
	else if (hexVal >='a' &&  hexVal <='f')
		hexVal=hexVal-'a'+10;
	else if (hexVal >='A' &&  hexVal <='F')
		hexVal=hexVal-'A'+10;
	else
		return FALSE;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\simplecrypt.h ===
// SimpleCrypt.h : Declaration of the CSimpleCrypt

#ifndef __SIMPLECRYPT_H_
#define __SIMPLECRYPT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimpleCrypt
class ATL_NO_VTABLE CSimpleCrypt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSimpleCrypt, &CLSID_SimpleCrypt>,
	public ISupportErrorInfo,
	public IDispatchImpl<ISimpleCrypt, &IID_ISimpleCrypt, &LIBID_CRYPTOLib>
{
public:
	CSimpleCrypt()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SIMPLECRYPT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSimpleCrypt)
	COM_INTERFACE_ENTRY(ISimpleCrypt)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	HRESULT FinalConstruct();	
	HRESULT FinalRelease();

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
// ISimpleCrypt
public:
	STDMETHOD(Decrypt)(/*[in]*/BSTR bstrEncrypted, /*[in]*/BSTR bstrKey, /*[out, retval]*/ BSTR* pVal);
	STDMETHOD(Encrypt)(/*[in]*/BSTR bstrData, /*[in]*/BSTR bstrKey, /*[out, retval]*/ BSTR* pVal);

private:
	DWORD       InitKeys(BSTR bstrKey);
	void		ToHex(BYTE* pbData, DWORD dwDataLen, BSTR* pHexRep);
	BOOL		ToBinary(CComBSTR bstrHexRep, BYTE* pbData, DWORD dwDataLen);
	BOOL		ToBinary(BYTE& hexVal);
    HCRYPTPROV  m_hProv;
    HCRYPTHASH  m_hKeyHash;
    HCRYPTKEY   m_hKey;
    DWORD       m_dwKeySize;
};

#endif //__SIMPLECRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\crypto\source\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9E61764D_36AE_11D2_B605_00C04FB6F3A1__INCLUDED_)
#define AFX_STDAFX_H__9E61764D_36AE_11D2_B605_00C04FB6F3A1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9E61764D_36AE_11D2_B605_00C04FB6F3A1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\context.cpp ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module	Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics

	Author:

		Neil Allain   ( a-neilal )	   August-1997 

	Revision History:

--*/
#include "stdafx.h"
#include <asptlb.h>
#include "context.h"


//---------------------------------------------------------------------------
//	GetServerObject
//
//	Get an instrinic object from the current Object context
//---------------------------------------------------------------------------
HRESULT
CContext::GetServerObject(
	IGetContextProperties*	pProps,
	BSTR					bstrObjName,
	const IID&				iid,
	void**					ppObj
)
{
	HRESULT rc = E_FAIL;
	_ASSERT( pProps );
	_ASSERT( bstrObjName );
	_ASSERT( ppObj );
	if ( pProps && bstrObjName && ppObj )
	{
		*ppObj = NULL;
		CComVariant vt;
		if ( !FAILED( pProps->GetProperty( bstrObjName, &vt ) ) )
		{
			if ( V_VT(&vt) == VT_DISPATCH )
			{
				IDispatch* pDispatch = V_DISPATCH(&vt);
				if ( pDispatch )
				{
					rc = pDispatch->QueryInterface( iid, ppObj );
				}
			}
		}
	}
	return rc;
}


HRESULT
CContext::Init(
	DWORD	dwFlags // which instrinsics to initialize
)
{
	HRESULT rc = E_FAIL;
	CComPtr<IObjectContext> pObjContext;

	rc = ::GetObjectContext( &pObjContext );
	if ( !FAILED( rc ) )
	{
		CComPtr<IGetContextProperties> pProps;
		rc = pObjContext->QueryInterface( IID_IGetContextProperties, (void**)&pProps );
		if ( !FAILED( rc ) )
		{
			CComBSTR bstrObj;
			if ( dwFlags & get_Request )
			{
				bstrObj = "Request";
				rc = GetServerObject( pProps, bstrObj, IID_IRequest, (void**)&m_piRequest );
			}
			if ( !FAILED(rc) && ( dwFlags & get_Response ) )
			{
				bstrObj = "Response";
				rc = GetServerObject( pProps, bstrObj, IID_IResponse, (void**)&m_piResponse );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Session ) )
			{
				bstrObj = "Session";
				rc = GetServerObject( pProps, bstrObj, IID_ISessionObject, (void**)&m_piSession );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Server ) )
			{
				bstrObj = "Server";
				rc = GetServerObject( pProps, bstrObj, IID_IServer, (void**)&m_piServer );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Application ) )
			{
				bstrObj = "Application";
				rc = GetServerObject( pProps, bstrObj, IID_IApplicationObject, (void**)&m_piApplication );
			}
		}
	}
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\catlpwr.cpp ===
// CATLPwr.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CATLPwrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CATLPwr.h"
#include "Power.h"

#define IID_DEFINED
#include "CATLPwr_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CPower, CPower)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\context.h ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module  Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics.  This class encapsulates the new way
		of getting access to ASP instinsic objects.  It does away with the need for OnStartPage
		and OnEndPage methods, and, by doing so, gives Application scope objects access to the
		intrinsics.  The intrincis should never be retained across calls, as the context may
		change between calls.

	Author:

		Neil Allain	     August-1997 

	Revision History:

--*/
#pragma once
#ifndef _CONTEXT_H_
#define _CONTEXT_H_

class CContext
{
public:
	enum {
		get_Server		= 0x0001,
		get_Response	= 0x0002,
		get_Request		= 0x0004,
		get_Session		= 0x0008,
		get_Application	= 0x0010,
        get_All         = 0xFFFF
	};
	
	HRESULT	            Init( DWORD );

	IRequest*			Request(){ _ASSERT(m_piRequest!=NULL); return m_piRequest; }
	IResponse*			Response(){ _ASSERT(m_piResponse!=NULL); return m_piResponse; }
	ISessionObject*		Session(){ _ASSERT(m_piSession!=NULL); return m_piSession; }
	IServer*			Server(){ _ASSERT(m_piServer!=NULL); return m_piServer; }
	IApplicationObject*	Application(){ _ASSERT(m_piApplication!=NULL); return m_piApplication; }

	static HRESULT		GetServerObject( IGetContextProperties*, BSTR, const IID&, void** );

private:
	CComPtr<IRequest>			m_piRequest;			//Request Object
	CComPtr<IResponse>			m_piResponse;			//Response Object
	CComPtr<ISessionObject>		m_piSession;			//Session Object
	CComPtr<IServer>			m_piServer;				//Server Object
	CComPtr<IApplicationObject> m_piApplication;		//Application Object
};


#endif	// !_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\power.cpp ===
// Power.cpp : Implementation of CCATLPwrApp and DLL registration.

#include "stdafx.h"
#include "CATLPwr.h"
#include "Power.h"
#include "context.h"
/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPower::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPower,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

// Ctor
CPower::CPower()
    : m_bstrMyProperty(OLESTR("C++ ATL Power Component"))
{}

// Get function for myProperty
STDMETHODIMP CPower::get_myProperty(BSTR* pbstrOutValue)
{
    if (pbstrOutValue == NULL)
        return E_POINTER;

    // Get Value from Property
    *pbstrOutValue = m_bstrMyProperty.Copy();
    
    return S_OK;
}

// Put function for myProperty
STDMETHODIMP CPower::put_myProperty(BSTR bstrInValue)
{
    if (bstrInValue == NULL)
        return E_POINTER;

    m_bstrMyProperty = bstrInValue;

    return S_OK;
}

// Basic Method which Converts bstrIn to Upper Case
STDMETHODIMP CPower::myMethod(BSTR bstrIn, BSTR* pbstrOut)  
{
    if (bstrIn == NULL || pbstrOut == NULL)
        return E_POINTER;

    // Create a temporary CComBSTR
    CComBSTR bstrTemp(bstrIn);

    if (!bstrTemp)
        return E_OUTOFMEMORY;

    // Make string uppercase   
    wcsupr(bstrTemp);  
    
    // Return m_str member of bstrTemp
    *pbstrOut = bstrTemp.Detach();

    return S_OK;
}


///////////// ASP-Specific Component Methods ////////////////

// Get Function Returns the Name of the Current Script
STDMETHODIMP CPower::get_myPowerProperty(BSTR* pbstrOutValue)
{
	// the Context class is an easy way to use IIS 4's new way
	// of getting instrinic objects.  The new method may seem
	// more complex, but it is more powerful since obects no
	// longer have to be page/session level to get access
	// to them.
	CContext cxt;
	if ( FAILED( cxt.Init( CContext::get_Request ) ) )
	{
		return E_FAIL;
	}

	// Do we have somewhere valid to store the return value?
	if (pbstrOutValue == NULL)
		return E_POINTER;

	// Initialize the return value
	*pbstrOutValue = NULL;

	// Get the ServerVariables Collection
	CComPtr<IRequestDictionary> piServerVariables;
	HRESULT hr = cxt.Request()->get_ServerVariables(&piServerVariables);

    if (FAILED(hr))
        return hr;

    // Get the SCRIPT_NAME item from the ServerVariables collection
    CComVariant vtIn(OLESTR("SCRIPT_NAME")), vtOut;
    hr = piServerVariables->get_Item(vtIn, &vtOut);

    if (FAILED(hr))
        return hr;

    // Get the SCRIPT_NAME item from the ServerVariables collection
    // vtOut Contains an IDispatch Pointer.  To fetch the value
    // for SCRIPT_NAME, you must get the Default Value for the 
    // Object stored in vtOut using VariantChangeType.
    hr = VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);

    // Copy and return SCRIPT_NAME
    if (SUCCEEDED(hr))
        *pbstrOutValue = ::SysAllocString(V_BSTR(&vtOut));
    
    return hr;
}

// ASP-specific Power Method
STDMETHODIMP CPower::myPowerMethod()  
{
	CContext cxt;
	if ( FAILED( cxt.Init( CContext::get_Request | CContext::get_Response ) ) )
	{
		return E_FAIL;
	}

    // Get the ServerVariables Collection
    CComPtr<IRequestDictionary> piServerVariables;
    HRESULT hr = cxt.Request()->get_ServerVariables(&piServerVariables);

    if (FAILED(hr))
        return hr;

    // Get the HTTP_USER_AGENT item from the ServerVariables collection
    CComVariant vtIn(OLESTR("HTTP_USER_AGENT")), vtOut;
    hr = piServerVariables->get_Item(vtIn, &vtOut);

    if (FAILED(hr))
        return hr;

    // vtOut Contains an IDispatch Pointer.  To fetch the value
    // for HTTP_USER_AGENT, you must get the Default Value for the 
    // Object stored in vtOut using VariantChangeType.
    hr = VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);

    if (SUCCEEDED(hr))
    { 
        // Look for "MSIE" in HTTP_USER_AGENT string
        if (wcsstr(vtOut.bstrVal, L"MSIE") != NULL)
            cxt.Response()->Write(CComVariant(
                OLESTR("You are using a very powerful browser."))); 
        else
            cxt.Response()->Write(CComVariant(
                OLESTR("Try Internet Explorer today!")));
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\power.h ===
// Power.h : Declaration of the CPower


#include "resource.h"       // main symbols

#include <asptlb.h>         // ASP Definitions

// 'asptlb.h' is installed with Active Server Pages.  Either copy it
// to your Include directory or add the appropriate directory to your
// Include Path.

/////////////////////////////////////////////////////////////////////////////
// CATLPwr

class CPower : 
    public CComDualImpl<IPower, &IID_IPower, &LIBID_CATLPwr>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CPower,&CLSID_CPower>
{
public:
    CPower();
BEGIN_COM_MAP(CPower)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPower)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPower) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CPower, _T("IISSample.C++ATLPower.1"), _T("IISSample.C++ATLPower"), IDS_POWER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPower
public:
	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalCountruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

    STDMETHOD(get_myProperty)(BSTR* pbstrOutValue);
    STDMETHOD(put_myProperty)(BSTR bstrInValue);
    STDMETHOD(myMethod)(BSTR bstrIn, BSTR* pbstrOut);

    // ASP-specific Property and Method
    STDMETHOD(get_myPowerProperty)(BSTR* pbstrOutValue);
    STDMETHOD(myPowerMethod)();

private:
	CComPtr<IUnknown>			m_pUnkMarshaler;
    CComBSTR                    m_bstrMyProperty;     // myProperty
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CATLPwr.rc
//
#define IDS_POWER_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\intermediate\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
#include <mtx.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\account.cpp ===
// Account.cpp : Implementation of CAccount
#include "stdafx.h"
#include "BankVC.h"
#include "Account.h"
#include "CreateTable.h"

extern CComBSTR CONNECTION;
	

/////////////////////////////////////////////////////////////////////////////
// CAccount

STDMETHODIMP CAccount::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IAccount
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CAccount::Post(long lngAccntNum, long lngAmount, BSTR *pVal)
{
	// Get the ObjectContext object
	HRESULT hr;
	TCHAR strErr[256];
	_ConnectionPtr pConnection;
	_RecordsetPtr  pRecordset = NULL;
	FieldsPtr pFields;
	FieldPtr pField;
	CComVariant vntValue;
	CComBSTR bstrSQL;
	CComPtr<IObjectContext> pObjectContext=NULL;
	CComPtr<ICreateTable> pCreateTable;
	BOOL bFatal=FALSE;
	


	
	hr = GetObjectContext(&pObjectContext);
	if(FAILED(hr))
	{
		wsprintf(strErr,"GetObjectContext() failed!");
		goto ErrorHandler;
	}

	// Create ADODB.Connection object 

	hr = pConnection.CreateInstance("ADODB.Connection.1");
	if(FAILED(hr))
	{
		wsprintf(strErr,"Failed to Create ADODB.Connection object!");
		goto ErrorHandler;
	}

	// Open ODBC connection

	hr = pConnection->Open(CONNECTION,NULL, NULL);
	if(FAILED(hr))
	{
		wsprintf(strErr,"Open connection failed!");
		goto ErrorHandler;
	}

	//Execute Update SQL statement
	
	wsprintf(strErr, "Update Account Set "  
			"Balance = Balance + %d where AccountNo = %d",lngAmount, lngAccntNum);
	bstrSQL = CComBSTR(strErr);

TryAgain:	
	
	hr=pConnection->Execute(bstrSQL, static_cast<VARIANT*> (&vtMissing), 
			adCmdText, &pRecordset);
	if(FAILED(hr))
		goto ErrorCreateTable;
	wsprintf(strErr, "Select Balance from Account where AccountNo = %d", lngAccntNum);
	bstrSQL=CComBSTR(strErr);

	//Get current balance
	hr=pConnection->Execute(bstrSQL, static_cast<VARIANT*> (&vtMissing),
			adCmdText, &pRecordset);

	if (FAILED(hr))
	{
		wsprintf(strErr, "Unable to obtain balance for Account %d", lngAccntNum);
		goto ErrorHandler;
	}

	pRecordset->get_Fields(&pFields);
	pFields->get_Item(CComVariant(L"Balance"), &pField);
	pField->get_Value( &vntValue);
	
	//If the current balance is less than 0, abort transaction 
	//otherwise complete transaction

	if (vntValue.lVal <0)
	{
		wsprintf(strErr, "Not enough fund to withdraw");
		goto ErrorHandler;
	}

	wsprintf (strErr, "%s account %ld, balance is $%ld. (VC++)",
			((lngAmount >= 0) ? "Credit to" : "Debit from"), lngAmount, vntValue.lVal);

	*pVal = CComBSTR(strErr).Copy();

	pObjectContext->SetComplete();
	return S_OK;

ErrorCreateTable:
	
	// first pass OK, but not second;
	
	if(bFatal==TRUE)
		goto ErrorHandler;
	bFatal=TRUE;

	//create a CreateTable object

	hr = pObjectContext->CreateInstance(CLSID_CreateTable,
    IID_ICreateTable, (void**)&pCreateTable);
	if (FAILED(hr))
		goto ErrorHandler;
	hr = pCreateTable->CreateAccount();
	if (FAILED(hr))
		goto ErrorHandler;
	goto TryAgain;

ErrorHandler:
	Error(strErr,IID_IAccount );
	if (pObjectContext)pObjectContext->SetAbort();	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\account.h ===
// Account.h : Declaration of the CAccount

#ifndef __ACCOUNT_H_
#define __ACCOUNT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAccount
class ATL_NO_VTABLE CAccount : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccount, &CLSID_Account>,
	public ISupportErrorInfo,
	public IDispatchImpl<IAccount, &IID_IAccount, &LIBID_BANKVCLib>
{
public:
	CAccount()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ACCOUNT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccount)
	COM_INTERFACE_ENTRY(IAccount)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IAccount
public:
	STDMETHOD(Post)(/*[in]*/ long lngAccntNum, /*[in]*/ long lngAmount, /*[out, retval]*/ BSTR* pVal);
};

#endif //__ACCOUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\bankvc.cpp ===
// BankVC.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f BankVCps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "BankVC.h"

#include "BankVC_i.c"
#include "Account.h"
#include "CreateTable.h"
#include "MoveMoney.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Account, CAccount)
OBJECT_ENTRY(CLSID_CreateTable, CCreateTable)
OBJECT_ENTRY(CLSID_MoveMoney, CMoveMoney)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_BANKVCLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\bankvc_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 11:09:17 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\MTXSample\source\BankVC.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAccount = {0x5A67AADF,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const IID IID_ICreateTable = {0x5A67AAE1,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const IID IID_IMoveMoney = {0x5A67AAE3,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const IID LIBID_BANKVCLib = {0x5A67AAD3,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const CLSID CLSID_Account = {0x5A67AAE0,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const CLSID CLSID_CreateTable = {0x5A67AAE2,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


const CLSID CLSID_MoveMoney = {0x5A67AAE4,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\bankvc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 11:09:17 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\MTXSample\source\BankVC.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __BankVC_h__
#define __BankVC_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAccount_FWD_DEFINED__
#define __IAccount_FWD_DEFINED__
typedef interface IAccount IAccount;
#endif 	/* __IAccount_FWD_DEFINED__ */


#ifndef __ICreateTable_FWD_DEFINED__
#define __ICreateTable_FWD_DEFINED__
typedef interface ICreateTable ICreateTable;
#endif 	/* __ICreateTable_FWD_DEFINED__ */


#ifndef __IMoveMoney_FWD_DEFINED__
#define __IMoveMoney_FWD_DEFINED__
typedef interface IMoveMoney IMoveMoney;
#endif 	/* __IMoveMoney_FWD_DEFINED__ */


#ifndef __Account_FWD_DEFINED__
#define __Account_FWD_DEFINED__

#ifdef __cplusplus
typedef class Account Account;
#else
typedef struct Account Account;
#endif /* __cplusplus */

#endif 	/* __Account_FWD_DEFINED__ */


#ifndef __CreateTable_FWD_DEFINED__
#define __CreateTable_FWD_DEFINED__

#ifdef __cplusplus
typedef class CreateTable CreateTable;
#else
typedef struct CreateTable CreateTable;
#endif /* __cplusplus */

#endif 	/* __CreateTable_FWD_DEFINED__ */


#ifndef __MoveMoney_FWD_DEFINED__
#define __MoveMoney_FWD_DEFINED__

#ifdef __cplusplus
typedef class MoveMoney MoveMoney;
#else
typedef struct MoveMoney MoveMoney;
#endif /* __cplusplus */

#endif 	/* __MoveMoney_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAccount_INTERFACE_DEFINED__
#define __IAccount_INTERFACE_DEFINED__

/* interface IAccount */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5A67AADF-37DA-11D2-955A-004005A2F9B1")
    IAccount : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Post( 
            /* [in] */ long lngAccntNum,
            /* [in] */ long lngAmount,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAccount __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAccount __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAccount __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Post )( 
            IAccount __RPC_FAR * This,
            /* [in] */ long lngAccntNum,
            /* [in] */ long lngAmount,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IAccountVtbl;

    interface IAccount
    {
        CONST_VTBL struct IAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccount_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAccount_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAccount_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAccount_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAccount_Post(This,lngAccntNum,lngAmount,pVal)	\
    (This)->lpVtbl -> Post(This,lngAccntNum,lngAmount,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAccount_Post_Proxy( 
    IAccount __RPC_FAR * This,
    /* [in] */ long lngAccntNum,
    /* [in] */ long lngAmount,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAccount_Post_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccount_INTERFACE_DEFINED__ */


#ifndef __ICreateTable_INTERFACE_DEFINED__
#define __ICreateTable_INTERFACE_DEFINED__

/* interface ICreateTable */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICreateTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5A67AAE1-37DA-11D2-955A-004005A2F9B1")
    ICreateTable : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAccount( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICreateTable __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICreateTable __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICreateTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICreateTable __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccount )( 
            ICreateTable __RPC_FAR * This);
        
        END_INTERFACE
    } ICreateTableVtbl;

    interface ICreateTable
    {
        CONST_VTBL struct ICreateTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTable_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICreateTable_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICreateTable_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICreateTable_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICreateTable_CreateAccount(This)	\
    (This)->lpVtbl -> CreateAccount(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICreateTable_CreateAccount_Proxy( 
    ICreateTable __RPC_FAR * This);


void __RPC_STUB ICreateTable_CreateAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTable_INTERFACE_DEFINED__ */


#ifndef __IMoveMoney_INTERFACE_DEFINED__
#define __IMoveMoney_INTERFACE_DEFINED__

/* interface IMoveMoney */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMoveMoney;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5A67AAE3-37DA-11D2-955A-004005A2F9B1")
    IMoveMoney : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Perform( 
            /* [in] */ long lngAcnt1,
            /* [in] */ long lngAcnt2,
            /* [in] */ long lngAmount,
            /* [in] */ long lngType,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMoveMoneyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMoveMoney __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMoveMoney __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMoveMoney __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMoveMoney __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMoveMoney __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMoveMoney __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMoveMoney __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Perform )( 
            IMoveMoney __RPC_FAR * This,
            /* [in] */ long lngAcnt1,
            /* [in] */ long lngAcnt2,
            /* [in] */ long lngAmount,
            /* [in] */ long lngType,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IMoveMoneyVtbl;

    interface IMoveMoney
    {
        CONST_VTBL struct IMoveMoneyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMoveMoney_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMoveMoney_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMoveMoney_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMoveMoney_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMoveMoney_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMoveMoney_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMoveMoney_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMoveMoney_Perform(This,lngAcnt1,lngAcnt2,lngAmount,lngType,pVal)	\
    (This)->lpVtbl -> Perform(This,lngAcnt1,lngAcnt2,lngAmount,lngType,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMoveMoney_Perform_Proxy( 
    IMoveMoney __RPC_FAR * This,
    /* [in] */ long lngAcnt1,
    /* [in] */ long lngAcnt2,
    /* [in] */ long lngAmount,
    /* [in] */ long lngType,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMoveMoney_Perform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMoveMoney_INTERFACE_DEFINED__ */



#ifndef __BANKVCLib_LIBRARY_DEFINED__
#define __BANKVCLib_LIBRARY_DEFINED__

/* library BANKVCLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_BANKVCLib;

EXTERN_C const CLSID CLSID_Account;

#ifdef __cplusplus

class DECLSPEC_UUID("5A67AAE0-37DA-11D2-955A-004005A2F9B1")
Account;
#endif

EXTERN_C const CLSID CLSID_CreateTable;

#ifdef __cplusplus

class DECLSPEC_UUID("5A67AAE2-37DA-11D2-955A-004005A2F9B1")
CreateTable;
#endif

EXTERN_C const CLSID CLSID_MoveMoney;

#ifdef __cplusplus

class DECLSPEC_UUID("5A67AAE4-37DA-11D2-955A-004005A2F9B1")
MoveMoney;
#endif
#endif /* __BANKVCLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\bankvc_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Nov 16 11:09:17 2000
 */
/* Compiler settings for N:\JanetFi\WorkingFolder\iis5.x\samples\psdksamp\components\cpp\MTXSample\source\BankVC.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "BankVC.h"

#define TYPE_FORMAT_STRING_SIZE   43                                
#define PROC_FORMAT_STRING_SIZE   139                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAccount, ver. 0.0,
   GUID={0x5A67AADF,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IAccount_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short IAccount_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_SERVER_INFO IAccount_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IAccount_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IAccount_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IAccount_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(8) _IAccountProxyVtbl = 
{
    &IAccount_ProxyInfo,
    &IID_IAccount,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IAccount::Post */
};


static const PRPC_STUB_FUNCTION IAccount_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IAccountStubVtbl =
{
    &IID_IAccount,
    &IAccount_ServerInfo,
    8,
    &IAccount_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: ICreateTable, ver. 0.0,
   GUID={0x5A67AAE1,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICreateTable_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ICreateTable_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    48
    };

static const MIDL_SERVER_INFO ICreateTable_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICreateTable_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICreateTable_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICreateTable_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(8) _ICreateTableProxyVtbl = 
{
    &ICreateTable_ProxyInfo,
    &IID_ICreateTable,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ICreateTable::CreateAccount */
};


static const PRPC_STUB_FUNCTION ICreateTable_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _ICreateTableStubVtbl =
{
    &IID_ICreateTable,
    &ICreateTable_ServerInfo,
    8,
    &ICreateTable_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IMoveMoney, ver. 0.0,
   GUID={0x5A67AAE3,0x37DA,0x11D2,{0x95,0x5A,0x00,0x40,0x05,0xA2,0xF9,0xB1}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IMoveMoney_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short IMoveMoney_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    78
    };

static const MIDL_SERVER_INFO IMoveMoney_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IMoveMoney_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IMoveMoney_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IMoveMoney_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(8) _IMoveMoneyProxyVtbl = 
{
    &IMoveMoney_ProxyInfo,
    &IID_IMoveMoney,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IMoveMoney::Perform */
};


static const PRPC_STUB_FUNCTION IMoveMoney_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IMoveMoneyStubVtbl =
{
    &IID_IMoveMoney,
    &IMoveMoney_ServerInfo,
    8,
    &IMoveMoney_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows NT 5.0 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Post */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lngAccntNum */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 26 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lngAmount */

/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 32 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 36 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 40 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateAccount */

/* 48 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 56 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
/* 62 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 64 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 74 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Perform */

/* 78 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 86 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 88 */	NdrFcShort( 0x20 ),	/* 32 */
/* 90 */	NdrFcShort( 0x8 ),	/* 8 */
/* 92 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 94 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 96 */	NdrFcShort( 0x1 ),	/* 1 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lngAcnt1 */

/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lngAcnt2 */

/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 110 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lngAmount */

/* 114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lngType */

/* 120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 122 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 126 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 128 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 130 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 134 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
/*  6 */	
			0x13, 0x0,	/* FC_OP */
/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 20 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 22 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
/* 26 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (10) */
/* 28 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 30 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 32 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (6) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _BankVC_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IAccountProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICreateTableProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IMoveMoneyProxyVtbl,
    0
};

const CInterfaceStubVtbl * _BankVC_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IAccountStubVtbl,
    ( CInterfaceStubVtbl *) &_ICreateTableStubVtbl,
    ( CInterfaceStubVtbl *) &_IMoveMoneyStubVtbl,
    0
};

PCInterfaceName const _BankVC_InterfaceNamesList[] = 
{
    "IAccount",
    "ICreateTable",
    "IMoveMoney",
    0
};

const IID *  _BankVC_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _BankVC_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _BankVC, pIID, n)

int __stdcall _BankVC_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _BankVC, 3, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _BankVC, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _BankVC, 3, *pIndex )
    
}

const ExtendedProxyFileInfo BankVC_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _BankVC_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _BankVC_StubVtblList,
    (const PCInterfaceName * ) & _BankVC_InterfaceNamesList,
    (const IID ** ) & _BankVC_BaseIIDList,
    & _BankVC_IID_Lookup, 
    3,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\createtable.cpp ===
// CreateTable.cpp : Implementation of CCreateTable
#include "stdafx.h"
#include "BankVC.h"
#include "CreateTable.h"

CComBSTR CONNECTION	("FILEDSN=IISSAMPLE");


char szSQL[]		=	"If not exists (Select name from sysobjects where name = 'Account' )\n" \
					"BEGIN \n" \
					"CREATE TABLE dbo.Account( \n" \
					"AccountNo int NOT NULL,\n"\
					"Balance int NULL,\n" \
					"CONSTRAINT PK__1_10 PRIMARY KEY CLUSTERED (AccountNo)\n)\n" \
					"Insert into Account Values (1, 1000) \n" \
					"Insert into Account Values (2, 1000) \n" \
					"END";

/////////////////////////////////////////////////////////////////////////////
// CCreateTable

STDMETHODIMP CCreateTable::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICreateTable
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CCreateTable::CreateAccount()
{
	// Get the ObjectContext object
	HRESULT hr;
	TCHAR strErr[512];
	_ConnectionPtr pConnection;
	_RecordsetPtr  pRecordset = NULL;
	CComPtr<IObjectContext> pObjectContext=NULL;

	hr = GetObjectContext(&pObjectContext);
	if(FAILED(hr))
	{
		wsprintf(strErr,"GetObjectContext Failed!");
		goto ErrorHandler;
	}
	

	// Create ADODB.Connection object and execute SQL statement to create Table
	//


	hr = pConnection.CreateInstance("ADODB.Connection.1");
	if(FAILED(hr))
	{
		wsprintf(strErr,"Create ADODB.Connection object failed!");
		goto ErrorHandler;
	}
	hr = pConnection->Open(CONNECTION, NULL, NULL );
	if(FAILED(hr))
	{
		wsprintf(strErr,"Open ODBC connection failed!");
		goto ErrorHandler;
	}
	hr = pConnection->Execute( CComBSTR(szSQL), static_cast<VARIANT*> (&vtMissing), adCmdText, &pRecordset);
	if(FAILED(hr))
	{
		wsprintf(strErr,"Create table failed ");
		goto ErrorHandler;
	}
	pObjectContext->SetComplete();

	return S_OK;

ErrorHandler:
	Error(strErr,IID_ICreateTable );
	if (pObjectContext) pObjectContext->SetAbort();	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\createtable.h ===
// CreateTable.h : Declaration of the CCreateTable

#ifndef __CREATETABLE_H_
#define __CREATETABLE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCreateTable
class ATL_NO_VTABLE CCreateTable : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCreateTable, &CLSID_CreateTable>,
	public ISupportErrorInfo,
	public IDispatchImpl<ICreateTable, &IID_ICreateTable, &LIBID_BANKVCLib>
{
public:
	CCreateTable()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CREATETABLE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCreateTable)
	COM_INTERFACE_ENTRY(ICreateTable)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICreateTable
public:
	STDMETHOD(CreateAccount)();
};

#endif //__CREATETABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\movemoney.cpp ===
// MoveMoney.cpp : Implementation of CMoveMoney
#include "stdafx.h"
#include "BankVC.h"
#include "MoveMoney.h"

/////////////////////////////////////////////////////////////////////////////
// CMoveMoney

STDMETHODIMP CMoveMoney::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMoveMoney
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CMoveMoney::Perform(long lngAcnt1, long lngAcnt2, long lngAmount, long lngType, BSTR *pVal)
{
	// Get the ObjectContext object
	HRESULT hr;
	TCHAR strErr[256];
	CComPtr<IObjectContext> pObjectContext=NULL;
	CComPtr<IAccount> pAccount;
	CComBSTR bstrResult, bstrRes1;
	
	
	hr = GetObjectContext(&pObjectContext);
	if(FAILED(hr))
	{
		wsprintf(strErr,"GetObjectContext() failed!");
		goto ErrorHandler;
	}

	hr =pObjectContext->CreateInstance(CLSID_Account,
				IID_IAccount, (LPVOID*) &pAccount);

  
	if(FAILED(hr))
	{
		wsprintf(strErr, "Create Account Object failed!");
		goto ErrorHandler;
	}
	
	strErr[0]='\0';

	switch(lngType){
	case 1: //
		hr = pAccount->Post(lngAcnt1, 0-lngAmount, &bstrResult);
		if (FAILED(hr))
			goto ErrorHandler;
		*pVal =bstrResult.Copy();
		break;
	case 2:
		hr = pAccount->Post(lngAcnt1, lngAmount, &bstrResult);
		if (FAILED(hr))
			goto ErrorHandler;
		*pVal =bstrResult.Copy();
		break;
	case 3:
		hr=pAccount->Post(lngAcnt2, lngAmount, &bstrResult);

		if (FAILED(hr))
		{
			goto ErrorHandler;
		}
		hr=pAccount->Post(lngAcnt1, 0-lngAmount, &bstrRes1);
		if (FAILED(hr))
		{
			goto ErrorHandler;
		}
		bstrResult.Append(bstrRes1);
		*pVal = bstrResult.Copy();
		break;
	default:
		wsprintf(strErr,"Invalid transaction type!");
		goto ErrorHandler;
	}

	pObjectContext->SetComplete();

	return S_OK;

ErrorHandler:
	Error(strErr,IID_IMoveMoney );
	if(pObjectContext)pObjectContext->SetAbort();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( BankVC )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( BankVC ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\movemoney.h ===
// MoveMoney.h : Declaration of the CMoveMoney

#ifndef __MOVEMONEY_H_
#define __MOVEMONEY_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMoveMoney
class ATL_NO_VTABLE CMoveMoney : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMoveMoney, &CLSID_MoveMoney>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMoveMoney, &IID_IMoveMoney, &LIBID_BANKVCLib>
{
public:
	CMoveMoney()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MOVEMONEY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMoveMoney)
	COM_INTERFACE_ENTRY(IMoveMoney)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMoveMoney
public:
	STDMETHOD(Perform)(/*[in]*/long lngAcnt1, /*[in]*/ long lngAcnt2, /*[in]*/long lngAmount, /*[in]*/long lngType, /*[out, retval]*/BSTR* pVal);
};

#endif //__MOVEMONEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BankVC.rc
//
#define IDS_PROJNAME                    100
#define IDR_ACCOUNT                     101
#define IDR_CREATETABLE                 102
#define IDR_MOVEMONEY                   103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\catlsmpl.cpp ===
// CATLSmpl.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CATLSmplps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CATLSmpl.h"
#include "Simple.h"

#define IID_DEFINED
#include "CATLSmpl_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSimple, CSimple)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CATLSmpl.rc
//
#define IDS_SIMPLE_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\mtxsample\source\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5A67AAD6_37DA_11D2_955A_004005A2F9B1__INCLUDED_)
#define AFX_STDAFX_H__5A67AAD6_37DA_11D2_955A_004005A2F9B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <mtx.h>
#import <msado10.dll> raw_interfaces_only no_namespace 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5A67AAD6_37DA_11D2_955A_004005A2F9B1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\simple.h ===
// Simple.h : Declaration of the CSimple


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CATLSmpl

class CSimple : 
    public CComDualImpl<ISimple, &IID_ISimple, &LIBID_CATLSmpl>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CSimple,&CLSID_CSimple>
{
public:
    CSimple();
BEGIN_COM_MAP(CSimple)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISimple)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSimple) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSimple, _T("IISSample.C++ATLSimple.1"), _T("IISSample.C++ATLSimple"), IDS_SIMPLE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISimple
public:
	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalCountruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

    STDMETHOD(get_myProperty)(BSTR* pbstrOutValue);
    STDMETHOD(put_myProperty)(BSTR bstrInValue);
    STDMETHOD(myMethod) (BSTR bstrIn, BSTR* pbstrOut);

private:
    CComBSTR			m_bstrMyProperty;
	CComPtr<IUnknown>	m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\components\cpp\simple\simple.cpp ===
// Simple.cpp : Implementation of CSimple

#include "stdafx.h"
#include "CATLSmpl.h"
#include "Simple.h"

/////////////////////////////////////////////////////////////////////////////
//

// Created by the ATL 1.1 COM Wizard
STDMETHODIMP CSimple::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ISimple,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//Ctor
CSimple::CSimple()
    : m_bstrMyProperty(OLESTR("C++ ATL Simple Component"))
{}

//Put function for myProperty
STDMETHODIMP CSimple::put_myProperty(BSTR bstrInValue)
{
    if (bstrInValue == NULL)
        return E_POINTER;

    m_bstrMyProperty = bstrInValue;

    return S_OK;
}

//Get function for myProperty
STDMETHODIMP CSimple::get_myProperty(BSTR* pbstrOutValue)
{
    if (pbstrOutValue == NULL)
        return E_POINTER;

    // Get Value from Property
    *pbstrOutValue = m_bstrMyProperty.Copy();
    
    return S_OK;
}

//Basic Method to convert a string to uppercase
STDMETHODIMP CSimple::myMethod(BSTR bstrIn, BSTR* pbstrOut)  
{
    if (bstrIn == NULL || pbstrOut == NULL)
        return E_POINTER;

    // Create a temporary CComBSTR
    CComBSTR bstrTemp(bstrIn);

    if (!bstrTemp)
        return E_OUTOFMEMORY;

    // Make string uppercase   
    wcsupr(bstrTemp);  
    
    // Return m_str member of bstrTemp
    *pbstrOut = bstrTemp.Detach();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\chunk\ctetest.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ctetest.h

Abstract:

    This header files contains the common routines used for
    Chunked Transfer Encoding ISAPI Extension DLL sample.

--*/

#ifndef _CTETEST_H
#define _CTETEST_H

#ifdef __cplusplus
extern "C" {
#endif

#include <httpext.h>
#include <stdlib.h>
#include <stdio.h>

// see cte_enc.c for details
typedef struct CTE_ENCODER_STRUCT * HCTE_ENCODER;

HCTE_ENCODER 
CteBeginWrite( 
    IN EXTENSION_CONTROL_BLOCK *pECB, 
    IN DWORD dwChunkSize
    );   

BOOL 
CteWrite( 
    IN HCTE_ENCODER h, 
    IN PVOID pData, 
    IN DWORD cbData
    );
    
BOOL 
CteEndWrite( 
    IN HCTE_ENCODER h
    );

#ifdef __cplusplus
}
#endif

#endif // _CTETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\cgiwrap\cgiwrap.c ===
/*++

File: cgiwrap.c

Demonstrates an executable which can be used to load an ISAPI DLL like
a CGI script.

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include <stdlib.h>

//
// These are things that go out in the Response Header
// 

#define HTTP_VER "HTTP/1.0"
#define SERVER_VERSION "Http-Srv-Beta2/1.0"

//
// Simple wrappers for the heap APIS
// 

#define xmalloc(s) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define xfree(s)   HeapFree(GetProcessHeap(), 0, (s))

//
// The mandatory exports from the ISAPI DLL
// 

typedef BOOL(WINAPI * VersionProc) (HSE_VERSION_INFO *);
typedef DWORD(*HttpExtProc) (EXTENSION_CONTROL_BLOCK *);


//
// Prototypes of the functions this sample implements
// 

BOOL WINAPI FillExtensionControlBlock(EXTENSION_CONTROL_BLOCK *);
BOOL WINAPI GetServerVariable(HCONN, LPSTR, LPVOID, LPDWORD);
BOOL WINAPI ReadClient(HCONN, LPVOID, LPDWORD);
BOOL WINAPI WriteClient(HCONN, LPVOID, LPDWORD, DWORD);
BOOL WINAPI ServerSupportFunction(HCONN, DWORD, LPVOID, LPDWORD, LPDWORD);
char *MakeDateStr(VOID);
char *GetEnv(char *);


//
// In the startup of this program, we look at our executable name and      
// replace the ".EXE" with ".DLL" to find the ISAPI DLL we need to load.   
// This means that the executable need only be given the same "name" as    
// the DLL to load. There is no recompilation required.                    
//

int __cdecl
main(int argc, char **argv)
{

    HINSTANCE hDll;
    VersionProc GetExtensionVersion;
    HttpExtProc HttpExtensionProc;
    HSE_VERSION_INFO version_info;
    EXTENSION_CONTROL_BLOCK ECB;
    DWORD rc;
    char szModuleFileName[256], *c;


    if (!GetModuleFileName(NULL, szModuleFileName, 256)) {
        fprintf(stderr, "cannot get ModuleFileName %d\n", GetLastError());
        return -1;
    }

    rc = strlen(szModuleFileName);
    c = szModuleFileName + rc - 4;  // Go back to the last "."

    c[1] = 'D';
    c[2] = 'L';
    c[3] = 'L';

    hDll = LoadLibrary(szModuleFileName);   // Load our DLL

    if (!hDll) {
        fprintf(stderr, "Error: Failure to load %s.dll (%d)\n",
            argv[0], GetLastError());
        return -1;
    }

    // 
    // Find the exported functions
    //

    GetExtensionVersion = (VersionProc) GetProcAddress(hDll, 
                                            "GetExtensionVersion");
    if (!GetExtensionVersion) {
        fprintf(stderr, "Can't Get Extension Version %d\n", GetLastError());
        return -1;
    }
    HttpExtensionProc = (HttpExtProc) GetProcAddress(hDll, 
                                          "HttpExtensionProc");
    if (!HttpExtensionProc) {
        fprintf(stderr, "Can't Get Extension proc %d\n", GetLastError());
        return -1;
    }

    //
    // This should really check if the version information matches what 
    // we expect.
    // 

    __try {
        if (!GetExtensionVersion(&version_info)) {
            fprintf(stderr, "Fatal: GetExtensionVersion failed\n");
            return -1;
        }
    }
    __except(1) {
        return -1;
    }

    // 
    // Fill the ECB with the necessary information
    // 

    if (!FillExtensionControlBlock(&ECB)) {
        fprintf(stderr, "Fill Ext Block Failed\n");
        return -1;
    }

    //
    // Call the DLL
    // 

    __try {
        rc = HttpExtensionProc(&ECB);
    }
    __except(1) {
        return -1;
    }


    //
    // We should really free memory (e.g., from GetEnv), but we'll be dead
    // soon enough
    //
    
    if (rc == HSE_STATUS_PENDING)   
        
        //
        // We will exit in ServerSupportFunction
        //

        Sleep(INFINITE);

    return 0;

}


//
// GetServerVariable() is how the DLL calls the main program to figure out
// the environment variables it needs. This is a required function.
// 

BOOL WINAPI
GetServerVariable(HCONN hConn, LPSTR lpszVariableName,
    LPVOID lpBuffer, LPDWORD lpdwSize)
{

    DWORD rc;

    // 
    // We don't really have an HCONN, so we assume a value of 0 (which is
    // passed
    // to the DLL in the ECB by HttpExtensionProc().
    // Hence the check for a non-zero HCONN

    if (hConn) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    rc = GetEnvironmentVariable(lpszVariableName, lpBuffer, *lpdwSize);

    if (!rc) {                  

        //
        // return of 0 indicates the variable was not found
        //
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    if (rc > *lpdwSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // GetEnvironmentVariable does not count the NUL character
    //
    *lpdwSize = rc + 1;         

    return TRUE;

}


//
// Again, we don't have an HCONN, so we simply wrap ReadClient() to
// ReadFile on stdin. The semantics of the two functions are the same
// 

BOOL WINAPI
ReadClient(HCONN hConn, LPVOID lpBuffer, LPDWORD lpdwSize)
{

    return ReadFile(GetStdHandle(STD_INPUT_HANDLE), lpBuffer, (*lpdwSize),
        lpdwSize, NULL);

}


//
// ditto for WriteClient()
// 

BOOL WINAPI
WriteClient(HCONN hConn, LPVOID lpBuffer, LPDWORD lpdwSize,
    DWORD dwReserved)
{

    return WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), lpBuffer, *lpdwSize,
        lpdwSize, NULL);

}


//
// This is a special callback function used by the DLL for certain extra 
// functionality. Look at the API help for details.
// 

BOOL WINAPI
ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
    LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
{

    char *lpszRespBuf;
    char *temp;
    DWORD dwBytes;
    BOOL bRet;

    switch (dwHSERequest) {

    case (HSE_REQ_SEND_RESPONSE_HEADER):
        lpszRespBuf = xmalloc(*lpdwSize + 80);  // accomodate our header

        if (!lpszRespBuf)
            return FALSE;
        wsprintf(lpszRespBuf, "%s %s %s %s\r\n%s", 
            HTTP_VER,
            lpvBuffer ? lpvBuffer : "200 Ok",   // Default response is 200 Ok
            temp = MakeDateStr(),               // Create a time string
            SERVER_VERSION,

        //
        // If this exists, it is a pointer to a data buffer to be sent. 
        //
            lpdwDataType ? (char *) lpdwDataType : NULL);

        xfree(temp);

        dwBytes = strlen(lpszRespBuf);
        bRet = WriteClient(0, lpszRespBuf, &dwBytes, 0);
        xfree(lpszRespBuf);

        break;


    case (HSE_REQ_DONE_WITH_SESSION):

        // 
        // A real server would do cleanup here
        //

        ExitProcess(0);
        break;

    case (HSE_REQ_SEND_URL_REDIRECT_RESP):

        // 
        // This sends a redirect (temporary) to the client.
        // The header construction is similar to RESPONSE_HEADER above.
        // 

        lpszRespBuf = xmalloc(*lpdwSize + 80);
        if (!lpszRespBuf)
            return FALSE;
        wsprintf(lpszRespBuf, "%s %s %s\r\n",
            HTTP_VER,
            "302 Moved Temporarily",
            (lpdwSize > 0) ? lpvBuffer : 0);
        dwBytes = strlen(lpszRespBuf);
        bRet = WriteClient(0, lpszRespBuf, &dwBytes, 0);
        xfree(lpszRespBuf);
        break;

    default:
        return FALSE;
        break;
    }
    return bRet;

}



//
// Makes a string of the date and time from GetSystemTime().
// This is in UTC, as required by the HTTP spec.`
// 

char *
MakeDateStr(void)
{
    SYSTEMTIME systime;
    char *szDate = xmalloc(64);

    char *DaysofWeek[] = 
        {"Sun", "Mon", "Tue", "Wed", "Thurs", "Fri", "Sat"};
    char *Months[] = 
        {"NULL", "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    GetSystemTime(&systime);

    wsprintf(szDate, "%s, %d %s %d %d:%d.%d", 
        DaysofWeek[systime.wDayOfWeek],
        systime.wDay,
        Months[systime.wMonth],
        systime.wYear,
        systime.wHour, systime.wMinute,
        systime.wSecond);

    return szDate;
}


//
// Fill the ECB up 
// 

BOOL WINAPI
FillExtensionControlBlock(EXTENSION_CONTROL_BLOCK * ECB)
{

    char *temp;

    ECB->cbSize = sizeof (EXTENSION_CONTROL_BLOCK);
    ECB->dwVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);
    ECB->ConnID = 0;

    // 
    // Pointers to the functions the DLL will call.
    // 
    
    ECB->GetServerVariable = GetServerVariable;
    ECB->ReadClient = ReadClient;
    ECB->WriteClient = WriteClient;
    ECB->ServerSupportFunction = ServerSupportFunction;

    // 
    // Fill in the standard CGI environment variables
    // 
    
    ECB->lpszMethod = GetEnv("REQUEST_METHOD");
    ECB->lpszQueryString = GetEnv("QUERY_STRING");
    ECB->lpszPathInfo = GetEnv("PATH_INFO");
    ECB->lpszPathTranslated = GetEnv("PATH_TRANSLATED");
    ECB->cbTotalBytes = ((temp = GetEnv("CONTENT_LENGTH")) ? 
                            (atoi(temp)) : 0);
    ECB->cbAvailable = 0;
    ECB->lpbData = "";
    ECB->lpszContentType = GetEnv("CONTENT_TYPE");

    return TRUE;

}


//
// Works like _getenv(), but uses win32 functions instead.
// 

char *
GetEnv(LPSTR lpszEnvVar)
{

    char *var, dummy;
    DWORD dwLen;

    if (!lpszEnvVar)
        return "";

    dwLen = GetEnvironmentVariable(lpszEnvVar, &dummy, 1);

    if (dwLen == 0)
        return "";

    var = xmalloc(dwLen);
    if (!var)
        return "";

    (void) GetEnvironmentVariable(lpszEnvVar, var, dwLen);

    return var;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\com\isapithread.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:    IsapiThread.cpp

Abstract:

    Implements a simple thread pool class for use with ISAPI extensions

Author:

    Wade A. Hilmo, April 1998

--*/

#include "IsapiThread.h"

BOOL ISAPITHREAD::InitThreadPool(
	LPTHREAD_START_ROUTINE pThreadProc,
	DWORD dwNumThreads,
	DWORD dwQueueSize
	)
/*++
Function :  ISAPITHREAD::InitThreadPool

Description:

    This function initializes the thread pool by creating the worker
	threads and the work item queue

Arguments:

	pThreadProc  - Thread proc for the worker threads
	dwNumThreads - The number of threads to create in the pool
	dwQueueSize  - The size of the work item queue

Return Value:

    Returns TRUE if successful, otherwise FALSE.

--*/
{
	DWORD x, dwThreadId;

	//
	// Initialize the member variables
	//

	m_WorkItemQueue = NULL;
	m_dwCurrentItem = 0;
	m_dwItemsInQueue = 0;
	m_arrWorkerThreads = NULL;
	m_dwNumThreads = 0;

	//
	// Queue size defaults to twice the number of worker threads
	//

	m_dwWorkItemQueueSize = 
		(dwQueueSize == 0xffffffff) ? dwNumThreads * 2 : dwQueueSize;
	
	//
	// Allocate the array to store the worker thread handles
	//

	m_arrWorkerThreads = new HANDLE[dwNumThreads];

	if (!m_arrWorkerThreads)
		goto Failed;

	//
	// Allocate the work item queue
	//

	m_WorkItemQueue = new EXTENSION_CONTROL_BLOCK *[m_dwWorkItemQueueSize];

	if (!m_WorkItemQueue)
		goto Failed;

	//
	// Initialize the queue critical section
	//

	InitializeCriticalSection(&m_csQueue);

	//
	// Start the worker threads
	//

	for (x = 0; x < dwNumThreads; x++)
	{
		m_arrWorkerThreads[x] = CreateThread(
			NULL,									// security attributes
			0,										// stack size
			pThreadProc,							// thread routine
			this,									// parameter
			0,										// flags
			&dwThreadId								// thread id
			);

		if (m_arrWorkerThreads[x])
			m_dwNumThreads++;
		else
			break;
	}

	if (m_dwNumThreads != dwNumThreads)
		goto Failed;

	//
	// Create the worker thread semaphore
	//

	m_hWorkerThreadSemaphore = CreateSemaphore(
		NULL,		// security attributes
		0,			// initial count - nonsignaled
		0x7fffffff,	// max count
		NULL		// name
		);

	if (!m_hWorkerThreadSemaphore)
		goto Failed;

	//
	// Done
	//

	return TRUE;

Failed:

	//
	// The destructor will deallocate buffers, so we don't need to here
	//

	return FALSE;
}


BOOL ISAPITHREAD::QueueWorkItem(
	EXTENSION_CONTROL_BLOCK *pecb,
    BOOL fReleaseThread
	)
/*++
Function :  ISAPITHREAD::QueueWorkItem

Description:

	Adds and item to the work item queue

Arguments:

	pecb - A pointer to the ECB to be added to the queue
    fReleaseThread - If this flag is TRUE, release a worker thread

Return Value:

    Returns TRUE if successful, FALSE if the queue is full.

--*/
{
	DWORD dwInsertionPoint;
	
	EnterCriticalSection(&m_csQueue);

	//
	// Check to see if the queue is full
	//

	if (m_dwItemsInQueue == m_dwWorkItemQueueSize)
		goto Failed;

	//
	// Add the work item to the queue
	//

	dwInsertionPoint = m_dwCurrentItem + m_dwItemsInQueue;

	if (dwInsertionPoint > m_dwWorkItemQueueSize - 1)
		dwInsertionPoint -= m_dwWorkItemQueueSize;

	m_WorkItemQueue[dwInsertionPoint] = pecb;

	m_dwItemsInQueue++;

	//
	// Done
	//

	LeaveCriticalSection(&m_csQueue);

    //
    // If requested, release a worker thread
    //

    if (fReleaseThread)
        ReleaseThread();

	return TRUE;

Failed:

	LeaveCriticalSection(&m_csQueue);

	return FALSE;
}

EXTENSION_CONTROL_BLOCK * ISAPITHREAD::GetWorkItem(
	void
	)
/*++
Function :  ISAPITHREAD::GetWorkItem

Description:

	Gets the next item from the work item queue

Arguments:

	none

Return Value:

    Returns a pointer to the next ECB in the queue, else NULL if the
	queue is empty

--*/
{
	EXTENSION_CONTROL_BLOCK *pRet;
	
	EnterCriticalSection(&m_csQueue);

	//
	// Check to see if the queue is empty
	//

	if (!m_dwItemsInQueue)
		goto Failed;

	//
	// Get the next item from the queue
	//

	pRet = m_WorkItemQueue[m_dwCurrentItem];

	m_dwCurrentItem++;

	if (m_dwCurrentItem == m_dwWorkItemQueueSize)
		m_dwCurrentItem = 0;

	m_dwItemsInQueue--;

	//
	// Done
	//

	LeaveCriticalSection(&m_csQueue);

	return pRet;

Failed:

	LeaveCriticalSection(&m_csQueue);

	return NULL;
}

void ISAPITHREAD::ReleaseThread(
	DWORD dwNumThreads
	)
/*++
Function :  ISAPITHREAD::ReleaseThread

Description:

	Releases one or more waiting pool threads

Arguments:

	dwNumThreads - The number of threads to release

Return Value:

	None

--*/
{
	ReleaseSemaphore(m_hWorkerThreadSemaphore, dwNumThreads, NULL);

	return;
}

void ISAPITHREAD::ClearQueue(
	void
	)
/*++
Function :  ISAPITHREAD::ClearQueue

Description:

	Clears the work item queue

Arguments:

	None

Return Value:

	None

--*/
{
	DWORD x;

	EnterCriticalSection(&m_csQueue);

	//
	// Clear the work items in the queue
	//
	
	for (x = 0; x < m_dwWorkItemQueueSize; x++)
		m_WorkItemQueue[x] = NULL;

	//
	// Reset the index counters
	//

	m_dwCurrentItem = 0;
	m_dwItemsInQueue = 0;

	LeaveCriticalSection(&m_csQueue);

	return;
}

ISAPITHREAD::ISAPITHREAD(void)
/*++
Function :  ISAPITHREAD::ISAPITHREAD

Description:

	Constructor for the ISAPITHREAD object

Arguments:

	None

Return Value:

	None

--*/
{
}

ISAPITHREAD::~ISAPITHREAD(void)
/*++
Function :  ISAPITHREAD::~ISAPITHREAD

Description:

	Destructor for the ISAPITHREAD object

Arguments:

	None

Return Value:

	None

--*/
{
    DWORD x;

	//
	// Clear the work item queue
	//

	ClearQueue();

	//
	// Release the worker threads.  The threads should exit
	// gracefully when they retrieve a NULL item from the queue.
	//

	ReleaseThread(m_dwNumThreads);

	//
	// Wait for the worker threads to exit.
	//

#ifdef _DEBUG
	OutputDebugString("Waiting for worker threads to exit...\r\n");
#endif

	WaitForMultipleObjects(
		m_dwNumThreads,		// number of objects
		m_arrWorkerThreads,	// array of handles
		TRUE,				// wait all flag
		INFINITE			// timeout
		);

#ifdef _DEBUG
	OutputDebugString("All worker threads exited gracefully.\r\n");
#endif

    //
    // Close the handles
    //

    for (x = 0; x < m_dwNumThreads; x++)
        CloseHandle(m_arrWorkerThreads[x]);

    CloseHandle(m_hWorkerThreadSemaphore);

    //
    // Delete the critical section
    //

    DeleteCriticalSection(&m_csQueue);

	//
	// Deallocate the arrays
	//

	delete m_arrWorkerThreads;
	delete m_WorkItemQueue;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\chunk\ctetest.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    ctetest.c

Abstract:

    ISAPI Extension sample illustrating Chunked Transfer Encoding. 

--*/

#include "ctetest.h"

//
// if chunksize= is not specified, use this value
//

#define DEFAULT_CHUNK_SIZE 1024


//
// auxiliary functions prototypes
//

static BOOL SendChunkedFile( EXTENSION_CONTROL_BLOCK *, DWORD, LPCSTR );
static BOOL SendHttpHeaders( EXTENSION_CONTROL_BLOCK *, LPCSTR, LPCSTR, BOOL );
static BOOL GetFileMimeType( LPCSTR, LPSTR, DWORD ); 
static BOOL GetQueryStringField( LPCSTR, LPCSTR, LPSTR, DWORD );
static void DisplayExampleUsage( EXTENSION_CONTROL_BLOCK * );



DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK *pECB
)
/*++

Purpose:

    Illustrate chunk transfer encoding in ISAPI HTTP Extension DLL.
    Process "GET" requests that specify a filename and transfer 
    chunk size.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS on successful transmission completion
    HSE_STATUS_ERROR on failure

--*/
{
    DWORD dwChunksize = 0;
    char szPath[MAX_PATH];
    char szHeaders[1024];
    DWORD cchPath, cchHeaders;
    char szChunkSize[32];

    //
    // if request method is not "GET", bail out
    //
    
    if( _stricmp( pECB->lpszMethod, "GET" ) != 0 ) {
    	return HSE_STATUS_ERROR;
    }    	
    
    //
    // process chunksize= query argument, if any
    //
    
    if( GetQueryStringField( pECB->lpszQueryString, "chunksize", 
            szChunkSize, sizeof szChunkSize )) {
        dwChunksize = atoi( szChunkSize );
    }
    
    if( dwChunksize == 0 ) {
    	dwChunksize = DEFAULT_CHUNK_SIZE;
	}    	

    //
    // process file= query argument
    //

    cchPath = sizeof szPath;
    if( !GetQueryStringField( 
            pECB->lpszQueryString, 
            "file", 
            szPath, 
            cchPath )) {

        // 
        // no file specified - display usage and report success
        //
        
        DisplayExampleUsage( pECB );

        return HSE_STATUS_SUCCESS;
    }

    //
    // use ServerSupportFunction to map virtual file name to local
    // path (otherwise users get access to any file on the system)
    //

    if( !pECB->ServerSupportFunction(
             pECB->ConnID,
             HSE_REQ_MAP_URL_TO_PATH,
             szPath,
             &cchPath,
             NULL ) ) {

        return HSE_STATUS_ERROR;
    }

    //
    // see if we can get file attributes, report error if not
    //

    if( GetFileAttributes( szPath ) == 0xFFFFFFFF ) {

        return HSE_STATUS_ERROR;
    }

    //
    // begin preparing the headers
    //
    
    strcpy( szHeaders, "Transfer-encoding: chunked\r\nContent-type: " );

    //
    // obtain MIME type for this file and append it to the headers
    //

    cchHeaders = strlen( szHeaders );
    GetFileMimeType( 
        szPath, 
        szHeaders + cchHeaders, 
        sizeof szHeaders - cchHeaders 
        );

    //
    // terminate headers with empty line
    //

    strcat( szHeaders, "\r\n\r\n" );

    //
    // try sending headers to the client
    //

    if( !SendHttpHeaders( pECB, "200 OK", szHeaders, TRUE ) ) {

        return HSE_STATUS_ERROR;
    }

    //
    // try sending the file using CTE encoding
    //

    if( !SendChunkedFile( pECB, dwChunksize, szPath ) ) {

        return HSE_STATUS_ERROR;
    }    
    
    return HSE_STATUS_SUCCESS;
}


BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO *pVer
)
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{

    //
    // tell the server our version number and extension description
    //

    pVer->dwExtensionVersion =
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    lstrcpyn(
        pVer->lpszExtensionDesc, 
        "ISAPI CTE test",
        HSE_MAX_EXT_DLL_NAME_LEN);

    return TRUE;
}


BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
)
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}



BOOL WINAPI
DllMain (
    IN HINSTANCE hInstance,
    IN DWORD fdwReason,
    IN LPVOID lpvReserved    
)
/*++

Purpose:

    Perform any required DLL initialization here.

Returns:

    TRUE if DLL was successfully initialized
    FALSE otherwise

--*/
{

    //
    // Nothing needs to be done. This function exists a template.
    //

    return TRUE;
}


static BOOL 
SendChunkedFile( 
    EXTENSION_CONTROL_BLOCK *pECB, 
    DWORD dwChunkSize,
    LPCSTR pszPath
)
/*++

Purpose:

    Transfer the specified file using chunked encoding.

    Illustrates the usage of CteBeginWrite(), CteWrite() and
    CteEndWrite() functions.


Arguments:

    pECB - pointer to extenstion control block 
    dwChunkSize - chunk size for transfer encoding
    pszPath - local file path

Returns:

    TRUE if the file was successfully transfered,
    FALSE otherwise
    
--*/
{
    HANDLE hFile;
    HCTE_ENCODER hCteWrite;
    BOOL fSuccess = FALSE;

    //
    // try accessing file
    //

    hFile = CreateFile(
                pszPath, 
                GENERIC_READ, 
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if( hFile != INVALID_HANDLE_VALUE ) {
        BYTE buf[4096];
        DWORD cbread;

        //
        // prepare chunk transfer encoder
        //

        hCteWrite = CteBeginWrite( pECB, dwChunkSize );
        if ( hCteWrite ) {
        
            for( ;; ) {

                if( !ReadFile( hFile, buf, sizeof buf, &cbread, NULL ) ) {
                    
                    //
                    // if ReadFile fails, break out of loop and cause 
                    // the function to return FALSE (failure)
                    //
                    
                    break;
                }
            
                if( cbread == 0 ) {
                
                    //
                    // ReadFile succeded, but read 0 bytes -
                    // we've achieved EOF and everything is transmitted.
                    // break out and return success!
                    //
                    
                    fSuccess = TRUE;
                    break;
                }

                //
                // transmit one buffer full of data,
                //
                
                if( !CteWrite( hCteWrite, buf, cbread ) ) {
                
                    //
                    // CteWrite failed - break out and return FALSE
                    //
                    
                    break;
                }                
            }

            //
            // finish transfer and release encoder context
            //
            
            if( !CteEndWrite( hCteWrite ) ) {
            
                fSuccess = FALSE;
            }
        }

        CloseHandle( hFile );
    }

    return fSuccess;
}



static BOOL 
SendHttpHeaders( 
    EXTENSION_CONTROL_BLOCK *pECB, 
    LPCSTR pszStatus,
    LPCSTR pszHeaders,
    BOOL fKeepConn
)
/*++

Purpose:
    Send specified HTTP status string and any additional header strings
    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO

Arguments:

    pECB - pointer to the extension control block
    pszStatus - HTTP status string (e.g. "200 OK")
    pszHeaders - any additional headers, separated by CRLFs and 
                 terminated by empty line
    fKeepConn - specifies whether to keep TCP connection open or close it
                after request is processed.

Returns:

    TRUE if headers were successfully sent
    FALSE otherwise

--*/
{
    HSE_SEND_HEADER_EX_INFO header_ex_info;
    BOOL success;

    header_ex_info.pszStatus = pszStatus;
    header_ex_info.pszHeader = pszHeaders;
    header_ex_info.cchStatus = strlen( pszStatus );
    header_ex_info.cchHeader = strlen( pszHeaders );
    header_ex_info.fKeepConn = fKeepConn;


    success = pECB->ServerSupportFunction(
                  pECB->ConnID,
                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                  &header_ex_info,
                  NULL,
                  NULL
                  );

    return success;
}



static BOOL 
GetFileMimeType( 
    LPCSTR pszPath, 
    LPSTR pszType, 
    DWORD cbMax 
)
/*++

Purpose:

    Given the file name, obtain MIME type for "Content-type:" header field.
    We try to find MIME type string under HCR\.xyz key, "Content Type" value.
    If that fails, we return default "application/ocetet-stream".

Arguments:
    
    pszPath - file path
    pszType - points to the buffer that will receive MIME type string
    cbMax - specifies the maximum number of characters to copy to the buffer,
            including the NUL character. If the text exceed this limit, it
            will be truncated.

Returns:

    TRUE, because we can always use default MIME type.
  
--*/
{
    LPSTR pszExt;
    HKEY hKey;
    DWORD value_type;
    LONG result;


    //
    // set MIME type to empty string
    //

    *pszType = '\0';


    //
    // try to locate file extension
    //

    pszExt = strrchr( pszPath, '.' );
    
    if( pszExt != NULL ) {
    
        // 
        // for file extension .xyz, MIME Type can be found
        // HKEY_CLASSES_ROOT\.xyz key in the registry
        //

        result = RegOpenKeyEx( 
                     HKEY_CLASSES_ROOT, 
                     pszExt, 
                     0L, 
                     KEY_READ, 
                     &hKey 
                     );
                     
        if( result == ERROR_SUCCESS) {
        
            //
            // we sucessfully opened the key.
            // try getting the "Content Type" value
            //
            
            result = RegQueryValueEx( 
                         hKey, 
	                     "Content Type", 
    	                 NULL, 
	                     &value_type, 
	                     (BYTE *)pszType, 
	                     &cbMax );

            //
            // if we failed to get the value or it is not string,
            // clear content-type field
            //
            
            if( result != ERROR_SUCCESS || value_type != REG_SZ ) {
                *pszType = '\0';
            }
            
            RegCloseKey( hKey );
        }
    }
    
    //
    // if at this point we don't have MIME type, use default
    //
    
    if( *pszType == '\0' ) {
        strncpy( pszType, "application/octet_stream", cbMax );
    }

    return TRUE;
}



static void
DisplayExampleUsage(
    EXTENSION_CONTROL_BLOCK *pECB
)
/*++

Purpose:
    
    Send short plaintext description of our usage to the user.

Arguments:
    
    pECB - pointer to the extension control block

--*/
{
    DWORD dwLength;
    static char szUsage[] = 
        "Example usage:\r\n"
        "http://localhost/scripts/ctetest.dll"
        "?file=/default.htm+chunksize=512\r\n";
        
    char szHeaders[1024];
    

    //
    // send simple headers and sample usage instruction
    //
    dwLength = sizeof szUsage - 1;
    
    sprintf( 
        szHeaders, 
        "Content-Length: %u\r\n"
        "Content-Type: text/plain\r\n\r\n",
        dwLength 
        );
    
    if( SendHttpHeaders( pECB, "200 OK", szHeaders, FALSE ) ) {
        pECB->WriteClient(
            pECB->ConnID,
            szUsage,
            &dwLength,
            HSE_IO_SYNC
            );
    }        
}



BOOL 
GetQueryStringField(
    LPCSTR pszQueryString,
    LPCSTR pszKey, 
    LPSTR buf, 
    DWORD cbuf
)
/*++

Purpose:
    Assuming "key1=value1+key2=value2" syntax,
    extract the value for specified key.
    

Arguments:
    pszQueryString - query string provided by ECB
    pszKey - key name
    buf - buffer for parameter value
    cbuf - buffer size

Returns:

    TRUE if the value was successfully extracted
    FALSE otherwise

--*/
{
    int len, keylen;
    LPCSTR p = pszQueryString;

    //
    // compute key and query lengths, bail out if either is missing
    //
    
    keylen = strlen( pszKey );
    len = strlen( p );

    if( keylen == 0 || len == 0 ) return FALSE;

    //
    // process one "+" delimited section at a time  
    //

    for( ;; ) {
    
        //
        // skip any leading blanks, bail out if end of line found
        //
        
        while( *p <= ' ' ) {

            if( *p == '\0' ) {
                return FALSE;
            }
            
            p++;
            len--;
        }

        //
        // if the key won't fit into the rest of the command line, bail out
        //
        
        if( keylen + 1 > len ) {
            return FALSE;
        }
            
        //
        // is this the key we are looking for?
        //
        
        if( _memicmp( p, pszKey, keylen ) == 0 && p[keylen] == '=' ) {
        
            //
            // found it - skip '=' and break out of the loop
            //
            
            p += keylen + 1;
            break;
        }

        //    
        // no match, try advancing to next '+' section
        //
        
        while( *p != '+' ) {

            if( *p == '\0' ) {
                return FALSE;
            }
            
            p++;
            len--;
        }
        
        //
        // found '+', skip it
        //
        
        p++;
        len--;
    }   

    //
    // copy the value up to: the end of line, cbuf chars, or
    // '+' separator, whichever comes first
    //
    
    while( *p && *p != '+' ) {

        if( cbuf <= 1 ) {
            break;
        }
        
        *(buf++) = *(p++);
        cbuf--;
    }

    //
    // zero-terminate the value, report success
    //
    
    *buf = '\0';
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\chunk\cte_enc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cte_enc.c

Abstract:

    This module contains routines implementing Chunked Transfer 
    Encoding (CTE) for ISAPI Extension DLLs. See Section 3.6 
    "Transfer Codings" of RFC 2068 for details.

Functions:
    CteBeginWrite
    CteWrite
    CteEndWrite

--*/


#include "ctetest.h"


//
// Encoder context structure 
//

typedef struct CTE_ENCODER_STRUCT {
    EXTENSION_CONTROL_BLOCK * pECB;         // a copy of current ECB pointer
    DWORD                     dwChunkSize;  // user-specified chunk size
    DWORD                     cbData;       // number of bytes in the buffer
    BYTE *                    pData;        // pointer to chunk data bytes
} CTE_ENCODER;

//
// Chunk header consists of HEX string for the chunk size in bytes
// (DWORD needs up to 8 bytes in HEX), followed by CRLF,
// therefore the maximum chunk header size is 10 bytes.
//

#define CTE_MAX_CHUNK_HEADER_SIZE 10

//
// Chunk data is always followed by CRLF
//

#define CTE_MAX_ENCODING_OVERHEAD (CTE_MAX_CHUNK_HEADER_SIZE + 2)

//
// Total encoder size includes:
//   the size of the encoder context structure itself,
//   the chunk data size,
//   the maximum encoding overhead (header and terminating CRLF)
//

#define CTE_ENCODER_SIZE(dwChunkSize) \
    (sizeof(CTE_ENCODER) + dwChunkSize + CTE_MAX_ENCODING_OVERHEAD)



HCTE_ENCODER
CteBeginWrite(
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN DWORD dwChunkSize
    )   
/*++

Purpose:

    Allocate and initialize chunked transfer encoder context
    
Arguments:    

    pECB - pointer to extension control as passed to HttpExtensionProc()
    dwChunkSize - the maximum size of the chunk to transmit

Returns:
    encoder context handle, or 
    NULL if memory allocation failed or chunk size was zero
    
--*/
{
    HCTE_ENCODER h;


    //
    // reject zero-length chunk size
    //

    if( dwChunkSize == 0 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    //
    // allocate context structure
    // 
    
    h = LocalAlloc( LMEM_FIXED, CTE_ENCODER_SIZE(dwChunkSize) );

    if( h != NULL ) {

        //
        // initialize context structure
        //

        h->pECB         = pECB;
        h->dwChunkSize  = dwChunkSize;
        h->cbData       = 0;

        //
        // chunk data bytes follow the context structure itself 
        // and chunk header 
        //

        h->pData = (BYTE *) h + sizeof( *h ) + CTE_MAX_CHUNK_HEADER_SIZE;

        //
        // this is the CRLF which follows chunk size 
        // (and immediately precedes data)
        //

        h->pData[-2] = '\r';
        h->pData[-1] = '\n';

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return h;
}


static BOOL
CteSendChunk(
    IN HCTE_ENCODER h
)
/*++

Purpose: 

    Send one chunk of data using ClientWrite() 
    <hex encoded chunk size>, CRLF, data bytes, if any, CRLF

Arguments:

    h - CTE Encoder handle    
      
Returns:

    TRUE if WriteClient succeeded
    FALSE if WriteClient failed
    
--*/
{
    char szChunkLength[9];
    DWORD cbChunkLength;
    BYTE *buf;
    DWORD cbToSend;
    BOOL success;

    //
    // produce hex string of the number of bytes
    // and compute the length of this string
    //
    _itoa( h->cbData, szChunkLength, 16 ); 
    cbChunkLength = strlen( szChunkLength );

    //
    // step back to make place for hex number and CRLF,
    // copy hex string to its location
    //

    buf = h->pData - 2 - cbChunkLength;
    memmove( buf, szChunkLength, cbChunkLength );

    //
    // compute the number of bytes to send
    // (this includes chunk data size, hex string and CRLF)
    // 

    cbToSend = h->cbData + cbChunkLength + 2;

    //
    // append trailing CRLF right after the data bytes
    //
    
    buf[cbToSend++] = '\r';
    buf[cbToSend++] = '\n';

    //
    // issue synchronous WriteClient and return result to the caller 
    //
    
    success = h->pECB->WriteClient(
                    h->pECB->ConnID, 
                    buf, 
                    &cbToSend, 
                    HSE_IO_SYNC 
                    );

    //
    // reset buffer pointer
    //
    
    h->cbData = 0;

    return success;
}


BOOL
CteWrite(
    IN HCTE_ENCODER h,
    IN PVOID pData,
    IN DWORD cbData
)
/*++

Purpose:

    Write specified number of data bytes to the chunk buffer.
    When the chunk buffer becomes full, call CteSendChunk() 
    to send it out.

Arguments:

    h - CTE Encoder handle 
    pData - pointer to data bytes 
    cbData - number of data bytes to send
    
Returns:    

    TRUE if bytes were successfully written
    FALSE if WriteClient() failed
    
--*/
{
    DWORD cbToConsume;
    PBYTE pBytesToSend = (PBYTE) pData;

    for( ;; ) {

        //
        // compute the number of bytes to consume,
        // break out of the loop, if nothing is left
        //

        cbToConsume = min( cbData, h->dwChunkSize - h->cbData );

        if( cbToConsume == 0 ) {
            break;
        }

        //
        // move bytes to the buffer, advance pointers and counters
        //
        
        memmove( h->pData + h->cbData, pBytesToSend, cbToConsume );

        h->cbData += cbToConsume;
        pBytesToSend += cbToConsume;
        cbData -= cbToConsume;

        //
        // if the chunk buffer is full, send it
        //
        
        if( h->cbData == h->dwChunkSize ) {
            if( !CteSendChunk( h ) ) {
                return FALSE;
            }
        }

    }

    return TRUE;
}


BOOL 
CteEndWrite(
    IN HCTE_ENCODER h
)
/*++

Purpose:

    Complete the transfer and release the encoder context

Arguments:

    h - CTE Encoder handle
    
Returns:

    TRUE if transfer was successfully completed
    FALSE if WriteClient() failed
    
--*/ 
{
    BOOL success;

    //
    // if there are some bytes in the chunk, send them
    //
    
    if( h->cbData ) {
        if( !CteSendChunk( h ) ) {
            return FALSE;
        }
    }
    
    //
    // send empty chunk (which means EOF)
    //
    
    success = CteSendChunk( h );
    
    //
    // release chunk transfer context
    //

    LocalFree( h );
    
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\com\invokobjthreads.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    InvokObjThreads.cpp

Abstract:

    ISAPI Extension sample to invoke an automation server method
    from worker threads

--*/

#define _WIN32_WINNT 0x0400
#include <windows.h>
#include <httpext.h>
#include "IsapiThread.h"

//
// Prototype for worker thread function
//

DWORD WINAPI WorkerThread(LPVOID pParam);

//
// Import type library information about the COM object
//

#import "GetUserName.dll"

//
// Global thread pool object
//

ISAPITHREAD *pThreadPool;

BOOL APIENTRY DllMain(
    HANDLE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved
    )
/*++
Function :  DllMain

Description:

    The initialization function for this DLL.

Arguments:

    hinstDll - Instance handle of the DLL
    dwReason - Reason why NT called this DLL
    lpvContext - Reserved parameter for future use

Return Value:

    Returns TRUE if successfull; otherwise FALSE.

--*/
{
#ifdef _DEBUG
    CHAR szDebug[1024];
#endif
    
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:

            //
            // Allocate the thread pool object
            //

			pThreadPool = new ISAPITHREAD;

			if (!pThreadPool)
            {
#ifdef _DEBUG
                wsprintf(
                    szDebug,
                    "Failed to allocate thread pool object. "
                    "InvokObjThreads is terminating.\r\n"
                    );

                OutputDebugString(szDebug);
#endif  // _DEBUG

				return FALSE;
            }

            //
            // Initialize the worker threads
            //

			if (!pThreadPool->InitThreadPool(WorkerThread))
			{
#ifdef _DEBUG
                wsprintf(
                    szDebug,
                    "Failed to initialize worker threads. "
                    "InvokObjThreads is terminating.\r\n"
                    );

                OutputDebugString(szDebug);
#endif  // _DEBUG

                delete pThreadPool;
				return FALSE;
			}

			break;

		case DLL_PROCESS_DETACH:
			break;

		default:
			return TRUE;
	}

	return TRUE;
}


BOOL WINAPI 
GetExtensionVersion(
    HSE_VERSION_INFO *pVer
    )
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, 
                                         HSE_VERSION_MAJOR );
    lstrcpyn( pVer->lpszExtensionDesc, 
        "InvokObjThreads ISAPI Sample", HSE_MAX_EXT_DLL_NAME_LEN );


    return TRUE;
}

DWORD WINAPI 
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pecb
    )
/*++

Purpose:

    Demonstrate how to create an instance of the automation object
    using VC++ 5.0 extensions and how to invoke its method.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS on successful transmission completion
    HSE_STATUS_ERROR on failure

--*/
{
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;
    CHAR szOutput[1024];
    DWORD dwBuffSize;

    //
    // Add the request to the work item queue.
    // If successful, we're done.  If not, return an error to the client
    //

    if (pThreadPool->QueueWorkItem(pecb))
        return HSE_STATUS_PENDING;

    //
    // Send headers back to client
    //

    HeaderExInfo.pszStatus = "200 OK";
    HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
    HeaderExInfo.pszHeader = "Content-type: text/html\r\n\r\n";
    HeaderExInfo.cchHeader = strlen( HeaderExInfo.pszHeader );
    HeaderExInfo.fKeepConn = FALSE;

    pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &HeaderExInfo,
        NULL,
        NULL
        );

    //
    // Send back a message to the client indicating that the queue is full
    //

    wsprintf(szOutput,
        "<h1>InvokObjThreads.dll</h1>"
        "<hr>The resource is busy.  Pleast try again later."
        );

    dwBuffSize = strlen(szOutput);

    pecb->WriteClient(pecb->ConnID, szOutput, &dwBuffSize, 0);

    return HSE_STATUS_SUCCESS;
}

BOOL WINAPI 
TerminateExtension(
    DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    //
    // Delete the thread pool object
    //

    delete pThreadPool;
    
    //
    // It is now OK to unload
    //
    
    return TRUE;
}

DWORD WINAPI WorkerThread(LPVOID pParam)
/*++

Purpose:

    Implements the worker thread functionality
  
Arguments:
    
    pParam - A pointer to the threadpool object to which the thread belongs
    
Returns:
    
    0
    
--*/
{
    char szOutput[1024];
    DWORD dwBuffSize, dwThreadId, dwResult;
    GETUSERNAMELib::IGetUserNameObjPtr pItf;
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;
    HRESULT hr;
    EXTENSION_CONTROL_BLOCK *pecb;
    ISAPITHREAD *pThreadPool = (ISAPITHREAD *)pParam;
    HANDLE hRequestToken;

#ifdef _DEBUG
    CHAR szDebug[1024];
#endif

    //
    // Get the ThreadId for this thread
    //

    dwThreadId = GetCurrentThreadId();

#ifdef _DEBUG
        wsprintf(
            szDebug,
            "Initializing worker thread %d.\r\n",
            dwThreadId
            );

        OutputDebugString(szDebug);
#endif // _DEBUG

    //
    // Initialize COM for this thread
    //

    hr = CoInitialize(NULL);

    if ( FAILED( hr ) )
    {
#ifdef _DEBUG
        wsprintf(
            szDebug,
            "CoIntialize failed for thread %d: 0x%08x (%d)\r\n",
            dwThreadId,
            hr,
            hr
            );

        OutputDebugString(szDebug);
#endif // _DEBUG

        return FALSE;
    }

    //
    // Initialize and instance of the automation server for this thread
    //

    hr = pItf.CreateInstance( L"GetUserNameObj.GetUserNameObj.1" );

    if ( FAILED( hr ) )
    {
#ifdef _DEBUG
        wsprintf(
            szDebug,
            "Failed to get interface pointer for thread %d: 0x%08x (%d)\r\n",
            dwThreadId,
            hr,
            hr
            );

        OutputDebugString(szDebug);
#endif // _DEBUG

        goto ExitWorkerThread;
    }

    //
    // Completed thread initialization.  Now wait for work
    //

    while (1)
    {
#ifdef _DEBUG
        wsprintf(
            szDebug,
            "Thread %d waiting for work.\r\n",
            dwThreadId
            );

        OutputDebugString(szDebug);
#endif  // _DEBUG

		dwResult = WaitForSingleObject(
            pThreadPool->m_hWorkerThreadSemaphore,
            INFINITE
            );

        //
        // Check to see that the wait succeeded
        //

        if (dwResult != WAIT_OBJECT_0)
        {
#ifdef _DEBUG
            wsprintf(
                szDebug,
                "Thread %d exiting due to wait failure.\r\n",
                dwThreadId
                );

            OutputDebugString(szDebug);
#endif  // _DEBUG

            goto ExitWorkerThread;
        }

        //
        // Get the next work item in the queue.  If the work item is NULL,
        // the thread should exit gracefully.
        //

		pecb = pThreadPool->GetWorkItem();

        if (!pecb)
        {
#ifdef _DEBUG
            wsprintf(
                szDebug,
                "Thread %d exiting gracefully.\r\n",
                dwThreadId
                );

            OutputDebugString(szDebug);
#endif  // _DEBUG

            goto ExitWorkerThread;
        }

        ///////
        // Process the work item
        ///////

#ifdef _DEBUG
        wsprintf(
            szDebug,
            "Thread %d processing work item.\r\n",
            dwThreadId
            );

        OutputDebugString(szDebug);
#endif  // _DEBUG


        //
        // Get the request token from IIS and set the token for this thead
        //

        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_GET_IMPERSONATION_TOKEN,
            &hRequestToken,
            NULL,
            NULL
            );

        SetThreadToken(NULL, hRequestToken);

        //
        // Send headers back to client
        //

        HeaderExInfo.pszStatus = "200 OK";
        HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
        HeaderExInfo.pszHeader = "Content-type: text/html\r\n\r\n";
        HeaderExInfo.cchHeader = strlen( HeaderExInfo.pszHeader );
        HeaderExInfo.fKeepConn = FALSE;

        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderExInfo,
            NULL,
            NULL
            );

        //
        // Build the output using the result of the call to
        // GetUserNameObj's GetMyName method
        //
    
        wsprintf(
            szOutput,
            "<h1>Request handled by thread %d.</h1>"
            "<hr>The GetMyName method returned %s.",
            dwThreadId,
            (char *)pItf->GetMyName( )
            );

        //
        // Send the output back to the client
        //
    
        dwBuffSize = strlen( szOutput );
        pecb->WriteClient( pecb->ConnID, szOutput, &dwBuffSize, 0 );

        //
        // Notify IIS that we are done processing the request
        //

        pecb->ServerSupportFunction(
            pecb->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            NULL,
            NULL,
            NULL
            );
    }

ExitWorkerThread:

    //
    // Uninitialize COM for this thread and return
    //

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\formdump\formdump.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    formdump.cpp

Abstract:

    ISAPI Extension sample illustrating how to obtain data from a web browser
    and how to build a reply to the form. 

--*/

#define WIN32_LEAN_AND_MEAN     // the bare essential Win32 API
#include <windows.h>
#include <ctype.h>              // for isprint()
#include <httpext.h>

#include "keys.h"
#include "html.h"

//
// local prototypes
// 
void SendVariables( EXTENSION_CONTROL_BLOCK * pECB );
void HexDumper( EXTENSION_CONTROL_BLOCK * pECB, LPBYTE lpbyBuf, DWORD dwLength );
void WhoAmI( EXTENSION_CONTROL_BLOCK * pECB );
BOOL SendHttpHeaders( EXTENSION_CONTROL_BLOCK *, LPCSTR, LPCSTR );


BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO * pVer
    )
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
    //
    // set version to httpext.h version constants
    //
    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    lstrcpyn((LPSTR) pVer->lpszExtensionDesc,
        "FORMDUMP - A Form Decoder and Dumper",
        HSE_MAX_EXT_DLL_NAME_LEN);

    return TRUE;
}       


DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:

    Pull in all inbound data.  Build a reply page
    so the user can see how forms appear in our key list.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS on successful completion
    HSE_STATUS_ERROR on failure

--*/
{
    HKEYLIST hKeyList;
    char szMsg[128];

    //
    // Get the keys sent by the client
    //
    
    hKeyList = GetKeyList( pECB );

    
    //
    // Send HTTP headers 
    //
    
    SendHttpHeaders( pECB, "200 OK", "Content-type: text/html\r\n\r\n" );

    //
    // Create a basic HTML page
    //
    
    HtmlCreatePage( pECB, "FormDump.dll Reply" );
    HtmlHeading( pECB, 1, "Data Available via ISAPI" );
    HtmlHorizontalRule( pECB );

    // 
    // Send each form field
    // 

    HtmlHeading( pECB, 2, "Form Fields" );

    if ( !hKeyList ) {
    
        //
        // Report no data/error
        //
        
        HtmlBold( pECB, "No form fields sent" );
        HtmlWriteText( pECB, " (or error decoding keys)" );
        HtmlEndParagraph( pECB );
        
    } else {
        HKEYLIST hKey;

        //
        // Print a quick overview
        //
        
        HtmlWriteTextLine( pECB, "The form you submitted data to just called" );
        HtmlWriteTextLine( pECB, "the Internet Information Server extension" );
        HtmlWriteTextLine( pECB, "FormDump.dll.  Here is a listing of what was" );
        HtmlWriteTextLine( pECB, "received and what variables inside FormDump" );
        HtmlWriteTextLine( pECB, "have the data." );
        HtmlEndParagraph( pECB );

        //
        // Loop through all of the keys
        //
        hKey = hKeyList;
        while ( hKey ) {
        
            //
            // Details about the key
            //
            
            LPCTSTR lpszKeyName;
            DWORD dwLength;
            BOOL bHasCtrlChars;
            int nInstance;
            HKEYLIST hLastKey;

            //
            // We get info, and hKey points to next key in list
            //
            
            hLastKey = hKey;    // keep this for later

            hKey = GetKeyInfo( hKey, &lpszKeyName, &dwLength,
                &bHasCtrlChars, &nInstance );

            //
            // Build web page
            //
            
            HtmlBold( pECB, "Form Field Name (lpszKeyName): " );
            HtmlWriteText( pECB, lpszKeyName );
            HtmlLineBreak( pECB );

            HtmlBold( pECB, "Length of Data (dwLength): " );
            wsprintf( szMsg, "%u", dwLength );
            HtmlWriteText( pECB, szMsg );
            HtmlLineBreak( pECB );

            HtmlBold( pECB, "Data Has Control Characters (bHasCtrlChars): " );
            wsprintf( szMsg, "%u", bHasCtrlChars );
            HtmlWriteText( pECB, szMsg );
            HtmlLineBreak( pECB );

            HtmlBold( pECB, "Instance of Form Field (nInstance): " );
            wsprintf( szMsg, "%u", nInstance );
            HtmlWriteText( pECB, szMsg );

            if ( dwLength ) {
                HtmlLineBreak( pECB );
                HtmlBold( pECB, "Data Sent for Field:" );
                HtmlLineBreak( pECB );

                HexDumper( pECB, GetKeyBuffer( hLastKey ), dwLength );
            }
            HtmlEndParagraph( pECB );
        }
    
        //
        // Clean up
        //
        
        FreeKeyList( hKeyList );
    }

    HtmlHorizontalRule( pECB );


    // 
    // Get user name from SID and return it in the page
    // 

    HtmlHeading( pECB, 2, "Security Context for HttpExtensionProc Thread" );
    WhoAmI( pECB );
    HtmlHorizontalRule( pECB );


    // 
    // Display all server variables
    // 

    HtmlHeading( pECB, 2, "Server Variables" );
    HtmlWriteTextLine( pECB, 
        "Below is a list of all variables available via" );
    HtmlWriteTextLine( pECB, "GetServerVariable ISAPI API.  Much of this" );
    HtmlWriteTextLine( pECB, 
        "information comes from the browser HTTP header." );
    HtmlEndParagraph( pECB );

    //
    // Send server variables obtained from the HTTP header
    //
    
    SendVariables( pECB );


    //
    // Finish up...
    //
    
    HtmlEndPage( pECB );

    return HSE_STATUS_SUCCESS;
}


BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
)
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}




void
HexDumper(
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN LPBYTE lpbyBuf,
    IN DWORD dwLength
)
/*++

Purpose:

    Put the inbound data in a hex dump format

Arguments:
    
    pECB - points to the extension control block
    lpbyByf - bytes to dump
    dwLength - specifies the number of bytes to dump
    
--*/
{
    DWORD dwSize;
    char szLine[80];
    char szHex[3];
    DWORD i;
    DWORD dwPos = 0;

    HtmlBeginPreformattedText( pECB );

    while (dwLength) {
    
        //
        // Take min of 16 or dwLength
        //
        
        dwSize = min(16, dwLength );

        //
        // Build text line
        //
        
        wsprintf(szLine, "  %04X ", dwPos );

        for (i = 0; i < dwSize; i++) {
            wsprintf(szHex, "%02X", lpbyBuf[i] );
            lstrcat(szLine, szHex );
            lstrcat(szLine, " " );
        }

        //
        // Add spaces for short lines
        //
        
        while (i < 16) {
            lstrcat(szLine, "   " );
            i++;
        }

        //
        // Add ASCII chars
        //
        
        for (i = 0; i < dwSize; i++) {
            if (isprint(lpbyBuf[i])) {
                wsprintf(szHex, "%c", lpbyBuf[i] );
                lstrcat(szLine, szHex );
            } else {
                lstrcat(szLine, "." );
            }
        }

        //
        // Write data to web page
        //
        
        HtmlWriteTextLine( pECB, szLine );

        //
        // Advance positions
        //
        
        dwLength -= dwSize;
        dwPos += dwSize;
        lpbyBuf += dwSize;
    }

    HtmlEndPreformattedText( pECB );
}


void
DumpVariable(
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN LPCTSTR szName
)
/*++

Purpose:
    
    Dump a server variable

Arguments:

    pECB - points to the extension control block
    lpbyByf - points to ASCIIZ name of the server variable to dump
    
--*/    
{
    DWORD dwBufferSize;
    char szBuffer[4096];
    BOOL bReturn;

    dwBufferSize = sizeof szBuffer;
    bReturn = pECB->GetServerVariable( pECB->ConnID,
        (LPSTR) szName,
        szBuffer,
        &dwBufferSize );

    if ( !bReturn || !szBuffer[0] )
        return;

    HtmlWriteText( pECB, szName );
    HtmlWriteText( pECB, "=" );
    HtmlWriteText( pECB, szBuffer );
    HtmlLineBreak( pECB );
}


BOOL 
SendHttpHeaders( 
    EXTENSION_CONTROL_BLOCK *pECB, 
    LPCSTR pszStatus,
    LPCSTR pszHeaders
)
/*++

Purpose:
    Send specified HTTP status string and any additional header strings
    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO

Arguments:

    pECB - pointer to the extension control block
    pszStatus - HTTP status string (e.g. "200 OK")
    pszHeaders - any additional headers, separated by CRLFs and 
                 terminated by empty line

Returns:

    TRUE if headers were successfully sent
    FALSE otherwise

--*/
{
    HSE_SEND_HEADER_EX_INFO header_ex_info;
    BOOL success;

    header_ex_info.pszStatus = pszStatus;
    header_ex_info.pszHeader = pszHeaders;
    header_ex_info.cchStatus = strlen( pszStatus );
    header_ex_info.cchHeader = strlen( pszHeaders );
    header_ex_info.fKeepConn = FALSE;


    success = pECB->ServerSupportFunction(
                  pECB->ConnID,
                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                  &header_ex_info,
                  NULL,
                  NULL
                  );

    return success;
}


void
SendVariables(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:

    Send all server variables (they came in the HTTP header)
    
Arguments:

    pECB - pointer to the extension control block
    
--*/    
{
    char *pChar, *pOpts, *pEnd;
    DWORD dwBufferSize;
    char szBuffer[4096];
    BOOL bReturn;

    // 
    // Dump the standard variables
    // 

    DumpVariable( pECB, "AUTH_TYPE" );
    DumpVariable( pECB, "CONTENT_LENGTH" );
    DumpVariable( pECB, "CONTENT_TYPE" );
    DumpVariable( pECB, "GATEWAY_INTERFACE" );
    DumpVariable( pECB, "PATH_INFO" );
    DumpVariable( pECB, "PATH_TRANSLATED" );
    DumpVariable( pECB, "QUERY_STRING" );
    DumpVariable( pECB, "REMOTE_ADDR" );
    DumpVariable( pECB, "REMOTE_HOST" );
    DumpVariable( pECB, "REMOTE_USER" );
    DumpVariable( pECB, "REQUEST_METHOD" );
    DumpVariable( pECB, "SCRIPT_NAME" );
    DumpVariable( pECB, "SERVER_NAME" );
    DumpVariable( pECB, "SERVER_PORT" );
    DumpVariable( pECB, "SERVER_PROTOCOL" );
    DumpVariable( pECB, "SERVER_SOFTWARE" );
    DumpVariable( pECB, "AUTH_PASS" );


    // 
    // Dump any others (in ALL_HTTP)
    // 

    dwBufferSize = sizeof szBuffer;
    bReturn = pECB->GetServerVariable( pECB->ConnID,
        "ALL_HTTP",
        szBuffer,
        &dwBufferSize );

    if ( bReturn ) {
        // 
        // Find lines, split key/data pair and write them as output
        // 

        pChar = szBuffer;
        while ( *pChar ) {
            if ( *pChar == '\r' || *pChar == '\n' ) {
                pChar++;
                continue;
            }
            pOpts = strchr( pChar, ':' );   // look for separator

            if ( !pOpts )
                break;
            if ( !*pOpts )
                break;

            pEnd = pOpts;
            while ( *pEnd && *pEnd != '\r' && *pEnd != '\n' )
                pEnd++;

            *pOpts = 0;         // split strings

            *pEnd = 0;

            // 
            // pChar points to variable name, pOpts + 1 points to variable
            // val
            // 

            HtmlWriteText( pECB, pChar );
            HtmlWriteText( pECB, "=" );
            HtmlWriteText( pECB, pOpts + 1 );
            HtmlLineBreak( pECB );

            pChar = pEnd + 1;
        }
    }
    HtmlEndParagraph( pECB );
    HtmlHorizontalRule( pECB );
}


void
WhoAmI(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:
    
    Get the user SID, lookup the account name and display it

Arguments:

    pECB - pointer to the extension control block
    
--*/    
{
    HANDLE hToken;
    PTOKEN_USER pTokenUser;
    BYTE byBuf[1024];
    DWORD dwLen;
    char szName[256], szDomain[256];
    DWORD dwNameLen, dwDomainLen;
    SID_NAME_USE eUse;

    if ( !OpenThreadToken( 
            GetCurrentThread( ), TOKEN_QUERY, TRUE, &hToken ) ) {
            
        DWORD dwError = GetLastError( );

        HtmlBold( pECB, "OpenThreadToken failed. " );
        HtmlPrintf( pECB, "Error code=%u", dwError );
        HtmlEndParagraph( pECB );
        return;
    }
    
    pTokenUser = (PTOKEN_USER) byBuf;
    if ( !GetTokenInformation(
            hToken, TokenUser, pTokenUser, sizeof byBuf, &dwLen ) ) {
            
        DWORD dwError = GetLastError( );

        CloseHandle( hToken );

        HtmlBold( pECB, "GetTokenInformation failed. " );
        HtmlPrintf( pECB, "Error code=%u dwLen=%u", dwError, dwLen );
        HtmlEndParagraph( pECB );
        return;
    }
    
    dwNameLen = sizeof szName;
    dwDomainLen = sizeof szDomain;
    if ( !LookupAccountSid( NULL, pTokenUser->User.Sid,
            szName, &dwNameLen,
            szDomain, &dwDomainLen, &eUse )) {
            
        DWORD dwError = GetLastError( );

        CloseHandle( hToken );

        HtmlBold( pECB, "LookupAccountSid failed. " );
        HtmlPrintf( pECB, "Error code=%u dwNameLen=%u dwDomainLen=%u",
            dwError, dwNameLen, dwDomainLen );
        HtmlEndParagraph( pECB );
        return;
    }
    
    HtmlBold( pECB, "Domain: " );
    HtmlWriteText( pECB, szDomain );
    HtmlLineBreak( pECB );
    HtmlBold( pECB, "User: " );
    HtmlWriteText( pECB, szName );
    HtmlEndParagraph( pECB );

    CloseHandle( hToken );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\com\isapithread.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:    IsapiThread.h

Abstract:

    Header file for the IsapiThread class

Author:

    Wade A. Hilmo, April 1998

--*/

#ifndef _ISAPITHREAD_DEFINED
#define _ISAPITHREAD_DEFINED

#include <windows.h>
#include <httpext.h>

class ISAPITHREAD
{
public:

	//
	// Semaphore handle
	//

	HANDLE m_hWorkerThreadSemaphore;

	//
	// Init and queue functions
	//

	BOOL InitThreadPool(
		LPTHREAD_START_ROUTINE pThreadProc,	// Worker thread proc
		DWORD dwNumThreads = 5,				// number of threads in pool
		DWORD dwQueueSize = 0xffffffff		// size of work item queue
		);

	BOOL QueueWorkItem(
		EXTENSION_CONTROL_BLOCK *pecb,	// ECB to queue
        BOOL fReleaseThread = TRUE      // Release thread automatically?
		);

	EXTENSION_CONTROL_BLOCK * GetWorkItem(
		void
		);

	void ReleaseThread(
		DWORD dwNumThreads = 1			// Number of threads to release
		);

	void ClearQueue(
		void
		);

	//
	// Constructor and destructor
	//

	ISAPITHREAD(void);
	~ISAPITHREAD(void);

private:

	EXTENSION_CONTROL_BLOCK **m_WorkItemQueue;
	CRITICAL_SECTION m_csQueue;
	DWORD m_dwNumThreads;
	DWORD m_dwWorkItemQueueSize;
	DWORD m_dwCurrentItem;
	DWORD m_dwItemsInQueue;
	HANDLE *m_arrWorkerThreads;
};

#endif	// _ISAPITHREAD_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\formdump\keys.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    keys.h

Abstract:

    header file for reusable interface

--*/

// Abstracted pointer
typedef void * HKEYLIST;

//
// Retrieves and decodes inbound form data.  Builds list of keys, and
// pointers to data within a content file.  Returns handle to first
// element in the list.
//

HKEYLIST GetKeyList(IN EXTENSION_CONTROL_BLOCK *pECB);

//
// GetKeyInfo extracts the key name and content values from the
// supplied key, and returns a handle to the next key in the list.
//
// The length is the exact length of the inbound data, but a NULL
// is appended to the data.  For example, a text string of five
// characters has a *pdwLength=5, but GetKeyBuffer returns at
// least a 6 byte buffer--the five characters and a NULL.
//

HKEYLIST GetKeyInfo(IN HKEYLIST hKey, OUT LPCSTR *plpszKeyName, 
                    OUT LPDWORD pdwLength, OUT BOOL *pbHasCtrlChars,
                    OUT LPINT pnInstance);

//
// GetKeyBuffer returns a pointer to the buffer holding data.
// Depending on the implementation in keys.cpp, this may or may not
// be a buffer the exact size of the data (it may be bigger).
//
// The data is zero-terminated.
//

LPBYTE GetKeyBuffer(IN HKEYLIST hKey);


//
// FindKey sequentially searches the linked list for a specific key.
// The return handle can be used with GetKeyInfo to get more details.
// FindKey returns the very first occurance of a duplicate key.
// Also, it searches from the given key which need not be the head
// key.
//

HKEYLIST FindKey(IN HKEYLIST hKeyList, IN LPCSTR lpszSearchName);


//
// FreeKeyList releases all of the memory associated with a key list.
// Also, content resources are deleted.
//

void FreeKeyList(IN HKEYLIST hKeyList);


//
// GetKeyOffset returns the offset within the internal buffer or
// the content file.  Under normal circumstances, use GetKeyInfo
// and GetKeyBuffer instead of directly accessing the buffer.
//

DWORD GetKeyOffset(IN HKEYLIST hKey);


#ifdef USE_TEMPORARY_FILES
//
// GetContentFile returns the name of the temporary file used
// to save the content.  The temporary file may be open.
//

LPCTSTR GetContentFile(IN HKEYLIST hKeyList);

//
// CloseContentFile forces the content file to be closed.  This
// allows you to pass the file to something else that may open
// it.  Call OpenContentFile before calling any other key
// function.
//

void CloseContentFile(IN HKEYLIST hKeyList);


//
// OpenContentFile forces the content file to be reopened.
// GetKeyBuffer will fail if the content file was closed by
// CloseContentFile, but not reopened.
//

void OpenContentFile(IN HKEYLIST hKeyList);

#else

//
// GetDataBuffer returns a pointer to the start of the data
// buffer which holds all content.  This function is not
// particularly useful -- use GetKeyBuffer to get a pointer
// to the buffer for a specific key.
//

LPBYTE GetDataBuffer(IN HKEYLIST hKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\formdump\html.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    html.h

Abstract:

    Header file for HTML authoring functions 

--*/


// Direct write of text, no translation
void WriteString (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpsz);

// Required page definition functions
void HtmlCreatePage (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszTitle);
void HtmlEndPage (IN EXTENSION_CONTROL_BLOCK *pECB);

// Rest of the calls are optional
void HtmlHeading (IN EXTENSION_CONTROL_BLOCK *pECB, IN int nHeading, 
                  IN LPCSTR lpszText);
void HtmlBeginHeading (IN EXTENSION_CONTROL_BLOCK *pECB, IN int nHeading);
void HtmlEndHeading (IN EXTENSION_CONTROL_BLOCK *pECB, IN int nHeading);

void HtmlWriteTextLine (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpsz);
void HtmlWriteText (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpsz);
void HtmlEndParagraph (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlHyperLink (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszDoc, 
                    IN LPCSTR lpszText);

void HtmlHyperLinkAndBookmark (IN EXTENSION_CONTROL_BLOCK *pECB, 
                               IN LPCSTR lpszDoc, IN LPCSTR lpszBookmark,
                               IN LPCSTR lpszText);

void HtmlBookmarkLink (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszBookmark,
                       IN LPCSTR lpszText);

void HtmlBeginListItem (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginUnnumberedList (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndUnnumberedList (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginNumberedList (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndNumberedList (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginDefinitionList (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndDefinitionList (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlDefinition (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszTerm,
                     LPSTR lpszDef);

void HtmlBeginDefinitionTerm (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlBeginDefinition (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginPreformattedText (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndPreformattedText (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginBlockQuote (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndBlockQuote (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginAddress (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndAddress (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginDefine (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndDefine (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginEmphasis (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndEmphasis (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginCitation (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndCitation (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginCode (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndCode (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginKeyboard (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndKeyboard (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginStatus (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndStatus (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginStrong (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndString (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBeginVariable (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndVariable (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlBold (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszText);
void HtmlBeginBold (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndBold (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlItalic (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszText);
void HtmlBeginItalic (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndItalic (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlFixed (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszText);
void HtmlBeginFixed (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlEndFixed (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlLineBreak (IN EXTENSION_CONTROL_BLOCK *pECB);
void HtmlHorizontalRule (IN EXTENSION_CONTROL_BLOCK *pECB);

void HtmlImage (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszPicFile,
                IN LPCSTR lpszAltText);

void HtmlPrintf (IN EXTENSION_CONTROL_BLOCK *pECB, IN LPCSTR lpszFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\formdump\keys.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    keys.cpp

Abstract:

   This module contains functions which deal with keys and values 
   on inbound form data. Please, see keys.h for details.

--*/
#define WIN32_LEAN_AND_MEAN     // the bare essential Win32 API
#include <windows.h>                                                                    
#include <httpext.h>

//
// If your application plans to receive huge amounts of data
// and you don't want megabytes of memory allocated, define
// the USE_TEMPORARY_FILES.  It is recommended to leave the
// define line below commented out unless absolutely necessary.
// 

//#define USE_TEMPORARY_FILES

#include "keys.h"

#ifndef USE_MEMORY

#ifndef USE_TEMPORARY_FILES
#define USE_MEMORY
#endif

#endif


//
// If you want to record errors, modify this macro definition to
// call your own logging function.  This sample does not save
// error strings.
// 
#define LOG(errorstring)        // OutputDebugString( errorstring ); \
                                // OutputDebugString ( "\r\n" )

//
// 
// Intended external interface:
// 
// GetKeyList       Determines if data was sent, and if it was, the
// data is extracted by GetPostKeys or GetUrlKeys,
// two private functions within this file.  A 
// pointer to a linked list is returned ( as a 
// handle ).
// 
// GetKeyInfo       Returns a pointer to the key name,
// the length of the data, a flag indicating if
// the data has control characters in it, and an
// instance number for duplicate key names.
// 
// GetKeyBuffer Returns a pointer to the buffer holding the key's
// data.
// 
// FindKey          Sequentially searches linked list for key name.
// 
// FreeKeyList      Deallocates memory used by the linked list of
// keys.  Also deletes content resources.
// 
// GetKeyOffset Returns the offset to either the content memory
// buffer or the content temporary file.
// 
// GetContentFile   Returns a pointer to the temporary file, only
// when USE_TEMPORARY_FILES is defined.
// 
// CloseContentFile Closes the content file, normally left open
// until FreeKeyList is called, available only
// when USE_TEMPORARY_FILES is defined.
// 
// OpenContentFile Reopens the content file for additional use
// by GetKeyBuffer, available only when 
// USE_TEMPORARY_FILES is defined.
// 
// GetDataBuffer    Returns a pointer to the content, only if the
// USE_TEMPORARY_FILES constant is NOT defined.
// 
// Helper functions called only in this source file:
// 
// GetQueryByte Similar to GetPostedByte, this function
// extracts data from the query string.
// 
// HexDigitToInt    Returns the decimal value of a hex character.
// 
// GetFirstByte Sets up POSDATA struct and calls GetNextByte.
// Caller specifies function used to retrieve
// data, either GetPostedByte or GetQueryByte.
// 
// GetNextByte      Uses GetInboundByte ( specified in GetFirstByte )
// to retrieve inbound data, and decodes it using
// the URL encoding rules.
// 
// BKL_Alloc        Allocates memory used in GetPostKeys.
// 
// BKL_Dealloc      Deallocates memory used in GetPostKeys.
// 
// BKL_Abort        Cleans up all resources for abnormal exits from
// GetPostKeys.
// 
// IsKeySeparator   Returns TRUE if character is one of "=\r\n&\0".
// 
// BuildKeyList Given a data extraction function ( i.e.
// GetPostedByte or GetQueryByte ), this function
// converts all keys into a linked list of POSTKEY
// structures.
// 
// GetPostKeys      Takes inbound data off the wire by calling
// BuildKeyList with GetPostedByte as the extraction
// function.
// 
// GetUrlKeys       Extracts data from the query string by calling
// BuildKeyList with GetQueryByte as the extraction
// function.
// 
// GetPropAddr      Calculates the address of the list's properties,
// appended to the first key in a list.
// 
// The typedef for the linked list is kept privately in this file,
// and our interface isolates other source files from the 
// implementation details.
// 

//
// Constants for this source file only
// 

#define MAX_KEY_NAME_LENGTH 256 // maximum size of an inbound key name
#define CONTENT_BUF_LENGTH 8192 // amount of content buffered before
                                // WriteFile call
                                    // ( used for temporary files only )

#define GNB_NOTHING_LEFT 0      // GetNextByte return values
#define GNB_DECODED_CHAR 1
#define GNB_NORMAL_CHAR 2


//
// POSDATA struct is used with GetInboundByte to keep
// track of the position within incoming data.
// GETINBOUNDBYTE is a function pointer type.
// 

typedef struct _tagPOSDATA {
    EXTENSION_CONTROL_BLOCK *pECB;
    int nCurrentPos;            // overall position

    int nBufferLength;          // length of buffer

    int nBufferPos;             // position within buffer

    int nAllocLength;           // size of buffer as allocated

    LPBYTE pData;
    int (*GetInboundByte)(struct _tagPOSDATA * p);
} POSDATA, *PPOSDATA;

typedef int (*GETINBOUNDBYTE)(PPOSDATA p);


#ifdef USE_MEMORY

//
// LISTPROP struct is used to maintain a set of
// list-wide properties.  This implementation
// uses the properties list to hold a buffer
// pointer.
// 

typedef struct _tagLISTPROP {
    LPBYTE lpbyBuf;
} LISTPROP, *PLISTPROP;

#elif defined USE_TEMPORARY_FILES

//
// This LISTPROP struct holds temporary
// file information.
// 

typedef struct _tagLISTPROP {
    char szTempFileName[MAX_PATH];
    HANDLE hFile;
} LISTPROP, *PLISTPROP;

#endif


// This private helper needs a prototype
PLISTPROP GetPropAddr( HKEYLIST hKey );


int 
GetPostedByte( 
    PPOSDATA pPosData 
)
/*++

Purpose:

    GetPostedByte returns a waiting character that is not
    decoded yet.  We have this function to smooth out the
    inbound data: the server gives us blocks of data, one at
    a time, and there can be any number of blocks.
     
    For the first call, pPosData->nAllocLength must be zero,
    and pECB must be set.

Arguments:

    pPostData - pointer to POSTDATA struct

Returns:

    incoming byte value or
    -1 to indicate an error

--*/
{
    int nBytesToCopy;

    // For readability only...
    EXTENSION_CONTROL_BLOCK *pECB;

    pECB = pPosData->pECB;

    // 
    // Initialize position struct on first call.
    // 

    if ( !pPosData->nAllocLength ) {
        // Initialize the members
        pPosData->nCurrentPos = 0;
        pPosData->nBufferPos = 0;
        pPosData->nBufferLength = 0;
        pPosData->nAllocLength = 0x10000;   // 65536 bytes

        // Allocate the memory
        pPosData->pData = (LPBYTE) HeapAlloc( 
            GetProcessHeap( ),
            HEAP_ZERO_MEMORY,
            pPosData->nAllocLength );
    }
    // 
    // Was memory allocated?  Is it still allocated?
    // If not, return right away.
    // 

    if ( !pPosData->pData ) {
        LOG( "GetPostedByte: Buffer not allocated." );
        return -1;
    }
    // 
    // Check for end.  Deallocate and return if we're done.
    // 

    if ( (DWORD) pPosData->nCurrentPos == pECB->cbTotalBytes ) {

        HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData->pData );
        pPosData->pData = 0;

        return -1;
    }

    // 
    // Check for buffer not loaded.  Load if necessary.
    // 

    if ( pPosData->nBufferPos == pPosData->nBufferLength ) {

        // 
        // Fill the buffer with new inbound data.
        // Request it via ReadClient if necessary.
        // 

        if ( pECB->cbAvailable < 1 ) {

            // Calculate how much we should go and get
            nBytesToCopy = pECB->cbTotalBytes - pPosData->nCurrentPos;
            if ( nBytesToCopy > pPosData->nAllocLength ) {
                nBytesToCopy = pPosData->nAllocLength;
            }

            // Let's go get the data
            if ( !pECB->ReadClient( 
                    pECB->ConnID, 
                    pPosData->pData, 
                    (LPDWORD) & nBytesToCopy 
                    )) {
                HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData->pData );
                pPosData->pData = 0;

                LOG( "GetPostedByte: Error reading data via ReadClient" );
                return -1;
            }
        }else{
            // Take at most nAllocLength bytes of data
            if ( pECB->cbAvailable > (DWORD) (pPosData->nAllocLength) ) {
                nBytesToCopy = pPosData->nAllocLength;
            }else{
                nBytesToCopy = pECB->cbAvailable;
            }

            // Copy the inbound data to our buffer
            memcpy( 
                pPosData->pData,
                &pECB->lpbData[pPosData->nCurrentPos],
                nBytesToCopy 
                );

            // Account for removed data
            pECB->cbAvailable -= nBytesToCopy;
        }

        // Our buffer is now full
        pPosData->nBufferLength = nBytesToCopy;
        pPosData->nBufferPos = 0;

        // Make sure we have something
        if ( !nBytesToCopy ) {
            HeapFree( GetProcessHeap( ), 0, (LPVOID) pPosData->pData );
            pPosData->pData = 0;
            return -1;
        }
    }
    // 
    // Inc current pos, buffer pos, and return a character
    // 

    pPosData->nCurrentPos++;
    pPosData->nBufferPos++;
    return ( (int)pPosData->pData[pPosData->nBufferPos - 1] );
}



int 
GetQueryByte( 
    IN OUT PPOSDATA pPosData 
)
/*++

Purpose:

    Returns a waiting character that is not
    decoded yet.  We have this function to match GetPostedData.

    For the first call, pPosData->nAllocLength must be zero,
    and pECB must be set.


Arguments:

    pPostData - points to POSDATA structura

Returns:

    byte value or -1 to indicate an error

--*/
{
    // For readability only...
    EXTENSION_CONTROL_BLOCK *pECB;

    pECB = pPosData->pECB;

    // 
    // Initialize position struct on first call.
    // 

    if ( !pPosData->nAllocLength ) {
        // Initialize the useful members
        pPosData->nBufferPos = 0;
        pPosData->nBufferLength = lstrlen( (LPCSTR) pECB->lpszQueryString );
        pPosData->nAllocLength = -1;

        char szMsg[256];

        wsprintf( 
            szMsg, 
            "pPosData->nBufferLength=%i", 
            pPosData->nBufferLength 
            );
        LOG( szMsg );
    }

    // 
    // Check for end.  Deallocate and return if we're done.
    // 

    if ( pPosData->nBufferPos == pPosData->nBufferLength ) {
        return -1;
    }

    // 
    // Inc buffer pos and return a character
    // 

    pPosData->nBufferPos++;
    return ( (int)pECB->lpszQueryString[pPosData->nBufferPos - 1] );
}


//
// Now that we have GetPostedByte, and GetQueryByte, we can 
// build a more useful function that decodes URL-style 
// encoded characters.
// 
// Recall that there are two special cases for this encoding:
// 
// 1. Each plus sign must be converted to a space
// 2. A percent sign denotes a hex value-encoded character
// 
// Percents are used to specify characters that are otherwise
// illegal.  This includes percents themselves, ampersands,
// control characters, and so on.
// 
// GetNextByte returns the decoded byte, plus a flag indicating
// normal character, decoded character, or failure.  See top of  
// file for return value constants.
// 


int 
HexDigitToInt( 
    IN char c 
)
/*++

Purpose:
    HexDigitToInt simply converts a hex-based character to an int.

Arguments:
    tc - character to convert

Returns:
    binary value of the character (0-15)
    -1 if the character is not hex digit

--*/
{
    if ( c >= '0' && c <= '9' ) {
        return ( c - '0' );
    }

    if ( tolower( c ) >= 'a' && tolower( c ) <= 'f' ) {
        return ( tolower( c ) - 'a'  + 10 );
    }

    return -1;
}


int 
GetNextByte( 
    IN OUT PPOSDATA pPosData, 
    OUT char * pc 
)
/*++

Purpose:
    Decode single byte of the input data

Arguments:
    pPostData - points to POSDATA struct
    pc - points to variable to accept decoded byte

Returns:
    GNB_NORMAL_CHAR, GNB_NOTHING_LEFT or GNB_DECODED_CHAR

--*/
{
    int nChar;
    int nDigit;

    // Initialize character pointer
    *pc = 0;

    // Fetch the next inbound character
    nChar = pPosData->GetInboundByte( pPosData );
    if ( nChar == -1 ) {
        return GNB_NOTHING_LEFT;
    }

    // Plus signs: convert to spaces
    if ( nChar == '+' ) {
        *pc = ' ';
        return GNB_DECODED_CHAR;
    }
    // Percent signs: convert hex values
    else if ( nChar == '%' ) {
        nChar = pPosData->GetInboundByte( pPosData );
        nDigit = HexDigitToInt( nChar );
        if ( nDigit == -1 ) {
            return GNB_NOTHING_LEFT;
        }

        *pc = ( char ) ( ( UINT ) nDigit << 4 );

        nChar = pPosData->GetInboundByte( pPosData );
        nDigit = HexDigitToInt( nChar );
        if ( nDigit == -1 ) { 
            *pc = 0;            // incomplete

            return GNB_NOTHING_LEFT;
        }
        *pc |= ( char ) ( UINT ) nDigit;

        return GNB_DECODED_CHAR;
    }
    // Must be normal character then
    *pc = (char) nChar;

    return GNB_NORMAL_CHAR;
}


int 
GetFirstByte( 
    IN OUT PPOSDATA pPosData,
    IN EXTENSION_CONTROL_BLOCK * pECB,
    OUT char * pc, 
    IN GETINBOUNDBYTE GetInboundByte 
)
/*++

Purpose:

    GetFirstByte eliminates the guesswork from initialization.
    We call GetFirstByte with an uninitialized POSDATA structure,
    and we call GetNextByte from there on.

Arguments:
    pPosData - points to POSDATA struct to initialize
    pECB - points to the extenstion control block 
    pc - points to variable to accept decoded byte
    GetInboundByte - points to function to get incoming bytes


Returns:
    same as GetNextByte()

--*/
{
    // Initialize struct
    pPosData->nAllocLength = 0;
    pPosData->pECB = pECB;
    pPosData->GetInboundByte = GetInboundByte;

    // Make the call as usual
    return GetNextByte( pPosData, pc );
}


//
// Structure used in data processing - the elements of the
// key list.
// 

typedef struct _tagPOSTKEY {
    int nInstance;              // used when key name is the same as another, 
                                // normally 0

    DWORD dwOffset;             // offset into content file
    DWORD dwLength;             // length of data
    BOOL bHasCtrlChars;         // a character value < 32 is in data
    struct _tagPOSTKEY *pNext;  // linked list
    struct _tagPOSTKEY *pHead;  // first in linked list
    LPBYTE lpbyBuf;             // pointer to the key's data in the list
                                // buffer

    // key string appended to structure
    // for the head key, list properties are appended
} POSTKEY, *PPOSTKEY;



//
// These three helper functions isolate the memory allocation, 
// deallocation and abnormal exit code.  They are used only to 
// keep BuildKeyList readable.
// 


BOOL 
BKL_Alloc( 
    OUT LPSTR * plpszKey, 
    OUT LPBYTE * plpbyBuf 
)
{
    // Allocate a buffer for the key name
    *plpszKey = (LPSTR) HeapAlloc( GetProcessHeap( ),
        HEAP_ZERO_MEMORY,
        MAX_KEY_NAME_LENGTH );

    if ( !*plpszKey ) {
        return FALSE;
    }

#ifdef USE_MEMORY
    // Init buffer to NULL
    *plpbyBuf = NULL;

#elif defined USE_TEMPORARY_FILES

    // Allocate a buffer for the content
    *plpbyBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ),
        HEAP_ZERO_MEMORY,
        CONTENT_BUF_LENGTH );

    if ( !*plpbyBuf ) {
        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpszKey );
        return FALSE;
    }
#endif

    return TRUE;
}


void 
BKL_Dealloc( 
    IN LPSTR * plpsz, 
    IN LPBYTE * plpby 
)
{
    if ( plpsz && *plpsz ) {
        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpsz );
    }
    if ( plpby && *plpby ) {
        HeapFree( GetProcessHeap( ), 0, (LPVOID) * plpby );
    }
}

//
// This allows us to clean up... with temporary files we have to close
// and delete them.  Otherwise, we have to free a lot of memory.
// 

#ifdef USE_TEMPORARY_FILES
#define MACRO_AbortCleanup BKL_Abort( pHead, hDataFile, \
    lpszKeyNameBuf, lpbyContentBuf );\
    if ( hDataFile != INVALID_HANDLE_VALUE ) DeleteFile( szTempPath )

#elif defined USE_MEMORY

#define MACRO_AbortCleanup BKL_Abort( pHead, INVALID_HANDLE_VALUE, \
    lpszKeyNameBuf,lpbyContentBuf ) 
#endif


void 
BKL_Abort( 
    IN PPOSTKEY pHead, 
    IN HANDLE hFile, 
    IN LPSTR lpszKey, 
    IN LPBYTE lpbyBuf 
)
{
    if ( pHead ) {
        FreeKeyList( (HKEYLIST) pHead );
    }

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
    }

    BKL_Dealloc( &lpszKey, &lpbyBuf );
}


BOOL 
IsKeySeparator( 
    char c 
)
/*++

Purpose:
    Identify key separators

Arguments:
    c - character

Returns:
    TRUE if character is a key separator,
    FALSE otherwise

--*/
{
    return ( c == '=' || c == '\r' || c == '\n' || c == '&' || !c );
}


PPOSTKEY 
BuildKeyList( 
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN GETINBOUNDBYTE GetInboundByte 
)
/*++

Purpose:

    Now that we have a way to get a decoded byte from the stream,
    we can parse POST data.  POST data comes in as:

    key=data&key=data&key=data\r\n

    A linked list of keys is established, and the head node
    of the list is returned.  A NULL indicates no keys or
    an error.


Arguments:
    pECB - pointer to the extension control block
    GetInboundByte - pointer to function to get input data

Returns:
    Pointer to the head node or NULL

--*/
{
    PPOSTKEY pHead = NULL;      // head of linked list ( the return val )
    PPOSTKEY pTail = NULL;      // last member in linked list
    PPOSTKEY pNewPostKey;       // pointer for unlinked, newly allocated
                                // objects

    PPOSTKEY pListWalk;         // linked list walking pointer
    PLISTPROP pProp;            // pointer to list properties
    LPSTR lpszKeyNameBuf;       // pointer to buffer, used in obtaining key
                                // name

    int nPos;                   // position within key name buffer
    DWORD dwOffset;             // offset from start of content buffer or
                                // file

    DWORD dwLength;             // length of key data
    char c;                     // general-purpose character
    int nReturn;                // general-purpose return code
    POSDATA pd;                 // POSDATA struct needed in GetInboundByte
    int nContentPos;            // position within content buffer
    LPBYTE lpbyContentBuf;      // pointer to buffer
    BOOL bHasCtrlChars;         // flag to detect ctrl chars

    // Call helper to allocate a buffer
    if ( !BKL_Alloc( &lpszKeyNameBuf, &lpbyContentBuf ) ) {
        LOG( "BuildKeyList: Memory allocation failure" );
        return NULL;
    }
    nContentPos = dwOffset = 0;


#ifdef USE_MEMORY
    // 
    // Allocate enough memory for all the content.
    // For the POST method, the cbTotalBytes gives us the number
    // of bytes that are being sent by the browser.  We can 
    // allocate that much but we'll really only use about 75% of it.
    // For the GET method, we need to allocate the size of the
    // query string plus 1.
    // 

    lpbyContentBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ),
        HEAP_ZERO_MEMORY,
        pECB->cbTotalBytes +
        lstrlen( pECB->lpszQueryString ) + 1 );

    if ( !lpbyContentBuf ) {

        LOG( "BuildKeyList: Error allocating content memory" );
        BKL_Dealloc( &lpszKeyNameBuf, &lpbyContentBuf );

        return NULL;
    }
#elif defined USE_TEMPORARY_FILES

    // 
    // When USE_TEMPORARY_FILES is chosen, we create
    // a temporary file to store all the inbound data.
    // This is done to support huge amounts of inbound
    // data, like file uploads.
    // 

    char szTempDir[MAX_PATH];   // directory of temporary files
    char szTempPath[MAX_PATH];  // path of content file
    HANDLE hDataFile;           // handle to content file
    DWORD dwBytesWritten;       // used with WriteFile

    // Get a temp file name
    GetTempPath( MAX_PATH, szTempDir );
    if ( !GetTempFileName( szTempDir, "key", 0, szTempPath ) ) {

        LOG( "BuildKeyList: Error creating temporary file" );
        BKL_Dealloc( &lpszKeyNameBuf, &lpbyContentBuf );

        return NULL;
    }
    // Create the content file
    hDataFile = CreateFile( szTempPath,
        GENERIC_READ | GENERIC_WRITE,
        0,                      // No sharing mode
        NULL,                   // Default security attribs
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL                    // No template file
        );

    // Return if an error occured
    if ( hDataFile == INVALID_HANDLE_VALUE ) {
        LOG( "BuildKeyList: Error opening temporary file" );
        MACRO_AbortCleanup;
        return NULL;
    }
#endif


    // 
    // 'for' statement detects the start of a valid key name.
    // 
    // To do inside 'for' loop:
    // Obtain key name
    // Write data to buffer or content file
    // Create POSTKEY object
    // Update links
    // 

    for ( nReturn = GetFirstByte( &pd, pECB, &c, GetInboundByte );
        nReturn != GNB_NOTHING_LEFT;
        nReturn = GetNextByte( &pd, &c ) ) {
            
        // If \r or \n, ignore and continue
        if ( c == '\r' || c == '\n' ) {
            continue;
        }

        // Get a key name
        nPos = 0;
        while ( !IsKeySeparator( c ) ) {
            if ( nPos < MAX_KEY_NAME_LENGTH ) {
                lpszKeyNameBuf[nPos] = c;
                nPos++;
            }
            nReturn = GetNextByte( &pd, &c );
            if ( nReturn == GNB_NOTHING_LEFT )  { // abrupt end!
                break;
            }
        }

        // If no equals sign or name too long,
        // we have a browser formatting error
        if ( c != '=' || nPos == MAX_KEY_NAME_LENGTH ) {
            LOG( "BuildKeyList: Browser formatting error" );

            MACRO_AbortCleanup;
            return NULL;
        }

        // Truncate the name string, reset data info variables
        lpszKeyNameBuf[nPos] = 0;
        nPos++;
        dwLength = 0;
        bHasCtrlChars = FALSE;

        // 
        // Move the data to the content buffer or file.
        // 
        for ( nReturn = GetNextByte( &pd, &c );
            !IsKeySeparator( c ) || nReturn == GNB_DECODED_CHAR;
            nReturn = GetNextByte( &pd, &c ) ) {

            lpbyContentBuf[nContentPos] = c;

            nContentPos += sizeof ( char );
            dwLength++;

            // Check for ctrl chars
            if ( c < 0x20 ) {
                bHasCtrlChars = TRUE;
            }

#ifdef USE_TEMPORARY_FILES
            // If we have enough data, write buffer to disk
            if ( nContentPos == CONTENT_BUF_LENGTH ) {
                if ( !WriteFile( hDataFile, lpbyContentBuf,
                    nContentPos, &dwBytesWritten, NULL ) ) {

                    LOG( "BuildKeyList: Error writing to content file" );
                    MACRO_AbortCleanup;
                    return NULL;
                }
                nContentPos = 0;
            }
#endif

        } // for( nReturn


#ifdef USE_MEMORY
        // 
        // Put a terminating NULL at the end of the key data.
        // 

        lpbyContentBuf[nContentPos] = 0;
        nContentPos++;

#elif defined USE_TEMPORARY_FILES

        // Drain buffer
        if ( nContentPos ) {
            if ( !WriteFile( hDataFile, lpbyContentBuf,
                nContentPos, &dwBytesWritten, NULL ) ) {

                LOG( "BuildKeyList: Error writing to content file" );
                MACRO_AbortCleanup;
                return NULL;
            }
            nContentPos = 0;
        }
#endif


        // Allocate a POSTKEY object, allocate extra for first key
        if ( pHead ) {
            pNewPostKey = (PPOSTKEY) HeapAlloc( 
                GetProcessHeap( ),
                HEAP_ZERO_MEMORY,
                sizeof (POSTKEY) + nPos 
                );
        }else{
            pNewPostKey = (PPOSTKEY) HeapAlloc( 
                GetProcessHeap( ),
                HEAP_ZERO_MEMORY,
                sizeof (POSTKEY) + nPos +
                sizeof (LISTPROP) );

            pProp = (PLISTPROP) ( (LPBYTE)pNewPostKey + 
                    sizeof (POSTKEY) + nPos );
        }

        // Check for valid pointer
        if ( !pNewPostKey ) {
            LOG( "BuildKeyList: POSTKEY memory allocation failure" );
            MACRO_AbortCleanup;
            return NULL;
        }

        // 
        // Set pNewPostKey members
        // 

        // Set nInstance
        pNewPostKey->nInstance = 0;
        pListWalk = pHead;
        while ( pListWalk ) {
            // Check for duplicate key names
            if ( !lstrcmpi( (LPCSTR) ( &pListWalk[1] ), lpszKeyNameBuf )) {
                pNewPostKey->nInstance++;
            }
            pListWalk = pListWalk->pNext;
        }

        // Set dwOffset, dwLength, bHasCtrlChars, lpbyBuf
        pNewPostKey->dwOffset = dwOffset;
        pNewPostKey->dwLength = dwLength;
        pNewPostKey->bHasCtrlChars = bHasCtrlChars;

#ifdef USE_MEMORY
        pNewPostKey->lpbyBuf = &lpbyContentBuf[dwOffset];
        dwOffset += dwLength + 1;

#elif defined USE_TEMPORARY_FILES

        pNewPostKey->lpbyBuf = NULL;
        dwOffset += dwLength;
#endif


        // Copy key name
        lstrcpy( (LPSTR) ( &pNewPostKey[1] ), lpszKeyNameBuf );

        // Link
        if ( pTail ) {
            pTail->pNext = pNewPostKey;
        }else{

#ifdef USE_TEMPORARY_FILES
            // Copy content file name to list properties
            lstrcpy( pProp->szTempFileName, szTempPath );

            // Set handle
            pProp->hFile = hDataFile;

#elif defined USE_MEMORY

            // Set content buffer pointer
            pProp->lpbyBuf = lpbyContentBuf;
#endif

            // Set head
            pHead = pNewPostKey;
        }

        pNewPostKey->pNext = NULL;
        pTail = pNewPostKey;

        pNewPostKey->pHead = pHead;     // may point to itself

    } // for ( nReturn

#ifdef USE_TEMPORARY_FILES
    // 
    // If content file is empty, close it and delete it
    // 

    if ( !pHead ) {
        LOG( "Empty content file is being deleted." );
        CloseHandle( hDataFile );
        DeleteFile( szTempPath );
    }
    // Free work buffer
    BKL_Dealloc( &lpszKeyNameBuf, &lpbyContentBuf );

#elif defined USE_MEMORY

    // Free work buffer
    BKL_Dealloc( &lpszKeyNameBuf, pHead ? NULL : &lpbyContentBuf );
#endif


    return pHead;
}


//
// We are now pretty much done with anything complex. BuildKeyList 
// will do all our parse work, so now we need a few wrappers to
// make a nice, clean external interface.
// 
// GetPostKeys calls BuildKeyList with GetPostedByte.
// 
// GetUrlKeys calls BuildKeyList with GetQueryByte.
// 

PPOSTKEY 
GetPostKeys( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    return BuildKeyList( pECB, GetPostedByte );
}

PPOSTKEY 
GetUrlKeys( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    return BuildKeyList( pECB, GetQueryByte );
}


PLISTPROP 
GetPropAddr( 
    IN HKEYLIST hKey 
)
/*++

Purpose:

    GetPropAddr returns the address of the end of
    the first key.  We stuff list properties there.
    This implementation of keys.cpp keeps a pointer
    to the content buffer.  The second version ( used
    in IS2WCGI ) appends a temporary file name
    to the first key.

Arguments:
    hKey - pointer to a key list

Returns:
    The address of the end of the first key

--*/
{
    LPCSTR lpszKeyName;
    PPOSTKEY pHead;

    // Safety
    if ( !hKey ) {
        return NULL;
    }

    // ContentPath follows POSTKEY struct and key name
    pHead = (PPOSTKEY) hKey;
    pHead = pHead->pHead;

    lpszKeyName = (LPCSTR) ( &pHead[1] );

    return (PLISTPROP) ( lpszKeyName + lstrlen( lpszKeyName ) + 1 );
}


HKEYLIST 
GetKeyList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
/*++

Purpose:

    Examines the method and calls GetPostKeys or GetUrlKeys, 
    whichever is relevant.
 

Arguments:
    pECB - points to the extension control block

Returns:
    GetPropAddr returns the address of the end of
    the first key.  We stuff list properties there.
    This implementation of keys.cpp keeps a pointer
    to the content buffer.  The second version ( used
    in IS2WCGI ) appends a temporary file name
    to the first key.

--*/
{
    if ( !lstrcmpi( pECB->lpszMethod, "POST" ) ) {
        LOG( "Method=POST" );
        return (HKEYLIST) GetPostKeys( pECB );
    }else if ( !lstrcmpi( pECB->lpszMethod, "GET" ) ) {
        LOG( "Method=GET" );
        return (HKEYLIST) GetUrlKeys( pECB );
    }
    LOG( "Unknown method" );

    return NULL;
}


HKEYLIST 
GetKeyInfo( 
    IN HKEYLIST hKey, 
    OUT LPCSTR * plpszKeyName,
    OUT LPDWORD pdwLength, 
    OUT BOOL * pbHasCtrlChars,
    OUT LPINT pnInstance 
)
//
// GetKeyInfo is a wrapper for the POSTKEY linked list.
// It returns the members of the supplied POSTKEY object.
// 
{
    PPOSTKEY pPostKey;

    // Safety
    if ( !hKey ) {
        return NULL;
    }

    pPostKey = (PPOSTKEY) hKey;

    // Set the data members
    if ( plpszKeyName )
        *plpszKeyName = ( LPCSTR ) ( &pPostKey[1] );
    if ( pdwLength )
        *pdwLength = pPostKey->dwLength;
    if ( pbHasCtrlChars )
        *pbHasCtrlChars = pPostKey->bHasCtrlChars;
    if ( pnInstance )
        *pnInstance = pPostKey->nInstance;

    // Return a handle to the next object in the list
    return ( ( HKEYLIST ) pPostKey->pNext );
}



#ifdef USE_MEMORY
LPBYTE 
GetKeyBuffer( 
    IN HKEYLIST hKey 
)
{
    // 
    // We have two versions of this function because
    // we may want to use file i/o when the extension
    // deals with massive amounts of inbound data
    // ( like multi-megabyte uploads ).
    // 

    // 
    // This version uses a memory buffer.
    // 

    PPOSTKEY pKey;

    // Safety
    if ( !hKey ) {
        return NULL;
    }

    pKey = (PPOSTKEY) hKey;

    return (LPBYTE) pKey->lpbyBuf;
}

#elif defined USE_TEMPORARY_FILES

LPBYTE 
GetKeyBuffer( 
    IN HKEYLIST hKey 
)
{
    // 
    // This version uses slow temporary files.
    // 

    PLISTPROP pProp;
    PPOSTKEY pKey;
    DWORD dwRead;

    // Get pointer to list properties
    pProp = GetPropAddr( hKey );

    // Safety
    if ( !pProp ) {
        return NULL;
    }

    pKey = (PPOSTKEY) hKey;

    // Check if memory was already loaded for this key
    if ( pKey->lpbyBuf ) {
        return pKey->lpbyBuf;
    }

    // If not, let's allocate memory and do a ReadFile
    pKey->lpbyBuf = (LPBYTE) HeapAlloc( GetProcessHeap( ),
        HEAP_ZERO_MEMORY,
        pKey->dwLength + 1 );
    if ( !pKey->lpbyBuf ) {
        LOG( "GetKeyBuffer: HeapAlloc failed" );
        return NULL;
    }
    // Do the ReadFile
    SetFilePointer( pProp->hFile, pKey->dwOffset, NULL, FILE_BEGIN );
    if ( !ReadFile( pProp->hFile, pKey->lpbyBuf,
            pKey->dwLength, &dwRead, NULL ) ||
        dwRead != pKey->dwLength ) {
        HeapFree( GetProcessHeap( ), 0, (LPVOID) pKey->lpbyBuf );
        pKey->lpbyBuf = NULL;

        LOG( "GetKeyBuffer: ReadFile failed" );
        return NULL;
    }
    return pKey->lpbyBuf;
}
#endif


HKEYLIST 
FindKey( 
    IN HKEYLIST hKeyList, 
    IN LPCSTR lpszSearchName 
)
/*++

Purpose:

    FindKey sequentially searches the linked list for a given key.

Arguments:

    hKeyList - points to key list
    lpszSearchName - points to a key name to find 

Returns:

    The return handle points to the element within the linked list.
    Use it in GetKeyInfo, but not FreeKeyList.

--*/
{
    PPOSTKEY pFindKey;

    pFindKey = (PPOSTKEY) hKeyList;
    while ( pFindKey ) {
        if ( !lstrcmpi( lpszSearchName, ( LPCSTR ) ( &pFindKey[1] ) ) ) {
            return ( ( HKEYLIST ) pFindKey );
        }

        pFindKey = pFindKey->pNext;
    }

    return NULL;
}


void 
FreeKeyList( 
    IN HKEYLIST hHeadKey 
)
/*++

Purpose:

    FreeKeyList deallocates all the objects in the key list.
    The content file is also deleted.

Arguments:
    hHeadKey - points to the list head    

--*/
{
    PPOSTKEY pObject;
    PPOSTKEY pDel;
    PLISTPROP pProp;

    // Safety
    if ( !hHeadKey ) {
        return;
    }

#ifdef USE_TEMPORARY_FILES
    // Close the content file
    CloseContentFile( hHeadKey );

    // delete the content file
    pProp = GetPropAddr( hHeadKey );
    DeleteFile( pProp->szTempFileName );

#elif defined USE_MEMORY

    // delete content
    pProp = GetPropAddr( hHeadKey );
    HeapFree( GetProcessHeap( ), 0, (LPVOID) pProp->lpbyBuf );
#endif

    // delete all objects in the list
    pObject = (PPOSTKEY) hHeadKey;
    pObject = pObject->pHead;
    while ( pObject ) {

#ifdef USE_TEMPORARY_FILES
        // 
        // Free each buffer when using temporary files
        // 

        if ( pObject->lpbyBuf )
            HeapFree( GetProcessHeap( ), 0, (LPVOID) pObject->lpbyBuf );
#endif

        pDel = pObject;
        pObject = pObject->pNext;

        HeapFree( GetProcessHeap( ), 0, (LPVOID) pDel );
    }
}


DWORD 
GetKeyOffset( 
    IN HKEYLIST hKey 
)
/*++

Purpose:

    GetKeyOffset returns the offset of a key into the internal
    buffer or temporary file.  This is provided for IS2WCGI
    so it can return an offset within the content file.

Arguments:
    
    hKey - points to a key

Returns:
    
    Offset of a key or NULL if no key provided

--*/
{
    // Safety
    if ( !hKey )
        return NULL;

    return ( (PPOSTKEY) hKey )->dwOffset;
}


#ifdef USE_TEMPORARY_FILES

LPCSTR 
GetContentFile( 
    IN HKEYLIST hKeyList 
)
/*++

Purpose:

    GetContentFile returns a pointer to the name of the
    temporary file.  This is provided for the IS2WCGI
    sample.

Arguments:


Returns:

--*/
{
    PLISTPROP pProp;

    // safety
    if ( !hKeyList )
        return NULL;

    pProp = GetPropAddr( hKeyList );

    return ( LPCSTR ) pProp->szTempFileName;
}


void 
CloseContentFile( 
    IN HKEYLIST hKey 
)
/*++

Purpose:

    CloseContentFile forces the content file to be closed.  This
    allows you to pass the file to something else that may open
    it.  Call OpenContentFile before calling any other key
    function.

Arguments:

--*/
{
    PLISTPROP pProp;

    if ( !hKey )
        return;

    pProp = GetPropAddr( hKey );
    if ( pProp->hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( pProp->hFile );
        pProp->hFile = INVALID_HANDLE_VALUE;
    }
}


void 
OpenContentFile( 
    IN HKEYLIST hKey 
)
/*++

Purpose:

    OpenContentFile forces the content file to be reopened.
    GetKeyBuffer will fail if the content file was closed by
    CloseContentFile, but not reopened.

Arguments:


Returns:

--*/
{
    PLISTPROP pProp;

    if ( !hKey )
        return;

    pProp = GetPropAddr( hKey );

    if ( pProp->hFile != INVALID_HANDLE_VALUE )
        return;

    // Create the content file
    pProp->hFile = CreateFile( pProp->szTempFileName,
        GENERIC_READ | GENERIC_WRITE,
        0,                      // No sharing mode
         NULL,                  // Default security attribs
         OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL );
}

#elif defined USE_MEMORY


LPBYTE 
GetDataBuffer( 
    IN HKEYLIST hKeyList 
)
/*++

Purpose:

    GetBufferPointer returns a pointer to the buffer used
    for content storage.

Arguments:

    hKeyList - points to a key list
    
Returns:

    pointer to the content buffer or NULL

--*/
{
    PLISTPROP pProp;

    // safety
    if ( !hKeyList )
        return NULL;

    pProp = GetPropAddr( hKeyList );

    return pProp->lpbyBuf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asyncread\areadcli.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    AReadCli.c

Abstract:

    This module demonstrates using asynchronous ReadClient call
    to read data sent from client. On return, this sends the 
    followings back to client:
    
    1) the number of bytes intended to send
    2) the number of bytes actually read.
    3) data content 

Author:

    Stanley Tam (stanleyt)   4-June 1997
    
Revision History:
  
--*/
#include <windows.h>
#include <stdio.h>
#include <httpext.h>


#define MAX_BUF_SIZE        (49152)                 // Max number of bytes for each read - 48K
#define MEM_ALLOC_THRESHOLD (1024 * 1024)           // Default heap size is 1M


typedef struct _IO_WORK_ITEM {

    PBYTE                       pbDATAFromClient;   // Grand read data holder
    DWORD                       cbReadSoFar;        // Number of bytes read so far, 
                                                    // and is used as index for pbDATAFromClient
    EXTENSION_CONTROL_BLOCK *   pecb;

}  IO_WORK_ITEM, * PIOWI;


//
//  Sample Form for doing a POST method
//

static CHAR             g_szPostForm[] =
                        "<h2>Asychronous ReadClient Sample Post Form</h2><p>\r\n\r\n"
                        "This demonstrates a post request being sent by this form to the sample ISAPI - AReadCli.dll<p>\r\n\r\n"
                        "AReadCli.dll reads data posted by this form and send it back to the browser.<p>\r\n"
                        "<h3>Post Form</h3>\r\n"
                        "Please enter data below:<br>\r\n"
                        "<form method=POST action=\"areadcli.dll\">\r\n"
                        "<textarea name=\"Data\" cols=48 rows=4></textarea>\r\n\r\n"
                        "<input type=submit> <input type=reset>\r\n"
                        "</form>";

//
//  Report read data
//

static CHAR             g_szReport[] = 
                        "Bytes count including \"Data=\"  \r\n"
                        "ECB Total Bytes:    %d.\r\n"
                        "Actual Read Bytes:  %d.\r\n";
                
DWORD
DoInit(IN OUT PIOWI piowi);

VOID
DoCleanUp(IN PIOWI piowi);

DWORD
DoAsyncReadClient(IN PIOWI piowi);
             
VOID WINAPI
AsyncReadClientIoCompletion(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                            IN PVOID pContext,
                            IN DWORD cbIO,
                            IN DWORD dwError);

DWORD
SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK pecb, 
                IN LPCSTR pszErrorMsg);

LPVOID 
AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize);

BOOL 
AR_Free(IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData);



DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 fReturn Value:

    fReturns TRUE if successful; otherwise FALSE is fReturned.

--*/
{
  BOOL    fReturn = TRUE;


  switch ( fdwReason) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( "Initializing the global data for areadcli.dll\n");

          //
          // Prevent the system from calling DllMain
          // when threads are created or destroyed.
          //

          DisableThreadLibraryCalls( hinstDll);

          //
          // Initialize various data and modules.
          //

          break;

      } // case DLL_PROCESS_ATTACH

    case DLL_PROCESS_DETACH:
      {

          if ( lpvContext != NULL) { }

          break;
      } // case DLL_PROCESS_DETACH

    default:
      break;
  }   // switch

  return (fReturn);
}  // DllLibMain()




BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO * Version)
/*++

Routine Description:

    Sets the ISAPI extension version information.

Arguments:

    Version     pointer to HSE_VERSION_INFO structure

Return Value:

    TRUE

--*/
{
    Version->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(Version->lpszExtensionDesc, "Asynchronous Read Client Sample ISAPI DLL");

    return TRUE;
}




DWORD WINAPI
HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)
/*++

Routine Description:

    This is the main routine for any ISAPI application. Inside DoASyncReadClient,
    proper action will be performed to read data from client asynchronously. Any data 
    read from client will be sent back to the client by using synchronous WriteClient.

Arguments:

    pecb        pointer to ECB containing parameters related to the request.

Return Value:

    HSE_STATUS_SUCCESS  or
    HSE_STATUS_PENDING  or 
    HSE_STATUS_ERROR

--*/
{
    PIOWI   piowi;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    
    //
    // The string length of textarea name "Data=" is 5. 
    // Available bytes <= 5 indicates that no user-
    // entered data has been sent, and the post form 
    // is shown.
    //

    if ( pecb->cbAvailable <= 5) {  

        hseStatus = SendMSGToClient(pecb, g_szPostForm);
    
    } else {

        piowi  = (PIOWI ) LocalAlloc( LMEM_FIXED, sizeof( IO_WORK_ITEM));

        if ( NULL == piowi) {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return (HSE_STATUS_ERROR);
        }

        piowi->pecb = pecb;

        //
        // Init Grand data holder, assign the first chunk(read-ahead chunk)
        // and update the index (cbRreadSoFar) of the grand data holder.
        //

        hseStatus = DoInit( piowi);
        
        if ( HSE_STATUS_ERROR != hseStatus) {
            
            //
            // Now we are ready to do asynchronous readclient here
            //

            hseStatus = DoAsyncReadClient( piowi);
        
            if (hseStatus != HSE_STATUS_PENDING) {

                //
                //  When IO finishes, tell IIS we will end the
                //  session. Also clean up other resources here
                //

                DoCleanUp( piowi);

            }
        
        }

    }
       
    return (hseStatus);
}




BOOL WINAPI
TerminateExtension(DWORD dwFlags)
/*++

Routine Description:

	This function is called when the WWW service is shutdown

Arguments:

	dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE

--*/
{
    return TRUE;
}




DWORD
SendMSGToClient(IN LPEXTENSION_CONTROL_BLOCK  pecb, IN LPCSTR pszMsg)
/*++

Routine Description:

    Prepare header, SendHeaderExInfo struct and write whatever
    message is intended to send to the client.

Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    pszMsg      - pointer to the body of the message that is sent to the content.

Return Value:

    HSE_STATUS_SUCCESS  or HSE_STATUS_ERROR

--*/
{
    HSE_SEND_HEADER_EX_INFO	SHEI;

    BOOL    fReturn;
    DWORD   cbText;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    CHAR    *pszText = NULL;
    
    CHAR    szStatus[] = "200 OK";
    CHAR    szHeaderBase[] = "Content-type: text/html\r\n\r\n";
    
    //
    //  Populate SendHeaderExInfo struct
    //
    //  NOTE we must send Content-Length header with correct 
    //  byte count in order for keep-alive to work.
    //
    //

    SHEI.pszStatus = szStatus;
    SHEI.pszHeader = szHeaderBase;
    SHEI.cchStatus = lstrlen(szStatus);
    SHEI.cchHeader = lstrlen(szHeaderBase);
    SHEI.fKeepConn = FALSE;
    
    //
    //  Build page 
    //
    
    cbText = strlen("<head><title>Simple Async Read Client Sample</title></head>\n<body></body>\n")
             + strlen(pszMsg)
             + 1;

    pszText = (PCHAR) AR_Allocate(pecb, cbText);

    if ( NULL == pszText) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }
    
    strcpy(pszText, "<head><title>Simple Async Read Client Sample</title></head>\n");
    strcat(pszText, "<body>");
    strcat(pszText, pszMsg);
    strcat(pszText, "</body>\n");
    cbText = (DWORD)strlen(pszText); 
        
    //
    // Send header and body text to client
    //

    fReturn = 
    pecb->ServerSupportFunction( pecb->ConnID,
                                 HSE_REQ_SEND_RESPONSE_HEADER_EX,  
                                 &SHEI,
                                 NULL,
                                 NULL) 
                                            
                                 &&

    pecb->WriteClient( pecb->ConnID,
                       pszText,
                       &cbText,
                       0 );

    if ( !fReturn)  {
        hseStatus = HSE_STATUS_ERROR;
    }

    
    AR_Free( pecb, pszText);
    
    return ( hseStatus);
} 




DWORD
DoAsyncReadClient(IN PIOWI piowi)
/*++

Routine Description:

    The caller of the asynchrnous read client.

Arguments:

    piowi       pointer to the work item
    
Return Value:

    HSE_STATUS_SUCCESS  or
    HSE_STATUS_PENDING  or 
    HSE_STATUS_ERROR

--*/
{   
    BOOL    fReturn;
    BYTE    *pbData = NULL;
    CHAR    szTmp[MAX_BUF_SIZE];
    DWORD   dwFlags;
    DWORD   cbTotalToRead = MAX_BUF_SIZE;
    DWORD   hseStatus =  HSE_STATUS_PENDING;
    
    //
    // Check if cbTotalBytes == cbAvailable
    // if so lpbData contains all the data sent by 
    // the client, and complete the session. 
    //

    if (piowi->pecb->cbTotalBytes == piowi->pecb->cbAvailable) {
        
        //
        // Construct the report and write it to client
        //

        pbData = (PBYTE) AR_Allocate(piowi->pecb, piowi->pecb->cbAvailable + MAX_BUF_SIZE);
            
        if ( NULL == pbData) {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return (HSE_STATUS_ERROR);
        }

        wsprintf ( pbData,
                   g_szReport,
                   piowi->pecb->cbTotalBytes,
                   piowi->pecb->cbAvailable );
                    
        strcat( pbData, piowi->pecb->lpbData);  

        hseStatus = SendMSGToClient( piowi->pecb, pbData);


        AR_Free( piowi->pecb, pbData);
        DoCleanUp( piowi);
        
        return ( hseStatus); // HSE_STATUS_SUCCESS or HSE_STATUS_ERROR;
    }

    //
    //  More to read...
    //

    //
    //  Set a call back function and context that will 
    //  be used for handling asynchrnous IO operations.
    //  This only needs to set up once.
    //

    fReturn =
    piowi->pecb->ServerSupportFunction(
                    piowi->pecb->ConnID,
                    HSE_REQ_IO_COMPLETION,
                    AsyncReadClientIoCompletion,
                    0,
                    (LPDWORD)piowi );  
    
    if ( !fReturn) {

        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_IO_COMPLETION request.");
        SendMSGToClient( piowi->pecb, szTmp);
        
        return ( HSE_STATUS_ERROR);
    }
    

    //
    //  Fire off the call to perform an asynchronus read from the client. 
    //
    
    // 
    // We need to first check if the size of the remaining chunk 
    // is less than MAX_BUF_SIZE, if so just read what is available, 
    // otherwise read MAX_BUF_SIZE bytes of data.
    // 

    cbTotalToRead = piowi->pecb->cbTotalBytes - piowi->cbReadSoFar;
    if ( cbTotalToRead > MAX_BUF_SIZE )  {

        cbTotalToRead = MAX_BUF_SIZE;
    }

    dwFlags = HSE_IO_ASYNC;
    fReturn = 
    piowi->pecb->ServerSupportFunction(
                        piowi->pecb->ConnID
                      , HSE_REQ_ASYNC_READ_CLIENT
                      , piowi->pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes
                        piowi->cbReadSoFar        // the byte right after the last written byte in the buffer
                      , &cbTotalToRead
                      , &dwFlags);

    if (!fReturn) {
        
        wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request.");
        SendMSGToClient( piowi->pecb, szTmp);
        
        hseStatus = HSE_STATUS_ERROR;
    }

    return ( hseStatus); // HSE_STATUS_PENDING or HSE_STATUS_ERROR;
    
}

 


VOID WINAPI
AsyncReadClientIoCompletion(
            IN LPEXTENSION_CONTROL_BLOCK pECB,
            IN PVOID pContext,
            IN DWORD cbIO,
            IN DWORD dwError)
/*++

Routine Description:

    This is the callback function for handling completions of asynchronous ReadClient.
    This function resubmits additional IO to read the next chunk of data from the 
    client. If there is no more data to read or problem during operation, this function 
    will inform IIS that it is about to end the request session.
    

Arguments:

    pecb        - extension control block
    pContext    - this is a IO_WORK_ITEM
    cbIO        - bytes just read
    dwError     - Win32 error status code

fReturn Value:

    None

--*/
{
    BOOL    fReturn;
    BYTE    *pbData = NULL;
    CHAR    szTmp[MAX_BUF_SIZE];
    DWORD   dwFlags;
    DWORD   cbTotalToRead;
    
    PIOWI   piowi = ( PIOWI) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = piowi->pecb;
    

    if (ERROR_SUCCESS == dwError) {

        //
        // Read successfully, so update current 
        // total bytes read (aka index of grand data holder)
        //

        piowi->cbReadSoFar += cbIO;     
                               
        //
        // If they are equal, we finish reading all bytes from client
        //
        
        if ( piowi->cbReadSoFar == pecb->cbTotalBytes ) { 

            //
            // Construct the report and write it to client
            //

            pbData = (PBYTE) AR_Allocate( pecb, piowi->cbReadSoFar + MAX_BUF_SIZE);
                
            if ( NULL == pbData) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                wsprintf ( szTmp, "Failed to allocate memory inside AsyncReadClientIoCompletion().");
                SendMSGToClient( pecb, szTmp);
                
                DoCleanUp( piowi);
 
                return;
            }
            
            wsprintf ( pbData, g_szReport, pecb->cbTotalBytes, piowi->cbReadSoFar );
            piowi->pbDATAFromClient[piowi->cbReadSoFar] = 0; 
            strcat( pbData, piowi->pbDATAFromClient);
            SendMSGToClient( pecb, pbData);
            

            AR_Free( piowi->pecb, pbData);
            DoCleanUp( piowi);
            
            return;
            
        } else {

            // 
            // Still have more data to read... 
            // 
            // We need to first check if the size of the remaining chunk 
            // is less than MAX_BUF_SIZE, if so just read what is available, 
            // otherwise read MAX_BUF_SIZE bytes of data.
            // 

            cbTotalToRead = pecb->cbTotalBytes - piowi->cbReadSoFar;
            if ( cbTotalToRead > MAX_BUF_SIZE )  {

                cbTotalToRead = MAX_BUF_SIZE;
            }
            
            // 
            // Fire off another call to perform an asynchronus read from the client. 
            //

            dwFlags = HSE_IO_ASYNC;
            fReturn = 
            pecb->ServerSupportFunction(
                          pecb->ConnID
                        , HSE_REQ_ASYNC_READ_CLIENT
                        , piowi->pbDATAFromClient + // append the new chunk to buffer, cbReadSoFar indexes
                          piowi->cbReadSoFar        // the byte right after the last written byte in the buffer
                        , &cbTotalToRead
                        , &dwFlags);

            if ( !fReturn) {
                wsprintf ( szTmp, "Problem occurred at ServerSupportFunction() sending HSE_REQ_ASYNC_READ_CLIENT request.");
                SendMSGToClient( pecb, szTmp);

                DoCleanUp( piowi);
                
                return;
            }

        }
    
    } else {

        //
        // Error on read
        //

        SetLastError(dwError);
        
        DoCleanUp( piowi);
    }
        
    return;
        
} // AsyncReadClientIoCompletion




DWORD
DoInit(IN OUT PIOWI piowi)
/*++

Routine Description:

    Initialize the  Grand data holder, assign the first chunk(read-ahead chunk)
    and update the index (cbRreadSoFar) of the grand data holder.
    
Arguments:

    piowi       pointer to the work item

fReturn Value:

    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR

--*/
{

    piowi->pbDATAFromClient = 
    (PBYTE) AR_Allocate( piowi->pecb, piowi->pecb->cbTotalBytes + MAX_BUF_SIZE);
    
    if ( NULL == piowi->pbDATAFromClient) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // The first chunk (read-ahead chunk) has arrived.  
    //
    
    strcpy ( piowi->pbDATAFromClient, piowi->pecb->lpbData);
    piowi->cbReadSoFar = piowi->pecb->cbAvailable;

    return (HSE_STATUS_SUCCESS);
}




VOID
DoCleanUp(IN PIOWI piowi)
/*++

Routine Description:

    End the session with IIS and clean up other previous allocated resources.
    
Arguments:

    piowi       pointer to the work item

fReturn Value:

    None

--*/
{
    
    
    if ( piowi->pbDATAFromClient != NULL) {

        AR_Free( piowi->pecb, piowi->pbDATAFromClient);

    }

    piowi->pecb->ServerSupportFunction( piowi->pecb->ConnID,
                                        HSE_REQ_DONE_WITH_SESSION,
                                        NULL,
                                        NULL,
                                        NULL);

    LocalFree( piowi);

    return;

}




LPVOID 
AR_Allocate(IN LPEXTENSION_CONTROL_BLOCK pecb, IN DWORD dwSize)
/*++

Routine Description:

    Memory allocation routine. Two different Win32 API's to allocate
    bytes in memory, which is based on the number of bytes coming from 
    the client. If the size is greater than 1 M bytes VirtualAllocate is 
    used, otherwise HeapAllocate is used.
    
Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    dwSize      - number of bytes to allocate

fReturn Value:

    Pointer to void

--*/
{
    LPVOID pvData = NULL;
    

    if ( pecb->cbTotalBytes > MEM_ALLOC_THRESHOLD) {

        pvData = 
        VirtualAlloc( NULL, 
                      dwSize,
                      MEM_RESERVE | MEM_COMMIT, 
                      PAGE_READWRITE);

    } else {

        pvData = 
        HeapAlloc( GetProcessHeap(), 
                   HEAP_ZERO_MEMORY,
                   dwSize);
                           
    }

    return ( pvData);

}




BOOL
AR_Free( IN LPEXTENSION_CONTROL_BLOCK pecb, IN LPVOID pvData)
/*++

Routine Description:

    Freeing memory routine, a complementary routine to AR_Allocate. 
    Two different Win32 API's will be used to free up bytes in memory,
    which is based on the number of bytes coming from the client. If 
    the size is greater than 1 M bytes VirtualFree is used. Otherwise, 
    HeapFree is used.
    
Arguments:

    pecb        - pointer to ECB containing parameters related to the request.
    pvData      - pointer to the data to be freed.

fReturn Value:

    TRUE or FALSE

--*/
{
    BOOL fReturn = FALSE;


    if ( pecb->cbTotalBytes > MEM_ALLOC_THRESHOLD) {
        
        fReturn = VirtualFree( pvData, 0, MEM_RELEASE);

    } else {

        fReturn = HeapFree( GetProcessHeap(), 0, pvData);
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\formdump\html.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    html.cpp

Abstract:

   This module contains simple HTML authoring functions.


--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>

#include <stdio.h>
#include <stdarg.h>

#include "html.h"


void
WriteString( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpsz
)
{
    DWORD dwBytesWritten;

    dwBytesWritten = lstrlen( lpsz );
    pECB->WriteClient( pECB->ConnID, (PVOID) lpsz, &dwBytesWritten, 0 );
}


void 
HtmlCreatePage( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszTitle
)
{
    WriteString( pECB, "<HTML>\r\n\r\n" );

    if ( lpszTitle ) {
        WriteString( pECB, "<HEAD><TITLE>" );
        HtmlWriteText( pECB, lpszTitle );
        WriteString( pECB, "</TITLE></HEAD>\r\n\r\n" );
    }
    WriteString( pECB, "<BODY>\r\n\r\n" );
}


void 
HtmlEndPage( 
    IN EXTENSION_CONTROL_BLOCK * pECB
)
{
    WriteString( pECB, "</BODY>\r\n\r\n" );
    WriteString( pECB, "</HTML>\r\n" );
}


void 
HtmlHeading( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN int nHeading,
    IN LPCSTR lpszText
)
{
    HtmlBeginHeading( pECB, nHeading );
    HtmlWriteText( pECB, lpszText );
    HtmlEndHeading( pECB, nHeading );
}


void 
HtmlBeginHeading( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN int nHeading
)
{
    char szCode[16];

    wsprintf( szCode, "<H%i>", nHeading );
    WriteString( pECB, szCode );
}


void 
HtmlEndHeading( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN int nHeading
)
{
    char szCode[16];

    wsprintf( szCode, "</H%i>", nHeading );
    WriteString( pECB, szCode );
}


void 
HtmlWriteTextLine( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpsz
)
{
    HtmlWriteText( pECB, lpsz );
    WriteString( pECB, "\r\n" );
}


void 
HtmlWriteText( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpsz
)
{
    char szBuf[1028];
    int nLen;
    int i;

    // 
    // Build up enough data to make call to WriteString
    // worthwhile; convert special chars too.
    // 
    nLen = 0;
    for ( i = 0; lpsz[i]; i++ ) {
        if ( lpsz[i] == '<' )
            lstrcpy( &szBuf[nLen], "&lt;" );
        else if ( lpsz[i] == '>' )
            lstrcpy( &szBuf[nLen], "&gt;" );
        else if ( lpsz[i] == '&' )
            lstrcpy( &szBuf[nLen], "&amp;" );
        else if ( lpsz[i] == '\"' )
            lstrcpy( &szBuf[nLen], "&quot;" );
        else {
            szBuf[nLen] = lpsz[i];
            szBuf[nLen + 1] = 0;
        }

        nLen += lstrlen( &szBuf[nLen] );

        if ( nLen >= 1024 ) {
            WriteString( pECB, szBuf );
            nLen = 0;
        }
    }

    if ( nLen )
        WriteString( pECB, szBuf );
}


void 
HtmlEndParagraph( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<P>\r\n" );
}


//
// HtmlHyperLink adds a hyptertext link.  lpszDoc is the destination
// document, and lpszText is the display text.
// 
// HtmlHyperLinkAndBookmark adds a hyperlink with a bookmark link.
// HtmlBookmarkLink adds only a bookmark link.
// 

void 
HtmlHyperLink( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszDoc, 
    IN LPCSTR lpszText
)
{
    WriteString( pECB, "<A HREF=\"" );
    HtmlWriteText( pECB, lpszDoc );
    WriteString( pECB, "\">" );
    HtmlWriteText( pECB, lpszText );
    WriteString( pECB, "</A>\r\n" );
}

void 
HtmlHyperLinkAndBookmark( 
    IN EXTENSION_CONTROL_BLOCK * pECB,
    IN LPCSTR lpszDoc, 
    IN LPCSTR lpszBookmark,
    IN LPCSTR lpszText
)
{
    WriteString( pECB, "<A HREF=\"" );
    if ( lpszDoc )
        HtmlWriteText( pECB, lpszDoc );
    WriteString( pECB, "#" );
    HtmlWriteText( pECB, lpszBookmark );
    WriteString( pECB, "\">" );
    HtmlWriteText( pECB, lpszText );
    WriteString( pECB, "</A>\r\n" );
}


void 
HtmlBookmarkLink( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszBookmark,
    IN LPCSTR lpszText
)
{
    HtmlHyperLinkAndBookmark( pECB, NULL, lpszBookmark, lpszText );
}


//
// The following support list formatting.
// 

void 
HtmlBeginUnnumberedList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<UL>\r\n" );
}


void 
HtmlBeginListItem( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<LI>" );
}


void 
HtmlEndUnnumberedList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</UL>" );
}


void 
HtmlBeginNumberedList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<OL>" );
}


void 
HtmlEndNumberedList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</OL>" );
}


void 
HtmlBeginDefinitionList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<DL>" );
}


void 
HtmlEndDefinitionList( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</DL>" );
}


void 
HtmlDefinition( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszTerm,
    IN LPSTR lpszDef
)
{
    int nStart, nEnd, nLen;
    char tcHolder;

    WriteString( pECB, "<DT> " );
    HtmlWriteText( pECB, lpszTerm );
    WriteString( pECB, "\r\n" );
    WriteString( pECB, "<DD> " );

    nStart = 0;
    nLen = lstrlen( lpszDef );
    do {
        nEnd = nStart + 70;
        if ( nEnd >= nLen ) {
            HtmlWriteText( pECB, &lpszDef[nStart] );
            WriteString( pECB, "\r\n" );
            break;
        }
        while ( nEnd > nStart )
            if ( lpszDef[nEnd] == ' ' )
                break;

        if ( nEnd == nStart )
            // too long!
            nEnd = nStart + 70;

        // write defintion segment
        tcHolder = lpszDef[nEnd];
        lpszDef[nEnd] = 0;
        HtmlWriteText( pECB, &lpszDef[nStart] );
        WriteString( pECB, "\r\n" );
        lpszDef[nEnd] = tcHolder;
        nStart = nEnd;

        // skip excess whitespace
        while ( lpszDef[nStart] == ' ' )
            nStart++;

        // pretty formatting
        if ( nStart < nLen )
            WriteString( pECB, "     " );
    } while ( nStart < nLen );
}


// For complex defintions
void 
HtmlBeginDefinitionTerm( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<DT>" );
}


void 
HtmlBeginDefinition( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<DD>" );
}


//
// Text formatting
// 

void 
HtmlBeginPreformattedText( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<PRE>" );
}


void 
HtmlEndPreformattedText( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</PRE>" );
}


void 
HtmlBeginBlockQuote( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<BLOCKQUOTE>" );
}


void 
HtmlEndBlockQuote( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</BLOCKQUOTE>" );
}


void 
HtmlBeginAddress( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<ADDRESS>" );
}


void 
HtmlEndAddress( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</ADDRESS>" );
}


void 
HtmlBeginDefine( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<DFN>" );
}


void 
HtmlEndDefine( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</DFN>" );
}


void 
HtmlBeginEmphasis( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<EM>" );
}


void 
HtmlEndEmphasis( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</EM>" );
}


void 
HtmlBeginCitation( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<CITE>" );
}


void 
HtmlEndCitation( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</CITE>" );
}


void 
HtmlBeginCode( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<CODE>" );
}


void 
HtmlEndCode( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</CODE>" );
}


void 
HtmlBeginKeyboard( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<KBD>" );
}


void 
HtmlEndKeyboard( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</KBD>" );
}


void 
HtmlBeginStatus( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<SAMP>" );
}


void 
HtmlEndStatus( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</SAMP>" );
}


void 
HtmlBeginStrong( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<STRONG>" );
}


void 
HtmlEndStrong( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</STRONG>" );
}


void 
HtmlBeginVariable( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<VAR>" );
}


void 
HtmlEndVariable( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</VAR>" );
}


void 
HtmlBold( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszText
)
{
    HtmlBeginBold( pECB );
    HtmlWriteText( pECB, lpszText );
    HtmlEndBold( pECB );
}


void 
HtmlBeginBold( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<B>" );
}


void 
HtmlEndBold( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</B>" );
}


void 
HtmlItalic( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszText
)
{
    HtmlBeginItalic( pECB );
    HtmlWriteText( pECB, lpszText );
    HtmlEndItalic( pECB );
}


void 
HtmlBeginItalic( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<I>" );
}


void 
HtmlEndItalic( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</I>" );
}


void 
HtmlFixed( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszText
)
{
    HtmlBeginFixed( pECB );
    HtmlWriteText( pECB, lpszText );
    HtmlEndFixed( pECB );
}


void 
HtmlBeginFixed( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<TT>" );
}


void 
HtmlEndFixed( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "</TT>" );
}


void 
HtmlLineBreak( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "<BR>\r\n" );
}


void 
HtmlHorizontalRule( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
{
    WriteString( pECB, "\r\n<HR>\r\n" );
}


void 
HtmlImage( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszPicFile,
    IN LPCSTR lpszAltText
)
{
    WriteString( pECB, "<IMG SRC = \"" );
    HtmlWriteText( pECB, lpszPicFile );
    WriteString( pECB, "\"" );
    if ( lpszAltText ) {
        WriteString( pECB, " ALT = \"" );
        HtmlWriteText( pECB, lpszAltText );
        WriteString( pECB, "\"" );
    }
    WriteString( pECB, ">\r\n" );
}


void 
HtmlPrintf( 
    IN EXTENSION_CONTROL_BLOCK * pECB, 
    IN LPCSTR lpszFormat,
    ...
)
{
    char szBuf[8192];

    va_list list;

    va_start( list, lpszFormat );

    vsprintf( szBuf, lpszFormat, list );
    WriteString( pECB, szBuf );

    va_end( list );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asynctrans\ftrans.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ftrans.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the Async TransmitFile support with callback.


Revision History:
--*/

#include <windows.h>
#include "httpext.h"

# include "openf.h"

/************************************************************
 *  Global Data
 ************************************************************/

LIST_ENTRY g_lWorkItems;
CRITICAL_SECTION g_csWorkItems;

# define USE_WORK_QUEUE   (0)


DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb,
              IN HANDLE hFile, 
              IN LPCSTR pszFile);




/************************************************************
 *    Functions
 ************************************************************/


BOOL WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    BOOL    fReturn = TRUE;

    switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
        {
          OutputDebugString( " Initializing the global data in ftrans.dll\n");

          //
          // Initialize various data and modules.
          //
          InitializeCriticalSection(&g_csWorkItems);
          InitializeListHead( &g_lWorkItems);
          InitFileHandleCache();

          break;
        } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
        {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();
          if ( lpvContext != NULL) {

              DeleteCriticalSection(&g_csWorkItems);
          }

          break;
        } /* case DLL_PROCESS_DETACH */

    default:
        break;
    } /* switch */

    return ( fReturn);
}  /* DllMain() */




DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

 Routine Description:

   This function performs the necessary action to send response for the 
    request received from the client. It picks up the name of a file from
    the pecb->lpszQueryString and transmits that file to the client.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.

 Return Value:

    Returns HSE_* status codes
--*/
{
    DWORD hseStatus;

    
    if ( pecb->lpszQueryString == NULL ||
        *pecb->lpszQueryString == '\0' 
        ) {
        
        hseStatus = SendHeaderToClient( pecb, "File Not Specified");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }
    
    return ( hseStatus);
    
} // HttpExtensionProc()




BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using TransmitFile" );
    
    return TRUE;
}


BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}





DWORD
SendHeaderToClient( 
    IN EXTENSION_CONTROL_BLOCK  * pecb, 
    IN LPCSTR pszErrorMsg
    )
{
	HSE_SEND_HEADER_EX_INFO	SendHeaderExInfo;
	char szStatus[]     = "200 OK";
	char szHeader[1024];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( szHeader,
              "Content-Type: text/html\r\n"
              "\r\n"              // marks the end of header block
              "<head><title>Simple File Transfer (Transmit File)"
              "</title></head>\n"
              "<body><h1>%s</h1>\n"
              ,
              pszErrorMsg );


    //
    //  Populate SendHeaderExInfo struct
    //

    SendHeaderExInfo.pszStatus = szStatus;
    SendHeaderExInfo.pszHeader = szHeader;
    SendHeaderExInfo.cchStatus = lstrlen( szStatus);
    SendHeaderExInfo.cchHeader = lstrlen( szHeader);
    SendHeaderExInfo.fKeepConn = FALSE;

    //
    //  Send header - use the EX Version to send the header blob
    //

	if ( !pecb->ServerSupportFunction(
    	            pecb->ConnID,
    	            HSE_REQ_SEND_RESPONSE_HEADER_EX,
    	            &SendHeaderExInfo,
    	            NULL,
    	            NULL
            ) ) {

    	return HSE_STATUS_ERROR;
	}
    
    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()
    


DWORD
SendFileToClient( 
    IN EXTENSION_CONTROL_BLOCK * pecb, 
    IN LPCSTR pszFile
    )
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer, 
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

#if SEPARATE_HEADERS
        hseStatus = SendHeaderToClient( pecb, "File Transfer begins");
#else 
        hseStatus = HSE_STATUS_SUCCESS;
#endif

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile, pszFile);
            
            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //
                
                if ( hseStatus != HSE_STATUS_SUCCESS) {
                    
                    //
                    // Error in transmitting the file. Send error message.
                    //
                    
                    wsprintfA( pchBuffer, 
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);
                    
                    SendHeaderToClient( pecb, pchBuffer);
                }
            }
        }

        if ( hseStatus != HSE_STATUS_PENDING) {
              
            //
            // file handle is closed for all non-pending cases
            // if the status is pending, file handle is cleaned up in callback
            //
            FcCloseFile( hFile);
        }
    }
    
    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (400)

typedef struct _AIO_WORK_ITEM {
    
    LIST_ENTRY    listEntry;
    EXTENSION_CONTROL_BLOCK * pecb;
    HSE_TF_INFO   hseTf;
    CHAR          pchBuffer[ MAX_BUFFER_SIZE ];

}  AIO_WORK_ITEM, * PAWI;




VOID
CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession)
{

    DWORD err = GetLastError();

    if ( paw->hseTf.hFile != INVALID_HANDLE_VALUE) { 
     
        FcCloseFile( paw->hseTf.hFile);
    }
    
    if (fDoneWithSession) {

        paw->pecb->ServerSupportFunction( paw->pecb->ConnID,
                                         HSE_REQ_DONE_WITH_SESSION,
                                         NULL, NULL, NULL);
    }
    SetLastError( err);

    //
    // Remove from work items list
    // 
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    RemoveEntryList( &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
# endif 

    LocalFree( paw);
    return;

} // CleanupAW()




VOID WINAPI
HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB, 
                IN PVOID    pContext,
                IN DWORD    cbIO,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required). In this case, this function is called at the end of a 
    successful TransmitFile() operation. This function primarily cleans up
    the data and worker queue item and exits.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    PAWI    paw = (PAWI ) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = paw->pecb;

    
    // assert( pecb == paw->pecb);

    //
    // 1. if no errors, we are done transmitting the file
    // 2. cleanup and exit
    //

    
    //
    // Do Cleanup
    //
    
    CleanupAW( paw, TRUE);


    return;

} // HseIoCompletion()




DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb,
              IN HANDLE hFile, 
              IN LPCSTR pszFile)
{

    PAWI   paw;
    DWORD  hseStatus = HSE_STATUS_PENDING;

    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM));
    if ( paw == NULL) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // Fill in all the data in AIO_WORK_ITEM
    //
    paw->pecb = pecb;
    InitializeListHead( &paw->listEntry);

    paw->hseTf.pfnHseIO = HseIoCompletion;
    paw->hseTf.pContext = paw;
    paw->hseTf.dwFlags  = (HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND);

    paw->hseTf.hFile    = hFile;
    paw->hseTf.BytesToWrite = GetFileSize(hFile, NULL);
    paw->hseTf.Offset   = 0;
    paw->hseTf.pTail    = NULL;
    paw->hseTf.TailLength = 0;


    //
    //  Set up the header to be sentout for the file
    //
    
#if SEPARATE_HEADERS
    paw->hseTf.HeadLength = 0;
    paw->hseTf.pHead    = NULL;

#else 
    paw->hseTf.HeadLength = 
      wsprintfA ( paw->pchBuffer,
                 "HTTP/1.1 200 OK\r\n"
                 "Content-Type: text/html\r\n"
                 "\r\n"
                 "<head><title>Simple File Transfer (TransmitFile) "
                 "</title></head>\n"
                 "<h1> Transferred file contains...</h1>\n");
    paw->hseTf.pHead = paw->pchBuffer;
# endif 
    
    // Add to the list
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    InsertTailList( &g_lWorkItems,  &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
#endif 

    //
    // Setup the Async TransmitFile
    //

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_TRANSMIT_FILE,
                                       &paw->hseTf,
                                       NULL,
                                       NULL)
        ) {

        //
        // Do cleanup and return error
        //

        // File handle will be freed by the caller for errors
        paw->hseTf.hFile = INVALID_HANDLE_VALUE;

        CleanupAW( paw, FALSE);
        hseStatus =  HSE_STATUS_ERROR;
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asynctrans\openf.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
     
     openf.h

   Abstract:

     This module defines functions for opening and closing files
      and provides transparent caching for file handles

   Project:
   
       Internet Server API Extnensions Samples DLL

   Revision History:

--*/

# ifndef _OPENF_HXX_
# define _OPENF_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <httpext.h>

/************************************************************
 *   Type Definitions  
 ************************************************************/

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

// typedef struct _LIST_ENTRY {
//   struct _LIST_ENTRY * volatile Flink;
//   struct _LIST_ENTRY * volatile Blink;
// } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
{RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
{RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
                            }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
                                    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
                                    }


/************************************************************
 *   Function Definitions  
 ************************************************************/


//
// Initialization and cleanup functions
//

DWORD   InitFileHandleCache(VOID);
DWORD   CleanupFileHandleCache(VOID);

HANDLE  FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile);
DWORD   FcCloseFile(IN HANDLE hFile);

BOOL    FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               );


# endif // _OPENF_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asynctrans\openf.c ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

      openf.c

   Abstract:

      This module implements a simple open file handle cache

   Project:

       ISAPI Extensions Sample DLL

   Functions Exported:


   Note:
      THIS IS NOT ROBUST for REAL WORLD.
      I wrote this for testing the ISAPI Async IO processing.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "openf.h"


/************************************************************
 *     Type definitions and Globals
 ************************************************************/

//
// internal data structure for maintaining the list of open file handles.
//

typedef struct _OPEN_FILE {
    
    HANDLE  hFile;
    struct _OPEN_FILE * pNext;
    LONG    nHits;
    LONG    nRefs;
    CHAR    rgchFile[MAX_PATH+1];

} OPEN_FILE, * LPOPEN_FILE;


LPOPEN_FILE g_pOpenFiles = NULL;
CRITICAL_SECTION g_csOpenFiles;
BOOL g_fIsNt = TRUE;

//
// Set up global variables containing the flags for CreateFile
//  The flags can be masked for Windows 95 system
//

DWORD  g_dwCreateFileShareMode = 
         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

DWORD  g_dwCreateFileFlags = 
         (FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);

/************************************************************
 *    Functions 
 ************************************************************/


DWORD
InitFileHandleCache(VOID)
/*++

  This function initializes the file handle cache.
  It should be called at the initialization time.

  Arguments:
    None
  
  Returns:
    Win32 error code. NO_ERROR indicates that the call succeeded.
--*/
{
    OSVERSIONINFO  osInfo;
    
    InitializeCriticalSection( &g_csOpenFiles);

    //
    // obtain the platform type to find out how to open the file
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        g_fIsNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    if ( !g_fIsNt) {

        //
        // Reset the flags appropriately so that Windows 95 will be happy
        //

        g_dwCreateFileShareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE);
        g_dwCreateFileFlags     = (FILE_FLAG_SEQUENTIAL_SCAN);
    }

    return (NO_ERROR);

} // InitFileHandleCache()




DWORD
CleanupFileHandleCache(VOID)
{
    LPOPEN_FILE  pFileScan;

    while ( g_pOpenFiles != NULL) {

        pFileScan = g_pOpenFiles;
        g_pOpenFiles = g_pOpenFiles->pNext;

        if ( pFileScan->hFile != INVALID_HANDLE_VALUE) {

            CloseHandle( pFileScan->hFile);
        }

        LocalFree( pFileScan);
    }

    DeleteCriticalSection( &g_csOpenFiles);

    return (NO_ERROR);
} // CleanupFileHandleCache()




HANDLE
FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile)
/*++

 FcOpenFile()
 
 Description:
   This function opens the file specified in the 'pszFile'. 
   If the file name starts with a '/' we use the ECB to map 
   the given path into a physical file path.

 Arguments:
  pecb - pointer to the ECB block
  pszFile - pointer to file name

 Returns:
   valid File handle on success
--*/
{
    LPOPEN_FILE  pFileScan;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    EnterCriticalSection( &g_csOpenFiles);

    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( 0 == lstrcmpi( pFileScan->rgchFile, pszFile)) {

            //
            //  there is a file match. 
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {

        //
        // File was not found. Create a new file handle
        //

        CHAR   rgchFileName[ MAX_PATH]; // local copy
        LPCSTR pszInputPath = pszFile;
        
        lstrcpyn( rgchFileName, pszFile, MAX_PATH);
        if ( *pszFile == '/') { 

            DWORD cbSize = sizeof(rgchFileName);
            BOOL  fRet;

            // reset the file pointer, so subsequent use will fail
            pszFile = NULL;

            //
            // Using the ECB map the Virtual path to the Physical path
            //

            fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                                HSE_REQ_MAP_URL_TO_PATH,
                                                rgchFileName,
                                                &cbSize, NULL);
            
            if (fRet) {
                // we got the mapping. Use it.
                pszFile = rgchFileName;
            }
        }   

        if ( NULL != pszFile) {
            pFileScan = LocalAlloc( LPTR, sizeof( *pFileScan));

            if ( NULL != pFileScan) {
                
                SECURITY_ATTRIBUTES sa;
                
                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;
                
                pFileScan->hFile = 
                    CreateFile( pszFile,
                                GENERIC_READ,
                                g_dwCreateFileShareMode,
                                &sa,
                                OPEN_EXISTING,
                                g_dwCreateFileFlags,
                                NULL );
                
                if ( INVALID_HANDLE_VALUE == pFileScan->hFile) {
                    
                    LocalFree( pFileScan);
                    pFileScan = NULL;
                } else {
                    
                    // insert this into the list at the top
                    lstrcpyn( pFileScan->rgchFile, pszInputPath, MAX_PATH);
                    pFileScan->pNext = g_pOpenFiles;
                    g_pOpenFiles = pFileScan;
                    pFileScan->nRefs = 1;
                    pFileScan->nHits = 0;
                }
            }
        }
    }

    if ( NULL != pFileScan) {

        hFile = pFileScan->hFile;
        pFileScan->nHits++;
        pFileScan->nRefs++;
    }

    LeaveCriticalSection( &g_csOpenFiles);

    return (hFile);

} // FcOpenFile()



DWORD
FcCloseFile(IN HANDLE hFile)
{
    LPOPEN_FILE  pFileScan;
    DWORD dwError = NO_ERROR;

    EnterCriticalSection( &g_csOpenFiles);

    //
    // Look for the handle and decrement the ref count.
    // 
    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( hFile == pFileScan->hFile) {

            //
            //  there is a file match. 
            //

            pFileScan->nRefs--;

            //
            // There is no freeing of the file when Ref hits '0' :(
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {
        //
        // file handle not found
        //
        dwError = ( ERROR_INVALID_HANDLE);
    }

    LeaveCriticalSection( &g_csOpenFiles);


    return ( dwError);

} // FcCloseFile()




BOOL
FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               )
/*++
  Description:
    Reads contents of file [hFile] from the specified offset in the overlapped 
    structure. The contents are read into the buffer supplied.

  Arguments:
    hFile        - handle for the File from which to read data
    pchBuffer    - pointer to the buffer into which the data is to be read
    dwBufferSize - DWORD containing the max size of the buffer supplied
    pcbRead      - number of bytes read from the file
    pov          - pointer to an overlapped structure that contains the 
                     offset from where to read the contents. The
                     overlapped structure also is used for Overlapped
                     IO in NT.

  Notes:
   This function automatically handles both Windows 95 and NT
   

  Returns:
    TRUE on success and FALSE if there is a failure.
    Use GetLastError() to get the last error code on failure.
--*/
{
    BOOL fRet = TRUE;

    *pcbRead = 0;
    
    if ( !g_fIsNt ) {
        //
        // Windows95 does not support Overlapped IO.
        //  So we shall thunk it out and use Synchronous IO
        //
        
        fRet = ( 
                SetFilePointer( hFile, 
                                pov->Offset,
                                NULL,
                                FILE_BEGIN) &&
                ReadFile( hFile,
                          pchBuffer,
                          dwBufferSize,
                          pcbRead,
                          NULL
                          )
                );
    } else {
            
            ResetEvent( pov->hEvent);

            fRet = TRUE;

            // read data from file
            if (!ReadFile(hFile,
                          pchBuffer,
                          dwBufferSize,
                          pcbRead,
                          pov
                          )) {
                
                DWORD err = GetLastError();
                
                if ( (err != ERROR_IO_PENDING) ||
                     !GetOverlappedResult( hFile, pov,
                                           pcbRead, TRUE)) {
                    
                    fRet = FALSE;
                }
            }
    }

    if ( fRet) {
        pov->Offset += *pcbRead;
    }

    return ( fRet);
} // FcReadFromFile()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\syncwrite\openf.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
     
     openf.h

   Abstract:

     This module defines functions for opening and closing files
      and provides transparent caching for file handles

   Project:
   
       Internet Server API Extnensions Samples DLL

   Revision History:

--*/

# ifndef _OPENF_HXX_
# define _OPENF_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <httpext.h>

/************************************************************
 *   Type Definitions  
 ************************************************************/

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

// typedef struct _LIST_ENTRY {
//   struct _LIST_ENTRY * volatile Flink;
//   struct _LIST_ENTRY * volatile Blink;
// } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
{RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
{RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
                            }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
                                    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
                                    }


/************************************************************
 *   Function Definitions  
 ************************************************************/


//
// Initialization and cleanup functions
//

DWORD   InitFileHandleCache(VOID);
DWORD   CleanupFileHandleCache(VOID);

HANDLE  FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile);
DWORD   FcCloseFile(IN HANDLE hFile);

BOOL    FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               );


# endif // _OPENF_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asyncwrite\fwasync.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    fwasync.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the Async WriteClient() with callback.

Revision History:
--*/

# include <windows.h>
# include <stdio.h>
# include "httpext.h"
# include "openf.h"

/************************************************************
 *  Global Data
 ************************************************************/

LIST_ENTRY g_lWorkItems;
CRITICAL_SECTION g_csWorkItems;

# define USE_WORK_QUEUE   (0)


DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile);





/************************************************************
 *    Functions
 ************************************************************/


BOOL WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( "Initializing the global data for fwasync.dll\n");

          //
          // Initialize various data and modules.
          //
          InitializeCriticalSection(&g_csWorkItems);
          InitializeListHead( &g_lWorkItems);
          fReturn = (InitFileHandleCache() == NO_ERROR);

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();
          if ( lpvContext != NULL) {

              DeleteCriticalSection(&g_csWorkItems);
          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

 Routine Description:

   This function performs the necessary action to send response for the
    request received from the client. It picks up the name of a file from
    the pecb->lpszQueryString and sends the file using Asynchronous WriteClient

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.

 Return Value:

    Returns HSE_* status codes
--*/
{
    DWORD hseStatus;


    if ( pecb->lpszQueryString == NULL) {

        hseStatus = SendHeaderToClient( pecb, "File Not Found");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }

    return ( hseStatus);

} // HttpExtensionProc()





BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using WriteClient" );

    return TRUE;
}


BOOL WINAPI
TerminateExtension(
                   /*IN */ DWORD dwFlags
    )
/*++
  This function is called when IIS decides to stop and unload the 
  ISAPI DLL. We can do any custom cleanup for the module inside this function
--*/
{
    //
    // Nothing specific do here for cleanup
    // Cleanup is done in the dll process detach in DllLibMain()
    //

    return ( TRUE);
}




DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{
	HSE_SEND_HEADER_EX_INFO	SendHeaderExInfo;
	char szStatus[]     = "200 OK";
	char szHeader[1024];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( szHeader,
              "Content-Type: text/html\r\n"
              "\r\n"              // marks the end of header block
              "<head><title>Simple File Transfer (Async Write)"
              "</title></head>\n"
              "<body><h1>%s</h1>\n"
              ,
              pszErrorMsg );


    //
    //  Populate SendHeaderExInfo struct
    //

    SendHeaderExInfo.pszStatus = szStatus;
    SendHeaderExInfo.pszHeader = szHeader;
    SendHeaderExInfo.cchStatus = lstrlen( szStatus);
    SendHeaderExInfo.cchHeader = lstrlen( szHeader);
    SendHeaderExInfo.fKeepConn = FALSE;

    //
    //  Send header - use the EX Version to send the header blob
    //

	if ( !pecb->ServerSupportFunction(
    			pecb->ConnID
    			, HSE_REQ_SEND_RESPONSE_HEADER_EX
    			, &SendHeaderExInfo
    			, NULL
    			, NULL
            ) ) {

    	return HSE_STATUS_ERROR;
	}
	
    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()



DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile)
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer,
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

        wsprintfA( pchBuffer, " Transferred file contains...");

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile);

            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //

                // close file handle
                FcCloseFile( hFile);

                if ( hseStatus != HSE_STATUS_SUCCESS) {

                    //
                    // Error in transmitting the file. Send error message.
                    //

                    wsprintfA( pchBuffer,
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);

                    SendHeaderToClient( pecb, pchBuffer);
                }
            }
        }
    }

    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (4096)

typedef struct _AIO_WORK_ITEM {

    LIST_ENTRY    listEntry;
    EXTENSION_CONTROL_BLOCK * pecb;
    HANDLE        hFile;
    OVERLAPPED    ov;
    DWORD         nRead;
    CHAR          pchBuffer[ MAX_BUFFER_SIZE ];

}  AIO_WORK_ITEM, * PAWI;



DWORD
ReadDataForPaw(IN PAWI paw)
{
    DWORD hseStatus = HSE_STATUS_SUCCESS;

    // read data from the file
    if (!FcReadFromFile( paw->hFile, paw->pchBuffer, MAX_BUFFER_SIZE,
                         &paw->nRead,
                         &paw->ov)
        ) {

        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);

} // ReadDataForPaw()




DWORD
SendDataForPaw(IN PAWI paw)
{
    DWORD hseStatus = HSE_STATUS_PENDING;

    // write data to client

    if ( !paw->pecb->WriteClient( paw->pecb->ConnID,
                                 paw->pchBuffer,
                                 &paw->nRead,
                                 HSE_IO_ASYNC)
        ) {

        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);
} // SendDataForPaw()




VOID
CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession)
{

    DWORD err = GetLastError();

    FcCloseFile( paw->hFile);
    CloseHandle( paw->ov.hEvent);

    if (fDoneWithSession) {
        paw->pecb->ServerSupportFunction( paw->pecb->ConnID,
                                         HSE_REQ_DONE_WITH_SESSION,
                                         NULL, NULL, NULL);
    }
    SetLastError( err);

    //
    // Remove from work items list
    //
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    RemoveEntryList( &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
# endif

    LocalFree( paw);
    return;

} // CleanupAW()




VOID WINAPI
HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB,
                IN PVOID    pContext,
                IN DWORD    cbIO,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required). In this case, this function is called at the end of a
    successful Async WriteClient(). This function attempts to read the next
    chunk of data and sends it to client. If there is no next chunk this
    function cleans up the state and informs IIS about its intention to end
    the request.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    PAWI    paw = (PAWI ) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = paw->pecb;
    DWORD   hseStatus;


    //
    // 1. if no errors, do another read of the file
    // 2. send the read contents to client
    // 3. if no data present, cleanup and exit
    //

    if ( dwError != NO_ERROR) {

        //
        // Do Cleanup
        //

        CleanupAW( paw, TRUE);
        return;
    }

    //    assert( paw->nRead == cbIO);


    //
    // Read next chunk of data
    //
    
    paw->nRead = 0;
    hseStatus = ReadDataForPaw( paw);
    
    if ( hseStatus == HSE_STATUS_SUCCESS && paw->nRead > 0) {
        
        hseStatus = SendDataForPaw( paw);
    }

    if ( hseStatus != HSE_STATUS_PENDING) {

        CleanupAW( paw, TRUE);
    }

    return;
} // HseIoCompletion()



DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile)
{

    PAWI   paw;
    DWORD  hseStatus = HSE_STATUS_SUCCESS;

    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM));
    if ( paw == NULL) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // Fill in all the data in AIO_WORK_ITEM
    //
    paw->pecb = pecb;
    InitializeListHead( &paw->listEntry);
    paw->hFile = hFile;
    paw->nRead = 0;
    memset( &paw->ov, 0, sizeof(OVERLAPPED));
    paw->ov.OffsetHigh = 0;
    paw->ov.Offset = 0;
    paw->ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL);

    if ( paw->ov.hEvent == NULL) {

        LocalFree( paw);
        return (HSE_STATUS_ERROR);
    }

    //
    // Setup the callback context for the Async IO
    //

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_IO_COMPLETION,
                                       HseIoCompletion,
                                       0,
                                       (LPDWORD ) paw)
        ) {

        //
        // Do cleanup and return error
        //

        CloseHandle( paw->ov.hEvent);
        LocalFree( paw);
        return HSE_STATUS_ERROR;
    }

    // Add to the list
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    InsertTailList( &g_lWorkItems,  &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
#endif

    hseStatus = ReadDataForPaw( paw);

    if ( hseStatus == HSE_STATUS_SUCCESS && paw->nRead > 0 ) {


        hseStatus = SendDataForPaw( paw);
    }

    if ( hseStatus != HSE_STATUS_PENDING) {

        CleanupAW(paw, FALSE);
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asyncwrite\openf.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
     
     openf.h

   Abstract:

     This module defines functions for opening and closing files
      and provides transparent caching for file handles

   Project:
   
       Internet Server API Extnensions Samples DLL

   Revision History:

--*/

# ifndef _OPENF_HXX_
# define _OPENF_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <httpext.h>

/************************************************************
 *   Type Definitions  
 ************************************************************/

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

// typedef struct _LIST_ENTRY {
//   struct _LIST_ENTRY * volatile Flink;
//   struct _LIST_ENTRY * volatile Blink;
// } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
{RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
{RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
                            }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
                                    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
                                    }


/************************************************************
 *   Function Definitions  
 ************************************************************/


//
// Initialization and cleanup functions
//

DWORD   InitFileHandleCache(VOID);
DWORD   CleanupFileHandleCache(VOID);

HANDLE  FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile);
DWORD   FcCloseFile(IN HANDLE hFile);

BOOL    FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               );


# endif // _OPENF_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\asyncwrite\openf.c ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

      openf.c

   Abstract:

      This module implements a simple open file handle cache

   Project:

       ISAPI Extensions Sample DLL

   Functions Exported:


   Note:
      THIS IS NOT ROBUST for REAL WORLD.
      I wrote this for testing the ISAPI Async IO processing.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "openf.h"


/************************************************************
 *     Type definitions and Globals
 ************************************************************/

//
// internal data structure for maintaining the list of open file handles.
//

typedef struct _OPEN_FILE {
    
    HANDLE  hFile;
    struct _OPEN_FILE * pNext;
    LONG    nHits;
    LONG    nRefs;
    CHAR    rgchFile[MAX_PATH+1];

} OPEN_FILE, * LPOPEN_FILE;


LPOPEN_FILE g_pOpenFiles = NULL;
CRITICAL_SECTION g_csOpenFiles;
BOOL g_fIsNt = TRUE;

//
// Set up global variables containing the flags for CreateFile
//  The flags can be masked for Windows 95 system
//

DWORD  g_dwCreateFileShareMode = 
         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

DWORD  g_dwCreateFileFlags = 
         (FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);

/************************************************************
 *    Functions 
 ************************************************************/


DWORD
InitFileHandleCache(VOID)
/*++

  This function initializes the file handle cache.
  It should be called at the initialization time.

  Arguments:
    None
  
  Returns:
    Win32 error code. NO_ERROR indicates that the call succeeded.
--*/
{
    OSVERSIONINFO  osInfo;
    
    InitializeCriticalSection( &g_csOpenFiles);

    //
    // obtain the platform type to find out how to open the file
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        g_fIsNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    if ( !g_fIsNt) {

        //
        // Reset the flags appropriately so that Windows 95 will be happy
        //

        g_dwCreateFileShareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE);
        g_dwCreateFileFlags     = (FILE_FLAG_SEQUENTIAL_SCAN);
    }

    return (NO_ERROR);

} // InitFileHandleCache()




DWORD
CleanupFileHandleCache(VOID)
{
    LPOPEN_FILE  pFileScan;

    while ( g_pOpenFiles != NULL) {

        pFileScan = g_pOpenFiles;
        g_pOpenFiles = g_pOpenFiles->pNext;

        if ( pFileScan->hFile != INVALID_HANDLE_VALUE) {

            CloseHandle( pFileScan->hFile);
        }

        LocalFree( pFileScan);
    }

    DeleteCriticalSection( &g_csOpenFiles);

    return (NO_ERROR);
} // CleanupFileHandleCache()




HANDLE
FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile)
/*++

 FcOpenFile()
 
 Description:
   This function opens the file specified in the 'pszFile'. 
   If the file name starts with a '/' we use the ECB to map 
   the given path into a physical file path.

 Arguments:
  pecb - pointer to the ECB block
  pszFile - pointer to file name

 Returns:
   valid File handle on success
--*/
{
    LPOPEN_FILE  pFileScan;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    EnterCriticalSection( &g_csOpenFiles);

    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( 0 == lstrcmpi( pFileScan->rgchFile, pszFile)) {

            //
            //  there is a file match. 
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {

        //
        // File was not found. Create a new file handle
        //

        CHAR   rgchFileName[ MAX_PATH]; // local copy
        LPCSTR pszInputPath = pszFile;
        
        lstrcpyn( rgchFileName, pszFile, MAX_PATH);
        if ( *pszFile == '/') { 

            DWORD cbSize = sizeof(rgchFileName);
            BOOL  fRet;

            // reset the file pointer, so subsequent use will fail
            pszFile = NULL;

            //
            // Using the ECB map the Virtual path to the Physical path
            //

            fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                                HSE_REQ_MAP_URL_TO_PATH,
                                                rgchFileName,
                                                &cbSize, NULL);
            
            if (fRet) {
                // we got the mapping. Use it.
                pszFile = rgchFileName;
            }
        }   

        if ( NULL != pszFile) {
            pFileScan = LocalAlloc( LPTR, sizeof( *pFileScan));

            if ( NULL != pFileScan) {
                
                SECURITY_ATTRIBUTES sa;
                
                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;
                
                pFileScan->hFile = 
                    CreateFile( pszFile,
                                GENERIC_READ,
                                g_dwCreateFileShareMode,
                                &sa,
                                OPEN_EXISTING,
                                g_dwCreateFileFlags,
                                NULL );
                
                if ( INVALID_HANDLE_VALUE == pFileScan->hFile) {
                    
                    LocalFree( pFileScan);
                    pFileScan = NULL;
                } else {
                    
                    // insert this into the list at the top
                    lstrcpyn( pFileScan->rgchFile, pszInputPath, MAX_PATH);
                    pFileScan->pNext = g_pOpenFiles;
                    g_pOpenFiles = pFileScan;
                    pFileScan->nRefs = 1;
                    pFileScan->nHits = 0;
                }
            }
        }
    }

    if ( NULL != pFileScan) {

        hFile = pFileScan->hFile;
        pFileScan->nHits++;
        pFileScan->nRefs++;
    }

    LeaveCriticalSection( &g_csOpenFiles);

    return (hFile);

} // FcOpenFile()



DWORD
FcCloseFile(IN HANDLE hFile)
{
    LPOPEN_FILE  pFileScan;
    DWORD dwError = NO_ERROR;

    EnterCriticalSection( &g_csOpenFiles);

    //
    // Look for the handle and decrement the ref count.
    // 
    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( hFile == pFileScan->hFile) {

            //
            //  there is a file match. 
            //

            pFileScan->nRefs--;

            //
            // There is no freeing of the file when Ref hits '0' :(
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {
        //
        // file handle not found
        //
        dwError = ( ERROR_INVALID_HANDLE);
    }

    LeaveCriticalSection( &g_csOpenFiles);


    return ( dwError);

} // FcCloseFile()




BOOL
FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               )
/*++
  Description:
    Reads contents of file [hFile] from the specified offset in the overlapped 
    structure. The contents are read into the buffer supplied.

  Arguments:
    hFile        - handle for the File from which to read data
    pchBuffer    - pointer to the buffer into which the data is to be read
    dwBufferSize - DWORD containing the max size of the buffer supplied
    pcbRead      - number of bytes read from the file
    pov          - pointer to an overlapped structure that contains the 
                     offset from where to read the contents. The
                     overlapped structure also is used for Overlapped
                     IO in NT.

  Notes:
   This function automatically handles both Windows 95 and NT
   

  Returns:
    TRUE on success and FALSE if there is a failure.
    Use GetLastError() to get the last error code on failure.
--*/
{
    BOOL fRet = TRUE;

    *pcbRead = 0;
    
    if ( !g_fIsNt ) {
        //
        // Windows95 does not support Overlapped IO.
        //  So we shall thunk it out and use Synchronous IO
        //
        
        fRet = ( 
                SetFilePointer( hFile, 
                                pov->Offset,
                                NULL,
                                FILE_BEGIN) &&
                ReadFile( hFile,
                          pchBuffer,
                          dwBufferSize,
                          pcbRead,
                          NULL
                          )
                );
    } else {
        
        ResetEvent( pov->hEvent);

        fRet = TRUE;

        // read data from file
        if (!ReadFile(hFile,
                      pchBuffer,
                      dwBufferSize,
                      pcbRead,
                      pov
                      )) {
            
            DWORD err = GetLastError();

            if ( (err != ERROR_IO_PENDING) || 
                 !GetOverlappedResult( hFile, pov, pcbRead, TRUE) ) {
                
                fRet = FALSE;
            }
        }
    }

    if ( fRet ) {
        pov->Offset += *pcbRead;
    }

    return ( fRet );
} // FcReadFromFile()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\syncwrite\openf.c ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

      openf.c

   Abstract:

      This module implements a simple open file handle cache

   Project:

       ISAPI Extensions Sample DLL

   Functions Exported:


   Note:
      THIS IS NOT ROBUST for REAL WORLD.
      I wrote this for testing the ISAPI Async IO processing.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "openf.h"


/************************************************************
 *     Type definitions and Globals
 ************************************************************/

//
// internal data structure for maintaining the list of open file handles.
//

typedef struct _OPEN_FILE {
    
    HANDLE  hFile;
    struct _OPEN_FILE * pNext;
    LONG    nHits;
    LONG    nRefs;
    CHAR    rgchFile[MAX_PATH+1];

} OPEN_FILE, * LPOPEN_FILE;


LPOPEN_FILE g_pOpenFiles = NULL;
CRITICAL_SECTION g_csOpenFiles;
BOOL g_fIsNt = TRUE;

//
// Set up global variables containing the flags for CreateFile
//  The flags can be masked for Windows 95 system
//

DWORD  g_dwCreateFileShareMode = 
         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

DWORD  g_dwCreateFileFlags = 
         (FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);

/************************************************************
 *    Functions 
 ************************************************************/


DWORD
InitFileHandleCache(VOID)
/*++

  This function initializes the file handle cache.
  It should be called at the initialization time.

  Arguments:
    None
  
  Returns:
    Win32 error code. NO_ERROR indicates that the call succeeded.
--*/
{
    OSVERSIONINFO  osInfo;
    
    InitializeCriticalSection( &g_csOpenFiles);

    //
    // obtain the platform type to find out how to open the file
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        g_fIsNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    if ( !g_fIsNt) {

        //
        // Reset the flags appropriately so that Windows 95 will be happy
        //

        g_dwCreateFileShareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE);
        g_dwCreateFileFlags     = (FILE_FLAG_SEQUENTIAL_SCAN);
    }

    return (NO_ERROR);

} // InitFileHandleCache()




DWORD
CleanupFileHandleCache(VOID)
{
    LPOPEN_FILE  pFileScan;

    while ( g_pOpenFiles != NULL) {

        pFileScan = g_pOpenFiles;
        g_pOpenFiles = g_pOpenFiles->pNext;

        if ( pFileScan->hFile != INVALID_HANDLE_VALUE) {

            CloseHandle( pFileScan->hFile);
        }

        LocalFree( pFileScan);
    }

    DeleteCriticalSection( &g_csOpenFiles);

    return (NO_ERROR);
} // CleanupFileHandleCache()




HANDLE
FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile)
/*++

 FcOpenFile()
 
 Description:
   This function opens the file specified in the 'pszFile'. 
   If the file name starts with a '/' we use the ECB to map 
   the given path into a physical file path.

 Arguments:
  pecb - pointer to the ECB block
  pszFile - pointer to file name

 Returns:
   valid File handle on success
--*/
{
    LPOPEN_FILE  pFileScan;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    EnterCriticalSection( &g_csOpenFiles);

    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( 0 == lstrcmpi( pFileScan->rgchFile, pszFile)) {

            //
            //  there is a file match. 
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {

        //
        // File was not found. Create a new file handle
        //

        CHAR   rgchFileName[ MAX_PATH]; // local copy
        LPCSTR pszInputPath = pszFile;
        
        lstrcpyn( rgchFileName, pszFile, MAX_PATH);
        if ( *pszFile == '/') { 

            DWORD cbSize = sizeof(rgchFileName);
            BOOL  fRet;

            // reset the file pointer, so subsequent use will fail
            pszFile = NULL;

            //
            // Using the ECB map the Virtual path to the Physical path
            //

            fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                                HSE_REQ_MAP_URL_TO_PATH,
                                                rgchFileName,
                                                &cbSize, NULL);
            
            if (fRet) {
                // we got the mapping. Use it.
                pszFile = rgchFileName;
            }
        }   

        if ( NULL != pszFile) {
            pFileScan = LocalAlloc( LPTR, sizeof( *pFileScan));

            if ( NULL != pFileScan) {
                
                SECURITY_ATTRIBUTES sa;
                
                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;
                
                pFileScan->hFile = 
                    CreateFile( pszFile,
                                GENERIC_READ,
                                g_dwCreateFileShareMode,
                                &sa,
                                OPEN_EXISTING,
                                g_dwCreateFileFlags,
                                NULL );
                
                if ( INVALID_HANDLE_VALUE == pFileScan->hFile) {
                    
                    LocalFree( pFileScan);
                    pFileScan = NULL;
                } else {
                    
                    // insert this into the list at the top
                    lstrcpyn( pFileScan->rgchFile, pszInputPath, MAX_PATH);
                    pFileScan->pNext = g_pOpenFiles;
                    g_pOpenFiles = pFileScan;
                    pFileScan->nRefs = 1;
                    pFileScan->nHits = 0;
                }
            }
        }
    }

    if ( NULL != pFileScan) {

        hFile = pFileScan->hFile;
        pFileScan->nHits++;
        pFileScan->nRefs++;
    }

    LeaveCriticalSection( &g_csOpenFiles);

    return (hFile);

} // FcOpenFile()



DWORD
FcCloseFile(IN HANDLE hFile)
{
    LPOPEN_FILE  pFileScan;
    DWORD dwError = NO_ERROR;

    EnterCriticalSection( &g_csOpenFiles);

    //
    // Look for the handle and decrement the ref count.
    // 
    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( hFile == pFileScan->hFile) {

            //
            //  there is a file match. 
            //

            pFileScan->nRefs--;

            //
            // There is no freeing of the file when Ref hits '0' :(
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {
        //
        // file handle not found
        //
        dwError = ( ERROR_INVALID_HANDLE);
    }

    LeaveCriticalSection( &g_csOpenFiles);


    return ( dwError);

} // FcCloseFile()




BOOL
FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               )
/*++
  Description:
    Reads contents of file [hFile] from the specified offset in the overlapped 
    structure. The contents are read into the buffer supplied.

  Arguments:
    hFile        - handle for the File from which to read data
    pchBuffer    - pointer to the buffer into which the data is to be read
    dwBufferSize - DWORD containing the max size of the buffer supplied
    pcbRead      - number of bytes read from the file
    pov          - pointer to an overlapped structure that contains the 
                     offset from where to read the contents. The
                     overlapped structure also is used for Overlapped
                     IO in NT.

  Notes:
   This function automatically handles both Windows 95 and NT
   

  Returns:
    TRUE on success and FALSE if there is a failure.
    Use GetLastError() to get the last error code on failure.
--*/
{
    BOOL fRet = TRUE;

    *pcbRead = 0;
    
    if ( !g_fIsNt ) {
        //
        // Windows95 does not support Overlapped IO.
        //  So we shall thunk it out and use Synchronous IO
        //
        
        fRet = ( 
                SetFilePointer( hFile, 
                                pov->Offset,
                                NULL,
                                FILE_BEGIN) &&
                ReadFile( hFile,
                          pchBuffer,
                          dwBufferSize,
                          pcbRead,
                          NULL
                          )
                );
    } else {
        
        ResetEvent( pov->hEvent);

        fRet = TRUE;

        // read data from file
        if (!ReadFile(hFile,
                      pchBuffer,
                      dwBufferSize,
                      pcbRead,
                      pov
                      )) {
            
            DWORD err = GetLastError();

            if ( (err != ERROR_IO_PENDING) || 
                 !GetOverlappedResult( hFile, pov, pcbRead, TRUE) ) {
                
                fRet = FALSE;
            }
        }
    }

    if ( fRet ) {
        pov->Offset += *pcbRead;
    }

    return ( fRet );
} // FcReadFromFile()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\syncread\readcli.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    readcli.c

Abstract:

    This module absorbs input from the client, and then returns
    it to the client.

Revision History:
--*/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_LENGTH 4096
#define STRING_LENGTH 80

// Prototypes
BOOL SendErrorToClient( LPEXTENSION_CONTROL_BLOCK pec, CHAR *szErrorText );

BOOL WINAPI 
GetExtensionVersion( HSE_VERSION_INFO *Version )
/*++

Routine Description:

    Sets the ISAPI extension version information.

Arguments:

    Version     pointer to HSE_VERSION_INFO structure

Return Value:

    TRUE

--*/
{
    Version->dwExtensionVersion = 
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strcpy( Version->lpszExtensionDesc, "ReadClient Extension" );

    return TRUE;
}


DWORD WINAPI 
HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pec )
/*++

Routine Description:

    This is the main routine for any ISAPI application.  We read in all
    the data from the client, using the ReadClient function, and then
    spit it all back out to the client using WriteClient.

Arguments:

    pec           pointer to ECB containing parameters related to the request.

Return Value:

    Either HSE_STATUS_SUCCESS or HSE_STATUS_ERROR

--*/
{
    BOOL bResult;
    CHAR *szBuffer;
    CHAR szTemp[BUFFER_LENGTH];
    CHAR szTmpBuf[BUFFER_LENGTH];
    DWORD dwBytesRead;
    DWORD dwBytesWritten;
    DWORD dwTotalRead;
    DWORD dwTotalWritten;
    DWORD dwContentLength;
    DWORD dwBufferSize;
    HSE_SEND_HEADER_EX_INFO SendHeaderExInfo;

    // Determine the amount of data available from the
    // Content-Length header
    dwBufferSize = sizeof( szTmpBuf ) - 1;
    bResult = pec->GetServerVariable(
        pec->ConnID,
        "CONTENT_LENGTH",
        szTmpBuf,
        &dwBufferSize
        );
    if ( !bResult ) {
        bResult = SendErrorToClient( pec, "Content-Length header not found" );
        if ( !bResult ) {
            return( HSE_STATUS_ERROR );
        }
        return( HSE_STATUS_SUCCESS );
    }
    dwContentLength = atol( szTmpBuf );

    // Allocate the buffer based on the Content-Length
    szBuffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwContentLength + 5 );
    if ( szBuffer == NULL ) {
        sprintf(
            szTemp,
            "Unable to allocate %ld bytes of memory for buffer",
            dwContentLength + 5
            );
        bResult = SendErrorToClient( pec, szTemp );
        if ( !bResult ) {
            return( HSE_STATUS_ERROR );
        }
        return( HSE_STATUS_SUCCESS );
    }

    // If the client didn't post anything, return and create a nice form
    // for them
    if ( pec->cbAvailable == 0 ) {
        bResult = SendErrorToClient( pec, "Your request did not contain any data" );
        if ( !bResult ) {
            return( HSE_STATUS_ERROR );
        }
        return( HSE_STATUS_SUCCESS );
    }


    // Initialize variables before reading in the data
    dwTotalWritten = 0;
    dwTotalRead = pec->cbAvailable;

    // Copy the first chunk of the data into the buffer
    strncpy( szBuffer, pec->lpbData, dwTotalRead );
    szBuffer[dwTotalRead] = 0;

    // Loop to read in the rest of the data from the client
    while ( dwTotalRead < pec->cbTotalBytes ) {
        // Set the size of our temporary buffer
        dwBytesRead = sizeof( szTmpBuf ) - 1;
        if ( (dwTotalRead + dwBytesRead) > pec->cbTotalBytes ) {
            dwBytesRead = pec->cbTotalBytes - dwTotalRead;
        }

        // Read the data into the temporary buffer
        bResult = pec->ReadClient(
            pec->ConnID,
            szTmpBuf,
            &dwBytesRead
            );
        if ( !bResult ) {
            HeapFree( GetProcessHeap(), 0, szBuffer );
            return( HSE_STATUS_ERROR );
        }
        // NULL-Terminate the temporary buffer
        szTmpBuf[dwBytesRead] = 0;

        // Append the temporary buffer to the real buffer
        if ( dwBytesRead != 0 ) {
            strcat( szBuffer + dwTotalRead, szTmpBuf );
        }
        dwTotalRead += dwBytesRead;
    } // while ( dwTotalRead < pec->cbTotalBytes )

    // All the data has been read in and stored in our buffer
    // Now send the data back to the client
    SendHeaderExInfo.pszStatus = "200 OK";
    SendHeaderExInfo.pszHeader = "Content-Type: text/html\r\n\r\n";
    SendHeaderExInfo.cchStatus = lstrlen( SendHeaderExInfo.pszStatus );
    SendHeaderExInfo.cchHeader = lstrlen( SendHeaderExInfo.pszHeader );
    SendHeaderExInfo.fKeepConn = FALSE;

    bResult = pec->ServerSupportFunction(
        pec->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &SendHeaderExInfo,
        NULL,
        NULL
        );
    if ( !bResult ) {
        HeapFree( GetProcessHeap(), 0, szBuffer );
        return( HSE_STATUS_ERROR );
    }
    dwBytesWritten = dwTotalRead;
    bResult = pec->WriteClient(
        pec->ConnID,
        szBuffer,
        &dwBytesWritten,
        0
        );
    if ( !bResult ) {
        HeapFree( GetProcessHeap(), 0, szBuffer );
        return( HSE_STATUS_ERROR );
    }
    HeapFree( GetProcessHeap(), 0, szBuffer );
    return( HSE_STATUS_SUCCESS );
}




BOOL WINAPI
TerminateExtension( DWORD dwFlags )
/*++

Routine Description:

    This function is called when the WWW service is shutdown

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise

--*/
{
    return TRUE;
}


BOOL SendErrorToClient( LPEXTENSION_CONTROL_BLOCK pec, CHAR *szErrorText )
/*++

Routine Description:

    This function sends any error messages and usage information
    to the client.  It also creates a nice little form which can
    be used to post data.

Arguments:

    pec - pointer to ECB containing parameters related to the request
    szErrorText - Helpful error text to send to the client

Return Value:

    TRUE or FALSE, depending on the success of WriteClient

--*/
{
    BOOL bResult;
    CHAR szTemp[BUFFER_LENGTH];
    DWORD dwBytesWritten;
    HSE_SEND_HEADER_EX_INFO SendHeaderExInfo;

    SendHeaderExInfo.pszStatus = "200 OK";
    SendHeaderExInfo.pszHeader = "Content-Type: text/html\r\n\r\n";
    SendHeaderExInfo.cchStatus = lstrlen( SendHeaderExInfo.pszStatus );
    SendHeaderExInfo.cchHeader = lstrlen( SendHeaderExInfo.pszHeader );
    SendHeaderExInfo.fKeepConn = FALSE;

    bResult = pec->ServerSupportFunction(
        pec->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &SendHeaderExInfo,
        NULL,
        NULL
        );
    if ( !bResult ) {
        return FALSE;
    }

    dwBytesWritten = sprintf( 
        szTemp, 
        "<h3>Error: %s</h3><p>\r\n\r\n"
        "Usage: readcli.dll<p>\r\n\r\n"
        "Request must be a POST request, with extra data<p>\r\n"
        "<h2>Sample Form</h2>\r\n"
        "Enter data below:<br>\r\n"
        "<form method=POST action=\"readcli.dll\">\r\n"
        "<input type=text name=test size=80><br>\r\n"
        "<input type=submit>\r\n",
        szErrorText
        );
    bResult = pec->WriteClient(
        pec->ConnID,
        szTemp,
        &dwBytesWritten,
        0
        );
    return( bResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\io\syncwrite\fwrite.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    fwrite.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the WriteClient() callback.

Revision History:
--*/

# define WIN32_LEAN_AND_MEAN
# include <windows.h>
# include <stdio.h>
# include "httpext.h"
# include "openf.h"

DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile);




BOOL WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( " Initializing the global data in fwrite.dll\n");

          //
          // Initialize various data and modules.
          //
          fReturn = (InitFileHandleCache() == NO_ERROR);

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK * pecb
)
{
    DWORD hseStatus;


    if ( pecb->lpszQueryString == NULL) {

        hseStatus = SendHeaderToClient( pecb, "File Not Found");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }

    return ( hseStatus);

} // HttpExtensionProc()





BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using WriteClient" );

    return TRUE;
}



BOOL WINAPI
TerminateExtension(
                   /*IN */ DWORD dwFlags
    )
/*++
  This function is called when IIS decides to stop and unload the 
  ISAPI DLL. We can do any custom cleanup for the module inside this function
--*/
{
    //
    // Nothing specific do here for cleanup
    // Cleanup is done in the dll process detach in DllLibMain()
    //

    return ( TRUE);
}




DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{
	HSE_SEND_HEADER_EX_INFO	SendHeaderExInfo;
	char szStatus[]     = "200 OK";
	char szHeader[1024];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( szHeader,
              "Content-Type: text/html\r\n"
              "\r\n"              // marks the end of header block
              "<head><title>Simple File Transfer (Synchronous Write)"
              "</title></head>\n"
              "<body><h1>%s</h1>\n"
              ,
              pszErrorMsg );


    //
    //  Populate SendHeaderExInfo struct
    //

    SendHeaderExInfo.pszStatus = szStatus;
    SendHeaderExInfo.pszHeader = szHeader;
    SendHeaderExInfo.cchStatus = lstrlen( szStatus);
    SendHeaderExInfo.cchHeader = lstrlen( szHeader);
    SendHeaderExInfo.fKeepConn = FALSE;

    //
    //  Send header - use the EX Version to send the header blob
    //

	if ( !pecb->ServerSupportFunction(
    			pecb->ConnID
    			, HSE_REQ_SEND_RESPONSE_HEADER_EX
    			, &SendHeaderExInfo
    			, NULL
    			, NULL
            ) ) {

    	return HSE_STATUS_ERROR;
	}

    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()



DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile)
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer,
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

        wsprintfA( pchBuffer, " Transferred file contains...");

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile);

            if ( hseStatus != HSE_STATUS_PENDING) {

                if ( hseStatus != HSE_STATUS_SUCCESS) {

                    //
                    // Error in transmitting the file. Send error message.
                    //

                    wsprintfA( pchBuffer,
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);

                    SendHeaderToClient( pecb, pchBuffer);
                }
            }

            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //

                // close file handle
                FcCloseFile( hFile);
            }
        }
    }

    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (4096)

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile)
{
    CHAR  pchBuffer[MAX_BUFFER_SIZE];
    DWORD dwBytesInFile = GetFileSize(hFile, NULL);
    DWORD nRead = 0;
    DWORD hseStatus = HSE_STATUS_SUCCESS;
    OVERLAPPED  ov;
    DWORD err;

    //
    // Send the whole file.
    // Loop thru reading the file and transmitting it to client
    //


    memset(&ov, 0, sizeof(OVERLAPPED));

    ov.OffsetHigh = 0;
    ov.Offset = 0;
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, "OVERLAPPED::hEvent");

    if ( ov.hEvent == NULL) {

        return (HSE_STATUS_ERROR);
    }

    do {

        nRead = 0;

        // read data from the file
        if (!FcReadFromFile( hFile, pchBuffer, MAX_BUFFER_SIZE, &nRead,
                           &ov)
            ) {

            hseStatus = HSE_STATUS_ERROR;
            break;
        }

        // write data to client

        if ( !pecb->WriteClient( pecb->ConnID,
                                 pchBuffer, &nRead,
                                0)
            ) {

            hseStatus = HSE_STATUS_ERROR;
            break;
        }

    } while (TRUE);


    if ( ov.hEvent != NULL) {

        err = GetLastError();
        CloseHandle( ov.hEvent);
        ov.hEvent = NULL;
        SetLastError( err);
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\keepalivewiththreads\threadpool.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    ThreadPool.h

--*/

// Number of threads in pool
#define POOL_THREADS 2

// Number of entries in ECBqueue
#define WORK_QUEUE_ENTRIES 2

// Global critical section to control access to ECB queue
CRITICAL_SECTION csQueueLock;

// Semaphore to wait on in worker thread; each time an ECB is added to the 
// ECBqueue by HttpExtensionProc, the semaphore must be released once
HANDLE hWorkSem;

// These functions will add/retrieve an ECB to/from the linked list.
// ENTER csQueueLock BEFORE CALLING AND LEAVE csQueueLock AFTER
//   RETURNING FROM THESE FUNCTIONS!!!
BOOL AddWorkQueueEntry(EXTENSION_CONTROL_BLOCK *);
BOOL GetWorkQueueEntry(EXTENSION_CONTROL_BLOCK ** ppECB);

// This function initializes the thread pool
BOOL InitThreadPool(void);

// Function that threads in pool run
DWORD WINAPI WorkerFunction(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\keepalivewiththreads\threadpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    ThreadPool.c

Abstract:

    Work queue management functions.

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include "threadpool.h"


//
// Structure to create simple linked list
//

typedef struct {
	EXTENSION_CONTROL_BLOCK *pECB;	    // Data for list entry
	DWORD dwNextEntry;			        // Pointer to next entry
} ECB_QUEUE_ENTRY;


//
// Array that is a simple linked list
//

ECB_QUEUE_ENTRY ECBqueue[WORK_QUEUE_ENTRIES];


//
// Index of next ECBqueue entry to use, and last Entry in use.
//

DWORD dwCurrentEntry, dwLastEntry;


//
// Flag to indicate that there are no other entries in the ECBqueue
//

BOOL fQueueEmpty;


BOOL 
InitThreadPool(
    void
)
/*++
Purpose:

    Initialize our thread pool.

--*/
{
	DWORD i;
	DWORD dwThreadID;

    //
    // Create Semaphore in nonsignaled state
    //

    if ( (hWorkSem = CreateSemaphore( NULL, 0, 0x7fffffff, NULL )) == NULL ) {
		return FALSE;
    }

	InitializeCriticalSection( &csQueueLock );

	fQueueEmpty = TRUE;

    //
	// Create Pool Threads
    //

	for ( i = 0; i < POOL_THREADS; i++ ) {
		if ( CreateThread( 
                NULL, 
                0, 
                WorkerFunction, 
                (LPVOID) i, 
                0, 
                &dwThreadID
                ) == NULL ) {
			return FALSE;
        }
	}

    //
	// Clear work queue
    //

	ZeroMemory( ECBqueue, WORK_QUEUE_ENTRIES * sizeof (ECB_QUEUE_ENTRY) );


	return TRUE;
}


BOOL 
AddWorkQueueEntry(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:

    Add single work unit to the queue

Arguments:

    pECB - pointer to the extension control block

Returns:
    
    TRUE if the unit was successfully queued
    FALSE if queue is full

--*/
{
	DWORD i;

	for ( i = 0; i < WORK_QUEUE_ENTRIES; i++ ) {
		if ( ECBqueue[i].pECB == NULL ) {
			if ( fQueueEmpty ) {
				dwCurrentEntry = i;
				fQueueEmpty = FALSE;
            } else {
				ECBqueue[dwLastEntry].dwNextEntry = i;
            }

			ECBqueue[i].pECB = pECB;
			dwLastEntry = i;

			return TRUE;
		}
	}

	// If no NULL queue entry found, indicate failure
	return FALSE;
}

BOOL 
GetWorkQueueEntry(
    OUT EXTENSION_CONTROL_BLOCK ** ppECB
)
/*++

Purpose:

Arguments:

Returns:

--*/
{
    if ( (*ppECB = ECBqueue[dwCurrentEntry].pECB) == NULL ) {
		return FALSE;
    } else {
		ECBqueue[dwCurrentEntry].pECB = NULL;
		if (dwCurrentEntry == dwLastEntry)	// If this is only pending item

			fQueueEmpty = TRUE;
		else
			dwCurrentEntry = ECBqueue[dwCurrentEntry].dwNextEntry;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\keepalivewiththreads\keepalivep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name: KeepAliveP.c

Abstract:

      Sample ISAPI Extension demonstrating Keep-Alive with a thread pool.

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include "threadpool.h"

BOOL WINAPI 
DllMain( 
    IN HINSTANCE hinstDll, 
    IN DWORD fdwReason, 
    IN LPVOID lpvContext
) 
/*++

Purpose:
    
    Initialize the thread pool when the DLL is loaded by IIS.

Arguments:

    hinstDLL - DLL instance handle
    fdwReason - notification code
    lpdvContext - reserved

Returns:

    TRUE if notification was successfully processed by the DLL
    FALSE to indicate a failure

--*/
{
	BOOL fReturn = TRUE;

	switch ( fdwReason ) {

	case DLL_PROCESS_ATTACH:
		fReturn = InitThreadPool( );
		break;
	}

	return fReturn;
}


BOOL WINAPI 
GetExtensionVersion( 
    OUT HSE_VERSION_INFO * pVer
)
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
	pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );
	lstrcpyn( 
        pVer->lpszExtensionDesc, 
        "ISAPI Keep-Alive with Thread Pool Extension Sample",
		HSE_MAX_EXT_DLL_NAME_LEN );

	return TRUE;
}


DWORD WINAPI 
HttpExtensionProc( 
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:
    Demonstrate usage of persistent connections serviced by a thread pool.

Arguments:

    pECB - points to the extension control block

Returns:
    
    HSE_STATUS_PENDING if request was successfully queued 
    HSE_SUCCESS_AND_KEEP_CONN if request was served immediately
        (presumably because the queue was full)

--*/
{
	DWORD dwSize;
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;

	char szHeader[] = 
        "Connection: Keep-Alive\r\n"
        "Content-Length: %lu\r\n"
        "Content-type: text/html\r\n\r\n";

	char szBusyMessage[] = 
        "<html> <form method=get action=KeepAliveP.dll> <input type=submit> "
	    "<br>pECB->ConnID=%lu  <br>Server was too busy. </form></html>";

	char szBuffer[4096];
	char szBuffer2[4096];

	EnterCriticalSection( &csQueueLock );

    if ( !AddWorkQueueEntry( pECB ) ) {

        //
        // if ECB could not be assigned
        //

		LeaveCriticalSection( &csQueueLock );

		sprintf( szBuffer2, szBusyMessage, pECB->ConnID );

        //
		// Send outgoing header
        //

		sprintf( szBuffer, szHeader, strlen( szBuffer2 ) );

        HeaderExInfo.pszHeader = szBuffer;
        HeaderExInfo.cchHeader = strlen( szBuffer );
        HeaderExInfo.pszStatus = "200 OK";
        HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
        HeaderExInfo.fKeepConn = TRUE;


		pECB->ServerSupportFunction( 
            pECB->ConnID, 
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderExInfo,
            NULL,
			NULL
            );

        //
		// Send content
        //

		dwSize = strlen( szBuffer2 );
		pECB->WriteClient( pECB->ConnID, szBuffer2, &dwSize, 0 );

		return HSE_STATUS_SUCCESS_AND_KEEP_CONN;

	} else {

        //
        // release 1 thread from the pool
        //

		ReleaseSemaphore( hWorkSem, 1, NULL );

		LeaveCriticalSection( &csQueueLock );
	}

	return HSE_STATUS_PENDING;
}


BOOL WINAPI
TerminateExtension( 
    IN DWORD dwFlags 
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise

--*/
{
    return TRUE;
}



DWORD WINAPI 
WorkerFunction( 
    IN LPVOID pvThreadNum
)
/*++

Purpose:
    
    Worker thread function - simulates extended processing
    of the HTTP request

Arguments:

    pvThreadNum - thread number

Returns:
    
    alsways returns 0

--*/
{
	EXTENSION_CONTROL_BLOCK *pECB;
	DWORD dwRet, dwState, dwSize, dwThreadNum;
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;

	//This header will be filled in with the content length
	char szHeader[] = 
        "Connection: Keep-Alive\r\nContent-Length: %lu\r\n"
        "Content-type: text/html\r\n\r\n";

	char szContent[] = 
        "<html> <form method=get action=KeepAliveP.dll><input type=submit> " 
	    "<br>pECB->ConnID=%lu  <br>dwThreadNum=%lu</form></html>";

	char szBuffer[4096];
	char szBuffer2[4096];

	dwThreadNum = ( DWORD ) pvThreadNum;

	while ( TRUE ) {

		dwRet = WaitForSingleObject( hWorkSem, INFINITE );
		if ( dwRet == WAIT_OBJECT_0 ) {

			EnterCriticalSection( &csQueueLock );

            if ( GetWorkQueueEntry( &pECB ) ) {	
                
                //
                // Found work to do
                //

				LeaveCriticalSection( &csQueueLock );

				sprintf( szBuffer2, szContent, pECB->ConnID, dwThreadNum );

				// Send outgoing header
				sprintf( szBuffer, szHeader, strlen( szBuffer2 ) );

                HeaderExInfo.pszHeader = szBuffer;
                HeaderExInfo.cchHeader = strlen( szBuffer );
                HeaderExInfo.pszStatus = "200 OK";
                HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
                HeaderExInfo.fKeepConn = TRUE;

				pECB->ServerSupportFunction( 
                    pECB->ConnID, 
                    HSE_REQ_SEND_RESPONSE_HEADER_EX,
					&HeaderExInfo, 
                    NULL,
                    NULL
                    );

                //
				// Simulate extended processing
                //

				Sleep( 3000 );

				//
                // Send content
                //

				dwSize = strlen( szBuffer2 );
				pECB->WriteClient( pECB->ConnID, szBuffer2, &dwSize, 0 );

				//
                // Tell IIS to keep the connection open
                //

				dwState = HSE_STATUS_SUCCESS_AND_KEEP_CONN;

				pECB->ServerSupportFunction( 
                    pECB->ConnID, 
                    HSE_REQ_DONE_WITH_SESSION, 
                    &dwState, 
                    NULL, 
                    0 
                    );

            } else {			

                //
                // No item found is unexpected condition - exit thread
                //

				LeaveCriticalSection( &csQueueLock );
				ExitThread( 0 );
			}

        } else {
			break;
        }
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\keep-alive\keepalive.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    KeepAlive.c

Abstract:

   Sample ISAPI Extension demonstrating Keep-Alive.

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>


BOOL WINAPI 
GetExtensionVersion(
    OUT HSE_VERSION_INFO * pVer
    )
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strncpy( 
        pVer->lpszExtensionDesc,
        "ISAPI Keep-Alive Extension Sample",
        HSE_MAX_EXT_DLL_NAME_LEN 
        );

    return TRUE;
}


DWORD WINAPI 
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK * pECB
    )
/*++

Purpose:
    Demonstrate persistent connection from ISAPI extension DLL.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS_AND_KEEP_CONN

--*/
{
    //
    // Use the "Connection: Keep-Alive" header to keep the connection open;
    // also, the "Content-Length:" header is required, so that the client knows when
    // the server has finished. 
    //

    char szHeader[] = 
        "Connection: Keep-Alive\r\n"
        "Content-Length: %lu\r\n"
        "Content-type: text/html\r\n\r\n";

    char szContent[] = 
        "<html> <form method=get action=\\scripts\\KeepAlive.dll>"
        "<h1>Keep-Alive Sample</h1><hr>"
        "<input type=submit value=\"Send Request\"></form></html>";

    char szBuffer[4096];
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;
    DWORD dwSize;

    //
    // Send outgoing header with exact content length
    //
    
    sprintf( szBuffer, szHeader, strlen( szContent ) );
    HeaderExInfo.pszHeader = szBuffer;
    HeaderExInfo.cchHeader = strlen( szBuffer );
    HeaderExInfo.pszStatus = "200 OK";
    HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
    HeaderExInfo.fKeepConn = TRUE;

    pECB->ServerSupportFunction( 
        pECB,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &HeaderExInfo,
        NULL,
        NULL
        );


    //
    // Send content
    //

    dwSize = strlen( szContent );

    pECB->WriteClient( pECB, szContent, &dwSize, HSE_IO_SYNC );


    //
    // This return code tells IIS not to close the socket connection.
    //

    return HSE_STATUS_SUCCESS_AND_KEEP_CONN;
}


BOOL WINAPI
TerminateExtension(
    IN DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise
    
--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\authfilt\authfilt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.


Module Name:

    authfilt.c

Abstract:

    This module is an example of an ISAPI Authentication Filter.

    It demonstrates how to do an authentication filter based on an external
    datasource.  Though this sample uses a flat file, access to a database
    could easily be plugged in.

--*/

#include <windows.h>
#include <httpfilt.h>
#include "authfilt.h"

//
// Functions
//

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    BOOL        fReturn = TRUE;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:

        if ( !InitializeUserDatabase() ||
             !InitializeCache() )
        {
            DbgWrite(( DEST,
                       "[GetFilterVersion] Database or cache failed, error %d\n",
                       GetLastError() ))

            return FALSE;
        }

        //
        //  We don't care about thread attach/detach notifications
        //

        DisableThreadLibraryCalls( hinstDll );

        break;

    case DLL_PROCESS_DETACH:
        {

            if ( lpvContext != NULL)
            {
                TerminateCache();
                TerminateUserDatabase();
            }

            break;
        } /* case DLL_PROCESS_DETACH */

    default:
        break;
    }   /* switch */

    return ( fReturn);
}  /* DllLibMain() */



BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    DbgWrite(( DEST,
               "[GetFilterVersion] Server filter version is %d.%d\n",
               HIWORD( pVer->dwServerFilterVersion ),
               LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_AUTHENTICATION     |
                     SF_NOTIFY_LOG                |

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "Sample Authentication Filter, version 1.0" );

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
/*++

Routine Description:

    Filter notification entry point

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    BOOL                  fAllowed;
    CHAR                  achUser[SF_MAX_USERNAME];
    HTTP_FILTER_AUTHENT * pAuth;
    HTTP_FILTER_LOG *     pLog;
    CHAR *                pch;

    //
    //  Handle this notification
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_AUTHENTICATION:

        pAuth = (HTTP_FILTER_AUTHENT *) pvData;

        //
        //  Ignore the anonymous user
        //

        if ( !*pAuth->pszUser )
        {
            //
            //  Tell the server to notify any subsequent notifications in the
            //  chain
            //

            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        //  Save the unmapped username so we can log it later
        //

        strcpy( achUser, pAuth->pszUser );

        //
        //  Make sure this user is a valid user and map to the appropriate
        //  Windows NT user
        //

        if ( !ValidateUser( pAuth->pszUser,
                            pAuth->pszPassword,
                            &fAllowed ))
        {
            DbgWrite(( DEST,
                       "[OnAuthentication] Error %d validating user %s\n",
                       GetLastError(),
                       pAuth->pszUser ));

            return SF_STATUS_REQ_ERROR;
        }

        if ( !fAllowed )
        {
            //
            //  This user isn't allowed access.  Indicate this to the server
            //

            SetLastError( ERROR_ACCESS_DENIED );

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped user name so we can log it later on.  We allocate
        //  enough space for two usernames so we can use this memory block
        //  for logging.  Note we may have already allocated it from a previous
        //  request on this TCP session
        //

        if ( !pfc->pFilterContext )
        {
            pfc->pFilterContext = pfc->AllocMem( pfc, 2 * SF_MAX_USERNAME + 4, 0 );

            if ( !pfc->pFilterContext )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return SF_STATUS_REQ_ERROR;
            }
        }

        strcpy( (CHAR *) pfc->pFilterContext, achUser );

        return SF_STATUS_REQ_HANDLED_NOTIFICATION;

    case SF_NOTIFY_LOG:

        //
        //  The unmapped username is in pFilterContext if this filter
        //  authenticated this user
        //

        if ( pfc->pFilterContext )
        {
            pch  = pfc->pFilterContext;
            pLog = (HTTP_FILTER_LOG *) pvData;

            //
            //  Put both the original username and the NT mapped username
            //  into the log in the form "Original User (NT User)"
            //

            strcat( pch, " (" );
            strcat( pch, pLog->pszClientUserName );
            strcat( pch, ")" );

            pLog->pszClientUserName = pch;
        }

        return SF_STATUS_REQ_NEXT_NOTIFICATION;

    default:
        DbgWrite(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        break;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\authfilt\authfilt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.


Module Name:

    authfilt.h

Abstract:

    This module contains the common definitions for the authentication filter
    sample

--*/

#ifndef _AUTHFILT_H_
#define _AUTHFILT_H_

//
//  Constants
//

#define ISWHITE( ch )      ((ch) && ((ch) == ' ' || (ch) == '\t' ||  \
                            (ch) == '\n' || (ch) == '\r'))

#if DBG
#define DEST               buff
#define DbgWrite( x )      {                                    \
                                char buff[256];                 \
                                wsprintf x;                     \
                                OutputDebugString( buff );      \
                           }
#else
#define DbgWrite( x )      /* nothing */
#endif


//
//  Prototypes
//

//
//  Database routines
//

BOOL
InitializeUserDatabase(
    VOID
    );

BOOL
ValidateUser(
    CHAR * pszUserName,
    CHAR * pszPassword,
    BOOL * pfValid
    );

BOOL
LookupUserInDb(
    IN CHAR * pszUser,
    OUT BOOL * pfFound,
    OUT CHAR * pszPassword,
    OUT CHAR * pszNTUser,
    OUT CHAR * pszNTUserPassword
    );

VOID
TerminateUserDatabase(
    VOID
    );

//
//  Cache routines
//

BOOL
InitializeCache(
    VOID
    );

BOOL
LookupUserInCache(
    CHAR * pszUserName,
    BOOL * pfFound,
    CHAR * pszPassword,
    CHAR * pszNTUser,
    CHAR * pszNTUserPassword
    );

BOOL
AddUserToCache(
    CHAR * pszUserName,
    CHAR * pszPassword,
    CHAR * pszNTUser,
    CHAR * pszNTUserPassword
    );

VOID
TerminateCache(
    VOID
    );

#endif //_AUTHFILT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\redirect\redirect.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    redirect.cpp

Abstract:

    Redirect is a sample ISAPI extension to demonstrate redirecting
    a request.  It redirects requests to a URL specified on the
    query string.  

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>

#define BUFF_SIZE   2048

//
// local prototypes
//

DWORD SendInstructionPage( EXTENSION_CONTROL_BLOCK * pECB );




BOOL WINAPI 
GetExtensionVersion( 
    OUT HSE_VERSION_INFO * pVer 
)
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
	pVer->dwExtensionVersion = 
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

	lstrcpyn( 
        pVer->lpszExtensionDesc, 
        "Redirect ISAPI Sample", 
        HSE_MAX_EXT_DLL_NAME_LEN );

	return TRUE;
}


DWORD WINAPI 
HttpExtensionProc( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
/*++

Purpose:

    If no query string is present, or if the query
    string is not identified as a legal target for redirection,
    Redirect.dll will return a page to the client with brief 
    instructions for its use.

    Redirections to a resource on the same server as the dll will
    be handled by IIS and will be transparent to the browser
    (HSE_REQ_SEND_URL).

    Redirections to a resource on a different server will result
    in an HTTP 302 response instructing the browser to obtain the 
    resource from another location (HSE_REQ_SEND_URL_REDIRECT_RESP).

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS on successful completion
    HSE_STATUS_ERROR on failure

--*/
{
    //        
	// If no query string is present, return the instruction page
    //

    if ( !strlen( pECB->lpszQueryString ) ) {

		return SendInstructionPage( pECB );
    }

    //
	// Check to see if the redirect URL is on another server. If it is, use
	// HSE_REQ_SEND_URL_REDIRECT_RESP.  If it's on this local server, use
	// HSE_REQ_SEND_URL to return the specified URL without using an HTTP 302
	// status code.
    //

	DWORD dwBuffSize = strlen( pECB->lpszQueryString );


    if ( !strnicmp( pECB->lpszQueryString, "http://", 7 ) ) {

        pECB->ServerSupportFunction( 
            pECB->ConnID, 
            HSE_REQ_SEND_URL_REDIRECT_RESP, 
            pECB->lpszQueryString, 
            &dwBuffSize, 
            NULL 
            );

    } else {

        //
		// Check to make sure that query string begins with a '/'.
        //

        if ( *( pECB->lpszQueryString ) != '/' ) {

			return SendInstructionPage( pECB );
        }

		pECB->ServerSupportFunction( 
            pECB->ConnID, 
            HSE_REQ_SEND_URL, 
            pECB->lpszQueryString, 
            &dwBuffSize, 
            NULL 
            );
	}

	return HSE_STATUS_SUCCESS;
}


DWORD 
SendInstructionPage( 
    IN EXTENSION_CONTROL_BLOCK * pECB 
)
/*++

Purpose:
    Send short http usage description to the user.

Arguments:

    pECB - pointer to the extenstion control block 
    
Returns:

    HSE_STATUS_SUCCESS on successful completion
    HSE_STATUS_ERROR on failure

--*/
{

	char szStatus[] = "200 OK";
	char szContent[] =
	"<html>"
	"<head><title>Redirect URL</title></head>"
	"<body>"
	"<h1>Redirect.dll</h1>\r\n<hr>\r\n"
	"Redirect.dll returns the resource specified on the query string.<br>\r\n<br>\r\n"
	"To specify a resource on the same server as Redirect.dll, use the following form:<br>\r\n<br>\r\n"
	"<code> http://server/scripts/Redirect.dll?/virtualdir/file.htm </code><br>\r\n<br>\r\n"
	"To specify a resource on another server, use the following form:<br>\r\n<br>\r\n"
	"<code> http://server/scripts/Redirect.dll?http://server/virtualdir/file.htm </code>"
	"</body>"
	"</html>";

	char szHeaderBase[] = "Content-Length: %lu\r\nContent-type: text/html\r\n\r\n";
	char szHeader[BUFF_SIZE];



	//
	//  fill in byte count in Content-Length header
	//

    DWORD cchContent = strlen( szContent );

	sprintf( szHeader, szHeaderBase, cchContent );


	//
	//  Populate SendHeaderExInfo struct
	//

	HSE_SEND_HEADER_EX_INFO SendHeaderExInfo;

	SendHeaderExInfo.pszStatus = szStatus;
	SendHeaderExInfo.pszHeader = szHeader;
	SendHeaderExInfo.cchStatus = strlen( szStatus );
	SendHeaderExInfo.cchHeader = strlen( szHeader );
	SendHeaderExInfo.fKeepConn = FALSE;

    //
    // Send header
    //

	if ( !pECB->ServerSupportFunction( 
			pECB->ConnID,
			HSE_REQ_SEND_RESPONSE_HEADER_EX,
			&SendHeaderExInfo,
			NULL,
			NULL
		    ) ) {

		return HSE_STATUS_ERROR;
	}

	//
	//  Send content
	//

	if ( !pECB->WriteClient( pECB->ConnID, szContent, &cchContent, 0 ) ) {

		return HSE_STATUS_ERROR;
	}

	return HSE_STATUS_SUCCESS;

}


BOOL WINAPI
TerminateExtension( 
    IN DWORD dwFlags 
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\servervariables\dumpvars.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    DumpVars.cpp

Abstract:

    ISAPI Extension sample to dump server variables

--*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>


DWORD WINAPI 
HttpExtensionProc( 
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:

    Use WriteClient() function to dump the value of each 
    server variable in the table.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_SUCCESS

--*/
{
	char * aszServerVariables[] =
	    {"APPL_MD_PATH", "APPL_PHYSICAL_PATH", "AUTH_PASSWORD",
		"AUTH_TYPE", "AUTH_USER", "CERT_COOKIE", "CERT_FLAGS",
		"CERT_ISSUER", "CERT_KEYSIZE", "CERT_SECRETKEYSIZE",
		"CERT_SERIALNUMBER", "CERT_SERVER_ISSUER",
		"CERT_SERVER_SUBJECT", "CERT_SUBJECT", "CONTENT_LENGTH",
		"CONTENT_TYPE", "HTTP_ACCEPT", "HTTPS", "HTTPS_KEYSIZE",
		"HTTPS_SECRETKEYSIZE", "HTTPS_SERVER_ISSUER",
		"HTTPS_SERVER_SUBJECT", "INSTANCE_ID", "INSTANCE_META_PATH",
		"PATH_INFO", "PATH_TRANSLATED", "QUERY_STRING",
		"REMOTE_ADDR", "REMOTE_HOST", "REMOTE_USER",
		"REQUEST_METHOD", "SCRIPT_NAME", "SERVER_NAME",
		"SERVER_PORT", "SERVER_PORT_SECURE", "SERVER_PROTOCOL",
		"SERVER_SOFTWARE", "URL"};
	char szOutput[2048], szValue[1024];
	DWORD dwBuffSize, dwNumVars, dwError, x;
    HSE_SEND_HEADER_EX_INFO HeaderExInfo;

    //
	// Send headers to the client
    //
    HeaderExInfo.pszStatus = "200 OK";
    HeaderExInfo.pszHeader = "Content-type: text/html\r\n\r\n";
    HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
    HeaderExInfo.cchHeader = strlen( HeaderExInfo.pszHeader );
    HeaderExInfo.fKeepConn = FALSE;
    
    pECB->ServerSupportFunction( 
        pECB->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &HeaderExInfo,
        NULL,
        NULL
        );


    //
	// Begin sending back HTML to the client
    //

	strcpy( 
        szOutput, 
        "<HTML>\r\n<BODY><h1>Server Variable Dump</h1>\r\n<hr>\r\n"
        );
	dwBuffSize = strlen( szOutput );
	pECB->WriteClient( pECB->ConnID, szOutput, &dwBuffSize, 0 );


	dwNumVars = ( sizeof aszServerVariables )/( sizeof aszServerVariables[0] );

    //
	// Get the server variables and send them
    //

	for ( x = 0; x < dwNumVars; x++ ) {

		dwBuffSize = 1024;
        szValue[0] = '\0';
		if ( !pECB->GetServerVariable( 
                pECB->ConnID, 
                aszServerVariables[x], 
                szValue, 
                &dwBuffSize
                ) ) {

            //
            // Analyze the problem and report result to user
            //

			switch (dwError = GetLastError( )) {
			case ERROR_INVALID_PARAMETER:
				strcpy( szValue, "ERROR_INVALID_PARAMETER" );
				break;

			case ERROR_INVALID_INDEX:
				strcpy( szValue, "ERROR_INVALID_INDEX" );
				break;

			case ERROR_INSUFFICIENT_BUFFER:
				wsprintf( 
                    szValue, 
                    "ERROR_INSUFFICIENT_BUFFER - %d bytes required.", 
                    dwBuffSize
                    );
				break;

			case ERROR_MORE_DATA:
				strcpy( szValue, "ERROR_MORE_DATA" );
				break;

			case ERROR_NO_DATA:
				strcpy( szValue, "ERROR_NO_DATA" );
				break;

			default:
				wsprintf( 
                    szValue, 
                    "*** Error %d occured retrieving server variable ***",
                    dwError
                    );
			}
		}

        // 
        // Dump server variable name and value
        //

		wsprintf( szOutput, "%s: %s<br>\r\n", aszServerVariables[x], szValue );
		dwBuffSize = strlen( szOutput );

        //
        // Send the line to client
        //

		pECB->WriteClient( pECB->ConnID, szOutput, &dwBuffSize, 0 );
	}

	//
    // End HTML page
    //

	strcpy( szOutput, "</BODY>\r\n</HTML>\r\n\r\n" );
	dwBuffSize = strlen( szOutput );
	pECB->WriteClient( pECB->ConnID, szOutput, &dwBuffSize, 0 );

	return HSE_STATUS_SUCCESS;
}


BOOL WINAPI 
GetExtensionVersion( 
    OUT HSE_VERSION_INFO * pVer
 )
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{
	pVer->dwExtensionVersion = 
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

	lstrcpyn( 
        pVer->lpszExtensionDesc, 
        "DumpVars ISAPI Sample", 
        HSE_MAX_EXT_DLL_NAME_LEN );

	return TRUE;
}


BOOL WINAPI
TerminateExtension( 
    IN DWORD dwFlags 
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\workerthread\workerthread.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:    WorkerThread.c

Abstract:

    IIS maintains a pool of threads to handle incoming HTTP requests.  When all of
    these threads are in use, new requests will be rejected.  If all the pool threads
    are in a wait state (for instance, running ISAPI dlls that are waiting for a query
    on a remote database to complete), IIS may reject incoming requests even if there
    is plenty of CPU power to handle them.
    
    One way of avoiding this situation is to offload processing of these types of
    requests to a worker thread, releasing the IIS thread back to the pool so that it
    can be used for another request.  This basic sample demonstrates how to implement
    this in an ISAPI dll.

*/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>
#include <stdio.h>

//
// global variables
//

DWORD g_dwThreadCount = 0;

//
// local functions prototypes
//

DWORD WINAPI WorkerFunction( LPVOID ); 
BOOL SendHttpHeaders(EXTENSION_CONTROL_BLOCK *, LPCSTR , LPCSTR, BOOL );



BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO *pVer
)
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - poins to extension version info structure 

Returns:

    always returns TRUE

--*/
{

    //
    // tell the server our version number and extension description
    //

    pVer->dwExtensionVersion =
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    lstrcpyn(
        pVer->lpszExtensionDesc, 
        "ISAPI Worker Thread Extension Sample", 
        HSE_MAX_EXT_DLL_NAME_LEN 
        );

	return TRUE;
}


DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK *pECB
)
/*++

Purpose:

    Create a thread to handle extended processing. It will be passed 
    the address of a function ("WorkerFunction") to run, and the address 
    of the ECB associated with this session.

Arguments:

    pECB - pointer to the extenstion control block 

Returns:

    HSE_STATUS_PENDING to mark this request as pending

--*/
{
    DWORD dwThreadID;


    // (NOTE: in production environment you'd probably 
    //  wanted to limit the number of threads created)

    CreateThread(NULL,              // Pointer to thread security attributes 
                 0,                 // Initial thread stack size, in bytes 
                 WorkerFunction,    // Pointer to thread function 
                 pECB,              // The ECB is the argument for the new thread
                 0,                 // Creation flags 
                 &dwThreadID        // Pointer to returned thread identifier 
                 );

    //
    // update global thread count
    //

    InterlockedIncrement( &g_dwThreadCount );

    // Return HSE_STATUS_PENDING to release IIS pool thread without losing connection

    return HSE_STATUS_PENDING;
}


DWORD WINAPI 
WorkerFunction(
    IN LPVOID vECB
)
/*++

Purpose:

    Show how to perform extended processing in ISAPI DLL without
    tying IIS threads. 

Arguments:

    vECB - points to current extension control block

Returns:
    
    returns 0  

--*/
{
    char szHeader[] =   "Content-type: text/html\r\n\r\n";
    char szContent[]=   "<html> <form method=get action=WorkerThread.dll><h1>Worker Thread Sample</h1><hr>"
                        "<input type=submit value=\"Send Request\"> </form></html>";
    EXTENSION_CONTROL_BLOCK *pECB;
    DWORD dwSize;

    //
    // Initialize local ECB pointer to void pointer passed to thread
    //

    pECB = vECB;
	

    //
    // Send outgoing header
    //
	
    SendHttpHeaders( pECB, "200 OK", szHeader, FALSE );

    //
    // Simulate extended processing for 5 seconds
    //
    
    Sleep(5000);


    //
    // Send content
    //
    
    dwSize = strlen( szContent );
    pECB->WriteClient( pECB->ConnID, szContent, &dwSize, 0 );


    //
    // Inform server that the request has been satisfied, 
    // and the connection may now be dropped
    //

    pECB->ServerSupportFunction( 
        pECB->ConnID, 
        HSE_REQ_DONE_WITH_SESSION, 
        NULL, 
        NULL, 
        NULL 
        );

    //
    // update global thread count
    //

    InterlockedDecrement( &g_dwThreadCount );

    return 0;
}


BOOL 
SendHttpHeaders( 
    EXTENSION_CONTROL_BLOCK *pECB, 
    LPCSTR pszStatus,
    LPCSTR pszHeaders,
    BOOL fKeepConnection
)
/*++

Purpose:
    Send specified HTTP status string and any additional header strings
    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO

Arguments:

    pECB - pointer to the extension control block
    pszStatus - HTTP status string (e.g. "200 OK")
    pszHeaders - any additional headers, separated by CRLFs and 
                 terminated by empty line

Returns:

    TRUE if headers were successfully sent
    FALSE otherwise

--*/
{
    HSE_SEND_HEADER_EX_INFO header_ex_info;
    BOOL success;

    header_ex_info.pszStatus = pszStatus;
    header_ex_info.pszHeader = pszHeaders;
    header_ex_info.cchStatus = strlen( pszStatus );
    header_ex_info.cchHeader = strlen( pszHeaders );
    header_ex_info.fKeepConn = fKeepConnection;


    success = pECB->ServerSupportFunction(
                  pECB->ConnID,
                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                  &header_ex_info,
                  NULL,
                  NULL
                  );

    return success;
}


BOOL WINAPI
TerminateExtension( 
    IN DWORD dwFlags 
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown.

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE when extension is ready to be unloaded,

--*/
{

    // (Our threads are deterministic and will complete 
    //  not much later than 5 seconds from now)

    //
    // wait for all threads to terminate, sleeping for 1 sec
    //

    while( g_dwThreadCount > 0 ) {
        SleepEx( 1000, FALSE );
    }

    //
    // make sure the last thread indeed exited
    //

    SleepEx( 1000, FALSE );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\extensions\simple\simple.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    Simple.cpp

Abstract:

    This module shows the basic functions needed for ISAPI extension

--*/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <httpext.h>



BOOL WINAPI 
DllMain( 
    IN HINSTANCE hinstDll, 
    IN DWORD dwReason,
    IN LPVOID lpvContext 
)
/*++
Function :  DllMain

Description:

    The initialization function for this DLL.

Arguments:

    hinstDll - Instance handle of the DLL
    dwReason - Reason why NT called this DLL
    lpvContext - Reserved parameter for future use

Return Value:

    Returns TRUE if successfull; otherwise FALSE.

--*/
{
    // Note that appropriate initialization and termination code
    // would be written within the switch statement below.  Because
    // this example is very simple, none is currently needed.

    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}


BOOL WINAPI 
GetExtensionVersion( 
    OUT HSE_VERSION_INFO * pVer 
)
/*++

Purpose:

    The first function called after IIS successfully 
    loads the DLL.  The function should use the 
    version structure provided by IIS to set the ISAPI
    architectural version number of this extension.

    A simple text-string is also set so that 
    administrators can identify the DLL.

    Note that HSE_VERSION_MINOR and HSE_VERSION_MAJOR
    are constants defined in httpext.h.

Arguments: 

    pVer - points to extension version structure

Return Value:

    TRUE if successful; FALSE otherwise.    

--*/
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                             HSE_VERSION_MAJOR );

    strcpy( pVer->lpszExtensionDesc,
            "IIS SDK Simple ISAPI Extension" );

    return TRUE;
}


DWORD WINAPI 
HttpExtensionProc( 
    IN EXTENSION_CONTROL_BLOCK * pECB
)
/*++

Purpose:    

    Function called by the IIS Server when a request 
    for the ISAPI dll arrives.  The HttpExtensionProc                  
    function processes the request and outputs the
    appropriate response to the web client using
    WriteClient().

Argument:

    pECB - pointer to extention control block.

Return Value:

    HSE_STATUS_SUCCESS

--*/
{
    static char szMessage[] = 
    "<HTML>"
    "<HEAD><TITLE> Simple ISAPI Extension DLL </TITLE>"
    "</HEAD>\r\n"
    "<BODY>"
    "<P>Hello from Simple ISAPI Extension DLL!</P>\r\n"
    "</BODY></HTML>\r\n\r\n";

    HSE_SEND_HEADER_EX_INFO HeaderExInfo;

    //
    // prepare headers 
    //

    HeaderExInfo.pszStatus = "200 OK";
    HeaderExInfo.pszHeader = "Content-type: text/html\r\n\r\n";
    HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
    HeaderExInfo.cchHeader = strlen( HeaderExInfo.pszHeader );
    HeaderExInfo.fKeepConn = FALSE;

    
    //
    // send headers using IIS-provided callback
    // (note - if we needed to keep connection open,
    //  we would set fKeepConn to TRUE *and* we would
    //  need to provide correct Content-Length: header)

    pECB->ServerSupportFunction(
        pECB->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &HeaderExInfo,
        NULL,
        NULL
        );

    //
    // Calculate length of string to output to client
    //

    DWORD dwBytesToWrite = strlen( szMessage );
    

    //
    // send text using IIS-provied callback
    //

    pECB->WriteClient( pECB->ConnID, szMessage, &dwBytesToWrite, 0 );

    //
    // Indicate that the call to HttpExtensionProc was successful
    //

    return HSE_STATUS_SUCCESS;
}



BOOL WINAPI
TerminateExtension( 
    IN DWORD dwFlags 
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE if extension is ready to be unloaded,
    FALSE otherwise

--*/
{
    // Note: We must not agree to be unloaded if we have
    // any pending requests.

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\authfilt\cache.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.


Module Name:

    cache.c

Abstract:

    This module implements a simple user cache.  The cached users are kept
    in an LRU sorted list.  If there will be a large number of simultaneous
    users, then a sorted array would be more appropriate.

--*/

#include <windows.h>
#include <httpfilt.h>
#include "authfilt.h"

//
// Constants
//

//
//  The maximum number of users we will cache.  If there will be a large number
//  of simultaneous users, bump this value
//

#define MAX_CACHED_USERS        100

//
//  The position after which we'll move a cache entry to the front of the list
//

#define LIST_REORDER_THRESHOLD  6

//
//  Cached user structure
//

typedef struct _USER_INFO
{
    LIST_ENTRY  ListEntry;  // Double linked list entry

    CHAR  achUserName[SF_MAX_USERNAME];   // External username and password
    CHAR  achPassword[SF_MAX_PASSWORD];

    CHAR  achNTUserName[SF_MAX_USERNAME]; // NT account and password to map user to
    CHAR  achNTUserPassword[SF_MAX_PASSWORD];

} USER_INFO, *PUSER_INFO;


//
//  Globals
//

//
//  Circular double linked list of cached users
//

LIST_ENTRY CacheListHead;

//
//  Critical section protects cache list
//

CRITICAL_SECTION csCacheLock;

//
//  Indicates whether we are initialized
//

BOOL fCacheInitialized = FALSE;

//
//  Number of items in the cache
//

DWORD cCacheItems = 0;


BOOL
InitializeCache(
    VOID
    )
/*++

Routine Description:

    Initializes the cache module

Return Value:

    TRUE if initialized successfully, FALSE on error

--*/
{
    if ( fCacheInitialized )
        return TRUE;

    InitializeCriticalSection( &csCacheLock );
    CacheListHead.Blink = CacheListHead.Flink = &CacheListHead;

    fCacheInitialized = TRUE;

    return TRUE;
}


BOOL
LookupUserInCache(
    CHAR * pszUserName,
    BOOL * pfFound,
    CHAR * pszPassword,
    CHAR * pszNTUser,
    CHAR * pszNTUserPassword
    )
/*++

Routine Description:

    Checks to see if a user is in the cache and returns the user properties
    if found

Arguments:

    pszUserName - Case insensitive username to find
    pfFound     - Set to TRUE if the specified user was found
    pszPassword - Receives password for specified user if found
    pszNTUser   - Receives the NT Username to map this user to
    pszNTUserPassword - Receives the NT Password for pszNTUser

    Note: pszPassword and pszNTUserPassword must be at least SF_MAX_PASSWORD
    characters.  pszNTUser must be at least SF_MAX_USERNAME characters.

Return Value:

    TRUE if no errors occurred.

--*/
{
    LIST_ENTRY * pEntry;
    USER_INFO *  pUser;
    DWORD        cPosition = 0;

    //
    //  Search the cache for the specified user
    //

    EnterCriticalSection( &csCacheLock );

    for ( pEntry  = CacheListHead.Flink;
          pEntry != &CacheListHead;
          pEntry = pEntry->Flink )
    {
        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry );

        if ( !stricmp( pszUserName, pUser->achUserName ))
        {
            goto Found;
        }

        cPosition++;
    }

    LeaveCriticalSection( &csCacheLock );

    //
    //  Not Found
    //

    *pfFound = FALSE;
    return TRUE;

Found:

    //
    //  Copy out the user properties
    //

    strcpy( pszPassword,       pUser->achPassword );
    strcpy( pszNTUser,         pUser->achNTUserName );
    strcpy( pszNTUserPassword, pUser->achNTUserPassword );

    //
    //  Move this user entry to the front of the list as we're probably going
    //  to get subsequent requests for this user.  Note we only move it
    //  if it's not already near the front
    //

    if ( cPosition > LIST_REORDER_THRESHOLD )
    {
        //
        //  Remove from the old position...
        //

        pEntry->Blink->Flink = pEntry->Flink;
        pEntry->Flink->Blink = pEntry->Blink;

        //
        // ...and insert it at the beginning of the list
        //

        pEntry->Blink = &CacheListHead;
        pEntry->Flink = CacheListHead.Flink;

        CacheListHead.Flink->Blink = pEntry;
        CacheListHead.Flink        = pEntry;
    }

    LeaveCriticalSection( &csCacheLock );

    *pfFound = TRUE;

    return TRUE;
}

BOOL
AddUserToCache(
    CHAR * pszUserName,
    CHAR * pszPassword,
    CHAR * pszNTUser,
    CHAR * pszNTUserPassword
    )
/*++

Routine Description:

    Adds the specified user to the cache

Arguments:

    pszUserName - Username to add
    pszPassword - Contains the external password for this user
    pszNTUser   - Contains the NT user name to use for this user
    pszNTUserPassword - Contains the password for NTUser

Return Value:

    TRUE if no errors occurred.

--*/
{
    LIST_ENTRY * pEntry;
    USER_INFO *  pUser;

    //
    //  Check our parameters before adding them to the cache
    //

    if ( strlen( pszUserName ) > SF_MAX_USERNAME ||
         strlen( pszPassword ) > SF_MAX_PASSWORD ||
         strlen( pszNTUser   ) > SF_MAX_USERNAME ||
         strlen( pszNTUserPassword ) > SF_MAX_PASSWORD )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Search the cache for the specified user to make sure there are no
    //  duplicates
    //

    EnterCriticalSection( &csCacheLock );

    for ( pEntry  = CacheListHead.Flink;
          pEntry != &CacheListHead;
          pEntry = pEntry->Flink )
    {
        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry );

        if ( !stricmp( pszUserName, pUser->achUserName ))
        {
            goto Found;
        }
    }

    //
    //  Allocate a new cache item and put it at the head of the list
    //

    pUser = (USER_INFO *) LocalAlloc( LPTR, sizeof( USER_INFO ));

    if ( !pUser )
    {
        LeaveCriticalSection( &csCacheLock );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    pUser->ListEntry.Flink = CacheListHead.Flink;
    pUser->ListEntry.Blink = &CacheListHead;

    CacheListHead.Flink->Blink = &pUser->ListEntry;
    CacheListHead.Flink = &pUser->ListEntry;

Found:

    //
    //  Set the various fields
    //

    strcpy( pUser->achUserName,       pszUserName );
    strcpy( pUser->achPassword,       pszPassword );
    strcpy( pUser->achNTUserName,     pszNTUser );
    strcpy( pUser->achNTUserPassword, pszNTUserPassword );

    cCacheItems++;

    //
    //  If there are too many cached users, remove the least recently
    //  used one now
    //

    if ( cCacheItems > MAX_CACHED_USERS )
    {
        pEntry = CacheListHead.Blink;

        pEntry->Blink->Flink = &CacheListHead;
        CacheListHead.Blink  = pEntry->Blink;

        LocalFree( CONTAINING_RECORD( pEntry, USER_INFO, ListEntry ));

        cCacheItems--;
    }

    LeaveCriticalSection( &csCacheLock );

    return TRUE;
}

VOID
TerminateCache(
    VOID
    )
/*++

Routine Description:

    Terminates the cache module and frees any allocated memory

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pEntryNext;
    USER_INFO *  pUser;

    if ( !fCacheInitialized )
        return;

    EnterCriticalSection( &csCacheLock );

    //
    //  Free all of the cache entries
    //

    for ( pEntry  = CacheListHead.Flink;
          pEntry != &CacheListHead;
          pEntry  = pEntryNext )

    {
        pUser = CONTAINING_RECORD( pEntry, USER_INFO, ListEntry );

        pEntryNext = pEntry->Flink;

        //
        //  Remove this entry from the list and free it
        //

        pEntry->Blink->Flink = pEntry->Flink;
        pEntry->Flink->Blink = pEntry->Blink;

        LocalFree( pUser );
    }

    cCacheItems = 0;
    LeaveCriticalSection( &csCacheLock );

    DeleteCriticalSection( &csCacheLock );

    fCacheInitialized = FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\authfilt\db.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

This program is released into the public domain for any purpose.


Module Name:

    db.c

Abstract:

    This module implements the database routines for the authentication filter.

--*/

#include <windows.h>
#include <httpfilt.h>
#include "authfilt.h"

//
//  This is the name of the file that contains the username/password pairs and
//  the appropriate NT account the username/password should be mapped to.
//
//  The format of the file is:
//
//  User1:Password1, NTUser1:NTPassword1
//  User2:Password2, NTUser2:NTPassword2
//  User3:Password3, NTUser1:NTPassword1
//
//

#define USER_LIST_FILE     "c:\\inetsrv\\userdb.txt"

//
//  Globals
//

CHAR * pszUserFile = NULL;


BOOL
ValidateUser(
    IN OUT CHAR * pszUserName,
    IN OUT CHAR * pszPassword,
    OUT    BOOL * pfValid
    )
/*++

Routine Description:

    Looks up the username and confirms the user is allowed access to the
    server

Arguments:

    pszUserName - The username to validate, will contain the mapped username
                  on return.  Must be at least SF_MAX_USERNAME
    pszPassword - The password for this user.  Will contain the mapped
                  password on return.  Must be at least SF_MAX_PASSWORD
    pfValid     - Set to TRUE if the user should be logged on.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fFound;
    CHAR achPassword[SF_MAX_PASSWORD];
    CHAR achNTUser[SF_MAX_USERNAME];
    CHAR achNTUserPassword[SF_MAX_PASSWORD];

    //
    //  Assume we're going to fail validation
    //

    *pfValid = FALSE;

    //
    //  Lookup the user in the cache, if that fails, get the user from the
    //  database and add the retrieved user to the cache
    //

    if ( !LookupUserInCache( pszUserName,
                             &fFound,
                             achPassword,
                             achNTUser,
                             achNTUserPassword ))
    {
        return FALSE;
    }

    if ( !fFound )
    {
        if ( !LookupUserInDb( pszUserName,
                              &fFound,
                              achPassword,
                              achNTUser,
                              achNTUserPassword ))
        {
            return FALSE;
        }

        if ( fFound )
        {
            AddUserToCache( pszUserName,
                            achPassword,
                            achNTUser,
                            achNTUserPassword );
        }
    }

    if ( !fFound )
    {
        DbgWrite(( DEST,
                   "[ValidateUser] Failed to find user %s\n",
                   pszUserName ));

        return TRUE;
    }

    //
    //  Do the passwords match?
    //

    if ( !strcmp( pszPassword, achPassword ))
    {
        //
        //  We have a match, map to the NT user and password
        //

        strcpy( pszUserName, achNTUser );
        strcpy( pszPassword, achNTUserPassword );
        *pfValid = TRUE;
    }

    return TRUE;
}

BOOL
InitializeUserDatabase(
    VOID
    )
/*++

Routine Description:

    Retrieves the userlist from the file.  If the users were coming from a
    database, this routine would connect to the database.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HANDLE hFile;
    DWORD  cbFile;
    DWORD  cbRead;

    //
    //  Open and read the file.  The System account must have access to the
    //  file.
    //

    hFile = CreateFile( USER_LIST_FILE,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        DbgWrite(( DEST,
                   "[InitializeUserDatabase] Error %d openning %s\n",
                   GetLastError(),
                   USER_LIST_FILE ));

        return FALSE;
    }

    cbFile = GetFileSize( hFile, NULL );

    if ( cbFile == (DWORD) -1 )
    {
        CloseHandle( hFile );
        return FALSE;
    }

    pszUserFile = LocalAlloc( LPTR, cbFile + 1 );

    if ( !pszUserFile )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        CloseHandle( hFile );
        return FALSE;
    }

    if ( !ReadFile( hFile,
                    pszUserFile,
                    cbFile,
                    &cbRead,
                    NULL ))
    {
        CloseHandle( hFile );
        LocalFree( pszUserFile );

        return FALSE;
    }

    CloseHandle( hFile );

    //
    //  Zero terminate the file data
    //

    pszUserFile[cbRead] = '\0';

    return TRUE;
}

BOOL
LookupUserInDb(
    IN CHAR * pszUser,
    OUT BOOL * pfFound,
    OUT CHAR * pszPassword,
    OUT CHAR * pszNTUser,
    OUT CHAR * pszNTUserPassword
    )
/*++

Routine Description:

    Looks up the username in the database and returns the other attributes
    associated with this user

    The file data is not sorted to simulate the cost of an external database
    lookup.

Arguments:

    pszUserName - The username to find in the database (case insensitive)
    pfFound     - Set to TRUE if the specified user name was found in the
                  database
    pszPassword - The external password for the found user.  Buffer must be
                  at least SF_MAX_PASSWORD bytes.
    pszNTUser   - The NT username associated with this user, Buffer must be at
                  least SF_MAX_USERNAME bytes
    pszNTUserPassword - The password for NTUser. Buffer must be at least
                  SF_MAX_PASSWORD

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR * pch = pszUserFile;
    CHAR * pchEnd;
    DWORD  cchUser = strlen( pszUser );
    DWORD  cch;

    *pfFound = FALSE;

    //
    //  Find the external username.  We're expecting one user per line in
    //  the form:
    //
    //      username:password, NTUser:NTUserPassword
    //

    while ( pch && *pch )
    {
        while ( ISWHITE( *pch ) )
            pch++;

        if ( toupper( *pch ) == toupper( *pszUser ) &&
             !strnicmp( pszUser, pch, cchUser )     &&
             pch[cchUser] == ':' )
        {
            pch += cchUser + 1;
            goto Found;
        }

        pch = strchr( pch+1, '\n' );
    }

    //
    //  Not found
    //

    return TRUE;

Found:

    //
    //  Break out the external username
    //

    if ( !(pchEnd = strchr( pch, ',' )))
    {
        SetLastError( ERROR_INVALID_PASSWORDNAME );
        return FALSE;
    }

    cch = pchEnd - pch;

    if ( cch+1 > SF_MAX_PASSWORD )
    {
        SetLastError( ERROR_INVALID_PASSWORDNAME );
        return FALSE;
    }

    memcpy( pszPassword, pch, cch );
    pszPassword[cch] = '\0';

    pch = pchEnd + 1;

    //
    //  Get the NT username from the file
    //

    while ( ISWHITE( *pch ) )
        pch++;

    if ( !(pchEnd = strchr( pch, ':' )))
    {
        SetLastError( ERROR_BAD_USERNAME );
        return FALSE;
    }

    cch = pchEnd - pch;

    if ( cch+1 > SF_MAX_USERNAME )
    {
        SetLastError( ERROR_BAD_USERNAME );
        return FALSE;
    }

    memcpy( pszNTUser, pch, cch );
    pszNTUser[cch] = '\0';

    pch = pchEnd + 1;

    //
    //  Get the NT password from the file, look for a '\r' or '\n'
    //

    pchEnd = pch;

    while ( *pchEnd && *pchEnd != '\r' && *pchEnd != '\n' )
        pchEnd++;

    cch = pchEnd - pch;

    if ( cch+1 > SF_MAX_PASSWORD )
    {
        SetLastError( ERROR_INVALID_PASSWORDNAME );
        return FALSE;
    }

    memcpy( pszNTUserPassword, pch, cch );
    pszNTUserPassword[cch] = '\0';

    *pfFound = TRUE;

    return TRUE;
}

VOID
TerminateUserDatabase(
    VOID
    )
/*++

Routine Description:

    Shutsdown the user database.

--*/
{
    if ( pszUserFile )
    {
        LocalFree( pszUserFile );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

int
Filter(
    PHTTP_FILTER_CONTEXT  pfc,
	PHTTP_FILTER_RAW_DATA pRawData,
	LPCSTR                pszStart,
	UINT                  cch,
	int	                  iStart,
	LPCSTR                pszSessionID);

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\ckymunge.cpp ===
// CkyMunge: ISAPI filter for ASP session state for cookieless browsers.
// An inglorious hack that munges URLs embedded in outgoing ASP pages,
// embedding the ASPSESSIONID cookie in them.  Also useful as an example of
// an ISAPI filter that does something non-trivial with rawdata.


#include "CkyPch.h"

#include "debug.h"
#include "isapiflt.h"
#include "utils.h"
#include "notify.h"
#include "filter.h"
#include "globals.h"
#include "keyword.h"


#define MAJOR_VERSION 1
#define MINOR_VERSION 1

// the munging mode.  This will be read from the registry upon initialization
int	g_mungeMode = MungeMode_Off;

// the session ID size is either 16 or 24 chars (depends on the server version)
long g_SessionIDSize=-1;

// the "cookie extra" is the string appended after "ASPSESSIONID" and before
// "=".  It is actually the process ID (with some extra mangling)
static volatile long        g_fCookieExtraSet = 0;
static CRITICAL_SECTION     g_csCookieExtra;
CHAR                        g_szCookieExtra[ COOKIE_NAME_EXTRA_SIZE + 1 ];


static LPCTSTR szRegKey = "Software\\Microsoft\\CkyMunge";
static LPCTSTR szRegValue = "MungeMode";

void SetSessionIDSize( HTTP_FILTER_CONTEXT* );
void SetCookieExtra( LPCSTR );
bool IsValidCookieExtra( LPCSTR );

//
// Optional entry/exit point for all DLLs
//

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE /*hInstance*/,
    DWORD     dwReason,
    LPVOID    /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DEBUG_INIT();
        TRACE("%s starting up\n", EVENT_MODULE);

		// get the munge mode from the registry
		HKEY hKey;
		DWORD dwDisposition;
		if ( ::RegCreateKeyEx(
			HKEY_LOCAL_MACHINE,
			szRegKey,
			0,
			REG_NONE,
			0,
			KEY_ALL_ACCESS,
			NULL,
			&hKey,
			&dwDisposition ) != ERROR_SUCCESS )
		{
			TRACE( "Couldn't create/open key in registry\n" );
			return FALSE;
		}

		DWORD dwType;
		DWORD dwValue;
		DWORD dwBufferSize = sizeof( dwValue );

		if ( ::RegQueryValueEx(
			hKey,
			szRegValue,
			NULL,
			&dwType,
			reinterpret_cast<BYTE*>(&dwValue),
			&dwBufferSize ) != ERROR_SUCCESS )
		{
			TRACE( "No munge mode set, defaulting to smart mode\n" );
			dwValue = MungeMode_Smart;

			::RegSetValueEx(
				hKey,
				szRegValue,
				0,
				REG_DWORD,
				reinterpret_cast<BYTE*>(&dwValue),
				sizeof( DWORD ) );
		}
				
		g_mungeMode = static_cast<int>( dwValue );
        TRACE("MungeMode = %d\n", g_mungeMode);

        if (! InitUtils()  ||  ! InitKeywords())
            return FALSE;

        g_szCookieExtra[0]='\0';
        ::InitializeCriticalSection( &g_csCookieExtra );

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ::DeleteCriticalSection( &g_csCookieExtra );

        if (! TerminateUtils()  ||  ! TerminateKeywords())
            return FALSE;
        TRACE("%s shutting down\n", EVENT_MODULE);
        DEBUG_TERM();
    }

    return TRUE;    // ok
}



//
// Required initialization entrypoint for all ISAPI filters
//

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION* pVer)
{
    EventReport("", "", EVENTLOG_INFORMATION_TYPE, CMFI_LOADED); 

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    //  Specify the types and order of notification
    pVer->dwFlags = ((SF_NOTIFY_SECURE_PORT  | SF_NOTIFY_NONSECURE_PORT)
                     | SF_NOTIFY_ORDER_MEDIUM
                     | SF_NOTIFY_PREPROC_HEADERS
                     | SF_NOTIFY_URL_MAP
                     | SF_NOTIFY_SEND_RAW_DATA
                     | SF_NOTIFY_END_OF_REQUEST
                     );

    // Set the filter description
    wsprintf(pVer->lpszFilterDesc,
             "Active Server Pages ISAPI filter for munging ASPSESSIONID "
             "cookies, v%d.%02d",
             MAJOR_VERSION, MINOR_VERSION);
    TRACE("%s\n", pVer->lpszFilterDesc);

    return TRUE;
}



//
// Required dispatch entrypoint for all ISAPI filters
//

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT* pfc,
    DWORD                dwNotificationType,
    VOID*                pvData)
{
    // first verify the session ID size
    if ( g_SessionIDSize == -1 )
    {
        SetSessionIDSize( pfc );
    }

 	if ( g_mungeMode == MungeMode_Off )
	{
		// just get out as quick as possible
		return SF_STATUS_REQ_NEXT_NOTIFICATION;
	}

	CNotification* pNotify = CNotification::Get(pfc);
	if ( pNotify != NULL )
	{
		if ( pNotify->MungingOff() )
		{
			// we must've figured out that the browser is
			// accepting cookies.
			return SF_STATUS_REQ_NEXT_NOTIFICATION;
		}
	}

    switch (dwNotificationType)
    {
    case SF_NOTIFY_READ_RAW_DATA:
        return OnReadRawData(pfc,    (PHTTP_FILTER_RAW_DATA) pvData);

    case SF_NOTIFY_PREPROC_HEADERS:
        return OnPreprocHeaders(pfc, (PHTTP_FILTER_PREPROC_HEADERS) pvData);

    case SF_NOTIFY_URL_MAP:
        return OnUrlMap(pfc,         (PHTTP_FILTER_URL_MAP) pvData);

    case SF_NOTIFY_AUTHENTICATION:
        return OnAuthentication(pfc, (PHTTP_FILTER_AUTHENT) pvData);

    case SF_NOTIFY_ACCESS_DENIED:
        return OnAccessDenied(pfc,   (PHTTP_FILTER_ACCESS_DENIED) pvData);

    case SF_NOTIFY_SEND_RAW_DATA:
        return OnSendRawData(pfc,    (PHTTP_FILTER_RAW_DATA) pvData);

    case SF_NOTIFY_END_OF_REQUEST:
        return OnEndOfRequest(pfc);

    case SF_NOTIFY_LOG:
        return OnLog(pfc,            (PHTTP_FILTER_LOG) pvData);

    case SF_NOTIFY_END_OF_NET_SESSION:
        return OnEndOfNetSession(pfc);
        
    default:
        TRACE("Unknown notification: %x, context: %p, data: %p\n",
              dwNotificationType, pfc, pvData);
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
}



//
// Read raw data from the client (browser)
//

DWORD
OnReadRawData(
    PHTTP_FILTER_CONTEXT  pfc,
    PHTTP_FILTER_RAW_DATA pRawData)
{
    TRACE("OnReadRawData(%p, %p)\n", pfc, pRawData);

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// Preprocess the headers of the client's request before the server handles
// the request
//

DWORD
OnPreprocHeaders(
    PHTTP_FILTER_CONTEXT         pfc,
    PHTTP_FILTER_PREPROC_HEADERS pHeaders)
{
    TRACE("OnPreprocHeaders(%p)\n", pfc, pHeaders);

    CHAR  szUrl[1024*5];
    DWORD cbUrl = sizeof szUrl;

    // Get the URL for this request
    if (! pHeaders->GetHeader(pfc, "url", szUrl, &cbUrl))
    {
        TRACE("GetHeader(\"url\") failed\n");
        EventReport("OnPreprocHeaders", "url",
                    EVENTLOG_ERROR_TYPE, CMFE_GETHEADER);
        return SF_STATUS_REQ_ERROR;
    }

    CNotification* pNotify = NULL;
    CHAR szSessionID[ MAX_SESSION_ID_SIZE + 1 ];
    *szSessionID = '\0';

    // Does the URL contain an embedded Session ID, such as
    // /foo/bar.asp-ASP=PVZQGHUMEAYAHMFV ?

    if (DecodeURL(szUrl, szSessionID))
    {
        pNotify = CNotification::SetSessionID(pfc, szSessionID);

        // Set the URL to one without the Session ID
        if (!pHeaders->SetHeader(pfc, "url", szUrl))
        {
            TRACE("Failed to set Url header!\n", szUrl);
            EventReport("OnPreprocHeaders", szUrl,
                        EVENTLOG_ERROR_TYPE, CMFE_SETHEADER);
            return SF_STATUS_REQ_ERROR;
        }
    }


    // Look for a "Cookie:" header

    CHAR  szCookie[1024*4];
    DWORD cbCookie = sizeof szCookie;
    BOOL  fCookie = pHeaders->GetHeader(pfc, "Cookie:", szCookie, &cbCookie);

    if (fCookie  &&  cbCookie > 0)
    {
        TRACE("Cookie: %s\n", szCookie);
        // if the Cookie header includes ASPSESSIONID=<whatever>, use that
        pNotify = CNotification::SetSessionID(pfc, szCookie);

		// got a header with a cookie, so don't munge anymore
		if ( pNotify )
		{
			TRACE( "Cookies accepted: stop munging\n" );
			pNotify->m_fTestCookies = false;
		}
    }
    else if (pNotify != NULL  &&  *szSessionID != '\0')
    {
        // No cookie header, so we synthesize an ASPSESSIONID cookie header
        // from the Session ID embedded in the URL
        CHAR sz[ SZ_SESSION_ID_COOKIE_NAME_SIZE + MAX_SESSION_ID_SIZE
                + 1 + COOKIE_NAME_EXTRA_SIZE + 1];
        wsprintf(sz, "%s%s=%s", SZ_SESSION_ID_COOKIE_NAME,
                 g_szCookieExtra, szSessionID);
        TRACE("About to AddHeader(\"%s\")\n", sz);

        if (!pHeaders->AddHeader(pfc, "Cookie:", sz))
        {
            TRACE("Failed to AddHeader(\"Cookie:\", %s)\n", sz);
            EventReport("OnPreprocHeaders", szUrl,
                        EVENTLOG_ERROR_TYPE, CMFE_ADDHEADER);
            return SF_STATUS_REQ_ERROR;
        }

		// if we were testing cookies, we now know that the browser isn't
		// sending any to us, so start munging
		if ( pNotify->m_fTestCookies )
		{
			TRACE( "Cookies not accepted: continue munging\n" );
			pNotify->m_fTestCookies = false;
			pNotify->m_fEatCookies = true;
		}
    }

    // Kill the "Connection: Keep-alive" header, so that browser will
    // terminate session properly.  If it's present, the server
    // will send back a "Connection: Keep-Alive" header in response to
    // requests for .htm pages (though not for .asp pages).  The
    // browser will think that there's more data to come, when
    // there's not, and it will show an hourglass cursor and eventually
    // put up an error messagebox.

    BOOL fKeepAlive = pHeaders->SetHeader(pfc, "Connection:", "");

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// We have mapped the URL to the corresponding physical file
//

DWORD
OnUrlMap(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_URL_MAP pMapInfo)
{
    TRACE("OnUrlMap(%p, %p, %s)\n", pfc, pMapInfo, pMapInfo->pszURL);

    // Can we safely ignore this URL based on its MIME type (e.g., image/gif)?
    if (IsIgnorableUrl(pMapInfo->pszURL))
    {
        CNotification::Destroy(pfc);
        TRACE("Ignoring <%s>\n", pMapInfo->pszURL);
    }
    else
    {
        CNotification* pNotify = CNotification::Get(pfc);

        if (pNotify == NULL)
            pNotify = CNotification::Create(pfc, NULL);

        pNotify->m_nState = HN_SEEN_URL;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// Authenticating the user
//

DWORD
OnAuthentication(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_AUTHENT pAuthent)
{
    TRACE("OnAuthentication(%p, %p)\n", pfc, pAuthent);

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// Authentication failed
//

DWORD
OnAccessDenied(
    PHTTP_FILTER_CONTEXT       pfc,
    PHTTP_FILTER_ACCESS_DENIED pAccess)
{
    TRACE("OnAccessDenied(%p, %p)\n", pfc, pAccess);

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// Do the hard work of munging the data.  Note that we may be in one of
// three interesting states: HN_SEEN_URL (initially), HN_IN_HEADER (looking
// at the outgoing HTTP headers), and HN_IN_BODY (in the body of the
// response).  If the browser has cached this URL already (not the case
// with .ASP pages, but typically the case with ordinary HTML pages or
// images), no body is sent and we never move into the HN_IN_BODY state.
//
// The data will be sent in one or more packets, and we may need to buffer
// portions of those packets, as tokens may be split across two or more
// packets.  The code assumes that an individual header will not be split
// across packets.
//

DWORD
OnSendRawData(
    PHTTP_FILTER_CONTEXT  pfc,
    PHTTP_FILTER_RAW_DATA pRawData)
{
    TRACE("OnSendRawData(%p, %p)\n", pfc, pRawData);

   CNotification* pNotify = CNotification::Get(pfc);

    if (pNotify == NULL  ||  pNotify->m_nState == HN_UNDEFINED)
        return SF_STATUS_REQ_NEXT_NOTIFICATION;

	if ( pNotify->MungingOff() )
	{
		// either munging has been turned off, or we detected that
		// munging isn't necessary
		return SF_STATUS_REQ_NEXT_NOTIFICATION;
	}

    LPSTR   pszData = (LPSTR) pRawData->pvInData;
    int     iStart = 0; // offset of the beginning of the body data
    
    // first time in OnSendRawData?
    if (pNotify->m_nState == HN_SEEN_URL)
    {
        // Assume Content-Type header is in first packet
        LPCSTR pszContentType = FindHeaderValue("Content-Type:", "text/html",
                                                pRawData, 0);

        if (pszContentType == NULL)
        {
            pNotify->m_nState = HN_UNDEFINED;   // not HTML; ignore
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }
        else
        {
            pNotify->m_nState = HN_IN_HEADER;
            pNotify->m_ct = CT_TEXT_HTML;
        }
    }

    if (pNotify->m_nState == HN_IN_HEADER)
    {
        static const char szSetCookie[] = "Set-Cookie:";
        LPSTR pszCookie = FindString(szSetCookie, pRawData, 0);
        
        // multiple Set-Cookie headers may be present in the header
        while (pszCookie != NULL)
        {
            pNotify->m_nState = HN_IN_HEADER;
            
            // Header lines are supposed to be terminated by "\r\n"
            LPSTR pszEoln = strchr(pszCookie, '\r');
            
            if (pszEoln != NULL)
            {
                *pszEoln = '\0';
                TRACE("%s\n", pszCookie);
                
                // ASP only sends the ASPSESSIONID cookie if a session ID
                // hasn't already been picked, which happens either when
                // Session_OnStart is executed (if it and global.asa are
                // present) or when the Session object is first modified
                // by user code.
                LPCSTR szCookieName;
                if ( ( szCookieName =
                       strstr(pszCookie, SZ_SESSION_ID_COOKIE_NAME) ) != NULL)
                {
                    // need to figure out what's tacked onto the cookie name.
                    if ( !g_fCookieExtraSet )
                    {
                        SetCookieExtra( szCookieName );
                    }
                    
                    // we know this cookie contains ASPSESSIONID, but is it
                    // ours? (the cookie extra parts must match)
                    if ( strstr( szCookieName, g_szCookieExtra ) != NULL )
                    {
                        VERIFY(CNotification::SetSessionID(pfc, pszCookie)
                               == pNotify);
                        TRACE("Update: %s\n", pNotify->SessionID());
                        
                        *pszEoln = '\r';    // restore
                        
                        // Eat outgoing "Set-Cookie: ASPSESSIONIDXXXXXXXX=..."
                        // header?  Benign for cookie-less browsers; will keep
                        // cookie-warning browsers quiet.
                        if (pNotify->m_fEatCookies)
                        {
                            TRACE("Deleting cookie\n");
                            DeleteLine(szSetCookie, pRawData, pszCookie);
                        }
                    }
                }
                else
                {
                    *pszEoln = '\r';    // restore
                }
                
                pszCookie =
                    FindString(szSetCookie, pRawData,
                            pszEoln - static_cast<LPCSTR>(pRawData->pvInData));
            }
            else
            {
                pszCookie = NULL; // terminate loop
            }
        }

        // If a Content-Length header is present, we need to destroy it
        // because there is no way we can guess a priori how much longer
        // the data will become.  If we don't destroy it, the browser will
        // believe the header and become very confused.
        
        static const char szContentLength[] = "Content-Length:";
        LPSTR pszCL = FindString(szContentLength, pRawData, 0);

        if (pszCL != NULL)
        {
            char szFmt[ARRAYSIZE(szContentLength) + 10];
            sprintf(szFmt, "%s %%u", szContentLength);
            sscanf(pszCL, szFmt, &pNotify->m_cchContentLength);
            TRACE("%s is %u\n", szContentLength, pNotify->m_cchContentLength);
            DeleteLine(szContentLength, pRawData, pszCL);
        }

        // Is the end-of-headers marker present?
        LPCSTR pszEndHeaderBlock = FindString("\n\r\n", pRawData, 0);

        if (pszEndHeaderBlock != NULL)
        {
            pNotify->m_nState = HN_IN_BODY;
            iStart = pszEndHeaderBlock + 3 - pszData;
        }
    }

    // We're in the body.  Let's do some real work.

    if (pNotify->m_nState == HN_IN_BODY)
    {
        LPSTR pszBuf = pszData;
        int iEnd;

        // Have we got a partial line from the last packet?  If so, it
        // means that the last character in the buffer on that packet was
        // not a token boundary character, such as '\n' or '>'.  Prepend
        // that data to the current batch.
        
        if (pNotify->m_pbPartialToken != NULL)
        {
            ASSERT(iStart == 0);
            ASSERT(pNotify->m_cbPartialToken > 0);

            pNotify->AppendToken(pfc, pszBuf, pRawData->cbInData);

            pRawData->pvInData = pszBuf = (LPSTR) pNotify->m_pbPartialToken;
            pRawData->cbInData = pRawData->cbInBuffer
                = pNotify->m_cbPartialToken;
                
            iEnd = g_trie.EndOfBuffer(pRawData, iStart);

            if (iEnd < 0)
            {
                // Don't let IIS send any data on this pass
                pRawData->pvInData = NULL;
                pRawData->cbInData = pRawData->cbInBuffer = 0;

                return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
            else
            {
                // Have a complete token
                pNotify->m_pbPartialToken = pNotify->m_pbTokenBuffer = NULL;
                pNotify->m_cbPartialToken = pNotify->m_cbTokenBuffer = 0;
            }
        }

        ASSERT(pNotify->m_pbPartialToken == NULL
               &&  pNotify->m_cbPartialToken == 0);

        // Is the last token in the block incomplete?
        iEnd = g_trie.EndOfBuffer(pRawData, iStart);

        if (iEnd != pRawData->cbInData)
        {
            LPSTR pszBoln = (iEnd < 0)  ?  pszBuf + iStart  :  pszBuf + iEnd ;

            TRACE("Partial Token: ");
            pNotify->AppendToken(pfc, pszBoln,
                                 (pszBuf + pRawData->cbInData) - pszBoln);
            pRawData->cbInData -= pNotify->m_cbPartialToken;
        }

        pNotify->m_cchContentLength -= pRawData->cbInData;

        // Filter whatever is left
        const int nExtra = Filter(pfc, pRawData, pszBuf,
                                  pRawData->cbInData, iStart,
                                  pNotify->m_szSessionID);
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// The transaction is over.  Pump out any remaining data before the
// connection closes.
//

DWORD
OnEndOfRequest(
    PHTTP_FILTER_CONTEXT pfc)
{
    TRACE("OnEndOfRequest(%p)\n", pfc);

    CNotification* pNotify = CNotification::Get(pfc);

    if (pNotify != NULL  &&  pNotify->m_pbPartialToken != NULL)
    {
        // append a '\n', which is guaranteed to be a token boundary char
        pNotify->m_pbPartialToken[pNotify->m_cbPartialToken] = '\n';
#ifdef _DEBUG
        pNotify->m_pbPartialToken[pNotify->m_cbPartialToken + 1] = '\0';
#endif
        LPBYTE pbTemp = pNotify->m_pbPartialToken;
        DWORD  cb = pNotify->m_cbPartialToken + 1;

        // Note: WriteClient ends up calling OnSendRawData.  Destroy the
        // partial token before it's called.
        pNotify->m_pbPartialToken = NULL;
        pNotify->m_cbPartialToken = 0;

        if (!pfc->WriteClient(pfc, pbTemp, &cb, 0))
            TRACE("WriteClient failed, err %x.\n", GetLastError());
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// Log the details of the transaction
//

DWORD
OnLog(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_LOG     pLog)
{
    TRACE("OnLog(%p, %p)\n", pfc, pLog);

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



//
// The HTTP session (transaction) is over and the connection has been closed.
//

DWORD
OnEndOfNetSession(
    PHTTP_FILTER_CONTEXT pfc)
{
    TRACE("OnEndOfNetSession(%p)\n", pfc);

    CNotification::Destroy(pfc);

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}



void
SetSessionIDSize(
    PHTTP_FILTER_CONTEXT pfc )
{
    static const char szVersion4B2[] = "Microsoft-IIS/4.0 Beta 2";
    static const char szVersion4[]   = "Microsoft-IIS/4.0";
    const long version3Size = 16;
    const long version4Size = MAX_SESSION_ID_SIZE;
    const long version4B2Size = 16;

    long size = version3Size;

    DWORD dwBufferSize = 0;
    pfc->GetServerVariable( pfc, "SERVER_SOFTWARE", NULL, &dwBufferSize );
    if ( ::GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        LPSTR str = (LPSTR)_alloca( ++dwBufferSize );
        if (pfc->GetServerVariable(pfc, "SERVER_SOFTWARE", str, &dwBufferSize))
        {
            TRACE( "Server Software: %s\n", str );
            if ( strcmp( szVersion4B2, str ) == 0 )
            {
                TRACE( "Using version 4 beta 2 session ID size (%d bytes)\n",
                       version4B2Size );
                size = version4B2Size;
            }
            else if ( strncmp( szVersion4, str, strlen( szVersion4 ) ) == 0 )
            {
                TRACE( "Using version 4 session ID size (%d bytes)\n",
                       version4Size );
                size = version4Size;
            }
            else
            {
                TRACE( "Using version 3 session ID size (%d bytes)\n",
                       version3Size );
            }
        }
        else
        {
            TRACE( "Failed to get server variable, error: %d\n",
                   ::GetLastError() );
        }
    }
    else
    {
        TRACE( "Failed to get server variable(SERVER_SOFTWARE), error: %d\n",
               ::GetLastError() );
    }
    ::InterlockedExchange( &g_SessionIDSize, size );
}



void
SetCookieExtra(
    LPCSTR  szCookieName )
{
    ::EnterCriticalSection( &g_csCookieExtra );
    // need to check again in case the cookie extra was set
    // while we were waiting on the critical section
    if ( !g_fCookieExtraSet )
    {
        szCookieName += SZ_SESSION_ID_COOKIE_NAME_SIZE;
        if ( *szCookieName != '=' )
        {
            CHAR szExtra[ COOKIE_NAME_EXTRA_SIZE + 1 ];
            strncpy( szExtra, szCookieName, COOKIE_NAME_EXTRA_SIZE );
            szExtra[ COOKIE_NAME_EXTRA_SIZE ] = 0;

            if ( IsValidCookieExtra( szExtra ) )
            {
                // copy the cookie name extra
                strcpy( g_szCookieExtra, szExtra );
                TRACE("SetCookieExtra(%s)\n", g_szCookieExtra);
                ::InterlockedExchange( (long*)&g_fCookieExtraSet, 1 );
            }
            else
            {
                TRACE( "Cookie extra validation failed\n" );
            }
        }
    }
    ::LeaveCriticalSection( &g_csCookieExtra );
}



// Check to see if this `extra part' is a valid value for this server.
// The extra part is derived from the process ID and then randomized
// slightly.  So we can tell if the extra is reasonable based on the
// process ID.
bool
IsValidCookieExtra(
    LPCSTR  szExtra )
{
    bool rc = true;
    
    CHAR szProcessID[ COOKIE_NAME_EXTRA_SIZE + 1 ];

    // Process ID
    wsprintf(szProcessID, "%08X", GetCurrentProcessId());

    // check based on how we know the process ID is munged to the cookie extra
    static const char *pszDigitsToLetters[2] = {"GHIJKLMNOP","QRSTUVWXYZ"};

    for (int i = 0; i < COOKIE_NAME_EXTRA_SIZE; i++)
    {
        char cp = szProcessID[i];
        char ce = szExtra[i];
        if ( ( cp >= '0' ) && ( cp <= '9' ) )
        {
            int ndx = cp - '0';
            if ( ( pszDigitsToLetters[0][ndx] == ce )
                 || ( pszDigitsToLetters[1][ndx] == ce ) )
            {
                // okay, keep checking
            }
            else
            {
                // no good
                rc = false;
                i = COOKIE_NAME_EXTRA_SIZE;
            }
        }
        else
        {
            if ( cp == ce )
            {
                // okay, keep checking
            }
            else
            {
                // no good
                rc = false;
                i = COOKIE_NAME_EXTRA_SIZE;
            }
        }
    }
#ifdef _DEBUG
    if (!rc)
        TRACE("`%s' is not a valid extra\n", szExtra);
#endif
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georgere@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <tchar.h>

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define ASSERT_VALID(pObj)  \
    do {ASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
# define DUMP(pObj)  \
    do {ASSERT((pObj) != NULL); (pObj)->Dump();} while (0)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define ASSERT_VALID(pObj)      ((void)0)
# define DUMP(pObj)              ((void)0)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\ckypch.h ===
// force strict type checking
#define STRICT

// disable rarely-used sections of Windows
#define WIN32_LEAN_AND_MEAN
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NORPC
#define NOPROXYSTUB
#define NOIMAGE
#define NOTAPE

// Needed by AspAssertHandler in debug.cpp
// #define _WIN32_WINNT 0x400

#include <windows.h>
#include <httpfilt.h>

#include <crtdbg.h>
#include <tchar.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

// disable warning messages about truncating extremly long identifiers
#pragma warning (disable : 4786)
#include <string>
#include <set>
#include <map>
#include <vector>
#include <stack>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\filter.cpp ===
#include "CkyPch.h"

#include "filter.h"
#include "keyword.h"
#include "utils.h"
#include "globals.h"



//
// First pass through the data: count how many extra bytes we're going to
// need to allocate to hold the modified data, if any.
//

int
CountExtraBytes(
    LPCTSTR ptszStart,
    UINT    cch)
{
    ASSERT(ptszStart != NULL);
    
    LPCTSTR ptszEnd = ptszStart + cch;
    CStateStack ss;
    int cb = 0;
    
    for (LPCTSTR ptsz = ptszStart;  ptsz < ptszEnd; )
    {
        int cLen;
        const CToken* ptok = g_trie.Search(ptsz, &cLen, ptszEnd - ptsz);

        if (ptok == NULL)
            ++ptsz;
        else
        {
            cb += ptok->CountBytes(ss, ptsz, ptszEnd - ptsz);
            ptsz += ptok->m_str.length();
        }
    }

    return cb;
}



//
// Second pass: munge the data
//

void
DoFilter(
    LPCTSTR ptszStart,
    UINT    cch,
    LPCTSTR ptszSessionID,
    LPTSTR  ptszOutBuf)
{
    ASSERT(ptszStart != NULL  &&  cch > 0);
    ASSERT(ptszSessionID != NULL  &&  _tcslen(ptszSessionID) > 0);
    ASSERT(ptszOutBuf != NULL);
    
    LPCTSTR ptszEnd = ptszStart + cch;
    // const int cchUrl = _tcslen(ptszSessionID);
    // const int cchUrlNameValue = _tcslen(s_szUrlNameValue);
    CStateStack ss(ptszSessionID);
    
    for (LPCTSTR ptsz = ptszStart;  ptsz < ptszEnd; )
    {
        int cLen;
        const CToken* ptok = g_trie.Search(ptsz, &cLen, ptszEnd - ptsz);

        if (ptok == NULL)
        {
            // TRACE("%c", *ptsz);
            *ptszOutBuf++ = *ptsz++;
        }
        else
        {
            // DoFilter is supposed to copy itself, if appropriate,
            // and adjust ptsz and ptszOutBuf
            ptok->DoFilter(ss, ptsz, ptszEnd - ptsz, ptszOutBuf);
        }
    }
}



int
Filter(
    PHTTP_FILTER_CONTEXT  pfc,
    PHTTP_FILTER_RAW_DATA pRawData,
    LPCSTR                pszStart,
    UINT                  cch,
    int                   iStart,
    LPCSTR                pszSessionID)
{
    ASSERT(pszSessionID != NULL);

    // If empty SessionID (typically happens on plain HTML pages), nothing
    // useful can be done
    if (strlen(pszSessionID) == 0)
        return 0;

    const int nExtra = CountExtraBytes(pszStart + iStart, cch - iStart);

    if (nExtra > 0)
    {
        TRACE("Filtering `%s', found %d extra bytes\n", pszSessionID, nExtra);
        const int nNewSize = nExtra + cch;
        TRACE("FilterNew: ");
        LPSTR pchNew = (LPSTR) AllocMem(pfc, nNewSize);
        
        memcpy(pchNew, pszStart, iStart);
        DoFilter(pszStart + iStart, cch - iStart,
                 pszSessionID, pchNew + iStart);
        pRawData->pvInData = pchNew;
        pRawData->cbInData = pRawData->cbInBuffer = nNewSize;
    }

    return nExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\debug.cpp ===
#include "CkyPch.h"
#include "debug.h"


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}


#define ACTIVE_SERVER_PAGES

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\globals.h ===
#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#include "token.h"

#ifndef EXTERN
# define EXTERN extern
# define INITVAL(x)
#else
# define INITVAL(x)   = (x)
#endif

EXTERN CTokenTrie    g_trie;

#define SESSION_ID_PREFIX      "-ASP=" // "@ASP:"
#define SESSION_ID_PREFIX_SIZE 5       // 5
#define SESSION_ID_SUFFIX      ""      // ":SESS"
#define SESSION_ID_SUFFIX_SIZE 0       // 5
#define COOKIE_NAME_EXTRA_SIZE 8

#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\keyword.h ===
#ifndef __KEYWORD_H__
#define __KEYWORD_H__

BOOL
InitKeywords();

BOOL
TerminateKeywords();

#endif // __KEYWORD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\notify.h ===
#ifndef __NOTIFY_H__
#define __NOTIFY_H__


#define SZ_SESSION_ID_COOKIE_NAME      "ASPSESSIONID"
#define SZ_SESSION_ID_COOKIE_NAME_SIZE 12 // strlen(SZ_SESSION_ID_COOKIE_NAME)
#define MAX_SESSION_ID_SIZE 24

// the different types of munging available
// off		-	no munging will be done
// on		-	munging will always be done
// smart	-	the munger will "test the waters" to see if cookies are getting through for each session.
//				If they are, the munger will not be effectively off for this session.  Otherwise, cookies
//				will be munged as usual.
typedef enum
{
	MungeMode_Off=0,
	MungeMode_On,
	MungeMode_Smart
} MungeModeT;

// the munging mode.  This will be read from the registry upon initialization
extern int	g_mungeMode;

// the session ID size is either 16 or 24 characters (depending on the server version)
extern long g_SessionIDSize;

extern CHAR g_szCookieExtra[];

// states for OnSendRawData

enum HN_STATE {
    HN_UNDEFINED = 0,
    HN_SEEN_URL,
    HN_IN_HEADER,
    HN_IN_BODY,
};


enum CONTENT_TYPE {
    CT_UNDEFINED = 0,
    CT_TEXT_HTML,
};

class CNotification
{
public:
    enum {SPARE_BYTES = 2};
    		
    static
    CNotification*
    Create(
        PHTTP_FILTER_CONTEXT pfc,
        LPCSTR               pszCookie);
        
    static
    void
    Destroy(
        PHTTP_FILTER_CONTEXT pfc);

    static
    CNotification*
    Get(
        PHTTP_FILTER_CONTEXT pfc)
    {return static_cast<CNotification*>(pfc->pFilterContext);}

    static
    CNotification*
    SetSessionID(
        PHTTP_FILTER_CONTEXT pfc,
        LPCSTR               pszCookie);
    
    LPCSTR
    SessionID() const
    {return m_szSessionID;}

    HN_STATE
    State() const
    {return m_nState;}

    void
    AppendToken(
        PHTTP_FILTER_CONTEXT pfc,
        LPCSTR               pszNewData,
        int                  cchNewData);

	bool MungingOff() const
	{return ( !m_fEatCookies ) && ( !m_fTestCookies );}

protected:
    CNotification(
        LPCSTR pszCookie);

    ~CNotification();
    
public:
    HN_STATE     m_nState;
    CONTENT_TYPE m_ct;
    CHAR         m_szSessionID[ MAX_SESSION_ID_SIZE ];
    LPSTR        m_pszUrl;
    LPBYTE       m_pbPartialToken;
    int          m_cbPartialToken;
    LPBYTE       m_pbTokenBuffer;
    int          m_cbTokenBuffer;
    DWORD        m_cchContentLength;
    bool         m_fEatCookies;
	bool         m_fTestCookies;
};

#endif // __NOTIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\isapiflt.h ===
#ifndef __ISAPIFLT_H__
#define __ISAPIFLT_H__

#include <httpfilt.h>

#ifdef __cplusplus
extern "C" {
#endif


// This notification was added in IIS 3.0

#ifndef SF_NOTIFY_END_OF_REQUEST
# define SF_NOTIFY_END_OF_REQUEST            0x00000080
#endif


///////////////////////////////////////////////////////////////////////
// ISAPI Filter Notification handlers

DWORD
OnReadRawData(
    PHTTP_FILTER_CONTEXT  pfc,
    PHTTP_FILTER_RAW_DATA pRawData);

DWORD
OnPreprocHeaders(
    PHTTP_FILTER_CONTEXT         pfc,
    PHTTP_FILTER_PREPROC_HEADERS pHeaders);

DWORD
OnUrlMap(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_URL_MAP pMapInfo);

DWORD
OnAuthentication(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_AUTHENT pAuthent);

DWORD
OnAccessDenied(
    PHTTP_FILTER_CONTEXT       pfc,
    PHTTP_FILTER_ACCESS_DENIED pAccess);

DWORD
OnSendRawData(
    PHTTP_FILTER_CONTEXT  pfc,
    PHTTP_FILTER_RAW_DATA pRawData);

DWORD
OnEndOfRequest(
    PHTTP_FILTER_CONTEXT pfc);

DWORD
OnLog(
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_LOG     pLog);

DWORD
OnEndOfNetSession(
    PHTTP_FILTER_CONTEXT pfc);


#ifdef __cplusplus
}
#endif

#endif // __ISAPIFLT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by version.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\state.h ===
#ifndef __STATE_H__
#define __STATE_H__

#include <vector>
#include <stack>

#include "Notify.h"
#include "debug.h"

// Needed for STL on Visual C++ 5.0
#if _MSC_VER>=1100
using namespace std;
#endif


enum PARSESTATE {
	INVALID = -1,
	TEXT = 1,
	COMMENT,  // <!-- ... -->
	COMMENT2, // <comment> ... </comment>
	ANCHOR,
	AREA,
	HREF,
};



class CStateStack : public stack< PARSESTATE, vector<PARSESTATE> >
{
public:
	CStateStack()
        : m_fInTag(FALSE),
          m_fInComment(FALSE),
          m_fInComment2(FALSE)
    {
        *m_szSessionID = '\0';
        push(TEXT);
    }

	CStateStack(
        LPCTSTR ptszSessionID)
        : m_fInTag(FALSE),
          m_fInComment(FALSE),
          m_fInComment2(FALSE)
    {
        strcpy(m_szSessionID, ptszSessionID);
        push(TEXT);
    }

    ~CStateStack()
    {
    }

    BOOL    m_fInTag;
    BOOL    m_fInComment;
    BOOL    m_fInComment2;
    CHAR    m_szSessionID[ MAX_SESSION_ID_SIZE ];
};

#endif // __STATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\keyword.cpp ===
#include "CkyPch.h"

#include "keyword.h"
#include "filter.h"
#include "utils.h"

#undef EXTERN
#define EXTERN
#include "globals.h"


// Build table of keywords

typedef struct {
    LPCTSTR          ptszKwd;
    CToken::BOUNDARY bndPrefix;
    CToken::BOUNDARY bndSuffix;
} SKeywordData;


#define KEYWORD(KWD, tszKwd, bndStart, bndEnd, DoFilterDecl)        \
                                                      \
    class CKwd##KWD : public CToken                   \
    {                                                 \
    public:                                           \
        CKwd##KWD(                                    \
            LPCTSTR ptsz,                             \
            BOUNDARY bndPrefix,                       \
            BOUNDARY bndSuffix)                       \
            : CToken(ptsz, bndPrefix, bndSuffix)      \
        {}                                            \
                                                      \
        virtual UINT                                  \
        CountBytes(                                   \
            CStateStack& rss,                         \
            LPCTSTR      ptszData,                    \
            UINT         cchData) const;              \
                                                      \
        DoFilterDecl                                  \
    };                                                \
                                                      \
    static const SKeywordData kd##KWD =               \
        {tszKwd, CToken::bndStart, CToken::bndEnd};


#define DO_FILTER_DECL                                \
        virtual UINT                                  \
        DoFilter(                                     \
            CStateStack& rss,                         \
            LPCTSTR&     rptszData,                   \
            UINT         cchData,                     \
            LPTSTR&      rptszOutBuf) const;          \

#define NO_DO_FILTER_DECL /*none*/


KEYWORD(StartTag, _T("<"),          IRRELEVANT, IRRELEVANT, NO_DO_FILTER_DECL);
KEYWORD(Anchor,   _T("<a"),         IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL);
KEYWORD(Area,     _T("<area"),      IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL);
KEYWORD(EndTag,   _T(">"),          IRRELEVANT, IRRELEVANT, NO_DO_FILTER_DECL);
KEYWORD(HRef,     _T("href="),      WHITESPACE, IRRELEVANT, DO_FILTER_DECL);
KEYWORD(BegCmnt,  _T("<--!"),       IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL);
KEYWORD(EndCmnt,  _T("-->"),        WHITESPACE, IRRELEVANT, NO_DO_FILTER_DECL);
KEYWORD(BegCmnt2, _T("<comment>"),  IRRELEVANT, WHITESPACE, NO_DO_FILTER_DECL);
KEYWORD(EndCmnt2, _T("</comment>"), WHITESPACE, IRRELEVANT, NO_DO_FILTER_DECL);



#define KEYWORD_INIT(KWD)                             \
    g_trie.AddToken(new CKwd##KWD(kd##KWD.ptszKwd,    \
                                  kd##KWD.bndPrefix,  \
                                  kd##KWD.bndSuffix))


BOOL
InitKeywords()
{
    KEYWORD_INIT(StartTag);
    KEYWORD_INIT(Anchor);
    KEYWORD_INIT(Area);
    KEYWORD_INIT(EndTag);
    KEYWORD_INIT(HRef);
    KEYWORD_INIT(BegCmnt);
    KEYWORD_INIT(EndCmnt);
    KEYWORD_INIT(BegCmnt2);
    KEYWORD_INIT(EndCmnt2);

    DUMP(&g_trie);

    return TRUE;
}



BOOL
TerminateKeywords()
{
    g_trie.Flush();
    return TRUE;
}



//----------------------------------------------------------------
// "<" starting a tag

UINT
CKwdStartTag::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    rss.m_fInTag = TRUE;
    return 0;
}



//----------------------------------------------------------------
// "<a"

UINT
CKwdAnchor::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    if (!rss.m_fInComment)
        rss.push(ANCHOR);

    return 0;
}



//----------------------------------------------------------------
// "<area" (occurs inside <map> ... </map>)

UINT
CKwdArea::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    if (!rss.m_fInComment)
        rss.push(AREA);

    return 0;
}



//----------------------------------------------------------------
// ">" closing "<a [href=...] ...>" or "<area [href=...] ...>"

UINT
CKwdEndTag::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    if (!rss.m_fInComment  && !rss.m_fInComment2)
    {
        PARSESTATE ps = rss.top();
        
        if (ps == HREF)
        {
            ps = rss.top();
            rss.pop();
        }
        
        if (ps == ANCHOR  ||  ps == AREA)
        {
            ps = rss.top();
            rss.pop();
        }
    }

    rss.m_fInTag = FALSE;
    return 0;
}



//----------------------------------------------------------------
// "href="

UINT
CKwdHRef::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    PARSESTATE ps = rss.top();

    if (!rss.m_fInComment  && !rss.m_fInComment2)
        if (ps == ANCHOR  ||  ps == AREA)
            rss.push(HREF);

    const TCHAR* const ptszEnd = ptszData + cchData;
    
    ptszData += m_str.length();

    const TCHAR tchDelim = *ptszData;

    if (tchDelim == _T('"'))
        ++ptszData;
    
    int cLen;
    const URLTYPE ut = UrlType(ptszData, ptszEnd, cLen);
    
    if (ut != UT_HTTP  &&  ut != UT_HTTPS  &&  ut != UT_NONE)
        return 0;
    else
        ptszData += cLen;

    // Is it an absolute URL?  E.g., http://server/foo/...
    // Don't want to mangle URLs that belong to some other
    // server, as it won't know what to do with them
    if (ptszData[0] == '/'  &&  ptszData[1] == '/')
        return 0;

    // Is it a server-relative absolute URL?  E.g., http:/foo/...
    // Session IDs are scoped by application (virtual root) in ASP 1.0
    if (ptszData[0] == '/')
        return 0;

    TRACE("href = %x\n", 
          (SESSION_ID_PREFIX_SIZE
           + g_SessionIDSize
           + SESSION_ID_SUFFIX_SIZE));

    return (SESSION_ID_PREFIX_SIZE
            + g_SessionIDSize
            + SESSION_ID_SUFFIX_SIZE);
}



UINT
CKwdHRef::DoFilter(
    CStateStack& rss,
    LPCTSTR&     rptszData,
    UINT         cchData,
    LPTSTR&      rptszOutBuf) const
{
    UINT cb = CountBytes(rss, rptszData, cchData);

    if (cb != 0)
    {
        const TCHAR* const ptszEnd = rptszData + cchData;
        
        LPCTSTR ptsz = rptszData + m_str.length();
        
        const TCHAR tchDelim = *ptsz;
        
        if (tchDelim == _T('"'))
            ++ptsz;
        
        int cLen;
        const URLTYPE ut = UrlType(ptsz, ptszEnd, cLen);
        
        if (ut != UT_HTTP  &&  ut != UT_HTTPS  &&  ut != UT_NONE)
        {
            ASSERT(FALSE);
            return 0;
        }
        else
            ptsz += cLen;
        
        // Is it an absolute URL?  E.g., http://server/foo/...
        if (ptsz[0] == '/'  &&  ptsz[1] == '/')
        {
            ASSERT(FALSE);
            return 0;
        }
        
        while (*ptsz != _T('?')
               && *ptsz != _T(' ')
               && *ptsz != _T('>')
               && *ptsz != _T('"'))
        {
            // TRACE("%c", *ptsz);
            ++ptsz;
        }

        memcpy(rptszOutBuf, rptszData, ptsz - rptszData);
        rptszOutBuf += ptsz - rptszData;

        strcpy(rptszOutBuf, SESSION_ID_PREFIX);
        rptszOutBuf += SESSION_ID_PREFIX_SIZE;

        strcpy(rptszOutBuf, rss.m_szSessionID);
        rptszOutBuf += g_SessionIDSize;

        strcpy(rptszOutBuf, SESSION_ID_SUFFIX);
        rptszOutBuf += SESSION_ID_SUFFIX_SIZE;

        // TRACE("%s%s%s",
        //       SESSION_ID_PREFIX, rss.m_szSessionID, SESSION_ID_SUFFIX);

        rptszData = ptsz;
    }
    else
    {
        // we must skip over the keyword
       rptszData += m_str.length();
       memcpy( rptszOutBuf, m_str.c_str(), m_str.length() );
       rptszOutBuf += m_str.length();
    }

    return 0;   // we have taken care of updating rptszOutBuf
}



//----------------------------------------------------------------
// "<--! "

UINT
CKwdBegCmnt::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    rss.push(COMMENT);
    rss.m_fInComment = TRUE;

    return 0;
}



//----------------------------------------------------------------
// " -->"

UINT
CKwdEndCmnt::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    PARSESTATE ps = rss.top();

    if (ps == COMMENT)
    {
        ASSERT(rss.m_fInComment);
        ps = rss.top();
        rss.pop();
    }
    else if (rss.m_fInComment)
    {
        do
        {
            ps = rss.top();
            rss.pop();
        } while (ps != COMMENT  &&  ps != INVALID);
    }

    rss.m_fInComment = FALSE;

    return 0;
}




//----------------------------------------------------------------
// "<comment": an IE- and Mosaic-specific tag

UINT
CKwdBegCmnt2::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    rss.push(COMMENT2);
    rss.m_fInComment2 = TRUE;

    return 0;
}



//----------------------------------------------------------------
// " </comment"

UINT
CKwdEndCmnt2::CountBytes(
    CStateStack& rss,
    LPCTSTR      ptszData,
    UINT         cchData) const
{
    PARSESTATE ps = rss.top();

    if (ps == COMMENT2)
    {
        ASSERT(rss.m_fInComment2);
        ps = rss.top();
        rss.pop();
    }
    else if (rss.m_fInComment2)
    {
        do
        {
            ps = rss.top();
            rss.pop();
        } while (ps != COMMENT2  &&  ps != INVALID);
    }

    rss.m_fInComment2 = FALSE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\notify.cpp ===
#include "CkyPch.h"
#include "debug.h"
#include "utils.h"
#include "notify.h"


//
// ctor
//

CNotification::CNotification(
    LPCSTR pszCookie)
    : m_nState(HN_UNDEFINED),
      m_ct(CT_UNDEFINED),
      m_pszUrl(NULL),
      m_pbPartialToken(NULL),
      m_cbPartialToken(0),
      m_pbTokenBuffer(NULL),
      m_cbTokenBuffer(0),
      m_cchContentLength(UINT_MAX), // not specified for .ASPs
	  m_fTestCookies(false)
{
	// set the eat cookies and test cookies based on the munge mode.
	// Here's how the flags will affect output of this session

	// if EatCookies is true, cookies will be stripped and URLs will
	// be munged with the cookie
	// if TestCookies is true URLs will be munged
	switch ( g_mungeMode )
	{
		case MungeMode_Off:
		{
			m_fEatCookies = false;
		} break;

		case MungeMode_On:
		{
			m_fEatCookies = true;
		} break;

		// always default to smart
		default:
		{
			m_fEatCookies = false;
			m_fTestCookies = true;
		} break;
	}

    *m_szSessionID = '\0';

    if (pszCookie != NULL)
    {
        if (!Cookie2SessionID(pszCookie, m_szSessionID))
        {
            TRACE("CNotification(%s): ", pszCookie);
            CopySessionID(pszCookie, m_szSessionID);
        }
    }

    TRACE("CNotification(%s)\n", (*m_szSessionID ? m_szSessionID : "<none>"));
}



//
// dtor
//

CNotification::~CNotification()
{
    TRACE("~CNotification(%s)\n", m_szSessionID);
}



//
// Create a CNotification for a Filter Context
//

CNotification*
CNotification::Create(
    PHTTP_FILTER_CONTEXT pfc,
    LPCSTR               pszCookie)
{
    ASSERT(pfc->pFilterContext == NULL);
    
    TRACE("Notify: ");

    // placement new, using ISAPI's fast allocator
    LPBYTE pbNotify =
        static_cast<LPBYTE>(AllocMem(pfc, sizeof(CNotification)));
    CNotification* pNotify = new (pbNotify) CNotification(pszCookie);

    pfc->pFilterContext = static_cast<PVOID>(pNotify);

    return pNotify;
}



//
// Cleanup
//

void
CNotification::Destroy(
    PHTTP_FILTER_CONTEXT pfc)
{
    CNotification* pNotify = Get(pfc);

    if (pNotify != NULL)
        pNotify->~CNotification(); // placement destruction

    pfc->pFilterContext = NULL;
}



//
// Set the filter context's session ID, creating a CNotification if necessary
//

CNotification*
CNotification::SetSessionID(
    PHTTP_FILTER_CONTEXT pfc,
    LPCSTR               pszCookie)
{
    CNotification* pNotify = Get(pfc);

    if (pNotify != NULL)
    {
        if (!Cookie2SessionID(pszCookie, pNotify->m_szSessionID))
        {
            TRACE("SetSessionID(%s): ", pszCookie);
            CopySessionID(pszCookie, pNotify->m_szSessionID);
        }
    }
    else
        pNotify = Create(pfc, pszCookie);

    return pNotify;
}



//
// Sometimes the data in OnSendRawData ends in a partial token.  We need
// to buffer that partial token for the next call to OnSendRawData.  In
// some cases, it may take several successive calls to OnSendRawData to
// accumulate a complete token.  This routine builds the partial token,
// taking care of memory (re)allocation.  There's always SPARE_BYTES bytes
// unused at the end that callers (esp. OnEndOfRequest) can write into.
//

void
CNotification::AppendToken(
    PHTTP_FILTER_CONTEXT pfc,
    LPCSTR               pszNewData,
    int                  cchNewData)
{
    ASSERT(pszNewData != NULL  &&  cchNewData > 0);

    // if there's room, append new data to the currently allocated buffer
    if (m_cbPartialToken + cchNewData <= m_cbTokenBuffer - SPARE_BYTES)
    {
        m_pbPartialToken = m_pbTokenBuffer;
        memcpy(m_pbPartialToken + m_cbPartialToken, pszNewData, cchNewData);
        m_cbPartialToken += cchNewData;
#ifdef _DEBUG
        m_pbPartialToken[m_cbPartialToken] = '\0';
#endif
        return;
    }
    
    // We want to allocate some extra space so that we have room to
    // grow for a while before needing to allocate more space.  If we
    // allocated only exactly enough, we'd see O(n^2) memory usage in
    // degenerate cases because AllocMem doesn't return memory to its
    // pool until the transaction is over.
    DWORD cb2 = max(1024, 2 * (cchNewData + m_cbTokenBuffer) + SPARE_BYTES);

    if (cb2 > 10000)
        cb2 = 3 * (cchNewData + m_cbTokenBuffer) / 2 + SPARE_BYTES;

    m_cbTokenBuffer = cb2;
    LPBYTE pb  = (LPBYTE) AllocMem(pfc, m_cbTokenBuffer);
    LPBYTE pb2 = pb;

    // Already have a partial token buffer?  Copy contents, if so.
    if (m_cbPartialToken > 0)
    {
        ASSERT(m_pbPartialToken != NULL
               &&  m_pbPartialToken == m_pbTokenBuffer);
        memcpy(pb, m_pbPartialToken, m_cbPartialToken);
        pb2 += m_cbPartialToken;
    }
    else
        ASSERT(m_pbPartialToken == NULL);

    memcpy(pb2, pszNewData, cchNewData);
    m_pbPartialToken = m_pbTokenBuffer = pb;
    m_cbPartialToken += cchNewData;

#ifdef _DEBUG
    m_pbPartialToken[m_cbPartialToken] = '\0';
#endif

    ASSERT(m_cbPartialToken <= m_cbTokenBuffer - SPARE_BYTES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\token.h ===
#ifndef __TOKEN_H__
#define __TOKEN_H__

#include <string>
#include <tchar.h>

#include "state.h"
#include "trie.h"


//+---------------------------------------------------------------------
// CToken:

class CToken
{
public:
    enum BOUNDARY {
        IRRELEVANT = 1,
        WHITESPACE,
        ALPHA,
        NUMERIC,
        ALPHANUMERIC,
        NEWLINE,
    };

    CToken(
        const string&  rstr,
        const BOUNDARY bndPrefix = IRRELEVANT,
        const BOUNDARY bndSuffix = IRRELEVANT);

    static BOOL
    MatchesBoundaryClass(
        const TCHAR    tch,
        const BOUNDARY bnd);

    BOOL
    MatchesPrefixBoundary(
        const TCHAR tch) const
    {return MatchesBoundaryClass(tch, m_bndPrefix);}

    BOOL
    MatchesSuffixBoundary(
        const TCHAR tch) const
    {return MatchesBoundaryClass(tch, m_bndSuffix);}

    virtual UINT
    CountBytes(
        CStateStack& rss,
        LPCTSTR      ptszData,
        UINT         cchData) const = 0;

    virtual UINT
    DoFilter(
        CStateStack& rss,
        LPCTSTR&     rptszData,
        UINT	     cchData,
        LPTSTR&      rptszOutBuf) const;

    const string    m_str;
    const BOUNDARY  m_bndPrefix;
    const BOUNDARY  m_bndSuffix;
    
// Implementation
public:
#ifdef _DEBUG
    virtual void
    AssertValid() const;

    virtual void
    Dump() const;
#endif

    virtual
    ~CToken();
};



//+---------------------------------------------------------------------
// CTokenTrie:

class CTokenTrie : public CTrie<CToken, true, true>
{
public:
    CTokenTrie();
    
    bool
    AddToken(
        const CToken* ptok);
    
    int
    EndOfBuffer(
        PHTTP_FILTER_RAW_DATA pRawData,
        int iStart);
    
private:
    // bit array for last letter of all tokens
    BYTE  m_afLastChar[(CHAR_MAX - CHAR_MIN + 1 + 7) / 8];

    bool
    _LastCharPresent(
        CHAR ch) const;

    void
    _SetLastCharPresent(
        CHAR ch,
        bool f);
};

#endif // __TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\trie.h ===
// A trie is a multiway search tree (aka a radix tree).  See a good
// algorithms text, like Knuth or Sedgewick, for a complete description.
//
// Briefly, given a list of strings such as
//      cab, car, carts, cats, dog, doge, dogs
// you get a trie that looks like this:
//
//                /-[b]
//               /
//        <c>--<a>--[r]--<t>--[s]
//       /       \
//      /         \-<t>--[s]
//     *             
//      \              /-[e]
//       \            /
//        <d>--<o>--[g]
//                    \
//                     \-[s]
//
// where `[r]' denotes the end of a word and `<a>', the middle.
//
// A trie has several useful properties:
//  * fast
//  * easily handles longest substring matches
//  * fairly compact, especially when there are many overlapping strings
//
// The multiway tree is implemented as a binary tree with child and sibling
// pointers.
//
// The CTrie template takes three parameters:
//      class _TOKEN:        up to you
//      bool  fIgnoreCase:   case-sensitivity for searches
//      bool  fDeleteTokens: delete _TOKEN* when Flush() called?
// and it exposes three methods:
//      bool AddToken(ptszToken, _TOKEN*)
//      _TOKEN* Search(ptszSearch, pctchMatched = NULL, nMaxLen = 0)
//      void Flush()
//
// Use them like this:
//      CTrie<CToken, true, true> trie;
//      CToken* ptokHello = new CToken(...);
//
//      VERIFY(trie.AddToken(_T("Hello"), ptokHello));
//
//      CToken* ptok = trie.Search(_T("Goodbye"));
//      if (ptok != NULL) {...}
//
//      if (fIniFileChanged)
//      {
//          trie.Flush();   // will delete all tokens
//          AddTokensFromIniFile(trie);
//      }
//
// Note: If you use DUMP(&trie) or ASSERT_VALID(&trie), your _TOKEN class must
// have Dump() or AssertValid() methods, respectively, in its _DEBUG version.
//
//
// TODO:
//  * template really ought to be parameterized on ANSI/Unicode too
//  * STLify it: add iterators, turn it into a container, etc
//  * remove Win32 dependencies (TCHAR)
//  * add operator= and copy ctor
//
//
// George V. Reilly  <gvr@halcyon.com>  Oct 1995  Initial implementation
// George V. Reilly  <gvr@halcyon.com>  Sep 1996  Add CharPresent for ANSI
// George V. Reilly  <gvr@halcyon.com>  Mar 1997  Templatized; removed MFC


#ifndef __TRIE_H__
#define __TRIE_H__

#include <tchar.h>
#include <limits.h>
#include <malloc.h>

#include "debug.h"

// Workaround for bool being a "reserved extension" in Visual C++ 4.x
#if _MSC_VER<1100
# ifndef bool
#  define bool  BOOL
# endif
# ifndef true
#  define true  TRUE
# endif
# ifndef false
#  define false FALSE
# endif
#endif


// forward declaration
template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens> class CTrie;


//+---------------------------------------------------------------------
//  Class:      CTrieNode (tn)
//      one node for each letter

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrieNode
{
    friend class CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>;
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrieNode();

    CTrieNode(
        _Node*        pParent,
        const _TOKEN* ptok,
        const TCHAR   tch,
        LPCTSTR       ptszToken);

    bool
    SetData(
        const _TOKEN* ptok,
        LPCTSTR       ptszToken);

    ~CTrieNode();

protected:
    const _Node*  m_pParent;
    _Node*        m_pSibling;
    _Node*        m_pChild;
    const _TOKEN* m_ptok;
#ifdef _DEBUG
    LPTSTR        m_ptszToken;
#endif
    const TCHAR   m_tch;
    TCHAR         m_tchMaxChild;    // Maximum m_tch of child nodes (1 level)

// Diagnostics
public:
#ifdef _DEBUG
    void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    bool
    CheckNodeToken() const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrieNode(const CTrieNode&);
    CTrieNode& operator=(const CTrieNode&);
};



//+---------------------------------------------------------------------
//  Class:      CTrie (trie)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrie
{
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrie();

    virtual
    ~CTrie();

    virtual bool
    AddToken(
        LPCTSTR             ptszToken,
        const _TOKEN* const ptok);

    virtual const _TOKEN*
    Search(
        LPCTSTR   ptszSearch,
        int*      pctchMatched = NULL,
        const int nMaxLen = 0) const;

    virtual void
    Flush();

protected:
    _Node  m_tnRoot;
    TCHAR  m_tchMinChild;
    TCHAR  m_tchMaxChild;

    void
    _DeleteTrie(
        _Node* ptn);

#ifndef _UNICODE
    // bit array for first letter of all tokens
    BYTE  m_afCharPresent[(CHAR_MAX - CHAR_MIN + 1 + 7) / 8];

    bool
    _CharPresent(
        CHAR ch) const;

    void
    _SetCharPresent(
        CHAR ch,
        bool f);
#endif // !UNICODE


// Diagnostics
public:
#ifdef _DEBUG
    virtual void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    int   m_ctchMaxTokenLen;    // length of longest token string

    void
    _AssertWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel) const;

    void
    _DumpWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel,
        int&   rcNodes,
        int&   rcTokens) const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrie(const CTrie&);
    CTrie& operator=(const CTrie&);
};



#ifdef _UNICODE
# define TCHAR_MIN L'\0'
#else // !UNICODE
# define TCHAR_MIN CHAR_MIN
#endif // !UNICODE



//-----------------------------------------------------------------------------
// CTrieNode implementation

// CTrieNode::CTrieNode
//      default ctor (needed for CTrie::m_tnRoot)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode()
    : m_pParent(NULL),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(NULL),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(TCHAR_MIN),
      m_tchMaxChild(TCHAR_MIN)
{
}



// CTrieNode::CTrieNode
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode(
    _Node*        pParent,
    const _TOKEN* ptok,
    const TCHAR   tch,
    LPCTSTR       ptszToken)
    : m_pParent(pParent),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(ptok),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(tch),
      m_tchMaxChild(TCHAR_MIN)
{
    ASSERT(m_pParent != NULL);
    ASSERT(m_tch > TCHAR_MIN);
    
    _Node* ptnPrev = NULL;
    _Node* ptn = m_pParent->m_pChild;
        
    // find where in the list of pParent's children to insert `this'
    while (ptn != NULL  &&  ptn->m_tch < m_tch)
    {
        ptnPrev = ptn;
        ptn = ptn->m_pSibling;
    }
    
    ASSERT(ptn == NULL  ||  ptn->m_tch != m_tch);
    
    if (ptnPrev == NULL)
    {
        ASSERT(pParent->m_pChild == ptn);
        pParent->m_pChild = this;
    }
    else
        ptnPrev->m_pSibling = this;

    this->m_pSibling = ptn;

    if (pParent->m_tchMaxChild < m_tch)
        pParent->m_tchMaxChild = m_tch;

#ifdef _DEBUG
    if (ptszToken != NULL)
    {
        ASSERT(m_ptok != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
    }
#endif
}


    
// CTrieNode::SetData
//      sets the data if it's NULL.  Needed if you do
//      AddToken("foobar", &tokFoobar) and then AddToken("foo", &tokFoo)
//      to set the data for tokFoo.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::SetData(
    const _TOKEN* ptok,
    LPCTSTR       ptszToken)
{
    // Don't set data if ptok is NULL
    if (ptok == NULL)
        return false;
    
    // overwrite m_ptok only if it is NULL
    if (m_ptok == NULL)
    {
        m_ptok = ptok;
#ifdef _DEBUG
        ASSERT(m_ptszToken == NULL);
        ASSERT(ptszToken != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
#endif
    }

    return true;
}



// CTrieNode::~CTrieNode
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrieNode()
{
#ifdef _DEBUG
    delete [] m_ptszToken;
#endif

    // Is this an auto-delete trie, i.e., do we take care of deleting
    // the _TOKENs?
    if (fDeleteTokens)
    {
        // cast away constness so that delete will work
        delete const_cast<_TOKEN*> (m_ptok);
    }

    ASSERT(m_pChild == NULL);
}


    
//-----------------------------------------------------------------------------
// CTrieNode diagnostics

#ifdef _DEBUG

// CTrieNode::CheckNodeToken
//      Do the real work of validating a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CheckNodeToken() const
{
    // If there's no m_ptok, it's automatically valid
    if (m_ptok == NULL)
        return true;

    ASSERT(m_ptszToken != NULL);
    const int cLen = _tcslen(m_ptszToken);
    const _Node* ptn = this;

    ASSERT((m_pChild == NULL  &&  m_tchMaxChild == TCHAR_MIN)
           ||  (m_pChild != NULL  &&  m_tchMaxChild > TCHAR_MIN));

    // Walk back up towards CTrie::m_tnRoot
    for (int i = cLen;  --i >= 0;  )
    {
        ASSERT(ptn != NULL);
        ASSERT(ptn->m_tch != TCHAR_MIN);

        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(this->m_ptszToken[i])
                           : this->m_ptszToken[i]);

        if (ptn->m_tch != tch)
            ASSERT(false);

        ASSERT(ptn->m_pParent != NULL  &&  ptn->m_pParent->m_pChild != NULL);

        const _Node* ptn2;

        // check to see if ptn really is a child of its parent
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2 != ptn  &&  ptn2 != NULL;
             ptn2 = ptn2->m_pSibling)
        {}
        ASSERT(ptn2 == ptn);

        // check that ptn->m_pParent->m_tchMaxChild is correct
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2->m_pSibling != NULL;
             ptn2 = ptn2->m_pSibling)
        {
            ASSERT(ptn2->m_tch > TCHAR_MIN
                   &&  ptn2->m_tch < ptn2->m_pSibling->m_tch);
        }
        ASSERT(ptn->m_pParent->m_tchMaxChild == ptn2->m_tch);

        ptn = ptn->m_pParent;
        ASSERT(ptn->m_ptok != this->m_ptok);
    }

    // check to see if ptn == CTrie::m_tnRoot
    ASSERT(ptn->m_pParent == NULL  &&  ptn->m_pSibling == NULL
           &&  ptn->m_tch == TCHAR_MIN  &&  ptn->m_ptok == NULL);

    return true;
}



// CTrieNode::AssertValid
//      Validate a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    ASSERT(CheckNodeToken());
}



// CTrieNode::Dump
//      Dump a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    // TODO: flesh out
}

#endif // _DEBUG



//-----------------------------------------------------------------------------
// CTrie implementation

// CTrie::CTrie
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrie()
{
    Flush();
}



// CTrie::~CTrie
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrie()
{
    Flush();
}



#ifndef _UNICODE

// CTrie::_CharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_CharPresent(
    CHAR ch) const
{
    ASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char'

    return m_afCharPresent[i >> 3] & (1 << (i & 7))  ?  true  :  false;
}



// CTrie::_SetCharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_SetCharPresent(
    CHAR ch,
    bool f)
{
    ASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;

    if (f)
        m_afCharPresent[i >> 3] |=  (1 << (i & 7));
    else
        m_afCharPresent[i >> 3] &= ~(1 << (i & 7));
}

#endif // !UNICODE



// CTrie::AddToken
//      Add search string `ptszToken' to trie, which will return `ptok'
//      if searched for in Search().

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AddToken(
    LPCTSTR             ptszToken,
    const _TOKEN* const ptok)
{
    if (ptok == NULL  ||  ptszToken == NULL  ||  *ptszToken == _T('\0'))
    {
        ASSERT(false);
        return false;
    }

    const int cLen = _tcslen(ptszToken);
    _Node* ptnParent = &m_tnRoot;
    
    for (int i = 0;  i < cLen;  ++i)
    {
        ASSERT(ptnParent != NULL);
        
        _Node* ptn = ptnParent->m_pChild;
        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(ptszToken[i])
                           : ptszToken[i]);
        const _TOKEN* ptok2 = (i == cLen - 1)  ?  ptok       :  NULL;
        LPCTSTR ptsz2 =       (i == cLen - 1)  ?  ptszToken  :  NULL;

        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;
            
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            ptnParent = new _Node(ptnParent, ptok2, tch, ptsz2);
        }
        else
        {
            ASSERT(ptn->m_tch == tch);
            
            ptn->SetData(ptok2, ptsz2);
            ptnParent = ptn;
        }

        ASSERT(ptnParent->CheckNodeToken());
    }

    m_tchMinChild = m_tnRoot.m_pChild->m_tch;
    m_tchMaxChild = m_tnRoot.m_tchMaxChild;
#ifdef _DEBUG
    m_ctchMaxTokenLen = max(m_ctchMaxTokenLen, cLen);
#endif

    ASSERT(TCHAR_MIN < m_tchMinChild  &&  m_tchMinChild <= m_tchMaxChild);

#ifndef _UNICODE
    // Keep a map of the initial letter of each token, to speed up searches
    if (fIgnoreCase)
    {
        _SetCharPresent(tolower(ptszToken[0]), true);
        _SetCharPresent(toupper(ptszToken[0]), true);
    }
    else
        _SetCharPresent(ptszToken[0], true);
#endif // !UNICODE

#ifdef _DEBUG
    int nTemp;
    const _TOKEN* ptok2 = Search(ptszToken, &nTemp);

    ASSERT(ptok2 == ptok  &&  nTemp == cLen);
#endif // _DEBUG

    return true;
}



// CTrie::Search
//      Search trie for `ptszSearch', returning count of characters
//      matched in `pctchMatched' (if non-NULL), matching at most `nMaxLen'
//      characters, if nMaxLen != 0, or _tcslen(ptszSearch) otherwise.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
const _TOKEN*
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Search(
    LPCTSTR   ptszSearch,
    int*      pctchMatched /* = NULL */,
    const int nMaxLen /* = 0 */) const
{
    // Set count of matched characters
    if (pctchMatched != NULL)
        *pctchMatched = 0;

#ifndef _UNICODE
    if (! _CharPresent(ptszSearch[0]))
        return NULL;

    TCHAR tch;
#else    // UNICODE
    TCHAR tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[0]) : ptszSearch[0];

    if (tch < m_tchMinChild  ||  m_tchMaxChild < tch)
        return NULL;
#endif // UNICODE

    // For some uses (e.g., ptszSearch is not '\0'-terminated), nMaxLen is
    // specified.  If it's not specified, use the length of the string.
    const int cLen = (nMaxLen != 0)  ?  nMaxLen  :  _tcslen(ptszSearch);
    ASSERT(0 < cLen);

    bool fOvershot = true;
    const _Node* ptnParent = &m_tnRoot;
    const _Node* ptn = NULL;
    int i;

    // Find the longest approximate match.  For example, if we have "foo"
    // and "foobar" in the trie and we're asked to match "fool", we'll work
    // our way down to "foob", then backtrack up to "foo".

    for (i = 0;  i < cLen;  ++i)
    {
        ASSERT(ptnParent != NULL);

        ptn = ptnParent->m_pChild;
        ASSERT(ptn != NULL  &&  ptn->m_pParent == ptnParent);

        tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[i]) : ptszSearch[i];
        ASSERT(tch >= TCHAR_MIN);

        if (ptnParent->m_tchMaxChild < tch)
        {
            ASSERT(i > 0);
            break;
        }
        
        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;

        // failed to match?
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            ASSERT(ptn == NULL  ||  ptn->m_tch <= ptnParent->m_tchMaxChild);
            
            if (i == 0)
                return NULL;
            break;
        }
        else
        {
            ASSERT(ptn->m_tch == tch);
            ASSERT(ptn->m_pParent->m_tchMaxChild >= tch);

            if (ptn->m_pChild == NULL)
            {
                ASSERT(ptn->m_ptok != NULL);
                fOvershot = false;
                break;
            }

            ptnParent = ptn;
        }
    }

    if (fOvershot)
    {
        --i;  ptn = ptnParent;  // back up one character
    }
    else
        ASSERT(ptn->m_pChild == NULL);

    ASSERT(0 <= i  &&  i < cLen);
    ASSERT(ptn != NULL  &&  ptn != &m_tnRoot);
    
    // we've found an approximate match; backtrack until we find an exact match
    do
    {
        ASSERT(ptn != NULL);
        ASSERT(ptn->m_tch == (fIgnoreCase
                              ? (TCHAR) _totlower(ptszSearch[i])
                              : ptszSearch[i]));
        ASSERT(ptn->CheckNodeToken());
        
        const _TOKEN* const ptok = ptn->m_ptok;

        if (ptok != NULL)
        {
            ASSERT(i == (int) _tcslen(ptn->m_ptszToken) - 1);

            if (pctchMatched != NULL)
                *pctchMatched = i+1;

            return ptok;
        }

        ptn = ptn->m_pParent;
    } while (--i >= 0);

    return NULL;
}



// CTrie::Flush
//      flush all nodes leaving an empty trie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Flush()
{
    if (m_tnRoot.m_pChild != NULL)
        _DeleteTrie(m_tnRoot.m_pChild);

    m_tnRoot.m_pChild = NULL;  // or ~CTrieNode will ASSERT
    m_tnRoot.m_tchMaxChild = TCHAR_MIN;

    m_tchMinChild = m_tchMaxChild = TCHAR_MIN;
#ifdef _DEBUG
    m_ctchMaxTokenLen = 0;
#endif
#ifndef _UNICODE
    memset(m_afCharPresent, 0, sizeof(m_afCharPresent));
#endif
}



// CTrie::_DeleteTrie
//      recursively delete a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DeleteTrie(
    _Node* ptn)
{
    if (ptn == NULL)
    {
        ASSERT(false);
        return;
    }
    
    do
    {
        if (ptn->m_pChild != NULL)
        {
            _DeleteTrie(ptn->m_pChild);
            ptn->m_pChild = NULL;   // or ~CTrieNode will ASSERT
        }

        _Node* ptnSibling = ptn->m_pSibling;
        delete ptn;
        ptn = ptnSibling;   // tail recursion
    } while (ptn != NULL);
}



//-----------------------------------------------------------------------------
// CTrie diagnostics

#ifdef _DEBUG

// CTrie::AssertValid

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    ASSERT_VALID(&m_tnRoot);
    ASSERT(m_tnRoot.m_tchMaxChild == m_tchMaxChild);

    if (m_tnRoot.m_pChild != NULL)
    {
        ASSERT(m_tchMinChild == m_tnRoot.m_pChild->m_tch);
        ASSERT(m_ctchMaxTokenLen > 0);
        _AssertWalk(m_tnRoot.m_pChild, ptszName, 0);
    }
    else
    {
        ASSERT(m_tchMinChild == TCHAR_MIN && m_tchMinChild == m_tchMaxChild);
        ASSERT(m_ctchMaxTokenLen == 0);
    }
}



// CTrie::_AssertWalk
//      recursively validate a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_AssertWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel) const
{
    ASSERT(iLevel < m_ctchMaxTokenLen);
    
    do
    {
        ASSERT_VALID(ptn);
        
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            ASSERT(ptn->m_ptszToken != NULL);
            if (fIgnoreCase)
                ASSERT(_tcsicmp(ptszName, ptn->m_ptszToken) == 0);
            else
                ASSERT(_tcscmp(ptszName, ptn->m_ptszToken) == 0);
            ASSERT_VALID(ptn->m_ptok);
        }
        
        if (ptn->m_pChild != NULL)
            _AssertWalk(ptn->m_pChild, ptszName, iLevel+1);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}



// CTrie::Dump

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    int cNodes = 0, cTokens = 0;
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    TRACE0("Dumping trie...\n");

    if (m_tnRoot.m_pChild != NULL)
        _DumpWalk(m_tnRoot.m_pChild, ptszName, 0, cNodes, cTokens);

    TRACE2("%d nodes, %d tokens\n", cNodes, cTokens);
}



// CTrie::_DumpWalk
//      recursively dump a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DumpWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel,
    int&   rcNodes,
    int&   rcTokens) const
{
    ASSERT(iLevel < m_ctchMaxTokenLen);

    do
    {
        ASSERT_VALID(ptn);
        
        ++rcNodes;
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            ++rcTokens;
            ASSERT(ptn->m_ptszToken != NULL);
            TRACE2("\t%s (%s): ", ptszName, ptn->m_ptszToken);
            DUMP(ptn->m_ptok);
            TRACE0("\n");
        }
        
        if (ptn->m_pChild != NULL)
            _DumpWalk(ptn->m_pChild, ptszName, iLevel+1, rcNodes, rcTokens);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}

#endif // _DEBUG

#endif // __TRIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\token.cpp ===
#include "CkyPch.h"

#include "debug.h"
#include "token.h"
#include "utils.h"


// Base class for keywords

CToken::CToken(
    const string& rstr,
    const BOUNDARY bndPrefix /* =IRRELEVANT */,
    const BOUNDARY bndSuffix /* =IRRELEVANT */)
    : m_str(rstr),
      m_bndPrefix(bndPrefix),
      m_bndSuffix(bndSuffix)
{
}



CToken::~CToken()
{
}



BOOL
CToken::MatchesBoundaryClass(
    const TCHAR tch,
    const BOUNDARY bnd)
{
    switch (bnd)
    {
    case IRRELEVANT:
        return TRUE;
        
    case WHITESPACE:
        return _istspace(tch);
        
    case ALPHA:
        return _istalpha(tch);
        
    case NUMERIC:
        return _istdigit(tch);

    case ALPHANUMERIC:
        return _istalnum(tch);

    case NEWLINE:
        return tch == _T('\n')  ||  tch == _T('\r');

    default:
        ASSERT(FALSE);
        return FALSE;
    }
}



// DoFilter: default implementation is to update the state stack
// and copy the text that matched the token

UINT
CToken::DoFilter(
    CStateStack& rss,
    LPCTSTR&     rptszData,
    UINT         cchData,
    LPTSTR&      rptszOutBuf) const
{
    const UINT cb  = CountBytes(rss, rptszData, cchData);
    const UINT cch = m_str.length();

    // for (UINT i = 0; i < cch; ++i)
    //     TRACE("%c", rptszOutBuf[i]);

    memcpy(rptszOutBuf, rptszData, cch);
    rptszData += cch;
    rptszOutBuf += cch;

    return cb;
}



#ifdef _DEBUG

void
CToken::AssertValid() const
{
}



void
CToken::Dump() const
{
    TRACE("\t%d %d", (int) m_bndPrefix, (int) m_bndSuffix);
}

#endif // _DEBUG



//----------------------------------------------------------------


bool
CTokenTrie::AddToken(
    const CToken* ptok)
{
    return CTrie<CToken, true, true>::AddToken(ptok->m_str.c_str(), ptok);
}



inline bool
CTokenTrie::_LastCharPresent(
    CHAR ch) const
{
    ASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char'

    return m_afLastChar[i >> 3] & (1 << (i & 7))  ?  true  :  false;
}



inline void
CTokenTrie::_SetLastCharPresent(
    CHAR ch,
    bool f)
{
    ASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;

    if (f)
        m_afLastChar[i >> 3] |=  (1 << (i & 7));
    else
        m_afLastChar[i >> 3] &= ~(1 << (i & 7));
}


// ctor

CTokenTrie::CTokenTrie()
{
    memset(m_afCharPresent, 0, sizeof(m_afCharPresent));

    static const CHAR achEndTokens[] = {
        ' ', '\t', '\f', '\b', '\r', '\n', '>',
    };

    for (int i = ARRAYSIZE(achEndTokens);  --i >= 0; )
        _SetLastCharPresent(achEndTokens[i], true);
}



// Returns 1 past the last character which is a valid token-ending char,
// or < 0 if no such char
int
CTokenTrie::EndOfBuffer(
    PHTTP_FILTER_RAW_DATA pRawData,
    int iStart)
{
    LPSTR pszData = (LPSTR) pRawData->pvInData;

    // Empty interval?
    if (pRawData->cbInData == iStart)
        return iStart;

    for (int i = pRawData->cbInData;  --i >= iStart; )
    {
        if (_LastCharPresent(pszData[i]))
            return i+1;
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\themes.inc ===
<%
'	$Date: 11/24/97 12:17p $
'	$ModTime: $
'	$Revision: 2 $
'	$Workfile: themes.inc $

 Sub ShowFolderList(folderspec)
    Dim fs, f, f1, fc, s
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFolder(folderspec)
	Set fc = f.SubFolders
	s = "<OPTION VALUE=""" & """ SELECTED>Select your theme!"
    For Each f1 in fc
		s = s & "<OPTION NAME=" & """Theme""" & " VALUE=""" & f1.name 
		If myinfo.Theme = f1.name Then
			s = s & """ SELECTED>" & f1.name
		Else
			s = s & """>" & f1.name
		End If
	Next
	s = s & "</SELECT>"
    response.write s
 End Sub

 If myinfo.ranWizard <> "" Then
	'response.write "<FONT Size='-1'><A HREF = " & """#""" & " onClick = """ & HelpWindow("Style") & """>Template Style</A></FONT><BR>"_
 	'&
	response.write "<SELECT NAME='theme' Language='VBSCRIPT' ONCHANGE='Submit'>" 
 Else
	response.write "<H5>You can choose from the following templates to personalize your home page.</H5><BR><blockquote>"_
	& "<SELECT NAME='theme' Size=3>"
 End If
 call ShowFolderList(Server.MapPath("/iissamples/homepage/themes"))
 If myinfo.ranWizard <> "" Then 
	response.write "</blockquote>"
 End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\utils.cpp ===
// Miscellaneous utility functions

#include "CkyPch.h"

#include "utils.h"
#include "debug.h"
#include "notify.h"
#include "trie.h"
#include "globals.h"


// A list of MIME extensions that we know can safely ignore.
// TODO: really ought to get this list dynamically

static char* s_aszIgnoredExtensions[] = {
    "evy",     "hqx",     "doc",     "dot",     "bin",
    "oda",     "pdf",     "ai",      "eps",     "ps",
    "rtf",     "hlp",     "bcpio",   "cpio",    "csh",
    "dcr",     "dir",     "dxr",     "dvi",     "gtar",
    "hdf",     "latex",   "mdb",     "crd",     "clp",
    "xla",     "xlc",     "xlm",     "xls",     "xlt",
    "xlw",     "m1d",     "m14",     "wmf",     "mny",
    "ppt",     "mpp",     "pub",     "trm",     "wks",
    "wri",     "cdf",     "nc",      "pma",     "pmc",
    "pml",     "pmr",     "pmw",     "sh",      "shar",
    "sv4cpio", "sv4crc",  "tar",     "tcl",     "tex",
    "texi",    "texinfo", "roff",    "t",       "tr",
    "man",     "me",      "ms",      "ustar",   "src",
    "zip",     "au",      "snd",     "aif",     "aifc",
    "aiff",    "ram",     "wav",     "bmp",     "cod",
    "gif",     "ief",     "jpe",     "jpeg",    "jpg",
    "tif",     "tiff",    "ras",     "cmx",     "pnm",
    "pbm",     "pgm",     "ppm",     "rgb",     "xbm",
    "xpm",     "xwd",     "bas",     "c",       "h",
    "txt",     "rtx",     "tsv",     "etx",     "mpe",
    "mpeg",    "mpg",     "mov",     "qt",      "avi",
    "movie",   "flr",     "wrl",     "wrz",     "xaf",
    "xof",
};


// STL functor for CStrILookup

struct stricomp {
    bool
    operator()(
        const char* s1,
        const char* s2) const
    {
        return stricmp(s1, s2) < 0;
    }
};

typedef set<const char*, stricomp> CStrILookup;

static CStrILookup s_setMimeExtensions;


// Figure out the type of a URL (http:, mailto:, etc)

typedef struct {
    const char* m_pszUrlType;
    URLTYPE     m_ut;

#ifdef _DEBUG
    void
    AssertValid() const
    {}

    void
    Dump() const
    {
        TRACE("\t%d", m_ut);
    }
#endif
} SUrlType;


static const SUrlType s_aUrlTypes[] = {
    {"http:",   UT_HTTP},
    {"https:",  UT_HTTPS},
    {"ftp:",    UT_FTP},
    {"gopher:", UT_GOPHER},
    {"mailto:", UT_MAILTO},
    {"mk:",     UT_MK},
    {"news:",   UT_NEWS},
    {"newsrc:", UT_NEWSRC},
    {"nntp:",   UT_NNTP},
    {"telnet:", UT_TELNET},
    {"wais:",   UT_WAIS},
};


static CTrie<SUrlType, true, false> s_trieUrlType;



//
// Initialize various utility functions
//

BOOL
InitUtils()
{
    TRACE("InitUtils\n");

    // Double-check that we've set up our constants correctly
    ASSERT(strlen(SESSION_ID_PREFIX) == SESSION_ID_PREFIX_SIZE);
    ASSERT(strlen(SESSION_ID_SUFFIX) == SESSION_ID_SUFFIX_SIZE);
    ASSERT(strlen(SZ_SESSION_ID_COOKIE_NAME)== SZ_SESSION_ID_COOKIE_NAME_SIZE);

    // Build the set of ignorable MIME extensions
    s_setMimeExtensions.insert(s_aszIgnoredExtensions,
                               s_aszIgnoredExtensions
                                 + ARRAYSIZE(s_aszIgnoredExtensions));
#ifdef _DEBUG
    int cExt = 0;
    for (CStrILookup::iterator j = s_setMimeExtensions.begin();
         j != s_setMimeExtensions.end();
         ++j)
    {
        const char* psz = *j;
        TRACE("%s%c", psz, (++cExt & 3) ? '\t' : '\n' );
    }
    TRACE("\n");
#endif

    for (int i = 0;  i < ARRAYSIZE(s_aUrlTypes);  ++i)
        s_trieUrlType.AddToken(s_aUrlTypes[i].m_pszUrlType, &s_aUrlTypes[i]);

    DUMP(&s_trieUrlType);

    return InitEventLog();
}



//
// Clean up when terminating
//

BOOL
TerminateUtils()
{
    TRACE("TerminateUtils\n");

    // Best to clean up global objects as much as possible before terminating
    s_setMimeExtensions.clear();

    return TRUE;
}



//
// Can this URL be safely ignored?
//

BOOL
IsIgnorableUrl(
    LPCSTR pszUrl)
{
    // a URL ending in '/' (i.e., a directory name) is ignorable
    if (pszUrl[strlen(pszUrl) - 1] == '/')
        return TRUE;
    
    LPCSTR pszExtn = strrchr(pszUrl, '.');

    if (pszExtn != NULL)
    {
        return (s_setMimeExtensions.find(pszExtn + 1)
                != s_setMimeExtensions.end());
    }

    return FALSE;
}



//
// "http:" -> UT_HTTP, "ftp:" -> UT_FTP, etc
//

URLTYPE
UrlType(
    LPCTSTR ptszData,
    LPCTSTR ptszEnd,
    int&    rcLen)
{
    const SUrlType* put = s_trieUrlType.Search(ptszData, &rcLen,
                                               ptszEnd - ptszData);

    if (put != NULL)
        return put->m_ut;
    else
        return UT_NONE;
}



//
// Initializes the event log
//

BOOL
InitEventLog()
{
    HKEY hk = NULL; 
    
    // Add the source name as a subkey under the Application 
    // key in the EventLog service portion of the registry. 
    
    if (RegCreateKey(HKEY_LOCAL_MACHINE, 
                     "SYSTEM\\CurrentControlSet\\Services"
                     "\\EventLog\\Application\\" EVENT_SOURCE, 
                     &hk)) 
    {
        TRACE("could not create registry key\n"); 
        return FALSE;
    }
 
    // Get the full path of this DLL
 
    HMODULE hMod = GetModuleHandle(EVENT_MODULE);

    if (hMod == NULL)
    {
        TRACE("Can't get module handle for %s, error %d\n",
              EVENT_MODULE, GetLastError());
        return FALSE;
    }

    CHAR szModule[MAX_PATH]; 

    if (GetModuleFileName(hMod, szModule, MAX_PATH) > 0)
        TRACE("Module is `%s'\n", szModule);
    else
    {
        TRACE("No module, error %d\n", GetLastError());
        return FALSE;
    }

    // Add the Event ID message-file name to the subkey.
 
    if (RegSetValueEx(hk,                       // subkey handle
                      "EventMessageFile",       // value name
                      0,                        // reserved: must be zero
                      REG_EXPAND_SZ,            // value type
                      (LPBYTE) szModule,        // address of value data
                      strlen(szModule) + 1))    // length of value data
    {
        TRACE("could not set EventMessageFile\n"); 
        return FALSE;
    }
 
    // Set the supported types flags.
 
    DWORD dwData = (EVENTLOG_ERROR_TYPE
                    | EVENTLOG_WARNING_TYPE
                    | EVENTLOG_INFORMATION_TYPE); 
 
    if (RegSetValueEx(hk,                // subkey handle
                      "TypesSupported",  // value name
                      0,                 // reserved: must be zero
                      REG_DWORD,         // value type
                      (LPBYTE) &dwData,  // address of value data
                      sizeof(dwData)))   // length of value data
    {
        TRACE("could not set TypesSupported\n"); 
        return FALSE;
    }
 
    RegCloseKey(hk); 

    return TRUE;
}



//
// Report things in the Event Log
//

VOID
EventReport(
    LPCTSTR string1,
    LPCTSTR string2,
    WORD eventType,
    DWORD eventID)
{
    HANDLE hEvent;
    LPCTSTR pszaStrings[2];
    WORD cStrings;

    cStrings = 0;
    if ((pszaStrings[0] = string1) && (string1[0]))
        cStrings++;
    if ((pszaStrings[1] = string2) && (string2[0]))
        cStrings++;
    
    hEvent = RegisterEventSource(NULL, EVENT_SOURCE);

    if (hEvent) 
    {
        ReportEvent(hEvent,         // handle returned by RegisterEventSource 
                    eventType,      // event type to log 
                    0,              // event category 
                    eventID,        // event identifier 
                    NULL,           // user security identifier (optional) 
                    cStrings,       // number of strings to merge with message 
                    0,              // size of binary data, in bytes
                    pszaStrings,    // array of strings to merge with message 
                    NULL);          // address of binary data 
        DeregisterEventSource(hEvent);
    }
}



//
// stristr (stolen from fts.c, wickn)
//
// case-insensitive version of strstr
// stristr returns a pointer to the first occurrence of string2 in string1.
// The search does not include terminating nul characters.
//

char*
stristr(const char* string1, const char* string2)
{
    char *cp1 = (char*) string1, *cp2, *cp1a;
    char first;

    // get the first char in string to find
    first = string2[0];

    // first char often won't be alpha
    if (isalpha(first))
    {
        first = tolower(first);
        for ( ; *cp1  != '\0'; cp1++)
        {
            if (tolower(*cp1) == first)
            {
                for (cp1a = &cp1[1], cp2 = (char*) &string2[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }
    else
    {
        for ( ; *cp1 != '\0' ; cp1++)
        {
            if (*cp1 == first)
            {
                for (cp1a = &cp1[1], cp2 = (char*) &string2[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }

    return NULL;
}



//
// Find a string in a block of rawdata (a sort of stristr).
// Can't use stristr because the rawdata is not \0-terminated.
//

LPSTR
FindString(
    LPCSTR psz,
    PHTTP_FILTER_RAW_DATA pRawData,
    int iStart)
{
    LPSTR pszData = iStart + (LPSTR) pRawData->pvInData;
    const int cch = strlen(psz);
    const CHAR ch = tolower(*psz);

    for (int i = pRawData->cbInData - cch + 1 - iStart;  --i >= 0; )
    {
        if (ch == tolower(*pszData)  &&  strnicmp(psz, pszData, cch) == 0)
            return pszData;
        else
            ++pszData;
    }

    return NULL;
}



//
// Find a header-value pair, such as ("Content-Type:", "text/html").  Works
// no matter how many spaces between the pair
//

LPSTR
FindHeaderValue(
    LPCSTR pszHeader,
    LPCSTR pszValue,
    PHTTP_FILTER_RAW_DATA pRawData,
    int iStart)
{
    LPSTR psz = FindString(pszHeader, pRawData, iStart);

    if (psz != NULL)
    {
        LPSTR pszData = iStart + (LPSTR) pRawData->pvInData;
        int   i       = (psz - pszData) + strlen(pszHeader);
        
        // Skip spaces
        while (i < pRawData->cbInData  &&  isspace(pszData[i]))
            ++i;
        
        // Check for szValue
        const int cchValue = strlen(pszValue);
        
        if (i + cchValue <= pRawData->cbInData)
            if (strnicmp(pszData+i, pszValue, cchValue) == 0)
                return psz;
    }

    return NULL;
}



//
// Delete a line such as "Content-Length: 924\r\n"
//

BOOL
DeleteLine(
    LPCSTR psz,
    PHTTP_FILTER_RAW_DATA pRawData,
    LPSTR  pszStart /* = NULL */)
{
    if (pszStart == NULL)
        pszStart = FindString(psz, pRawData, 0);

    if (pszStart == NULL)
        return FALSE;

    LPCSTR pszData = (LPCSTR) pRawData->pvInData;

    for (unsigned i = pszStart - pszData;  i < pRawData->cbInData; )
    {
        if (pszData[i++] == '\n')
        {
            for (unsigned j = 0;  j <  pRawData->cbInData - i;  j++)
                pszStart[j] = pszData[i + j];
            if (j <  pRawData->cbInData)
                pszStart[j] = '\0';
            pRawData->cbInData -= i - (pszStart - pszData);

            return TRUE;
        }
    }

    return FALSE;
}



//
// Extract a Session ID from a Cookie header.  Cookie will be in the form
//     name1=value1; name2=value2; name3=value3; ...
// One of those name-value pairs should be something like:
//     ASPSESSIONIDXXXXXXXX=PVZQGHUMEAYAHMFV or
//     ASPSESSIONID=PVZQGHUMEAYAHMFV
//
 
BOOL
Cookie2SessionID(
    LPCSTR pszCookie,
    LPSTR  pszSessionID)
{
    if (pszCookie == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }
    
    LPCSTR psz = strstr(pszCookie, SZ_SESSION_ID_COOKIE_NAME);

    if (psz == NULL)
    {
        TRACE("C2SID: failed strstr `%s'\n", pszCookie);
        return FALSE;
    }

    // skip over the "ASPSESSIONIDXXXXXXXX=" or "ASPSESSIONID=" part
    psz += SZ_SESSION_ID_COOKIE_NAME_SIZE;
    if (*(psz) != '=')
    {
        if ( strncmp( psz, g_szCookieExtra, COOKIE_NAME_EXTRA_SIZE ) == 0 )
        {
            psz += COOKIE_NAME_EXTRA_SIZE;
            if ( *(psz) != '=' )
            {
                TRACE("C2SID: no = `%s'\n", psz);
                return FALSE;
            }
        }
        else
        {
            TRACE("C2SID: strncmp(%s) `%s'\n", g_szCookieExtra, psz);
            return FALSE;
        }
    }
    psz++;

    return CopySessionID(psz, pszSessionID);
}



//
// Extract a Session ID from psz, placing it into pszSessionID
//

BOOL
CopySessionID(
    LPCSTR psz,
    LPSTR  pszSessionID)
{
    ASSERT( g_SessionIDSize != -1 );

    strncpy(pszSessionID, psz, g_SessionIDSize);
    pszSessionID[g_SessionIDSize] = '\0';

#ifdef _DEBUG
    TRACE("SessionID='%s'\n", pszSessionID);
    for (psz = pszSessionID;  *psz;  ++psz)
        ASSERT('A' <= *psz  &&  *psz <= 'Z');
#endif

    return TRUE;
}



//
// Remove an encoded Session ID from a URL, returning the Session ID 
// e.g., /foo/bar.asp-ASP=PVZQGHUMEAYAHMFV?quux=5 ->
//           /foo/bar.asp?quux=5 + PVZQGHUMEAYAHMFV
//

BOOL
DecodeURL(
    LPSTR pszUrl,
    LPSTR pszSessionID)
{
    ASSERT( g_SessionIDSize != -1 );

    TRACE("Decode(%s)", pszUrl);
    
    LPSTR pszQuery = strchr(pszUrl, '?');

    if (pszQuery != NULL)
        *pszQuery++ = '\0';

    LPSTR pszLastSlash = strrchr(pszUrl, *SESSION_ID_PREFIX);

    if (pszLastSlash == NULL)
    {
        TRACE(" (no `" SESSION_ID_PREFIX "')\n");
        return FALSE;
    }

    const int cchEncodedID = strlen(pszLastSlash);

    if (strncmp(pszLastSlash, SESSION_ID_PREFIX, SESSION_ID_PREFIX_SIZE) != 0
        || cchEncodedID !=
            (SESSION_ID_PREFIX_SIZE + g_SessionIDSize + SESSION_ID_SUFFIX_SIZE)
        || strcmp(pszLastSlash + cchEncodedID - SESSION_ID_SUFFIX_SIZE,
                  SESSION_ID_SUFFIX) != 0)
    {
        if (pszQuery != NULL)
            *pszQuery = '?';
        TRACE(": not encoded\n");
        return FALSE;
    }
    else
    {
        strncpy(pszSessionID, pszLastSlash + SESSION_ID_PREFIX_SIZE,
                g_SessionIDSize);
        pszSessionID[g_SessionIDSize] = '\0';

        *pszLastSlash = '\0';

        if (pszQuery != NULL)
        {
            *pszLastSlash++ = '?';

            while ((*pszLastSlash++ = *pszQuery++) != '\0')
                ;
        }

        TRACE(" -> %s, %s\n", pszUrl, pszSessionID);

        return TRUE;
    }
}



//
// Wrapper for pfc->AllocMem.
//

VOID*
AllocMem(
    PHTTP_FILTER_CONTEXT  pfc,
    DWORD                 cbSize)
{
    PVOID pv = pfc->AllocMem(pfc, cbSize, 0);
#ifdef _DEBUG
    memset(pv, 0, cbSize);
#endif
    TRACE("Allocated %d (%x) bytes at %x\n", cbSize, cbSize, pv);
    return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\ckymunge\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

// disable warning messages about truncating extremly long identifiers
#pragma warning (disable : 4786)
#include <string>

// Needed for STL on Visual C++ 5.0
#if _MSC_VER>=1100
using namespace std;
#endif

#include "messages.h"

#define EVENT_SOURCE "CkyMunge"
#define EVENT_MODULE "CkyMunge.dll"

#define ARRAYSIZE(a)  (sizeof(a)/sizeof(*(a)))


BOOL
InitUtils();

BOOL
TerminateUtils();

BOOL
InitEventLog();

VOID
EventReport(
    LPCTSTR string1,
    LPCTSTR string2,
    WORD eventType,
    DWORD eventID);

char*
stristr(const char*, const char*);

LPSTR
FindString(
    LPCSTR psz,
    PHTTP_FILTER_RAW_DATA pRawData,
    int iStart);

LPSTR
FindHeaderValue(
    LPCSTR pszHeader,
    LPCSTR pszValue,
    PHTTP_FILTER_RAW_DATA pRawData,
    int iStart);

BOOL
DeleteLine(
    LPCSTR psz,
    PHTTP_FILTER_RAW_DATA pRawData,
    LPSTR  pszStart = NULL);

BOOL
Cookie2SessionID(
    LPCSTR pszCookie,
    LPSTR  pszSessionID);

BOOL
CopySessionID(
    LPCSTR psz,
    LPSTR  pszSessionID);

BOOL
IsIgnorableUrl(
    LPCSTR pszUrl);

BOOL
DecodeURL(
    LPSTR pszUrl,
    LPSTR pszSessionID);

VOID*
AllocMem(
    PHTTP_FILTER_CONTEXT  pfc,
    DWORD                 cbSize);


enum URLTYPE {
    UT_NONE,
    UT_UNKNOWN,
    UT_HTTP,
    UT_HTTPS,
    UT_FTP,
    UT_GOPHER,
    UT_MAILTO,
    UT_NEWS,
    UT_NEWSRC,
    UT_NNTP,
    UT_TELNET,
    UT_WAIS,
    UT_MK,
};


URLTYPE
UrlType(
    LPCTSTR ptszData,
    LPCTSTR ptszEnd,
    int&    rcLen);

#endif // __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\psdksamp\isapi\filters\upcase\upcase.c ===
/*++                                                                                                                             

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    upcase.c

Abstract:

    This filter converts HTML response data to upper case if requested
    by the client. The request is made by specifying an extra 
    subdirectory in the URL, which doesnt actually exist on the server,
    but is used by the filter to indicate that upper case is desired.
    The extra subdirectory is removed from the request before the HTTP
    server sees the request.

    When a request is received, the filter inspects the 
    subdirectories specified in the URL. If a subdirectory is 'UC'
    or 'uc', the subdirectory is removed from the request, and the
    filter saves in its pFilterContext field, a value indicating that
    the response data should be converted to upper case.

    When the filter entrypoint is later called for the response, it 
    checks the pFilterContext field and converts the data if 
    the mime-type of the response indicates that its an html file.
    This avoids conversions on binary data.

    An example URL entered by a user might be:

        http://www.myweb.com/sales/uc/projections.htm

    While the functionality of this filter is somewhat contrived, this
    filter does a good job of demonstrating the following features of
    filters:
        - parsing/modifying HTTP headers (in the request)
        - modifying data following HTTP headers (in the response)
        - saving state to be used by the filter later
        - adding request/response level functionality to the server
            (instead of using a mechanism like this to convert to 
             uppercase, you may use it to do on-the-fly customized
             translations of HTML pages (English -> French perhaps?)

Author:

    Kerry Schwartz (kerrys) 05-Nov-1995

modified:
    a-jiano					08/28/98					

--*/      

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <httpfilt.h>

BOOL
WINAPI __stdcall
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_NONSECURE_PORT     |
                     SF_NOTIFY_URL_MAP            |
                     SF_NOTIFY_SEND_RAW_DATA      |
                     SF_NOTIFY_ORDER_DEFAULT);

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    strcpy( pVer->lpszFilterDesc, 
            "Upper case conversion filter, Version 1.0");

    return TRUE;
}

DWORD
WINAPI __stdcall
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
{
    CHAR *pchIn, *pPhysPath;
    DWORD cbBuffer, cbtemp;
    PHTTP_FILTER_URL_MAP pURLMap;
    PHTTP_FILTER_RAW_DATA pRawData;
    void* pTmp;
  
    switch ( NotificationType )
    {
    case SF_NOTIFY_URL_MAP:

        pURLMap = (PHTTP_FILTER_URL_MAP) pvData;
        pPhysPath = pURLMap->pszPhysicalPath;
        pfc->pFilterContext = 0;


        while (*pPhysPath)
        {
            if (*pPhysPath == '\\' &&
               (*(pPhysPath+1) == 'u' || *(pPhysPath+1) == 'U') &&
               (*(pPhysPath+2) == 'c' || *(pPhysPath+2) == 'C') &&
                *(pPhysPath+3) == '\\')
            {
                while (*(pPhysPath+3))
                {
                    *pPhysPath = *(pPhysPath+3);
                    pPhysPath++;
                }
                *pPhysPath = '\0';
                pfc->pFilterContext = (VOID *) 1;
                break;
            }
            pPhysPath++;
        }

        break;

    case SF_NOTIFY_SEND_RAW_DATA:

        pRawData = (PHTTP_FILTER_RAW_DATA) pvData;

        if (pfc->pFilterContext)
        {
            pchIn = (BYTE *) pRawData->pvInData;
            cbBuffer = 0;
            cbtemp = 0;

            if (pfc->pFilterContext == (VOID *) 1)      // first block?
            {
                while (cbBuffer < pRawData->cbInData)
                {
                    if (pchIn[cbBuffer] == '\n' &&
                        pchIn[cbBuffer+2] == '\n')
                    {
                        cbBuffer +=3;
                        break;
                    }
                    cbBuffer++;
                }
            
                while (cbtemp < cbBuffer)
                {
                    if (pchIn[cbtemp] == '/' && pchIn[cbtemp+1] == 'h' &&
                        pchIn[cbtemp+2] == 't' && pchIn[cbtemp+3] == 'm')
                    {
                        pfc->pFilterContext = (VOID *) 2;
                        break;
                    }
                    cbtemp++;
                }
                if (cbtemp == cbBuffer)
                    pfc->pFilterContext = 0;        // not an html file
            }

            __try{

				if (pfc->pFilterContext)
				{
					//record cbBuffer incase failure, so __except block can continue

					cbtemp = cbBuffer;

					while (cbBuffer < pRawData->cbInData)
					{
						pchIn[cbBuffer] = 
							(pchIn[cbBuffer]>='a' && pchIn[cbBuffer]<='z') ? 
							(pchIn[cbBuffer]-'a'+'A') : pchIn[cbBuffer];
						cbBuffer++;
					}
            
				}
			}
			__except(1){

				// In case of memory access vialation
				// a new buffer is allocated 
				
				pTmp= pfc->AllocMem(pfc, pRawData->cbInBuffer, 0);
				if (!pTmp)
					return SF_STATUS_REQ_ERROR;
				memcpy(pTmp, pRawData->pvInData, pRawData->cbInBuffer);
				pRawData->pvInData = pTmp;
				pchIn = (BYTE *) pRawData->pvInData;

				cbBuffer = cbtemp;
				
				while (cbBuffer < pRawData->cbInData)
				{
					pchIn[cbBuffer] = 
						(pchIn[cbBuffer]>='a' && pchIn[cbBuffer]<='z') ? 
						(pchIn[cbBuffer]-'a'+'A') : pchIn[cbBuffer];
					cbBuffer++;
				}
			}  //end of __except
        }
        break;
           
    default:
        break;        
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\theme.inc ===
<!--#include virtual ='/iissamples/homepage/themes/gunmetal/layout.inc'-->

<!--#include virtual ='/iissamples/homepage/themes/looseleaf/layout.inc'-->

<!--#include virtual ='/iissamples/homepage/themes/journal/layout.inc'-->
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\casual\setup.inc ===
<%
 If myinfo.Theme = "casual" Then
'		$Date: 11/24/97 11:59a $
'		$ModTime: $
'		$Revision: 1 $
'		$Workfile: setup.inc $
'        Casual
	'Khaki colored cell for introduction
	response.write "<table width=100% border=0 cellpadding=20 cellspacing=0>"_
	& "<tr><td width='65%' bgcolor=#ddddcc valign=top><H2>"_
	& "<FORM NAME='Template' ACTION='template.asp' METHOD='POST'>"
	call Template_title
	response.write "</H2><P>"
	call page_datetime
	response.write "</td>"
	 'Blue colored cell for contact information
	response.write "<td width=35% bgcolor=#003871 valign=top><h2 class=white></h2><p><h3 class=white>"
	call Template_Phone
	response.write "<BR>"
	call Template_faxPhone
	response.write "<BR>"
	call Template_Name
	response.write "<BR>"
	call Template_address
	response.write "<BR></h3></td></tr>"_
	& "<tr><td width=65% valign=top>"
	' Main content area of the page
	response.write Template_Heading()
	response.write "</td><td width=35% valign=top><h2>While you are here:</h2><P>"
	 call Template_page_messaging
	response.write "<P><h2>My favorite links:</h2><BR>"
	 call Template_page_links
	response.write "</td></tr><tr><td Align=left>"
	 call ie_logo
	response.write "</td><td><INPUT TYPE='hidden' NAME='contents' Value='-1'>"_
    & "<Center><INPUT TYPE=SUBMIT VALUE='enter new changes'>"_
	& "</Center></FORM></td></tr></table>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\gunmetal\layout.inc ===
<%
 If myinfo.Theme = "gunmetal" Then
	'	$Date: 9/12/97 11:58a $
	'	$ModTime: $
	'	$Revision: 16 $
	'	$Workfile: layout.inc $
	response.write "<TABLE width='100%' height='100%' cellpadding='0'"_
	& " cellspacing='0' border='0'><TR>"
'				******************* Right  Column  *************
	 response.write "<TD Valign='TOP' align=left Width=200"_
	 & " BGColor='#868686' Background='/iissamples/homepage/themes/gunmetal/gradient.gif'>"
	 call page_datetime
	 call page_messaging
	 call file_check		'Checks for published files
	 call page_links
'				******************* Center Column  *************
	 response.write "</TD><TD Width='20' rowspan=2 BGColor='#868686'>"
'               ******************* Right  Column  *************
	response.write "<TD Valign='TOP' Align='left' BGColor='#DAE4DC' rowspan=2>"_
	& "<TABLE border=0 width='100%' height='100%' cellpadding='5' cellspacing='0'><TR>"_
	& "<TD Valign='TOP' class='bg3' Colspan=2 Height=80><H1>"
	call Title
	response.write "</H1></TD></TR><TR>"_
	& "<TD Valign=top align=left Colspan=2>"
	call layout_Email
	response.write "</TD></TR><TR><TD>"
	call Phone
	response.write "</TD><TD>"
	call faxPhone
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Address
	DIM n
	For n = 1 to 4
	response.write "</TD></TR><TR><TD Colspan=2>"
	response.write Heading(n)
	Next
	response.write "</TD></TR></TABLE></TD></TR>"_
	& "<TR><TD height=32 Align=center"_
	& " BGColor='#868686' Background='/iissamples/homepage/themes/gunmetal/gradient.gif'>"
	call ie_logo
	response.write "</TD></TR></TABLE>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\gunmetal\setup.inc ===
<!--
		$Date: 9/30/97 3:45p $
		$ModTime: $
		$Revision: 8 $
		$Workfile: setup.inc $
        GunMetal
	-->
<%
 If myinfo.Theme = "gunmetal" Then
'				******************* GENERIC CONTENTS  *************
'									Left Column
    response.write "<TD Valign=top align=left Width=200 class=bg1>"_
    & "<FORM NAME='Template' ACTION='template.asp' METHOD='POST'>"
	call page_datetime
    call Template_page_messaging
	call Template_page_links
	response.write "</TD>"
'									Center Column

	response.write "<TD Width='20' class=bg2 Valign=top rowspan=2>"_
	& "&nbsp;</TD>"_

'				******************* SPECIFIC CONTENTS *************
'									Right Column
	response.write "<TD Valign='TOP' Align='left' BGColor='#DAE4DC' rowspan=2>"_
	& "<TABLE border=0 width='100%' height='100%' cellpadding='0' cellspacing='0'><TR>"_
	& "<TD Valign='TOP' class='bg3' Colspan=2>"
	call Template_title
	response.write "</TD></TR><TR>"_
	& "<TD Valign=top align=left Colspan=2>"
	call Template_Name
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Template_Email
	response.write "</TD></TR><TR><TD>"
	call Template_Phone
	response.write "</TD><TD>"
	call Template_faxPhone
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Template_address
	response.write "</TD></TR><TR><TD Colspan=2>"_
	& 	Template_Heading()_ 
	& "</TD></TR><TR><TD Colspan=2>"_
    & "<INPUT TYPE='hidden' NAME='contents' Value='-1'>"_
    & "<Center><INPUT TYPE=SUBMIT VALUE='enter new changes'>"_
	& "</Center></FORM></TD></TR></TABLE>"
'				************ Last Row **************
	response.write "<TR><TD height=32 Align=center class=bg1>"
	call ie_logo
	response.write "</TD>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\casual\layout.inc ===
<%
 If myinfo.Theme = "casual" Then
'	$Date: 11/24/97 11:59a $
'	$ModTime: $
'	$Revision: 1 $
'	$Workfile: layout.inc $
'	casual
	DIM z
	'Khaki colored cell for introduction
	response.write "<table width=100% border=0 cellpadding=20 cellspacing=0>"_
	& "<tr><td width='65%' bgcolor=#ddddcc valign=top>"_
	& "<H2 class=black>" & ThmSalutation() & "</H2><BR>"_
	& "<H5 class=black>" & ThmDate() & "<BR>"_
	& ThmTime() & "</H5></TD>"
	'Blue colored cell for contact information
	response.write "<td width=35% bgcolor=#003871 valign=top>"
	If myinfo.Name <> "" OR myinfo.Email <> "" OR myinfo.faxphone <> "" OR myinfo.Department <>"" Then
		response.write "<H5 class=white>" & thmName() & "<BR>" & thmDept() & "<BR>"_
		& thmAddr() & "<BR>" & thmPhone() & "<BR>" & thmFax() & "<BR>" & thmEmail() & "</H5>"
	End If
	response.write "</td></tr>"_
	& "<tr><td width=65% valign=top BGColor='#FFFFFF'>"
	For z = 1 to 4
		response.write Heading(z) & "<P>"
	Next
	response.write "</td><td rowspan=2 width=35% valign=top BGColor='#FFFFFF' BACKGROUND='/iissamples/homepage/themes/casual/line.gif'>"
	If myinfo.Guestbook <> "" OR myinfo.Messages <> "" Then
		response.write "<H5 class=black>While you are here...</FONT><BR>"_
		& thmGuest() & "<BR>" & thmDrop() & "<BR>"
	End If
	call file_check
	If myinfo.intURL <> "" Then
		response.write "<H5 class=black>My favorite links:</H5><BR>"
		call urlArray
	End If
	response.write "</td></tr><tr><td Align=left BGColor='#FFFFFF'>"
	call IE_Logo
	response.write "</td></tr></table>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\sub.inc ===
<%
'	$Date: 10/20/97 6:35p $
'	$ModTime: $
'	$Revision: 26 $
'	$Workfile: sub.inc $

'	***	Style Sheet selection
 Sub styleSheet
	If myinfo.Theme <> "" Then
		response.write"<LINK REL=StyleSheet HREF='/iissamples/homepage/themes/" & myinfo.Theme & "/layout.css' TYPE='text/css' MEDIA=screen>"
    End If
 End Sub
'				*********************	DATE/TIME/MESSAGING/LINKS

'				*******		Date/Time
 Sub page_datetime
	response.write "<h4>Welcome!</h4>"_
	 & "<H5>Today is " & Date & ".<BR>"_
	 & "The local time is " & Time & ".</H5><BR>"
 End Sub

'				*******		Guestbook and Messaging
 Sub page_messaging
	If myinfo.Guestbook <> "" or myinfo.Messages <> "" or myinfo.Email <> "" Then
		If myinfo.Guestbook = "-1" or myinfo.Messages = "-1" or myinfo.checkEmail ="-1" Then
			response.write "<h4>While you are here...</h4>"
		End If
		response.write "<FONT style='font-family:verdana;font-size:10pt'>"
		If myinfo.Guestbook = "-1" THEN
			response.write "<P><a href='/iissamples/homepage/guestbk.asp'>Read my guest book</A><BR>"
		End If
		If myinfo.Messages = "-1" THEN
			response.write "<P><a href='/iissamples/homepage/signbook.asp?private=-1'>Leave a private message</a><BR>"
		End If
		response.write "</FONT>"
	End If
 End Sub

 Sub file_check
	'***This routine checks for files in the webpub directory and creates a link to view the file list when files do exist.
	DIM FileSystem, fl, g, f, sc, fc, isFiles
		isfiles = 0
		Set FileSystem=CreateObject("Scripting.FileSystemObject")
	'Set File System Object.
		g = Server.MapPath("\webpub")
		g = g + "\"
		Set f=FileSystem.GetFolder(g)
		Set sc = f.SubFolders
	'Check for files in folder.
		Set fc = f.Files
		For Each fl in fc
			isfiles= isfiles + 1
		Next
	'If files exist, create link.
		If isfiles > 0 Then
			response.write "<FONT style='font-family:verdana;font-size:10pt'>"_
			& "<A Href='/iissamples/homepage/myfiles.asp'>View my published documents.</A>"_
			& "</FONT><BR>"
		End If
 End Sub
	' ***This subroutine creates an array of your weblinks.
 Sub page_links
	If myinfo.intUrl <> "" Then
		response.write "<BR><FONT style='font-family:verdana;font-size:10pt'>"
		call urlArray
		response.write "</FONT>"
	End If
 End Sub

	'***Favorite links array
 Sub urlArray
	Dim urlList(), urlWordsList()
	intID = 0
	For i = 0 to myinfo.intUrl
		If  myinfo("urlWords" & i) = "null" or myinfo("urlWords" & i) = "endoffile" or myinfo("url" & i) = "http://" or myinfo("url" & i) = ""  THEN
			myinfo("url" & i) = "null"
			myinfo("urlWords" & i) = "null"
		Else
			Redim Preserve urlList(intID), urlWordsList(intID)
			urlList(intID) = Myinfo("url" & i)
			urlWordsList(intID) = Myinfo("urlWords" & i)
			response.write "<A href='" & urlList(intID) &"'>" & urlWordsList(intID) & "</A><BR>"
			intID = intID + 1
			myinfo.favoriteLinks = -1
		End If
	Next
 End Sub

	'***Title
 Sub Title
	If myinfo.Title <> "" Then
		response.write myinfo.Title
	ElseIf myinfo.Name <> "" Then
    	response.write myinfo.Name & "'" 
			If right(myInfo.Name, 1) <> "s" then
			response.write "s"
			End If
		response.write " Home Page"
	Else
		response.write "My Home Page"
	End If
 End sub

	'*** main page contents
 Sub layout_Email
	If myinfo.Email <> "" Then
		response.write "<FONT style='font-family:verdana;font-size:10pt'>"_
		& "<P><BR>Email:<BR>"_
		& "<A HREF=""" & "mailto:" & myinfo.Email & """>" & myinfo.Email & "</A></Font>"
	End If
 End Sub

 Sub Phone
	If myinfo.Phone <> "" Then
		response.write "<FONT style='font-family:verdana;font-size:10pt'>"_
		& "<P><BR>Phone number:<BR>"_
		& myinfo.Phone & "</Font>"
	End If
 End Sub

 Sub faxPhone
	If myinfo.faxPhone <> ""Then
		response.write "<FONT style='font-family:verdana;font-size:10pt'>"_
		& "<P><BR>Fax number:<BR>"_
		& myinfo.faxPhone &"</FONT><BR>"
	End If
 End Sub

 Sub Address
	If myinfo.Name <> "" Then
		response.write "<P><BR>" & myinfo.Name & "<br>"
	End If
    If myinfo.Department <> "" Then 
        response.write "<FONT style='font-family:verdana;font-size:10pt'><P><BR>"_
	    & myinfo.Department & "</Font><BR>"
    End If
	DIM number
	number = 1
	For number = 1 to 4
		If myinfo("Address" & number) <> "" Then
			response.write "<FONT style='font-family:verdana;font-size:10pt'><P><BR>"_
			& myinfo("Address" & number) & "</Font>"
		End If
	Next
 End Sub

	'*** Headings & paragraphs
 Function Heading(num)
	Dim strHeading
	strHeading = "<P><BR><FONT face='Verdana'><B>"
	If myinfo("Heading" & num) <> "" Then
		strHeading = strHeading & myinfo("Heading" & num) & "<BR>"
	End If
	strHeading = strHeading & "</B></FONT><FONT face='Verdana' size='-1'>"
	If myinfo("Words" & num) <> "" Then
		strHeading = strHeading & myinfo("Words" & num)
	End If
	strHeading = strHeading & "</FONT>"
	Heading = strHeading
 End Function
	'*** IE LOGO
 Sub ie_logo
	response.write "<CENTER><BR><a href='http://www.microsoft.com/ie'>"_
    & "<img src='/IISSamples/Default/IE.GIF' alt='Download Internet Explorer!' width='88' height='31' border=0></a>"_
	& "</CENTER>"
 End Sub

	'*** Navigation buttons for Guestbook and Administration pages.
 Sub navigationButtons
	If intMessageID <> "" Then
 		response.write "<TR><TD ALIGN='center' colspan='6'>"
		rst.MovePrevious
		If not rst.BOF Then
			response.write FormSubmit("SUBMIT", "prev", "<<")
		End If
		rst.MoveNext
			If page_Admin = "True" Then			' Add delete button to admin page.
				response.write FormSubmit("SUBMIT", "delete", "Delete message")
			Else
				response.write "&nbsp;&nbsp;&nbsp;"
			End If
		rst.MoveNext
		If not rst.EOF Then
			response.write FormSubmit("SUBMIT", "next", ">>")
		End If
		rst.MovePrevious
		response.write FormSubmit("HIDDEN", "MessageID", rst("MessageID"))
		response.write "</TD></TR><TR><TD Colspan=6><B>"
		If MessagePrivate ="True" Then
			response.write "<A HREF='admin.asp?private=True'>Return to the " & L_Dropbox & "</A><BR>"
		Else
			response.write "<A HREF='admin.asp?private=False&strQuery=" & strQuery & "'>Return to the " & L_Guestbook & "</A><BR>"_
		End If
	Else
		response.write "<TR><TD Colspan=3><B>"
		If MessagePrivate <> "True" Then
			response.write "<A HREF='qbe.asp'>New Query</A><BR>"
		End If
	End If
		response.write "<A HREF='default.asp'>Web Site</A></B></TD></TR>"
 End Sub
	'*** Guestbook and Administration pages:  Table of messages.
 Sub buildTable
 	Set rst = Session("rst")
	 If rst.EOF Then
 		If intMessageID <> "" Then
			response.Write "<TR><TD Colspan='3'>There are no more messages.</TD></TR>"
		ElseIf request.QueryString("MessageDateLimit") <> "" Then
			response.Write "<TR><TD Colspan='3'>There are no messages that meet your criteria.</TD></TR>"
		Else
			response.Write "<TR><TD BGColor='#FFFFFF' Colspan='3'>There are no entries in your "
			If MessagePrivate = "False" Then
				response.write L_Guestbook
			Else
				response.write L_Dropbox
			End If
			response.write ".</TD></TR>"
		End If
	 ElseIf intMessageID <> "" Then
 		Dim col1Cell
		Dim col5Cell
		Dim colFont
		col5Cell = "<TD  BGColor='#FFFFFF' ALIGN=left VALIGN=TOP COLSPAN=5><FONT style='font-family:verdana;font-size:8pt'>"
		col1Cell = "<TD  BGColor='#FFFFFF' ALIGN=right VALIGN=TOP COLSPAN=1><FONT style='font-family:verdana;font-size:10pt'>"
		Response.Write "<TR>"_
		& col1Cell & "<B>Date:</B></FONT></TD>"_
		& col5Cell & rst("MessageDate") & "</TD></TR>"_
		& "<TR>" & col1Cell & "<B>Name:</B></FONT></TD>"_
		& col5Cell & rst("MessageFrom") & "</FONT></TD></TR>"_
		& "<TR>" & col1Cell & "<B>Email:</B></FONT></TD>"_
		& col5Cell & "<A HREF='mailto:" & rst("Email") & "'>" & rst("Email") & "</A></FONT></TD></TR>"_
		& "<TR>" & col1Cell & "<B>Home page:</B></FONT></TD>"_
		& col5Cell  & "<A HREF='" & rst("URL") & "'>" & rst("URL") & "</A></FONT></TD></TR>"_
		& "<TR>" & col1Cell & "<B>Subject:</B></FONT></TD>"_
		& col5Cell  & rst("MessageSubject") & "</FONT></TD></TR>"_
		& "<TR>" & col1Cell & "<B>Message:</B></FONT></TD>"_
		& col5Cell & "<FONT SIZE='-1' FACE='arial','helvetica'>" & rst("MessageBody") & "</FONT></TD>"_
		& "</TR><TR><TD HEIGHT=5 Colspan=6>" & FormSubmit( "HIDDEN", "private", MessagePrivate ) & "</TD></TR>"
	Else
		tableCell = "<TD ALIGN=LEFT VALIGN=TOP BGColor='#FFFFFF'><FONT style='font-family:verdana;font-size:10pt'>"
		Response.Write "<TR><TD BGColor='#cccccc' WIDTH=125>"_
		& FormSubmit( "SUBMIT", "sort", "sort by date" )_
		& "</TD><TD BGColor='#cccccc'>"_
		& FormSubmit( "SUBMIT", "sort", "sort by author" )_
		& "</TD><TD BGColor='#cccccc'>"_
		& FormSubmit( "SUBMIT", "sort", "sort by subject" )_
		& FormSubmit( "HIDDEN", "private", MessagePrivate )_
		& "</TD></TR><TR><TD HEIGHT=1 Colspan=3 BGColor='#FFFFFF'></TD></TR>"
		count = 1
		Do UNTIL rst.EOF
			Response.Write "<TR>" & tableCell & rst("MessageDate") & "</A></FONT></TD>"_
			& tableCell & "<A HREF=""" & "admin.asp?message=" & rst("MessageID") & "&count=" & count & "&private=" & rst("MessagePrivate") & """>" & rst("MessageFrom") & "</A></FONT></TD>"_
			& tableCell & "<A HREF=""" & "admin.asp?message=" & rst("MessageID") & "&count=" & count & "&private=" & rst("MessagePrivate") & """>" & rst("MessageSubject") & "</A></FONT></TD>"
			rst.MoveNext
			Response.Write "</TR><TR><TD HEIGHT=1 Colspan=3></TD></TR>"
			count = count + 1
		Loop
	End If
 End Sub

'	***	Creates input buttons.
 Function FormSubmit( t, name, value )
	Dim btnSubmit
	btnSubmit = "<INPUT TYPE=""" & t & """ NAME=""" & name & """ VALUE=""" & value & """>"
	FormSubmit = btnSubmit
 End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\journal\layout.inc ===
<%
If myinfo.Theme = "journal" Then
	'	$Date: 9/11/97 6:07p $
	'	$ModTime: $
	'	$Revision: 15 $
	'	$Workfile: layout.inc $	
	response.write "<TABLE width='100%' height='100%' cellpadding='0'"_
	& " cellspacing='0' border='0'><TR>"
'				******************* Right  Column  *************
	response.write "<TD Valign=top align=left Width=200 class='bg1'>"
	call page_datetime	'Writes local date and time
	call page_messaging	'Writes guestbook and dropbox links
	call file_check		'Checks for published files
	call page_links		'Writes favorites links
'				******************* Center Column  *************
	response.write "</TD><TD Width='25' rowspan=2 class='bg2' Background='/iissamples/homepage/themes/journal/rip2_2.gif' BGColor='#8080FF'>&nbsp;</TD>"
'               ******************* Right  Column  *************
	'***BGColor and Background tag fixes an IE3 StyleSheet problem. 
	response.write "<TD Valign='TOP' Align='left' rowspan=2 BGColor='#8080FF'>"_
	& "<TABLE border=0 width='100%' height='100%' cellpadding='0' cellspacing='0'><TR>"_
	& "<TD Colspan=2 Height=63 VAlign='top' class='bg3' Background='/iissamples/homepage/themes/journal/rip3.gif'>"_
	& "<CENTER><FONT Style='font-size: 36pt; font-family:Verdana;font-weight: bold'>"
	If Len(myinfo.Title) > 6 then
		response.write "<H3>"
	End If
	call Title
	If Len(myinfo.Title) > 6 then
		response.write "</H3>"
	End If	
	response.write "</FONT></CENTER></TD></TR>"_
	& "<TR><TD Valign=top align=left Colspan='2'>"
	call layout_Email		'Writes email address
	response.write "</TD></TR><TR><TD>"
	call Phone		'Writes telephone number
	response.write "</TD><TD>"
	call faxPhone	'Writes fax number
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Address	'Writes address
	DIM num
	For num = 1 to 4
	response.write "</TD></TR><TR><TD Colspan=2>"
	response.write Heading(num)
	Next
	response.write "</TD></TR></TABLE></TD></TR>"_
	& "<TR><TD height=32 Align=center class=bg1>"
	call ie_logo	'Places IE logo and link on page
	response.write "</TD></TD></TR></TABLE>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\journal\setup.inc ===
<!--
		$Date: 9/24/97 8:53p $
		$ModTime: $
		$Revision: 8 $
		$Workfile: setup.inc $
        Journal
	-->
<%
 If myinfo.Theme = "journal" Then
'				******************* GENERIC CONTENTS  *************
'									Left Column
    response.write "<TD Valign=top align=left Width=200 class=bg1>"_
    & "<FORM NAME='Template' ACTION='template.asp' METHOD='POST'>"
	call page_datetime
    call Template_page_messaging
	call Template_page_links
	response.write "</TD>"
'									Center Column

	response.write "<TD Width='20' class=bg2 Valign=top rowspan=2>"_
	& "&nbsp;</TD>"_

'				******************* SPECIFIC CONTENTS *************
'									Right Column
	response.write "<TD Valign='TOP' Align='left' rowspan=2>"_
	& "<TABLE border=0 width='100%' height='100%' cellpadding='0' cellspacing='0'><TR>"_
	& "<TD Valign='TOP' class='bg3' Colspan=2>"
	call Template_title
	response.write "</TD></TR><TR>"_
	& "<TD Valign=top align=left Colspan=2>"
	call Template_Name
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Template_Email
	response.write "</TD></TR><TR><TD>"
	call Template_Phone
	response.write "</TD><TD>"
	call Template_faxPhone
	response.write "</TD></TR><TR><TD Colspan=2>"
	call Template_address
	response.write "</TD></TR><TR><TD Colspan=2>"_
	& 	Template_Heading()_ 
	& "</TD></TR><TR><TD Colspan=2>"_
    & "<INPUT TYPE='hidden' NAME='contents' Value='-1'>"_
    & "<Center><INPUT TYPE=SUBMIT VALUE='enter new changes'>"_
	& "</Center></FORM></TD></TR></TABLE>"
'				************ Last Row **************
	response.write "<TR><TD height=32 Align=center class=bg1>"
	call ie_logo
	response.write "</TD>"
 End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\looseleaf\setup.inc ===
<!--
		$Date: 9/24/97 8:51p $
		$ModTime: $
		$Revision: 9 $
		$Workfile: setup.inc $
        Looseleaf
	-->
<%
 If myinfo.Theme = "looseleaf" Then
'				******************* Theme 1 contents  *************
    response.write "<TD Valign=top Align=center class=bg1 Colspan=2>"_
    	& "<FORM NAME='Template' ACTION='template.asp' METHOD='POST'>"
	call Template_title
	response.write "</TD></TR><TR><TD Valign=top align=center Colspan=2>"
	 call page_datetime
   	response.write "</TD></TR><TR><TD align=center Colspan=2>"
    	call Template_page_messaging
   	response.write "</TD></TR><TR><TD align=center Colspan=2>"
	call Template_Name
	response.write "</TD></TR><TR><TD align=center Colspan=2>"
	call Template_Email
	response.write "</TD></TR><TR><TD align=center>"
	call Template_Phone
	response.write "</TD><TD align=center>"
	call Template_faxPhone
	response.write "</TD></TR><TR><TD align=center Colspan=2>"
	call Template_address
	response.write "</TD></TR><TR><TD align=center Colspan=2>"_
	& 	Template_Heading()_ 
	& "</TD></TR><TR><TD align=center Colspan=2>"_
    & "<INPUT TYPE='hidden' NAME='contents' Value='-1'>"_
    & "<Center><INPUT TYPE=SUBMIT VALUE='enter new changes'>"_
	& "</Center></FORM></TD></TR></TABLE>"
'				**************************************************
	 response.write "<TABLE border=0 Width='100%'"_
	 & " BGColor='#FFFFFF'>"_
	 & "<TR><TD Align=center valign=top BGColor='#FFFFFF'>"
	 call Template_page_links
	 response.write "</TD></TR>"_ 
	 & "<TR><TD height=32 Align=center BGColor='#FFFFFF'>"
	 call ie_logo
	 response.write "</TD>"
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\looseleaf\layout.inc ===
<%
 If myinfo.Theme = "looseleaf" Then
	response.write "<FONT FACE='VERDANA' SIZE='-2'>"
	'	$Date: 9/11/97 5:07p $
	'	$ModTime: $
	'	$Revision: 8 $
	'	$Workfile: layout.inc $
	response.write "<TABLE width='100%' height='100%' "_
    & "cellpadding='0' cellspacing='0' border='0' BGColor='#FFFFFF'>"
'				******************* CONTENTS *************
    response.write "<TR><TD Valign='TOP' Colspan=2 Align=center><H1>"
	 call Title
    response.write "</H1></TD></TR><TR><TD Valign=top Align=center Colspan=2>"
     call page_datetime
    response.write "<BR>"
	 call page_messaging
	 call file_check		'Checks for published files
    response.write "</TD></TR>"_

	& "<TR><TD Valign=top Align=center Colspan=2>"
	call layout_Email
	response.write "</TD></TR><TR><TD Align=center>"
	call Phone
	response.write "</TD><TD Align=center>"
	call faxPhone
	response.write "</TD></TR><TR><TD Colspan=2 Align=center>"
	call Address
	For num = 1 to 4
	response.write "</TD></TR><TR><TD Colspan=2 Align=center>"
	response.write Heading(num)
	Next
	response.write "</TD></TR><TR><TD Colspan=2 Align=center>"
     call page_links
	response.write "</TD></TR><TR><TD Colspan=2 Align=center>"
	call ie_logo
	response.write "</TD></TD></TR></TABLE></FONT>"
 End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\apiutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    apiutil.h

Abstract:

    Common internet server functions.

Author:

    Murali R. Krishnan  (MuraliK)    15-Sept-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Revision History:

--*/


#ifndef _APIUTIL_HXX_
#define _APIUTIL_HXX_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus


#ifdef MIDL_PASS
# define RPC_STATUS   long
#else 
# include <rpc.h>
#endif // MIDL_PASS


//
//  RPC utilities
//

# define PROT_SEQ_NP_OPTIONS_W    L"Security=Impersonation Dynamic False"


extern PVOID
MIDL_user_allocate( IN size_t Size);

extern VOID
MIDL_user_free( IN PVOID pvBlob);


extern RPC_STATUS 
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       );

extern RPC_STATUS
RpcBindHandleFree( IN OUT handle_t * pBindingHandle);


# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _APIUTIL_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\comadmii.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Mon Sep 28 15:19:52 1998
 */
/* Compiler settings for comadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICOMAdminCatalog = {0xDD662187,0xDFC2,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_COMAdmin = {0xF618C513,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalog = {0xF618C514,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogObject = {0xF618C515,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogCollection = {0xF618C516,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\atq.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ_H_
#define _ATQ_H_


#ifdef __cplusplus
extern "C" {
#endif


// Include Standard headers

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <winsock2.h>
# include <mswsock.h>
# include <uspud.h>
# include <iscaptrc.h>

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif


/*++
  ATQ API Overview:

  Global per module:
     AtqInitialize()
     AtqTerminate()

     AtqGetCompletionPort()
     AtqGetInfo()
     AtqSetInfo()

  ATQ Endpoint functions:
     AtqCreateEndpoint()
        AtqStartEndpoint()
        AtqEndpointGetInfo()
        AtqEndpointSetInfo()
        AtqStopCloseEndpoint()
     AtqCloseCloseEndpoint()

     AtqStopAndCloseEndpoint()  <-- soon to be killed
  Per ATQ Context Functions:
     AtqAddAsyncHandle()  <-- for non AcceptEx() sockets

     AtqGetAcceptExAddrs()       <-- for AcceptEx() sockets

     AtqContextSetInfo()

     AtqCloseFileHandle()
     AtqCloseSocket()
     AtqFreeContext()

  Bandwidth Throttler Functions:
     AtqCreateBandwidthInfo()
     AtqFreeBandwidthInfo()
     AtqBandwidthSetInfo()
     AtqBandwidthGetInfo()

  IO Functions:

     AtqReadFile()
     AtqWriteFile()
     AtqReadSocket()
     AtqWriteSocket()
     AtqTransmitFile()
     AtqTransmitFileAndRecv()
     AtqSendAndRecv()

  Utility Functions:

     AtqCreateFileW()
     AtqSpudInitialized()
     AtqReadDirChanges()
     AtqPostCompletionStatus()


--*/


/*----------------------------------------------------------
  Registry Parameters used by ATQ during AtqInitialize()
  ATQ loads some of the parameters from
  HKLM\System\CurrentControlSet\Services\InetInfo\Parameters

  Most of these parameters are for INTERNAL ANALYSIS and
   development/testing. Setup should not install values
   for the same. Setup can include values for items marked SETUP.
------------------------------------------------------------*/

// Names

#define ATQ_REG_PER_PROCESSOR_ATQ_THREADS TEXT("MaxPoolThreads")
#define ATQ_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit") // SETUP
#define ATQ_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define ATQ_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define ATQ_REG_USE_ACCEPTEX              TEXT("UseAcceptEx")
#define ATQ_REG_USE_KERNEL_APC            TEXT("UseKernelApc")
#define ATQ_REG_MIN_KB_SEC                TEXT("MinFileKbSec")    // SETUP
#define ATQ_REG_LISTEN_BACKLOG            TEXT("ListenBacklog")   // SETUP
#define ATQ_REG_ENABLE_DEBUG_THREADS      TEXT("EnableDebugThreads")
#define ATQ_REG_DISABLE_BACKLOG_MONITOR   TEXT("DisableBacklogMonitor")
#define ATQ_REG_FORCE_TIMEOUT             TEXT("ForceTimeout")

// Default Values

#define ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS         (4)
// special value of 0 means that system will determine this dynamically.
#define ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY         (0)
#define ATQ_REG_DEF_USE_KERNEL_APC                    (1)
#define ATQ_REG_DEF_MAX_UNCONNECTED_ACCEPTEX          (1024)

//
// thread limit settings
//

#define ATQ_REG_MIN_POOL_THREAD_LIMIT                 (64)
#define ATQ_REG_DEF_POOL_THREAD_LIMIT                 (128)
#define ATQ_REG_MAX_POOL_THREAD_LIMIT                 (256)

//
// THREAD_TIMEOUTs are high to prevent async ios from being cancelled
//  when the thread goes away.
//

#define ATQ_REG_DEF_THREAD_TIMEOUT                    (30 * 60)    // thirty minutes
#define ATQ_REG_DEF_USE_ACCEPTEX                      (TRUE)
#define ATQ_REG_DEF_MIN_KB_SEC                        (1000)  // 1000 bytes
#define ATQ_REG_DEF_LISTEN_BACKLOG                    (25)

//
// fake xmit file buffer size
//

#define ATQ_REG_DEF_NONTF_BUFFER_SIZE                 (4096)


/*----------------------------------------------------------
  Global Functions of ATQ module
-----------------------------------------------------------*/

// Flags for AtqInitialize()
# define ATQ_INIT_SPUD_FLAG          (0x00000001)

BOOL
AtqInitialize(
    IN DWORD dwFlags
    );

BOOL
AtqTerminate(
    VOID
    );

dllexp
HANDLE
AtqGetCompletionPort();

/*
 *  Sets various context information in Atq Module for global modifications
 *
 *
 *  Bandwidth Throttle:   Sets the throttle level in Bytes/Second.
 *        If INFINITE, then it is assumed that
 *                      there is no throttle value (default)
 *
 *  Max Pool Threads: Sets the maximum number of pool threads Atq will allow
 *        to be created per processor
 *
 *  MaxConcurrency: tells how many threads to permit per processor
 *
 *  Thread Timeout: Indicates how long a thread should be kep alive
 *        waiting on GetQueuedCompletionStatus() before commiting suicide
 *        (in seconds)
 *
 *  Inc/Dec max pool threads: If a server will be doing extended processing
 *        in an ATQ pool thread, they should increase the max pool threads
 *        while the extended processing is occurring.  This prevents starvation
 *        of other requests
 *
 *  AtqMinKbSec: set the assumed minimum KB per second for AtqTransmitFile()
 *        This value is used in calculating the timeout for file transfer
 *        operation
 *
 */

typedef enum _ATQ_INFO {

    AtqBandwidthThrottle = 0,
    AtqExitThreadCallback,
    AtqMaxPoolThreads,    // per processor values
    AtqMaxConcurrency,    // per processor concurrency value
    AtqThreadTimeout,
    AtqUseAcceptEx,       // Use AcceptEx if available
    AtqIncMaxPoolThreads, // Up the max thread count
    AtqDecMaxPoolThreads, // Decrease the max thread count
    AtqMinKbSec,          // Minimum assumed transfer rate for AtqTransmitFile
    AtqBandwidthThrottleMaxBlocked,  // Max number of blocked requests
    AtqMaxThreadLimit,    // absolute maximum number of threads
    AtqAvailableThreads   // Number of available threads
} ATQ_INFO;

//
// ATQ_THREAD_EXIT_CALLBACK
// Type of callback function to be called when an ATQ thread exits so
// that the user of ATQ may clen up thread specific data.
//

typedef
VOID
(*ATQ_THREAD_EXIT_CALLBACK) ( VOID );


dllexp
ULONG_PTR
AtqSetInfo(
    IN ATQ_INFO atqInfo,
    IN ULONG_PTR Data
    );

dllexp
ULONG_PTR
AtqGetInfo(
    IN ATQ_INFO atqInfo
    );



typedef struct _ATQ_STATISTICS {

    DWORD  cAllowedRequests;
    DWORD  cBlockedRequests;
    DWORD  cRejectedRequests;
    DWORD  cCurrentBlockedRequests;
    DWORD  MeasuredBandwidth;

} ATQ_STATISTICS;


dllexp
BOOL AtqGetStatistics( IN OUT ATQ_STATISTICS * pAtqStats);

dllexp
BOOL AtqClearStatistics(VOID);




/*----------------------------------------------------------
  ATQ Endpoint functions
-----------------------------------------------------------*/

//
//  endpoint data
//

typedef enum _ATQ_ENDPOINT_INFO {

    EndpointInfoListenPort,
    EndpointInfoListenSocket,
    EndpointInfoAcceptExOutstanding

}  ATQ_ENDPOINT_INFO;



//
//  ATQ_COMPLETION
//  This is the routine that is called upon IO completion (on
//  error or success).
//
//  Context is the context passed to AtqAddAsyncHandle
//  BytesWritten is the number of bytes written to the file or
//      bytes written to the client's buffer
//  CompletionStatus is the WinError completion code
//  lpOverLapped is the filled in overlap structure
//
//  If the timeout thread times out an IO request, the completion routine
//  will be called by the timeout thread with IOCompletion FALSE and
//  CompletionStatus == ERROR_SEM_TIMEOUT.  The IO request is *still*
//  outstanding in this instance.  Generally it will be completed when
//  the file handle is closed.
//

typedef
VOID
(*ATQ_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        BytesWritten,
            IN DWORD        CompletionStatus,  // Win32 Error code
            IN OVERLAPPED * lpo
            );

//
// Type of callback function to be called when a new connection is established.
//  This function should be defined before including conninfo.hxx
//

typedef
VOID
(*ATQ_CONNECT_CALLBACK) (
                IN SOCKET sNew,
                IN LPSOCKADDR_IN pSockAddr,
                IN PVOID EndpointContext,
                IN PVOID EndpointObject
                );



typedef struct _ATQ_ENDPOINT_CONFIGURATION {

    //
    // Port to listen on.  If 0, system will assign
    //

    USHORT ListenPort;

    //
    // IP address to bind to. 0 (INADDR_ANY) == wildcard.
    //

    DWORD IpAddress;

    DWORD cbAcceptExRecvBuffer;
    DWORD nAcceptExOutstanding;
    DWORD AcceptExTimeout;

    //
    // Callbacks
    //

    ATQ_CONNECT_CALLBACK pfnConnect;
    ATQ_COMPLETION pfnConnectEx;
    ATQ_COMPLETION pfnIoCompletion;

} ATQ_ENDPOINT_CONFIGURATION, *PATQ_ENDPOINT_CONFIGURATION;

dllexp
PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    );

dllexp
BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    );

dllexp
ULONG_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    );

dllexp
ULONG_PTR
AtqEndpointSetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo,
    IN ULONG_PTR Info
    );

dllexp
BOOL
AtqStopEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqCloseEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqStopAndCloseEndpoint(
    IN PVOID Endpoint,
    IN LPTHREAD_START_ROUTINE lpCompletion,
    IN PVOID lpCompletionContext
    );



/*----------------------------------------------------------
  ATQ CONTEXT functions
-----------------------------------------------------------*/

//
//  This is the public portion of an ATQ Context.  It should be treated
//  as read only
//
//  !!! Changes made to this structure should also be made to
//  ATQ_CONTEXT in atqtypes.hxx !!!
//

typedef struct _ATQ_CONTEXT_PUBLIC {

    HANDLE         hAsyncIO;       // handle for async i/o object: socket/file
    OVERLAPPED     Overlapped;     // Overlapped structure used for IO

} ATQ_CONTEXT_PUBLIC, *PATQ_CONTEXT;


dllexp
BOOL
AtqAddAsyncHandle(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );


dllexp
VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    );


/*++
  AtqCloseSocket()

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

/*++
  AtqCloseFileHandle()

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

  patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    );


/*++

   AtqFreeContext()

   Routine Description:

     Frees the context created in AtqAddAsyncHandle.
     Call this after the async handle has been closed and all outstanding
     IO operations have been completed. The context is invalid after this call.
     Call AtqFreeContext() for same context only ONCE.

   Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

   Returns:
    None
--*/
dllexp
VOID
AtqFreeContext(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );




enum ATQ_CONTEXT_INFO
{
    ATQ_INFO_TIMEOUT = 0,       // Timeout rounded up to ATQ timeout interval
    ATQ_INFO_RESUME_IO,         // resumes IO as is after Timeout
    ATQ_INFO_COMPLETION,        // Completion routine
    ATQ_INFO_COMPLETION_CONTEXT,// Completion context
    ATQ_INFO_BANDWIDTH_INFO,    // Bandwidth Throttling Descriptor
    ATQ_INFO_ABORTIVE_CLOSE,    // do abortive close on closesocket
    ATQ_INFO_FORCE_CLOSE        // Always close the socket in AtqCloseSocket()
};

/*++

  AtqContextSetInfo()

  Routine Description:

    Sets various bits of information for this context

  Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

  Return Value:

    The old value of the parameter

--*/

dllexp
ULONG_PTR
AtqContextSetInfo(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN ULONG_PTR       data
    );




/*----------------------------------------------------------
  ATQ Context IO functions
-----------------------------------------------------------*/

/*++

Routine Description:

    Atq<Operation><Target>()

    <Operation> :=  Read | Write | Transmit
    <Target>    :=  File | Socket

    These functions just setup ATQ context and then call the corresponding
    Win32/WinSock function for submitting an asynchronous IO operation. By
    default the Socket functions support scatter/gather using WSABUF

    These functions are wrappers and should be called instead of the
     correpsonding Win32 API.  The one difference from the Win32 API is TRUE
     is returned if the error ERROR_IO_PENDING occurred, thus clients do not
     need to check for this case.

   The timeout time for the request is calculated by taking the maximum of
     the context's timeout time and bytes transferred based on 1k/second.

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API/WinSock APIs

    NOTES: AtqTransmitFile takes an additional DWORD flags which may contain
        the winsock constants TF_DISCONNECT and TF_REUSE_SOCKET

    AtqReadFile and AtqWriteFile take an optional overlapped structure if
    clients want to have multiple outstanding reads or writes.  If the value
    is NULL, then the overlapped structure from the Atq context is used.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
    sets ERROR_NETWORK_BUSY as error when the request needs to be rejected.

--*/

dllexp
BOOL
AtqReadFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqReadSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo  OPTIONAL
    );

/*
 *  Code for reading into single buffer will look like the following.
 * {
 *   WSABUF wsaBuf = { (BytesToRead), (lpBuffer)};
 *   fRet = AtqReadSocket( patqContext, &wsaBuf, 1, lpo);
 * }
 */

dllexp
BOOL
AtqWriteFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqWriteSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo OPTIONAL
    );


dllexp
BOOL
AtqSyncWsaSend(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    );

// Note: This API always causes the complete file to be sent.
// If you want to change the behaviour store the appropriate offsets
//   in the ATQ_CONTEXT::Overlapped object. Or use AtqTransmitFileEx
dllexp
BOOL
AtqTransmitFile(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags      // TF_DISCONNECT, TF_REUSE_SOCKET
    );

dllexp
BOOL
AtqTransmitFileEx(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags,      // TF_DISCONNECT, TF_REUSE_SOCKET
    IN  OVERLAPPED *            lpo
    );

dllexp
BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    );

dllexp
BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    );


/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

typedef
VOID
(*ATQ_OPLOCK_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        Status
            );


dllexp
HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    PSPUD_FILE_INFORMATION pFileInfo
    );

dllexp
BOOL
AtqSpudInitialized(
    VOID
    );

dllexp
BOOL
AtqReadDirChanges(PATQ_CONTEXT patqContext,
                  LPVOID       lpBuffer,
                  DWORD        BytesToRead,
                  BOOL         fWatchSubDir,
                  DWORD        dwNotifyFilter,
                  OVERLAPPED * lpo );



/*++

  AtqPostCompletionStatus()

  Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

  Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

  Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

dllexp
BOOL
AtqPostCompletionStatus(
    IN     PATQ_CONTEXT patqContext,
    IN     DWORD        BytesTransferred
    );




/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

/*++

   Bandwidth Throttling Support

   The following items are used in the support for bandwidth throttling
--*/

enum ATQ_BANDWIDTH_INFO
{
    ATQ_BW_BANDWIDTH_LEVEL = 0,
    ATQ_BW_MAX_BLOCKED,
    ATQ_BW_STATISTICS,
    ATQ_BW_DESCRIPTION,
};

/*++

  AtqCreateBandwidthInfo()

  Routine Description:

    Allocate and opaque bandwidth descriptor

  Arguments:

    None

  Return Value:

    Pointer to descriptor.  NULL if failed.

--*/
dllexp
PVOID
AtqCreateBandwidthInfo(
    VOID
    );

/*++

  AtqFreeBandwidthInfo()

  Routine Description:

    Triggers the destruction of a bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to valid descriptor

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqFreeBandwidthInfo(
    IN     PVOID               pvBandwidthInfo
    );

/*++

  AtqBandwidthSetInfo()

  Routine Description:

    Set properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    Data - value of property

  Return Value:

    Old value of property

--*/
dllexp
ULONG_PTR
AtqBandwidthSetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    IN     ULONG_PTR            Data
    );

/*++

  AtqBandwidthGetInfo()

  Routine Description:

    Get properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    pData - filled in with value of property

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqBandwidthGetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    OUT    ULONG_PTR *          pData
    );

/*++

  AtqSetSocketOption()

  Routine Description:

    Set socket options. Presently only handles TCP_NODELAY

  Arguments:

    patqContext - pointer to ATQ context
    optName     - name of property to change
    optValue    - value of property to set

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqSetSocketOption(
    IN     PATQ_CONTEXT     patqContext,
    IN     INT              optName,
    IN     INT              optValue
    );

dllexp
PIIS_CAP_TRACE_INFO
AtqGetCapTraceInfo(
    IN     PATQ_CONTEXT     patqContext
);

#ifdef __cplusplus
}
#endif

#endif // !_ATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\comrepl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed Jan 27 09:33:39 1999
 */
/* Compiler settings for comrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comrepl_h__
#define __comrepl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICOMReplicateCatalog_FWD_DEFINED__
#define __ICOMReplicateCatalog_FWD_DEFINED__
typedef interface ICOMReplicateCatalog ICOMReplicateCatalog;
#endif  /* __ICOMReplicateCatalog_FWD_DEFINED__ */


#ifndef __ICOMReplicate_FWD_DEFINED__
#define __ICOMReplicate_FWD_DEFINED__
typedef interface ICOMReplicate ICOMReplicate;
#endif  /* __ICOMReplicate_FWD_DEFINED__ */


#ifndef __ReplicateCatalog_FWD_DEFINED__
#define __ReplicateCatalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class ReplicateCatalog ReplicateCatalog;
#else
typedef struct ReplicateCatalog ReplicateCatalog;
#endif /* __cplusplus */

#endif  /* __ReplicateCatalog_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mtxrepl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICOMReplicateCatalog_INTERFACE_DEFINED__
#define __ICOMReplicateCatalog_INTERFACE_DEFINED__

/* interface ICOMReplicateCatalog */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICOMReplicateCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98315904-7BE5-11d2-ADC1-00A02463D6E7")
    ICOMReplicateCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LONG lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportSourceCatalogFiles( 
            /* [in] */ BSTR bstrSourceComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyCatalogFilesToTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallCatalogOnTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanupSource( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogFilePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ICOMReplicateCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ LONG lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportSourceCatalogFiles )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrSourceComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyCatalogFilesToTarget )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallCatalogOnTarget )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupSource )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFilePath )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile);
        
        END_INTERFACE
    } ICOMReplicateCatalogVtbl;

    interface ICOMReplicateCatalog
    {
        CONST_VTBL struct ICOMReplicateCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMReplicateCatalog_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOMReplicateCatalog_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define ICOMReplicateCatalog_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define ICOMReplicateCatalog_GetTypeInfoCount(This,pctinfo)     \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICOMReplicateCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)      \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICOMReplicateCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICOMReplicateCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)      \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICOMReplicateCatalog_Initialize(This,lOptions)  \
    (This)->lpVtbl -> Initialize(This,lOptions)

#define ICOMReplicateCatalog_ExportSourceCatalogFiles(This,bstrSourceComputer)  \
    (This)->lpVtbl -> ExportSourceCatalogFiles(This,bstrSourceComputer)

#define ICOMReplicateCatalog_CopyCatalogFilesToTarget(This,bstrTargetComputer)  \
    (This)->lpVtbl -> CopyCatalogFilesToTarget(This,bstrTargetComputer)

#define ICOMReplicateCatalog_InstallCatalogOnTarget(This,bstrTargetComputer)    \
    (This)->lpVtbl -> InstallCatalogOnTarget(This,bstrTargetComputer)

#define ICOMReplicateCatalog_CleanupSource(This)        \
    (This)->lpVtbl -> CleanupSource(This)

#define ICOMReplicateCatalog_GetLogFilePath(This,pbstrLogFile)  \
    (This)->lpVtbl -> GetLogFilePath(This,pbstrLogFile)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_Initialize_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ LONG lOptions);


void __RPC_STUB ICOMReplicateCatalog_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_ExportSourceCatalogFiles_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrSourceComputer);


void __RPC_STUB ICOMReplicateCatalog_ExportSourceCatalogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_CopyCatalogFilesToTarget_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicateCatalog_CopyCatalogFilesToTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_InstallCatalogOnTarget_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicateCatalog_InstallCatalogOnTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_CleanupSource_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This);


void __RPC_STUB ICOMReplicateCatalog_CleanupSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_GetLogFilePath_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLogFile);


void __RPC_STUB ICOMReplicateCatalog_GetLogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICOMReplicateCatalog_INTERFACE_DEFINED__ */


#ifndef __ICOMReplicate_INTERFACE_DEFINED__
#define __ICOMReplicate_INTERFACE_DEFINED__

/* interface ICOMReplicate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICOMReplicate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52F25063-A5F1-11d2-AE04-00A02463D6E7")
    ICOMReplicate : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrSourceComputer,
            /* [in] */ LONG lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportSourceCatalogFiles( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTargetStatus( 
            /* [in] */ BSTR bstrTargetComputer,
            /* [out] */ LONG __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrMaster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyFilesToTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanupSourceShares( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogFile( 
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RollbackTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ICOMReplicateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOMReplicate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOMReplicate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICOMReplicate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrSourceComputer,
            /* [in] */ LONG lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportSourceCatalogFiles )( 
            ICOMReplicate __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetStatus )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer,
            /* [out] */ LONG __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrMaster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyFilesToTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupSourceShares )( 
            ICOMReplicate __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFile )( 
            ICOMReplicate __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        END_INTERFACE
    } ICOMReplicateVtbl;

    interface ICOMReplicate
    {
        CONST_VTBL struct ICOMReplicateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMReplicate_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOMReplicate_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define ICOMReplicate_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define ICOMReplicate_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICOMReplicate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)     \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICOMReplicate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICOMReplicate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)     \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICOMReplicate_Initialize(This,bstrSourceComputer,lOptions)      \
    (This)->lpVtbl -> Initialize(This,bstrSourceComputer,lOptions)

#define ICOMReplicate_ExportSourceCatalogFiles(This)    \
    (This)->lpVtbl -> ExportSourceCatalogFiles(This)

#define ICOMReplicate_GetTargetStatus(This,bstrTargetComputer,plStatus,pbstrMaster)     \
    (This)->lpVtbl -> GetTargetStatus(This,bstrTargetComputer,plStatus,pbstrMaster)

#define ICOMReplicate_CopyFilesToTarget(This,bstrTargetComputer)        \
    (This)->lpVtbl -> CopyFilesToTarget(This,bstrTargetComputer)

#define ICOMReplicate_InstallTarget(This,bstrTargetComputer)    \
    (This)->lpVtbl -> InstallTarget(This,bstrTargetComputer)

#define ICOMReplicate_CleanupSourceShares(This) \
    (This)->lpVtbl -> CleanupSourceShares(This)

#define ICOMReplicate_GetLogFile(This,pbstrLogFile)     \
    (This)->lpVtbl -> GetLogFile(This,pbstrLogFile)

#define ICOMReplicate_RollbackTarget(This,bstrTargetComputer)   \
    (This)->lpVtbl -> RollbackTarget(This,bstrTargetComputer)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_Initialize_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrSourceComputer,
    /* [in] */ LONG lOptions);


void __RPC_STUB ICOMReplicate_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_ExportSourceCatalogFiles_Proxy( 
    ICOMReplicate __RPC_FAR * This);


void __RPC_STUB ICOMReplicate_ExportSourceCatalogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_GetTargetStatus_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer,
    /* [out] */ LONG __RPC_FAR *plStatus,
    /* [out] */ BSTR __RPC_FAR *pbstrMaster);


void __RPC_STUB ICOMReplicate_GetTargetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_CopyFilesToTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_CopyFilesToTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_InstallTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_InstallTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_CleanupSourceShares_Proxy( 
    ICOMReplicate __RPC_FAR * This);


void __RPC_STUB ICOMReplicate_CleanupSourceShares_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_GetLogFile_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLogFile);


void __RPC_STUB ICOMReplicate_GetLogFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_RollbackTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_RollbackTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICOMReplicate_INTERFACE_DEFINED__ */



#ifndef __COMReplLib_LIBRARY_DEFINED__
#define __COMReplLib_LIBRARY_DEFINED__

/* library COMReplLib */
/* [helpstring][version][uuid] */ 

#define COMREPL_OPTION_REPLICATE_IIS_APPS               1
#define COMREPL_OPTION_MERGE_WITH_TARGET_APPS   2
#define COMREPL_OPTION_CHECK_APP_VERSION                4
#define COMREPL_OPTION_BACKUP_TARGET                    8
#define COMREPL_OPTION_LOG_TO_CONSOLE                   16

EXTERN_C const IID LIBID_COMReplLib;

EXTERN_C const CLSID CLSID_ReplicateCatalog;

#ifdef __cplusplus

class DECLSPEC_UUID("8C836AF9-FFAC-11D0-8ED4-00C04FC2C17B")
ReplicateCatalog;
#endif
#endif /* __COMReplLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\crypt32l.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypt32l.h
//
//  Contents:   Crypt32 static library
//              API Prototypes and Definitions
//
//  APIs:       Crypt32DllMain
//
//  NB: This header is for temporary use only, with the static library
//      form of crypt32 (crypt32l).  It should not be used after IE4 ships,
//      since then the correct action will be to use the dll form of crypt32.
//
//--------------------------------------------------------------------------

#ifndef _CRYPT32L_H_
#define _CRYPT32L_H_


//+-------------------------------------------------------------------------
//
//  Function:  Crypt32DllMain
//
//  Synopsis:  Initialize the Crypt32 static library code
//
//  Returns:   FALSE iff failed
//
//  Notes:
//      If crypt32l.lib is linked with an exe, call
//          Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)
//      at the start of main() and
//          Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)
//      at the end of main().
//
//      If linking with a dll, call Crypt32DllMain from the dll's init
//      routine, passing it the same args as were passed to the init routine.
//
//--------------------------------------------------------------------------
BOOL
WINAPI
Crypt32DllMain(
    HMODULE hInstDLL,
    DWORD   fdwReason,
    LPVOID  lpvReserved
    );


#endif //_CRYPT32L_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\comrepl_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed Jan 27 09:33:39 1999
 */
/* Compiler settings for comrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICOMReplicateCatalog = {0x98315904,0x7BE5,0x11d2,{0xAD,0xC1,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const IID IID_ICOMReplicate = {0x52F25063,0xA5F1,0x11d2,{0xAE,0x04,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const IID LIBID_COMReplLib = {0x98315905,0x7BE5,0x11d2,{0xAD,0xC1,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const CLSID CLSID_ReplicateCatalog = {0x8C836AF9,0xFFAC,0x11D0,{0x8E,0xD4,0x00,0xC0,0x4F,0xC2,0xC1,0x7B}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\mechanical\layout.inc ===
<%
 If myinfo.Theme = "mechanical" Then
'	$Date: 11/24/97 11:59a $
'	$ModTime: $
'	$Revision: 1 $
'	$Workfile: layout.inc $
'	mechanical
%>
<table border=0 cellpadding=10 cellspacing=0 width=100% HEIGHT=100%>
<TR>
<TD valign=top width="60%" BGColor="#FFFFE4" class=bgpale>
<%
	response.write "<SPAN Class=headerb>" & ThmSalutation() & "</SPAN><BR><BLOCKQUOTE>" & ThmDate() & "<BR>" & ThmTime()_
	& "</BLOCKQUOTE><P>"
%>
<CENTER>
<img src="/iissamples/homepage/themes/mechanical/dotline.gif" width=490 height=20 border=0>
</CENTER><p>
<%
	For z = 1 to 4
		response.write Heading(z) & "<P>"
	Next
%>
</SPAN></FONT>
</TD>
<TD valign=top WIDTH="40%" BGColor="#5B0012" class=bgred>
<%
 If myinfo.Name <> "" OR myinfo.Email <> "" OR myinfo.faxphone <> "" OR myinfo.Department <>"" Then
	response.write "<IMG SRC='/iissamples/homepage/themes/mechanical/dot.gif' width=10 height=10>"_
	& "<SPAN class=headerw> Contact information:</SPAN><BR>"_
	& "<SPAN class=medw>" & thmName() & "<BR>" & thmDept() & "<BR>"_
	& thmAddr() & "<BR>" & thmPhone() & "<BR>" & thmFax() & "<BR>" & thmEmail() & "</SPAN>"_
	& "<BR>"_
	& "<img src='/iissamples/homepage/themes/mechanical/trans.gif' width=1 height=10 border=0><BR>"
 End If
 response.write "<IMG SRC='/iissamples/homepage/themes/mechanical/dot.gif' width=10 height=10> "_
 & "<SPAN class=headerw> While you are here...</SPAN><BR>"_
 &  thmGuest() & "<BR>"_
 & thmDrop() & "<BR>"
 call file_check
%>
 <img src="/iissamples/homepage/themes/mechanical/trans.gif" width=1 height=10 border=0><P>
<%
	If myinfo.intUrl <> "" Then
		response.write "<IMG SRC='/iissamples/homepage/themes/mechanical/dot.gif' width=10 height=10> "_
		& "<SPAN class=headerw>My favorite links:</SPAN><BR>"
		call urlArray
	End If
%>
 <img src="/iissamples/homepage/themes/mechanical/trans.gif" width=10 height=25 border=0><br>

</SPAN></FONT>
<P></TD>
</TR><TR><TD BGColor="#FFFFE4" class=bgpale>&nbsp;</TD><TD BGColor="#5B0012" class=bgred>
<%
	call IE_Logo
%>
</TR></TABLE>
<%
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\sdksamp\asp\docs\libcodebrws.inc ===
<%
	Function fMin(iNum1, iNum2)
		If iNum1 = 0 AND iNum2 = 0 Then
			fMin = -1
		ElseIf iNum2 = 0 Then
			fMin = iNum1
		ElseIf iNum1 = 0 Then
			fMin = iNum2
		ElseIf iNum1 < iNum2 Then
			fMin = iNum1
		Else 
			fMin = iNum2
		End If
	End Function
%>

<%
	Function fCheckLine (ByVal strLine)
		Dim iTemp, iPos
		fCheckLine = 0
		iTemp = 0

		iPos = InStr(strLine, "<" & "%")
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 1
		End If

		iPos = InStr(strLine, "%" & ">")
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 2
		End If

		iPos = InStr(1, strLine, "<" & "SCRIPT", 1)
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 3
		End If

		iPos = InStr(1, strLine, "<" & "/SCRIPT", 1)
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 4
		End If

		iPos = InStr(1, strLine, "<" & "!--", 1)
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 5
		End If

		iPos = InStr(1, strLine, "-" & "->", 1)
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 6
		End If

		iPos = InStr(1, strLine, "'", 1)
		If fMin(iTemp, iPos) = iPos Then
			iTemp = iPos
			fCheckLine = 7
		End If

	End Function
%>

<%
	Sub PrintHTML (ByVal strLine)
		Dim iPos, iSpaces, i
		iSpaces = Len(strLine) - Len(LTrim(strLine))
		i = 1
		
		While Mid(Strline, i, 1) = Chr(9)
			iSpaces = iSpaces + 5
			i = i + 1
		Wend
		
		If iSpaces > 0 Then
			For i = 1 to iSpaces
				Response.Write("&nbsp;")
			Next
		End If
		
		iPos = InStr(strLine, "<")
		If iPos Then
			Response.Write(Left(strLine, iPos - 1))
			Response.Write("&lt;")
			strLine = Right(strLine, Len(strLine) - iPos)
			Call PrintHTML(strLine)
		Else
			Response.Write(strLine)
		End If

	End Sub
%>

<%
	Sub PrintLine (ByVal strLine, iFlag)
		Dim iPos
		
		Select Case iFlag
		
			Case 0
				Call PrintHTML(strLine)

			Case 1
				iPos = InStr(strLine, "<" & "%")
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("<FONT COLOR=" & strServerSideColor & ">")
				Response.Write("&lt;%")
				strLine = Right(strLine, Len(strLine) - (iPos + 1))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 2
				iPos = InStr(strLine, "%" & ">")
				Call PrintHTML(Left(strLine, iPos -1))
				Response.Write("%&gt;")
				Response.Write("</FONT>")
				strLine = Right(strLine, Len(strLine) - (iPos + 1))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 3
				iPos = InStr(1, strLine, "<" & "SCRIPT", 1)
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("<FONT COLOR=" & strClientSideColor & ">")
				Response.Write("&lt;SCRIPT")
				strLine = Right(strLine, Len(strLine) - (iPos + 6))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 4
				iPos = InStr(1, strLine, "<" & "/SCRIPT>", 1)
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("&lt;/SCRIPT&gt;")
				Response.Write("</FONT>")
				strLine = Right(strLine, Len(strLine) - (iPos + 8))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 5
				iPos = InStr(1, strLine, "<" & "!--", 1)
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("<FONT COLOR=" & strCommentsColor & ">")
				Response.Write("&lt;!--")
				strLine = Right(strLine, Len(strLine) - (iPos + 3))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 6
				iPos = InStr(1, strLine, "-" & "->", 1)
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("--&gt;")
				Response.Write("</FONT>")
				strLine = Right(strLine, Len(strLine) - (iPos + 2))
				Call PrintLine(strLine, fCheckLine(strLine))

			Case 7
				iPos = InStr(1, strLine, "'", 1)
				Call PrintHTML(Left(strLine, iPos - 1))
				Response.Write("<FONT COLOR=" & strCommentsColor & ">")
				Response.Write(Right(strLine, Len(strline) - (iPos - 1)))
				Response.Write "</FONT>"

			Case Else
				Response.Write("Function Error -- Please contact the administrator.")
		
		End Select

	End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\dirmon.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Change notification

File: dirmon.h

Owner: cgrant

This is the header file for the CDirMonitor and CDirMonitorEntry classes.
===================================================================*/

#ifndef _DIRMON_H
#define _DIRMON_H

// TODO: We seem to need this pragma to base CDirMonitor on the
//		 CTypedHashTable template from IISRTL. We should find out
//		 why the compiler gives us this warning even if CTypedHashTable
//       is explcitly declared as __declspec(dlliimport)
#pragma warning(disable:4275)

// These declarations are needed to export the template classes from
// IATQ.DLL and import them into other modules.

// These definitions are used to manage the export/import declarations
// for the classes exported from the DIRMON module of ATQ.
#ifndef IATQ_DLLEXP
# ifdef IATQ_DLL_IMPLEMENTATION
#  define IATQ_DLLEXP __declspec(dllexport)
#  ifdef IIATQ_MPLEMENTATION_EXPORT
#   define IATQ_EXPIMP
#  else
#   undef  IATQ_EXPIMP
#  endif 
# else // !IATQ_DLL_IMPLEMENTATION
#  define IATQ_DLLEXP __declspec(dllimport)
#  define IATQ_EXPIMP extern
# endif // !IATQ_DLL_IMPLEMENTATION 
#endif // !IATQ_DLLEXP

#include "dbgutil.h"
#include "atq.h"
#include "lkrhash.h"

class CDirMonitor;

class IATQ_DLLEXP CDirMonitorEntry
{
friend class CDirMonitor;

public:
    CDirMonitorEntry();
    virtual ~CDirMonitorEntry();
    virtual VOID AddRef(VOID);
    virtual BOOL Release(VOID);    // return FALSE if last release
    virtual BOOL Init(DWORD);
    
protected:
    DWORD               m_dwNotificationFlags;
    DWORD               m_cPathLength;
    LPSTR               m_pszPath;
    LONG                m_cDirRefCount;	// Ref count for external usage
    LONG                m_cIORefCount;  // Ref count of Asynch IO
    HANDLE              m_hDir;
    PATQ_CONTEXT        m_pAtqCtxt;
    OVERLAPPED          m_ovr;
    DWORD				m_cBufferSize;
    BYTE*               m_pbBuffer;
    CDirMonitor*        m_pDirMonitor;
    BOOL                m_fInCleanup;
    BOOL    			m_fWatchSubdirectories;

    VOID IOAddRef(VOID);
    BOOL IORelease(VOID);	// return FALSE if last release
    BOOL RequestNotification(VOID);
    BOOL Cleanup();
    DWORD GetBufferSize(VOID);
    BOOL SetBufferSize(DWORD);
    BOOL ResetDirectoryHandle(VOID);

    virtual BOOL ActOnNotification(DWORD dwStatus, DWORD dwBytesWritten) = 0;
} ;

inline VOID CDirMonitorEntry::AddRef(VOID)
{
    // This ref count tracks how many templates
    // and applications are depending on this monitor entry.
    
    InterlockedIncrement( &m_cDirRefCount );

    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] After AddRef Ref count %d\n", m_cDirRefCount));
    #endif // DBG_NOTIFICATION
}


inline BOOL CDirMonitorEntry::Release(VOID)
{
    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Before Release Ref count %d.\n", m_cDirRefCount));
    #endif // DBG_NOTIFICATION

    if ( !InterlockedDecrement( &m_cDirRefCount ) )
    {
        // When ref count reaches 0, clean up resources
        
        BOOL fDeleteNeeded = Cleanup();

        // Cleanup said that we need to handle the deletion,
        // probably because there were no Asynch operations outstanding
        
        if (fDeleteNeeded)
        {
            delete this;
        }
        
        return FALSE;
    }

    return TRUE;
}

inline VOID CDirMonitorEntry::IOAddRef(VOID)
{
    // This refcount track how many
    // asynch IO requests are oustanding
    
    InterlockedIncrement( &m_cIORefCount );
}


inline BOOL CDirMonitorEntry::IORelease(VOID)
{
    if ( !InterlockedDecrement( &m_cIORefCount ) )
    {

        // When both IO and external ref counts reaches 0,
        // free this object
        
        if (m_cDirRefCount == 0)
        {
            delete this;
        }
        return FALSE;
    }

    return TRUE;
}

inline DWORD CDirMonitorEntry::GetBufferSize(VOID)
{
	return m_cBufferSize;
}

class IATQ_DLLEXP CDirMonitor : public CTypedHashTable<CDirMonitor, CDirMonitorEntry, const char*>
{
public:
    CDirMonitor();
    ~CDirMonitor();
    VOID Lock(VOID);
    VOID Unlock(VOID);
    CDirMonitorEntry *FindEntry(LPCSTR pszPath);
    BOOL Monitor( CDirMonitorEntry *pDME, LPCSTR pszDirectory, BOOL fWatchSubDirectories, DWORD dwFlags);
    BOOL Cleanup(VOID);
    LK_RETCODE InsertEntry( CDirMonitorEntry *pDME );
    LK_RETCODE RemoveEntry( CDirMonitorEntry *pDME );
    LONG   AddRef(VOID);
    LONG   Release(VOID);
    
	static const char* CDirMonitor::ExtractKey(const CDirMonitorEntry* pDME)
	{
		return pDME->m_pszPath;
	};

	static DWORD CDirMonitor::CalcKeyHash(const char* pszKey)
	{
		return HashStringNoCase(pszKey);
	};

	static bool CDirMonitor::EqualKeys(const char* pszKey1, const char* pszKey2)
	{
		return _stricmp(pszKey1, pszKey2) == 0;
	};

	static void CDirMonitor::AddRefRecord(CDirMonitorEntry* pDME, int nIncr)
	{
	// Don't do automatic ref counting. Handle reference counts explicitly
	}

private:
    CRITICAL_SECTION    m_csLock;
    CRITICAL_SECTION    m_csSerialComplLock;
    LONG                m_cRefs;

    VOID                SerialComplLock();
    VOID                SerialComplUnlock();

public:
    static VOID DirMonitorCompletionFunction( PVOID pCtxt, DWORD dwBytesWritten, DWORD dwCompletionStatus, OVERLAPPED *pOvr );

};
inline LONG CDirMonitor::AddRef()
{
    return InterlockedIncrement( &m_cRefs );
}

inline LONG CDirMonitor::Release()
{
    return InterlockedDecrement( &m_cRefs);
}
inline VOID CDirMonitor::Lock(VOID)
{
    EnterCriticalSection( &m_csLock);
}


inline VOID CDirMonitor::Unlock(VOID)
{
    LeaveCriticalSection( &m_csLock);
}

inline VOID CDirMonitor::SerialComplLock(VOID)
{
    EnterCriticalSection( &m_csSerialComplLock);
}


inline VOID CDirMonitor::SerialComplUnlock(VOID)
{
    LeaveCriticalSection( &m_csSerialComplLock);
}


#endif /* _DIRMON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\img\wwwroot\iissamp\hp\tms\mechanical\setup.inc ===
<%
 If myinfo.Theme = "mechanical" Then
'	$Date: 11/24/97 11:59a $
'	$ModTime: $
'	$Revision: 1 $
'	$Workfile: setup.inc $
'	mechanical

DIM intID, i
%>
<table border=0 cellpadding=10 cellspacing=0 width=100% HEIGHT=100%>
<FORM NAME='Template' ACTION='template.asp' METHOD='POST'>
<TR>
<TD valign=top width="60%" class=bgpale>
<blockquote>
<% 
	call page_datetime
%>
</blockquote></b><p>
<img src="/iissamples/homepage/themes/mechanical/dotline.gif" width=490 height=20 border=0><p>
<%
	response.write Template_Heading()
%>
</td>
<TD valign=top WIDTH="35%" BGColor="#5B0012" class=bgred>
<%
	 If ( myinfo.Name <> "" OR myinfo.Email <> "" OR myinfo.faxphone <> "" OR myinfo.Department <>"") Then
%>
	<SPAN class=headerw>Contact information:</SPAN><P>
<%
	 End If
	 'response.write FieldValue( thispage, "Name" , "Name:", 20 ) & "<BR>"_
	 '& FieldValue( thispage, "Email" , "Email Address:", 20 ) & "<BR>"_
	 '& FieldValue( thispage, "Phone", "Phone number:", 20) & "<BR>"_
	 '& FieldValue( thispage, "faxPhone", "Fax number:", 20) & "<BR>"_
	 '& FieldValue( thispage, "Department", "Department:", 30) & "<BR>"_
	 '& Address( thispage, 30)
	
	call Template_Name
	response.write "<BR>"
	layout_Email
	response.write "<BR>"
	call Template_Phone
	response.write "<BR>"
	call Template_faxPhone
	response.write "<BR>"
	call Template_address
%>
	<img src="/iissamples/homepage/themes/mechanical/trans.gif" width=10 height=25 border=0><br>
	<FONT COLOR=WHITE>	
<%
    call Template_page_messaging
%>
	</FONT>
	<img src="/iissamples/homepage/themes/mechanical/trans.gif" width=10 height=25 border=0><P>
<%
		If myinfo.intUrl <> "" Then
			response.write "<SPAN class=headerw>My favorite links</SPAN><P>"
		End If
		call Template_page_links
%>
	<img src="/iissamples/homepage/themes/mechanical/trans.gif" width=10 height=25 border=0><br>
<%
	call ie_logo
	response.write "<INPUT TYPE='hidden' NAME='contents' Value='-1'>"_
	& "<Center><INPUT TYPE=SUBMIT VALUE='enter new changes'></Center></FORM>"
%>
</td>
</tr>
</table>
<%
End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\dynodbc.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      dynodbc.h

   Abstract:
      This header declares functions for dynamically loading ODBC.

   Author:

       Murali R. Krishnan    ( MuraliK )    3-Nov-1995

   Environment:
       Win32 -- User Mode

   Project:

      Internet Services Common Code.

   Revision History:

--*/

# ifndef _DYNODBC_H_
# define _DYNODBC_H_

/************************************************************
 *     Include Headers
 ************************************************************/


//
// SQL-ODBC interface headers
//
# include "sql.h"
# include "sqlext.h"




/************************************************************
 *   Dynamic Load support
 ************************************************************/

BOOL
DynLoadODBC(
    VOID
    );

//
//  Prototypes form sql.h
//

typedef RETCODE (SQL_API * pfnSQLAllocConnect)(
    HENV        henv,
    HDBC   FAR *phdbc);

typedef RETCODE (SQL_API * pfnSQLAllocEnv)(
    HENV   FAR *phenv);

typedef RETCODE (SQL_API * pfnSQLAllocStmt)(
    HDBC        hdbc,
    HSTMT  FAR *phstmt);

typedef RETCODE (SQL_API * pfnSQLBindCol)(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLCancel)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLColAttributes)(
    HSTMT       hstmt,
    UWORD       icol,
    UWORD       fDescType,
    PTR         rgbDesc,
        SWORD       cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc);

typedef RETCODE (SQL_API * pfnSQLConnect)(
    HDBC        hdbc,
    UCHAR  FAR *szDSN,
    SWORD       cbDSN,
    UCHAR  FAR *szUID,
    SWORD       cbUID,
    UCHAR  FAR *szAuthStr,
    SWORD       cbAuthStr);

typedef RETCODE (SQL_API * pfnSQLDescribeCol)(
    HSTMT       hstmt,
    UWORD       icol,
    UCHAR  FAR *szColName,
    SWORD       cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);

typedef RETCODE (SQL_API * pfnSQLDisconnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLError)(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD       cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg);

typedef RETCODE (SQL_API * pfnSQLExecDirect)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLExecute)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFetch)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFreeConnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLFreeEnv)(
    HENV        henv);

typedef RETCODE (SQL_API * pfnSQLFreeStmt)(
    HSTMT       hstmt,
    UWORD       fOption);

typedef RETCODE (SQL_API * pfnSQLGetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursorMax,
    SWORD  FAR *pcbCursor);

typedef RETCODE (SQL_API * pfnSQLNumResultCols)(
    HSTMT       hstmt,
    SWORD  FAR *pccol);

typedef RETCODE (SQL_API * pfnSQLPrepare)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLRowCount)(
    HSTMT       hstmt,
    SDWORD FAR *pcrow);

typedef RETCODE (SQL_API * pfnSQLSetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursor);

typedef RETCODE (SQL_API * pfnSQLTransact)(
    HENV        henv,
    HDBC        hdbc,
    UWORD       fType);

//
//  Prototypes form sqlext.h
//

typedef RETCODE (SQL_API * pfnSQLSetConnectOption)(
    HDBC        hdbc,
    UWORD       fOption,
    SQLPOINTER  vParam);

typedef RETCODE (SQL_API * pfnSQLDrivers)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR FAR  *szDriverDesc,
    SWORD       cbDriverDescMax,
    SWORD FAR  *pcbDriverDesc,
    UCHAR FAR  *szDriverAttributes,
    SWORD       cbDrvrAttrMax,
    SWORD  FAR *pcbDrvrAttr);

typedef RETCODE (SQL_API * pfnSQLBindParameter)(
    HSTMT       hstmt,
    UWORD       ipar,
    SWORD       fParamType,
    SWORD       fCType,
    SWORD       fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLDataSources)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR  FAR *szDSN,
    SWORD       cbDSNMax,
    SWORD  FAR *pcbDSN,
    UCHAR  FAR *szDescription,
    SWORD       cbDescriptionMax,
    SWORD  FAR *pcbDescription);

typedef RETCODE (SQL_API * pfnSQLGetInfo)(
    HDBC        hdbc,
    UWORD       fInfoType,
    PTR         rgbInfoValue,
    SWORD       cbInfoValueMax,
    SWORD  FAR *pcbInfoValue);

typedef RETCODE (SQL_API * pfnSQLMoreResults)(
    HSTMT       hstmt );

/************************************************************
 *   Variables
 ************************************************************/

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

extern pfnSQLAllocConnect        pSQLAllocConnect   ;
extern pfnSQLAllocEnv            pSQLAllocEnv       ;
extern pfnSQLAllocStmt           pSQLAllocStmt      ;
extern pfnSQLBindCol             pSQLBindCol        ;
extern pfnSQLCancel              pSQLCancel         ;
extern pfnSQLColAttributes       pSQLColAttributes  ;
extern pfnSQLConnect             pSQLConnect        ;
extern pfnSQLDescribeCol         pSQLDescribeCol    ;
extern pfnSQLDisconnect          pSQLDisconnect     ;
extern pfnSQLError               pSQLError          ;
extern pfnSQLExecDirect          pSQLExecDirect     ;
extern pfnSQLExecute             pSQLExecute        ;
extern pfnSQLFetch               pSQLFetch          ;
extern pfnSQLFreeConnect         pSQLFreeConnect    ;
extern pfnSQLFreeEnv             pSQLFreeEnv        ;
extern pfnSQLFreeStmt            pSQLFreeStmt       ;
extern pfnSQLGetCursorName       pSQLGetCursorName  ;
extern pfnSQLNumResultCols       pSQLNumResultCols  ;
extern pfnSQLPrepare             pSQLPrepare        ;
extern pfnSQLRowCount            pSQLRowCount       ;
extern pfnSQLSetCursorName       pSQLSetCursorName  ;
extern pfnSQLTransact            pSQLTransact       ;

extern pfnSQLSetConnectOption    pSQLSetConnectOption;
extern pfnSQLDrivers             pSQLDrivers         ;
extern pfnSQLDataSources         pSQLDataSources     ;
extern pfnSQLBindParameter       pSQLBindParameter   ;

extern pfnSQLGetInfo             pSQLGetInfo        ;
extern pfnSQLMoreResults         pSQLMoreResults    ;


# endif // _DYNODBC_H_

/************************ End of File ***********************/





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\except.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Exception Handling

File: Except.h

Owner: DGottner

Exception handling macros implemented via Win32 structured exceptions.

Usage:

	TRY
		<try block>

	CATCH (<exception variable>)
		<exception handler>

	END_TRY

To throw an exception use "THROW (<integer expression>)"

To set up a termination handler use:

	TRY
		<try block>

	FINALLY
		<termination handler>

	END_TRY

Rationale:
	This macro package offers a strict subset of Win32 structured exception
	handling. There is no support for exception filters (you have to rethrow
	exceptions), and no support for the resumption model of exception handling
	(though Win32 supports the resumption model)

	The purpose for these restrictions is to make it very easy to rewrite the
	exception handling macros for use with other exception throwing mechanisms.
	It would be easy to use this same interface with C++ exceptions or
	setjmp/longjmp.

	The braces with TRY, CATCH, and FINALLY are optional. Since this code is
	structured using self-bracketing constructs, the braces seem redundant.

	There is no need to declare the datatype of the <exception variable>
	because it is always an integer.
-----------------------------------------------------------------------------*/

#ifndef _EXCEPT_H
#define _EXCEPT_H

// Pragmas --------------------------------------------------------------------
//
// Turn off the "signed/unsigned conversion" warning off because it we get this
// all the time that we throw an HRESULT. (which is a harmless thing)  The
// warning is usually benign anyway.


#pragma warning(disable: 4245)


// Macros ---------------------------------------------------------------------

#define TRY	               __try {
#define CATCH(nException)  } __except(1) { DWORD nException = GetExceptionCode();
#define FINALLY            } __finally {
#define END_TRY            }

#define THROW(nException)  RaiseException(nException, 0, 0, NULL)

#endif // _EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\fsconst.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
        fsconsts.h

   Abstract:
        File System constants  defined here

   Author:

       Murali R. Krishnan    ( MuraliK )   21-Feb-1995

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common Headers

   Revision History:

--*/

# ifndef _FSCONST_H_
# define _FSCONST_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Constants
 ************************************************************/

//
// Constants that define values for each file system we
//  are going to support for servers
//  FS_ is a prefix for FileSystem  type
//

# define  FS_ERROR          ( 0x00000000)   // initializing value
# define  FS_FAT            ( 0x00000001)
# define  FS_NTFS           ( 0x00000002)
# define  FS_HPFS           ( 0x00000003)
# define  FS_OFS            ( 0x00000004)
# define  FS_CDFS           ( 0x00000005)




# endif // _FSCONST_H_

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef __GIP_H__
#define __GIP_H__

/*===================================================================
  Includes
===================================================================*/

#include <irtldbg.h>
#include <objidl.h>

/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class dllexp CGlobalInterfaceAPI
{
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#ifdef _DEBUG
	inline void AssertValid() const
    {
        IRTLASSERT(m_fInited);
        IRTLASSERT(m_pGIT);
    }
#else
	inline void AssertValid() const {}
#endif
};

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register(
    IUnknown *pUnk,
    REFIID riid,
    DWORD *pdwCookie)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
}

inline HRESULT CGlobalInterfaceAPI::Get(
    DWORD dwCookie,
    REFIID riid, 
    void **ppv)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
}
        
inline HRESULT CGlobalInterfaceAPI::Revoke(
    DWORD dwCookie)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
}

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif // __GIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\festrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//
# ifndef _FESTRCNV_H_
# define _FESTRCNV_H_

#ifdef __cplusplus
extern "C" {
#endif

// Define for Japanese Code Type
#define CODE_UNKNOWN            0
#define CODE_ONLY_SBCS          0
#define CODE_JPN_JIS            1
#define CODE_JPN_EUC            2
#define CODE_JPN_SJIS           3

// ----------------------------------
// Public Functions for All FarEast
//-----------------------------------

// Convert from PC Code Set to UNIX Code Set
int PC_to_UNIX (
    int CodePage,
    int CodeSet,
    UCHAR *pPC,
    int PC_len,
    UCHAR *pUNIX,
    int UNIX_len
    );

// Convert from UNIX Code Set to PC Code Set
int UNIX_to_PC (
    int CodePage,
    int CodeSet,
    UCHAR *pUNIX,
    int UNIX_len,
    UCHAR *pPC,
    int PC_len
    );

#ifdef __cplusplus
}
#endif

# endif // _FESTRCNV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\ftpd.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpd.h

    This file contains constants & type definitions shared between the
    FTPD Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     23-Oct-1995 Imported for new ftp server
        MuraliK     14-Dec-1995 service name imported from inetinfo.h

*/


#ifndef _FTPD_H_
#define _FTPD_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <inetinfo.h>

//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define FTPD_ANNOTATION_FILE_A           "~FTPSVC~.CKM"
#define FTPD_ANNOTATION_FILE_W          L"~FTPSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define FTPD_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_A

# define FTPD_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_W

#define FTPD_PARAMETERS_KEY_A   FTPD_SERVICE_KEY_A ## "\\Parameters"

#define FTPD_PARAMETERS_KEY_W   FTPD_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define FTPD_PERFORMANCE_KEY_A  FTPD_SERVICE_KEY_A ## "\\Performance"

#define FTPD_PERFORMANCE_KEY_W  FTPD_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//

#define FTPD_ACCESS_KEY_A                "AccessCheck"
#define FTPD_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define FTPD_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define FTPD_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define FTPD_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define FTPD_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define FTPD_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define FTPD_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define FTPD_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define FTPD_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define FTPD_SHOW_4_DIGIT_YEAR_A          "Show4DigitYear"
#define FTPD_SHOW_4_DIGIT_YEAR_W         L"Show4DigitYear"

#define FTPD_GREETING_MESSAGE_A          "GreetingMessage"
#define FTPD_GREETING_MESSAGE_W         L"GreetingMessage"

#define FTPD_EXIT_MESSAGE_A              "ExitMessage"
#define FTPD_EXIT_MESSAGE_W             L"ExitMessage"

#define FTPD_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define FTPD_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define FTPD_DEBUG_FLAGS_A               "DebugFlags"
#define FTPD_DEBUG_FLAGS_W              L"DebugFlags"

#define FTPD_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define FTPD_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define FTPD_LOWERCASE_FILES_A           "LowercaseFiles"
#define FTPD_LOWERCASE_FILES_W          L"LowercaseFiles"

#define FTPD_LISTEN_BACKLOG_A            "ListenBacklog"
#define FTPD_LISTEN_BACKLOG_W           L"ListenBacklog"

#define FTPD_ENABLE_LICENSING_A          "EnableLicensing"
#define FTPD_ENABLE_LICENSING_W         L"EnableLicensing"

#define FTPD_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define FTPD_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"

#define FTPD_NO_EXTENDED_FILENAME_A      "DisableExtendedCharFileNames"
#define FTPD_NO_EXTENDED_FILENAME_W     L"DisableExtendedCharFileNames"

#define FTPD_ENABLE_PORT_ATTACK_A        "EnablePortAttack"
#define FTPD_ENABLE_PORT_ATTACK_W       L"EnablePortAttack"

#define FTPD_ENABLE_PASV_THEFT_A         "EnablePasvTheft"
#define FTPD_ENABLE_PASV_THEFT_W        L"EnablePasvTheft"

#define FTPD_BANNER_MESSAGE_A            "BannerMessage"
#define FTPD_BANNER_MESSAGE_W           L"BannerMessage"

#define FTPD_USER_ISOLATION_A            "UserIsolationMode"
#define FTPD_USER_ISOLATION_W           L"UserIsolationMode"

#define FTPD_LOG_IN_UTF_8_A              "FtpLogInUtf8"
#define FTPD_LOG_IN_UTF_8_W             L"FtpLogInUtf8"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define FTPD_ANONYMOUS_SECRET_A          "FTPD_ANONYMOUS_DATA"
#define FTPD_ANONYMOUS_SECRET_W         L"FTPD_ANONYMOUS_DATA"

#define FTPD_ROOT_SECRET_A               "FTPD_ROOT_DATA"
#define FTPD_ROOT_SECRET_W              L"FTPD_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_W
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_W
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_W
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_W
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_W
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_W
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_W
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_W
#define FTPD_SHOW_4_DIGIT_YEAR          FTPD_SHOW_4_DIGIT_YEAR_W
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_W
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_W
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_W
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_W
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_W
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_W
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_W
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_W
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_W
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_W
#define FTPD_NO_EXTENDED_FILENAME       FTPD_NO_EXTENDED_FILENAME_W
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_W
#define FTPD_ENABLE_PASV_THEFT          FTPD_ENABLE_PASV_THEFT_W
#define FTPD_BANNER_MESSAGE             FTPD_BANNER_MESSAGE_W
#define FTPD_USER_ISOLATION             FTPD_USER_ISOLATION_W
#define FTPD_LOG_IN_UTF_8               FTPD_LOG_IN_UTF_8_W

#else   // !UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_A
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_A
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_A
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_A
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_A
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_A
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_A
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_A
#define FTPD_SHOW_4_DIGIT_YEAR          FTPD_SHOW_4_DIGIT_YEAR_A
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_A
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_A
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_A
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_A
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_A
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_A
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_A
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_A
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_A
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_A
#define FTPD_NO_EXTENDED_FILENAME       FTPD_NO_EXTENDED_FILENAME_A
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_A
#define FTPD_ENABLE_PASV_THEFT          FTPD_ENABLE_PASV_THEFT_A
#define FTPD_BANNER_MESSAGE             FTPD_BANNER_MESSAGE_A
#define FTPD_USER_ISOLATION             FTPD_USER_ISOLATION_A
#define FTPD_LOG_IN_UTF_8               FTPD_LOG_IN_UTF_8_A


#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _FTP_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} FTP_USER_INFO, * LPFTP_USER_INFO;

typedef struct _FTP_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         ServiceUptime;
    DWORD         TotalAllowedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalBlockedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;
    DWORD         TimeOfLastClear;

} FTP_STATISTICS_0, * LPFTP_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    );

NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _FTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iadm.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    iadm.h

    Defunct file.
    All clients should use iadmw.h.
*/
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\gntlsapi.h ===
//	gntlsapi.h
//
//	Global NT License Service, for cooperative machine-wide CAL counting

#ifndef _GNTLSAPI_H
#define _GNTLSAPI_H

#ifdef __cplusplus
extern "C"{
#endif 

#include <ntlsapi.h>					// using this for definitions of basic types and structs



//	GNtLicenseRequest
//
//	Same as NtLicenseRequest, except guaranteed not to double count, so will only call NtLicenseRequest
//	once no matter how many times GNtLicenseRequest is called for client/product/version on this machine.
//	Same return values as NtLicenseRequest.

LS_STATUS_CODE LS_API_ENTRY GNtLicenseRequestW(
	LPWSTR			ProductName,
    LPWSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

LS_STATUS_CODE LS_API_ENTRY GNtLicenseRequestA(
	LPSTR			ProductName,
    LPSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

#ifdef UNICODE
#define GNtLicenseRequest	GNtLicenseRequestW
#else
#define GNtLicenseRequest	GNtLicenseRequestA
#endif // !UNICODE


//	GNtLicenseExemption
//
//	By calling GNtLicenseExemption, the caller is saying that this client/product/version is exempt
//	from requiring (further) licenses on this machine. The caller may or may not have already consumed
//	license(s) for this client/product/version by calling directly to NtLicenseRequest.  The exemption is
//	released by calling GNtLSFreeHandle.  This is ref counted, so must call GNtLSFreeHandle for each call
//	to GNtLicenseExemption.
//	Returns LS_SUCCESS or LS_BAD_ARG.

LS_STATUS_CODE LS_API_ENTRY GNtLicenseExemptionW(
	LPWSTR			ProductName,
    LPWSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

LS_STATUS_CODE LS_API_ENTRY GNtLicenseExemptionA(
	LPSTR			ProductName,
    LPSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

#ifdef UNICODE
#define GNtLicenseExemption	GNtLicenseExemptionW
#else
#define GNtLicenseExemption	GNtLicenseExemptionA
#endif // !UNICODE


//	GNtLSFreeHandle
//
//	Same as NtLSFreeHandle, except works for LicenseHandles returned from both GNtLicenseRequest and
//	GNtLicenseExemption.  Do not call this with a LicenseHandle returned by NtLicenseRequest.
//	Same return values as NtLSFreeHandle.

LS_STATUS_CODE LS_API_ENTRY GNtLSFreeHandle(
    LS_HANDLE		LicenseHandle);



//
//	function pointer typedefs
//

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_REQUEST_W)(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_REQUEST_A)(
    LPSTR       ProductName,
    LPSTR       Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

#ifdef UNICODE
#define PGNT_LICENSE_REQUEST	PGNT_LICENSE_REQUEST_W
#else
#define PGNT_LICENSE_REQUEST	PGNT_LICENSE_REQUEST_A
#endif // !UNICODE


typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_EXEMPTION_W)(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_EXEMPTION_A)(
    LPSTR       ProductName,
    LPSTR       Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

#ifdef UNICODE
#define PGNT_LICENSE_EXEMPTION	PGNT_LICENSE_EXEMPTION_W
#else
#define PGNT_LICENSE_EXEMPTION	PGNT_LICENSE_EXEMPTION_A
#endif // !UNICODE


typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LS_FREE_HANDLE)(
    LS_HANDLE   LicenseHandle );



#ifdef __cplusplus
}
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iiscryptp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iiscryptp.h

Abstract:

    This include file contains private constants, type definitions, and
    function prototypes shared between the various IIS cryptographic
    routines but *not* available to "normal" code.

Author:

    Keith Moore (keithmo)        23-Apr-1998

Revision History:

--*/


#ifndef _IISCRYPTP_H_
#define _IISCRYPTP_H_


//
// Get the dependent include files.
//

#include <iiscrypt.h>


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Global lock manipulators.
//

IIS_CRYPTO_API
VOID
WINAPI
IcpAcquireGlobalLock(
    VOID
    );

IIS_CRYPTO_API
VOID
WINAPI
IcpReleaseGlobalLock(
    VOID
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _IISCRYPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iadmext.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997-1999           **/
/**********************************************************************/

/*
    iadmext.h

    This module contains the interface for extensions to the IISADMIN service.


    FILE HISTORY:
    7/8/97      michth      created
*/

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iadmext_h__
#define __iadmext_h__

#ifdef __cplusplus
extern "C"{
#endif



/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

/*
The Main Interface. All extensions must support this interface.
*/
// {51DFE970-F6F2-11d0-B9BD-00A0C922E750}
DEFINE_GUID(IID_IADMEXT, 0x51dfe970, 0xf6f2, 0x11d0, 0xb9, 0xbd, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

/*
InProcess COM Registration. All extensions must write a subkey name by the
CLSID for the above interface under this key in the Registry.
*/
#define IISADMIN_EXTENSIONS_REG_KEYA          "SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEYW          L"SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEY           TEXT("SOFTWARE\\Microsoft\\InetStp\\Extensions")

/*
DCOM Registration. CLSIDS for the DCOM interface provided by these extensions will
be written to this key and ID by IISADMIN as a multisz property.

This is intended for use by other applications which need to find out what classid's are
registered.
*/

#define IISADMIN_EXTENSIONS_CLSID_MD_KEYA      "LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEYW      L"LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEY      TEXT("LM/IISADMIN/EXTENSIONS/DCOMCLSIDS")
#define IISADMIN_EXTENSIONS_CLSID_MD_ID       MD_IISADMIN_EXTENSIONS

#ifndef __IADMEXT_INTERFACE_DEFINED__
#define __IADMEXT_INTERFACE_DEFINED__


EXTERN_C const IID IID_IADMEXT;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IADMEXT : public IUnknown
    {
    public:
        //
        // All methods below will be called under a thread which has called
        // CoInitializeEx(NULL, COINIT_MULTITHREADED).
        //
        // The IMSAdminBase Object will be available during all of these calls.
        //

        //
        // Initialize will be called by IISADMIN when it initializes.
        //
        virtual HRESULT STDMETHODCALLTYPE Initialize(void) = 0;

        //
        // EnumDcomCLSIDs will be called by IISADMIN when it initializes,
        // and the returned CLSIDs will be written to the metabase at
        // the path IISADMIN_EXTENSIONS_CLSID_MD_KEY.
        //
        virtual HRESULT STDMETHODCALLTYPE EnumDcomCLSIDs(
            /* [size_is][out] */ CLSID *pclsidDcom,
            /* [in] */ DWORD dwEnumIndex) = 0;

        //
        // Terminate will be called by IISADMIN when it terminates.
        //
        virtual HRESULT STDMETHODCALLTYPE Terminate(void) = 0;

    };

#else   /* C style interface */
#endif
#endif  /* __IADMEXT_INTERFACE_DEFINED__ */

#ifdef __cplusplus
}
#endif

#endif // __iadmext_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iiscblob.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscblob.h

Abstract:

    This include file contains the definition of the IIS_CRYPTO_BLOB
    structure and associated constants.

Author:

    Keith Moore (keithmo)        25-Feb-1997

Revision History:

--*/


#ifndef _IISCBLOB_H_
#define _IISCBLOB_H_

#ifndef _IIS_CRYPTO_BLOB_DEFINED
#define _IIS_CRYPTO_BLOB_DEFINED
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Structure signatures for the various blob types.
//

#define SALT_BLOB_SIGNATURE         ((DWORD)'bScI')
#define KEY_BLOB_SIGNATURE          ((DWORD)'bKcI')
#define PUBLIC_KEY_BLOB_SIGNATURE   ((DWORD)'bPcI')
#define DATA_BLOB_SIGNATURE         ((DWORD)'bDcI')
#define HASH_BLOB_SIGNATURE         ((DWORD)'bHcI')
#define CLEARTEXT_BLOB_SIGNATURE    ((DWORD)'bCcI')

//
// A crypto blob. Note that this is just the header for the blob.
// The details of the blob internals are private to the IIS Crypto
// package.
//

typedef struct _IIS_CRYPTO_BLOB {

    //
    // The structure signature for this blob.
    //

    DWORD BlobSignature;

    //
    // The total length of this blob, NOT including this header.
    //

    DWORD BlobDataLength;


#if defined(MIDL_PASS)

    //
    // Define the raw data so that MIDL can marshal correctly.
    //

    [size_is(BlobDataLength)] unsigned char BlobData[*];

#endif  // MIDL_PASS

} IIS_CRYPTO_BLOB;


#if defined(MIDL_PASS)

// BUGBUG: Hackety Hack: midl doesn't know about __unaligned, so we don't
// tell it.  At some point, midl should be fixed to know about it.  Also,
// we should ultimately stop using __unaligned

typedef IIS_CRYPTO_BLOB *PIIS_CRYPTO_BLOB;

#else

typedef IIS_CRYPTO_BLOB UNALIGNED64 *PIIS_CRYPTO_BLOB;

#endif  // MIDL_PASS




#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus
#endif  // _IIS_CRYPTO_BLOB_DEFINED


#endif  // _IISCBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iis64.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iis64.h

Abstract:

    This include file contains public macros and type definitions to ease
    the port from 32- to 64-bits.

Author:

    Keith Moore (keithmo)        20-Jan-1998

Revision History:

--*/


#ifndef _IIS64_H_
#define _IIS64_H_


#ifdef __cplusplus
extern "C" {
#endif  // _cplusplus


//
// Ensure the size_t type is properly defined.
//

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a size_t type,
// allowing the result to be easily assigned to any 32-bit variable or
// passed to a function expecting a 32-bit argument.
//

#define DIFF(x)     ((size_t)(x))


//
// Macros for mapping "native" Win32 HANDLEs <-> Winsock SOCKETs.
//
// N.B. These are temporary and will (hopefully) go away after the
//      public WINSOCK2.H header file is made Win64 compliant.
//

#define HANDLE_TO_SOCKET(h) ((SOCKET)(h))
#define SOCKET_TO_HANDLE(s) ((HANDLE)(s))


#ifdef __cplusplus
}   // extern "C"
#endif  // _cplusplus


#endif  // _IIS64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iiscrypt.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscrypt.h

Abstract:

    This include file contains public constants, type definitions, and
    function prototypes for the IIS cryptographic routines.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _IISCRYPT_H_
#define _IISCRYPT_H_


//
// Get the dependent include files.
//

#include <windows.h>
#include <wincrypt.h>
#include <iiscblob.h>


//
// Define API decoration, should we ever move these routines into a DLL.
//

#define IIS_CRYPTO_API


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// A NULL crypto handle, mysteriously absent from wincrypt.h.
//

#define CRYPT_NULL 0


//
// Initialization/termination functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoInitialize(
    VOID
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoTerminate(
    VOID
    );



// special function for programatically disabling encryption for French case
VOID 
WINAPI
IISCryptoInitializeOverride(
    BOOL flag
    );



//
// Memory allocation functions. Clients may provide their own
// definitions of these routines if necessary.
//

PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    );

VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    );


//
// Container functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer(
    OUT HCRYPTPROV * phProv,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer2(
    OUT HCRYPTPROV * phProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteStandardContainer(
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteContainerByName(
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseContainer(
    IN HCRYPTPROV hProv
    );


//
// Key manipulation functions.
//
IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyDeriveKey2(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyExchangeKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetSignatureKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGenerateSessionKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseKey(
    IN HCRYPTKEY hKey
    );


//
// Hash manipulation functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateHash(
    OUT HCRYPTHASH * phHash,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDestroyHash(
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashData(
    IN HCRYPTHASH hHash,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashSessionKey(
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hSessionKey
    );


//
// Generic blob manipulators.
//

#define IISCryptoGetBlobLength(p) (((p)->BlobDataLength) + sizeof(*(p)))

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoReadBlobFromRegistry(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoWriteBlobToRegistry(
    IN PIIS_CRYPTO_BLOB pBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoCompareBlobs(
    IN PIIS_CRYPTO_BLOB pBlob1,
    IN PIIS_CRYPTO_BLOB pBlob2
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData2(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateCleartextBlob(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PVOID pBlobData,
    IN DWORD dwBlobDataLength
    );


//
// Key blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportPublicKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppPublicKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hPublicKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportPublicKeyBlob(
    OUT HCRYPTKEY * phPublicKey,
    IN PIIS_CRYPTO_BLOB pPublicKeyBlob,
    IN HCRYPTPROV hProv
    );


//
// Data blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob2(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );


//
// Hash blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportHashBlob(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN HCRYPTHASH hHash
    );



//
// Simple check function for some special French case
//

BOOL
WINAPI
IISCryptoIsClearTextSignature (
    IIS_CRYPTO_BLOB UNALIGNED *pBlob
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _IISCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iisinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iisinfo.h

Abstract:

    This file contains the IIS v3 admin APIs.


Author:

    Johnson Apacible (johnsona) June-11-1996

--*/

#ifndef _IISINFO_H_
#define _IISINFO_H_

#include "inetinfo.h"

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

NET_API_STATUS
NET_API_FUNCTION
InitW3CounterStructure(
    IN LPWSTR        pszServer OPTIONAL,
	IN OUT LPDWORD   lpcbTotalRequired
	);

NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfData(
    IN LPWSTR        pszServer OPTIONAL,
	IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD      lpNumObjectTypes 
	);

NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics2(
    IN LPWSTR   pszServer OPTIONAL,
    IN DWORD    Level,
    IN DWORD    dwInstance,
    IN DWORD    dwReserved,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics2(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwInstance
    );


NET_API_STATUS
NET_API_FUNCTION
FtpQueryStatistics2(
    IN LPWSTR   pszServer OPTIONAL,
    IN DWORD    dwLevel,
    IN DWORD    dwInstance,
    IN DWORD    dwReserved,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
FtpClearStatistics2(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
IISEnumerateUsers(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwLevel,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    OUT LPDWORD                 nRead,
    OUT LPBYTE *                Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
IISDisconnectUser(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    );

typedef W3_USER_INFO    IIS_USER_INFO_1, *LPIIS_USER_INFO_1;

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _IISINFO_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\hashfn.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRHash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#ifdef __HASHFN_NAMESPACE__
namespace HashFn {
#endif // __HASHFN_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRHash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRHash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = 37 * dwHash  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRHash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = 37 * dwHash  +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           37 * Hash(rFoo.m_ch)  +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRHash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    LPBYTE pb = static_cast<LPBYTE>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = 37 * dwHash  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRHash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    DWORD* pdw = reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid));
    
    dwHash = 37 * dwHash  +  *pdw++;
    dwHash = 37 * dwHash  +  *pdw++;
    dwHash = 37 * dwHash  +  *pdw++;
    dwHash = 37 * dwHash  +  *pdw;

    return dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * 37  +  u.dw[1];
}

#ifdef __HASHFN_NAMESPACE__
}
#endif // __HASHFN_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\imdp.h ===
#ifndef _MDP_IMD_
#define _MDP_IMD_

#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

// {F1E08563-1598-11d1-9D77-00C04FD7BF3E}
DEFINE_GUID(CLSID_MDPCOM, 0xf1e08563, 0x1598, 0x11d1, 0x9d, 0x77, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x3e);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\imd.h ===
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imd_h__
#define __imd_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IMDCOM_FWD_DEFINED__
#define __IMDCOM_FWD_DEFINED__
typedef interface IMDCOM IMDCOM;
#endif  /* __IMDCOM_FWD_DEFINED__ */


#ifndef __IMDCOMSINKA_FWD_DEFINED__
#define __IMDCOMSINKA_FWD_DEFINED__
typedef interface IMDCOMSINKA IMDCOMSINKA;
#endif  /* __IMDCOMSINKA_FWD_DEFINED__ */


#ifndef __IMDCOMSINKW_FWD_DEFINED__
#define __IMDCOMSINKW_FWD_DEFINED__
typedef interface IMDCOMSINKW IMDCOMSINKW;
#endif  /* __IMDCOMSINKW_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"
#include "mddef.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


#ifndef _MD_IMD_
#define _MD_IMD_
/*
The Main Interface
*/
DEFINE_GUID(CLSID_MDCOM, 0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOM, 0xc1aa48c0, 0xfacc, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOM2, 0x08dbe811, 0x20e5, 0x4e09, 0xb0, 0xc8, 0xcf, 0x87, 0x19, 0x0c, 0xe6, 0x0e);
DEFINE_GUID(IID_NSECOM, 0x4810a750, 0x4318, 0x11d0, 0xa5, 0xc8, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);
DEFINE_GUID(CLSID_NSEPMCOM, 0x05dc3bb0, 0x4337, 0x11d0, 0xa5, 0xc8, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);
DEFINE_GUID(CLSID_MDCOMEXE, 0xba4e57f1, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
#define GETMDCLSID(IsService) CLSID_MDCOM
DEFINE_GUID(CLSID_MDPCOM, 0xf1e08563, 0x1598, 0x11d1, 0x9d, 0x77, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x3e);
#define GETMDPCLSID(IsService) CLSID_MDPCOM
#define IID_IMDCOMSINK       IID_IMDCOMSINK_A
DEFINE_GUID(IID_IMDCOMSINK_A, 0x5229ea36, 0x1bdf, 0x11d0, 0x9d, 0x1c, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOMSINK_W, 0x6906ee20, 0xb69f, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMDCOM_INTERFACE_DEFINED__
#define __IMDCOM_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOM
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOM;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDInitialize( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDTerminate(
            /* [in] */ BOOL bSaveData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdown( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteChildMetaObjectsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteChildMetaObjectsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaObjectsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaObjectsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRenameMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRenameMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetAllMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetAllMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteAllMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteAllMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaDataA(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaDataW(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataPathsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataPathsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ LPWSTR pszMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDOpenMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDOpenMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSaveData(METADATA_HANDLE hMDHandle = 0) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetHandleInfo(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetSystemChangeNumber(
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetDataSetNumberA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetDataSetNumberW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddRefReferenceData(
            /* [in] */ DWORD dwMDDataTag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDReleaseReferenceData(
            /* [in] */ DWORD dwMDDataTag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetLastChangeTimeA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetLastChangeTimeW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetLastChangeTimeA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetLastChangeTimeW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwVersion) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion) = 0;

    };

#else   /* C style interface */
#endif



#endif  /* __IMDCOM_INTERFACE_DEFINED__ */


#ifndef __IMDCOM2_INTERFACE_DEFINED__
#define __IMDCOM2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOM
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOM2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOM2 : public IMDCOM
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDBackupWithPasswdW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreWithPasswdW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDExportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDImportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszDestPath,
            /* [string][in][unique] */ LPCWSTR pszKeyType,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreHistoryW(
            /* [unique][in][string] */ LPCWSTR pszMDHistoryLocation,
            /* [in] */ DWORD dwMDMajorVersion,
            /* [in] */ DWORD dwMDMinorVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumHistoryW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDHistoryLocation,
            /* [out] */ DWORD *pdwMDMajorVersion,
            /* [out] */ DWORD *pdwMDMinorVersion,
            /* [out] */ PFILETIME pftMDHistoryTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;
    };

#else   /* C style interface */
#endif

#endif  /* __IMDCOM2_INTERFACE_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0145
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


/*
The Callback Interface - Clients that need to receive callbacks need to provide
    an implementation of this interface and Advise the metadata server.
*/
#define IMDCOMSINK   IMDCOMSINKA


extern RPC_IF_HANDLE __MIDL__intf_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0145_v0_0_s_ifspec;

#ifndef __IMDCOMSINKA_INTERFACE_DEFINED__
#define __IMDCOMSINKA_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOMSINKA
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOMSINKA;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOMSINKA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_A __RPC_FAR pcoChangeList[  ]) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdownNotify() = 0;

    };

#else   /* C style interface */

#endif  /* C style interface */



#endif  /* __IMDCOMSINKA_INTERFACE_DEFINED__ */


#ifndef __IMDCOMSINKW_INTERFACE_DEFINED__
#define __IMDCOMSINKW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOMSINKW
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOMSINKW;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOMSINKW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdownNotify() = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEventNotify(
            /* [in] */ DWORD dwMDEvent) = 0;
    };

#else   /* C style interface */

#endif  /* C style interface */
#endif  /* __IMDCOMSINKW_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0147
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */



#ifdef UNICODE

#define ComMDAddMetaObject ComMDAddMetaObjectW
#define ComMDDeleteMetaObject ComMDDeleteMetaObjectW
#define ComMDDeleteChildMetaObjects ComMDDeleteChildMetaObjectsW
#define ComMDEnumMetaObjects ComMDEnumMetaObjectsW
#define ComMDCopyMetaObject ComMDCopyMetaObjectW
#define ComMDRenameMetaObject ComMDRenameMetaObjectW
#define ComMDSetMetaData ComMDSetMetaDataW
#define ComMDGetMetaData ComMDGetMetaDataW
#define ComMDDeleteMetaData ComMDDeleteMetaDataW
#define ComMDEnumMetaData ComMDEnumMetaDataW
#define ComMDGetAllMetaData ComMDGetAllMetaDataW
#define ComMDDeleteAllMetaData ComMDDeleteAllMetaDataW
#define ComMDCopyMetaData ComMDCopyMetaDataW
#define ComMDGetMetaDataPaths ComMDGetMetaDataPathsW
#define ComMDOpenMetaObject ComMDOpenMetaObjectW
#define ComMDGetDataSetNumber ComMDGetDataSetNumberW
#define ComMDSetLastChangeTime ComMDSetLastChangeTimeW
#define ComMDGetLastChangeTime ComMDGetLastChangeTimeW
#define ComMDBackup ComMDBackupW
#define ComMDRestore ComMDRestoreW
#define ComMDEnumBackups ComMDEnumBackupsW
#define ComMDDeleteBackup ComMDDeleteBackupW
#define ComMDBackupWithPasswd ComMDBackupWithPasswdW
#define ComMDRestoreWithPasswd ComMDRestoreWithPasswdW
#define ComMDExport ComMDExportW
#define ComMDImport ComMDImportW
#define ComMDRestoreHistory ComMDRestoreHistoryW
#define ComMDEnumHistory ComMDEnumHistoryW

#else // Not UNICODE

#define ComMDAddMetaObject ComMDAddMetaObjectA
#define ComMDDeleteMetaObject ComMDDeleteMetaObjectA
#define ComMDDeleteChildMetaObjects ComMDDeleteChildMetaObjectsA
#define ComMDEnumMetaObjects ComMDEnumMetaObjectsA
#define ComMDCopyMetaObject ComMDCopyMetaObjectA
#define ComMDRenameMetaObject ComMDRenameMetaObjectA
#define ComMDSetMetaData ComMDSetMetaDataA
#define ComMDGetMetaData ComMDGetMetaDataA
#define ComMDDeleteMetaData ComMDDeleteMetaDataA
#define ComMDEnumMetaData ComMDEnumMetaDataA
#define ComMDGetAllMetaData ComMDGetAllMetaDataA
#define ComMDDeleteAllMetaData ComMDDeleteAllMetaDataA
#define ComMDCopyMetaData ComMDCopyMetaDataA
#define ComMDGetMetaDataPaths ComMDGetMetaDataPathsA
#define ComMDOpenMetaObject ComMDOpenMetaObjectA
#define ComMDGetDataSetNumber ComMDGetDataSetNumberA
#define ComMDSetLastChangeTime ComMDSetLastChangeTimeA
#define ComMDGetLastChangeTime ComMDGetLastChangeTimeA
#define ComMDBackup ComMDBackupA
#define ComMDRestore ComMDRestoreA
#define ComMDEnumBackups ComMDEnumBackupsA
#define ComMDDeleteBackup ComMDDeleteBackupA
#define ComMDBackupWithPasswd ComMDBackupWithPasswdA
#define ComMDRestoreWithPasswd ComMDRestoreWithPasswdA
#define ComMDExport ComMDExportA
#define ComMDImport ComMDImportA
#define ComMDRestoreHistory ComMDRestoreHistoryA
#define ComMDEnumHistory ComMDEnumHistoryA

#endif //UNICODE

#endif

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\immd5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#if !defined(_IMMD5_INCLUDE)
#define _IMMD5_INCLUDE

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;

#define MD5_LEN 16

#define PROTO_LIST(list)    list


void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iisver.h ===
//
// Apps' rc files should look like this:
//
/**
#include "windows.h"
#include "ntverp.h"

#define VER_FILEDESCRIPTION_STR         "File Description"
#define VER_INTERNALNAME_STR            "Internal Name"
#define VER_ORIGINALFILENAME_STR        "Original Name"
#define VER_FILETYPE                    VFT_DLL

#include "iisver.h"
#include "common.ver"

**/
//
// Apps may also define, in the same place as the other defines, above:
// VER_FILESUBTYPE
// VER_IISPRODUCTNAME_STR
// VER_IISMAJORVERSION
// VER_IISMINORVERSION
// VER_IISPRODUCTVERSION_STR
// VER_IISPRODUCTVERSION
// VER_IISPRODUCTBUILD
//

#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "IIS Executable"
#endif

#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "IISFile.exe"
#endif

#ifndef VER_ORIGINALFILENAME_STR
#define VER_ORIGINALFILENAME_STR    VER_INTERNALNAME_STR
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifndef VER_IISPRODUCTNAME_STR
#define VER_IISPRODUCTNAME_STR      "Internet Information Services"
#endif

#define VER_PRODUCTNAME_STR         VER_IISPRODUCTNAME_STR

#ifndef VER_IISMAJORVERSION
#if _IIS_5_1
#define VER_IISMAJORVERSION         5
#else
#define VER_IISMAJORVERSION         6
#endif
#endif

#ifndef VER_IISMINORVERSION
#if _IIS_5_1
#define VER_IISMINORVERSION         1
#else
#define VER_IISMINORVERSION         0
#endif
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#define VER_IISPRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_IISMAJORVERSION, VER_IISMINORVERSION)

#define VER_IISPRODUCTVERSION_STR2(x,y) VER_IISPRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_IISPRODUCTVERSION_STR1(x,y) VER_IISPRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR          VER_IISPRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

//
// VER_PRODUCTBUILD is defined by ntverp.h as the nt build number
//

#ifndef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD            0984
#endif

#ifndef VER_IISPRODUCTBUILD
#define VER_IISPRODUCTBUILD         VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifndef VER_IISPRODUCTVERSION
#define VER_IISPRODUCTVERSION          VER_IISMAJORVERSION,VER_IISMINORVERSION,VER_IISPRODUCTBUILD,VER_PRODUCTBUILD_QFE
#endif

#define VER_PRODUCTVERSION          VER_IISPRODUCTVERSION

#ifndef VER_FILEVERSION
#define VER_FILEVERSION             VER_PRODUCTVERSION
#endif

#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef VER_FILESUBTYPE
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\inetsec.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetsec.h

Abstract:

    Contains prototype and data definitions for user security objects
    creation and access check functions.

    Adapted the code from \nt\private\net\inc\secobj.h

Author:

    Madan Appiah (madana)  19-Sep-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INETSEC_H_
#define _INETSEC_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID LocalAdminSid;             // NT local admins SID
extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid


//
// Structure to hold information about an ACE to be created
//

typedef struct {
    BYTE AceType;
    BYTE InheritFlags;
    BYTE AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} ACE_DATA, *PACE_DATA;

//
// Function prototypes
//

DWORD
INetCreateWellKnownSids(
    VOID
    );

VOID
INetFreeWellKnownSids(
    VOID
    );

DWORD
INetCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

DWORD
INetDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    );

#ifdef UNICODE
#define INetAccessCheckAndAudit  INetAccessCheckAndAuditW
#else
#define INetAccessCheckAndAudit  INetAccessCheckAndAuditA
#endif // !UNICODE

DWORD
INetAccessCheckAndAuditA(
    IN  LPCSTR SubsystemName,
    IN  LPSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

DWORD
INetAccessCheckAndAuditW(
    IN  LPCWSTR SubsystemName,
    IN  LPWSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

DWORD
INetAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

#ifdef __cplusplus
}
#endif


#endif  // _INETSEC_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\inetinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetinfo.h

Abstract:

    This file contains the internet info server admin APIs.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995  Made a new copy for product split from inetasrv.h
    MuraliK     12-Oct-1995  Fixes to support product split
    MuraliK     15-Nov-1995  Support Wide Char interface names

--*/

#ifndef _INETINFO_H_
#define _INETINFO_H_

# include "inetcom.h"
# include "iiscnfg.h"

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

/************************************************************
 *  Symbolic Constants
 ************************************************************/

//
//  The total number of instances of common services using the commong
//  service counters
//

#define MAX_PERF_CTR_SVCS              3
#define LAST_PERF_CTR_SVC              INET_HTTP_SVC_ID

#ifndef NO_AUX_PERF

#ifndef MAX_AUX_PERF_COUNTERS
#define MAX_AUX_PERF_COUNTERS          (20)
#endif // MAX_AUX_PERF_COUNTERS

#endif // NO_AUX_PERF

//
//  Service name.
//

#ifndef _EXEXPRESS
#define INET_INFO_SERVICE_NAME             TEXT("INETINFO")
#define INET_INFO_SERVICE_NAME_A           "INETINFO"
#define INET_INFO_SERVICE_NAME_W           L"INETINFO"
#else
#define INET_INFO_SERVICE_NAME             TEXT("KNETINFO")
#define INET_INFO_SERVICE_NAME_A           "KNETINFO"
#define INET_INFO_SERVICE_NAME_W           L"KNETINFO"
#define inetinfo_ServerIfHandle			   knetinfo_ServerIfHandle
#endif

//
// IIS Version number
//

#define IIS_VERSION_MAJOR           5
#define IIS_VERSION_MINOR           1


#define IIS_SERVER_VERSION_MAJOR           6
#define IIS_SERVER_VERSION_MINOR           0

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            TEXT("System\\CurrentControlSet\\Services\\InetInfo")

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY TEXT("\\Parameters")

//
//  If this registry key exists under the W3Svc\Parameters key,
//  it is used to validate server access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the Server.
//

#define INET_INFO_ACCESS_KEY                TEXT("AccessCheck")

//
// Special instances value
//

//
// First instance of the service.
//

#define INET_INSTANCE_FIRST                 0xf0000001

//
// None is used to support users of the old APIs where there was
// no concept of an instance.
//

#define INET_INSTANCE_DOWNLEVEL             0xf0000002

//
// indicates the the request is for global data
//

#define INET_INSTANCE_GLOBAL                0xf0000003

//
// root instance is a special instance which is not active
//

#define INET_INSTANCE_ROOT                  0

#define INET_INSTANCE_ALL                   0xffffffff

#define INET_INSTANCE_MIN                   (1)
#define INET_INSTANCE_MAX                   (0x7ffffffff)

//
//  Authentication requirements values
//

#define INET_INFO_AUTH_ANONYMOUS           MD_AUTH_ANONYMOUS
#define INET_INFO_AUTH_CLEARTEXT           MD_AUTH_BASIC
#define INET_INFO_AUTH_NT_AUTH             MD_AUTH_NT
#define INET_INFO_AUTH_MD5_AUTH            MD_AUTH_MD5
#define INET_INFO_AUTH_MAPBASIC            MD_AUTH_MAPBASIC

#define INET_INFO_AUTH_W95_MASK            INET_INFO_AUTH_ANONYMOUS

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define INET_INFO_ANONYMOUS_SECRET         TEXT("INET_INFO_ANONYMOUS_DATA")
#define INET_INFO_ANONYMOUS_SECRET_A       "INET_INFO_ANONYMOUS_DATA"
#define INET_INFO_ANONYMOUS_SECRET_W       L"INET_INFO_ANONYMOUS_DATA"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Internet Server Common Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

# define  INET_INFO_INTERFACE_NAME     INET_INFO_SERVICE_NAME
# define  INET_INFO_NAMED_PIPE         TEXT("\\PIPE\\") ## INET_INFO_INTERFACE_NAME
# define  INET_INFO_NAMED_PIPE_W  L"\\PIPE\\" ## INET_INFO_SERVICE_NAME_W


//
//  Field control values for the INET_INFO_CONFIG_INFO structure
//

#define FC_INET_INFO_CONNECTION_TIMEOUT    ((FIELD_CONTROL)BitFlag(0))
#define FC_INET_INFO_MAX_CONNECTIONS       ((FIELD_CONTROL)BitFlag(1))
#define FC_INET_INFO_LOG_CONFIG            ((FIELD_CONTROL)BitFlag(2))
#define FC_INET_INFO_ADMIN_NAME            ((FIELD_CONTROL)BitFlag(3))
#define FC_INET_INFO_SERVER_COMMENT        ((FIELD_CONTROL)BitFlag(4))
#define FC_INET_INFO_ADMIN_EMAIL           ((FIELD_CONTROL)BitFlag(5))
#define FC_INET_INFO_HOST_NAME             ((FIELD_CONTROL)BitFlag(6))
#define FC_INET_INFO_SERVER_SIZE           ((FIELD_CONTROL)BitFlag(7))

#define FC_INET_INFO_DEF_LOGON_DOMAIN      ((FIELD_CONTROL)BitFlag(15))
#define FC_INET_INFO_AUTHENTICATION        ((FIELD_CONTROL)BitFlag(16))
#define FC_INET_INFO_ALLOW_ANONYMOUS       ((FIELD_CONTROL)BitFlag(17))
#define FC_INET_INFO_LOG_ANONYMOUS         ((FIELD_CONTROL)BitFlag(18))
#define FC_INET_INFO_LOG_NONANONYMOUS      ((FIELD_CONTROL)BitFlag(19))
#define FC_INET_INFO_ANON_USER_NAME        ((FIELD_CONTROL)BitFlag(20))
#define FC_INET_INFO_ANON_PASSWORD         ((FIELD_CONTROL)BitFlag(21))
#define FC_INET_INFO_PORT_NUMBER           ((FIELD_CONTROL)BitFlag(22))
#define FC_INET_INFO_SITE_SECURITY         ((FIELD_CONTROL)BitFlag(23))
#define FC_INET_INFO_VIRTUAL_ROOTS         ((FIELD_CONTROL)BitFlag(24))
#define FC_INET_INFO_SECURE_PORT_NUMBER    ((FIELD_CONTROL)BitFlag(25))
#define FC_INET_INFO_SERVER_NAME           ((FIELD_CONTROL)BitFlag(26))
#define FC_INET_INFO_AUTO_START            ((FIELD_CONTROL)BitFlag(27))
#define FC_INET_INFO_ADDRESS_TYPE          ((FIELD_CONTROL)BitFlag(28))
#define FC_INET_INFO_IP_ADDRESS            ((FIELD_CONTROL)BitFlag(29))

// common parameters for publishing servers only
# define FC_INET_INFO_ALL              (FC_INET_INFO_CONNECTION_TIMEOUT |\
                                        FC_INET_INFO_MAX_CONNECTIONS    |\
                                        FC_INET_INFO_LOG_CONFIG         |\
                                        FC_INET_INFO_ADMIN_NAME         |\
                                        FC_INET_INFO_SERVER_COMMENT     |\
                                        FC_INET_INFO_ADMIN_EMAIL        |\
                                        FC_INET_INFO_HOST_NAME          |\
                                        FC_INET_INFO_SERVER_SIZE        |\
                                        FC_INET_INFO_AUTHENTICATION     |\
                                        FC_INET_INFO_ALLOW_ANONYMOUS    |\
                                        FC_INET_INFO_LOG_ANONYMOUS      |\
                                        FC_INET_INFO_LOG_NONANONYMOUS   |\
                                        FC_INET_INFO_ANON_USER_NAME     |\
                                        FC_INET_INFO_ANON_PASSWORD      |\
                                        FC_INET_INFO_PORT_NUMBER        |\
                                        FC_INET_INFO_SITE_SECURITY      |\
                                        FC_INET_INFO_VIRTUAL_ROOTS      |\
                                        FC_INET_INFO_SECURE_PORT_NUMBER |\
                                        FC_INET_INFO_SERVER_NAME        |\
                                        FC_INET_INFO_AUTO_START         |\
                                        FC_INET_INFO_ADDRESS_TYPE       |\
                                        FC_INET_INFO_IP_ADDRESS         |\
                                        FC_INET_INFO_DEF_LOGON_DOMAIN    \
                                        )

//
//  Virtual root access mask values
//

#define VROOT_MASK_READ                MD_ACCESS_READ
#define VROOT_MASK_WRITE               MD_ACCESS_WRITE
#define VROOT_MASK_EXECUTE             MD_ACCESS_EXECUTE
#define VROOT_MASK_READ_SOURCE         MD_ACCESS_SOURCE
#define VROOT_MASK_SSL                 MD_ACCESS_SSL
#define VROOT_MASK_DONT_CACHE          MD_ACCESS_DONT_CACHE
#define VROOT_MASK_NEGO_CERT           MD_ACCESS_NEGO_CERT
#define VROOT_MASK_NEGO_MANDATORY      MD_ACCESS_REQUIRE_CERT
#define VROOT_MASK_MAP_CERT            MD_ACCESS_MAP_CERT
#define VROOT_MASK_SSL128              MD_ACCESS_SSL128
#define VROOT_MASK_SCRIPT              MD_ACCESS_SCRIPT
#define VROOT_MASK_NO_REMOTE_READ      MD_ACCESS_NO_REMOTE_READ
#define VROOT_MASK_NO_REMOTE_WRITE     MD_ACCESS_NO_REMOTE_WRITE
#define VROOT_MASK_NO_REMOTE_EXECUTE   MD_ACCESS_NO_REMOTE_EXECUTE
#define VROOT_MASK_NO_REMOTE_SCRIPT    MD_ACCESS_NO_REMOTE_SCRIPT

#define VROOT_MASK_MASK                MD_ACCESS_MASK

//
//  INet admin API structures
//

typedef struct _INET_INFO_IP_SEC_ENTRY
{
    DWORD       dwMask;                  // Mask and network number in
    DWORD       dwNetwork;               // network order

} INET_INFO_IP_SEC_ENTRY, *LPINET_INFO_IP_SEC_ENTRY;

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

typedef struct _INET_INFO_IP_SEC_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_IP_SEC_ENTRY  aIPSecEntry[];

} INET_INFO_IP_SEC_LIST, *LPINET_INFO_IP_SEC_LIST;


typedef struct _INET_INFO_SITE_ENTRY
{
    LPWSTR  pszComment;               // Site Comment
    DWORD   dwInstance;               // Site Instance Number

} INET_INFO_SITE_ENTRY, *LPINET_INFO_SITE_ENTRY;

typedef struct _INET_INFO_SITE_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_SITE_ENTRY  aSiteEntry[];

} INET_INFO_SITE_LIST, *LPINET_INFO_SITE_LIST;


typedef struct _INET_INFO_VIRTUAL_ROOT_ENTRY
{
    LPWSTR  pszRoot;                  // Virtual root name
    LPWSTR  pszAddress;               // Optional IP address
    LPWSTR  pszDirectory;             // Physical direcotry
    DWORD   dwMask;                   // Mask for this virtual root
    LPWSTR  pszAccountName;           // Account to connect as
    WCHAR   AccountPassword[PWLEN+1]; // Password for pszAccountName
    DWORD   dwError;                  // Error code if entry wasn't added
                                      // only used for gets

} INET_INFO_VIRTUAL_ROOT_ENTRY, *LPINET_INFO_VIRTUAL_ROOT_ENTRY;

typedef struct _INET_INFO_VIRTUAL_ROOT_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_VIRTUAL_ROOT_ENTRY  aVirtRootEntry[];

} INET_INFO_VIRTUAL_ROOT_LIST, *LPINET_INFO_VIRTUAL_ROOT_LIST;

//
//  Admin configuration information
//

typedef struct _INET_INFO_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD       dwConnectionTimeout;     // how long to hold connections
    DWORD       dwMaxConnections;        // max connections allowed

    LPWSTR      lpszAdminName;
    LPWSTR      lpszAdminEmail;
    LPWSTR      lpszServerComment;

    LPINET_LOG_CONFIGURATION  lpLogConfig;

    LANGID      LangId;                  // These are read only
    LCID        LocalId;
    BYTE        ProductId[64];

    BOOL        fLogAnonymous;           // Log Anonymous users?
    BOOL        fLogNonAnonymous;        // Log Non anonymous users?

    LPWSTR      lpszAnonUserName;        // Anonymous user name?
    WCHAR       szAnonPassword[PWLEN+1]; // Password for the anonymous user

    DWORD       dwAuthentication;        // What authentication is enabled?

    short       sPort;                   // Port Number for service

    LPINET_INFO_IP_SEC_LIST DenyIPList;      // Site security deny list
    LPINET_INFO_IP_SEC_LIST GrantIPList;     // Site security grant list

    LPINET_INFO_VIRTUAL_ROOT_LIST VirtualRoots; // Symlinks to other data dirs

} INET_INFO_CONFIG_INFO, * LPINET_INFO_CONFIG_INFO;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Global Internet Server Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define FC_GINET_INFO_BANDWIDTH_LEVEL      ((FIELD_CONTROL)BitFlag(0))
#define FC_GINET_INFO_MEMORY_CACHE_SIZE    ((FIELD_CONTROL)BitFlag(1))


#define FC_GINET_INFO_ALL \
                (   FC_GINET_INFO_BANDWIDTH_LEVEL      | \
                    FC_GINET_INFO_MEMORY_CACHE_SIZE    | \
                    0                                \
                    )

typedef struct _INET_INFO_GLOBAL_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         BandwidthLevel;          // Bandwidth Level used.
    DWORD         cbMemoryCacheSize;

} INET_INFO_GLOBAL_CONFIG_INFO, * LPINET_INFO_GLOBAL_CONFIG_INFO;

//
// Global statistics
//

typedef struct _INET_INFO_STATISTICS_0
{

    INETA_CACHE_STATISTICS  CacheCtrs;
    INETA_ATQ_STATISTICS    AtqCtrs;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} INET_INFO_STATISTICS_0, * LPINET_INFO_STATISTICS_0;

//
// Capabilities Flags
//

typedef struct _INET_INFO_CAP_FLAGS {

    DWORD   Flag;   // Which capabilities are enabled
    DWORD   Mask;   // Which capabilities are supported

} INET_INFO_CAP_FLAGS, * LPINET_INFO_CAP_FLAGS;

//
// Inet info server capabilities
//

typedef struct _INET_INFO_CAPABILITIES {

    DWORD   CapVersion;     // Version number of this structure
    DWORD   ProductType;    // Product type
    DWORD   MajorVersion;   // Major version number
    DWORD   MinorVersion;   // Minor Version number
    DWORD   BuildNumber;    // Build number
    DWORD   NumCapFlags;    // Number of capabilities structures

    LPINET_INFO_CAP_FLAGS    CapFlags;

} INET_INFO_CAPABILITIES, * LPINET_INFO_CAPABILITIES;

//
//  Location of FrontPage web registry settings if installed
//

#define REG_FP_PATH        "Software\\Microsoft\\FrontPage\\3.0"

//
// Product type
//

#define INET_INFO_PRODUCT_NTSERVER          0x00000001
#define INET_INFO_PRODUCT_NTWKSTA           0x00000002
#define INET_INFO_PRODUCT_WINDOWS95         0x00000003
#define INET_INFO_PRODUCT_UNKNOWN           0xffffffff

//
// Settable server capabilities
//

#define IIS_CAP1_ODBC_LOGGING               0x00000001
#define IIS_CAP1_FILE_LOGGING               0x00000002
#define IIS_CAP1_VIRTUAL_SERVER             0x00000004
#define IIS_CAP1_BW_THROTTLING              0x00000008
#define IIS_CAP1_IP_ACCESS_CHECK            0x00000010
#define IIS_CAP1_MAX_CONNECTIONS            0x00000020
#define IIS_CAP1_10_CONNECTION_LIMIT        0x00000040
#define IIS_CAP1_MULTIPLE_INSTANCE          0x00000080
#define IIS_CAP1_SSL_SUPPORT                0x00000100
#define IIS_CAP1_OPERATORS_LIST             0x00000200
#define IIS_CAP1_CPU_AUDITING               0x00000800
#define IIS_CAP1_SERVER_COMPRESSION         0x00001000
#define IIS_CAP1_DAV                        0x00002000
#define IIS_CAP1_POOLED_OOP                 0x00010000

//
// Get or'd in at runtime after checking the network configuration
//

#define IIS_CAP1_DIGEST_SUPPORT             0x00004000
#define IIS_CAP1_NT_CERTMAP_SUPPORT         0x00008000

//
//  Gets 'or'ed in at runtime after checking the registry
//

#define IIS_CAP1_FP_INSTALLED               0x00000400

#define IIS_CAP1_ALL  ( IIS_CAP1_ODBC_LOGGING       |   \
                        IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_VIRTUAL_SERVER     |   \
                        IIS_CAP1_BW_THROTTLING      |   \
                        IIS_CAP1_IP_ACCESS_CHECK    |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT|   \
                        IIS_CAP1_MULTIPLE_INSTANCE  |   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_OPERATORS_LIST     |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_CPU_AUDITING       |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_NTS  ( IIS_CAP1_ODBC_LOGGING       |   \
                        IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_VIRTUAL_SERVER     |   \
                        IIS_CAP1_BW_THROTTLING      |   \
                        IIS_CAP1_IP_ACCESS_CHECK    |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_MULTIPLE_INSTANCE  |   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_OPERATORS_LIST     |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_CPU_AUDITING       |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_NTW  ( IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT|   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_W95  ( IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT    \
                        )

//
//  INet admin API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetServerCapabilities(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES * ppCap
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_INFO_GLOBAL_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_INFO_GLOBAL_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_INFO_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  HTTP (w3) specific items                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

#define W3_SERVICE_NAME                TEXT("W3SVC")
#define W3_SERVICE_NAME_A              "W3SVC"
#define W3_SERVICE_NAME_W              L"W3SVC"

# define  W3_INTERFACE_NAME     W3_SERVICE_NAME
# define  W3_NAMED_PIPE         TEXT("\\PIPE\\") ## W3_INTERFACE_NAME
# define  W3_NAMED_PIPE_W       L"\\PIPE\\" ## W3_SERVICE_NAME_W

//
// Built-in application package ID's and class ID's
//

#define W3_INPROC_PACKAGE_ID    L"{3D14228C-FBE1-11d0-995D-00C04FD919C1}"
#define W3_OOP_POOL_PACKAGE_ID  L"{3D14228D-FBE1-11d0-995D-00C04FD919C1}"
#define W3_INPROC_WAM_CLSID     L"{99169CB0-A707-11d0-989D-00C04FD919C1}"
#define W3_OOP_POOL_WAM_CLSID   L"{99169CB1-A707-11d0-989D-00C04FD919C1}"


//
//  Manifests for APIs
//

#define FC_W3_DIR_BROWSE_CONTROL       ((FIELD_CONTROL)BitFlag(0))
#define FC_W3_DEFAULT_LOAD_FILE        ((FIELD_CONTROL)BitFlag(1))
#define FC_W3_CHECK_FOR_WAISDB         ((FIELD_CONTROL)BitFlag(2))
#define FC_W3_DIRECTORY_IMAGE          ((FIELD_CONTROL)BitFlag(3))
#define FC_W3_SERVER_AS_PROXY          ((FIELD_CONTROL)BitFlag(4))
#define FC_W3_CATAPULT_USER_AND_PWD    ((FIELD_CONTROL)BitFlag(5))
#define FC_W3_SSI_ENABLED              ((FIELD_CONTROL)BitFlag(6))
#define FC_W3_SSI_EXTENSION            ((FIELD_CONTROL)BitFlag(7))
#define FC_W3_GLOBAL_EXPIRE            ((FIELD_CONTROL)BitFlag(8))
#define FC_W3_SCRIPT_MAPPING           ((FIELD_CONTROL)BitFlag(9))
#define FC_W3_CGI_SCRIPT_TIMEOUT       ((FIELD_CONTROL)BitFlag(10))
#define FC_W3_POOL_ODBC_CONN_TIME      ((FIELD_CONTROL)BitFlag(11))
#define FC_W3_CACHE_ISAPI_APPS         ((FIELD_CONTROL)BitFlag(12))
#define FC_W3_USE_KEEP_ALIVES          ((FIELD_CONTROL)BitFlag(13))
#define FC_W3_ENABLE_HEADER_DOC        ((FIELD_CONTROL)BitFlag(14))
#define FC_W3_HEADER_DOC_NAME          ((FIELD_CONTROL)BitFlag(15))
#define FC_W3_ENABLE_FOOT_DOC          ((FIELD_CONTROL)BitFlag(16))
#define FC_W3_FOOTER_DOC_NAME          ((FIELD_CONTROL)BitFlag(17))
#define FC_W3_CUSTOMER_HEADERS         ((FIELD_CONTROL)BitFlag(18))




#define FC_W3_ALL                      (FC_W3_DIR_BROWSE_CONTROL | \
                                        FC_W3_DEFAULT_LOAD_FILE  | \
                                        FC_W3_CHECK_FOR_WAISDB   | \
                                        FC_W3_DIRECTORY_IMAGE    | \
                                        FC_W3_SERVER_AS_PROXY    | \
                                        FC_W3_CATAPULT_USER_AND_PWD |\
                                        FC_W3_SSI_ENABLED        | \
                                        FC_W3_SSI_EXTENSION      | \
                                        FC_W3_GLOBAL_EXPIRE      | \
                                        FC_W3_SCRIPT_MAPPING     | \
                                        FC_W3_CGI_SCRIPT_TIMEOUT | \
                                        FC_W3_POOL_ODBC_CONN_TIME| \
                                        FC_W3_CACHE_ISAPI_APPS   | \
                                        FC_W3_USE_KEEP_ALIVES    | \
                                        FC_W3_ENABLE_HEADER_DOC  | \
                                        FC_W3_HEADER_DOC_NAME    | \
                                        FC_W3_ENABLE_FOOT_DOC    | \
                                        FC_W3_FOOTER_DOC_NAME    | \
                                        FC_W3_CUSTOMER_HEADERS     \
                                        )

//
//  HTTP Directory browsing flags
//

//#define DIRBROW_SHOW_ICON           0x00000001
#define DIRBROW_SHOW_DATE           MD_DIRBROW_SHOW_DATE
#define DIRBROW_SHOW_TIME           MD_DIRBROW_SHOW_TIME
#define DIRBROW_SHOW_SIZE           MD_DIRBROW_SHOW_SIZE
#define DIRBROW_SHOW_EXTENSION      MD_DIRBROW_SHOW_EXTENSION
#define DIRBROW_LONG_DATE           MD_DIRBROW_LONG_DATE

#define DIRBROW_ENABLED             MD_DIRBROW_ENABLED
#define DIRBROW_LOADDEFAULT         MD_DIRBROW_LOADDEFAULT

#define DIRBROW_MASK                MD_DIRBROW_MASK

//
//  Setting the csecGlobalExpire field to this value will prevent the server
//  from generating an "Expires:" header.
//

#define NO_GLOBAL_EXPIRE           0xffffffff

//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | \
                                    ENC_CAPS_PCT)

#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

//
//  Structures for APIs
//

typedef struct _W3_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} W3_USER_INFO, * LPW3_USER_INFO;

typedef struct _W3_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;

    DWORD         TotalGets;
    DWORD         TotalPosts;
    DWORD         TotalHeads;
    DWORD         TotalOthers;      // Other HTTP verbs
    DWORD         TotalCGIRequests;
    DWORD         TotalBGIRequests;
    DWORD         TotalNotFoundErrors;

    DWORD         CurrentCGIRequests;
    DWORD         CurrentBGIRequests;
    DWORD         MaxCGIRequests;
    DWORD         MaxBGIRequests;

    DWORD         TimeOfLastClear;
# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} W3_STATISTICS_0, * LPW3_STATISTICS_0;

typedef struct _W3_STATISTICS_1
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;

    DWORD         TotalOptions;
    DWORD         TotalGets;
    DWORD         TotalPosts;
    DWORD         TotalHeads;
    DWORD         TotalPuts;
    DWORD         TotalDeletes;
    DWORD         TotalTraces;
    DWORD         TotalMove;
    DWORD         TotalCopy;
    DWORD         TotalMkcol;
    DWORD         TotalPropfind;
    DWORD         TotalProppatch;
    DWORD         TotalSearch;
    DWORD         TotalLock;
    DWORD         TotalUnlock;
    DWORD         TotalOthers;      // Other HTTP verbs
    DWORD         TotalCGIRequests;
    DWORD         TotalBGIRequests;
    DWORD         TotalNotFoundErrors;
    DWORD         TotalLockedErrors;

    DWORD         CurrentCalAuth;
    DWORD         MaxCalAuth;
    DWORD         TotalFailedCalAuth;
    DWORD         CurrentCalSsl;
    DWORD         MaxCalSsl;
    DWORD         TotalFailedCalSsl;

    DWORD         CurrentCGIRequests;
    DWORD         CurrentBGIRequests;
    DWORD         MaxCGIRequests;
    DWORD         MaxBGIRequests;

    // bandwidth throttling info

    DWORD         CurrentBlockedRequests;
    DWORD         TotalBlockedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         MeasuredBw;
    DWORD         ServiceUptime;

    DWORD         TimeOfLastClear;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} W3_STATISTICS_1, * LPW3_STATISTICS_1;

typedef struct _W3_SCRIPT_MAP_ENTRY
{
    LPWSTR lpszExtension;
    LPWSTR lpszImage;
} W3_SCRIPT_MAP_ENTRY, *LPW3_SCRIPT_MAP_ENTRY;

typedef struct _W3_SCRIPT_MAP_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    W3_SCRIPT_MAP_ENTRY  aScriptMap[];

} W3_SCRIPT_MAP_LIST, *LPW3_SCRIPT_MAP_LIST;

typedef struct _W3_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         dwDirBrowseControl;       // Directory listing and def. load
    LPWSTR        lpszDefaultLoadFile;      // File to load if feature is on
    BOOL          fCheckForWAISDB;          // Call waislookup if .dct found?
    LPWSTR        lpszDirectoryImage;       // Image for directory in file list
    BOOL          fServerAsProxy;           // Run server as a proxy if TRUE
    LPWSTR        lpszCatapultUser;         // The user/password to impersonate
    WCHAR         szCatapultUserPwd[PWLEN+1]; // if the proxy server is using
                                            // the catapult server

    BOOL          fSSIEnabled;              // Are server side includes enabled?
    LPWSTR        lpszSSIExtension;         // Extension for server side inc.

    DWORD         csecGlobalExpire;         // Value to set Expires: header to

    LPW3_SCRIPT_MAP_LIST ScriptMap;         // List of extension mappings

    DWORD         dwEncCaps;                // Encryption capabilities

} W3_CONFIG_INFO, *LPW3_CONFIG_INFO;

//
// API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
W3GetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPW3_CONFIG_INFO *    ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3SetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPW3_CONFIG_INFO    pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3EnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPW3_USER_INFO * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3DisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  FTP specific items                                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
//
//  Service name.
//

#define FTPD_SERVICE_NAME               TEXT("MSFTPSVC")
#define FTPD_SERVICE_NAME_A              "MSFTPSVC"
#define FTPD_SERVICE_NAME_W             L"MSFTPSVC"


//
//   Client Interface Name for RPC connections over named pipes
//

# define  FTP_INTERFACE_NAME     FTPD_SERVICE_NAME
# define  FTP_NAMED_PIPE         TEXT("\\PIPE\\") ## FTP_INTERFACE_NAME
# define  FTP_NAMED_PIPE_W       L"\\PIPE\\" ## FTPD_SERVICE_NAME_W


//
//  Manifests for APIs.
//

#define FC_FTP_ALLOW_ANONYMOUS          ((FIELD_CONTROL)BitFlag( 0))
#define FC_FTP_ALLOW_GUEST_ACCESS       ((FIELD_CONTROL)BitFlag( 1))
#define FC_FTP_ANNOTATE_DIRECTORIES     ((FIELD_CONTROL)BitFlag( 2))
#define FC_FTP_ANONYMOUS_ONLY           ((FIELD_CONTROL)BitFlag( 3))
#define FC_FTP_EXIT_MESSAGE             ((FIELD_CONTROL)BitFlag( 4))
#define FC_FTP_GREETING_MESSAGE         ((FIELD_CONTROL)BitFlag( 5))
#define FC_FTP_HOME_DIRECTORY           ((FIELD_CONTROL)BitFlag( 6))
#define FC_FTP_LISTEN_BACKLOG           ((FIELD_CONTROL)BitFlag( 7))
#define FC_FTP_LOWERCASE_FILES          ((FIELD_CONTROL)BitFlag( 8))
#define FC_FTP_MAX_CLIENTS_MESSAGE      ((FIELD_CONTROL)BitFlag( 9))
#define FC_FTP_MSDOS_DIR_OUTPUT         ((FIELD_CONTROL)BitFlag(10))

#define FC_FTP_READ_ACCESS_MASK         ((FIELD_CONTROL)BitFlag(11))
#define FC_FTP_WRITE_ACCESS_MASK        ((FIELD_CONTROL)BitFlag(12))
#define FC_FTP_ALLOW_REPLACE_ON_RENAME  ((FIELD_CONTROL)BitFlag(13))
#define FC_FTP_SHOW_4_DIGIT_YEAR        ((FIELD_CONTROL)BitFlag(14))
#define FC_FTP_BANNER_MESSAGE           ((FIELD_CONTROL)BitFlag(15))
#define FC_FTP_USER_ISOLATION           ((FIELD_CONTROL)BitFlag(16))
#define FC_FTP_LOG_IN_UTF_8             ((FIELD_CONTROL)BitFlag(17))

#define FC_FTP_ALL                      (                                  \
                                          FC_FTP_ALLOW_ANONYMOUS         | \
                                          FC_FTP_ALLOW_GUEST_ACCESS      | \
                                          FC_FTP_ANNOTATE_DIRECTORIES    | \
                                          FC_FTP_ANONYMOUS_ONLY          | \
                                          FC_FTP_EXIT_MESSAGE            | \
                                          FC_FTP_GREETING_MESSAGE        | \
                                          FC_FTP_HOME_DIRECTORY          | \
                                          FC_FTP_LISTEN_BACKLOG          | \
                                          FC_FTP_LOWERCASE_FILES         | \
                                          FC_FTP_MAX_CLIENTS_MESSAGE     | \
                                          FC_FTP_MSDOS_DIR_OUTPUT        | \
                                          FC_FTP_READ_ACCESS_MASK        | \
                                          FC_FTP_WRITE_ACCESS_MASK       | \
                                          FC_FTP_ALLOW_REPLACE_ON_RENAME | \
                                          FC_FTP_SHOW_4_DIGIT_YEAR       | \
                                          FC_FTP_BANNER_MESSAGE          | \
                                          FC_FTP_USER_ISOLATION          | \
                                          FC_FTP_LOG_IN_UTF_8            | \
                                          0 )


//
//  Structures for APIs.
//

typedef struct _FTP_CONFIG_INFO
{
    FIELD_CONTROL   FieldControl;

    BOOL            fAllowAnonymous;
    BOOL            fAllowGuestAccess;
    BOOL            fAnnotateDirectories;
    BOOL            fAnonymousOnly;
    LPWSTR          lpszExitMessage;
    LPWSTR          lpszGreetingMessage;
    LPWSTR          lpszHomeDirectory;
    DWORD           dwListenBacklog;
    BOOL            fLowercaseFiles;
    LPWSTR          lpszMaxClientsMessage;
    BOOL            fMsdosDirOutput;
    BOOL            fFourDigitYear;
    LPWSTR          lpszBannerMessage;
    DWORD           dwUserIsolationMode;
    BOOL            fLogInUtf8;

} FTP_CONFIG_INFO, * LPFTP_CONFIG_INFO;


//
//  API Prototypes.
//

NET_API_STATUS
NET_API_FUNCTION
FtpGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPFTP_CONFIG_INFO *   ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
FtpSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPFTP_CONFIG_INFO   pConfig
    );


# include <ftpd.h>

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Gopher specific items                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
//  Service name.
//

# define GOPHERD_SERVICE_NAME           TEXT("GopherSvc")
# define GOPHERD_SERVICE_NAME_A         "GopherSvc"
# define GOPHERD_SERVICE_NAME_W         L"GopherSvc"

//
//   Client Interface Name for RPC connections over named pipes
//
# define  GOPHERD_INTERFACE_NAME     GOPHERD_SERVICE_NAME
# define  GOPHERD_NAMED_PIPE         TEXT("\\PIPE\\") ## GOPHERD_INTERFACE_NAME
# define  GOPHERD_NAMED_PIPE_W       L"\\PIPE\\" ## GOPHERD_SERVICE_NAME_W

//
// Gopher port
//

#define IPPORT_GOPHER               0x46

/************************************************************
 *   Symbolic Constants
 *   Prefix GDA_  stands for Gopher Daemon Admin
 ************************************************************/

# define   GDA_SITE                   ((FIELD_CONTROL ) BitFlag( 1)) // SZ
# define   GDA_ORGANIZATION           ((FIELD_CONTROL ) BitFlag( 2)) // SZ
# define   GDA_LOCATION               ((FIELD_CONTROL ) BitFlag( 3)) // SZ
# define   GDA_GEOGRAPHY              ((FIELD_CONTROL ) BitFlag( 4)) // SZ
# define   GDA_LANGUAGE               ((FIELD_CONTROL ) BitFlag( 5)) // SZ
# define   GDA_CHECK_FOR_WAISDB       ((FIELD_CONTROL ) BitFlag( 8)) // BOOL

# define   GDA_DEBUG_FLAGS            ((FIELD_CONTROL ) BitFlag( 30)) // DWORD

# define   GDA_ALL_CONFIG_INFO        ( GDA_SITE         | \
                                        GDA_ORGANIZATION | \
                                        GDA_LOCATION     | \
                                        GDA_GEOGRAPHY    | \
                                        GDA_LANGUAGE     | \
                                        GDA_CHECK_FOR_WAISDB | \
                                        GDA_DEBUG_FLAGS    \
                                       )

# define   GOPHERD_ANONYMOUS_SECRET_W       L"GOPHERD_ANONYMOUS_DATA"
# define   GOPHERD_ROOT_SECRET_W            L"GOPHERD_ROOT_DATA"


//
// Configuration information is the config data that is communicated
//  b/w the server and admin UI
//
typedef struct  _GOPHERD_CONFIG_INFO {

    FIELD_CONTROL  FieldControl;        // bit mask indicating fields set.

    LPWSTR      lpszSite;               // Name of Gopher site
    LPWSTR      lpszOrganization;       // Organization Name
    LPWSTR      lpszLocation;           // Location of server
    LPWSTR      lpszGeography;          // Geographical data
    LPWSTR      lpszLanguage;           // Language for server

    BOOL        fCheckForWaisDb;        // Check & allow Wais Db

    //  Debugging data
    DWORD       dwDebugFlags;           // Bitmap of debugging data

} GOPHERD_CONFIG_INFO, * LPGOPHERD_CONFIG_INFO;


typedef struct _GOPHERD_STATISTICS_INFO {

    LARGE_INTEGER   TotalBytesSent;
    LARGE_INTEGER   TotalBytesRecvd;

    DWORD           TotalFilesSent;
    DWORD           TotalDirectoryListings;
    DWORD           TotalSearches;

    DWORD           CurrentAnonymousUsers;
    DWORD           CurrentNonAnonymousUsers;
    DWORD           MaxAnonymousUsers;
    DWORD           MaxNonAnonymousUsers;
    DWORD           TotalAnonymousUsers;
    DWORD           TotalNonAnonymousUsers;

    DWORD           TotalConnections;
    DWORD           MaxConnections;
    DWORD           CurrentConnections;

    DWORD           ConnectionAttempts;     // raw connections made
    DWORD           LogonAttempts;          // total logons attempted
    DWORD           AbortedAttempts;        // Aborted connections
    DWORD           ErroredConnections;     // # in Error when processed

    DWORD           GopherPlusRequests;

    DWORD           TimeOfLastClear;
} GOPHERD_STATISTICS_INFO,  * LPGOPHERD_STATISTICS_INFO;


//
//   GOPHERD_USER_INFO  contains details about connected users.
//   This structure may undergo modification. Currently UserInformation
//    is not supported.
//

typedef struct _GOPHERD_USER_INFO  {

    DWORD   dwIdUser;               // Id for user
    LPWSTR  lpszUserName;           // User name
    BOOL    fAnonymous;             // TRUE if user logged on as anonymous
                                    //  FALSE otherwise
    DWORD   dwInetHost;             // host address for client

    //
    //  Other details if required
    //
} GOPHERD_USER_INFO, * LPGOPHERD_USER_INFO;



/************************************************************
 * Gopher Server RPC APIs
 ************************************************************/


//
//  Server Administrative Information
//

DWORD
NET_API_FUNCTION
GdGetAdminInformation(
    IN      LPWSTR                  pszServer  OPTIONAL,
    OUT     LPGOPHERD_CONFIG_INFO * ppConfigInfo
    );

DWORD
NET_API_FUNCTION
GdSetAdminInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPGOPHERD_CONFIG_INFO   pConfigInfo
    );



//
//  API for Users enumeration  ( Not Yet Supported).
//

DWORD
NET_API_FUNCTION
GdEnumerateUsers(
    IN      LPWSTR      pszServer OPTIONAL,
    OUT     LPDWORD     lpnEntriesRead,
    OUT     LPGOPHERD_USER_INFO * lpUserBuffer
    );

DWORD
NET_API_FUNCTION
GdDisconnectUser(
    IN      LPWSTR      pszServer  OPTIONAL,
    IN      DWORD       dwIdUser
    );


//
// Statistics API
//

DWORD
NET_API_FUNCTION
GdGetStatistics(
    IN      LPWSTR      pszServer  OPTIONAL,
    OUT     LPBYTE      lpStatBuffer        // pass LPGOPHERD_STATISTICS_INFO
    );


DWORD
NET_API_FUNCTION
GdClearStatistics(
    IN      LPWSTR      pszServer  OPTIONAL
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Catapult specific items                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

# define INET_GATEWAY_INTERFACE_NAME    TEXT("gateway")


// preserve back ward compatibility
typedef INET_INFO_CONFIG_INFO    INETA_CONFIG_INFO,
                               * LPINETA_CONFIG_INFO;
typedef INET_INFO_IP_SEC_ENTRY   INETA_IP_SEC_ENTRY,
                               * LPINETA_IP_SEC_ENTRY;
typedef INET_INFO_IP_SEC_LIST    INETA_IP_SEC_LIST,
                               * LPINETA_IP_SEC_LIST;
typedef INET_INFO_VIRTUAL_ROOT_ENTRY  INETA_VIRTUAL_ROOT_ENTRY,
                               * LPINETA_VIRTUAL_ROOT_ENTRY;
typedef INET_INFO_VIRTUAL_ROOT_LIST  INETA_VIRTUAL_ROOT_LIST,
                               * LPINETA_VIRTUAL_ROOT_LIST;

typedef INET_INFO_GLOBAL_CONFIG_INFO   INETA_GLOBAL_CONFIG_INFO,
                               * LPINETA_GLOBAL_CONFIG_INFO;

typedef   INET_INFO_STATISTICS_0    INETA_STATISTICS_0,
                               * LPINETA_STATISTICS_0;

#define INETA_PARAMETERS_KEY    (INET_INFO_PARAMETERS_KEY)


#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _INETINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\inetaccs.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetaccs.h

Abstract:

    This file contains the internet access server admin APIs.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995     Made a new copy for product split from inetasrv.h
    Sophiac     16-Oct-1995     Added common statistics apis for perfmon
    MuraliK     14-Dec-1995     Changed Interface names to use Service names

--*/

#ifndef _INETACCS_H_
#define _INETACCS_H_

#include <inetcom.h>

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


/************************************************************
 *  Symbolic Constants
 ************************************************************/

#ifndef NO_AUX_PERF

#ifndef MAX_AUX_PERF_COUNTERS
#define MAX_AUX_PERF_COUNTERS          (20)
#endif // MAX_AUX_PERF_COUNTERS

#endif // NO_AUX_PERF

//
//  Service name.
//

#define INET_ACCS_SERVICE_NAME             TEXT("INETACCS")
#define INET_ACCS_SERVICE_NAME_A           "INETACCS"
#define INET_ACCS_SERVICE_NAME_W           L"INETACCS"

//
//  Configuration parameters registry key.
//

#define INET_ACCS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\inetaccs")

#define INET_ACCS_PARAMETERS_KEY \
            INET_ACCS_KEY TEXT("\\Parameters")

#define INET_ACCS_CACHE_KEY                TEXT("Cache")
#define INET_ACCS_FILTER_KEY               TEXT("Filter")

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Internet Server Common Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

# define INET_ACCS_INTERFACE_NAME  INET_ACCS_SERVICE_NAME
# define INET_ACCS_NAMED_PIPE      TEXT("\\PIPE\\") ## INET_ACCS_INTERFACE_NAME
# define INET_ACCS_NAMED_PIPE_W    L"\\PIPE\\" ## INET_ACCS_SERVICE_NAME_W

//
// Field Control common for Gateway services
//

#define FC_INET_ACCS_ALL                FC_INET_COM_ALL

//
//  Admin configuration information
//

typedef struct _INET_ACCS_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    //
    // don't add any service specific config parameter here.
    //

    INET_COM_CONFIG_INFO CommonConfigInfo;

    //
    // add service specific parameters here.
    //

} INET_ACCS_CONFIG_INFO, * LPINET_ACCS_CONFIG_INFO;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Global Internet Server Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define FC_GINET_ACCS_MEMORY_CACHE_SIZE    ((FIELD_CONTROL)BitFlag(1))
#define FC_GINET_ACCS_DISK_CACHE_TIMEOUT   ((FIELD_CONTROL)BitFlag(2))
#define FC_GINET_ACCS_DISK_CACHE_UPDATE    ((FIELD_CONTROL)BitFlag(3))
#define FC_GINET_ACCS_FRESHNESS_INTERVAL   ((FIELD_CONTROL)BitFlag(4))
#define FC_GINET_ACCS_CLEANUP_INTERVAL     ((FIELD_CONTROL)BitFlag(5))
#define FC_GINET_ACCS_CLEANUP_FACTOR       ((FIELD_CONTROL)BitFlag(6))
#define FC_GINET_ACCS_CLEANUP_TIME         ((FIELD_CONTROL)BitFlag(7))
#define FC_GINET_ACCS_PERSISTENT_CACHE     ((FIELD_CONTROL)BitFlag(8))
#define FC_GINET_ACCS_DISK_CACHE_LOCATION  ((FIELD_CONTROL)BitFlag(9))
#define FC_GINET_ACCS_BANDWIDTH_LEVEL      ((FIELD_CONTROL)BitFlag(10))
#define FC_GINET_ACCS_DOMAIN_FILTER_CONFIG ((FIELD_CONTROL)BitFlag(11))


#define FC_GINET_ACCS_ALL              (FC_GINET_ACCS_MEMORY_CACHE_SIZE    | \
                                        FC_GINET_ACCS_DISK_CACHE_TIMEOUT   | \
                                        FC_GINET_ACCS_DISK_CACHE_UPDATE    | \
                                        FC_GINET_ACCS_FRESHNESS_INTERVAL   | \
                                        FC_GINET_ACCS_CLEANUP_INTERVAL     | \
                                        FC_GINET_ACCS_CLEANUP_FACTOR       | \
                                        FC_GINET_ACCS_CLEANUP_TIME         | \
                                        FC_GINET_ACCS_PERSISTENT_CACHE     | \
                                        FC_GINET_ACCS_DISK_CACHE_LOCATION  | \
                                        FC_GINET_ACCS_BANDWIDTH_LEVEL      | \
                                        FC_GINET_ACCS_DOMAIN_FILTER_CONFIG | \
                                        0                                \
                                        )

//
//  Disk cache settings
//

typedef struct _INET_ACCS_DISK_CACHE_LOC_ENTRY
{
    LPWSTR pszDirectory;                 // Directory for temporary files
    DWORD  cbMaxCacheSize;               // Maximum number of bytes (in 1024
                                         // byte increments)
} INET_ACCS_DISK_CACHE_LOC_ENTRY, *LPINET_ACCS_DISK_CACHE_LOC_ENTRY;


#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

typedef struct _INET_ACCS_DISK_CACHE_LOC_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_ACCS_DISK_CACHE_LOC_ENTRY  aLocEntry[];

} INET_ACCS_DISK_CACHE_LOC_LIST, *LPINET_ACCS_DISK_CACHE_LOC_LIST;

//
//  Domain Filter settings
//

typedef struct _INET_ACCS_DOMAIN_FILTER_ENTRY
{
    DWORD     dwMask;                    // Mask and network number in
    DWORD     dwNetwork;                 // network order
    LPSTR     pszFilterSite;             // domain filter site name

} INET_ACCS_DOMAIN_FILTER_ENTRY, *LPINET_ACCS_DOMAIN_FILTER_ENTRY;

typedef struct _INET_ACCS_DOMAIN_FILTER_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_ACCS_DOMAIN_FILTER_ENTRY  aFilterEntry[];

} INET_ACCS_DOMAIN_FILTER_LIST, *LPINET_ACCS_DOMAIN_FILTER_LIST;

//
// Domain Filter Types
//

#define INET_ACCS_DOMAIN_FILTER_DISABLED     0
#define INET_ACCS_DOMAIN_FILTER_DENIED       1
#define INET_ACCS_DOMAIN_FILTER_GRANT        2

typedef struct _INET_ACCS_GLOBAL_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         cbMemoryCacheSize;       // Size of memory cache

    DWORD         DiskCacheTimeOut;        // Remove if not accessed in this
                                           // time (in seconds)
    DWORD         DiskCacheUpdate;         // When to refresh the data (sec)

    DWORD         FreshnessInterval;       // Time to refresh the data

    DWORD         CleanupInterval;         // Time interval between unused
                                           // file cleanups (sec)
    DWORD         CleanupFactor;           // % of the cache storage freed up
                                           // during cleanup
    DWORD         CleanupTime;             // scheduled time to clean up

    DWORD         PersistentCache;         // Allow cache not to be cleaned

    LPINET_ACCS_DISK_CACHE_LOC_LIST  DiskCacheList;

    DWORD         BandwidthLevel;          // Bandwidth Level used.
    DWORD         DomainFilterType;        // set to either DENIED
                                           // or GRANT or DISABLED
    LPINET_ACCS_DOMAIN_FILTER_LIST  GrantFilterList;
                                           // domain filter granted sites
    LPINET_ACCS_DOMAIN_FILTER_LIST  DenyFilterList;
                                           // domain filter denied sites

} INET_ACCS_GLOBAL_CONFIG_INFO, * LPINET_ACCS_GLOBAL_CONFIG_INFO;


//
// Global statistics
//

typedef struct _INET_ACCS_STATISTICS_0
{

    INET_COM_CACHE_STATISTICS  CacheCtrs;
    INET_COM_ATQ_STATISTICS    AtqCtrs;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} INET_ACCS_STATISTICS_0, * LPINET_ACCS_STATISTICS_0;


//
//  Inet Access admin API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_ACCS_GLOBAL_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_ACCS_GLOBAL_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_ACCS_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_ACCS_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETACCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\inetcom.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetcom.h

Abstract:

    This file contains contains global definitions for internet products.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

--*/

#ifndef _INETCOM_H_
#define _INETCOM_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <lmcons.h>              // for definitions of NET_API*

#ifndef dllexp
# define dllexp     __declspec( dllexport)
#endif // dllexp

//
//  Server bitfield mask definitions
//
//  The services using the tsunami cache must be the lowest bits in the
//  bitfield.
//

#define INET_FTP                INET_FTP_SVC_ID
#define INET_GOPHER             INET_GOPHER_SVC_ID
#define INET_HTTP               INET_HTTP_SVC_ID

//
// service ids
//

#define INET_FTP_SVC_ID             0x00000001
#define INET_GOPHER_SVC_ID          0x00000002
#define INET_HTTP_SVC_ID            0x00000004
#define INET_DNS_SVC_ID             0x00000008

#define INET_HTTP_PROXY             0x00000010
#define INET_NNTP_SVC_ID            0x00000040
#define INET_SMTP_SVC_ID            0x00000080
#define INET_GATEWAY_SVC_ID         0x00000100
#define INET_POP3_SVC_ID            0x00000200
#define INET_CHAT_SVC_ID            0x00000400
#define INET_LDAP_SVC_ID            0x00000800
#define INET_IMAP_SVC_ID            0x00001000

//
//  structure Field Control defines
//

typedef DWORD FIELD_CONTROL;
typedef DWORD FIELD_FLAG;

//
//  Returns TRUE if the field specified by bitFlag is set
//

#define IsFieldSet(fc, bitFlag) \
    (((FIELD_CONTROL)(fc) & (FIELD_FLAG)(bitFlag)) != 0)

//
//  Indicates the field specified by bitFlag contains a valid value
//

#define SetField(fc, bitFlag) \
    ((FIELD_CONTROL)(fc) |= (FIELD_FLAG)(bitFlag))

//
//  Simple macro that sets the ith bit
//

#define BitFlag(i)                    ((0x1) << (i))


//
//  Values for Logging related parameters should match with values in
//       internet\svcs\inc\inetlog.h
//

//
// Log Type
//

#define INET_LOG_INVALID              ((DWORD ) -1)
#define INET_LOG_DISABLED             0
#define INET_LOG_TO_FILE              1
#define INET_LOG_TO_SQL               2

//
// Log File Periods -- options identifying logging periods for InetaLogToFile
//

#define INET_LOG_PERIOD_INVALID       ((DWORD)-1)
#define INET_LOG_PERIOD_NONE          0
#define INET_LOG_PERIOD_DAILY         1
#define INET_LOG_PERIOD_WEEKLY        2
#define INET_LOG_PERIOD_MONTHLY       3
#define INET_LOG_PERIOD_HOURLY        4
#define INET_LOG_PERIOD_YEARLY        5     // unsupported

//
// Log Format
//

#define INET_LOG_FORMAT_INTERNET_STD  0
#define INET_LOG_FORMAT_NCSA          3
#define INET_LOG_FORMAT_BINARY        1
#define INET_LOG_FORMAT_CUSTOM        2
#define INET_LOG_FORMAT_EXTENDED      2


# define MAX_TABLE_NAME_LEN            ( 30) // Most DBs support only 30 bytes
# define MAX_USER_NAME_LEN             ( UNLEN + 1)
# define MAX_PASSWORD_LEN              ( PWLEN + 1)


typedef struct _INET_LOG_CONFIGURATION
{

    DWORD   inetLogType;    // type of log.

    // File specific logging. (valid if inetLogType == INET_LOG_TO_FILE)
    DWORD   ilPeriod;              // one of Log File Periods

    // Empty string means do not modify existing default
    WCHAR   rgchLogFileDirectory[MAX_PATH]; // dest for log files

    // Zero value means do not modify the existing default.
    DWORD   cbSizeForTruncation;   // max size for each log file.


    // Sql specific logging (valid if inetLogType == INET_LOG_TO_SQL)
    // Empty string means do not modify existing default

    // rgchDataSource last 4 bytes will be the ilFormat for the log format
    // rgchDataSource second last 4 bytes will be the binary mask for the binary logging format

    WCHAR   rgchDataSource[MAX_PATH];    // ODBC data source name
    WCHAR   rgchTableName[MAX_TABLE_NAME_LEN];    // table name on data source
    WCHAR   rgchUserName[MAX_USER_NAME_LEN];
                                         // name of user for ODBC connections
    WCHAR   rgchPassword[MAX_PASSWORD_LEN];     // password for ODBC connection

} INET_LOG_CONFIGURATION, * LPINET_LOG_CONFIGURATION;


//
// Global statistics
//

typedef struct _INETA_CACHE_STATISTICS {

    //
    //  These are file handle cache counters (global only)
    //
    DWORD FilesCached;         // # of files currently in the cache
    DWORD TotalFilesCached;    // # of files added to the cache ever
    DWORD FileHits;            // cache hits
    DWORD FileMisses;          // cache misses
    DWORD FileFlushes;         // flushes due to dir change or other
    DWORDLONG CurrentFileCacheSize;// Current file cache size
    DWORDLONG MaximumFileCacheSize;// Maximum file cache size
    DWORD FlushedEntries;      // # of flushed entries still kicking around
    DWORD TotalFlushed;        // # of entries ever flushed from the cache

    //
    //  These are URI cache counters (global only)
    //
    DWORD URICached;           // # of files currently in the cache
    DWORD TotalURICached;      // # of files added to the cache ever
    DWORD URIHits;             // cache hits
    DWORD URIMisses;           // cache misses
    DWORD URIFlushes;          // flushes due to dir change or other
    DWORD TotalURIFlushed;     // # of entries ever flushed from the cache

    //
    //  These are blob cache counters (global only)
    //
    DWORD BlobCached;          // # of files currently in the cache
    DWORD TotalBlobCached;     // # of files added to the cache ever
    DWORD BlobHits;            // cache hits
    DWORD BlobMisses;          // cache misses
    DWORD BlobFlushes;         // flushes due to dir change or other
    DWORD TotalBlobFlushed;    // # of entries ever flushed from the cache

} INETA_CACHE_STATISTICS, *LPINETA_CACHE_STATISTICS;

typedef struct _INETA_ATQ_STATISTICS {

    // Numbers related to Atq Blocking, Rejections of requests
    DWORD         TotalBlockedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;

} INETA_ATQ_STATISTICS, *LPINETA_ATQ_STATISTICS;

//
// service types for InternetConnect() and dirlist
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3


#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\iscaptrc.h ===
#ifndef _ISCAPTRC_H
#define _ISCAPTRC_H
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iscaptrc.h

Abstract:

    Include file to contain variables required for capacity planning tracing
    of IIS.

Author:

    07-Nov-1998  SaurabN

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

dllexp
ULONG
_stdcall
IISInitializeCapTrace(
    PVOID Param
    );

dllexp 
DWORD 
GetIISCapTraceFlag();

dllexp 
TRACEHANDLE 
GetIISCapTraceLoggerHandle();

dllexp 
VOID 
SetIISCapTraceFlag(DWORD dwFlag);

typedef struct _IIS_CAP_TRACE_HEADER
{
	EVENT_TRACE_HEADER	TraceHeader;
	MOF_FIELD			TraceContext;

} IIS_CAP_TRACE_HEADER, *PIIS_CAP_TRACE_HEADER;

typedef struct _IIS_CAP_TRACE_INFO
{
	IIS_CAP_TRACE_HEADER	IISCapTraceHeader;
	MOF_FIELD				MofFields[3];
	
} IIS_CAP_TRACE_INFO, *PIIS_CAP_TRACE_INFO;

#endif /* _ISCAPTRC_H*/

#define IIS_CAP_TRACE_VERSION            1

//
// This is the control Guid for the group of Guids traced below
//

// {7380A4C4-7911-11d2-8BD7-080009DCC2FA}

DEFINE_GUID(IISCapControlGuid, 
0x7380a4c4, 0x7911, 0x11d2, 0x8b, 0xd7, 0x8, 0x0, 0x9, 0xdc, 0xc2, 0xfa);

//
// This is the trace guid
//

// {7380A4C5-7911-11d2-8BD7-080009DCC2FA}

DEFINE_GUID(IISCapTraceGuid, 
0x7380a4c5, 0x7911, 0x11d2, 0x8b, 0xd7, 0x8, 0x0, 0x9, 0xdc, 0xc2, 0xfa);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define RUNNING_AS_SERVICE 1

#include <tchar.h>

# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>
#   define IRTLASSERT(f) DBG_ASSERT(f)
#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)           IRTLASSERT(f)
#  define DEBUG_ONLY(f)           (f)
#  define TRACE                   IrtlTrace
#  define TRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define TRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define TRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define TRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !_DEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  define DEBUG_ONLY(f)           ((void)0)
#  define TRACE                   1 ? (void)0 : IrtlTrace
#  define TRACE0(psz)
#  define TRACE1(psz, p1)
#  define TRACE2(psz, p1, p2)
#  define TRACE3(psz, p1, p2, p3)
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !_DEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef _DEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !_DEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !_DEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\infoimp.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        infoimp.h

   Abstract:
        This file allows us to include standard system headers files
          in the .idl file.
        The main .idl file imports a file called "imports.idl". This
          allows the .idl file to use the types defined in these headers.
        It also causes the following lines to be added to the MIDL generated
          files:
            # include "infoimp.h"

        Thus the routines and types defined here are available for RPC
            stub routines as well.

   Author:

           Murali R. Krishnan    ( MuraliK )    10-Nov-1994

   Project:

           Information Services Generic Imports file

   Revision History:

--*/

# ifndef _INFO_IMPORTS_H_
# define _INFO_IMPORTS_H_

# include <windef.h>
# include <lmcons.h>

#ifdef MIDL_PASS

#define  LPWSTR [string]  wchar_t *
#define  LPSTR  [string]  char*
#define  BOOL   DWORD

#endif // MIDL_PASS


#include "inetcom.h"
#include "inetinfo.h"
#include "apiutil.h"  // defines MIDL_user_allocate() & MIDL_user_free()

#endif // _INFO_IMPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\inetsvcs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsvcs.h

Abstract:

    Header file for Internet Services common data/functions.

Author:

    Murali R. Krishnan (MuraliK)   20-Feb-1996  - Migrated from old tcpsvcs.h

Revision History:

--*/

#ifndef _INETSVCS_H_
#define _INETSVCS_H_

//
// Service DLLs are loaded into master service executable (eg: inetinfo.exe)
//   All the dlls should export this entry point
//    defined by INETSVCS_ENTRY_POINT
//
// Note that INETSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define INETSVCS_ENTRY_POINT         ServiceEntry
#define INETSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PINETSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#ifndef _NO_TRACING_
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; DBGPRINTF( (DBG_CONTEXT, buff )); }
#else
#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif
#endif

#define BUG_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }


#define INIT_LOCK(_lock)        InitializeCriticalSection( _lock );
#define DELETE_LOCK(_lock)      DeleteCriticalSection( _lock );
#define ACQUIRE_LOCK(_lock)     EnterCriticalSection( _lock );
#define RELEASE_LOCK(_lock)     LeaveCriticalSection( _lock );

//
// Event used to indicate whether service is running as exe
//

#define IIS_AS_EXE_OBJECT_NAME  "Internet_infosvc_as_exe"


#endif	// ifndef _INETSVCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Heap routines
    
// Private IIS heap
HANDLE
WINAPI 
IisHeap();

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes);

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes);

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes);

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem);

// additional IISRTL initialization
BOOL
WINAPI 
InitializeIISRTL();

// call before unloading IISRTL
void
WINAPI 
TerminateIISRTL();

// case-insensitive strstr
IRTL_DLLEXP const char* stristr(const char* pszString, const char* pszSubString);

// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// how many CPUs on this machine?
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\lstentry.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__


//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\isplat.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       isplat.h

   Abstract:

        Exports platform data types for Internet Services.

   Author:

       Johnson Apacible     (johnsona)      29-Feb-1996

   Project:

       Internet Server DLLs

   Revision History:

--*/

 // Just to ensure the the old platform type does not cause problems
# define _ISPLAT_H_ 

# ifndef _ISPLAT_H_
# define _ISPLAT_H_

# if !defined( dllexp)
#define dllexp __declspec( dllexport )
# endif // dllexp

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// Used to get the platform type
//

dllexp
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// external macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)

//
// infocomm internal
//

extern
PLATFORM_TYPE    TsPlatformType;

#define TsIsNtServer( )         InetIsNtServer(TsPlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(TsPlatformType)
#define TsIsWindows95()         InetIsWindows95(TsPlatformType)

# ifdef __cplusplus
}; // extern "C"
# endif // __cplusplus


# endif // _ISPLAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

   llsapi.h

Abstract:

   License logging server's RPC API's.

Author:

   Arthur Hanson (arth) 21-Mar-1995

Environment:

   User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 04-Dec-1995
      o  Added type definitions, macros, and prototypes for extended RPC APIs
         and license certificate APIs (available only post-3.51).
      o  Corrected prototypes for LlsServerEnumW(), LlsServerEnumA(),
         LlsLocalProductInfoGetW(), and LlsLocalProductInfoGetA().

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;
typedef PVOID LLS_REPL_HANDLE, *PLLS_REPL_HANDLE;

#define LLS_INVALID_LICENSE_HANDLE  ( 0xFFFFFFFF )

#define LLS_NUM_SECRETS             ( 4 )

typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;

typedef struct _LLS_LICENSE_INFO_1 {
   LPTSTR Product;
   LPTSTR Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_LICENSE_INFO_1, *PLLS_LICENSE_INFO_1;

typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;

typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1 {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_PRODUCT_LICENSE_INFO_1, *PLLS_PRODUCT_LICENSE_INFO_1;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0
{
   TCHAR    ServerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0, *PLLS_CERTIFICATE_CLAIM_INFO_0;

typedef struct _LLS_LOCAL_SERVICE_INFO_0
{
   LPTSTR   KeyName;
   LPTSTR   DisplayName;
   LPTSTR   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0, *PLLS_LOCAL_SERVICE_INFO_0;

#define LLS_LICENSE_MODE_PER_SEAT            ( 0 )
#define LLS_LICENSE_MODE_PER_SERVER          ( 1 )

#define LLS_LICENSE_MODE_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_MODE_ALLOW_PER_SERVER    ( 2 )

#define LLS_LICENSE_FLIP_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_FLIP_ALLOW_PER_SERVER    ( 2 )


// capability flags; query with LlsCapabilityIsSupported
#define LLS_CAPABILITY_SECURE_CERTIFICATES         (  0 )
#define LLS_CAPABILITY_REPLICATE_CERT_DB           (  1 )
#define LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY  (  2 )
#define LLS_CAPABILITY_REPLICATE_USERS_EX          (  3 )
#define LLS_CAPABILITY_SERVICE_INFO_GETW           (  4 )
#define LLS_CAPABILITY_LOCAL_SERVICE_API           (  5 )
#define LLS_CAPABILITY_MAX                         ( 32 )


//***************************************************
//* Nt LS API data constants
//* (for use with LlsLicenseRequest() API)
//***************************************************

#define NT_LS_USER_NAME               ((ULONG) 0)  // username only
#define NT_LS_USER_SID                ((ULONG) 1)  // SID only


#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#  define LlsConnect LlsConnectW
#else
#  define LlsConnect LlsConnectA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_W)( LPWSTR, PLLS_HANDLE );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_A)( LPSTR,  PLLS_HANDLE );

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_W)( LPWSTR, PLLS_HANDLE, DWORD, LPBYTE * );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_A)( LPSTR,  PLLS_HANDLE, DWORD, LPBYTE * );

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

typedef NTSTATUS (NTAPI *PLLS_CLOSE)( LLS_HANDLE );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_W)( LLS_HANDLE, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_A)( LLS_HANDLE, DWORD, LPBYTE );

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif
//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif


//////////////////////////////////////////////////////////////////////////////
//  LLS EXTENDED API  //
////////////////////////

BOOL
NTAPI
LlsCapabilityIsSupported(
   LLS_HANDLE  Handle,
   DWORD       Capability );

typedef BOOL (NTAPI *PLLS_CAPABILITY_IS_SUPPORTED)( LLS_HANDLE, DWORD );

NTSTATUS
NTAPI
LlsProductSecurityGetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product,
   OUT LPBOOL     pSecurity
   );

NTSTATUS
NTAPI
LlsProductSecurityGetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product,
   OUT LPBOOL     pSecurity
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_W)( LLS_HANDLE, LPWSTR, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_A)( LLS_HANDLE, LPSTR,  LPBOOL );

#ifdef UNICODE
#  define LlsProductSecurityGet LlsProductSecurityGetW
#else
#  define LlsProductSecurityGet LlsProductSecurityGetA
#endif

NTSTATUS
NTAPI
LlsProductSecuritySetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product
   );

NTSTATUS
NTAPI
LlsProductSecuritySetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_W)( LLS_HANDLE, LPWSTR );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_A)( LLS_HANDLE, LPSTR  );

#ifdef UNICODE
#  define LlsProductSecuritySet LlsProductSecuritySetW
#else
#  define LlsProductSecuritySet LlsProductSecuritySetA
#endif

NTSTATUS
NTAPI
LlsProductLicensesGetW(
   IN LLS_HANDLE         Handle,
   IN LPWSTR             DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

NTSTATUS
NTAPI
LlsProductLicensesGetA(
   IN LLS_HANDLE         Handle,
   IN LPSTR              DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_W)( LLS_HANDLE, LPWSTR, DWORD, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_A)( LLS_HANDLE, LPSTR,  DWORD, LPDWORD );

#ifdef UNICODE
#  define LlsProductLicensesGet LlsProductLicensesGetW
#else
#  define LlsProductLicensesGet LlsProductLicensesGetA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimEnumW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

NTSTATUS
NTAPI
LlsCertificateClaimEnumA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_W)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_A)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );

#ifdef UNICODE
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumW
#else
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_A)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );

#ifdef UNICODE
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckW
#else
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddW(
   IN LLS_HANDLE        Handle,
   IN LPWSTR            ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

NTSTATUS
NTAPI
LlsCertificateClaimAddA(
   IN LLS_HANDLE        Handle,
   IN LPSTR             ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_W)( LLS_HANDLE, LPWSTR, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_A)( LLS_HANDLE, LPSTR,  DWORD, LPBYTE );

#ifdef UNICODE
#  define LlsCertificateClaimAdd LlsCertificateClaimAddW
#else
#  define LlsCertificateClaimAdd LlsCertificateClaimAddA
#endif


NTSTATUS
NTAPI
LlsReplicationCertDbAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Certificates );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_CERT_DB_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     SecureProducts );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationUserAddExW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Users );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_EX_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsLocalServiceEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

NTSTATUS
NTAPI
LlsLocalServiceEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

#ifdef UNICODE
#  define LlsLocalServiceEnum LlsLocalServiceEnumW
#else
#  define LlsLocalServiceEnum LlsLocalServiceEnumA
#endif

NTSTATUS
NTAPI
LlsLocalServiceAddW(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

NTSTATUS
NTAPI
LlsLocalServiceAddA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceAdd LlsLocalServiceAddW
#else
#  define LlsLocalServiceAdd LlsLocalServiceAddA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoSetW(
   LLS_HANDLE Handle,
   LPWSTR     KeyName,
   DWORD      Level,
   LPBYTE     bufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoSetA(
   LLS_HANDLE  Handle,
   LPSTR       KeyName,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetW
#else
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoGetW(
   LLS_HANDLE  Handle,
   LPWSTR      KeyName,
   DWORD       Level,
   LPBYTE *    pbufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoGetA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPSTR       KeyName,
   LPBYTE *    pbufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetW
#else
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsLicenseRequestW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequestA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest LlsLicenseRequestW
#else
#  define LlsLicenseRequest LlsLicenseRequestA
#endif

NTSTATUS
NTAPI
LlsLicenseFree(
   LLS_HANDLE  Handle,
   DWORD       LicenseHandle );

//////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

#define CCF_ENTER_FLAG_PER_SEAT_ONLY         ( 1 )
#define CCF_ENTER_FLAG_PER_SERVER_ONLY       ( 2 )
#define CCF_ENTER_FLAG_SERVER_IS_ES          ( 4 )

// prototype for certificate source enter API
typedef DWORD (APIENTRY *PCCF_ENTER_API)(    HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags );

DWORD APIENTRY CCFCertificateEnterUI(        HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

// prototype for certificate source remove API
typedef DWORD (APIENTRY *PCCF_REMOVE_API)(   HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             DWORD    dwFlags,
                                             DWORD    dwLicenseLevel,
                                             LPVOID   lpvLicenseInfo );

DWORD APIENTRY CCFCertificateRemoveUI(       HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")
#define REG_KEY_CONFIG   TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")

#define REG_VALUE_NAME     TEXT("DisplayName")
#define REG_VALUE_FAMILY   TEXT("FamilyDisplayName")
#define REG_VALUE_MODE     TEXT("Mode")
#define REG_VALUE_FLIP     TEXT("FlipAllow")
#define REG_VALUE_LIMIT    TEXT("ConcurrentLimit")
#define REG_VALUE_HIGHMARK TEXT("LocalKey")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\lkrhash.h ===
/*++


   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

       Deprecated: Use the version in %sdxroot%\inetsrv\iis\iisrearc\core\inc
       instead.

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#define LKR_COMPACT_DELETE 1
#define LKR_NEWCODE 1
// #define LKR_FIND_FIRST 1
#define LKR_SUBTABLE 1
#define LKR_MASK 1


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:    typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Debugging support for iisprobe and inetdbg?
// * Use auto_ptrs.
// * Provide ReplaceRecord and DeleteRecord methods on iterators.
// * Sloppy iterators
// * Provide implementations of the STL collection classes, map, set,
//   multimap, and multiset.
// * Make exception safe.
//--------------------------------------------------------------------


#include <irtldbg.h>
#include <lstentry.h>
#include <hashfn.h>
#include <limits.h>



#ifdef __LKRHASH_NAMESPACE__
namespace LKRHash {
#endif // __LKRHASH_NAMESPACE__

enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};

// Default values for the hashtable constructors
enum {
    LK_DFLT_MAXLOAD=     4, // Default upperbound on average chain length.
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};

// build fix hack
enum {
    DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
    DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
    DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
};

//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT, class _Iter>
class CTypedHashTable;


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};


//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much a
// slowdown having a global lock on the CLKRHashTable causes.  It is *never*
// used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#define LKRHASH_ACACHE 1
// #define LKRHASH_MANODEL 1
// #define LKRHASH_MADEL 1

// #define LKRHASH_MEM_DEFAULT_ALIGN 32

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("IISRTL:" #C, &acc);

#elif defined(LKRHASH_MANODEL)

# include <manodel.hxx>
  typedef MEMORY_ALLOC_NO_DELETE  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new MEMORY_ALLOC_NO_DELETE(sizeof(C),        \
                                              LKRHASH_MEM_DEFAULT_ALIGN);

#elif defined(LKRHASH_MADEL)

# include <madel.hxx>
  typedef MEMORY_ALLOC_DELETE  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new MEMORY_ALLOC_DELETE(sizeof(C),           \
                                           LKRHASH_MEM_DEFAULT_ALIGN, N);

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



// Used to initialize and destroy custom allocators
bool LKRHashTableInit();
void LKRHashTableUninit();


#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend bool LKRHashTableInit();                         \
        friend void LKRHashTableUninit();                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
          IRTLASSERT(s == sizeof(C));                           \
          IRTLASSERT(sm_palloc != NULL);                        \
          return sm_palloc->Alloc();                            \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
          IRTLASSERT(pv != NULL);                               \
          IRTLASSERT(sm_palloc != NULL);                        \
          sm_palloc->Free(pv);                                  \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKRHASH_ALLOCATOR_NEW(C, N);                        \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    // typedef CSmallSpinLock   TableLock;
    // typedef CFakeLock        TableLock;
    // typedef CSpinLock        TableLock;
    // typedef CSpinLock2       TableLock;
    // typedef CSpinLock3       TableLock;
    // typedef CShareLock       TableLock;
    // typedef CReaderWriterLock  TableLock;
    // typedef CReaderWriterLock2 TableLock;
    typedef CReaderWriterLock3 TableLock;

    typedef CSmallSpinLock   BucketLock;
    // typedef CFakeLock        BucketLock;
    // typedef CSpinLock        BucketLock;
    // typedef CSpinLock2       BucketLock;
    // typedef CSpinLock3       BucketLock;
    // typedef CShareLock       BucketLock;
    // typedef CReaderWriterLock  BucketLock;
    // typedef CReaderWriterLock2 BucketLock;
    // typedef CReaderWriterLock3 BucketLock;

    class CIterator;
    friend class CLKRLinearHashTable::CIterator;

private:
    class CNodeClump;
    friend class CLKRLinearHashTable::CNodeClump;

    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION

    enum {
        // Given M = A % B, A and B unsigned 32-bit integers greater than zero,
        // there are no values of A or B which yield M = 2^32-1.  Why?  Because
        // M must be less than B.
        HASH_INVALID_SIGNATURE = ULONG_MAX,
    };


    // Class for nodes on a bucket chain.  Instead of a node containing
    // one (signature, record-pointer, next-tuple-pointer) tuple, it
    // contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
    // This improves locality of reference greatly; i.e., it's L1
    // cache-friendly.  It also reduces memory fragmentation and memory
    // allocator overhead.  It does complicate the chain traversal code
    // slightly, admittedly.
    //
    // This theory is beautiful.  In practice, however, CNodeClumps
    // are *not* perfectly aligned on 32-byte boundaries by the memory
    // allocators.  Experimental results indicate that we get a 2-3%
    // speed improvement by using 32-byte-aligned blocks, but this must
    // be considered against the average of 16 bytes wasted per block.

    class CNodeClump
    {
    public:
        // Record slots per chunk - set so a chunk matches (one or
        // two) cache lines.  2 ==> 28 bytes, 6 ==> 60 bytes
        // Note: the default max load factor is 4.0, which implies that
        // there will seldom be more than one node clump in a chain.
        enum {
            BUCKET_BYTE_SIZE = 64,
            BUCKET_OVERHEAD  = sizeof(BucketLock) + sizeof(CNodeClump*),
            NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
            NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
        };

        DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
        CNodeClump* m_pncNext;               // next node clump on the chain
        const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

        CNodeClump()
        {
            Clear();
        }

        void
        Clear()
        {
            m_pncNext = NULL;  // no dangling pointers
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  ++i)
            {
                m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                m_pvNode[i] = NULL;
            }
        }

        bool
        InvalidSignature(
            int i) const
        {
            IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
            return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
        }

        bool
        IsEmptyNode(
            int i) const
        {
            IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
            return (m_pvNode[i] == NULL);
        }

        bool
        IsLastClump() const
        {
            return (m_pncNext == NULL);
        }

#ifdef _DEBUG
        // Don't want overhead of calls to dtor in retail build
        ~CNodeClump()
        {
            IRTLASSERT(IsLastClump());  // no dangling pointers
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  ++i)
                IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
    };


    // Class for bucket chains of the hash table.  Note that the first
    // nodeclump is actually included in the bucket and not dynamically
    // allocated, which increases space requirements slightly but does
    // improve performance.
    class CBucket
    {
    private:
        mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
        static LONG sm_cBuckets;

        static const char*
        _LockName()
        {
            LONG l = ++sm_cBuckets;
            // possible race condition but we don't care, as this is never
            // used in production code
            static char s_szName[CLockStatistics::L_NAMELEN];
            wsprintf(s_szName, "B%06x", 0xFFFFFF & l);
            return s_szName;
        }
#endif // LOCK_INSTRUMENTATION

    public:
        CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(_DEBUG)
        CBucket()
#ifdef LOCK_INSTRUMENTATION
            : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
        {
#ifdef _DEBUG
            LOCK_LOCKTYPE lt = BucketLock::LockType();
            if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
                IRTLASSERT(sizeof(*this) <= 64);
#endif _DEBUG
        }
#endif // LOCK_INSTRUMENTATION || _DEBUG

        void  WriteLock()           { m_Lock.WriteLock(); }
        void  ReadLock() const      { m_Lock.ReadLock(); }
        void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
        void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
        bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
        bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
        bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
        bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
        void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
        WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
        CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
    };


    // The hash table space is divided into fixed-size segments (arrays of
    // CBuckets) and physically grows/shrinks one segment at a time.

    // We provide small, medium, and large segments to better tune the
    // overall memory requirements of the hash table according to the
    // expected usage of an instance.

    class CSegment
    {
    public:
        virtual ~CSegment() {}; // link fails if this is pure virtual
        virtual DWORD Bits() const = 0;
        virtual DWORD Size() const = 0;
        virtual DWORD Mask() const = 0;
        virtual DWORD InitSize() const = 0;
        virtual CBucket& Slot(DWORD i) = 0;
    };


    // Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
    class CSmallSegment : public CSegment
    {
    public:
        // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
        enum {
            SEGBITS  =            3,// number of bits extracted from a hash
                                    // address for offset within a segment
            SEGSIZE  = (1<<SEGBITS),// segment size
            SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
            INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CSmallSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#ifdef _DEBUG
        CSmallSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this)
                       == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
    };


    // Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
    class CMediumSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            6,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 2 * SEGSIZE,
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CMediumSegment()       {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#ifdef _DEBUG
        CMediumSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this)
                       == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
    };

    // Large-sized segments contain 2^9 = 512 buckets => ~32Kb
    class CLargeSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            9,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 4 * SEGSIZE,
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CLargeSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }


#ifdef _DEBUG
        CLargeSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this)
                       == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
    };


    // A directory keeps track of the segments comprising the hash table.
    // The directory is just a variable-sized array of pointers to
    // segments (CDirEntrys).
    class CDirEntry
    {
    public:
        // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
        // of anything else.  Should be powers of two.
        enum {
            MIN_DIRSIZE =  (1<<3),   // minimum directory size
            MAX_DIRSIZE = (1<<20),   // maximum directory size
        };

        CSegment* m_pseg;

        CDirEntry()
            : m_pseg(NULL)
        {}

        ~CDirEntry()
        { delete m_pseg; }
    };

public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE     = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE     = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE       = 16,
    };


private:

    // Miscellaneous helper functions

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
#ifdef LKR_MASK
    { return _H0(dwSignature, m_dwBktAddrMask1); }
#else // !LKR_MASK
    { return _H1(dwSignature, m_dwBktAddrMask); }
#endif // !LKR_MASK

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
#ifdef LKR_SUBTABLE
        return (*m_pfnExtractKey)(pvRecord);
#else
        return (pvRecord != NULL)  ?  (*m_pfnExtractKey)(pvRecord)  :  NULL;
#endif
    }

    // Hash a key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
        dwHash = HashScramble(dwHash);
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature. The bucket is locked before
    // returning. Assumes table is already locked, to avoid race conditions.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const
    {
        IRTLASSERT(IsValid());
        IRTLASSERT(m_dwBktAddrMask > 0);
        IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask+1)) == 0); // 00011..111
        IRTLASSERT(m_dwBktAddrMask == (1U << m_nLevel) - 1);
#ifdef LKR_MASK
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
#endif // LKR_MASK
        IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask);
        IRTLASSERT(0 < m_dwSegBits  &&  m_dwSegBits < 20
                   &&  m_dwSegSize == (1U << m_dwSegBits)
                   &&  m_dwSegMask == (m_dwSegSize - 1));
        IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());

        const DWORD dwBktAddr = _BucketAddress(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);

        CBucket* const pbkt = _Bucket(dwBktAddr);
        IRTLASSERT(pbkt != NULL);

        if (fLockForWrite)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        return pbkt;
    }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    static bool
    _FreeSegmentDirectory(
        CDirEntry* paDirSegs);

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "LH%05x", 0xFFFFF & l);
        return s_szName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask;  // mask used for address calculation
#ifdef LKR_MASK
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
#endif // LKR_MASK
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

#ifdef LKR_NEWCODE
    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;

    void        _InsertThisIntoGlobalList()
    {
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
    }

    void        _RemoveThisFromGlobalList()
    {
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
    }
#endif // LKR_NEWCODE

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite);
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

#ifdef LKR_COMPACT_DELETE
    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;
#endif // LKR_COMPACT_DELETE


    // Predicate functions
    static LK_PREDICATE _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
    void         _Clear(bool fShrinkDirectory);


    void         _SetSegVars(LK_TABLESIZE lkts);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&)
        : m_dwSignature(SIGNATURE_FREE)
#ifdef LOCK_INSTRUMENTATION
        , m_Lock(NULL)
#endif // LOCK_INSTRUMENTATION
#ifdef LKR_NEWCODE
        , m_nTableLockType(0),
          m_nBucketLockType(0),
          m_phtParent(NULL)
#endif // LKR_NEWCODE
    {*(BYTE*)NULL;}

    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&)
    {return *(CLKRLinearHashTable*)NULL;}

#ifdef LKR_NEWCODE
private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent       // Owning table.
        );
#endif // LKR_NEWCODE

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS  // for signature compatiblity
                                                  // with CLKRHashTable
        );

    ~CLKRLinearHashTable();

    static const char* ClassName()           {return "CLKRLinearHashTable";}
    int                NumSubTables() const  {return 1;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;
#endif

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);

    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Prints the table (to where??)
    void           Print() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  (MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0  // == (1 << N)
                  &&  (MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0
                  &&  MAX_DIRSIZE > MIN_DIRSIZE
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount()
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    // Lock manipulators

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of the
    // iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Should call ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);
    //
    // If record has no reference-counting semantics, then you can ignore
    // the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    };

    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };

private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };
};



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

    class CIterator;
    friend class CLKRHashTable::CIterator;
    friend class CLKRLinearHashTable;

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table

#ifdef LKR_NEWCODE
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;

    void
    _InsertThisIntoGlobalList()
    {
        sm_llGlobalList.InsertHead(&m_leGlobalList);
    }

    void
    _RemoveThisFromGlobalList()
    {
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
    }
#endif // LKR_NEWCODE

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&)             {*(BYTE*)NULL;}
    CLKRHashTable& operator=(const CLKRHashTable&)  {return *(CLKRHashTable*)NULL;}


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
#ifdef LKR_SUBTABLE
        return (*m_pfnExtractKey)(pvRecord);
#else
        return (pvRecord != NULL)  ?  (*m_pfnExtractKey)(pvRecord)  :  NULL;
#endif
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
        dwHash = HashScramble(dwHash);
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const
    {
        IRTLASSERT(m_lkrcState == LK_SUCCESS
                   && m_palhtDir != NULL  &&  m_cSubTables > 0);
#ifndef LKR_SUBTABLE
        if (m_lkrcState == LK_SUCCESS)
        {
#endif
            const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
            DWORD       index = (dwSignature % PRIME) % m_cSubTables;
            return m_palhtDir[index];
#ifndef LKR_SUBTABLE
        }
        else
            return NULL;
#endif
    }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent       // Owning table.
    );

    static bool
    _FreeSubTable(
        SubTable* plht);

public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS  // #subordinate hash tables.
        );

    ~CLKRHashTable();

    static const char* ClassName()           {return "CLKRHashTable";}
    int                NumSubTables() const  {return m_cSubTables;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst = _SubTable(hash_val);
#ifdef LKR_SUBTABLE
        LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);
#else
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_InsertRecord(pvRecord, hash_val,
                                                     fOverwrite)
                               :  LK_UNUSABLE);
#endif
        LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;
#endif

        LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(pnKey);
        SubTable* const pst = _SubTable(hash_val);
#ifdef LKR_SUBTABLE
        LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val);
#else
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_DeleteKey(pnKey, hash_val)
                               :  LK_UNUSABLE);
#endif
        LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst = _SubTable(hash_val);
#ifdef LKR_SUBTABLE
        LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);
#else
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_DeleteRecord(pvRecord, hash_val)
                               :  LK_UNUSABLE);
#endif
        LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
        DWORD     hash_val   = _CalcKeyHash(pnKey);
        SubTable* const pst  = _SubTable(hash_val);
#ifdef LKR_SUBTABLE
        LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
#else
        LK_RETCODE lkrc      = (pst != NULL
                                ?  pst->_FindKey(pnKey, hash_val, ppvRecord)
                                :  LK_UNUSABLE);
#endif
        LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
        return lkrc;
    }

    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
#ifdef LKR_SUBTABLE
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
        DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst  = _SubTable(hash_val);
#ifdef LKR_SUBTABLE
        LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
#else
        LK_RETCODE lkrc      = (pst != NULL
                                ?  pst->_FindRecord(pvRecord, hash_val)
                                :  LK_UNUSABLE);
#endif
        LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
        return lkrc;
    }

    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
    void           Clear();

    int            CheckTable() const;
    void           Print() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount();
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

public:
    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }
};



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------

#define LKRHASH_HACKY_CAST(T, pv)  ((T) (UINT_PTR) (pv))

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable,
           class _BaseIterator=_BaseHashTable::CIterator
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;
    typedef CTypedHashTable<_Derived, _Record, _Key,
                                 _BaseHashTable, _BaseIterator>
                            HashTable;
    typedef _BaseIterator   BaseIterator;

    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        _Key           key  = static_cast<_Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here, but the stupid
        // Win64 compiler thinks it knows better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        _Key key = LKRHASH_HACKY_CAST(_Key, pnKey);
        return _Derived::CalcKeyHash(key);
    }

    static bool
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        _Key key1 = LKRHASH_HACKY_CAST(_Key, pnKey1);
        _Key key2 = LKRHASH_HACKY_CAST(_Key, pnKey2);
        return _Derived::EqualKeys(key1, key2);
    }

    static void
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain length
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of hash table.
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS// #subordinate hash tables.
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls)
    {}

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    { return _BaseHashTable::DeleteKey(reinterpret_cast<const DWORD_PTR>(key));}

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change
    // TODO: Print?


    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }


    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

};



#ifdef __LKRHASH_NAMESPACE__
}
#endif // __LKRHASH_NAMESPACE__


#endif // __LKRHASH_H__


#ifdef SAMPLE_LKRHASH_TESTCLASS


//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKRHashTable
//--------------------------------------------------------------------

// some random class

class CTest
{
public:
    enum {BUFFSIZE=20};

    int   m_n;                  // This will also be a key
    char  m_sz[BUFFSIZE];       // This will be the primary key
    bool  m_fWhatever;
    mutable LONG  m_cRefs;      // Reference count for lifetime management.
                                // Must be mutable to use 'const CTest*' in
                                // hashtables

    CTest(int n, const char* psz, bool f)
        : m_n(n), m_fWhatever(f), m_cRefs(0)
    {
        strncpy(m_sz, psz, BUFFSIZE-1);
        m_sz[BUFFSIZE-1] = '\0';
    }

    ~CTest()
    {
        IRTLASSERT(m_cRefs == 0);
    }
};



// A typed hash table of CTests, keyed on the string field.  Case-insensitive.

class CStringTestHashTable
    : public CTypedHashTable<CStringTestHashTable, const CTest, const char*>
{
public:
    CStringTestHashTable()
        : CTypedHashTable<CStringTestHashTable, const CTest,
                          const char*>("string", LK_DFLT_MAXLOAD,
                                       LK_SMALL_TABLESIZE)
    {}

    static const char*
    ExtractKey(const CTest* pTest)
    {
        return pTest->m_sz;
    }

    static DWORD
    CalcKeyHash(const char* pszKey)
    {
        return HashStringNoCase(pszKey);
    }

    static bool
    EqualKeys(const char* pszKey1, const char* pszKey2)
    {
        return _stricmp(pszKey1, pszKey2) == 0;
    }

    static void
    AddRefRecord(const CTest* pTest, int nIncr)
    {
        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            //      if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);

        TRACE("AddRef(%p, %s) %d, cRefs == %d\n",
              pTest, pTest->m_sz, nIncr, pTest->m_cRefs);
    }
};


// Another typed hash table of CTests.  This one is keyed on the numeric field.

class CNumberTestHashTable
    : public CTypedHashTable<CNumberTestHashTable, const CTest, int>
{
public:
    CNumberTestHashTable()
        : CTypedHashTable<CNumberTestHashTable, const CTest, int>("number") {}
    static int   ExtractKey(const CTest* pTest)        {return pTest->m_n;}
    static DWORD CalcKeyHash(int nKey)                 {return Hash(nKey);}
    static bool  EqualKeys(int nKey1, int nKey2)       {return nKey1 == nKey2;}
    static void  AddRefRecord(const CTest* pTest, int nIncr) {/* do nothing*/}
};


// A class to exercise ApplyIf()

class CApplyIfTest
{
public:
    static LK_PREDICATE
    Predicate(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cPreds;
        TRACE("CApplyIfTest::Predicate(%p (%s, %d), %p)\n",
              pTest, pTest->m_sz, pTest->m_n, pThis);
        return (pTest->m_n % 10 == 7)  ?  LKP_PERFORM  :   LKP_NO_ACTION;
    }

    static LK_ACTION
    Action(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cActions;
        LK_ACTION lka = (pTest->m_n > 30)  ?  LKA_SUCCEEDED  :  LKA_FAILED;

        TRACE("CApplyIfTest::Action(%p (%s, %d), %p) %s\n",
              pTest, pTest->m_sz, pTest->m_n, pThis,
              lka == LKA_SUCCEEDED ? "succeeded" : "failed");

        if (lka == LKA_SUCCEEDED)
            ++pThis->m_cSuccesses;
        else if (lka == LKA_FAILED)
            ++pThis->m_cFailures;

        return lka;
    }

    int m_cPreds;
    int m_cActions;
    int m_cSuccesses;
    int m_cFailures;

    CApplyIfTest()
        : m_cPreds(0), m_cActions(0), m_cSuccesses(0), m_cFailures(0)
    {}
};


// The Predicate and Action functions can be static member functions,
// but don't have to be

LK_PREDICATE
DeleteIfGt10(
    const CTest* pTest,
    void* pvState)
{
    TRACE("DeleteIfGt10(%p, %s, %p) = %d\n",
          pTest, pTest->m_sz, pvState, pTest->m_n);
    return (pTest->m_n > 10)  ?  LKP_PERFORM  :   LKP_NO_ACTION;
}


#include <stdio.h>
#include <string.h>

void Test(
    bool fVerbose)
{
    // Some objects for the hash tables
    CTest tl(5,  "Larson",   true);
    CTest tk(17, "Krishnan", false);
    CTest tr(37, "Reilly",   true);

    // A string-keyed hash table
    CStringTestHashTable stht;

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr));

    TRACE("Check the overwrite feature of InsertRecord\n");
    IRTLVERIFY(LK_KEY_EXISTS == stht.InsertRecord(&tr, false));
    IRTLASSERT(tr.m_cRefs == 1);
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr, true));
    IRTLASSERT(tr.m_cRefs == 1);    // 1+1-1 == 1

    TRACE("Check that the keys are really present in the table and that "
          "the refcounting works\n");
    const CTest* pTest = NULL;
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tl.m_sz, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tl.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tk.m_sz, &pTest)  &&  pTest == &tk);
    IRTLASSERT(tk.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tr.m_sz, &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindRecord(&tr));
    IRTLASSERT(tr.m_cRefs == 2);    // FindRecord does not addref

    TRACE("Look for a key under an alternate spelling (case-insensitive)\n");
    IRTLVERIFY(LK_SUCCESS == stht.FindKey("rEiLlY", &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 3);

    TRACE("Release the references added by FindKey\n");
    stht.AddRefRecord(&tl, -1);
    tk.m_cRefs--;
    tr.m_cRefs = 1;

    TRACE("Now build the numeric hash table\n");
    CNumberTestHashTable ntht;

    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tr));

    TRACE("Test ApplyIf()\n");
    CApplyIfTest ait;

    IRTLVERIFY(1 == ntht.ApplyIf(ait.Predicate, ait.Action, &ait));
    IRTLASSERT(3 == ait.m_cPreds  &&  2 == ait.m_cActions
               &&  1 == ait.m_cSuccesses  &&  1 == ait.m_cFailures);

    TRACE("Test DeleteIf()\n");
    IRTLASSERT(3 == ntht.Size());
    ntht.DeleteIf(DeleteIfGt10, NULL);
    IRTLASSERT(1 == ntht.Size());

    TRACE("Check that the keys that were supposed to be deleted "
          "really are gone\n");
    IRTLASSERT(tl.m_n <= 10);
    IRTLVERIFY(LK_SUCCESS == ntht.FindKey(tl.m_n, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tk.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tk.m_n, &pTest)
               &&  pTest == NULL);
    IRTLASSERT(tr.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tr.m_n, &pTest)
               &&  pTest == NULL);

    IRTLVERIFY(LK_SUCCESS == ntht.DeleteRecord(&tl));
    IRTLASSERT(0 == ntht.Size());

    TRACE("Check Iterators\n");
    DWORD  cRec = 0;
    CStringTestHashTable::CIterator iter;
    LK_RETCODE lkrc = stht.InitializeIterator(&iter);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        CStringTestHashTable::Key     pszKey = iter.Key();
        CStringTestHashTable::Record* pRec   = iter.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = stht.IncrementIterator(&iter);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = stht.CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == stht.Size());

    TRACE("Check const iterators\n");
    const CStringTestHashTable& sthtConst = stht;
    CStringTestHashTable::CConstIterator iterConst;
    cRec = 0;

    lkrc = sthtConst.InitializeIterator(&iterConst);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        const CStringTestHashTable::Key     pszKey = iterConst.Key();
        const CStringTestHashTable::Record* pRec   = iterConst.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Const Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = sthtConst.IncrementIterator(&iterConst);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = sthtConst.CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == sthtConst.Size());

#if 1
    TRACE("Check Clear\n");
    stht.Clear();
    IRTLASSERT(0 == stht.Size());
#else
    TRACE("Check DeleteKey\n");
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tl.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tk.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tr.m_sz));
#endif

    TRACE("Test done\n");
    // ~CTest will check for m_cRefs==0
}

#endif // SAMPLE_LKRHASH_TESTCLASS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\makefile.inc ===
#
#   makefile0
#   Author: Murali R. Krishnan ( MuraliK)
#   Date:   2-Feb-1995
#
#   Describes the targets to be built first.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

#
#  The individual services build inetamsg.mc into their resources so nuke the
#  .rc and .bin file
#

$(O)\inetamsg.h: inetamsg.mc
    mc -v -h .\$(O) -r .\$(O) inetamsg.mc
    -del $(O)\inetamsg.rc $(O)\msg00001.bin

$(O)\iiscnfg.h $(O)\iiscnfgp.h: iiscnfg.x
    hsplit -e -o $(O)\iiscnfg.h $(O)\iiscnfgp.h iiscnfg.x

$(O)\iisfilt.h $(O)\iisfiltp.h: iisfilt.x
    hsplit -e -o $(O)\iisfilt.h $(O)\iisfiltp.h iisfilt.x

$(O)\iisext.h $(O)\iisextp.h: iisext.x
    hsplit -e -o $(O)\iisext.h $(O)\iisextp.h iisext.x
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\logconst.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       logconst.h

   Abstract:

        Contains the constant declarations for logging.

   Author:

        Unknown

--*/

#ifndef _LOGCONST_H_
#define _LOGCONST_H_

//
// Field masks for extended logging
//      Fields are logged in order of increasing mask value
//

#define EXTLOG_DATE                 MD_EXTLOG_DATE
#define EXTLOG_TIME                 MD_EXTLOG_TIME
#define EXTLOG_CLIENT_IP            MD_EXTLOG_CLIENT_IP
#define EXTLOG_USERNAME             MD_EXTLOG_USERNAME
#define EXTLOG_SITE_NAME            MD_EXTLOG_SITE_NAME
#define EXTLOG_COMPUTER_NAME        MD_EXTLOG_COMPUTER_NAME
#define EXTLOG_SERVER_IP            MD_EXTLOG_SERVER_IP
#define EXTLOG_METHOD               MD_EXTLOG_METHOD
#define EXTLOG_URI_STEM             MD_EXTLOG_URI_STEM
#define EXTLOG_URI_QUERY            MD_EXTLOG_URI_QUERY
#define EXTLOG_HTTP_STATUS          MD_EXTLOG_HTTP_STATUS
#define EXTLOG_WIN32_STATUS         MD_EXTLOG_WIN32_STATUS
#define EXTLOG_BYTES_SENT           MD_EXTLOG_BYTES_SENT
#define EXTLOG_BYTES_RECV           MD_EXTLOG_BYTES_RECV
#define EXTLOG_TIME_TAKEN           MD_EXTLOG_TIME_TAKEN
#define EXTLOG_SERVER_PORT          MD_EXTLOG_SERVER_PORT
#define EXTLOG_USER_AGENT           MD_EXTLOG_USER_AGENT
#define EXTLOG_COOKIE               MD_EXTLOG_COOKIE
#define EXTLOG_REFERER              MD_EXTLOG_REFERER
#define EXTLOG_PROTOCOL_VERSION     MD_EXTLOG_PROTOCOL_VERSION
#define EXTLOG_HOST                 MD_EXTLOG_HOST

#define DEFAULT_EXTLOG_FIELDS       (EXTLOG_CLIENT_IP | \
                                     EXTLOG_TIME      | \
                                     EXTLOG_METHOD    | \
                                     EXTLOG_URI_STEM  | \
                                     EXTLOG_HTTP_STATUS)

#define EXTLOG_VERSION              "1.0"

//
// names associated with fields
//

#define EXTLOG_CLIENT_IP_ID         "c-ip"
#define EXTLOG_SERVER_IP_ID         "s-ip"
#define EXTLOG_DATE_ID              "date"
#define EXTLOG_TIME_ID              "time"
#define EXTLOG_TIME_TAKEN_ID        "time-taken"
#define EXTLOG_METHOD_ID            "cs-method"
#define EXTLOG_URI_STEM_ID          "cs-uri-stem"
#define EXTLOG_URI_QUERY_ID         "cs-uri-query"
#define EXTLOG_HTTP_STATUS_ID       "sc-status"
#define EXTLOG_WIN32_STATUS_ID      "sc-win32-status"
#define EXTLOG_USERNAME_ID          "cs-username"
#define EXTLOG_COOKIE_ID            "cs(Cookie)"
#define EXTLOG_USER_AGENT_ID        "cs(User-Agent)"
#define EXTLOG_REFERER_ID           "cs(Referer)"
#define EXTLOG_COMPUTER_NAME_ID     "s-computername"
#define EXTLOG_SITE_NAME_ID         "s-sitename"
#define EXTLOG_BYTES_SENT_ID        "sc-bytes"
#define EXTLOG_BYTES_RECV_ID        "cs-bytes"
#define EXTLOG_SERVER_PORT_ID       "s-port"
#define EXTLOG_PROTOCOL_VERSION_ID  "cs-version"
#define EXTLOG_HOST_ID              "cs-host"

#endif // _LOGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\logtype.h ===
#ifndef _LOGTYPE_H_
#define _LOGTYPE_H_

/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name:

      logtype.hxx

   Abstract:

      This module provides definitions of the server side logging object

   Author:

       Terence Kwan    ( terryk )    18-June-1996

--*/

#include "logconst.h"

//
//  MISC defines
//

# define MAX_SERVER_NAME_LEN           ( MAX_COMPUTERNAME_LENGTH + 1)
# define MAX_NT_SERVICE_NAME_LEN       ( SNLEN + 1)
# define MAX_DATABASE_NAME_LEN         (MAX_PATH)
# define IISLOG_EVENTLOG_SOURCE        TEXT("IISLOG")

//
// Max field/record lengths
//

#define MAX_LOG_RECORD_FORMAT_LEN       (  120)
#define MIN_FILE_TRUNCATION_SIZE        ( 128*1024)
#define MAX_LOG_TARGET_FIELD_LEN        ( 4096)
#define MAX_LOG_PARAMETER_FIELD_LEN     ( 4096)
#define MAX_LOG_OPERATION_FIELD_LEN     ( 100)
#define MAX_LOG_USER_FIELD_LEN          ( 255)
#define MAX_LOG_RECORD_LEN              ( 10 * 1024)
#define NO_FILE_TRUNCATION              0xffffffff


/************************************************************
 *   Type Definitions
 ************************************************************/


//
//  The following handle ( INETLOG_HANDLE) is to be used as
//     handle for processing log information.
//

typedef VOID * INETLOG_HANDLE;

# define INVALID_INETLOG_HANDLE_VALUE          ( NULL)



/*++

  struct   INETLOG_INFORMATION

     This structure specifies the information required to write
      one log record.

--*/

typedef struct  _INETLOG_INFORMATION 
{

    LPSTR     pszClientHostName;
    LPSTR     pszClientUserName;
    LPSTR     pszServerAddress;     // input ip address for connection
    LPSTR     pszOperation;         //  eg: 'get'  in FTP
    LPSTR     pszTarget;            // target path/machine name
    LPSTR     pszParameters;        // string containing parameters.
    LPSTR     pszVersion;           // protocol version string.

    DWORD     cbClientHostName;
    DWORD     cbOperation;
    DWORD     cbTarget;

    DWORD     dwBytesSent;      // count of bytes sent
    DWORD     dwBytesRecvd;     // count of bytes recvd

    DWORD     msTimeForProcessing;  // time required for processing
    DWORD     dwWin32Status;        // Win32 error code. 0 for success
    DWORD     dwProtocolStatus;     // status: whatever service wants.
    DWORD     dwPort;

    DWORD     cbHTTPHeaderSize;
    LPSTR     pszHTTPHeader;        // Header Information

} INETLOG_INFORMATION, * PINETLOG_INFORMATION;



/*++

  struct  INETLOG_CONFIGURATION

    This structure contains the configuration information used for logging.

    The configuration includes:
      Format of Log record -- specifies the order in which the log record
         is written. ( serialization of INETLOG_INFORMATION).
      Type of Logging.  ( LOG_TYPE)
      Parameters depending upon type of logging.

      Type                      Parameters:
      InetNoLog                None
      InetLogToFile            Directory containing file; truncation size +
                                period ( daily, weekly, monthly).
      INET_LOG_TO_SQL          Sql Server Name, Sql Database Name,
                               Sql Table Name.
                             ( the table has to be already created).

      for SQL and logging to remote files eg: \\logserver\logshare\logdir
      we also need information about UserName and Passwd ( LSA_SECRET)
         for logging.  NYI.

     We do not support the remote directory in present version ( 2/2/95)

--*/
typedef struct _INETLOG_CONFIGURATIONA 
{

    DWORD          inetLogType;

    union 
    {

        struct 
        {

        //
        //  Used for InetLogToFile and InetLogToPeriodicFile
        //
            CHAR       rgchLogFileDirectory[ MAX_PATH];
            DWORD      cbSizeForTruncation;
            DWORD      ilPeriod;
            DWORD      cbBatchSize; // count of bytes to batch up per write.
            DWORD      ilFormat;
            DWORD      dwFieldMask;

        } logFile;

        struct 
        {

            //
            // Used for InetLogToSql
            //  ODBC bundles DatabaseName and ServerName and ServerType
            //   using a logical name called DataSource.
            //
            CHAR       rgchDataSource[ MAX_DATABASE_NAME_LEN];
            CHAR       rgchTableName[ MAX_TABLE_NAME_LEN];
            CHAR       rgchUserName[ MAX_USER_NAME_LEN];
            CHAR       rgchPassword[ MAX_PASSWORD_LEN];
        } logSql;

    } u;

    CHAR      rgchLogRecordFormat[ MAX_LOG_RECORD_FORMAT_LEN];

}  INETLOG_CONFIGURATIONA, * PINETLOG_CONFIGURATIONA;

/*--

This type declaration is duplicated here so that the Web Server can use this
in the LOGGING object.

--*/

#ifndef _ILOGOBJ_HXX_

typedef struct _CUSTOM_LOG_DATA
{
    LPCSTR  szPropertyPath;
    PVOID   pData;
    
} CUSTOM_LOG_DATA, *PCUSTOM_LOG_DATA;

#endif 

#endif  // _LOGTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\locks.h ===
/*++

   Copyright    (c)    1998-1999    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CRtlResource        NT's RTL_RESOURCE
//      CShareLock          Michael Parkes's CSharelock
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_RTLRESOURCE,
    LOCK_SHARELOCK,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CRtlResource;
class IRTL_DLLEXP CShareLock;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif


// Workarounds for certain useful interlocked operations are not
// available on Windows 95

#ifndef _M_IX86

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
    return InterlockedExchangeAdd(plAddr, lValue);
}

# define Lock_Yield()    ((void) 0)

#else // _M_IX86

#pragma warning(disable: 4035)

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
}

#pragma warning(default: 4035)

// Makes tight loops a little more cache friendly and reduces power consumption
# define Lock_Yield()    _asm { rep nop }

#endif // _M_IX86


//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    char     m_szName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_szName[0] = '\0';
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    char            m_szName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const char* Name() const        {return m_szName;}                      \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(pszName)         \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (pszName == NULL)                            \
        m_szName[0] = '\0';                         \
    else                                            \
        strncpy(m_szName, pszName, sizeof(m_szName))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = ::GetCurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef _DEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        InterlockedExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return (m_lTid != 0);
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CSmallSpinLock";}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        InterlockedExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD dwSpins)     {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CSpinLock";}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD dwSpins) {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CFakeLock";}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool TryWriteLock()
    {
#if _WIN32_WINNT >= 0x400
        // TODO: Use GetProcAddress at runtime
        return TryEnterCriticalSection(&m_cs) ? true : false;
#else
        return false;   // Not implemented in Windows 95
#endif
    }
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CCritSec";}
}; // CCritSec




//--------------------------------------------------------------------
// RTL_RESOURCE is a multi-reader, single-writer lock provided on NT, but
// not published as part of the Win32 API.  IIS exposes it in <tsres.hxx>.

#include <tsres.hxx>

class IRTL_DLLEXP CRtlResource :
    public CLockBase<LOCK_RTLRESOURCE, LOCK_MRSW,
                       LOCK_RECURSIVE /*??*/, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    RTL_RESOURCE    m_res;

    LOCK_INSTRUMENTATION_DECL();

public:
    CRtlResource()
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CRtlResource(const char*)
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CRtlResource()     { InetDeleteResource(&m_res); }

    void WriteLock()    { InetAcquireResourceExclusive(&m_res, TRUE); }
    void ReadLock()     { InetAcquireResourceShared(&m_res, TRUE); }
    bool TryWriteLock() {return !!InetAcquireResourceExclusive(&m_res, FALSE);}
    bool TryReadLock()  { return !!InetAcquireResourceShared(&m_res, FALSE); }
    void WriteUnlock()  { InetReleaseResource(&m_res); }
    void ReadUnlock()   { WriteUnlock(); }

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        InetConvertSharedToExclusive(&m_res);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        InetConvertExclusiveToShared(&m_res);
    }
    
    bool SetSpinCount(WORD wSpins)
    {CCritSec::SetSpinCount(&m_res.CriticalSection, wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CRtlResource";}
}; // CRtlResource




//--------------------------------------------------------------------
// CSharelock is a multi-reader, single-writer lock due to MParkes.

#include <sharelok.h>

class IRTL_DLLEXP CShareLock :
    public CLockBase<LOCK_SHARELOCK, LOCK_MRSW,
                       LOCK_RECURSIVE /* ?? */, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CSharelock      m_sl;

    LOCK_INSTRUMENTATION_DECL();

public:
    CShareLock()
        : m_sl()
    {
    }
#ifdef LOCK_INSTRUMENTATION
    CShareLock(const char*)
        : m_sl()
    {
    }
#endif // LOCK_INSTRUMENTATION

    void WriteLock()    { m_sl.ClaimExclusiveLock(INFINITE); }
    void ReadLock()     { m_sl.ClaimShareLock(INFINITE); }
    bool TryWriteLock() { return !!m_sl.ClaimExclusiveLock(0); }
    bool TryReadLock()  { return !!m_sl.ClaimShareLock(0); }
    void WriteUnlock()  { m_sl.ReleaseExclusiveLock(); }
    void ReadUnlock()   { m_sl.ReleaseShareLock(); }
    
    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return IsWriteUnlocked();}

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        m_sl.ChangeSharedLockToExclusiveLock(INFINITE);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        m_sl.ChangeExclusiveLockToSharedLock();
    }
    
    bool SetSpinCount(WORD wSpins)
    { m_sl.UpdateMaxSpins(wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CShareLock";}
};  // CShareLock



//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const char* pszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        InterlockedIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        InterlockedIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        InterlockedDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;    
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        InterlockedExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        InterlockedDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        InterlockedDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        InterlockedIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        InterlockedDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        InterlockedExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        InterlockedDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock";}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const char* pszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock2";}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = InterlockedExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        bool f = ((l & SL_WRITERS_MASK) == 0
                  &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!f  ||  m_lTid == 0);
        return f;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const char* pszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
        {
            InterlockedExchange(const_cast<LONG*>(&m_lTid), 0);
            for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
                 !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
                 l = m_lRW)
            {
                Lock_Yield();
            }
        }
        else
            InterlockedExchange(const_cast<LONG*>(&m_lTid), lNew);
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {
        return (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                && ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
                && ((m_lTid & SL_OWNER_MASK) > 0));
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            InterlockedExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        InterlockedExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock3";}
}; // CReaderWriterLock3


#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__

#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} IISMD5_CTX;

#define IISMD5_LEN 16

#define PROTO_LIST(list)    list


__declspec(dllexport)
void IISMD5Init PROTO_LIST ((IISMD5_CTX *));

__declspec(dllexport)
void IISMD5Update PROTO_LIST ((IISMD5_CTX *, unsigned char *, unsigned int));

__declspec(dllexport)
void IISMD5Final PROTO_LIST ((IISMD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mdcommsg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mddef.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Tue Jun 24 13:13:55 1997
 */
/* Compiler settings for .\mddef.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mddef_h__
#define __mddef_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "unknwn.h"
#include "mddefw.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Jun 24 13:13:55 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


/*++

Copyright (c) 1997 Microsoft Corporation

Module Name: mddef.h

    Definitions for Admin Objects and Metadata

--*/
#ifndef _MD_DEF_
#define _MD_DEF_


/*
    Events for ComMDEventNotify

        MD_EVENT_MID_RESTORE - Called when a restore is in progress. At this points
        all old handles have been invalidated, and new ones have not been opened.
        The metabase is locked when this is called. Do not call the metabase when
        processing this.
*/

enum MD_EVENTS
    {
        MD_EVENT_MID_RESTORE
    };

/*
    Change Object - The structure passed to ComMDSinkNotify.

        Path - The path of the MetaObject modified.

        ChangeType - The types of changes made, from the flags below.

        NumDataIDs - The number of data id's changed.

        DataIDs - An array of the data id's changed.
*/
#undef MD_CHANGE_OBJECT
#undef PMD_CHANGE_OBJECT

#ifdef UNICODE
#define MD_CHANGE_OBJECT     MD_CHANGE_OBJECT_W
#define PMD_CHANGE_OBJECT    PMD_CHANGE_OBJECT_W
#else  //UNICODE
#define MD_CHANGE_OBJECT     MD_CHANGE_OBJECT_A
#define PMD_CHANGE_OBJECT    PMD_CHANGE_OBJECT_A
#endif //UNICODE

typedef struct  _MD_CHANGE_OBJECT_A
    {
    /* [string] */ unsigned char __RPC_FAR *pszMDPath;
    DWORD dwMDChangeType;
    DWORD dwMDNumDataIDs;
    /* [size_is][unique] */ DWORD __RPC_FAR *pdwMDDataIDs;
    }   MD_CHANGE_OBJECT_A;

typedef struct _MD_CHANGE_OBJECT_A __RPC_FAR *PMD_CHANGE_OBJECT_A;

#endif


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:08 1997
 */
/* Compiler settings for mtx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtx_h__
#define __mtx_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IObjectContext_FWD_DEFINED__
#define __IObjectContext_FWD_DEFINED__
typedef interface IObjectContext IObjectContext;
#endif 	/* __IObjectContext_FWD_DEFINED__ */


#ifndef __IGetContextProperties_FWD_DEFINED__
#define __IGetContextProperties_FWD_DEFINED__
typedef interface IGetContextProperties IGetContextProperties;
#endif 	/* __IGetContextProperties_FWD_DEFINED__ */


#ifndef __IEnumNames_FWD_DEFINED__
#define __IEnumNames_FWD_DEFINED__
typedef interface IEnumNames IEnumNames;
#endif 	/* __IEnumNames_FWD_DEFINED__ */


#ifndef __ISecurityProperty_FWD_DEFINED__
#define __ISecurityProperty_FWD_DEFINED__
typedef interface ISecurityProperty ISecurityProperty;
#endif 	/* __ISecurityProperty_FWD_DEFINED__ */


#ifndef __IObjectControl_FWD_DEFINED__
#define __IObjectControl_FWD_DEFINED__
typedef interface IObjectControl IObjectControl;
#endif 	/* __IObjectControl_FWD_DEFINED__ */


#ifndef __IObjectContextActivity_FWD_DEFINED__
#define __IObjectContextActivity_FWD_DEFINED__
typedef interface IObjectContextActivity IObjectContextActivity;
#endif 	/* __IObjectContextActivity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0000
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtx.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server 2.0											
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef _MTX_NOFORCE_LIBS
#pragma comment(lib, "mtx.lib")
#endif
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

extern RPC_IF_HANDLE __MIDL_itf_mtx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0000_v0_0_s_ifspec;

#ifndef __IObjectContext_INTERFACE_DEFINED__
#define __IObjectContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContext
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372ae0-cae7-11cf-be81-00aa00a2fa25")
    IObjectContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableCommit( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsInTransaction( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsSecurityEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCallerInRole( 
            /* [in] */ BSTR __MIDL_0000,
            /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComplete )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAbort )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsInTransaction )( 
            IObjectContext __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsSecurityEnabled )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsCallerInRole )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ BSTR __MIDL_0000,
            /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001);
        
        END_INTERFACE
    } IObjectContextVtbl;

    interface IObjectContext
    {
        CONST_VTBL struct IObjectContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContext_CreateInstance(This,rclsid,riid,ppv)	\
    (This)->lpVtbl -> CreateInstance(This,rclsid,riid,ppv)

#define IObjectContext_SetComplete(This)	\
    (This)->lpVtbl -> SetComplete(This)

#define IObjectContext_SetAbort(This)	\
    (This)->lpVtbl -> SetAbort(This)

#define IObjectContext_EnableCommit(This)	\
    (This)->lpVtbl -> EnableCommit(This)

#define IObjectContext_DisableCommit(This)	\
    (This)->lpVtbl -> DisableCommit(This)

#define IObjectContext_IsInTransaction(This)	\
    (This)->lpVtbl -> IsInTransaction(This)

#define IObjectContext_IsSecurityEnabled(This)	\
    (This)->lpVtbl -> IsSecurityEnabled(This)

#define IObjectContext_IsCallerInRole(This,__MIDL_0000,__MIDL_0001)	\
    (This)->lpVtbl -> IsCallerInRole(This,__MIDL_0000,__MIDL_0001)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContext_CreateInstance_Proxy( 
    IObjectContext __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFIID riid,
    /* [retval][iid_is][out] */ LPVOID __RPC_FAR *ppv);


void __RPC_STUB IObjectContext_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetComplete_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetAbort_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_EnableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_EnableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_DisableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_DisableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectContext_IsInTransaction_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_IsInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectContext_IsSecurityEnabled_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_IsSecurityEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_IsCallerInRole_Proxy( 
    IObjectContext __RPC_FAR * This,
    /* [in] */ BSTR __MIDL_0000,
    /* [retval][out] */ BOOL __RPC_FAR *__MIDL_0001);


void __RPC_STUB IObjectContext_IsCallerInRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContext_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0006
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_mtx_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0006_v0_0_s_ifspec;

#ifndef __IGetContextProperties_INTERFACE_DEFINED__
#define __IGetContextProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGetContextProperties
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IGetContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af4-cae7-11cf-be81-00aa00a2fa25")
    IGetContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetContextProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetContextProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetContextProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IGetContextProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IGetContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNames )( 
            IGetContextProperties __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IGetContextPropertiesVtbl;

    interface IGetContextProperties
    {
        CONST_VTBL struct IGetContextPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetContextProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetContextProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetContextProperties_Count(This,plCount)	\
    (This)->lpVtbl -> Count(This,plCount)

#define IGetContextProperties_GetProperty(This,name,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,name,pProperty)

#define IGetContextProperties_EnumNames(This,ppenum)	\
    (This)->lpVtbl -> EnumNames(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetContextProperties_Count_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IGetContextProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetContextProperties_GetProperty_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pProperty);


void __RPC_STUB IGetContextProperties_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGetContextProperties_EnumNames_Proxy( 
    IGetContextProperties __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IGetContextProperties_EnumNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetContextProperties_INTERFACE_DEFINED__ */


#ifndef __IEnumNames_INTERFACE_DEFINED__
#define __IEnumNames_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumNames
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IEnumNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af2-cae7-11cf-be81-00aa00a2fa25")
    IEnumNames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR __RPC_FAR *rgname,
            /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNames __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNames __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR __RPC_FAR *rgname,
            /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNames __RPC_FAR * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNames __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNames __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumNamesVtbl;

    interface IEnumNames
    {
        CONST_VTBL struct IEnumNamesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNames_Next(This,celt,rgname,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgname,pceltFetched)

#define IEnumNames_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNames_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNames_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNames_Next_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [in] */ unsigned long celt,
    /* [size_is][out] */ BSTR __RPC_FAR *rgname,
    /* [retval][out] */ unsigned long __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumNames_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Skip_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumNames_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Reset_Proxy( 
    IEnumNames __RPC_FAR * This);


void __RPC_STUB IEnumNames_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNames_Clone_Proxy( 
    IEnumNames __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumNames_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNames_INTERFACE_DEFINED__ */


#ifndef __ISecurityProperty_INTERFACE_DEFINED__
#define __ISecurityProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISecurityProperty
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_ISecurityProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372aea-cae7-11cf-be81-00aa00a2fa25")
    ISecurityProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDirectCreatorSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCreatorSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectCallerSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCallerSID( 
            PSID __RPC_FAR *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSID( 
            PSID pSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISecurityProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISecurityProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISecurityProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectCreatorSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalCreatorSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectCallerSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalCallerSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID __RPC_FAR *pSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSID )( 
            ISecurityProperty __RPC_FAR * This,
            PSID pSID);
        
        END_INTERFACE
    } ISecurityPropertyVtbl;

    interface ISecurityProperty
    {
        CONST_VTBL struct ISecurityPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISecurityProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISecurityProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISecurityProperty_GetDirectCreatorSID(This,pSID)	\
    (This)->lpVtbl -> GetDirectCreatorSID(This,pSID)

#define ISecurityProperty_GetOriginalCreatorSID(This,pSID)	\
    (This)->lpVtbl -> GetOriginalCreatorSID(This,pSID)

#define ISecurityProperty_GetDirectCallerSID(This,pSID)	\
    (This)->lpVtbl -> GetDirectCallerSID(This,pSID)

#define ISecurityProperty_GetOriginalCallerSID(This,pSID)	\
    (This)->lpVtbl -> GetOriginalCallerSID(This,pSID)

#define ISecurityProperty_ReleaseSID(This,pSID)	\
    (This)->lpVtbl -> ReleaseSID(This,pSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISecurityProperty_GetDirectCreatorSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetDirectCreatorSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetOriginalCreatorSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetOriginalCreatorSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetDirectCallerSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetDirectCallerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_GetOriginalCallerSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID __RPC_FAR *pSID);


void __RPC_STUB ISecurityProperty_GetOriginalCallerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISecurityProperty_ReleaseSID_Proxy( 
    ISecurityProperty __RPC_FAR * This,
    PSID pSID);


void __RPC_STUB ISecurityProperty_ReleaseSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISecurityProperty_INTERFACE_DEFINED__ */


#ifndef __IObjectControl_INTERFACE_DEFINED__
#define __IObjectControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectControl
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372aec-cae7-11cf-be81-00aa00a2fa25")
    IObjectControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual void STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE CanBePooled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IObjectControl __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IObjectControl __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *CanBePooled )( 
            IObjectControl __RPC_FAR * This);
        
        END_INTERFACE
    } IObjectControlVtbl;

    interface IObjectControl
    {
        CONST_VTBL struct IObjectControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectControl_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IObjectControl_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IObjectControl_CanBePooled(This)	\
    (This)->lpVtbl -> CanBePooled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectControl_Activate_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IObjectControl_Deactivate_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectControl_CanBePooled_Proxy( 
    IObjectControl __RPC_FAR * This);


void __RPC_STUB IObjectControl_CanBePooled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectControl_INTERFACE_DEFINED__ */


#ifndef __IObjectContextActivity_INTERFACE_DEFINED__
#define __IObjectContextActivity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContextActivity
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectContextActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372afc-cae7-11cf-be81-00aa00a2fa25")
    IObjectContextActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivityId( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContextActivity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContextActivity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContextActivity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActivityId )( 
            IObjectContextActivity __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        END_INTERFACE
    } IObjectContextActivityVtbl;

    interface IObjectContextActivity
    {
        CONST_VTBL struct IObjectContextActivityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContextActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContextActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContextActivity_GetActivityId(This,pGUID)	\
    (This)->lpVtbl -> GetActivityId(This,pGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContextActivity_GetActivityId_Proxy( 
    IObjectContextActivity __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IObjectContextActivity_GetActivityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContextActivity_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtx_0100
 * at Thu Sep 11 16:03:08 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


extern HRESULT __cdecl GetObjectContext (IObjectContext** ppInstanceContext);
extern void* __cdecl SafeRef(REFIID rid, IUnknown* pUnk);


extern RPC_IF_HANDLE __MIDL_itf_mtx_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtx_0100_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtxadmii.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:04 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\opt_time.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    opt_time.h

Abstract:

    This file enables time-based (speed) optimizations. This pragma is
    placed in a separate file to make it easier to tune later.

    opt_rest.h is the complement to this file.

Author:

    Keith Moore (keithmo)       23-Jul-1997

Revision History:

--*/

#pragma optimize( "t", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtxrepli.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:05 1997
 */
/* Compiler settings for mtxrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMTSReplicateCatalog = {0x8C836AF8,0xFFAC,0x11D0,{0x8E,0xD4,0x00,0xC0,0x4F,0xC2,0xC1,0x7B}};


const IID LIBID_MTSReplLib = {0x8C836AE9,0xFFAC,0x11D0,{0x8E,0xD4,0x00,0xC0,0x4F,0xC2,0xC1,0x7B}};


const CLSID CLSID_ReplicateCatalog = {0x8C836AF9,0xFFAC,0x11D0,{0x8E,0xD4,0x00,0xC0,0x4F,0xC2,0xC1,0x7B}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtxadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:04 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxadmin_h__
#define __mtxadmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __ICatalogObject_FWD_DEFINED__
#define __ICatalogObject_FWD_DEFINED__
typedef interface ICatalogObject ICatalogObject;
#endif 	/* __ICatalogObject_FWD_DEFINED__ */


#ifndef __ICatalogCollection_FWD_DEFINED__
#define __ICatalogCollection_FWD_DEFINED__
typedef interface ICatalogCollection ICatalogCollection;
#endif 	/* __ICatalogCollection_FWD_DEFINED__ */


#ifndef __IComponentUtil_FWD_DEFINED__
#define __IComponentUtil_FWD_DEFINED__
typedef interface IComponentUtil IComponentUtil;
#endif 	/* __IComponentUtil_FWD_DEFINED__ */


#ifndef __IPackageUtil_FWD_DEFINED__
#define __IPackageUtil_FWD_DEFINED__
typedef interface IPackageUtil IPackageUtil;
#endif 	/* __IPackageUtil_FWD_DEFINED__ */


#ifndef __IRemoteComponentUtil_FWD_DEFINED__
#define __IRemoteComponentUtil_FWD_DEFINED__
typedef interface IRemoteComponentUtil IRemoteComponentUtil;
#endif 	/* __IRemoteComponentUtil_FWD_DEFINED__ */


#ifndef __IRoleAssociationUtil_FWD_DEFINED__
#define __IRoleAssociationUtil_FWD_DEFINED__
typedef interface IRoleAssociationUtil IRoleAssociationUtil;
#endif 	/* __IRoleAssociationUtil_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __CatalogObject_FWD_DEFINED__
#define __CatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogObject CatalogObject;
#else
typedef struct CatalogObject CatalogObject;
#endif /* __cplusplus */

#endif 	/* __CatalogObject_FWD_DEFINED__ */


#ifndef __CatalogCollection_FWD_DEFINED__
#define __CatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogCollection CatalogCollection;
#else
typedef struct CatalogCollection CatalogCollection;
#endif /* __cplusplus */

#endif 	/* __CatalogCollection_FWD_DEFINED__ */


#ifndef __ComponentUtil_FWD_DEFINED__
#define __ComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentUtil ComponentUtil;
#else
typedef struct ComponentUtil ComponentUtil;
#endif /* __cplusplus */

#endif 	/* __ComponentUtil_FWD_DEFINED__ */


#ifndef __PackageUtil_FWD_DEFINED__
#define __PackageUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class PackageUtil PackageUtil;
#else
typedef struct PackageUtil PackageUtil;
#endif /* __cplusplus */

#endif 	/* __PackageUtil_FWD_DEFINED__ */


#ifndef __RemoteComponentUtil_FWD_DEFINED__
#define __RemoteComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteComponentUtil RemoteComponentUtil;
#else
typedef struct RemoteComponentUtil RemoteComponentUtil;
#endif /* __cplusplus */

#endif 	/* __RemoteComponentUtil_FWD_DEFINED__ */


#ifndef __RoleAssociationUtil_FWD_DEFINED__
#define __RoleAssociationUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RoleAssociationUtil RoleAssociationUtil;
#else
typedef struct RoleAssociationUtil RoleAssociationUtil;
#endif /* __cplusplus */

#endif 	/* __RoleAssociationUtil_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxadmin_0000
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxadmin.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server SDK												
// Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_s_ifspec;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalog
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22870-8a19-11d0-81b6-00a0c9231c29")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MajorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection)

#define ICatalog_Connect(This,bstrConnectString,ppCatalogCollection)	\
    (This)->lpVtbl -> Connect(This,bstrConnectString,ppCatalogCollection)

#define ICatalog_get_MajorVersion(This,retval)	\
    (This)->lpVtbl -> get_MajorVersion(This,retval)

#define ICatalog_get_MinorVersion(This,retval)	\
    (This)->lpVtbl -> get_MinorVersion(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_GetCollection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_Connect_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConnectString,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MajorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogObject
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyReadOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Valid )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyWriteOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogObject_get_Value(This,bstrPropName,retval)	\
    (This)->lpVtbl -> get_Value(This,bstrPropName,retval)

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    (This)->lpVtbl -> put_Value(This,bstrPropName,val)

#define ICatalogObject_get_Key(This,retval)	\
    (This)->lpVtbl -> get_Key(This,retval)

#define ICatalogObject_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,retval)

#define ICatalogObject_get_Valid(This,retval)	\
    (This)->lpVtbl -> get_Valid(This,retval)

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICatalogObject_put_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [in] */ VARIANT val);


void __RPC_STUB ICatalogObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Key_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Name_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyReadOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Valid_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Valid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyWriteOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyWriteOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogCollection
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Populate )( 
            ICatalogCollection __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RemoveEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUtilInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMajorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMinorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByKey )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByQuery )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant)

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject)

#define ICatalogCollection_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define ICatalogCollection_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    (This)->lpVtbl -> Add(This,ppCatalogObject)

#define ICatalogCollection_Populate(This)	\
    (This)->lpVtbl -> Populate(This)

#define ICatalogCollection_SaveChanges(This,retval)	\
    (This)->lpVtbl -> SaveChanges(This,retval)

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)

#define ICatalogCollection_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogCollection_get_AddEnabled(This,retval)	\
    (This)->lpVtbl -> get_AddEnabled(This,retval)

#define ICatalogCollection_get_RemoveEnabled(This,retval)	\
    (This)->lpVtbl -> get_RemoveEnabled(This,retval)

#define ICatalogCollection_GetUtilInterface(This,ppUtil)	\
    (This)->lpVtbl -> GetUtilInterface(This,ppUtil)

#define ICatalogCollection_get_DataStoreMajorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMajorVersion(This,retval)

#define ICatalogCollection_get_DataStoreMinorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMinorVersion(This,retval)

#define ICatalogCollection_PopulateByKey(This,aKeys)	\
    (This)->lpVtbl -> PopulateByKey(This,aKeys)

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get__NewEnum_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);


void __RPC_STUB ICatalogCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Item_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Count_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Remove_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex);


void __RPC_STUB ICatalogCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Add_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Populate_Proxy( 
    ICatalogCollection __RPC_FAR * This);


void __RPC_STUB ICatalogCollection_Populate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_SaveChanges_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetCollection_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [in] */ VARIANT varObjectKey,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalogCollection_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Name_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_AddEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_AddEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_RemoveEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_RemoveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetUtilInterface_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);


void __RPC_STUB ICatalogCollection_GetUtilInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMajorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMinorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByKey_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * aKeys);


void __RPC_STUB ICatalogCollection_PopulateByKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByQuery_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrQueryString,
    /* [in] */ long lQueryType);


void __RPC_STUB ICatalogCollection_PopulateByQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPackageUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRoleAssociationUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSAdmin
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0003
    {	mtsErrObjectErrors	= 0x80110401,
	mtsErrObjectInvalid	= 0x80110402,
	mtsErrKeyMissing	= 0x80110403,
	mtsErrAlreadyInstalled	= 0x80110404,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= 0x80110407,
	mtsErrPDFReadFail	= 0x80110408,
	mtsErrPDFVersion	= 0x80110409,
	mtsErrCoReqCompInstalled	= 0x80110410,
	mtsErrBadPath	= 0x8011040a,
	mtsErrPackageExists	= 0x8011040b,
	mtsErrRoleExists	= 0x8011040c,
	mtsErrCantCopyFile	= 0x8011040d,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= 0x8011040f,
	mtsErrInvalidUserids	= 0x80110410,
	mtsErrNoRegistryCLSID	= 0x80110411,
	mtsErrBadRegistryProgID	= 0x80110412,
	mtsErrAuthenticationLevel	= 0x80110413,
	mtsErrUserPasswdNotValid	= 0x80110414,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= 0x80110418,
	mtsErrRemoteInterface	= 0x80110419,
	mtsErrDllRegisterServer	= 0x8011041a,
	mtsErrNoServerShare	= 0x8011041b,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= 0x8011041d,
	mtsErrBadRegistryLibID	= 0x8011041e,
	mtsErrPackDirNotFound	= 0x8011041f,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= 0x80110423,
	mtsErrCompFileDoesNotExist	= 0x80110424,
	mtsErrCompFileLoadDLLFail	= 0x80110425,
	mtsErrCompFileGetClassObj	= 0x80110426,
	mtsErrCompFileClassNotAvail	= 0x80110427,
	mtsErrCompFileBadTLB	= 0x80110428,
	mtsErrCompFileNotInstallable	= 0x80110429,
	mtsErrNotChangeable	= 0x8011042a,
	mtsErrNotDeletable	= 0x8011042b,
	mtsErrSession	= 0x8011042c,
	mtsErrCompFileNoRegistrar	= 0x80110434
    }	MTSAdminErrorCodes;

#define E_MTS_OBJECTERRORS			 	mtsErrObjectErrors				
#define E_MTS_OBJECTINVALID				mtsErrObjectInvalid				
#define E_MTS_KEYMISSING				mtsErrKeyMissing				
#define E_MTS_ALREADYINSTALLED			mtsErrAlreadyInstalled			
#define E_MTS_DOWNLOADFAILED			mtsErrDownloadFailed			
#define E_MTS_PDFWRITEFAIL				mtsErrPDFWriteFail				
#define E_MTS_PDFREADFAIL				mtsErrPDFReadFail				
#define E_MTS_PDFVERSION				mtsErrPDFVersion				
#define E_MTS_COREQCOMPINSTALLED		mtsErrCoReqCompInstalled		
#define E_MTS_BADPATH					mtsErrBadPath					
#define E_MTS_PACKAGEEXISTS				mtsErrPackageExists				
#define E_MTS_ROLEEXISTS				mtsErrRoleExists				
#define E_MTS_CANTCOPYFILE				mtsErrCantCopyFile				
#define E_MTS_NOTYPELIB					mtsErrNoTypeLib					
#define E_MTS_NOUSER					mtsErrNoUser					
#define E_MTS_INVALIDUSERIDS			mtsErrInvalidUserids			
#define E_MTS_NOREGISTRYCLSID			mtsErrNoRegistryCLSID			
#define E_MTS_BADREGISTRYPROGID			mtsErrBadRegistryProgID			
#define E_MTS_AUTHENTICATIONLEVEL		mtsErrAuthenticationLevel		
#define E_MTS_USERPASSWDNOTVALID		mtsErrUserPasswdNotValid		
#define E_MTS_NOREGISTRYREAD			mtsErrNoRegistryRead			
#define E_MTS_NOREGISTRYWRITE			mtsErrNoRegistryWrite			
#define E_MTS_NOREGISTRYREPAIR			mtsErrNoRegistryRepair			
#define E_MTS_CLSIDORIIDMISMATCH		mtsErrCLSIDOrIIDMismatch		
#define E_MTS_REMOTEINTERFACE			mtsErrRemoteInterface			
#define E_MTS_DLLREGISTERSERVER			mtsErrDllRegisterServer			
#define E_MTS_NOSERVERSHARE				mtsErrNoServerShare				
#define E_MTS_NOACCESSTOUNC				mtsErrNoAccessToUNC				
#define E_MTS_DLLLOADFAILED				mtsErrDllLoadFailed				
#define E_MTS_BADREGISTRYLIBID			mtsErrBadRegistryLibID			
#define E_MTS_PACKDIRNOTFOUND			mtsErrPackDirNotFound			
#define E_MTS_TREATAS					mtsErrTreatAs					
#define E_MTS_BADFORWARD				mtsErrBadForward				
#define E_MTS_BADIID					mtsErrBadIID					
#define E_MTS_REGISTRARFAILED			mtsErrRegistrarFailed			
#define E_MTS_COMPFILE_DOESNOTEXIST		mtsErrCompFileDoesNotExist		
#define E_MTS_COMPFILE_LOADDLLFAIL		mtsErrCompFileLoadDLLFail		
#define E_MTS_COMPFILE_GETCLASSOBJ		mtsErrCompFileGetClassObj		
#define E_MTS_COMPFILE_CLASSNOTAVAIL	mtsErrCompFileClassNotAvail		
#define E_MTS_COMPFILE_BADTLB			mtsErrCompFileBadTLB			
#define E_MTS_COMPFILE_NOTINSTALLABLE	mtsErrCompFileNotInstallable	
#define E_MTS_NOTCHANGEABLE				mtsErrNotChangeable				
#define E_MTS_NOTDELETEABLE				mtsErrNotDeleteable				
#define E_MTS_SESSION					mtsErrSession					
#define E_MTS_COMPFILE_NOREGISTRAR		mtsErrCompFileNoRegistrar		

EXTERN_C const IID LIBID_MTSAdmin;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Catalog;

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogObject;

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogCollection;

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ComponentUtil;

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PackageUtil;

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RemoteComponentUtil;

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RoleAssociationUtil;

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\opt_rest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    opt_rest.h

Abstract:

    This file restores default optimizations. This pragma is placed in a
    separate file to make it easier to tune later.

    The other opt_*.h files complement this file.

Author:

    Keith Moore (keithmo)       23-Jul-1997

Revision History:

--*/

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtxrepl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:05 1997
 */
/* Compiler settings for mtxrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxrepl_h__
#define __mtxrepl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMTSReplicateCatalog_FWD_DEFINED__
#define __IMTSReplicateCatalog_FWD_DEFINED__
typedef interface IMTSReplicateCatalog IMTSReplicateCatalog;
#endif 	/* __IMTSReplicateCatalog_FWD_DEFINED__ */


#ifndef __ReplicateCatalog_FWD_DEFINED__
#define __ReplicateCatalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class ReplicateCatalog ReplicateCatalog;
#else
typedef struct ReplicateCatalog ReplicateCatalog;
#endif /* __cplusplus */

#endif 	/* __ReplicateCatalog_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMTSReplicateCatalog_INTERFACE_DEFINED__
#define __IMTSReplicateCatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSReplicateCatalog
 * at Thu Sep 11 16:03:05 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMTSReplicateCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8C836AF8-FFAC-11D0-8ED4-00C04FC2C17B")
    IMTSReplicateCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MTSComputerToComputer( 
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IISComputerToComputer( 
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSReplicateCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSReplicateCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSReplicateCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MTSComputerToComputer )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IISComputerToComputer )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc);
        
        END_INTERFACE
    } IMTSReplicateCatalogVtbl;

    interface IMTSReplicateCatalog
    {
        CONST_VTBL struct IMTSReplicateCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSReplicateCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSReplicateCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSReplicateCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSReplicateCatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMTSReplicateCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMTSReplicateCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMTSReplicateCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMTSReplicateCatalog_MTSComputerToComputer(This,bstrServerDest,bstrServerSrc)	\
    (This)->lpVtbl -> MTSComputerToComputer(This,bstrServerDest,bstrServerSrc)

#define IMTSReplicateCatalog_IISComputerToComputer(This,bstrServerDest,bstrServerSrc)	\
    (This)->lpVtbl -> IISComputerToComputer(This,bstrServerDest,bstrServerSrc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMTSReplicateCatalog_MTSComputerToComputer_Proxy( 
    IMTSReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrServerDest,
    /* [in] */ BSTR bstrServerSrc);


void __RPC_STUB IMTSReplicateCatalog_MTSComputerToComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMTSReplicateCatalog_IISComputerToComputer_Proxy( 
    IMTSReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrServerDest,
    /* [in] */ BSTR bstrServerSrc);


void __RPC_STUB IMTSReplicateCatalog_IISComputerToComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSReplicateCatalog_INTERFACE_DEFINED__ */



#ifndef __MTSReplLib_LIBRARY_DEFINED__
#define __MTSReplLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSReplLib
 * at Thu Sep 11 16:03:05 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MTSReplLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReplicateCatalog;

class DECLSPEC_UUID("8C836AF9-FFAC-11D0-8ED4-00C04FC2C17B")
ReplicateCatalog;
#endif
#endif /* __MTSReplLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\mtxpriv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:09 1997
 */
/* Compiler settings for mtxpriv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxpriv_h__
#define __mtxpriv_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IContextProperties_FWD_DEFINED__
#define __IContextProperties_FWD_DEFINED__
typedef interface IContextProperties IContextProperties;
#endif 	/* __IContextProperties_FWD_DEFINED__ */


#ifndef __IMTSCall_FWD_DEFINED__
#define __IMTSCall_FWD_DEFINED__
typedef interface IMTSCall IMTSCall;
#endif 	/* __IMTSCall_FWD_DEFINED__ */


#ifndef __IMTSActivity_FWD_DEFINED__
#define __IMTSActivity_FWD_DEFINED__
typedef interface IMTSActivity IMTSActivity;
#endif 	/* __IMTSActivity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mtx.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0000
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------
// mtxpriv.h  -- Microsoft Transaction Server Undisclosed APIs
//
// This file provides the prototypes for those APIs and COM interfaces
// used by Microsoft Transaction Server applications which have NOT been
// disclosed or documented.
//
// Microsoft Transaction Server 2.0
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------
#include <mtx.h>

#define CONTEXT_E_EXCEPTION				0x8004E010
#define CONTEXT_E_QUEUEFULL				0x8004E011


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_s_ifspec;

#ifndef __IContextProperties_INTERFACE_DEFINED__
#define __IContextProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextProperties
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af1-cae7-11cf-be81-00aa00a2fa25")
    IContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNames )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        END_INTERFACE
    } IContextPropertiesVtbl;

    interface IContextProperties
    {
        CONST_VTBL struct IContextPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextProperties_Count(This,plCount)	\
    (This)->lpVtbl -> Count(This,plCount)

#define IContextProperties_GetProperty(This,name,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,name,pProperty)

#define IContextProperties_EnumNames(This,ppenum)	\
    (This)->lpVtbl -> EnumNames(This,ppenum)

#define IContextProperties_SetProperty(This,name,property)	\
    (This)->lpVtbl -> SetProperty(This,name,property)

#define IContextProperties_RemoveProperty(This,name)	\
    (This)->lpVtbl -> RemoveProperty(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextProperties_Count_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IContextProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_GetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pProperty);


void __RPC_STUB IContextProperties_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_EnumNames_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IContextProperties_EnumNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_SetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT property);


void __RPC_STUB IContextProperties_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_RemoveProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IContextProperties_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextProperties_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0104
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#ifdef __cplusplus
extern "C"
#endif __cplusplus
EXTERN_C HRESULT __stdcall MTSCreateActivity ( REFIID riid, void** ppobj );
EXTERN_C HRESULT __stdcall CreateActivityInMTA ( REFIID riid, void** ppobj );


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_s_ifspec;

#ifndef __IMTSCall_INTERFACE_DEFINED__
#define __IMTSCall_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSCall
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AEF-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCall )( 
            IMTSCall __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSCallVtbl;

    interface IMTSCall
    {
        CONST_VTBL struct IMTSCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSCall_Re