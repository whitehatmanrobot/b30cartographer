Input;         // pszInData parameter passed to ExtEscape

} ESCAPEDATA, *PESCAPEDATA;

//
// Check if a document event requires a device context
//

#define DocEventRequiresDC(iEsc) \
        ((iEsc) >= DOCUMENTEVENT_RESETDCPRE && (iEsc) <= DOCUMENTEVENT_LAST)

static DWORD LaunchFaxWizard(PDOCEVENTUSERMEM    pDocEventUserMem);


static void
ComposeRecipientJobParam(
                LPTSTR lpParamBuf,
                LPDWORD lpdwParamSize,
                const COVERPAGEFIELDS *   pCPFields
                );

static void
ComposeSenderJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    const COVERPAGEFIELDS *    pCPFields
    );

static BOOL
ComposeFaxJobParameter(
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR  *           lppParamBuf
    );

static void
CloseMappingHandles(
    PDOCEVENTUSERMEM pDocEventUserMem
    );


PDOCEVENTUSERMEM
GetPDEVUserMem(
    HDC     hdc
    )

/*++

Routine Description:

    Retrieve a pointer to the user mode memory structure associated with a PDEV

Arguments:

    hdc - Specifies the printer device context

Return Value:

    Pointer to user mode memory structure, NULL if there is an error

--*/

{
    PDOCEVENTUSERMEM pDocEventUserMem;

    //
    // Get a pointer to the user mode memory structure associated
    // with the specified device context
    //

    EnterDrvSem();

    pDocEventUserMem = gDocEventUserMemList;

    while (pDocEventUserMem && hdc != pDocEventUserMem->hdc)
        pDocEventUserMem = pDocEventUserMem->pNext;

    LeaveDrvSem();

    //
    // Make sure the user memory structure is valid
    //
    if (pDocEventUserMem) 
    {
        if (! ValidPDEVUserMem(pDocEventUserMem)) 
        {
            Error(("Corrupted user mode memory structure\n"));
            pDocEventUserMem = NULL;
        }
    } 
    else
    {
        Error(("DC has no associated user mode memory structure\n"));
    }
    return pDocEventUserMem;
}


static LRESULT
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    )
{
    if (lpPersonalProfileInfo) 
    {
        MemFree(lpPersonalProfileInfo->lptstrName);
        MemFree(lpPersonalProfileInfo->lptstrFaxNumber);
        MemFree(lpPersonalProfileInfo->lptstrCompany);
        MemFree(lpPersonalProfileInfo->lptstrStreetAddress);
        MemFree(lpPersonalProfileInfo->lptstrCity);
        MemFree(lpPersonalProfileInfo->lptstrState);
        MemFree(lpPersonalProfileInfo->lptstrZip);
        MemFree(lpPersonalProfileInfo->lptstrCountry);
        MemFree(lpPersonalProfileInfo->lptstrTitle);
        MemFree(lpPersonalProfileInfo->lptstrDepartment);
        MemFree(lpPersonalProfileInfo->lptstrOfficeLocation);
        MemFree(lpPersonalProfileInfo->lptstrHomePhone);
        MemFree(lpPersonalProfileInfo->lptstrOfficePhone);
        MemFree(lpPersonalProfileInfo->lptstrEmail);
        MemFree(lpPersonalProfileInfo->lptstrBillingCode);
        MemFree(lpPersonalProfileInfo->lptstrTSID);
    }
    return ERROR_SUCCESS;
}
static LRESULT
FreeRecipientInfo(DWORD * pdwNumberOfRecipients,  PFAX_PERSONAL_PROFILE lpRecipientsInfo)
{
    LRESULT lResult;
    DWORD i;

    Assert(pdwNumberOfRecipients);

    if (*pdwNumberOfRecipients==0)
        return ERROR_SUCCESS;

    Assert(lpRecipientsInfo);

    for(i=0;i<*pdwNumberOfRecipients;i++)
    {
        if (lResult = FaxFreePersonalProfileInformation(&lpRecipientsInfo[i]) != ERROR_SUCCESS)
            return lResult;
    }

    MemFree(lpRecipientsInfo);

    *pdwNumberOfRecipients = 0;

    return ERROR_SUCCESS;
}

static DWORD
CopyRecipientInfo(DWORD dwNumberOfRecipients,
                  PFAX_PERSONAL_PROFILE   pfppDestination,
                  PFAX_PERSONAL_PROFILE   pfppSource)
{
    DWORD   dwIndex;

    Assert(pfppDestination);
    Assert(pfppSource);

    for(dwIndex=0;dwIndex<dwNumberOfRecipients;dwIndex++)
    {
        if ((pfppDestination[dwIndex].lptstrName = DuplicateString(pfppSource[dwIndex].lptstrName)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ((pfppDestination[dwIndex].lptstrFaxNumber = DuplicateString(pfppSource[dwIndex].lptstrFaxNumber)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Verbose(("Copied %ws from %ws\n", pfppSource[dwIndex].lptstrName,pfppSource[dwIndex].lptstrFaxNumber));
    }
    return ERROR_SUCCESS;
}

static DWORD
CopyPersonalProfileInfo( PFAX_PERSONAL_PROFILE   pfppDestination,
                        PFAX_PERSONAL_PROFILE   pfppSource)
{
/*++

Routine Description:

    Duplicates FAX_PERSONAL_PROFILE structures

Arguments:

    pfppDestination - points to destination structure
    pfppSource - points to source structure

Comments:
    Set pfppDestination->dwSizeOfStruct before call to this function

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
    DWORD dwResult = ERROR_SUCCESS;

    Assert(pfppDestination);
    Assert(pfppSource);

    if (!pfppSource || !pfppDestination || (pfppSource->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
        || (pfppDestination->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE)))
        return ERROR_INVALID_PARAMETER;

    ZeroMemory(pfppDestination, sizeof(FAX_PERSONAL_PROFILE));

    pfppDestination->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    if (pfppSource->lptstrName && !(pfppDestination->lptstrName = StringDup(pfppSource->lptstrName)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrFaxNumber && !(pfppDestination->lptstrFaxNumber = StringDup(pfppSource->lptstrFaxNumber)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCompany && !(pfppDestination->lptstrCompany = StringDup(pfppSource->lptstrCompany)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrStreetAddress && !(pfppDestination->lptstrStreetAddress = StringDup(pfppSource->lptstrStreetAddress)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCity && !(pfppDestination->lptstrCity = StringDup(pfppSource->lptstrCity)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrState && !(pfppDestination->lptstrState = StringDup(pfppSource->lptstrState)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrZip && !(pfppDestination->lptstrZip = StringDup(pfppSource->lptstrZip)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCountry && !(pfppDestination->lptstrCountry = StringDup(pfppSource->lptstrCountry)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrTitle && !(pfppDestination->lptstrTitle = StringDup(pfppSource->lptstrTitle)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrDepartment && !(pfppDestination->lptstrDepartment = StringDup(pfppSource->lptstrDepartment)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrOfficeLocation && !(pfppDestination->lptstrOfficeLocation = StringDup(pfppSource->lptstrOfficeLocation)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrHomePhone && !(pfppDestination->lptstrHomePhone = StringDup(pfppSource->lptstrHomePhone)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrOfficePhone && !(pfppDestination->lptstrOfficePhone = StringDup(pfppSource->lptstrOfficePhone)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrEmail && !(pfppDestination->lptstrEmail = StringDup(pfppSource->lptstrEmail)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrBillingCode && !(pfppDestination->lptstrBillingCode = StringDup(pfppSource->lptstrBillingCode)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrTSID && !(pfppDestination->lptstrTSID = StringDup(pfppSource->lptstrTSID)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    goto exit;

error:
    MemFree(pfppDestination->lptstrName);
    MemFree(pfppDestination->lptstrFaxNumber);
    MemFree(pfppDestination->lptstrCompany);
    MemFree(pfppDestination->lptstrStreetAddress);
    MemFree(pfppDestination->lptstrCity);
    MemFree(pfppDestination->lptstrState);
    MemFree(pfppDestination->lptstrZip);
    MemFree(pfppDestination->lptstrCountry);
    MemFree(pfppDestination->lptstrTitle);
    MemFree(pfppDestination->lptstrDepartment);
    MemFree(pfppDestination->lptstrOfficeLocation);
    MemFree(pfppDestination->lptstrHomePhone);
    MemFree(pfppDestination->lptstrOfficePhone);
    MemFree(pfppDestination->lptstrEmail);
    MemFree(pfppDestination->lptstrBillingCode);
    MemFree(pfppDestination->lptstrTSID);

exit:
    return dwResult;
}

VOID
FreePDEVUserMem(
    PDOCEVENTUSERMEM    pDocEventUserMem
    )

/*++

Routine Description:

    Free up the user mode memory associated with each PDEV and delete preview file if created.

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    if (pDocEventUserMem) {

        FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);
        FaxFreePersonalProfileInformation(pDocEventUserMem->lpSenderInfo);

        //
        // Free our mapping file resources (if allocated)
        //
        CloseMappingHandles(pDocEventUserMem);

        //
        // If we created a preview file, and for some reason it wasn't deleted than delete it.
        //
        if (pDocEventUserMem->szPreviewFile[0] != TEXT('\0'))
        {
            if (!DeleteFile(pDocEventUserMem->szPreviewFile))
            {
                Error(("DeleteFile() failed. Error code: %d.\n", GetLastError()));
            }
        }

        MemFree(pDocEventUserMem->lpSenderInfo);
        MemFree(pDocEventUserMem->lptstrServerName);
        MemFree(pDocEventUserMem->lptstrPrinterName);
        MemFree(pDocEventUserMem->pSubject);
        MemFree(pDocEventUserMem->pNoteMessage);
        MemFree(pDocEventUserMem->pPrintFile);
        MemFree(pDocEventUserMem->pReceiptAddress);
        MemFree(pDocEventUserMem->pPriority);
        MemFree(pDocEventUserMem->pReceiptFlags);
        MemFree(pDocEventUserMem);
    }
}


void
CloseMappingHandles(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Free any resources that were used for the preview mapping

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value: --

--*/

{
    if (pDocEventUserMem->pPreviewTiffPage)
    {
        UnmapViewOfFile(pDocEventUserMem->pPreviewTiffPage);
        pDocEventUserMem->pPreviewTiffPage = NULL;
    }
    if (pDocEventUserMem->hMapping)
    {
        if (!CloseHandle(pDocEventUserMem->hMapping))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
            // Try to continue...
        }
        pDocEventUserMem->hMapping = NULL;
    }
    if (INVALID_HANDLE_VALUE != pDocEventUserMem->hMappingFile)
    {
        if (!CloseHandle(pDocEventUserMem->hMappingFile))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
            // Try to continue...
        }
        pDocEventUserMem->hMappingFile = INVALID_HANDLE_VALUE;
    }
}


DWORD
CreateTiffPageMapping(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Creates a temperary file of size MAX_TIFF_PAGE_SIZE, and maps a view to it. This mapping serves
    as a communication channel between the UI and Graphics driver parts to transfer preview pages.

    The page starts with a MAP_TIFF_PAGE_HEADER structure that has the following fields:
        cb         - The structure size
        dwDataSize - The number of bytes of the raw TIFF data constructing the next page
        iPageCount - The page number currently printed
        bPreview   - TRUE if everything until now is OK. FALSE if print preview is disabled or
                     aborted (by either driver parts).

    The cb and iPageCount fields are used to validate the mapping: cb should always be the structure
    size and iPageCount should be the same as our internal page count (pDocEventUserMem->pageCount)
    when a new page is retrieved.
    The bPreview field is used to abort the print preview operation by either driver parts.

    This function sets the hMappingFile, hMapping, pPreviewTiffPage and devmode.dmPrivate.szMappingFile
    fields of the user memory structure according to success / failure.

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    Win32 Error codes

--*/

{
    TCHAR szTmpPath[MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    LPTSTR pszMappingFile = pDocEventUserMem->devmode.dmPrivate.szMappingFile;
    UINT uRet;

    //
    // Invalidate all mapping handles
    //
    pDocEventUserMem->hMappingFile = INVALID_HANDLE_VALUE;
    pDocEventUserMem->hMapping = NULL;
    pDocEventUserMem->pPreviewTiffPage = NULL;

    //
    // Create the path for our mapping file. This path HAS to be under the system32
    // directory or the kernel driver (NT4) won't be able to map the file. My choice is:
    // '%WinDir%\system32\'
    //
    uRet = GetSystemDirectory(szTmpPath, MAX_PATH);
    if (!uRet)
    {
        dwRet = GetLastError();
        goto ErrExit;
    }

	//    
    // Look for %windir%\system32\FxsTmp folder that is created by Setup.
    //
    if (wcslen(szTmpPath)  +
        wcslen(TEXT("\\")) +
        wcslen(FAX_PREVIEW_TMP_DIR) >= MAX_PATH)
    {
        dwRet = ERROR_BUFFER_OVERFLOW;
        goto ErrExit;
    }
    wcscat(szTmpPath, TEXT("\\"));
    wcscat(szTmpPath, FAX_PREVIEW_TMP_DIR);

	//
    // Create a NEW file
    //
    if (!GetTempFileName(szTmpPath, FAX_PREFIX, 0, pszMappingFile))
    {
        dwRet = GetLastError();
        Error(("GetTempFileName() failed:%d\n", dwRet));
        goto ErrExit;
    }    
    
    //
    // Open the new file with shared read / write / delete privileges and FILE_FLAG_DELETE_ON_CLOSE
    // attribute
    //
    if ( INVALID_HANDLE_VALUE == (pDocEventUserMem->hMappingFile = CreateFile(
                pszMappingFile,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                NULL)) )
    {
        dwRet = GetLastError();
        Error(("CreateFile() failed: %d.\n", dwRet));
        goto ErrExit;
    }

    //
    // Extend the file size to MAX_TIFF_PAGE_SIZE
    //
    dwRet = SetFilePointer(
                    pDocEventUserMem->hMappingFile,
                    MAX_TIFF_PAGE_SIZE,
                    NULL,
                    FILE_BEGIN);
    if (INVALID_SET_FILE_POINTER == dwRet)
    {
        dwRet = GetLastError();
        Error(("SetFilePointer() failed:%d\n", dwRet));
        goto ErrExit;
    }
    if (!SetEndOfFile(pDocEventUserMem->hMappingFile))
    {
        dwRet = GetLastError();
        Error(("SetEndOfFile() failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Create a file mapping of the whole file
    //
    pDocEventUserMem->hMapping = CreateFileMapping(
        pDocEventUserMem->hMappingFile,         // handle to file
        NULL,                                   // security
        PAGE_READWRITE,                         // protection
        0,                                      // high-order DWORD of size
        0,                                      // low-order DWORD of size
        NULL                                    // object name
        );
    if (pDocEventUserMem->hMapping == NULL)
    {
        dwRet = GetLastError();
        Error(("File mapping failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Open a view
    //
    pDocEventUserMem->pPreviewTiffPage = (PMAP_TIFF_PAGE_HEADER) MapViewOfFile(
        pDocEventUserMem->hMapping,         // handle to file-mapping object
        FILE_MAP_WRITE,                     // access mode
        0,                                  // high-order DWORD of offset
        0,                                  // low-order DWORD of offset
        0                                   // number of bytes to map
        );
    if (NULL == pDocEventUserMem->pPreviewTiffPage)
    {
        dwRet = GetLastError();
        Error(("MapViewOfFile() failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Success - set initial header information
    //
    pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
    pDocEventUserMem->pPreviewTiffPage->cb = sizeof(MAP_TIFF_PAGE_HEADER);
    pDocEventUserMem->pPreviewTiffPage->dwDataSize = 0;
    pDocEventUserMem->pPreviewTiffPage->iPageCount = 0;
    return ERROR_SUCCESS;

ErrExit:

    //
    // Cleanup
    //
    // IMPORTANT: Set mapping file name to empty string. This signals the graphics dll that
    // there is no mapping file.
    //
    CloseMappingHandles(pDocEventUserMem);
    pszMappingFile[0] = TEXT('\0');
    return dwRet;
}


INT
DocEventCreateDCPre(
    HANDLE        hPrinter,
    HDC           hdc,
    PCREATEDCDATA pCreateDCData,
    PDEVMODE     *ppdmOutput
    )

/*++

Routine Description:

    Handle CREATEDCPRE document event

Arguments:

    hPrinter - Handle to the printer object
    hdc - Specifies the printer device context
    pCreateDCData - Pointer to CREATEDCDATA structure passed in from GDI
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/
{
    PDOCEVENTUSERMEM    pDocEventUserMem = NULL;
    PPRINTER_INFO_2     pPrinterInfo2 = NULL;
    DWORD               dwRes;
    DWORD               dwEnvSize;

    Assert(pCreateDCData);
    Assert(ppdmOutput);

    Verbose(("Document event: CREATEDCPRE%s\n", pCreateDCData->fromCreateIC ? "*" : ""));
    *ppdmOutput = NULL;

    //
    // Allocate space for user mode memory data structure
    //

    if (((pDocEventUserMem = MemAllocZ(sizeof(DOCEVENTUSERMEM))) == NULL))
    {
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    ZeroMemory(pDocEventUserMem, sizeof(DOCEVENTUSERMEM));

    if ((pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) == NULL ||
        (pDocEventUserMem->lptstrPrinterName = DuplicateString(pPrinterInfo2->pPrinterName)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    if (pPrinterInfo2->pServerName==NULL)
    {
        pDocEventUserMem->lptstrServerName = NULL;
    }
    else
    {
        LPTSTR pServerName = pPrinterInfo2->pServerName;

        //
        // Truncate prefix backslashes
        //
        while (*pServerName == TEXT('\\'))
        {
            pServerName++;
        }
        //
        // Save the server name
        //
        if ((pDocEventUserMem->lptstrServerName = DuplicateString(pServerName)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            goto Error;
        }
    }

    //
    // Merge the input devmode with the driver and system defaults
    //

    pDocEventUserMem->hPrinter = hPrinter;

    GetCombinedDevmode(&pDocEventUserMem->devmode,
                        pCreateDCData->pdmInput, hPrinter, pPrinterInfo2, FALSE);
    Verbose(("Document event: CREATEDCPRE %x\n", pDocEventUserMem));
    MemFree(pPrinterInfo2);

    //
    // Special code path for EFC server printing - if FAXDM_EFC_SERVER bit is
    // set in DMPRIVATE.flags, then we'll bypass the fax wizard and let the
    // job through without any intervention.
    //
    //
    // The above comment is not accurate. The flag that turns off the wizard is
    // FAXMDM_NO_WIZARD.
    // This flag is set in the private DEVMODE area (flags field) by FaxStartPrintJob.
    // FaxStartPrintJob already has all the information that the wizard usually provides and it
    // wishes the wizard to not show up. To do that it sets this field and passes the
    // job parameters in the JOB_INFO_2.pParameters string as a tagged string.
    // Note that this is not the same case as when StartDoc is called with a output file name specified.
    // In this case the wizard is not brought up as well.
    //
    if (pDocEventUserMem->devmode.dmPrivate.flags & FAXDM_NO_WIZARD) 
    {
        pDocEventUserMem->directPrinting = TRUE;
    }
    //
    // if printing a fax attachment then enable direct printing
    //
    dwEnvSize = GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, NULL, 0 );
    if (dwEnvSize)
    {
        pDocEventUserMem->pPrintFile = (LPTSTR) MemAllocZ( dwEnvSize * sizeof(TCHAR) );
        if (NULL == pDocEventUserMem->pPrintFile)
        {
            Error(("Memory allocation failed\n"));
            goto Error;
        }

        if (0 == GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, pDocEventUserMem->pPrintFile, dwEnvSize ))
        {
            Error(("GetEnvironmentVariable failed\n"));
            MemFree (pDocEventUserMem->pPrintFile);
            pDocEventUserMem->pPrintFile = NULL;
            goto Error;
        }
        pDocEventUserMem->bAttachment = TRUE;
        pDocEventUserMem->directPrinting = TRUE;
    }

    //
    // Create a memory mapped file that will serve as a commincation chanel between both
    // driver parts. This file will provide means of transfering rendered TIFF pages for
    // print preview if it was required by the user
    //
    dwRes = CreateTiffPageMapping(pDocEventUserMem);
    if (ERROR_SUCCESS != dwRes)
    {
        Error(("CreateTiffPageMapping() failed: %d\n", dwRes));
        //
        // We can still continue, but print preview won't be available...
        //
        pDocEventUserMem->bShowPrintPreview = FALSE;
        pDocEventUserMem->bPreviewAborted = TRUE;
    }
    else
    {
        pDocEventUserMem->bShowPrintPreview = TRUE;
        pDocEventUserMem->bPreviewAborted = FALSE;
    }
    //
    // Initialize the TIFF preview file fields
    //
    pDocEventUserMem->szPreviewFile[0] = TEXT('\0');
    pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
    //
    // Mark the private fields of our devmode
    //
    //@
    //@ DocEventUserMem.Siganture is allways &DocEventUserMem
    //@ DocEventUserMem.Signature.DocEventUserMem.Signature is allways &DocEventUserMem
    //@ ValidPDEVUserMem checks for this.
    //@
    MarkPDEVUserMem(pDocEventUserMem);
    //@
    //@ This make the driver use the devmode we merged instaed of the
    //@ devmode specified by the caller to CreateDC.
    //@ This way we make sure the driver gets a DEVMODE with per user
    //@ default (W2K) or just hard-code defaults (NT4) for all the fields
    //@ that were not speicified or invalid in the input devmode.
    //@ Note that the system passes to the driver a COPY of the devmode structure
    //@ we return and NOT a pointer to it.
    //@
    *ppdmOutput = (PDEVMODE) &pDocEventUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;

Error:
    MemFree(pPrinterInfo2);
    if (pDocEventUserMem)
    {
        MemFree(pDocEventUserMem->lptstrPrinterName);
        MemFree(pDocEventUserMem);
    }
    return DOCUMENTEVENT_FAILURE;
}


INT
DocEventResetDCPre(
    HDC         hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PDEVMODE    pdmInput,
    PDEVMODE   *ppdmOutput
    )

/*++

Routine Description:

    Handle RESETDCPRE document event

Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory of DocEvent structure
    pdmInput - Points to the input devmode passed to ResetDC
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    if (pdmInput == (PDEVMODE) &pDocEventUserMem->devmode) 
    {

        //
        // ResetDC was called by ourselves - assume the devmode is already valid
        //
    } 
    else 
    {
        //
        // Merge the input devmode with driver and system default
        //
        GetCombinedDevmode(&pDocEventUserMem->devmode,
            pdmInput, pDocEventUserMem->hPrinter, NULL, TRUE);
        //
        // Mark the private fields of our devmode
        //
        MarkPDEVUserMem(pDocEventUserMem);
    }
    *ppdmOutput = (PDEVMODE) &pDocEventUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;
}


BOOL
IsPrintingToFile(
    LPCTSTR     pDestStr
    )

/*++

Routine Description:

    Check if the destination of a print job is a file.

Arguments:

    pDestStr - Job destination specified in DOCINFO.lpszOutput

Return Value:

    TRUE if the destination is a disk file, FALSE otherwise

--*/

{
    DWORD   fileAttrs, fileType;
    HANDLE  hFile;

    //
    // If the destination is NULL, then we're not printing to file
    //
    // Otherwise, attempt to use the destination string as the name of a file.
    // If we failed to get file attributes or the name refers to a directory,
    // then we're not printing to file.
    //

    if (pDestStr == NULL)
    {
        return FALSE;
    }
    //
    //  make sure it's not a directory
    //
    fileAttrs = GetFileAttributes(pDestStr);
    if (fileAttrs != 0xffffffff)
    {
        if (fileAttrs & FILE_ATTRIBUTE_DIRECTORY)
        {
            return FALSE;
        }
    }
    //
    // check if file exists...if it doesn't try to create it.
    //
    hFile = CreateFile(pDestStr, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hFile = CreateFile(pDestStr, 0, 0, NULL, CREATE_NEW, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    }
    //
    // Verifiy that we did not opened a port handle
    //
    fileAttrs = GetFileAttributes(pDestStr);
    if (0xffffffff == fileAttrs)
    {
        //
        // pDestStr does not point to a valid file
        //
        if (!CloseHandle(hFile))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
            // Try to continue...
        }
        return FALSE;
    }

    //
    // verify that this file is really a disk file, not a link to LPT1 or something evil like that
    //
    fileType = GetFileType(hFile);
    if (!CloseHandle(hFile))
    {
        Error(("CloseHandle() failed: %d.\n", GetLastError()));
        // Try to continue...
    }
    if ((fileType & FILE_TYPE_DISK)==0)
    {
        return FALSE;
    }
    //
    // it must be a file
    //
    return TRUE;
}

DWORD LaunchFaxWizard(PDOCEVENTUSERMEM    pDocEventUserMem)
{
    DWORD                   hWndOwner = 0;
    DWORD                   dwFlags  = 0;
    LPFAX_SEND_WIZARD_DATA  lpInitialData = NULL;
    LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData = NULL;
    INT                     iResult;
    TCHAR                   tszNumericData[10];
    DWORD                   ec = ERROR_SUCCESS;
    HRESULT                 hRc;

    if ( !(lpFaxSendWizardData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) ||
            !(lpInitialData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) )
    {
        ec = GetLastError();
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    ZeroMemory(lpInitialData, sizeof(FAX_SEND_WIZARD_DATA));
    lpInitialData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);
    lpInitialData->dwPageCount =  pDocEventUserMem->pageCount;

    ZeroMemory(lpFaxSendWizardData, sizeof(FAX_SEND_WIZARD_DATA));
    lpFaxSendWizardData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);


    // prepare structures and parameters
    lpInitialData->tmSchedule.wHour = pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour;
    lpInitialData->tmSchedule.wMinute = pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute;
    lpInitialData->lptstrPreviewFile = StringDup(pDocEventUserMem->szPreviewFile);
    if (!lpInitialData->lptstrPreviewFile)
    {
        ec = GetLastError();
        Error(("StringDup() failed (ec: %ld)",ec));
        goto Error;
    }


    if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
    {
        dwFlags |=  FSW_USE_SEND_WIZARD | FSW_FORCE_COVERPAGE;
    }

    // If the file mapping succeeded enable the preview option
    if (pDocEventUserMem->pPreviewTiffPage &&
		FALSE == pDocEventUserMem->bPreviewAborted)
    {
        dwFlags |= FSW_PRINT_PREVIEW_OPTION;
    }

    iResult = DOCUMENTEVENT_SUCCESS;

    hRc = FaxSendWizard( hWndOwner,
                         dwFlags,
                         pDocEventUserMem->lptstrServerName,
                         pDocEventUserMem->lptstrPrinterName,
                         lpInitialData,
                         pDocEventUserMem->tstrTifName,
                         lpFaxSendWizardData );
    {
            }

    if (S_FALSE == hRc)
    {
        ec = ERROR_CANCELLED;
        goto Error; // This is not really an error
    }

    if (S_OK != hRc)
    {
        Error(("FaxSendWizard() failed (hRc: %ld)",hRc));
        ec = ERROR_GEN_FAILURE;
        goto Error;
    }

    //
    // Unpack result structures:
    //

    pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour = lpFaxSendWizardData->tmSchedule.wHour ;
    pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute = lpFaxSendWizardData->tmSchedule.wMinute ;
    pDocEventUserMem->devmode.dmPrivate.whenToSend = lpFaxSendWizardData->dwScheduleAction;


    Assert ((lpFaxSendWizardData->Priority >= FAX_PRIORITY_TYPE_LOW) &&
                (lpFaxSendWizardData->Priority <= FAX_PRIORITY_TYPE_HIGH));
        if (0 > _snwprintf (tszNumericData,
                            sizeof (tszNumericData) / sizeof (tszNumericData[0]),
                            TEXT("%d"),
                            lpFaxSendWizardData->Priority))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            goto Error;
        }

        pDocEventUserMem->pPriority = DuplicateString(tszNumericData);
        if (!pDocEventUserMem->pPriority)
        {
            ec = GetLastError();
            goto Error;
        }

        if (0 > _snwprintf (tszNumericData,
                            sizeof (tszNumericData) / sizeof (tszNumericData[0]),
                            TEXT("%d"),
                            lpFaxSendWizardData->dwReceiptDeliveryType))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            goto Error;
        }

        pDocEventUserMem->pReceiptFlags = DuplicateString(tszNumericData);
        if (!pDocEventUserMem->pReceiptFlags)
        {
            ec = GetLastError();
            goto Error;
        }

        if (lpFaxSendWizardData->szReceiptDeliveryAddress)
        {
            if (!(pDocEventUserMem->pReceiptAddress
                    = DuplicateString(lpFaxSendWizardData->szReceiptDeliveryAddress)))
            {
                ec = GetLastError();
                Error(("DuplicateString() failed (ec: %ld)",ec));
                goto Error;
            }
        }
    if (lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode)
        _tcscpy(pDocEventUserMem->devmode.dmPrivate.billingCode,
            lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode);

    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName)
        _tcscpy(pDocEventUserMem->coverPage,
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName );
    pDocEventUserMem->bServerCoverPage =
        lpFaxSendWizardData->lpCoverPageInfo->bServerBased;

    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
    {
        if (!(pDocEventUserMem->pSubject
                = DuplicateString(lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)))
        {
            ec = GetLastError();
            Error(("DuplicateString() failed (ec: %ld)",ec));
            goto Error;
        }
    }
    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)
    {
        if (!(pDocEventUserMem->pNoteMessage
                = DuplicateString(lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)))
        {
            ec = GetLastError();
            Error(("DuplicateString() failed (ec: %ld)",ec));
            goto Error;
        }
    }

    Assert(lpFaxSendWizardData->dwNumberOfRecipients);
    pDocEventUserMem->dwNumberOfRecipients = lpFaxSendWizardData->dwNumberOfRecipients;

    if (!SetEnvironmentVariable( _T("ScanTifName"), pDocEventUserMem->tstrTifName ))
    {
        Error(("SetEnvironmentVariable failed. ec = 0x%X",GetLastError()));
    }

    // copy recipients
    if ( pDocEventUserMem->dwNumberOfRecipients && (pDocEventUserMem->lpRecipientsInfo =
        MemAllocZ(sizeof(FAX_PERSONAL_PROFILE)*pDocEventUserMem->dwNumberOfRecipients)) == NULL)
    {
        ec = GetLastError();
        Error(("Memory allocation failed (ec: %ld)",ec));
        goto Error;
    }

    if ((ec = CopyRecipientInfo(pDocEventUserMem->dwNumberOfRecipients,
                                     pDocEventUserMem->lpRecipientsInfo,
                                     lpFaxSendWizardData->lpRecipientsInfo)) != ERROR_SUCCESS)
    {

        Error(("CopyRecipientInfo failed (ec: %ld)",ec));
        goto Error;
    }

    if (lpFaxSendWizardData->lpSenderInfo)
    {
        if ((pDocEventUserMem->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))) == NULL)
        {

            ec = GetLastError();
            Error(("MemAlloc() failed (ec: %ld)",ec));
            goto Error;
        }
        pDocEventUserMem->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        if ((ec = CopyPersonalProfileInfo(   pDocEventUserMem->lpSenderInfo,
                                             lpFaxSendWizardData->lpSenderInfo)) != ERROR_SUCCESS)
        {
            Error(("CopyRecipientInfo failed (ec: %ld)", ec));
            pDocEventUserMem->lpSenderInfo = NULL;
            goto Error;
        }

    }

    Assert(pDocEventUserMem->lpRecipientsInfo);
    pDocEventUserMem->jobType = JOBTYPE_NORMAL;
    Assert(ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert(ERROR_SUCCESS != ec);
    FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);
    FaxFreePersonalProfileInformation(pDocEventUserMem->lpSenderInfo);
    MemFree(pDocEventUserMem->lpSenderInfo);
    MemFree(pDocEventUserMem->pSubject);
    MemFree(pDocEventUserMem->pNoteMessage);
    MemFree(pDocEventUserMem->pPrintFile);
    MemFree(pDocEventUserMem->pReceiptAddress);
    MemFree(pDocEventUserMem->pPriority);
    MemFree(pDocEventUserMem->pReceiptFlags);


Exit:
    if (lpInitialData) 
    {
         //
         // Note: One should NOT call FaxFreeSendWizardData on lpInitialData.
         //       The reason is that FaxSendWizard used a different allocator
         //       then we do. Thus we just free the individual fields we
         //       allocated.
         MemFree(lpInitialData->lptstrPreviewFile);
    }
    FaxFreeSendWizardData(lpFaxSendWizardData);
    MemFree (lpInitialData);
    MemFree (lpFaxSendWizardData);
    return ec;
}


INT
DocEventStartDocPre(
    HDC         hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    LPDOCINFO   pDocInfo
    )

/*++

Routine Description:

    Handle STARTDOCPRE document event.

    This events occurs when StartDoc is called. GDI will call this event just before calling kernel mode GDI.

    If the printing is to a file:
        set the job type to JOBTYPE_DIRECT (pDocEventUserMem->JobType)
        and return successfully with DOCUMENTEVENT_SUCCESS.
    If the printing is not to a file:
        Bring up the send fax wizard.
        The send fax wizard will update the relevant pUserMem members for recipient list, subject, note , etc.
        Indicate that this is a normal job be setting
        pDocEventUserMem->jobType = JOBTYPE_NORMAL;


Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory structure
    pDocInfo - Points to DOCINFO structure that was passed in from GDI

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    //
    // Initialize user mode memory structure
    //

    DWORD                   hWndOwner = 0;
    DWORD                   dwFlags  = 0;

    pDocEventUserMem->pageCount = 0;
    FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);

    //
    // Present the fax wizard here if necessary
    //
    //
    //If DOCINFO has a file name specified and this is indeed a file name
    //(not a directory or something like LPT1:) then we need to print directly to the
    //file and we do not bring up the send wizard.
    //

    if (pDocInfo && IsPrintingToFile(pDocInfo->lpszOutput))
    {

        //
        // Printing to file case: don't get involved
        //

        Warning(("Printing direct: %ws\n", pDocInfo->lpszOutput));
        pDocEventUserMem->jobType = JOBTYPE_DIRECT;
        pDocEventUserMem->directPrinting = TRUE;

    }
    else
    {
        //
        // Normal fax print job. Present the send fax wizard.
        // If the user selected cancel, then return -2 to GDI.
        //
        //
        // The wizard will update information in pUserMem.
        // This includes the recipient list , selected cover page, subject text , note text
        // and when to print the fax.
        //

        //
        // Make sure we don't leave any open files
        //
        if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
        {
            //
            // We should never get here with an open file handle. But if so, close the handle
            // (TODO: This file will be opened with delete on close).
            //
            Assert(FALSE);
            CloseHandle(pDocEventUserMem->hPreviewFile);
            pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
        }

        //
        // Create a temporary TIFF file for preview
        //
        if (FALSE == pDocEventUserMem->bPreviewAborted)
        {
            if (GenerateUniqueFileName(
                                NULL,   // Create in the system temporary directory
                                FAX_TIF_FILE_EXT,
                                pDocEventUserMem->szPreviewFile,
                                MAX_PATH))
            {
                pDocEventUserMem->hPreviewFile = CreateFile(
                                                    pDocEventUserMem->szPreviewFile,
                                                    GENERIC_WRITE,
                                                    0,
                                                    NULL,
                                                    OPEN_EXISTING,
                                                    FILE_ATTRIBUTE_TEMPORARY,
                                                    NULL);
                if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
                {
                    //
                    // Success. Signal the graphics driver we want print preview
                    //

                    // If we enabled the preview option to the user it means everything is OK
                    Assert(pDocEventUserMem->pPreviewTiffPage);
                    pDocEventUserMem->pPreviewTiffPage->bPreview = TRUE;
                    pDocEventUserMem->bShowPrintPreview = TRUE;
                }
                else
                {
                    Error(("Failed opening file.Error: %d.\n", GetLastError()));
                    if (!DeleteFile(pDocEventUserMem->szPreviewFile))
                    {
                        Error(("DeleteFile() failed: %d.\n", GetLastError()));
                    }
                }
            }
            else
            {
                Error(("Failed creating temporary preview file\n"));
            }

            //
            // If we failed creating the file abort preview operation
            //
            if (INVALID_HANDLE_VALUE == pDocEventUserMem->hPreviewFile)
            {
                //
                // Set file name to empty string so we won't try to delete the file twice when
                // the DC is deleted
                //
                pDocEventUserMem->szPreviewFile[0] = TEXT('\0');

                //
                // Abort preview (note that the preview is still disabled in the mapping).
                //
                pDocEventUserMem->bPreviewAborted = TRUE;
            }
        }

        pDocEventUserMem->jobType = JOBTYPE_NORMAL;
    }

    return DOCUMENTEVENT_SUCCESS;
}


DWORD
FaxTimeToJobTime(
    DWORD   faxTime
    )

/*++

Routine Description:

    Convert fax time to spooler job time:
        Fax time is a DWORD whose low-order WORD represents hour value and
        high-order WORD represents minute value. Spooler job time is a DWORD
        value expressing minutes elapsed since 12:00 AM GMT.

Arguments:

    faxTime - Specifies the fax time to be converted

Return Value:

    Spooler job time corresponding to the input fax time

--*/

{
    TIME_ZONE_INFORMATION   timeZoneInfo;
    LONG                    jobTime;

    //
    // Convert fax time to minutes pass midnight
    //

    jobTime = LOWORD(faxTime) * 60 + HIWORD(faxTime);

    //
    // Take time zone information in account - Add one full
    // day to take care of the case where the bias is negative.
    //

    switch (GetTimeZoneInformation(&timeZoneInfo)) {

    case TIME_ZONE_ID_DAYLIGHT:

        jobTime += timeZoneInfo.DaylightBias;

    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_UNKNOWN:

        jobTime += timeZoneInfo.Bias + MINUTES_PER_DAY;
        break;

    default:

        Error(("GetTimeZoneInformation failed: %d\n", GetLastError()));
        break;
    }

    //
    // Make sure the time value is less than one day
    //

    return jobTime % MINUTES_PER_DAY;
}

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    Error(("GetJob failed: %d\n", GetLastError()));
    MemFree(pJobInfo);
    return NULL;
}


BOOL
SetJobInfoAndTime(
    HANDLE      hPrinter,
    DWORD       jobId,
    LPTSTR      pJobParam,
    PDMPRIVATE  pdmPrivate
    )

/*++

Routine Description:

    Change the devmode and start/stop times associated with a cover page job

    Sets JOB_INFO_2:pParameters to the provided pJobParam string that contains the fax job parameters
    to be convyed to the fax print monitor.

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the job ID
    pJobParam - Specifies the fax job parameters
    pdmPrivate - Specifies private devmode information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_2 *pJobInfo2;
    BOOL        result = FALSE;

    //
    // Get the current job information
    //

    if (pJobInfo2 = MyGetJob(hPrinter, 2, jobId)) {

        //
        // set the time to send to be now, always
        //

        Warning(("Fax job parameters: %ws\n", pJobParam));

        //
        // Set the pParameters field of JOB_INFO_2 to the tagged string with the job
        // information. This mechanism is used to pass the fax related job information
        // to the fax monitor.
        //
        pJobInfo2->pParameters = pJobParam;
        pJobInfo2->Position = JOB_POSITION_UNSPECIFIED;
        pJobInfo2->pDevMode = NULL;
        pJobInfo2->UntilTime = pJobInfo2->StartTime;

        if (! (result = SetJob(hPrinter, jobId, 2, (PBYTE) pJobInfo2, 0))) {
            Error(("SetJob failed: %d\n", GetLastError()));
        }

        MemFree(pJobInfo2);
    }

    return result;
}


BOOL
ChainFaxJobs(
    HANDLE  hPrinter,
    DWORD   parentJobId,
    DWORD   childJobId
    )

/*++

Routine Description:

    Tell the spooler to chain up two print jobs

Arguments:

    hPrinter - Specifies the printer object
    parentJobId - Specifies the job to chain from
    childJobId - Specifies the job to chain to

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_3 jobInfo3 = { parentJobId, childJobId };

    Warning(("Chaining cover page job to body job: %d => %d\n", parentJobId, childJobId));

    return SetJob(hPrinter, parentJobId, 3, (PBYTE) &jobInfo3, 0);
}


LPTSTR
GetJobName(
    HANDLE  hPrinter,
    DWORD   jobId
    )

/*++

Routine Description:

    Return the name of the specified print job

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the fax body job

Return Value:

    Pointer to the job name string, NULL if there is an error

--*/

{
    JOB_INFO_1 *pJobInfo1;
    LPTSTR      pJobName = NULL;

    //
    // Get the information about the specified job and
    // return a copy of the job name string
    //

    if (pJobInfo1 = MyGetJob(hPrinter, 1, jobId))
    {
        if ( (pJobInfo1->pDocument) &&
             ((pJobName = DuplicateString(pJobInfo1->pDocument)) == NULL) )
        {
            Error(("DuplicateString(%s) failed.", pJobInfo1->pDocument));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        MemFree(pJobInfo1);
    }

    return pJobName;
}




//*********************************************************************************
//* Name:   ComposeFaxJobName()
//* Author: Ronen Barenboim
//* Date:   April 22, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the document name for a print job by composing the document
//*     body  name with the recipient name (in case of a single recipient) or
//*     the word "Broadcast" in case of a multiple recipient job.
//*     The job name has the format <Recipient Name> - <Body Name> where
//*     <Recipient Name> is "Broadcast" in the case a multiple recipient
//*     tranmission.
//*
//* PARAMETERS:
//*     [IN]    PDOCEVENTUSERMEM pDocEventUserMem
//*         A pointer to a USERMEM structure that contains information on the recipients.
//*         Note that USERMEM.nRecipientCount must be valid (calculated) before calling
//*         this function.
//*
//*     [IN]    LPTSTR  pBodyDocName
//*         The name of the document.
//*
//* RETURN VALUE:
//*     Pointer to a newly allocated string that contains the composed name.
//*     The caller must free the memory occupied by the string by calling
//*     MemFree().
//*     If the function fails the return value is NULL.
//*********************************************************************************
LPTSTR
ComposeFaxJobName(
    PDOCEVENTUSERMEM pDocEventUserMem,
    LPTSTR  pBodyDocName
    )

#define DOCNAME_FORMAT_STRING   TEXT("%s - %s")

{

    LPTSTR  pCoverJobName;
    LPTSTR pRecipientName;
    #define MAX_BROADCAST_STRING_LEN 256
    TCHAR szBroadcast[MAX_BROADCAST_STRING_LEN];

    Assert(pDocEventUserMem);

    if (pDocEventUserMem->dwNumberOfRecipients > 1) {
        if (!LoadString(ghInstance,
                        IDS_BROADCAST_RECIPIENT,
                        szBroadcast,
                        sizeof(szBroadcast)/sizeof(TCHAR)))
        {
            Error(("Failed to load broadcast recipient string. (ec: %lc)",GetLastError()));
            return NULL;
        }
        else {
            pRecipientName = szBroadcast;
        }
    } else {
        Assert(pDocEventUserMem->lpRecipientsInfo);
        Assert(pDocEventUserMem->lpRecipientsInfo[0].lptstrName);
        pRecipientName = pDocEventUserMem->lpRecipientsInfo[0].lptstrName;
    }


    if (pBodyDocName == NULL) {
        //
        // No body. job name is just the recipient name.
        //
        if ((pCoverJobName = DuplicateString(pRecipientName)) == NULL)
        {
            Error(("DuplicateString(%s) failed", pRecipientName));
        }


    }
    else
    {
        DWORD dwSize;

        dwSize = SizeOfString(DOCNAME_FORMAT_STRING) +
                 SizeOfString(pBodyDocName) +
                 SizeOfString(pRecipientName);
        pCoverJobName = MemAlloc(dwSize);
        if (pCoverJobName)
        {
            //
            // Body name specified. The cover page job name is generated by
            // concatenating the recipient's name with the body job name.
            //
            wsprintf(pCoverJobName, DOCNAME_FORMAT_STRING, pRecipientName, pBodyDocName);
        }
        else
        {
            Error((
                "Failed to allocate %ld bytes for pCoverJobName (ec: %ld)",
                dwSize,
                GetLastError()));

        }

    }
    return pCoverJobName;
}


LPTSTR
GetBaseNoteFilename(
    VOID
    )

/*++

Routine Description:

    Get the name of base cover page file in system32 directory

Arguments:

    argument-name - description of argument

Return Value:

    Pointer to name of base cover page file
    NULL if there is an error

--*/

#define BASENOTE_FILENAME   TEXT("\\basenote.cov")

{
    TCHAR       systemDir[MAX_PATH];
    LPTSTR      pBaseNoteName = NULL;
    COVDOCINFO  covDocInfo;

    if (GetSystemDirectory(systemDir, MAX_PATH) &&
        (pBaseNoteName = MemAlloc(SizeOfString(systemDir) + SizeOfString(BASENOTE_FILENAME))))
    {
        _tcscpy(pBaseNoteName, systemDir);
        _tcscat(pBaseNoteName, BASENOTE_FILENAME);
        Verbose(("Base cover page filename: %ws\n", pBaseNoteName));

        if (PrintCoverPage(NULL, NULL, pBaseNoteName, &covDocInfo) ||
            ! (covDocInfo.Flags & COVFP_NOTE) ||
            ! (covDocInfo.Flags & COVFP_SUBJECT))
        {
            Error(("Invalid base cover page file: %ws\n", pBaseNoteName));
            MemFree(pBaseNoteName);
            pBaseNoteName = NULL;
        }
    }

    return pBaseNoteName;
}


//*********************************************************************************
//* Name:   ComposeFaxJobParameter()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates the tagged parameter string that carries the job parameters
//*     (sender information, cover page information ,recipient information)
//*     to the fax monitor on the fax server (using JOB_INFO_2.pParameters).
//* PARAMETERS:
//*     pDocEventUserMem
//*         A pointer to a USERMEM structure from which some of the information
//*         is collected.
//*     pCPFields
//*         A pointer to a COVERPAGEFIELS structure from which sender and cover
//*         page information is collected.
//*     lppParamBuf
//*         The address of a pointer varialbe that will accept the address of the
//*         buffer this function will allocated for the resulting tagged string.
//*         The caller of this function must free this buffer using MemFree().
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         If failed.
//*********************************************************************************
BOOL
ComposeFaxJobParameter(
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR  *           lppParamBuf
    )
{
    DWORD   dwBufSize;
    DWORD   dwPartialBufSize;
    DWORD   dwLeftBufferSize;
    LPTSTR  lptstrBuf;
    UINT    i;

    Assert(pDocEventUserMem);
    Assert(pCPFields);
    Assert(lppParamBuf);

    //
    // Calculate the parameter buffer we need to allocated
    //
    dwBufSize=0;

    //
    // Calcualte non recipient params string size
    //
    ComposeSenderJobParam(NULL, &dwPartialBufSize, pDocEventUserMem, pCPFields); // void return value
    dwBufSize=dwBufSize+dwPartialBufSize;

    //
    // Go over each recipient and calculate the total required buffer size
    //
    for (i=0;i<pDocEventUserMem->dwNumberOfRecipients;i++)
    {
        //
        // Get recipient's name and fax number
        //
        Assert(pDocEventUserMem->lpRecipientsInfo[i].lptstrName);
        pCPFields->RecName = pDocEventUserMem->lpRecipientsInfo[i].lptstrName;
        Assert(pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber);
        pCPFields->RecFaxNumber = pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber;
        ComposeRecipientJobParam(NULL, &dwPartialBufSize, pCPFields);
        dwBufSize=dwBufSize+dwPartialBufSize; //keep space for the seperating NULL
    }
    //
    // Don't forget the space for the terminating NULL (the ComposeX functions do not include
    // it in the size they report).
    //
    dwBufSize=dwBufSize+sizeof(TCHAR); // dwBufSize is size in BYTES so we must calc the byte size of a TCHAR
    //
    // Allocate the required buffer
    //
    lptstrBuf=MemAlloc(dwBufSize);
    if (!lptstrBuf) {
        Error(("Failed to allocate buffer of size %ld for parameter buffer (ec: 0x%0X)",dwBufSize,GetLastError()));
        return FALSE;
    }

    //
    // Write the parameters into the buffer
    //
    dwLeftBufferSize = dwBufSize;
    dwPartialBufSize = dwBufSize;
    *lppParamBuf=lptstrBuf;
    ComposeSenderJobParam(lptstrBuf, &dwPartialBufSize, pDocEventUserMem, pCPFields);
    lptstrBuf+=(dwPartialBufSize/sizeof(TCHAR));  // The reported size is in bytes !!!
    Assert (dwLeftBufferSize >= dwPartialBufSize);
    dwLeftBufferSize -= dwPartialBufSize;
    for (i=0;i<pDocEventUserMem->dwNumberOfRecipients;i++)
    {
        //
        // Get recipient's name and fax number
        //
        pCPFields->RecName = pDocEventUserMem->lpRecipientsInfo[i].lptstrName;
        pCPFields->RecFaxNumber = pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber;
        dwPartialBufSize = dwLeftBufferSize;
        ComposeRecipientJobParam(lptstrBuf, &dwPartialBufSize, pCPFields);
        lptstrBuf+=(dwPartialBufSize/sizeof(TCHAR)); // The reported size is in bytes !!!
        Assert (dwLeftBufferSize >= dwPartialBufSize);
        dwLeftBufferSize -= dwPartialBufSize;
    }
    //
    // No need to add a terminating NULL since ParamTagsToString allways appends a NULL terminated string
    // to the existing string (it uses _tcscpy).
    //
    return TRUE;
}

//*********************************************************************************
//* Name:   ComposeRecipientJobParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a taged parameter string containing recipient information.
//*
//* PARAMETERS:
//*     lpParamBuf
//*         Pointer to the string buffer where the tagged string is written.
//*     lpdwParamSize
//*         Pointer to a DWORD where the function reports the size of the parameter
//*         string in BYTES.
//*         If this parameter is NULL then the function does not generate
//*         the string but only reports its size.
//*         The size does NOT include the terminating NULL char.
//*     pCPFields
//*         Pointer to a COVERPAGEFIELDS structure from which the recipient
//*         information is collected.
//* RETURN VALUE:
//*     None.
//*********************************************************************************
void
ComposeRecipientJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    const COVERPAGEFIELDS *   pCPFields
    )

{


    FAX_TAG_MAP_ENTRY tagMap[] =
    {

        //
        // Recipient info
        //
        { FAXTAG_NEW_RECORD,                FAXTAG_NEW_RECORD_VALUE}, // Parameters record start indication
        { FAXTAG_RECIPIENT_NAME,            pCPFields->RecName },
        { FAXTAG_RECIPIENT_NUMBER,          pCPFields->RecFaxNumber },
        { FAXTAG_RECIPIENT_COMPANY,         pCPFields->RecCompany },
        { FAXTAG_RECIPIENT_STREET,          pCPFields->RecStreetAddress },
        { FAXTAG_RECIPIENT_CITY,            pCPFields->RecCity },
        { FAXTAG_RECIPIENT_STATE,           pCPFields->RecState },
        { FAXTAG_RECIPIENT_ZIP,             pCPFields->RecZip },
        { FAXTAG_RECIPIENT_COUNTRY,         pCPFields->RecCountry },
        { FAXTAG_RECIPIENT_TITLE,           pCPFields->RecTitle },
        { FAXTAG_RECIPIENT_DEPT,            pCPFields->RecDepartment },
        { FAXTAG_RECIPIENT_OFFICE_LOCATION, pCPFields->RecOfficeLocation },
        { FAXTAG_RECIPIENT_HOME_PHONE,      pCPFields->RecHomePhone },
        { FAXTAG_RECIPIENT_OFFICE_PHONE,    pCPFields->RecOfficePhone },

    };


    DWORD dwTagCount;

    Assert(pCPFields);
    Assert(lpdwParamSize);

    dwTagCount=sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY);

    ParamTagsToString(tagMap, dwTagCount, lpParamBuf, lpdwParamSize );
}




//*********************************************************************************
//* Name:   ComposeSenderJobParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a taged parameter string containing cover page information, sender
//*     information and the number of recipients in the tranmission.
//*
//* PARAMETERS:
//*     lpParamBuf
//*         Pointer to the string buffer where the tagged string is written.
//*     lpdwParamSize
//*         Pointer to a DWORD where the function reports the size of the parameter
//*         string in BYTES.
//*         If this parameter is NULL then the function does not generate
//*         the string but only reports its size.
//*         The size does NOT include the terminating NULL char.
//*     pDocEventUserMem
//*         Pointer to a USERMEM structure from which some of information
//*         is collected.
//*     pCPFields
//*         Pointer to a COVERPAGEFIELDS structure from which the cover page
//*         and sender information is collected.
//*
//* RETURN VALUE:
//*     None.
//*********************************************************************************
void
ComposeSenderJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    PDOCEVENTUSERMEM  pDocEventUserMem,
    const COVERPAGEFIELDS *    pCPFields)
{

    #define FAXTAG_SERVER_COVERPAGE_IDX 9 
    #define FAXTAG_TSID_IDX             3 

    TCHAR lptstrRecipientCount[11];


    FAX_TAG_MAP_ENTRY tagMap[] =
    {
        { FAXTAG_NEW_RECORD,                FAXTAG_NEW_RECORD_VALUE},
        { FAXTAG_WHEN_TO_SEND,              NULL },
        { FAXTAG_SEND_AT_TIME,              NULL },
        { FAXTAG_TSID,                      pCPFields->SdrFaxNumber },
        { FAXTAG_BILLING_CODE,              pDocEventUserMem->devmode.dmPrivate.billingCode },
        { FAXTAG_RECEIPT_TYPE,              pDocEventUserMem->pReceiptFlags },
        { FAXTAG_RECEIPT_ADDR,              pDocEventUserMem->pReceiptAddress },
        { FAXTAG_PRIORITY,                  pDocEventUserMem->pPriority },
        { FAXTAG_COVERPAGE_NAME,            pDocEventUserMem->coverPage },
        { FAXTAG_SERVER_COVERPAGE,          NULL },
        { FAXTAG_PAGE_COUNT,                pCPFields->NumberOfPages},
        { FAXTAG_SENDER_NAME,               pCPFields->SdrName },
        { FAXTAG_SENDER_NUMBER,             pCPFields->SdrFaxNumber},
        { FAXTAG_SENDER_COMPANY,            pCPFields->SdrCompany },
        { FAXTAG_SENDER_TITLE,              pCPFields->SdrTitle },
        { FAXTAG_SENDER_DEPT,               pCPFields->SdrDepartment },
        { FAXTAG_SENDER_OFFICE_LOCATION ,   pCPFields->SdrOfficeLocation },
        { FAXTAG_SENDER_HOME_PHONE,         pCPFields->SdrHomePhone },
        { FAXTAG_SENDER_OFFICE_PHONE,       pCPFields->SdrOfficePhone },
        { FAXTAG_SENDER_STREET,             pDocEventUserMem->lpSenderInfo->lptstrStreetAddress },
        { FAXTAG_SENDER_CITY,               pDocEventUserMem->lpSenderInfo->lptstrCity },
        { FAXTAG_SENDER_STATE,              pDocEventUserMem->lpSenderInfo->lptstrState },
        { FAXTAG_SENDER_ZIP,                pDocEventUserMem->lpSenderInfo->lptstrZip },
        { FAXTAG_SENDER_COUNTRY,            pDocEventUserMem->lpSenderInfo->lptstrCountry },
        { FAXTAG_SENDER_EMAIL,              pDocEventUserMem->lpSenderInfo->lptstrEmail },
        { FAXTAG_NOTE,                      pDocEventUserMem->pNoteMessage },
        { FAXTAG_SUBJECT,                   pDocEventUserMem->pSubject},
        { FAXTAG_RECIPIENT_COUNT,           lptstrRecipientCount}
    };



    TCHAR   SendAtTime[16];
    DWORD  dwTagCount;


    if (pDocEventUserMem->bServerCoverPage)
    {
        tagMap[FAXTAG_SERVER_COVERPAGE_IDX].lptstrValue=TEXT("1");
    } else
    {
        tagMap[FAXTAG_SERVER_COVERPAGE_IDX].lptstrValue=NULL;
    }

    //
    // create the sendattime string
    //

    if (pDocEventUserMem->devmode.dmPrivate.whenToSend == JSA_DISCOUNT_PERIOD) {
        tagMap[1].lptstrValue=TEXT("cheap");
    }

    if (pDocEventUserMem->devmode.dmPrivate.whenToSend == JSA_SPECIFIC_TIME) {

        wsprintf( SendAtTime, TEXT("%02d:%02d"),
            pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour,
            pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute
            );

        tagMap[1].lptstrValue= TEXT("at");
        tagMap[2].lptstrValue= SendAtTime;
    }

    wsprintf( lptstrRecipientCount, TEXT("%10d"),pDocEventUserMem->dwNumberOfRecipients);
    //
    // Figure out the total length of the tagged string
    //
    dwTagCount=sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY);

    ParamTagsToString(tagMap, dwTagCount, lpParamBuf, lpdwParamSize );

}


//*****************************************************************************
//* Name:   WriteCoverPageToPrintJob
//* Author: Ronen Barenboim (Feb-99)
//*****************************************************************************
//* DESCRIPTION:
//*     Reads the content of the specified cover page template and writes it
//*     to the specified printer.
//*     The user should call StartDocPrinter() and StartPagePrinter()
//*     before calling this function.
//* PARAMETERS:
//*     [IN]    HANDLE hPrinter:
//*                 A handle to the printer to which the cover page template
//*                 should be written.
//*     [IN]    LPCTSTR lpctstrCoverPageFile:
//*                 The full path to the cover page file whose content is to be
//*                 written to the printer.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL WriteCoverPageToPrintJob(HANDLE hPrinter, LPCTSTR lpctstrCoverPageFile)
{
    #define BUF_SIZE 64*1024  // Buffer size for read operation
    CHAR chBuf[BUF_SIZE];     // Read operation buffer
    BOOL bRes;                // The result of the function
    HANDLE hCoverFile;        // Handle to the cover page file
    DWORD dwBytesRead;        // The number of bytes actually read at each cycle

    Assert(hPrinter);
    Assert(lpctstrCoverPageFile);

    bRes=FALSE;
    hCoverFile=INVALID_HANDLE_VALUE;

    //
    // Open the cover page template file for reading
    //
    hCoverFile=CreateFile(
            lpctstrCoverPageFile,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            0);
    if (INVALID_HANDLE_VALUE == hCoverFile )
    {
        goto Exit;
    }

    //
    //Read the file and write it into the print job
    //
    do {
        bRes=ReadFile(hCoverFile,&chBuf,sizeof(chBuf),&dwBytesRead,NULL) ;
        if (!bRes) {
            Error(("Failed to read cover page file into print job (cover page file: %s ec: %d\n)",
                lpctstrCoverPageFile,
                GetLastError())
             );
            break;

        } else {
            Verbose(("Success reading cover page file %s. %d bytes read.\n",lpctstrCoverPageFile,dwBytesRead));
        }

        if (dwBytesRead) {
            //
            // If dwBytesRead != 0 we are NOT at the enf of the file.
            //
            DWORD dwWritten;

            bRes=WritePrinter(hPrinter,(LPVOID)chBuf,dwBytesRead,&dwWritten);
            if (!bRes) {
                Error(("Failed to write to printer (ec = %d)", GetLastError()));
            } else
            {
                Verbose(("Success writing to printer. %d bytes written.\n",dwWritten));
            }
        }
    } while (dwBytesRead); // While not EOF

Exit:
    //
    //Close the cover page file
    //
    if (INVALID_HANDLE_VALUE!=hCoverFile)
    {
        if (!CloseHandle(hCoverFile))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
        }
    }
    return bRes;
}



//*****************************************************************************
//* Name:   DoCoverPageRendering
//* Author: Ronen Barenboim (Feb-99)
//*****************************************************************************
//* DESCRIPTION:
//*  Creates the cover page print job and attaches it to the body print job.
//*  The cover page job is created even when a cover page is NOT specified.
//*  It contains all the job parameters for the job as a tagged string
//*  placed in JOB_INFO_2.pParameters. This contains the information for the
//*  sender, cover page, job parameters and ALL recipients.
//*
//*  The content of the job is empty if no cover page is specified or
//*  The cover page is server based.
//*  For personal cover pages the content of the cover page template is written
//*  into the job as "RAW" data. The print monitor on the server will extract this
//*  data to reconstruct the cover page file on the server.
//*
//* PARAMETERS:
//*     [IN]    PDOCEVENTUSERMEM pDocEventUserMem:
//*                 A pointer to a USERMEM structure containing the context information
//*                 for the print job.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL
DoCoverPageRendering(
    PDOCEVENTUSERMEM    pDocEventUserMem
    )
{
    PCOVERPAGEFIELDS    pCPFields=NULL;
    DOC_INFO_1          docinfo;
    INT                 newJobId=0;
    INT                 lastJobId=0;
    INT                 cCoverPagesSent=0;
    PDMPRIVATE          pdmPrivate = &pDocEventUserMem->devmode.dmPrivate;
    HANDLE              hPrinter = pDocEventUserMem->hPrinter;
    DWORD               bodyJobId = pDocEventUserMem->jobId;
    LPTSTR              pBodyDocName=NULL;
    LPTSTR              pJobParam=NULL;
    BOOL                sendCoverPage;
    DWORD               pageCount;

    
    //
    // Fill out a DOCINFO structure which is passed to StartDoc
    //

    memset(&docinfo, 0, sizeof(docinfo));
    //docinfo.cbSize = sizeof(docinfo);
    
    
    //
    // Determine if we need a cover page or not
    //

    if ( (sendCoverPage = pdmPrivate->sendCoverPage) && IsEmptyString(pDocEventUserMem->coverPage)) {

        Warning(("Missing cover page file\n"));
        sendCoverPage = FALSE;
    }

    pageCount = pDocEventUserMem->pageCount;

    //
    // Collect cover page information into a newly allocated pCPFields. pCPFields will be
    // passed to ComposeFaxJobParameters() to provide the values for the job tags.
    //

    if ((pCPFields = CollectCoverPageFields(pDocEventUserMem->lpSenderInfo,pageCount)) == NULL) {

        Error(("Couldn't collect cover page information\n"));
        goto Exit;
    }

    

    pBodyDocName = GetJobName(hPrinter, bodyJobId);
    if (!pBodyDocName) {
        Error(("GetJobName failed (ec: %ld)", GetLastError()));
        Assert(FALSE);
        //
        // We continue inspite of the error. We can handle a NULL body doc name.
        //
    }

    //
    // We assume the fax body job has already been paused
    // Use a separate cover page for each recipient
    //

    newJobId = 0;
    docinfo.pDocName = NULL;
    pJobParam = NULL;
    //
    // Start a cover page job
    //

    //
    // The cover page job document name is "<BODY_NAME> - COVERPAGE"
    //

    docinfo.pOutputFile=NULL;
    docinfo.pDatatype=TEXT("RAW"); // Since we write the template into the job we want to bypass the driver.

    //
    // Create the tagged string of job parameters to be placed into JOB_INFO_2:pParameters.
    // The parameters include the parameters found at the FAX_JOB_PARAM client API structure.
    // pJobParam is ALLOCATED.
    //
    if (!ComposeFaxJobParameter(pDocEventUserMem, pCPFields,&pJobParam)) {
        Error(("ComposeFaxJobParameter failed. (ec: 0x%X)",GetLastError()));
        goto Error;
    }
    Assert(pJobParam); // Should be allocated now.

    docinfo.pDocName = ComposeFaxJobName(pDocEventUserMem,pBodyDocName);//pBodyDocName, TEXT("COVERPAGE"));

    if (!docinfo.pDocName) {
        Error(("ComposeFaxJobName failed. Body: %s (ec: %ld)",pBodyDocName,GetLastError()));
        //
        // we can do with no document name.
        //
    }


    if ((newJobId = StartDocPrinter(hPrinter,1, (LPBYTE)&docinfo)) !=0) {
        BOOL        rendered = FALSE;
        //
        // Pass fax job parameters using JOB_INFO_2.pParameters field.
        //

        //
        // Pause the new cover page job.
        //

        if (!SetJob(hPrinter, newJobId, 0, NULL, JOB_CONTROL_PAUSE)) {
             Error(("Failed to pause job id: %d (ec: %ld)",newJobId,GetLastError()));
             Assert(FALSE);
             goto Error;
        }

        if (!SetJobInfoAndTime(hPrinter,
                               newJobId,
                               pJobParam,
                               pdmPrivate)) {
            Error(("SetJobInfoAndTime failed. Job id : %d.",newJobId));
            Assert(FALSE);
            goto Error;
        }

        if (! sendCoverPage || pDocEventUserMem->bServerCoverPage) {
            //
            // If the user chose not to include cover page or a server side cover page was specified
            // the cover page job will be empty
            // Note that even if there is no cover page to send we still create a cover page print job
            // and link it to the body.
            // The cover print job is used to convery sender/recipient information. The fax print monitor will
            // use the job parameters string placed in JOB_INFO_2:pParameters to get this information at the server.
            //
            rendered = TRUE;

        } else {
            if (StartPagePrinter(hPrinter)) {
                //
                // Write the content of the cover page template into the print job.
                // The print monitor on the server will extract this information to get
                // the cover page template and render the cover page on the server.
                //
                rendered=WriteCoverPageToPrintJob(hPrinter,pDocEventUserMem->coverPage);

                if (!rendered) {
                    Error(("WriteCoverPageToPrintJob failed: %d\n", rendered ));
                    //
                    // Must call EndPagePrinter if error was encounterd or not.
                    //
                }

                if (!EndPagePrinter(hPrinter)) {
                    Error(("EndPagePrinter failed. (ec: %ld)",GetLastError()));
                    goto Error;
                }

                if (!rendered) {
                    goto Error;
                }


            } else {
                Error(("StartPagePrinter failed. (ec: %ld)",GetLastError()));
                rendered=FALSE;
                goto Error;
            }
        }


        //
        // Chain the cover page job to the fax body job if no error occured.
        //
        // Chain the cover page job to the BODY job.
        // The cover page job is the parent job. The body is the child job.
        // Note that multiple cover page
        // Jobs will be chained to the same BODY job.
        // also note the cover page jobs are not chained to each other. Just to the body.
        //

        if (rendered) {
            if (ChainFaxJobs(hPrinter, newJobId, bodyJobId)) {
                if (lastJobId != 0) {
                    if (!SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME)) {
                        Error(("Failed to resume job with id: %d",lastJobId));
                        Assert(FALSE);
                        goto Error;
                    }
                }
                lastJobId = newJobId;
                if (!EndDocPrinter(hPrinter)) {
                    Error(("EndPagePrinter failed. (ec: %ld)",GetLastError()));
                    Assert(FALSE);
                    goto Error;
                }
                cCoverPagesSent++;
            } else {
                Error(("ChainFaxJobs for CoverJobId=%d BodyJobId=%d has failed. Aborting job.",newJobId, bodyJobId));
                goto Error;
            }

        } else {
            Error(("Cover page template not written into job (rendered=FALSE). Aborting job."));
            goto Error;
        }
    } else {
        Error(("StartDocPrinter failed. (ec: %ld)",GetLastError()));
        goto Error;
    }
    goto Exit;


Error:
    Error(("Cover page job failed"));
    if (0!=newJobId) {
        //
        // This means that an error was detected after we created the job.
        // Note that if StartDocPrinter failed this code is not executed.
        //
        Error(("Aborting cover page job. JobId = %d",newJobId));
        if (!AbortPrinter(hPrinter)) {
            Error(("AbortPrinter failed (ec: %ld)",GetLastError()));
        }
    }


Exit:

    if (docinfo.pDocName) {
        MemFree((PVOID)docinfo.pDocName);
    }

    if (pJobParam) {
        MemFree((PVOID)pJobParam);
    }

    if (pBodyDocName) {
        MemFree(pBodyDocName);
    }
    if (pCPFields) {
        FreeCoverPageFields(pCPFields);
    }


    //
    // Resume the last cover page job if it's paused and
    // delete the fax body job if no cover page jobs were sent
    //

    if (lastJobId != 0) {

        if (!SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME)) {
            Error(("Failed to resume last job id : %d",lastJobId));
            Assert(FALSE);
        }

    }

    if (cCoverPagesSent > 0) {
        if (!SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_RESUME)) {
            Error(("Failed to resume body job with id: %d",bodyJobId));
            Assert(FALSE);
        }

    } else {
        Error(("No recipient jobs created. Fax job deleted due to an error.\n"));
        if (!SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_DELETE)) {
            Error(("Failed to delete body job with id: %d",bodyJobId));
            Assert(FALSE);
        }

    }

    return cCoverPagesSent > 0;
}
INT
DocEventEndDocPost(
    HDC                 hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem
    )

/*++

Routine Description:

    Handle ENDDOCPOST document event

Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    INT result = DOCUMENTEVENT_SUCCESS;

    switch (pDocEventUserMem->jobType) 
    {
        case JOBTYPE_NORMAL:

            Warning(("Number of pages printed: %d\n", pDocEventUserMem->pageCount));

            if (! pDocEventUserMem->directPrinting) 
            {
                LRESULT ec;
                ec = LaunchFaxWizard(pDocEventUserMem);
                if (ERROR_SUCCESS == ec)
                {
                    //
                    // Generate a cover page for each recipient and associate
                    // the cover page job with the main body.
                    // The job will contain the cover page template data and the
                    // recipient parameters.
                    if (! DoCoverPageRendering(pDocEventUserMem)) 
                    {
                        Error(("DoCoverPageRendering failed."));
                        result = DOCUMENTEVENT_FAILURE;
                    }
                }
                else
                {
                    result = DOCUMENTEVENT_FAILURE;
                }
                //
                // Free up the list of recipients
                //
                FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);
            }
            break;
    }

    if (DOCUMENTEVENT_SUCCESS != result)
    {
        //
        // Cancel the job ignoring errors
        //
        if (!SetJob(
                pDocEventUserMem->hPrinter,
                pDocEventUserMem->jobId,
                0,
                NULL,
                JOB_CONTROL_DELETE))
        {
            Error(("Failed to cancel job. JobId: %ld (ec: %ld)",
                    pDocEventUserMem->jobId,
                    GetLastError()));
        }
    }
    return result;
}


BOOL
AppendPreviewPage(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Append the next document page to the temporary preview file

Arguments:

    pDocEventUserMem

Return Value:

    TRUE on success

Note:

    If this routine is called for page 0, it just checks that the graphics driver hasn't
    cancled the print preview option and validates the mapping structures.

--*/

{
    DWORD dwWritten;

    // If we get here print preview should be enabled an all preview handles valid
    Assert(FALSE == pDocEventUserMem->bPreviewAborted);
    Assert(INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile);
    Assert(NULL != pDocEventUserMem->pPreviewTiffPage);

    //
    // Validate preview mapping
    //

    // The size of the header should be correct
    if (sizeof(MAP_TIFF_PAGE_HEADER) != pDocEventUserMem->pPreviewTiffPage->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pDocEventUserMem->bPreviewAborted = TRUE;
        return FALSE;
    }

    // Check if the preview operation hasn't beed cancled by the graphics driver
    if (FALSE == pDocEventUserMem->pPreviewTiffPage->bPreview)
    {
        Error(("Preview aborted by graphics driver\n"));
        pDocEventUserMem->bPreviewAborted = TRUE;
        return FALSE;
    }

    //
    // If we are called prior to the first sent page just return
    //
    if (!pDocEventUserMem->pageCount)
    {
        return TRUE;
    }

    //
    // Validate correct page number:
    //
    // The graphics driver increments the page count on the call to DrvStartPage(), while we
    // increment the page count on the ENDPAGE event.
    //
    // As this function is called by the STARTPAGE event handler (before 'DrvStartPage' is called
    // again in the graphics driver) or by the ENDDOCPOST event handler, the page number set by
    // the graphics driver in the mapping should be equal to our page count in this stage.
    //
    if (pDocEventUserMem->pageCount != pDocEventUserMem->pPreviewTiffPage->iPageCount)
    {
        Error(("Wrong preview page: %d. Page expected: %d.\n",
                    pDocEventUserMem->pPreviewTiffPage->iPageCount,
                    pDocEventUserMem->pageCount));
        pDocEventUserMem->bPreviewAborted = TRUE;
        pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
        return FALSE;
    }

    //
    // Append new page to temporary preview file
    //

    if (0 == pDocEventUserMem->pPreviewTiffPage->dwDataSize)
    {
        //
        // Nothing to add (?!). It is impossible to get an empty TIFF page
        //
        Error(("Recieved empty preview page: %d.\n", pDocEventUserMem->pageCount));
        Assert(FALSE);
        return TRUE;
    }

    if (!WriteFile(
        pDocEventUserMem->hPreviewFile,
        pDocEventUserMem->pPreviewTiffPage + 1,
        pDocEventUserMem->pPreviewTiffPage->dwDataSize,
        &dwWritten,
        NULL) || dwWritten != pDocEventUserMem->pPreviewTiffPage->dwDataSize)
    {
        Error(("Failed appending preview page: %d. Error: %d\n",
                    pDocEventUserMem->pageCount,
                    GetLastError()));
        pDocEventUserMem->bPreviewAborted = TRUE;
        pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
        return FALSE;
    }

    return TRUE;
}



INT
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    INT     iEsc,
    ULONG   cbIn,
    PULONG  pjIn,
    ULONG   cbOut,
    PULONG  pjOut
    )

/*++

Routine Description:

    Hook into GDI at various points during the output process

Arguments:

    hPrinter - Specifies the printer object
    hdc - Handle to the printer DC
    iEsc - Why this function is called (see notes below)
    cbIn - Size of the input buffer
    pjIn - Pointer to the input buffer
    cbOut - Size of the output buffer
    pjOut - Pointer to the output buffer

Return Value:

    DOCUMENTEVENT_SUCCESS - success
    DOCUMENTEVENT_UNSUPPORTED - iEsc is not supported
    DOCUMENTEVENT_FAILURE - an error occured

NOTE:

    DOCUMENTEVENT_CREATEDCPRE
        input - pointer to a CREATEDCDATA structure
        output - pointer to a devmode that's passed to DrvEnablePDEV
        return value -
            DOCUMENTEVENT_FAILURE causes CreateDC to fail and nothing else is called

    DOCUMENTEVENT_CREATEDCPOST
        hdc - NULL if if something failed since CREATEDCPRE
        input - pointer to the devmode pointer returned by CREATEDCPRE
        return value - ignored

    DOCUMENTEVENT_RESETDCPRE
        input - pointer to the input devmode passed to ResetDC
        output - pointer to a devmode that's passed to the kernel driver
        return value -
            DOCUMENTEVENT_FAILURE causes ResetDC to fail
            and CREATEDCPOST will not be called in that case

    DOCUMENTEVENT_RESETDCPOST
        return value - ignored

    DOCUMENTEVENT_STARTDOCPRE
        input - pointer to a DOCINFOW structure
        return value -
            DOCUMENTEVENT_FAILURE causes StartDoc to fail
            and DrvStartDoc will not be called in this case

    DOCUMENTEVENT_STARTDOCPOST
        return value - ignored

    DOCUMENTEVENT_STARTPAGE
        return value -
            DOCUMENTEVENT_FAILURE causes StartPage to fail
            and DrvStartPage will not be called in this case

    DOCUMENTEVENT_ENDPAGE
        return value - ignored and DrvEndPage always called

    DOCUMENTEVENT_ENDDOCPRE
        return value - ignored and DrvEndDoc always called

    DOCUMENTEVENT_ENDDOCPOST
        return value - ignored

    DOCUMENTEVENT_ABORTDOC
        return value - ignored

    DOCUMENTEVENT_DELETEDC
        return value - ignored

    DOCUMENTEVENT_ESCAPE
        input - pointer to a ESCAPEDATA structure
        cbOut, pjOut - cbOutput and lpszOutData parameters passed to ExtEscape
        return value - ignored

    DOCUMENTEVENT_SPOOLED
        This flag bit is ORed with other iEsc values if the document is
        spooled as metafile rather than printed directly to port.

--*/

{
    PDOCEVENTUSERMEM    pDocEventUserMem = NULL;
    PDEVMODE            pDevmode;
    INT                 result = DOCUMENTEVENT_SUCCESS;
    HANDLE              hMutex;

    Verbose(("Entering DrvDocumentEvent: %d...\n", iEsc));

    //
    // Metafile spooling on fax jobs is not currently supported
    //
    Assert((iEsc & DOCUMENTEVENT_SPOOLED) == 0);
    //
    // Check if the document event requires a device context
    //

    if (DocEventRequiresDC(iEsc)) 
    {
        if (!hdc || !(pDocEventUserMem = GetPDEVUserMem(hdc))) 
        {
            Error(("Invalid device context: hdc = %x, iEsc = %d\n", hdc, iEsc));
            return DOCUMENTEVENT_FAILURE;
        }
    }

    switch (iEsc) 
    {
        case DOCUMENTEVENT_CREATEDCPRE:

            Assert(cbIn >= sizeof(CREATEDCDATA) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
            result = DocEventCreateDCPre(hPrinter, hdc, (PCREATEDCDATA) pjIn, (PDEVMODE *) pjOut);
            break;

        case DOCUMENTEVENT_CREATEDCPOST:
            //
            // Handle CREATEDCPOST document event:
            //  If CreateDC succeeded, then associate the user mode memory structure
            //  with the device context. Otherwise, free the user mode memory structure.
            //
            Assert(cbIn >= sizeof(PVOID) && pjIn);
            pDevmode = *((PDEVMODE *) pjIn);
            Assert(CurrentVersionDevmode(pDevmode));

            pDocEventUserMem = ((PDRVDEVMODE) pDevmode)->dmPrivate.pUserMem;

            Assert(ValidPDEVUserMem(pDocEventUserMem));

            if (hdc) 
            {
                pDocEventUserMem->hdc = hdc;
                EnterDrvSem();
                pDocEventUserMem->pNext = gDocEventUserMemList;
                gDocEventUserMemList = pDocEventUserMem;
                LeaveDrvSem();

            } 
            else
            {
                FreePDEVUserMem(pDocEventUserMem);
            }
            break;

        case DOCUMENTEVENT_RESETDCPRE:

            Verbose(("Document event: RESETDCPRE\n"));
            Assert(cbIn >= sizeof(PVOID) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
            result = DocEventResetDCPre(hdc, pDocEventUserMem, *((PDEVMODE *) pjIn), (PDEVMODE *) pjOut);
            break;

        case DOCUMENTEVENT_STARTDOCPRE:
            //
            // normal case if we're bringing up the send wizard
            //
            //
            // When direct printing is requested we don't even call DocEventStartDocPre().
            // When direct printing is requested all the information required to print
            // the job will be provided by the application. For example FaxStartPrintJob()
            // uses direct printing. It provides the fax job parameters directly into
            // JOB_INFO_2.pParameters on its own.
            //

            if (!pDocEventUserMem->directPrinting)
            {
                Assert(cbIn >= sizeof(PVOID) && pjIn);
                //
                // Check if the printing application is using DDE and did not create new process for printing
                // If it so, the environment variable FAX_ENVVAR_PRINT_FILE was not found
                //
                hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, FAXXP_MEM_MUTEX_NAME);
                if (hMutex)
                {
                    if (WaitForSingleObject( hMutex, 1000 * 60 * 5) == WAIT_OBJECT_0)
                    {
                        HANDLE hSharedMem;
                        //
                        // we own the mutex...make sure we can open the shared memory region.
                        //
                        hSharedMem = OpenFileMapping(FILE_MAP_READ, FALSE, FAXXP_MEM_NAME);
                        if (NULL == hSharedMem)
                        {
                            Error(("OpenFileMapping failed error: %d\n", GetLastError()));
                            result = DOCUMENTEVENT_FAILURE;
                        }
                        else
                        {
                            //
                            // we own the mutex and we have the shared memory region open.
                            //

                            // check if we are printing to a file.
                            //
                            LPTSTR filename;

                            filename = (LPTSTR)MapViewOfFile(
                                                     hSharedMem,
                                                     FILE_MAP_READ,
                                                     0,
                                                     0,
                                                     0
                                                     );

                            if (!filename)
                            {
                                Error(("Failed to map a view of the file: %d\n", hSharedMem));
                                result = DOCUMENTEVENT_FAILURE;
                            }
                            else
                            {
                                //
                                // check if this is really the filename we want to print to.
                                //
                                LPDOCINFO   lpDocInfo = *((LPDOCINFO *)pjIn);
                                if (lpDocInfo->lpszDocName)
                                {
                                    LPTSTR      lptstrSubStr = NULL;
                                    LPTSTR lptstrTmpInputFile = _tcschr(filename, TEXT('\0'));
                                    Assert (lptstrTmpInputFile);
                                    lptstrTmpInputFile = _tcsinc(lptstrTmpInputFile);
                                    Assert (_tcsclen(lptstrTmpInputFile));

                                    lptstrSubStr = _tcsstr(lpDocInfo->lpszDocName, lptstrTmpInputFile);
                                    if (lptstrSubStr)
                                    {
                                        //
                                        // We assume the shared memory was pointed to us
                                        //
                                        pDocEventUserMem->pPrintFile = DuplicateString(filename);
                                        if (!pDocEventUserMem->pPrintFile)
                                        {
                                            Error(("Memory allocation failed\n"));
                                            result = DOCUMENTEVENT_FAILURE;
                                        }
                                        else
                                        {
                                            //
                                            // At last - every thing is OK, this is a direct printing from PrintRandomDocument
                                            // to a application that is using DDE and an instance was already open.
                                            //
                                            pDocEventUserMem->directPrinting = TRUE;
                                            pDocEventUserMem->bAttachment = TRUE;
                                        }
                                    }

                                }
                                else
                                {     
									//
									// To handle the race conditions between two diffrent instances of the printer driver over the shared memory created by PrintRandomDocument().
									// We are using now two mechanisms for detecting printing of an attachment using PrintRandomDocument().
									// 	First we check if an environment variable is set (Set by PrintRandomDocument()). If it is set the driver knows it is an attachment printing.
									// 	If it is not set, the driver looks for a mutex controlling a shred memory created by PrintRandomDocument(). If it does not exist it is a printing to the fax server.
									// 	If the shared memory exists, the driver compares the document name in the DOCINFO provided by StartDoc, and the input file name in the shared memory.
									// 	If there is a match, it is printing of an attachment, else it is a printing to the fax server
									// There is still a hole  in this implementation, if there is an open instance of the printing application, and the ShellExecuteEx does not create new process for printing, and the printing application does not set the lpszDocName in StartDoc to contain the input file name.
                                    Warning (("No lpszDocName in DOCINFO - Could not verify the input file name in shared memory\n"));
                                }
                                UnmapViewOfFile( filename );
                            }

                            if (!CloseHandle( hSharedMem ))
                            {
                                Error(("CloseHandle() failed: %d.\n", GetLastError()));
                                // Try to continue...
                            }
                        }
                        ReleaseMutex( hMutex );
                    }
                    else
                    {
                        //
                        //  Something went wrong with WaitForSingleObject
                        //
                        result = DOCUMENTEVENT_FAILURE;
                    }

                    if (!CloseHandle( hMutex ))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                }
            }

            //
            // Check again for direct printing
            //
            if (!pDocEventUserMem->directPrinting)
            {
                result = DocEventStartDocPre(hdc, pDocEventUserMem, *((LPDOCINFO *) pjIn));
            }
            else
            {
                //
                // we're doing direct printing -- check if this is an attachment
                //
                pDocEventUserMem->jobType = JOBTYPE_DIRECT;
                if (TRUE == pDocEventUserMem->bAttachment)
                {
                    (*((LPDOCINFO *) pjIn))->lpszOutput = pDocEventUserMem->pPrintFile;
                }
            }
            break;

        case DOCUMENTEVENT_STARTDOCPOST:

            if (!pDocEventUserMem->directPrinting && pDocEventUserMem->jobType == JOBTYPE_NORMAL)
            {
                //
                // Job ID is passed in from GDI
                //
                //
                // Save the job id returned from StartDoc. This is the job id of the body.
                // Pause the body job so we can attach cover page jobs to it before it starts
                // executing.
                //

                Assert(cbIn >= sizeof(DWORD) && pjIn);
                pDocEventUserMem->jobId = *((LPDWORD) pjIn);

                //
                // Tell spooler to pause the fax body job so that
                // we can associate cover pages with it later
                //

                if (! SetJob(pDocEventUserMem->hPrinter, pDocEventUserMem->jobId, 0, NULL, JOB_CONTROL_PAUSE))
                {
                    Error(("Couldn't pause fax body job: %d\n", pDocEventUserMem->jobId));
                    return DOCUMENTEVENT_FAILURE;
                }
            }
            break;

        case DOCUMENTEVENT_STARTPAGE:
            if (! pDocEventUserMem->directPrinting) 
            {
                //
                // Get PREVIOUS preview page (this event is called BEFORE the graphics dll recieved
                // the DrvSendPage() call for this page, so we actually get the previous page).
                //
                // NOTE: This event is recieved before the graphics dll recieves its DrvStartPage()
                // call where it increments the page count and resets the mapping surface. The first
                // time we get this event there is no actual page but we perform validity checking.
                //
                if (pDocEventUserMem->bShowPrintPreview && !pDocEventUserMem->bPreviewAborted)
                {
                    if (!AppendPreviewPage(pDocEventUserMem))
                    {
                        Error(("AppendPreviewPage() failed.\n"));
                        Assert(pDocEventUserMem->bPreviewAborted);
                        // We can continue with no print preview...
                    }
                }
            }
            break;

        case DOCUMENTEVENT_ENDPAGE:
            if (! pDocEventUserMem->directPrinting) 
            {
                pDocEventUserMem->pageCount++;
            }
            break;

        case DOCUMENTEVENT_ENDDOCPOST:
            if (!pDocEventUserMem->directPrinting)
            {
                //
                // Get the last preview page
                //
                if (pDocEventUserMem->bShowPrintPreview && !pDocEventUserMem->bPreviewAborted)
                {
                    if (!AppendPreviewPage(pDocEventUserMem))
                    {
                        Error(("AppendPreviewPage() failed.\n"));
                        Assert(pDocEventUserMem->bPreviewAborted);
                        // We can continue with no print preview...
                    }
                }
                //
                // Close the preview file
                //
                if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
                {
                    if (!CloseHandle(pDocEventUserMem->hPreviewFile))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                    pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
                }
                //
                // Call the handler
                //
                result = DocEventEndDocPost(hdc, pDocEventUserMem);
                //
                // If we created a preview file, delete it.
                //
                if (pDocEventUserMem->szPreviewFile[0] != TEXT('\0'))
                {
                    if (!DeleteFile(pDocEventUserMem->szPreviewFile))
                    {
                        Error(("DeleteFile() failed. Error code: %d.\n", GetLastError()));
                    }
                    pDocEventUserMem->szPreviewFile[0] = TEXT('\0');
                }
            }

            if (TRUE == pDocEventUserMem->bAttachment)
            {
                HANDLE              hEndDocEvent;
                LPTSTR szEndDocEventName= NULL;
                LPTSTR lptstrEventName = NULL;

                Assert (pDocEventUserMem->pPrintFile);
                //
                // Create the EndDoc event name
                //
                szEndDocEventName = (LPTSTR) MemAlloc( SizeOfString(pDocEventUserMem->pPrintFile) + SizeOfString(FAXXP_ATTACH_END_DOC_EVENT) );
            
                if (szEndDocEventName)
                {
                    _tcscpy (szEndDocEventName, pDocEventUserMem->pPrintFile);
                    _tcscat (szEndDocEventName, FAXXP_ATTACH_END_DOC_EVENT);

                    lptstrEventName = _tcsrchr(szEndDocEventName, TEXT('\\'));
                    Assert (lptstrEventName);
                    lptstrEventName = _tcsinc(lptstrEventName);
                    //
                    // Send event to the printing application (PrintRandomDocument() that file is ready)
                    //
                    hEndDocEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, lptstrEventName);
                    if (NULL == hEndDocEvent)
                    {
                        Error(("OpenEvent() failed. Error code: %d.\n", GetLastError()));
                        result = DOCUMENTEVENT_FAILURE;
                    }
                    else
                    {
                        if (!SetEvent( hEndDocEvent ))
                        {
                            Error(("SetEvent() failed. Error code: %d.\n", GetLastError()));
                            result = DOCUMENTEVENT_FAILURE;
                        }

                        if (!CloseHandle(hEndDocEvent))
                        {
                            Error(("CloseHandle() failed: %d.\n", GetLastError()));
                            // Try to continue...
                        }
                    }

                    MemFree(szEndDocEventName);
                }
                else
                {
                    Error(("Memory allocation for szEndDocEventName failed.\n"));
                    result = DOCUMENTEVENT_FAILURE;
                }

            }
            break;

        case DOCUMENTEVENT_DELETEDC:

            EnterDrvSem();

            if (pDocEventUserMem == gDocEventUserMemList)
            {
                gDocEventUserMemList = gDocEventUserMemList->pNext;
            }
            else 
            {
                PDOCEVENTUSERMEM p;

                if (p = gDocEventUserMemList) 
                {
                    while (p->pNext && p->pNext != pDocEventUserMem)
                    {
                        p = p->pNext;
                    }
                    if (p->pNext != NULL)
                    {
                        p->pNext = pDocEventUserMem->pNext;
                    }
                    else
                    {
                        Error(("Orphaned user mode memory structure!!!\n"));
                    }
                } 
                else
                {
                    Error(("gDocEventUserMemList shouldn't be NULL!!!\n"));
                }
            }
            LeaveDrvSem();
            FreePDEVUserMem(pDocEventUserMem);
            break;

        case DOCUMENTEVENT_ABORTDOC:
            if (TRUE == pDocEventUserMem->bAttachment)
            {
                //
                // Send event to the printing application (PrintRandomDocument() that printing was aborted)
                //
                HANDLE              hAbortEvent;
                TCHAR szAbortEventName[FAXXP_ATTACH_EVENT_NAME_LEN] = {0};
                LPTSTR lptstrEventName = NULL;

                Assert (pDocEventUserMem->pPrintFile);
                //
                // Create the Abort event name
                //
                _tcscpy (szAbortEventName, pDocEventUserMem->pPrintFile);
                _tcscat (szAbortEventName, FAXXP_ATTACH_ABORT_EVENT);
                lptstrEventName = _tcsrchr(szAbortEventName, TEXT('\\'));
                Assert (lptstrEventName);
                lptstrEventName = _tcsinc(lptstrEventName);

                hAbortEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, lptstrEventName);
                if (NULL == hAbortEvent)
                {
                    Error(("OpenEvent() failed. Error code: %d.\n", GetLastError()));
                    result = DOCUMENTEVENT_FAILURE;
                }
                else
                {
                    if (!SetEvent( hAbortEvent ))
                    {
                        Error(("SetEvent() failed. Error code: %d.\n", GetLastError()));
                        result = DOCUMENTEVENT_FAILURE;
                    }

                    if (!CloseHandle(hAbortEvent))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                }
            }
            break;

        case DOCUMENTEVENT_RESETDCPOST:
        case DOCUMENTEVENT_ENDDOCPRE:
            break;

        case DOCUMENTEVENT_ESCAPE:
        default:
            Verbose(("Unsupported DrvDocumentEvent escape: %d\n", iEsc));
            result = DOCUMENTEVENT_UNSUPPORTED;
            break;
    }
    return result;
}   // DrvDocumentEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\devprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devinfo.c

Abstract:

    Property sheet handler for "Device" page 

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"
#include "faxuiconstants.h"

//
// List of controls displayes for desktop SKUs only
//
DWORD 
g_dwDesktopControls[] =
{
    IDC_BRANDING_CHECK,         
    IDC_RETRIES_STATIC,         
    IDC_RETRIES_EDIT,           
    IDC_RETRIES_SPIN,           
    IDC_OUTB_RETRYDELAY_STATIC, 
    IDC_RETRYDELAY_EDIT,        
    IDC_RETRYDELAY_SPIN,           
    IDC_OUTB_MINUTES_STATIC,       
    IDC_OUTB_DIS_START_STATIC,     
    IDC_DISCOUNT_START_TIME,       
    IDC_OUTB_DIS_STOP_STATIC,      
    IDC_DISCOUNT_STOP_TIME,
    0
};

static BOOL
SaveSendChanges(IN HWND hDlg);

PPRINTER_NAMES      g_pPrinterNames = NULL;
DWORD               g_dwNumPrinters = 0;


BOOL
ValidateSend(
    HWND  hDlg
)
/*++

Routine Description:

    Validate the check box and controls for send

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL bEnabled;

    if(g_bUserCanChangeSettings) 
    {
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED;

        //
        // Enable/disable controls according to "Enable Send" check box
        //
        PageEnable(hDlg, bEnabled);

        if(!bEnabled)
        {
            //
            // Enable "Enable Send" check box
            //
            EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SEND),    TRUE);
            SetFocus(GetDlgItem(hDlg, IDC_DEVICE_PROP_SEND));

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SEND_ICON),    TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SEND_OPTIONS), TRUE);
            ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
            ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
        }
        else
        {
            ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_SHOW);
            ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_SHOW);
        }
    }
    else
    {
        PageEnable(hDlg, FALSE);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
    }

    return TRUE;
}

INT_PTR 
CALLBACK
DevSendDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for send settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL                fRet = FALSE;
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    DWORD               dwDeviceId;

    switch( message ) 
    {
        case WM_INITDIALOG:
        {
            SYSTEMTIME  sTime = {0};
            PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;
            TCHAR       tszSecondsFreeTimeFormat[MAX_PATH];
            //
            //Get the shared data from PROPSHEETPAGE lParam value
            //and load it into GWL_USERDATA
            //
            dwDeviceId = (DWORD)((LPPROPSHEETPAGE)lParam)->lParam; 

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)dwDeviceId);

            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_TSID, EM_SETLIMITTEXT, TSID_LIMIT, 0);

            pFaxPortInfo = FindPortInfo(dwDeviceId);
            if(!pFaxPortInfo)
            {
                Error(("FindPortInfo() failed.\n"));
                Assert(FALSE);
                fRet = TRUE;
                break;
            }

            CheckDlgButton(hDlg, IDC_DEVICE_PROP_SEND, pFaxPortInfo->bSend ? BST_CHECKED : BST_UNCHECKED);

            SetDlgItemText(hDlg, IDC_DEVICE_PROP_TSID, pFaxPortInfo->lptstrTsid);

            if(!IsDesktopSKU())
            {
                //
                // Hide desktop controls for non desktop platform
                //
                DWORD dw;
                for(dw=0; g_dwDesktopControls[dw] != 0; ++dw)
                {
                    ShowWindow(GetDlgItem(hDlg, g_dwDesktopControls[dw]), SW_HIDE);
                }
                goto InitDlgExit;
            }
            
            //
            // Update desktop controls
            //
            if(!Connect(hDlg, TRUE))
            {
                goto InitDlgExit;
            }

            if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
            {
                Error(( "FaxGetOutboxConfiguration() failed with %d.\n", GetLastError()));
                goto InitDlgExit;
            }

            //
            // Branding
            //            
            CheckDlgButton(hDlg, IDC_BRANDING_CHECK, pOutboxConfig->bBranding ? BST_CHECKED : BST_UNCHECKED);
            //
            // Retries
            //
            SendDlgItemMessage(hDlg, IDC_RETRIES_EDIT, EM_SETLIMITTEXT, FXS_RETRIES_LENGTH, 0);

#if FXS_RETRIES_LOWER > 0
            if (pOutboxConfig->dwRetries < FXS_RETRIES_LOWER)
            {
                pOutboxConfig->dwRetries = FXS_RETRIES_LOWER;
            }
#endif
            if (pOutboxConfig->dwRetries > FXS_RETRIES_UPPER)
            {
                pOutboxConfig->dwRetries = FXS_RETRIES_UPPER;
            }
            SendDlgItemMessage(hDlg, IDC_RETRIES_SPIN, UDM_SETRANGE32, FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
            SendDlgItemMessage(hDlg, IDC_RETRIES_SPIN, UDM_SETPOS32, 0, (LPARAM)pOutboxConfig->dwRetries);

            SetDlgItemInt(hDlg, IDC_RETRIES_EDIT, pOutboxConfig->dwRetries, FALSE);
            //
            // Retry Delay
            //
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_EDIT, EM_SETLIMITTEXT, FXS_RETRYDELAY_LENGTH, 0);

#if FXS_RETRYDELAY_LOWER > 0
            if (pOutboxConfig->dwRetryDelay < FXS_RETRYDELAY_LOWER)
            {
                pOutboxConfig->dwRetryDelay = FXS_RETRYDELAY_LOWER;
            }
#endif
            if (pOutboxConfig->dwRetryDelay > FXS_RETRYDELAY_UPPER)
            {
                pOutboxConfig->dwRetryDelay = FXS_RETRYDELAY_UPPER;
            }
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_SPIN, UDM_SETRANGE32, FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_SPIN, UDM_SETPOS32, 0, (LPARAM)pOutboxConfig->dwRetryDelay);

            SetDlgItemInt(hDlg, IDC_RETRYDELAY_EDIT, pOutboxConfig->dwRetryDelay, FALSE);

            //
            // Discount rate start time
            //
            GetSecondsFreeTimeFormat(tszSecondsFreeTimeFormat, MAX_PATH);

            GetLocalTime(&sTime);

            sTime.wHour   = pOutboxConfig->dtDiscountStart.Hour;
            sTime.wMinute = pOutboxConfig->dtDiscountStart.Minute;

            SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_SETFORMAT, 0, (LPARAM)tszSecondsFreeTimeFormat);
            SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&sTime);

            //
            // Discount rate stop time
            //
            sTime.wHour   = pOutboxConfig->dtDiscountEnd.Hour;
            sTime.wMinute = pOutboxConfig->dtDiscountEnd.Minute;

            SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_SETFORMAT, 0, (LPARAM)tszSecondsFreeTimeFormat);
            SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&sTime);

            FaxFreeBuffer(pOutboxConfig);

InitDlgExit:
            ValidateSend(hDlg);
            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
            {
                // activate apply button        

                WORD wID = LOWORD( wParam );

                switch( wID ) 
                {
                    case IDC_DEVICE_PROP_TSID:
                    case IDC_RETRIES_EDIT:
                    case IDC_RETRYDELAY_EDIT:
                    case IDC_DISCOUNT_START_TIME:
                    case IDC_DISCOUNT_STOP_TIME:
                        if( HIWORD(wParam) == EN_CHANGE ) 
                        {     // notification code 
                            Notify_Change(hDlg);
                        }

                        fRet = TRUE;
                        break;                    

                    case IDC_DEVICE_PROP_SEND:                    

                        if ( HIWORD(wParam) == BN_CLICKED ) 
                        {   
                            if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED)
                            {
                                dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                                if(!IsDeviceInUse(dwDeviceId) &&
                                   GetDeviceLimit() == CountUsedFaxDevices())
                                {
                                    CheckDlgButton(hDlg, IDC_DEVICE_PROP_SEND, BST_UNCHECKED);

                                    DisplayErrorMessage(hDlg, 
                                        MB_OK | MB_ICONSTOP,
                                        FAXUI_ERROR_DEVICE_LIMIT,
                                        GetDeviceLimit());
                                    fRet = TRUE;
                                    break;
                                }
                            }

                            // notification code
                            ValidateSend(hDlg);
                            Notify_Change(hDlg);
                        }
                        
                        fRet = TRUE;
                        break;

                    default:
                        break;
                } // switch

                break;
            }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                    SaveSendChanges(hDlg);
                    fRet = TRUE;
                    break;

                case DTN_DATETIMECHANGE:    // Date/time picker has changed
                    Notify_Change(hDlg);
                    fRet = TRUE;
                    break;

                default:
                    break;
            }
            break;
        }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    } // switch

    return fRet;
}

BOOL
ValidateReceive(
    HWND   hDlg
)
/*++

Routine Description:

    Validate the check box and controls for receive

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL    bEnabled; // enable/disable controls
    BOOL    bManualAnswer;
    BOOL    bVirtual;   // Is the device virtual?

    // if g_bUserCanChangeSettings is FALSE, controls are disabled by default.
    if(g_bUserCanChangeSettings) 
    {
        DWORD dwDeviceId;
        DWORD dwRes;

        dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        Assert (dwDeviceId);

        if(!Connect(hDlg, TRUE))
        {
            return FALSE;
        }

        dwRes = IsDeviceVirtual (g_hFaxSvcHandle, dwDeviceId, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            return FALSE;
        }
        DisConnect ();
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED;

        if(bEnabled && 
           IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER)   != BST_CHECKED &&
           IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER) != BST_CHECKED)
        {
            //
            // Set default to auto answer
            //
            CheckDlgButton(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER, BST_CHECKED);
        }

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_CSID),          bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER), bEnabled && !bVirtual);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER),   bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS1),             bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID1),      bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),       bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_ANSWER_MODE), bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_ROUTE),      bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_AUTO_ANSWER), bEnabled);

        bManualAnswer = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER);
        Assert (!(bVirtual && bManualAnswer));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_RINGS),      bEnabled && !bManualAnswer && !bVirtual);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS), bEnabled && !bManualAnswer && !bVirtual);
        if (bVirtual)
        {
            //
            // Virtual devices always answer after one ring
            //
            SetDlgItemInt (hDlg, IDC_DEVICE_PROP_RINGS, 1, FALSE);
        }

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT),    bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO), bEnabled
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_PRINT));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SAVE),        bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER), bEnabled 
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SAVE));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR), bEnabled
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SAVE));

        EnableWindow(GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER),   bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), bEnabled);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), bEnabled ? SW_SHOW : SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), bEnabled ? SW_SHOW : SW_HIDE);
    }
    else
    {
        PageEnable(hDlg, FALSE);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
    }

    return TRUE;
}

BOOL
InitReceiveInfo(
    HWND    hDlg
    )
/*++

Routine Description:

    Initialize the routing information for specific device

Arguments:

    hDlg - the dialog handle of the dialog

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    DWORD               dwDeviceId;
    HWND                hControl;
    PFAX_PORT_INFO_EX   pFaxPortInfo;
    LPBYTE              pRoutingInfoBuffer;
    DWORD               dwRoutingInfoBufferSize;
    DWORD               dwCurrentRM;
    BOOL                bSuccessed = TRUE;

    Verbose(("Entering InitReceiveInfo...\n"));

    //
    // Get device id from dialog page
    //

    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    pFaxPortInfo = FindPortInfo(dwDeviceId);
    if(!pFaxPortInfo)
    {
        Error(("FindPortInfo() failed.\n"));
        Assert(FALSE);
        return FALSE;
    }

    // set up the check box
    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_RECEIVE), g_bUserCanChangeSettings);

    CheckDlgButton(hDlg, IDC_DEVICE_PROP_RECEIVE, pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF);

    // set up the CSID control
    SetDlgItemText(hDlg, IDC_DEVICE_PROP_CSID, pFaxPortInfo->lptstrCsid);

    // setup the ring count spinner control
    hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS); 

    if(MIN_RING_COUNT <= pFaxPortInfo->dwRings && pFaxPortInfo->dwRings <= MAX_RING_COUNT)
    {
        SetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, pFaxPortInfo->dwRings, FALSE);
        SendMessage( hControl, UDM_SETPOS32, 0, (LPARAM) MAKELONG(pFaxPortInfo->dwRings, 0) );        
    }
    else
    {
        SetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, DEFAULT_RING_COUNT, FALSE);
        SendMessage( hControl, UDM_SETPOS32, 0, (LPARAM) MAKELONG(DEFAULT_RING_COUNT, 0) );        
    }

    //
    // Answer mode
    //
    if (FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxPortInfo->ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER, TRUE);
    }
    else if (FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER, TRUE);
    }

    //
    // Get the routing info
    //
    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }

    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        BOOL Enabled;

        Enabled = FaxDeviceEnableRoutingMethod( g_hFaxSvcHandle, 
                                                dwDeviceId, 
                                                RoutingGuids[dwCurrentRM], 
                                                QUERY_STATUS );
        //
        // Show routing extension data 
        //
        pRoutingInfoBuffer = NULL;
        if(!FaxGetExtensionData(g_hFaxSvcHandle, 
                                dwDeviceId, 
                                RoutingGuids[dwCurrentRM], 
                                &pRoutingInfoBuffer, 
                                &dwRoutingInfoBufferSize))
        {
            Error(("FaxGetExtensionData failed with %ld.\n", GetLastError()));
            pRoutingInfoBuffer = NULL;
        }

        switch (dwCurrentRM) 
        {
            case RM_FOLDER:

                CheckDlgButton( hDlg, IDC_DEVICE_PROP_SAVE, Enabled ? BST_CHECKED : BST_UNCHECKED );

                // enable controls if the user has "modify" permission
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER ), Enabled );
                    EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR ), Enabled );
                }
                if (pRoutingInfoBuffer && *pRoutingInfoBuffer)
                {
                    SetDlgItemText( hDlg, IDC_DEVICE_PROP_DEST_FOLDER, (LPCTSTR)pRoutingInfoBuffer );
                }
                break;

            case RM_PRINT:

                hControl = GetDlgItem( hDlg, IDC_DEVICE_PROP_PRINT_TO );

                //
                // Now find out if we match the data the server has
                //
                if (pRoutingInfoBuffer && lstrlen((LPWSTR)pRoutingInfoBuffer))
                {
                    //
                    // Server has some name for printer
                    //
                    LPCWSTR lpcwstrMatchingText = FindPrinterNameFromPath (g_pPrinterNames, g_dwNumPrinters, (LPWSTR)pRoutingInfoBuffer);
                    if (!lpcwstrMatchingText)
                    {
                        //
                        // No match, just fill in the text we got from the server
                        //
                        SendMessage(hControl, CB_SETCURSEL, -1, 0);
                        SetWindowText(hControl, (LPWSTR)pRoutingInfoBuffer);
                    }
                    else
                    {
                        SendMessage(hControl, CB_SELECTSTRING, -1, (LPARAM) lpcwstrMatchingText);
                    }
                }
                else
                {
                    //
                    // No server configuation - Select nothing
                    //
                }

                CheckDlgButton( hDlg, IDC_DEVICE_PROP_PRINT, Enabled ? BST_CHECKED : BST_UNCHECKED );                
                //
                // Enable controls if the user has "modify" permission
                //
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT), TRUE);
                    EnableWindow(hControl, Enabled);
                }
                break;
        }
        if (pRoutingInfoBuffer)
        {
            FaxFreeBuffer(pRoutingInfoBuffer);
        }
    }

    DisConnect();

    return bSuccessed;
}

BOOL
SaveReceiveInfo(
    HWND    hDlg
)

/*++

Routine Description:

    Save the receive routing info to the system

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    DWORD               dwDeviceId;
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;
    DWORD               dwCurrentRM;
    BOOL                bSuccessed = TRUE;
    HWND                hControl;
    TCHAR               szCsid[CSID_LIMIT + 1] = {0};
    BYTE                pRouteInfo[RM_COUNT][INFO_SIZE] = {0};
    LPTSTR              lpCurSel; 
    LPDWORD             Enabled; 
    DWORD               dwRingCount = 0; // default value is an invalid value
    DWORD               dwRes = 0;

    Verbose(("Entering SaveReceiveInfo...\n"));

    // 
    // check the validity of ring count
    //
    dwRingCount = GetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, &bSuccessed, FALSE);
    if( dwRingCount < MIN_RING_COUNT || dwRingCount > MAX_RING_COUNT )
    {
        hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_RINGS);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RING_COUNT, MIN_RING_COUNT, MAX_RING_COUNT);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bSuccessed = FALSE;
        goto Exit;
    }

    // 
    // Check the validity first in the loop, 
    // then save the routing info
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        // initialize
        lpCurSel = (LPTSTR)(pRouteInfo[dwCurrentRM] + sizeof(DWORD));
        Enabled = (LPDWORD) pRouteInfo[dwCurrentRM];
        *Enabled = 0;

        switch (dwCurrentRM) 
        {
            case RM_PRINT:

                *Enabled = (IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_PRINT ) == BST_CHECKED);
                lpCurSel[0] = TEXT('\0');
                //
                // Just read-in the selected printer display name
                //
                GetDlgItemText (hDlg, IDC_DEVICE_PROP_PRINT_TO, lpCurSel, MAX_PATH);
                hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO);
                //
                // we will check the validity only when this routing method is enabled
                // but we will save the select change anyway.
                //
                if (*Enabled) 
                {
                    if (lpCurSel[0] == 0) 
                    {
                        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_SELECT_PRINTER);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        bSuccessed = FALSE;
                        goto Exit;
                    }
                }
                break;

            case RM_FOLDER:

                *Enabled = (IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) == BST_CHECKED);
                hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER);

                //
                // we will check the validity only when this routing method is enabled
                // but we will save the text change anyway.
                //
                GetWindowText( hControl, lpCurSel, MAX_PATH - 1 );

                if (*Enabled) 
                {
                    if(PathIsRelative (lpCurSel) || !DirectoryExists(lpCurSel))
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        bSuccessed = FALSE;
                        goto Exit;
                    }
                }
        }
    }
    // 
    // Now save the device and routing info
    // Get device id from dialog page
    //
    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    // 
    // Save routing methods info
    //
    if(!Connect(hDlg, TRUE))
    {
        bSuccessed = FALSE;
        goto Exit;
    }

    if(!FaxGetPortEx(g_hFaxSvcHandle, dwDeviceId, &pFaxPortInfo))
    {
        bSuccessed = FALSE;
        dwRes = GetLastError();
        Error(("Can't save routing information.\n"));
        goto Exit;
    }
    //
    // Save receive settings
    //
    if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED)
    {
        //
        // Collect and verify TSID
        //
        GetDlgItemText(hDlg, IDC_DEVICE_PROP_CSID, szCsid, CSID_LIMIT + 1);
        pFaxPortInfo->lptstrCsid = szCsid;
        if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER) == BST_CHECKED)
        {
            pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            //
            // save ring count info
            //
            pFaxPortInfo->dwRings = dwRingCount;
        }
        else if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER) == BST_CHECKED)
        {
            //
            // Turn off manual-answer for ALL devices.
            //
            DWORD dw;
            for (dw = 0; dw < g_dwPortsNum; dw++)
            {
                if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                {
                    g_pFaxPortInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                }
            }
            //
            // Turn on manual-answer for selected device only.
            //
            pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        }
    }
    else
    {
        pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
    }
    
    if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
    {
        bSuccessed = FALSE;
        dwRes = GetLastError();
        Error(( "Set port information error in DoSaveDeviceList(), ec = %d.\n", dwRes));
        goto Exit;
    }
    //
    // save routing methods
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        lpCurSel = (LPTSTR)(pRouteInfo[dwCurrentRM] + sizeof(DWORD));
        Enabled  = (LPDWORD)pRouteInfo[dwCurrentRM];

        if ((RM_PRINT == dwCurrentRM) && *Enabled)
        {
            //
            // Attempt to convert printer display name to printer path before we pass it on to the server
            //
            LPCWSTR lpcwstrPrinterPath = FindPrinterPathFromName (g_pPrinterNames, g_dwNumPrinters, lpCurSel);
            if (lpcwstrPrinterPath)
            {
                //
                // We have a matching path - replace name with path.
                //
                lstrcpyn (lpCurSel, lpcwstrPrinterPath, MAX_PATH);
            }
        }

        if(!FaxSetExtensionData(g_hFaxSvcHandle, 
            dwDeviceId, 
            RoutingGuids[dwCurrentRM], 
            (LPBYTE)lpCurSel, 
            sizeof(TCHAR) * MAX_PATH))
        {
            bSuccessed = FALSE;
            dwRes = GetLastError();
            Error(("FaxSetExtensionData() failed with %d.\n", dwRes));
            goto Exit;
        }

        if(!FaxDeviceEnableRoutingMethod(g_hFaxSvcHandle, 
            dwDeviceId, 
            RoutingGuids[dwCurrentRM], 
            *Enabled ? STATUS_ENABLE : STATUS_DISABLE ))
        {
            bSuccessed = FALSE;
            dwRes = GetLastError();
            Error(("FaxDeviceEnableRoutingMethod() failed with %d.\n", dwRes));
            goto Exit;
        }
    }

    bSuccessed = TRUE;

Exit:
    FaxFreeBuffer(pFaxPortInfo);
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            break;
    }
    return bSuccessed;
}

INT_PTR 
CALLBACK 
DevRecvDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for the receive settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL    fRet = FALSE;
    HWND    hControl;
    DWORD   dwDeviceId;

    switch( message ) 
    {
        case WM_DESTROY:
            if (g_pPrinterNames)
            {
                ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
                g_pPrinterNames = NULL;
            }
            break;

        case WM_INITDIALOG:
        {
            //
            //Get the shared data from PROPSHEETPAGE lParam value
            //and load it into GWL_USERDATA
            //
            dwDeviceId = (DWORD)((LPPROPSHEETPAGE)lParam)->lParam; 
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)dwDeviceId);

            //
            // Initialize the list of destination printers
            //
            hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO);

            SetLTRComboBox(hDlg, IDC_DEVICE_PROP_PRINT_TO);

            if (g_pPrinterNames)
            {
                ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
                g_pPrinterNames = NULL;
            }
            g_pPrinterNames = CollectPrinterNames (&g_dwNumPrinters, TRUE);
            if (!g_pPrinterNames)
            {
                if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
                {
                    //
                    // No printers
                    //
                }
                else
                {
                    //
                    // Real error
                    //
                }
            }
            else
            {
                //
                // Success - fill in the combo-box
                //
                DWORD dw;
                for (dw = 0; dw < g_dwNumPrinters; dw++)
                {
                    SendMessage(hControl, CB_ADDSTRING, 0, (LPARAM) g_pPrinterNames[dw].lpcwstrDisplayName);
                }
            }        
            //
            // We only allow two-digit phone ring answer
            //
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_RINGS, EM_SETLIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_CSID, EM_SETLIMITTEXT, CSID_LIMIT, 0);
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_DEST_FOLDER, EM_SETLIMITTEXT, MAX_ARCHIVE_DIR - 1, 0);
            //
            // Initiate the spin control. 
            //
            SendMessage( GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS), 
                         UDM_SETRANGE32, MIN_RING_COUNT, MAX_RING_COUNT );

            SetLTREditDirection(hDlg, IDC_DEVICE_PROP_DEST_FOLDER);
            SHAutoComplete (GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER), SHACF_FILESYSTEM);

            InitReceiveInfo(hDlg);
            ValidateReceive(hDlg);
            return TRUE;
        }

        case WM_COMMAND:
        {
            // activate apply button        

            WORD wID = LOWORD( wParam );

            switch( wID ) 
            {
                case IDC_DEVICE_PROP_RECEIVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {
                        if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED)
                        {
                            dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                            if(!IsDeviceInUse(dwDeviceId) &&
                               GetDeviceLimit() <= CountUsedFaxDevices())
                            {
                                CheckDlgButton(hDlg, IDC_DEVICE_PROP_RECEIVE, BST_UNCHECKED);

                                DisplayErrorMessage(hDlg, 
                                    MB_OK | MB_ICONSTOP,
                                    FAXUI_ERROR_DEVICE_LIMIT,
                                    GetDeviceLimit());
                                fRet = TRUE;
                                break;
                            }
                        }

                        ValidateReceive(hDlg);
                        Notify_Change(hDlg);
                    }
                    break;

                case IDC_DEVICE_PROP_CSID:
                case IDC_DEVICE_PROP_DEST_FOLDER:
                    if( HIWORD(wParam) == EN_CHANGE ) // notification code
                    {      
                        Notify_Change(hDlg);
                    }

                    if (IDC_DEVICE_PROP_DEST_FOLDER == wID && HIWORD(wParam) == EN_KILLFOCUS) 
                    {
                        TCHAR szFolder[MAX_PATH * 2];
                        TCHAR szResult[MAX_PATH * 2];
                        //
                        // Edit control lost its focus
                        //
                        GetDlgItemText (hDlg, wID, szFolder, ARR_SIZE(szFolder));
                        if (lstrlen (szFolder))
                        {
                            if (GetFullPathName(szFolder, ARR_SIZE(szResult), szResult, NULL))
                            {
                                PathMakePretty (szResult);
                                SetDlgItemText (hDlg, wID, szResult);
                            }
                        }
                    }
                    break;                    

                case IDC_DEVICE_PROP_MANUAL_ANSWER:
                case IDC_DEVICE_PROP_AUTO_ANSWER:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {
                        BOOL bEnabled = IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_AUTO_ANSWER );

                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_RINGS ),      bEnabled );
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_SPIN_RINGS ), bEnabled );

                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_PRINT:

                    if ( HIWORD(wParam) == BN_CLICKED )  // notification code
                    {
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_PRINT_TO ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_PRINT ) );
                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_SAVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {     
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) );
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) );

                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_DEST_FOLDER_BR:
                {
                    TCHAR   szTitle[MAX_TITLE_LEN];

                    if(!LoadString(ghInstance, IDS_BROWSE_FOLDER, szTitle, MAX_TITLE_LEN))
                    {
                        lstrcpy(szTitle, TEXT("Select a folder"));
                    }

                    if(BrowseForDirectory(hDlg, IDC_DEVICE_PROP_DEST_FOLDER, szTitle))
                    {
                        Notify_Change(hDlg);
                    }   

                    break;
                }

                case IDC_DEVICE_PROP_PRINT_TO:

                    if ((HIWORD(wParam) == CBN_SELCHANGE) || // notification code
                        (HIWORD(wParam) == CBN_EDITCHANGE))
                    {      
                        Notify_Change(hDlg);
                    }
                    break;

                default:
                    break;
            } // switch

            fRet = TRUE;
            break;
        }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                {
                    // if the user only has read permission, return immediately
                    if(!g_bUserCanChangeSettings)
                    {
                        return TRUE;
                    }

                    if(!SaveReceiveInfo(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                    else
                    {
                        Notify_UnChange(hDlg);
                        g_bPortInfoChanged = TRUE;
                    }

                    return TRUE;
                }

            } // switch

            break;
        }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    } // switch

    return fRet;
}   // DevRecvDlgProc


BOOL
InitCleanupInfo(
    HWND hDlg
)
/*++

Routine Description:

    Initialize the auto-cleanup information for a specific device

Arguments:

    hDlg - the dialog handle of the dialog

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    Verbose(("Entering InitCleanupInfo...\n"));
    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }

    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", GetLastError()));
        return FALSE;
    }

    if (pOutboxConfig->dwAgeLimit)
    {
        if (pOutboxConfig->dwAgeLimit < FXS_DIRTYDAYS_LOWER)
        {
            pOutboxConfig->dwAgeLimit = FXS_DIRTYDAYS_LOWER;
        }
        if (pOutboxConfig->dwAgeLimit > FXS_DIRTYDAYS_UPPER)
        {
            pOutboxConfig->dwAgeLimit = FXS_DIRTYDAYS_UPPER;
        }
        //
        // Age limit is active
        //
        CheckDlgButton(hDlg, IDC_DELETE_CHECK, BST_CHECKED);
        SetDlgItemInt (hDlg, IDC_DAYS_EDIT, pOutboxConfig->dwAgeLimit, FALSE);
    }
    else
    {
        //
        // Age limit is inactive
        //
        CheckDlgButton(hDlg, IDC_DELETE_CHECK, BST_UNCHECKED);
        SetDlgItemInt (hDlg, IDC_DAYS_EDIT, FXS_DIRTYDAYS_LOWER, FALSE);
    }
    DisConnect();
    return TRUE;
}   // InitCleanupInfo

BOOL
ValidateCleanup(
    HWND  hDlg
)
/*++

Routine Description:

    Validate the check box and controls for cleanup

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL bEnabled;

    if(g_bUserCanChangeSettings) 
    {
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DELETE_CHECK) == BST_CHECKED;
    }
    else
    {
        bEnabled = FALSE;
        EnableWindow (GetDlgItem(hDlg, IDC_DELETE_CHECK), bEnabled);
        EnableWindow (GetDlgItem(hDlg, IDC_STATIC_CLEANUP_ICON), bEnabled);
        EnableWindow (GetDlgItem(hDlg, IDC_STATIC_CLEANUP_OPTIONS), bEnabled);
    }        
    //
    // Enable/disable controls according to "Enable Send" check box
    //
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_EDIT), bEnabled);
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_SPIN), bEnabled);
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_STATIC), bEnabled);
    return TRUE;
}   // ValidateCleanup

BOOL
SaveCleanupInfo(
    IN HWND hDlg)
/*++

Routine name : SaveCleanupInfo

Routine description:

    Process Apply Button

Author:

    Eran Yraiv (EranY), April, 2001

Arguments:

    hDlg                          [IN]    - Handle to the Window

Return Value:

    TRUE if Apply is succeeded, FALSE otherwise.

--*/
{
    DWORD   dwRes = 0;
    BOOL    bErrorDisplayed = FALSE;

    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    //
    //  if the user only has read permission, return immediately
    //
    if(!g_bUserCanChangeSettings)
    {
        return TRUE;
    }

    if(!Connect(hDlg, TRUE))
    {
        //
        //  Failed to connect to the Fax Service. Connect() showed the Error Message.
        //
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        return FALSE;
    }

    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", dwRes));
        return FALSE;
    }
    Assert(pOutboxConfig);
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELETE_CHECK))
    {
        BOOL bRes;
        int iAgeLimit = GetDlgItemInt (hDlg, IDC_DAYS_EDIT, &bRes, FALSE);

        if (!bRes || (iAgeLimit > FXS_DIRTYDAYS_UPPER) || (iAgeLimit < FXS_DIRTYDAYS_LOWER))
        {
            //
            // Bad data or out of range
            //
            HWND hControl = GetDlgItem(hDlg, IDC_DAYS_EDIT);
            dwRes = ERROR_INVALID_DATA;
            SetLastError (ERROR_INVALID_DATA);
            DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_DIRTY_DAYS, FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
            SendMessage(hControl, EM_SETSEL, 0, -1);
            SetFocus(hControl);
            SetActiveWindow(hControl);
            bErrorDisplayed = TRUE;
            goto ClearData;
        }
        pOutboxConfig->dwAgeLimit = iAgeLimit;
    }
    else
    {
        //
        // Age limit is disabled
        //
        pOutboxConfig->dwAgeLimit = 0;
    }
    if(!FaxSetOutboxConfiguration(g_hFaxSvcHandle, pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(("FaxSetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

ClearData:
    FaxFreeBuffer(pOutboxConfig);
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;
    }
    return (dwRes == 0);
}   // SaveCleanupInfo

INT_PTR 
CALLBACK 
DevCleanupDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for the cleanup settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL    fRet = FALSE;

    switch( message ) 
    {
        case WM_INITDIALOG:
            //
            // we only allow two-digit days
            //
            SendDlgItemMessage(hDlg, 
                               IDC_DAYS_EDIT, 
                               EM_SETLIMITTEXT, 
                               FXS_DIRTYDAYS_LENGTH, 
                               0);
            //
            // Initiate the spin control. 
            //
            SendDlgItemMessage(hDlg, 
                               IDC_DAYS_SPIN,
                               UDM_SETRANGE32, 
                               FXS_DIRTYDAYS_LOWER, 
                               FXS_DIRTYDAYS_UPPER);

            InitCleanupInfo(hDlg);
            ValidateCleanup(hDlg);
            return TRUE;

        case WM_COMMAND:
        {
            WORD wID = LOWORD( wParam );
            switch( wID ) 
            {
                case IDC_DELETE_CHECK:

                    if (BN_CLICKED == HIWORD(wParam)) // notification code
                    {
                        //
                        // User checked / unchecked the checkbox
                        //
                        ValidateCleanup(hDlg);
                        Notify_Change(hDlg);
                    }
                    break;

                case IDC_DAYS_EDIT:
                    if(EN_CHANGE == HIWORD(wParam)) // notification code
                    {      
                        //
                        // User changed something in the edit control
                        //
                        Notify_Change(hDlg);
                    }
                    break;                    

                default:
                    break;
            } // switch
            fRet = TRUE;
            break;
        }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                {
                    // if the user only has read permission, return immediately
                    if(!g_bUserCanChangeSettings)
                    {
                        return TRUE;
                    }

                    if(!SaveCleanupInfo(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                    else
                    {
                        Notify_UnChange(hDlg);
                        g_bPortInfoChanged = TRUE;
                    }
                    return TRUE;
                }
            } // switch
            break;
        }

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;
    } // switch
    return fRet;
}   // DevCleanupDlgProc


BOOL
SaveSendChanges(
    IN HWND hDlg)
/*++

Routine name : SaveSendChanges

Routine description:

    Process Apply Button

Author:

    Iv Garber (IvG),    Feb, 2001

Arguments:

    hDlg                          [TBD]    - Handle to the Window

Return Value:

    TRUE if Apply is succeeded, FALSE otherwise.

--*/
{
    DWORD   dwDeviceId = 0;
    DWORD   dwRes = 0;
    DWORD   dwData;
    TCHAR   szTsid[TSID_LIMIT + 1] = {0};
    BOOL    bRes;
    BOOL    bErrorDisplayed = FALSE;

    SYSTEMTIME  sTime = {0};

    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    //
    //  if the user only has read permission, return immediately
    //
    if(!g_bUserCanChangeSettings)
    {
        return TRUE;
    }

    //
    //  apply changes here!!
    //
    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);


    if(!Connect(hDlg, TRUE))
    {
        //
        //  Failed to connect to the Fax Service. Connect() showed the Error Message.
        //
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        return FALSE;
    }


    if(!FaxGetPortEx(g_hFaxSvcHandle, dwDeviceId, &pFaxPortInfo))
    {
        //
        //  Show the Error Message and return with FALSE
        //  
        dwRes = GetLastError();
        Error(( "FaxGetPortEx() failed with %d.\n", dwRes));
        goto ClearData;
    }

    Assert(pFaxPortInfo);

    //
    //  save settings
    //
    pFaxPortInfo->bSend = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED ? TRUE : FALSE;
    if (pFaxPortInfo->bSend)
    {
        //
        // Collect and verify TSID
        //
        GetDlgItemText(hDlg, IDC_DEVICE_PROP_TSID, szTsid, TSID_LIMIT);
        pFaxPortInfo->lptstrTsid = szTsid;
    }
    if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
    {
        //
        //  Show the Error Message and return with FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxSetPortEx() failed with %d.\n", dwRes));
        goto ClearData;
    }
    else
    {
        Notify_UnChange(hDlg);
        g_bPortInfoChanged = TRUE;
    }

    if(!IsDesktopSKU())
    {
        goto ClearData;
    }

    //
    // save desktop controls
    //
    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

    Assert(pOutboxConfig);

    //
    // Branding
    //            
    pOutboxConfig->bBranding = (IsDlgButtonChecked(hDlg, IDC_BRANDING_CHECK) == BST_CHECKED);

    //
    // Retries
    //
    dwData = GetDlgItemInt(hDlg, IDC_RETRIES_EDIT, &bRes, FALSE);
    if (!bRes || 
#if FXS_RETRIES_LOWER > 0 
        (dwData < FXS_RETRIES_LOWER) || 
#endif
        (dwData > FXS_RETRIES_UPPER))
    {
        //
        // Bad data or out of range
        //
        HWND hControl = GetDlgItem(hDlg, IDC_RETRIES_EDIT);

        dwRes = ERROR_INVALID_DATA;
        SetLastError (ERROR_INVALID_DATA);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RETRIES, FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bErrorDisplayed = TRUE;
        goto ClearData;
    }
    pOutboxConfig->dwRetries = dwData;
    //
    // Retry Delay
    //
    dwData = GetDlgItemInt(hDlg, IDC_RETRYDELAY_EDIT, &bRes, FALSE);
    if (!bRes || 
#if FXS_RETRYDELAY_LOWER > 0
        (dwData < FXS_RETRYDELAY_LOWER) || 
#endif
        (dwData > FXS_RETRYDELAY_UPPER))
    {
        //
        // Bad data or out of range
        //
        HWND hControl = GetDlgItem(hDlg, IDC_RETRYDELAY_EDIT);

        dwRes = ERROR_INVALID_DATA;
        SetLastError (ERROR_INVALID_DATA);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RETRY_DELAY, FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bErrorDisplayed = TRUE;
        goto ClearData;
    }
    pOutboxConfig->dwRetryDelay = dwData;
    //
    // Discount rate start time
    //
    SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&sTime);
    pOutboxConfig->dtDiscountStart.Hour   = sTime.wHour;
    pOutboxConfig->dtDiscountStart.Minute = sTime.wMinute;
    //
    // Discount rate stop time
    //
    SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&sTime);
    pOutboxConfig->dtDiscountEnd.Hour   = sTime.wHour;
    pOutboxConfig->dtDiscountEnd.Minute = sTime.wMinute;

    if(!FaxSetOutboxConfiguration(g_hFaxSvcHandle, pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(("FaxSetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

ClearData:
    FaxFreeBuffer(pOutboxConfig);
    FaxFreeBuffer(pFaxPortInfo);
    DisConnect();


    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            if (!bErrorDisplayed)
            {
                DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;

        default:
            if (!bErrorDisplayed)
            {
                DisplayErrorMessage(hDlg, 0, dwRes);
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;
    }
    return (dwRes == 0);
}   // SaveSendChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\faxui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.c

Abstract:

    Common routines for fax driver user interface

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"


CRITICAL_SECTION    faxuiSemaphore;     // Semaphore for protecting critical sections
HANDLE              ghInstance;         // DLL instance handle
PDOCEVENTUSERMEM    gDocEventUserMemList;       // Global list of user mode memory structures
INT                 _debugLevel = 1;    // for debuggping purposes
static BOOL         gs_bfaxuiSemaphoreInit = FALSE; // Flag for faxuiSemaphore CS initialization

PVOID
PrMemAlloc(
    SIZE_T size
    )
{
    return (PVOID)LocalAlloc(LPTR, size);
}

VOID
PrMemFree(
    PVOID ptr
    )
{
    if (ptr) {
        LocalFree((HLOCAL) ptr);
    }
}



BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    static BOOL bSHFusionInitialized = FALSE;
#ifndef WIN__95
    INITCOMMONCONTROLSEX CommonControlsEx = {
                                             sizeof(INITCOMMONCONTROLSEX),
                                             ICC_WIN95_CLASSES|ICC_DATE_CLASSES 
                                            };
#endif
    switch (ulReason) 

    {
        case DLL_PROCESS_ATTACH:

            if (!SHFusionInitializeFromModuleID(hModule,SXS_MANIFEST_RESOURCE_ID))
            {
                Verbose(("SHFusionInitializeFromModuleID failed"));
            }
            else
            {
                bSHFusionInitialized = TRUE;
            }

            if (!InitializeCriticalSectionAndSpinCount (&faxuiSemaphore, (DWORD)0x10000000))
            {            
                return FALSE;
            }
            gs_bfaxuiSemaphoreInit = TRUE;

            ghInstance = hModule;
            gDocEventUserMemList = NULL;

            HeapInitialize( NULL, PrMemAlloc, PrMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );
        
    #ifndef WIN__95
            if (!InitCommonControlsEx(&CommonControlsEx))
            {
                Verbose(("InitCommonControlsEx failed"));
            }
    #else
            InitCommonControls();
    #endif

            DisableThreadLibraryCalls(hModule);

            break;

        case DLL_PROCESS_DETACH:

            while (gDocEventUserMemList != NULL) 
            {
                PDOCEVENTUSERMEM    pDocEventUserMem;

                pDocEventUserMem = gDocEventUserMemList;
                gDocEventUserMemList = gDocEventUserMemList->pNext;
                FreePDEVUserMem(pDocEventUserMem);
            }

            if (TRUE == gs_bfaxuiSemaphoreInit)
            {
                DeleteCriticalSection(&faxuiSemaphore);
            }

            ReleaseActivationContext();
            if (bSHFusionInitialized)
            {
                SHFusionUninitialize();
                bSHFusionInitialized = FALSE;
            }
            break;
    }

    return TRUE;
}



LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    )

/*++

Routine Description:

    Calling common UI DLL entry point dynamically

Arguments:

    hwndOwner, pfnPropSheetUI, lParam, pResult - Parameters passed to common UI DLL

Return Value:

    Return value from common UI library

--*/

{
    HINSTANCE   hInstCompstui;
    FARPROC     pProc;
    LONG        Result = ERR_CPSUI_GETLASTERROR;

    //
    // Only need to call the ANSI version of LoadLibrary
    //

    static const CHAR szCompstui[] = "compstui.dll";
    static const CHAR szCommonPropSheetUI[] = "CommonPropertySheetUIW";

    if ((hInstCompstui = LoadLibraryA(szCompstui)) &&
        (pProc = GetProcAddress(hInstCompstui, szCommonPropSheetUI)))
    {
        Result = (LONG)(*pProc)(hwndOwner, pfnPropSheetUI, lParam, pResult);
    }

    if (hInstCompstui)
        FreeLibrary(hInstCompstui);

    return Result;
}



VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    )

/*++

Routine Description:

    Combine DEVMODE information:
     start with the driver default
     then merge with the system default //@ not done
     then merge with the user default //@ not done
     finally merge with the input devmode

    //@ The end result of this merge operation is a dev mode with default values for all the public
    //@ fields that are not specified or not valid. Input values for all the specified fields in the 
    //@ input dev mode that were specified and valid. And default (or per user in W2K) values for the private fields.
  

Arguments:

    pdmOut - Pointer to the output devmode buffer
    pdmIn - Pointer to an input devmode
    hPrinter - Handle to a printer object
    pPrinterInfo2 - Point to a PRINTER_INFO_2 structure or NULL
    publicOnly - Only merge the public portion of the devmode

Return Value:

    TRUE

--*/

{
    PPRINTER_INFO_2 pAlloced = NULL;
    PDEVMODE        pdmUser;

    //
    // Get a PRINTER_INFO_2 structure if one is not provided
    //

    if (! pPrinterInfo2)
        pPrinterInfo2 = pAlloced = MyGetPrinter(hPrinter, 2);

    //
    // Start with driver default devmode
    //

    if (! publicOnly) {

        //@ Generates the driver default dev mode by setting default values for the public fields
        //@ and loading per user dev mode for the private fields (W2K only for NT4 it sets default
        //@ values for the private fields too).

        DriverDefaultDevmode(pdmOut,
                             pPrinterInfo2 ? pPrinterInfo2->pPrinterName : NULL,
                             hPrinter);
    }

    //
    // Merge with the system default devmode and user default devmode
    //

    if (pPrinterInfo2) {

        #if 0

        //
        // Since we have per-user devmode and there is no way to
        // change the printer's default devmode, there is no need
        // to merge it here.
        //

        if (! MergeDevmode(pdmOut, pPrinterInfo2->pDevMode, publicOnly))
            Error(("Invalid system default devmode\n"));

        #endif

        if (pdmUser = GetPerUserDevmode(pPrinterInfo2->pPrinterName)) {

            if (! MergeDevmode(pdmOut, pdmUser, publicOnly))
                Error(("Invalid user devmode\n"));

            MemFree(pdmUser);
        }
    }

    MemFree(pAlloced);

    //
    // Merge with the input devmode
    //
    //@ The merge process wil copy the private data as is.
    //@ for public data it will only consider the fields which are of interest to the fax printer.
    //@ it will copy them to the destination if they are specified and valid.
    //@ The end result of this merge operation is a dev mode with default values for all the public
    //@ fields that are not specified or not valid. Input values for all the specified fields in the 
    //@ input dev mode that were specified and valid. And default (or per user in W2K) values for the private fields.
    
    if (! MergeDevmode(pdmOut, pdmIn, publicOnly))
        Error(("Invalid input devmode\n"));
}



PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Fill in the data structure used by the fax driver user interface

Arguments:

    hPrinter - Handle to the printer
    pdmInput - Pointer to input devmode, NULL if there is none

Return Value:

    Pointer to UIDATA structure, NULL if error.

--*/

{
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    PUIDATA         pUiData = NULL;
    HANDLE          hheap = NULL;

    //
    // Create a heap to manage memory
    // Allocate memory to hold UIDATA structure
    // Get printer info from the spooler
    // Copy the driver name
    //

    if (! (hheap = HeapCreate(0, 4096, 0)) ||
        ! (pUiData = HeapAlloc(hheap, HEAP_ZERO_MEMORY, sizeof(UIDATA))) ||
        ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)))
    {
        if (hheap)
            HeapDestroy(hheap);

        MemFree(pPrinterInfo2);
        return NULL;
    }

    pUiData->startSign = pUiData->endSign = pUiData;
    pUiData->hPrinter = hPrinter;
    pUiData->hheap = hheap;

    //
    // Combine various devmode information
    //

    GetCombinedDevmode(&pUiData->devmode, pdmInput, hPrinter, pPrinterInfo2, FALSE);

    //
    // Validate the form requested by the input devmode
    //

    if (! ValidDevmodeForm(hPrinter, &pUiData->devmode.dmPublic, NULL))
        Error(("Invalid form specification\n"));

    MemFree(pPrinterInfo2);
    return pUiData;
}




BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

    Implementation of DDI entry point DevQueryPrintEx. Even though we don't
    really need this entry point, we must export it so that the spooler
    will load our driver UI.

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure

Return Value:

    TRUE if there is no conflicts, FALSE otherwise

--*/

{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\faxui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.h

Abstract:

    Fax driver user interface header file

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXUI_H_
#define _FAXUI_H_

#ifdef __cplusplus
extern "C" {
#endif

#define ISOLATION_AWARE_ENABLED 1

#include <windows.h>
#include <shellapi.h>
#include <fxsapip.h>

#include "faxlib.h"
#include <faxres.h>

#include <winddiui.h>
#include <commctrl.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlwapi.h>

#ifdef FAX_SCAN_ENABLED
#include <twain.h>
#endif

#include "registry.h"
#include "timectrl.h"
#include "resource.h"

#include "faxsendw.h"
#include "faxroute.h"

#include <shlobj.h>
#include <shfusion.h>

//
// Data structure maintained by the fax driver user interface
//

typedef struct 
{
    PVOID           startSign;
    HANDLE          hPrinter;
    HANDLE          hheap;
    DRVDEVMODE      devmode;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hFaxOptsPage;
    BOOL            hasPermission;
    BOOL            configDefault;
    LPTSTR          pHelpFile;

    INT             cForms;
    LPTSTR          pFormNames;
    PWORD           pPapers;
    PVOID           endSign;

} UIDATA, *PUIDATA;

//
// Check if a UIDATA structure is valid
//

#define ValidUiData(p) ((p) && (p) == (p)->startSign && (p) == (p)->endSign)

//
// Combine DEVMODE information:
//  start with the driver default
//  then merge with the system default
//  then merge with the user default
//  finally merge with the input devmode
//

VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    );

//
// Fill in the data structure used by the fax driver user interface
//

PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    );

//
// Calling common UI DLL entry point dynamically
//

LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    );

//
// Retrieves a list of supported paper sizes
//

DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

#define CCHBINNAME          24      // max length for bin names
#define CCHPAPERNAME        64      // max length for form names

//
// Display an error message dialog
//

INT
DisplayErrorMessage(
    HWND    hwndParent,
    UINT    uiType,
    INT     iErrorCode,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_FORMAT_LEN      128
#define MAX_MESSAGE_LEN     512


// Data structures used by the user mode DLL to associate private
// information with a printer device context (PDEV to be exactly)
//

typedef struct {
    PVOID           pNext;                   // Points to the next item in the linked list
    HANDLE          hPrinter;                // Printer handle
    HANDLE          hMappingFile;            // Handle to the mapping file
    HANDLE          hPreviewFile;            // Handle to the preview file (document body)
    HANDLE          hMapping;                // Handle to the mapping object
    PMAP_TIFF_PAGE_HEADER pPreviewTiffPage;  // View of the mapping containing the preview page
    HDC             hdc;                     // Handle to the device context
    INT             pageCount;               // Number of pages in the document
    DWORD           jobId;                   // Current job ID
    INT             jobType;                 // Job type
    BOOL            directPrinting;          // Direct printing and skip the fax wizard
    BOOL            bShowPrintPreview;       // Indicates the user requested print preview
    BOOL            bPreviewAborted;         // Set to TRUE if an unrecoverable error occurred
                                             // concering print preview
    BOOL            bAttachment;             // TRUE for Direct printing of an attachment
    LPTSTR          pPrintFile;              // print to file file name
    LPTSTR          pPriority;               // Fax priority
    LPTSTR          pReceiptFlags;           // Flags of FAX_ENUM_DELIVERY_REPORT_TYPES
    LPTSTR          pReceiptAddress;         // Email address or computer name

    TCHAR           szPreviewFile[MAX_PATH]; // Preview file name
    TCHAR           coverPage[MAX_PATH];     // Cover page filename
    BOOL            bServerCoverPage;        // Is the cover page a server based cover page.
    LPTSTR          pSubject;                // Subject string
    LPTSTR          pNoteMessage;            // Note message string

    DRVDEVMODE      devmode;                 // The first field must be a current version devmode

    DWORD                   dwNumberOfRecipients;
    PFAX_PERSONAL_PROFILE   lpRecipientsInfo;

    PFAX_PERSONAL_PROFILE   lpSenderInfo;

    LPTSTR          lptstrServerName;
    LPTSTR          lptstrPrinterName;

    TCHAR           tstrTifName[MAX_PATH];  // Cover page filename

    PVOID           signature;              // Signature

} DOCEVENTUSERMEM, *PDOCEVENTUSERMEM;


#define ValidPDEVUserMem(p) \
        ((p) && (p) == (p)->signature)

//
// Mark the user mode memory structure
//

#define MarkPDEVUserMem(p)  \
        { (p)->signature = (p)->devmode.dmPrivate.pUserMem = (p); }

//
// Fax prefix and extension for temporary preview files
//

#define FAX_PREFIX      TEXT("fxs")

//
// Different types of print job
//

#define JOBTYPE_DIRECT  0
#define JOBTYPE_NORMAL  1


//
// Free up the user mode memory associated with each PDEV
//

VOID
FreePDEVUserMem(
    PDOCEVENTUSERMEM    pDocEventUserMem
    );

//
// Global variable declarations
//

extern CRITICAL_SECTION faxuiSemaphore;
extern HANDLE   ghInstance;
extern BOOL     oleInitialized;
extern PDOCEVENTUSERMEM gDocEventUserMemList;

#define EnterDrvSem() EnterCriticalSection(&faxuiSemaphore)
#define LeaveDrvSem() LeaveCriticalSection(&faxuiSemaphore)

INT_PTR
UserInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Global variables and macros
//

extern HANDLE   g_hFaxSvcHandle;
extern BOOL     g_bUserCanQuerySettings;
extern BOOL     g_bUserCanChangeSettings;

extern PFAX_PORT_INFO_EX  g_pFaxPortInfo; // port information 
extern DWORD              g_dwPortsNum;   // number of available fax devices

extern BOOL  g_bPortInfoChanged;         // TRUE if selected port info in g_pFaxPortInfo 
                                         // has been changed by device property sheet


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)            (sizeof(a)/sizeof(a[0]))
#endif

#define RESOURCE_STRING_LEN     256
#define MAX_DEVICE_NAME         MAX_PATH
#define MAX_FIELD_LEN           512
#define MAX_ARCHIVE_DIR         MAX_PATH - 16

#define CSID_LIMIT              20
#define TSID_LIMIT              20

#define MIN_RING_COUNT          1
#define MAX_RING_COUNT          99
#define DEFAULT_RING_COUNT      2

#define MIN_TIMEOUT     10
#define MAX_TIMEOUT     30
#define DEFAULT_TIMEOUT 10

#define RM_FOLDER   0
#define RM_PRINT    1

#define RM_COUNT    2           // number of routing methods

#define INFO_SIZE   (MAX_PATH * sizeof(TCHAR) + sizeof(DWORD))

static const LPCTSTR RoutingGuids[RM_COUNT] = {
    REGVAL_RM_FOLDER_GUID,      // RM_FOLDER
    REGVAL_RM_PRINTING_GUID     // RM_PRINT
};

typedef struct _COLUMN_HEADER {

    UINT    uResourceId;    // header string resource id
    INT     ColumnWidth;    // column width
} COLUMN_HEADER, *PCOLUMN_HEADER;

#define Notify_Change(hDlg) { \
    HWND hwndSheet = GetParent( hDlg ); \
    PropSheet_Changed( hwndSheet, hDlg ); \
} \

#define Notify_UnChange(hDlg) { \
    HWND hwndSheet = GetParent( hDlg ); \
    PropSheet_UnChanged( hwndSheet, hDlg ); \
} \

//
// Functions in devinfo.c
//

BOOL
FillInDeviceInfo(
    HWND    hDlg
    );

BOOL
DoInitDeviceList(
    HWND hDlg 
    );

BOOL
ValidateControl(
    HWND            hDlg,
    INT             iItem
    );

BOOL
ChangePriority(
    HWND            hDlg,
    BOOL            bMoveUp
    );

BOOL
DoSaveDeviceList(
    HWND hDlg // window handle of the device info page
    );

void
DisplayDeviceProperty(
    HWND    hDlg
);

HMENU 
CreateContextMenu(
    VOID
    );

INT_PTR
DeviceInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions in archfldr.c
//

INT_PTR
ArchiveInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RemoteInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions in statopts.c
//

BOOL
ValidateNotification(
    HWND            hDlg
    );

INT_PTR
StatusOptionDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions in devprop.c
//

int InitReceiveInfo(
    HWND    hDlg
    );

int SaveReceiveInfo(
    HWND    hDlg
    );

BOOL
ValidateSend(
    HWND            hDlg
    );

BOOL
ValidateReceive(
    HWND            hDlg
    );

INT_PTR CALLBACK 
DevSendDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

INT_PTR CALLBACK
DevRecvDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

INT_PTR CALLBACK
DevCleanupDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

//
// Functions in util.c
//

VOID
InitializeStringTable(
    VOID
    );

VOID
DeInitializeStringTable(
    VOID
    );

LPTSTR
GetString(
    DWORD ResourceId
    );

BOOL IsLocalPrinter(
    LPTSTR pPrinterName
    );

BOOL
IsFaxServiceRunning(
    );

VOID
DisConnect(
    );

BOOL
Connect(
    HWND    hDlg,
    BOOL    bDisplayErrorMessage
    );

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    );

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
    );

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    LPTSTR title
    );

LPTSTR
ValidatePath(
    LPTSTR szPath
    ); 

PFAX_PORT_INFO_EX
FindPortInfo(
    DWORD dwDeviceId
);

void
PageEnable(
    HWND hDlg,
    BOOL bEnable
);

DWORD
CountUsedFaxDevices();

BOOL
IsDeviceInUse(
    DWORD dwDeviceId
);
 
VOID
NotifyDeviceUsageChanged ();

//
// Functions in security.cpp
//

HPROPSHEETPAGE 
CreateFaxSecurityPage();

void
ReleaseFaxSecurity();

void 
ReleaseActivationContext();

HANDLE 
GetFaxActivationContext();



#ifdef __cplusplus
}
#endif

#endif // !_FAXUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\prnprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnprop.c

Abstract:

    Implementation of DDI entry points:
        DrvDevicePropertySheets
        PrinterProperties

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include <shellapi.h>
#include <faxreg.h>
#include "resource.h"

BOOL    g_bUserCanChangeSettings = FALSE;
BOOL    g_bUserCanQuerySettings  = FALSE;
HANDLE  g_hFaxSvcHandle          = NULL;   // global fax handle
HANDLE  g_hFaxActCtx             = INVALID_HANDLE_VALUE; 


PFAX_PORT_INFO_EX  g_pFaxPortInfo = NULL;
DWORD              g_dwPortsNum = 0;

BOOL  g_bPortInfoChanged = FALSE;

#define EXTRA_PAGES 3


HANDLE CreateActivationContextFromResource(LPCTSTR pszResourceName)
{
    TCHAR   tszModuleName[MAX_PATH * 2];
    ACTCTX  act             = {0};
    //    
    // Get the name for the module that contains the manifest resource
    // to create the Activation Context from.
    //
    if (!GetModuleFileName(ghInstance, tszModuleName, ARR_SIZE(tszModuleName)))
    {
        return INVALID_HANDLE_VALUE;
    }
    //
    // Now let's try to create an activation context from manifest resource.
    //
    act.cbSize          = sizeof(act);
    act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName  = pszResourceName;
    act.lpSource        = tszModuleName;

    return CreateActCtx(&act);
}   // CreateActivationContextFromResource

void ReleaseActivationContext()
{
    if (INVALID_HANDLE_VALUE != g_hFaxActCtx)
    {
        ReleaseActCtx(g_hFaxActCtx);
        g_hFaxActCtx = INVALID_HANDLE_VALUE;
    }
}   // ReleaseActivationContext


BOOL CreateFaxActivationContext()
{
    if(INVALID_HANDLE_VALUE != g_hFaxActCtx)
    {
        //
        // Already created
        //
        return TRUE;
    }
    g_hFaxActCtx = CreateActivationContextFromResource(MAKEINTRESOURCE(SXS_MANIFEST_RESOURCE_ID));
    return (INVALID_HANDLE_VALUE != g_hFaxActCtx);
}   // CreateFaxActivationContext

HANDLE GetFaxActivationContext()
{
    //
    // Make sure we've created our activation context.
    //
    CreateFaxActivationContext();
    // Return the global.
    return g_hFaxActCtx;
}   // GetFaxActivationContext


HPROPSHEETPAGE
AddPropertyPage(
    PPROPSHEETUI_INFO   pPSUIInfo,
    PROPSHEETPAGE      *psp 
)
{
    HPROPSHEETPAGE hRes;
    hRes = (HPROPSHEETPAGE)(pPSUIInfo->pfnComPropSheet(
                                pPSUIInfo->hComPropSheet, 
                                CPSFUNC_ADD_PROPSHEETPAGE, 
                                (LPARAM) psp, 
                                0));
    return hRes;
}   // AddPropertyPage

LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Printer Properties" dialog

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DEVICEPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PROPSHEETPAGE           psp[EXTRA_PAGES];
    HPROPSHEETPAGE          hPropSheetPage;
    DWORD                   dwRes = 0;
    int                     iRet  = 1;
    HANDLE                  hActCtx = INVALID_HANDLE_VALUE;

    //
    // Validate input parameters
    //
    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit)) 
    {
        Assert(FALSE);
        return -1;
    }

    //
    // Handle various cases for which this function might be called
    //
    switch (pPSUIInfo->Reason) 
    {
        case PROPSHEETUI_REASON_INIT:
            InitializeStringTable();
            memset(&psp, 0, sizeof(psp));
            //
            // if the printer is remote, show a simple page
            //
            if(!IsLocalPrinter(pDPHdr->pszPrinterName))
            {
                //
                // add a simple page because we need to add at least one page
                //
                psp[0].dwSize = sizeof(PROPSHEETPAGE);
                psp[0].hInstance = ghInstance;
                psp[0].lParam = (LPARAM)pDPHdr->pszPrinterName;
                psp[0].pszTemplate = MAKEINTRESOURCE(IDD_REMOTE_INFO);
                psp[0].pfnDlgProc = RemoteInfoDlgProc;

                if ( hPropSheetPage = AddPropertyPage(pPSUIInfo, &psp[0]) )
                {
                    pPSUIInfo->UserData = 0;
                    pPSUIInfo->Result = CPSUI_CANCEL;
                    goto exit;
                }
                break;
            }
            //
            // check the fax service status and start it if needed
            //
            if(!EnsureFaxServiceIsStarted(NULL))
            {
                dwRes = GetLastError();
                Error(( "Can't start fax service. ec = %d\n", dwRes));
                DisplayErrorMessage(NULL, 0, dwRes);
                break;
            }
            //
            // check the user's right to query/modify device setting, if the user doesn't have
            // modify permission, all controls will be disabled.
            //
            if(Connect(NULL, TRUE))
            {
                g_bUserCanQuerySettings = FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_QUERY_CONFIG, NULL);
                if(ERROR_SUCCESS != GetLastError())
                {
                    dwRes = GetLastError();
                    Error(( "FaxAccessCheckEx(FAX_ACCESS_QUERY_CONFIG) failed with %d\n", dwRes));
                    goto ConnectError;
                }

                g_bUserCanChangeSettings = FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL);
                if(ERROR_SUCCESS != GetLastError())
                {
                    dwRes = GetLastError();
                    Error(( "FaxAccessCheckEx(FAX_ACCESS_MANAGE_CONFIG) failed with %d\n", dwRes));
                    goto ConnectError;
                }

                if(!FaxEnumPortsEx(g_hFaxSvcHandle, &g_pFaxPortInfo, &g_dwPortsNum))
                {
                    dwRes = GetLastError();
                    Error(( "FaxEnumPortsEx failed with %d\n", dwRes));
                    goto ConnectError;
                }
                else
                {
                    g_bPortInfoChanged = FALSE;
                }
                DisConnect();
            }
            if(!g_bUserCanQuerySettings)
            {
                //
                // if the user does not have FAX_ACCESS_QUERY_CONFIG 
                // do not show fax pages
                //
                break;
            }
            psp[0].dwSize      = sizeof(PROPSHEETPAGE);
            psp[0].hInstance   = ghInstance;
            psp[0].lParam      = 0;
            psp[0].pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_INFO);
            psp[0].pfnDlgProc  = DeviceInfoDlgProc;

            psp[1].dwSize      = sizeof(PROPSHEETPAGE);
            psp[1].hInstance   = ghInstance;
            psp[1].lParam      = 0;
            psp[1].pszTemplate = MAKEINTRESOURCE(IDD_STATUS_OPTIONS);
            psp[1].pfnDlgProc  = StatusOptionDlgProc;

            psp[2].dwSize      = sizeof(PROPSHEETPAGE);
            psp[2].hInstance   = ghInstance;
            psp[2].lParam      = 0;
            psp[2].pszTemplate = MAKEINTRESOURCE(IDD_ARCHIVE_FOLDER);
            psp[2].pfnDlgProc  = ArchiveInfoDlgProc;

            //
            // Need to add a Activation Context so that Compstui will create the property page using
            // ComCtl v6 (i.e. so it will / can be Themed).
            //
            hActCtx = GetFaxActivationContext();
            if (INVALID_HANDLE_VALUE != hActCtx)
            {
                pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, 
                                           CPSFUNC_SET_FUSION_CONTEXT, 
                                           (LPARAM)hActCtx, 
                                           0);
            }

            if(!IsSimpleUI())
            {
                //
                // Add Fax Security page
                //
                hPropSheetPage = CreateFaxSecurityPage();
                if(hPropSheetPage)
                {                
                    if(!pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, 
                                                   CPSFUNC_ADD_HPROPSHEETPAGE, 
                                                   (LPARAM)hPropSheetPage, 
                                                   0))
                    {
                        Error(("Failed to add Fax Security page.\n"));
                    }
                }
            }

            if (AddPropertyPage(pPSUIInfo, &psp[0]) && // Devices
                AddPropertyPage(pPSUIInfo, &psp[1]) && // Tracking
                AddPropertyPage(pPSUIInfo, &psp[2]))   // Archives
            {
                pPSUIInfo->UserData = 0;
                pPSUIInfo->Result = CPSUI_CANCEL;
                goto exit;
            }        
            break;

ConnectError:
            DisConnect();
            DisplayErrorMessage(NULL, 0, dwRes);
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

                pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
                pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
                pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
                pPSUIHdr->hInst = ghInstance;
                pPSUIHdr->IconID = IDI_CPSUI_FAX;
            }

            goto exit;

        case PROPSHEETUI_REASON_SET_RESULT:
            pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
            goto exit;

        case PROPSHEETUI_REASON_DESTROY:
            DeInitializeStringTable();

            g_dwPortsNum = 0;
            FaxFreeBuffer(g_pFaxPortInfo);
            g_pFaxPortInfo = NULL;
            //
            // Release CFaxSecurity object
            //
            ReleaseFaxSecurity();
			DisConnect();
            goto exit;
    }

exit:
    return iRet;
}   // DrvDevicePropertySheets


BOOL
PrinterProperties(
    HWND    hwnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    Displays a printer-properties dialog box for the specified printer

Arguments:

    hwnd - Identifies the parent window of the dialog box
    hPrinter - Identifies a printer object

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

[Note:]

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    DEVICEPROPERTYHEADER devPropHdr;
    DWORD                result;

    memset(&devPropHdr, 0, sizeof(devPropHdr));
    devPropHdr.cbSize = sizeof(devPropHdr);
    devPropHdr.hPrinter = hPrinter;
    devPropHdr.pszPrinterName = NULL;

    //
    // Decide if the caller has permission to change anything
    //

    if (! SetPrinterDataDWord(hPrinter, PRNDATA_PERMISSION, 1))
        devPropHdr.Flags |= DPS_NOPERMISSION;

    CallCompstui(hwnd, DrvDevicePropertySheets, (LPARAM) &devPropHdr, &result);

    return result > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Definition of resource ID constants

Environment:

        Fax driver user interface

Revision History:

        02/26/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//

#define IDS_FULL_REMOTE_INFO        300
#define IDS_PARTIAL_REMOTE_INFO     301
#define IDS_BROWSE_FOLDER           302
#define IDS_SLOT_ONLYONE            303
#define IDS_DEVICE_NAME             304
#define IDS_SEND                    305
#define IDS_RECEIVE                 306
#define IDS_NO_DEVICE_SELECTED      307
#define IDS_DEVICE_ENABLED          308
#define IDS_DEVICE_DISABLED         309

#define IDS_DEVICE_AUTO_ANSWER      310
#define IDS_DEVICE_MANUAL_ANSWER    311
#define IDS_MSG_TITLE               312
#define IDS_BROADCAST_RECIPIENT     313
#define IDS_PREVIEW_TITLE           314
#define IDS_PREVIEW_OK              315
#define IDS_PREVIEW_FAILURE         316
#define IDS_QUALITY_NORMAL          317
#define IDS_QUALITY_DRAFT           318
#define IDS_NO_DEVICES              319

#define IDS_NOT_FAX_DEVICE          320

//
// Dialog resource IDs
//

#define IDD_DOCPROP                     100
#define IDD_DEVICE_INFO                 101
#define IDD_SEND_PROP                   102
#define IDD_RECEIVE_PROP                103
#define IDD_STATUS_OPTIONS              104
#define IDD_ARCHIVE_FOLDER              105
#define IDD_REMOTE_INFO                 106
#define IDI_UP                          107
#define IDI_DOWN                        108
#define IDI_FAX_DEVICE                  109
#define IDI_STATUS                      110
#define IDI_SEND                        111
#define IDI_RECEIVE                     112
#define IDI_ARCHIVE                     113
#define IDI_DEVICE_INFO                 114
#define IDI_REMOTE                      115
#define IDI_FAX_ERROR                   116
#define IDI_FAX_OPTIONS                 117
#define IDR_SEND                        118
#define IDR_RECEIVE                     119
#define IDR_CONTEXTMENU                 120
#define IDI_FAX_INFO                    121
#define IDD_SOUNDS                      122
#define IDD_CLEANUP_PROP                123
#define IDI_CLEANUP                     124

//
// Control resource IDs
//
#define IDC_PAPER_SIZE                  303
#define IDC_IMAGE_QUALITY               304
#define IDC_PORTRAIT                    305
#define IDC_LANDSCAPE                   306

#define IDC_TITLE                       326
#define IDC_FAX_SEND_GRP                327
#define IDC_DEFAULT_PRINT_SETUP_GRP     328
#define IDC_ORIENTATION                 329

#define IDC_STATIC_DEVICE_INFO          1000
#define IDC_DEVICE_LIST                 1001
#define IDC_PRI_UP                      1002
#define IDC_PRI_DOWN                    1003
#define IDC_TSID                        1004
#define IDC_PRINT_TO                    1005
#define IDC_CSID                        1006
#define IDC_RINGS                       1007
#define IDC_DEVICE_INFO_GRP             1008
#define IDC_DEST_FOLDER                 1009
#define IDC_DEVICE_PROP                 1011
#define IDC_DEVICE_PROP_SEND            1012
#define IDC_STATIC_TSID                 1014
#define IDC_DEVICE_PROP_TSID            1015
#define IDC_STATIC_TSID1                1016
#define IDC_STATIC_CSID                 1018
#define IDC_DEVICE_PROP_CSID            1019
#define IDC_STATIC_CSID1                1020
#define IDC_DEVICE_PROP_RINGS           1021
#define IDC_DEVICE_PROP_SPIN_RINGS      1022
#define IDC_STATIC_RINGS                1023
#define IDC_DEVICE_PROP_PRINT           1026
#define IDC_DEVICE_PROP_PRINT_TO        1027
#define IDC_DEVICE_PROP_SAVE            1028
#define IDC_DEVICE_PROP_DEST_FOLDER     1029
#define IDC_DEVICE_PROP_DEST_FOLDER_BR  1030
#define IDC_STATIC_ROUTE                1034
#define IDC_STATIC_BORDER               1035
#define IDC_STATIC_ARCHIVE              1036
#define IDC_INCOMING                    1037
#define IDC_INCOMING_FOLDER             1038
#define IDC_INCOMING_FOLDER_BR          1039
#define IDC_OUTGOING                    1040
#define IDC_OUTGOING_FOLDER             1041
#define IDC_OUTGOING_FOLDER_BR          1042
#define IDC_STATIC_PRINT                1043
#define IDC_STATIC_SAVE                 1044
#define IDC_STATIC_DEVICE               1046
#define IDC_STATIC_REMOTE_INFO          1047
#define IDC_DEVICE_PROP_MANUAL_ANSWER   1048
#define IDC_DEVICE_PROP_AUTO_ANSWER     1049
#define IDC_STATIC_RINGS1               1050
#define IDC_DEVICE_PROP_NEVER_ANSWER    1051
#define IDC_STATIC_STATUS_OPTIONS       1052
#define IDC_STATUS_TASKBAR              1053
#define IDC_STATUS_SOUND                1054
#define IDC_STATUS_BALLOON_TIMEOUT      1055
#define IDC_BALLOON_TIMEOUT             1056
#define IDC_BALLOON_TIMEOUT_SPIN        1057
#define IDC_STATIC_BALLOON_TIMEOUT      1058
#define IDC_STATIC_BALLOON_TIMEOUT1     1059
#define IDC_STATUS_BALLOON              1060
#define IDC_SEND_NOTIFICATION           1061
#define IDC_RECEIVE_NOTIFICATION        1062
#define IDC_SENDERROR_NOTIFICATION      1060
#define IDC_STATIC_DISPLAY_BALLOON      1064
#define IDC_RING_NOTIFICATION           1065
#define IDC_STATIC_SEND_OPTIONS         1066
#define IDC_STATIC_ARCHIVE_ICON         1067
#define IDC_STATIC_STATUS_ICON          1068
#define IDC_STATIC_SEND_ICON            1069
#define IDC_STATIC_RECEIVE_OPTIONS      1070
#define IDC_STATIC_ERROR_ICON           1071
#define IDC_STATIC_RECEIVE_ICON         1072
#define IDC_STATIC_ARCHIVE_OPTIONS      1073
#define IDC_DEVICE_PROP_RECEIVE         1074
#define IDC_STATIC_REMOTE_PRINTER       1075
#define IDC_STATIC_DEVICE_ICON          1076
#define IDCSTATIC_ANSWER_MODE           1077
#define IDC_STATIC_REMOTE_ICON          1078
#define IDC_STATIC_CHECK_NOTIFICATION_DESC 1079
#define IDC_STATIC_CHECK_NOTIFICATION_ICON 1080
#define IDCSTATIC_AUTO_ANSWER              1081
#define IDC_STATIC_CLEANUP_ICON         1082
#define IDC_STATIC_CLEANUP_OPTIONS      1083

#define IDC_ICON_STORE_IN_FOLDER        1082
#define IDC_STATIC_STORE_IN_FOLDER      1083

//
// Notifications page IDD_STATUS_OPTIONS
//
#define IDC_STATIC_SELECT_MODEM         1100
#define IDC_COMBO_MODEM                 1101
#define IDC_CHECK_MONITOR_ON_SEND       1103
#define IDC_CHECK_MONITOR_ON_RECEIVE    1104
#define IDC_BUTTON_SOUND                1106
#define IDC_GROUP_NOTIFY                1107
#define IDC_CHECK_NOTIFY_PROGRESS       1108
#define IDC_CHECK_NOTIFY_IN_COMPLETE    1109
#define IDC_CHECK_NOTIFY_OUT_COMPLETE   1110
#define IDC_GROUP_MONITOR               1111
#define IDC_STATIC_DEVICE_NOTE          1112
#define IDC_STATIC_NOTE_ICON            1113
#define IDC_STATIC_AUTO_OPEN            1114

//
// Sound Notifications dialog IDD_SOUNDS
//
#define IDC_CHECK_RING                  1120
#define IDC_CHECK_RECEIVE               1121
#define IDC_CHECK_SENT                  1122
#define IDC_CHECK_ERROR                 1123
#define IDC_BUTTON_CONFIGURE            1124

#define IDC_STATIC                      -1

//
// IDD_SEND_PROP
//
#define IDC_BRANDING_CHECK              1141
#define IDC_RETRIES_STATIC              1142
#define IDC_RETRIES_EDIT                1143
#define IDC_RETRIES_SPIN                1144
#define IDC_OUTB_RETRYDELAY_STATIC      1145
#define IDC_RETRYDELAY_EDIT             1146
#define IDC_RETRYDELAY_SPIN             1147
#define IDC_OUTB_MINUTES_STATIC         1148
#define IDC_OUTB_DIS_START_STATIC       1149
#define IDC_DISCOUNT_START_TIME         1150
#define IDC_OUTB_DIS_STOP_STATIC        1151
#define IDC_DISCOUNT_STOP_TIME          1152
#define IDC_DELETE_CHECK                1153
#define IDC_DAYS_EDIT                   1154
#define IDC_DAYS_SPIN                   1155
#define IDC_DAYS_STATIC                 1156    

//
// Command resource IDs
//
#define IDM_PROPERTY                    40001
#define IDM_SEND_ENABLE                 40002
#define IDM_SEND_DISABLE                40003
#define IDM_RECEIVE_AUTO                40004
#define IDM_RECEIVE_MANUAL              40005
#define IDM_RECEIVE_DISABLE             40006

//
//  menu IDR_SEND_RECEIVE
//
#define IDR_SEND_RECEIVE                40011
#define IDM_SEND                        40012
#define IDM_RECEIVE                     40013

//
// Security strings
//
#define IDS_FAXSEC_SUB_LOW              40111
#define IDS_FAXSEC_SUB_NORMAL           40112
#define IDS_FAXSEC_SUB_HIGH             40113
#define IDS_FAXSEC_JOB_QRY              40114
#define IDS_FAXSEC_JOB_MNG              40115
#define IDS_FAXSEC_CONFIG_QRY           40116
#define IDS_FAXSEC_CONFIG_SET           40117
#define IDS_FAXSEC_QRY_IN_ARCH          40118
#define IDS_FAXSEC_MNG_IN_ARCH          40119
#define IDS_FAXSEC_QRY_OUT_ARCH         40120
#define IDS_FAXSEC_MNG_OUT_ARCH         40121
#define IDS_FAXSEC_READ_PERM            40122
#define IDS_FAXSEC_CHNG_PERM            40123
#define IDS_FAXSEC_CHNG_OWNER           40124
#define IDS_RIGHT_FAX                   40125
#define IDS_RIGHT_MNG_DOC               40126
#define IDS_RIGHT_MNG_CFG               40127
#define IDS_SECURITY_TITLE              40128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1120
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\security.cpp ===
//
// ISecurityInformation interface implementation
//

#include <aclui.h>
#include "faxui.h"

class CFaxSecurity : public ISecurityInformation
{
protected:
    ULONG  m_cRef;

    STDMETHOD(MakeSelfRelativeCopy)(PSECURITY_DESCRIPTOR  psdOriginal,
                                    PSECURITY_DESCRIPTOR* ppsdNew);
public:
    CFaxSecurity() : m_cRef(1) {}
    virtual ~CFaxSecurity() {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);

    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);

    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);

    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);

    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);

    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);

    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};


CFaxSecurity* g_pFaxSecurity = NULL;


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CFaxSecurity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CFaxSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        g_pFaxSecurity = NULL;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CFaxSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CFaxSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
// *** ISecurityInformation methods implementation ***
/*
 -  CFaxSecurity::GetObjectInformation
 -
 *  Purpose:
 *      Performs an access check against the fax service security descriptor
 *
 *  Arguments:
 *      [in]   pObjectInfo      - pointer to object information structure.
 *
 *  Return:
 *      OLE error code
 */
{
    DWORD  ec  = ERROR_SUCCESS;
    
    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }

    HANDLE  hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE  hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;

    if( pObjectInfo == NULL ) 
    {
        Error(("Invalid parameter - pObjectInfo == NULL\n"));
        Assert( pObjectInfo != NULL );
        return E_POINTER;
    }

    //
    // Set Flags
    //
    pObjectInfo->dwFlags =  SI_EDIT_ALL       | 
                            SI_NO_TREE_APPLY  | 
                            SI_NO_ACL_PROTECT |
                            SI_ADVANCED       |
                            SI_PAGE_TITLE;
    
    //
    // Check if to add SI_READONLY 
    //
    if (!FaxAccessCheckEx(g_hFaxSvcHandle, WRITE_DAC, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_READONLY;
        }
        else 
        {
            Error(("FaxAccessCheckEx(WRITE_DAC) failed with %d \n", ec));
            goto exit;
        }
    }

    //
    // Check if to add SI_OWNER_READONLY 
    //
    hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(g_hFaxSvcHandle,WRITE_OWNER, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_OWNER_READONLY;
        }
        else 
        {
            Error(("FaxAccessCheckEx(WRITE_OWNER) failed with %d \n", ec));
            goto exit;
        }
    }

    //
    // Check if to remove SI_EDIT_AUDITS 
    //
    hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(g_hFaxSvcHandle, ACCESS_SYSTEM_SECURITY, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags &= ~SI_EDIT_AUDITS;
        }
        else 
        {
            Error(("FaxAccessCheckEx(ACCESS_SYSTEM_SECURITY) failed with %d \n", ec));
            goto exit;
        }
    }


    //
    // Set all other fields
    //
    static TCHAR tszPageTitle[MAX_PATH] = {0};
    if(LoadString((HINSTANCE)ghInstance, IDS_SECURITY_TITLE, tszPageTitle, ARR_SIZE(tszPageTitle)))
    {
        pObjectInfo->pszPageTitle = tszPageTitle;
    }
    else
    {
        ec = GetLastError();
        Error(("LoadString(IDS_SECURITY_TITLE) failed with %d \n", ec));

        pObjectInfo->pszPageTitle = NULL;
    }

    static TCHAR tszPrinterName[MAX_PATH] = {0};
    if(GetFirstLocalFaxPrinterName(tszPrinterName, ARR_SIZE(tszPrinterName)))
    {
        pObjectInfo->pszObjectName = tszPrinterName;
    }
    else
    {
        ec = GetLastError();
        Error(("GetFirstLocalFaxPrinterName() failed with %d \n", ec));

        pObjectInfo->pszObjectName = NULL;
    }
   
    pObjectInfo->hInstance = (HINSTANCE)ghInstance;
    pObjectInfo->pszServerName = NULL;    

exit:
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    return HRESULT_FROM_WIN32(ec);

} // CFaxSecurity::GetObjectInformation


STDMETHODIMP
CFaxSecurity::GetSecurity(SECURITY_INFORMATION  si,
                          PSECURITY_DESCRIPTOR* ppSD,
                          BOOL                  fDefault)
/*
 -  CFaxSecurityInformation::GetSecurity
 -
 *  Purpose:
 *      requests a security descriptor for the securable object whose 
 *      security descriptor is being edited. The access control editor 
 *      calls this method to retrieve the object's current or default security descriptor.
 *
 *  Arguments:
 *      [in]   RequestedInformation  - security information.
 *      [out]  ppSecurityDescriptor  - pointer to security descriptor.
 *      [in]   fDefault              - not implemented
 *
 *  Return:
 *      OLE error code
 */
{
    HRESULT hRc = S_OK;
    DWORD   ec  = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    HANDLE  hPrivBeforeSE_SECURITY = INVALID_HANDLE_VALUE;

    Assert(ppSD);

    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }
	   
    if( fDefault == TRUE ) 
    {
        Error(("Non implemeted feature -> fDefault == TRUE\n"));
        return E_NOTIMPL;
    }  

	if (si & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);    
	}

	//
    // Get the current relative descriptor from the fax server
    //
    if(!FaxGetSecurityEx(g_hFaxSvcHandle, si, &pSecurityDescriptor)) 
    {
        ec = GetLastError();
        Error(("FaxGetSecurityEx() failed with %d\n", ec));
        hRc = HRESULT_FROM_WIN32(ec);
        goto exit;
    }

	//
    // return a self relative descriptor copy allocated with LocalAlloc()
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, ppSD );
    if( FAILED( hRc ) ) 
    {
        Error(("MakeSelfRelativeCopy() failed with %08X\n", hRc));
        goto exit;
    }    
    
    Assert(S_OK == hRc);
    
exit:
	if (pSecurityDescriptor)
	{
		FaxFreeBuffer(pSecurityDescriptor);
	}
	ReleasePrivilege (hPrivBeforeSE_SECURITY);

    return hRc;

} // CFaxSecurity::GetSecurity

STDMETHODIMP
CFaxSecurity::SetSecurity(SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR pSD)
/*
 -  CFaxSecurityInformation::SetSecurity
 -
 *  Purpose:
 *      Provides a security descriptor containing the security information 
 *      the user wants to apply to the securable object. The access control 
 *      editor calls this method when the user clicks the Okay or Apply buttons.
 *
 *  Arguments:
 *      [in]   SecurityInformation - security information structure.
 *      [in]   pSecurityDescriptor - pointer to security descriptor.
 *
 *  Return:
 *      OLE error code
 */
{
    HRESULT  hRc = S_OK;
    DWORD    ec = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR psdSelfRelativeCopy = NULL;
    
	HANDLE  hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE  hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;
 
    Assert(pSD); 
    Assert( IsValidSecurityDescriptor( pSD ));     
	
    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }

	//
    // Prepare self relative descriptor
    //
	hRc = MakeSelfRelativeCopy( pSD, &psdSelfRelativeCopy );
    if( FAILED( hRc ) ) 
    {
        Error(("MakeSelfRelativeCopy() failed with %08X\n", hRc));
        goto exit;
    }

	if (si & OWNER_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);    
	}

	if (si & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
	}
	
    //
    // save the new relative descriptor to the fax server
    //
    if(!FaxSetSecurity(g_hFaxSvcHandle, si, psdSelfRelativeCopy)) 
    {
        ec = GetLastError();
        Error(("FaxSetSecurity() failed with %d\n", ec));
        hRc = HRESULT_FROM_WIN32(ec);
        goto exit;
    }

    Assert( S_OK == hRc || E_ACCESSDENIED == hRc);	

exit:
    if (psdSelfRelativeCopy)
	{
		::LocalFree(psdSelfRelativeCopy);
	}

	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
		
	return hRc;

} // CFaxSecurity::SetSecurity

STDMETHODIMP
CFaxSecurity::GetAccessRights(const GUID* pguidObjectType,
                              DWORD       dwFlags,
                              PSI_ACCESS* ppAccess,
                              ULONG*      pcAccesses,
                              ULONG*      piDefaultAccess)
/*
 -  CFaxSecurityInformation::GetAccessRights
 -
 *  Purpose:
 *      Requests information about the access rights that can be 
 *      controlled for a securable object. The access control 
 *      editor calls this method to retrieve display strings and 
 *      other information used to initialize the property pages.
 *
 *  Arguments:
 *      [in] pguidObjectType  - Pointer to a GUID structure that 
 *                              identifies the type of object for which 
 *                              access rights are being requested. 
 *      [in] dwFlags -          A set of bit flags that indicate the property
 *                              page being initialized
 *      [out] ppAccess -        Pointer to a variable that you should 
 *                              set to a pointer to an array of SI_ACCESS 
 *                              structures. 
 *      [out] pcAccesses -      Pointer to a variable that you should set 
 *                              to indicate the number of entries in the ppAccess array. 
 *      [out] piDefaultAccess - Pointer to a variable that you should set 
 *                              to indicate the zero-based index of the array entry that contains 
 *                              the default access rights. 
 *                              The access control editor uses this entry as the initial access rights in a new ACE. 
 *
 *  Return:
 *      OLE error code
 */
{
    Assert( ppAccess );
    Assert( pcAccesses );
    Assert( piDefaultAccess );

    //
    // Access rights for the Basic security page
    //
    static SI_ACCESS siFaxBasicAccess[] =
    {
        // 0 Fax
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_HIGH | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT | FAX_ACCESS_QUERY_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_RIGHT_FAX),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 1 Manage fax configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_CONFIG | FAX_ACCESS_QUERY_CONFIG,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_CFG),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 2 Manage fax documents
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_JOBS			| FAX_ACCESS_QUERY_JOBS			|
            FAX_ACCESS_MANAGE_IN_ARCHIVE	| FAX_ACCESS_QUERY_IN_ARCHIVE	|
            FAX_ACCESS_MANAGE_OUT_ARCHIVE	| FAX_ACCESS_MANAGE_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_DOC),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        }
    };

    //
    // Access rights for the Advanced security page
    //
    static SI_ACCESS siFaxAccess[] =
    {
        // 0 submit permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_LOW),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 1 submit normal permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_NORMAL ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_NORMAL),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 2 submit high permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_HIGH ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_HIGH),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 3 query jobs 
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_JOBS,
            MAKEINTRESOURCE(IDS_FAXSEC_JOB_QRY),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 4 Manage jobs
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_JOBS,
            MAKEINTRESOURCE(IDS_FAXSEC_JOB_MNG),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 5 query configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_CONFIG,
            MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_QRY),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 6 Manage configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_CONFIG,
            MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_SET),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },    
        // 7 Query incoming faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_QRY_IN_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 8 Manage incoming faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_MNG_IN_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 9 Query outgoing faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_QRY_OUT_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 10 Manage outgoing faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_MNG_OUT_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // specific permissions
        // 11 Read permission
        {   
            &GUID_NULL, 
            READ_CONTROL,
            MAKEINTRESOURCE(IDS_FAXSEC_READ_PERM),
            SI_ACCESS_SPECIFIC 
        },
        // 12 Change Permissions
        {   
            &GUID_NULL, 
            WRITE_DAC,
            MAKEINTRESOURCE(IDS_FAXSEC_CHNG_PERM),
            SI_ACCESS_SPECIFIC 
        },
        // 13 Take ownership
        {   
            &GUID_NULL, 
            WRITE_OWNER,
            MAKEINTRESOURCE(IDS_FAXSEC_CHNG_OWNER),
            SI_ACCESS_SPECIFIC
        }
    };

    *ppAccess        = (0 == dwFlags) ? siFaxBasicAccess : siFaxAccess;    
    *pcAccesses      = ULONG((0 == dwFlags) ? ARR_SIZE(siFaxBasicAccess) : ARR_SIZE(siFaxAccess));
    *piDefaultAccess = (0 == dwFlags) ? 0 : 1;

    return S_OK;

} // CFaxSecurity::GetAccessRights


STDMETHODIMP
CFaxSecurity::MapGeneric(const GUID*  pguidObjectType,
                         UCHAR*       pAceFlags,
                         ACCESS_MASK* pmask)
/*
 -  CFaxSecurityInformation::MapGeneric
 -
 *  Purpose:
 *      Requests that the generic access rights in an access mask 
 *      be mapped to their corresponding standard and specific access rights.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
{
    static GENERIC_MAPPING genericMapping =
    {
            (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),          // GenericRead 
            (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),        // GenericWrite 
            (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),    // GenericExecute 
            (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FAX_GENERIC_ALL) // GenericAll 
    };

    MapGenericMask(pmask, &genericMapping);

    return S_OK;
}

STDMETHODIMP
CFaxSecurity::GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes,
                              ULONG*            pcInheritTypes)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CFaxSecurity::PropertySheetPageCallback(HWND         hwnd,
                                        UINT         uMsg,
                                        SI_PAGE_TYPE uPage)
{
    return S_OK;
}


HRESULT 
CFaxSecurity::MakeSelfRelativeCopy(PSECURITY_DESCRIPTOR  psdOriginal,
                                   PSECURITY_DESCRIPTOR* ppsdNew)
/*
 -  CFaxSecurityInformation::MakeSelfRelativeCopy
 -
 *  Purpose:
 *      This pravite method copies Security descriptors 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
{
    Assert( NULL != psdOriginal );

    //
    // we have to find out whether the original is already self-relative
    //
    SECURITY_DESCRIPTOR_CONTROL  sdc                 = 0;
    PSECURITY_DESCRIPTOR         psdSelfRelativeCopy = NULL;
    DWORD                        dwRevision          = 0;
    DWORD                        cb                  = 0;

    Assert(IsValidSecurityDescriptor( psdOriginal ) ); 

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) 
    {
        DWORD err = ::GetLastError();
        Error(("GetSecurityDescriptorControl() failed with %d\n", err));
        return HRESULT_FROM_WIN32( err );
    }

    if( sdc & SE_SELF_RELATIVE )
	{
        // the original is in self-relative format, just byte-copy it

        // get size
        cb = ::GetSecurityDescriptorLength( psdOriginal );

        // alloc the memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
            Error(("Out of memory.\n"));
            return E_OUTOFMEMORY;
        }

        // make the copy
        ::memcpy( psdSelfRelativeCopy, psdOriginal, cb );
    } 
    else 
    {
        // the original is in absolute format, convert-copy it

        // get new size - it will fail and set cb to the correct buffer size
        ::MakeSelfRelativeSD( psdOriginal, NULL, &cb );

        // alloc the new amount of memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(!psdSelfRelativeCopy) 
        {
            Error(("Out of memory.\n"));
            return E_OUTOFMEMORY; // just in case the exception is ignored
        }

        if( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) ) 
        {
            DWORD err = ::GetLastError();
            Error(("MakeSelfRelativeSD() failed with %d\n", err));

            ::LocalFree( psdSelfRelativeCopy );

            return HRESULT_FROM_WIN32( err );
        }
    }

    *ppsdNew = psdSelfRelativeCopy;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code
//
///////////////////////////////////////////////////////////////////////////////

extern "C"
HPROPSHEETPAGE 
CreateFaxSecurityPage()
{
    if(!g_pFaxSecurity)
    {
        g_pFaxSecurity = new CFaxSecurity();
    }

    if(!g_pFaxSecurity)
    {
        Error(("Out of memory.\n"));
        return NULL;
    }

    HPROPSHEETPAGE hPage = CreateSecurityPage(g_pFaxSecurity);
    if(!hPage)
    {
        Error(("CreateSecurityPage() failed with %d\n", ::GetLastError()));
    }

    return hPage;
}

extern "C"
void
ReleaseFaxSecurity()
{
    if(g_pFaxSecurity)
    {
        g_pFaxSecurity->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\statopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    statopts.c

Abstract:

    Property sheet handler for "Status Option" page

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.
        Copy part of code from shell\ext\systray\dll\fax.cpp

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h" 


HWND g_hwndTracking = NULL;

INT_PTR 
CALLBACK 
SoundDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
);


BOOL
GetSelectedDeviceId(
    HWND   hDlg,
    DWORD* pdwDeviceId
)
/*++

Routine Description:

    Returns selected divice ID from IDC_COMBO_MODEM combo box

Arguments:

    hDlg        - [in]  Handle to the Status Options property sheet page
    pdwDeviceId - [out] selected device ID

Return Value:

    TRUE for success, FALSE otherwise

--*/
{
    DWORD dwCount = 0;
    DWORD dwIndex = 0;
    HWND  hComboModem = NULL;

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        Error(( "GetDlgItem(hDlg, IDC_COMBO_MODEM) failed, ec = %d.\n", GetLastError()));
        return FALSE;
    }

    dwCount = (DWORD)SendMessage(hComboModem, CB_GETCOUNT,0,0);
    if(CB_ERR == dwCount || 0 == dwCount)
    {
        Error(( "SendMessage(hComboModem, CB_GETCOUNT,0,0) failed\n"));
        return FALSE;
    }

    dwIndex = (DWORD)SendMessage(hComboModem, CB_GETCURSEL,0,0);
    if(CB_ERR == dwIndex)
    {
        Error(( "SendMessage(hComboModem, CB_GETCURSEL,0,0) failed\n"));
        return FALSE;
    }

    *pdwDeviceId = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
    if(CB_ERR == *pdwDeviceId)
    {
        Error(( "SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0) failed\n"));
        return FALSE;
    }

    return TRUE;
}

void
OnDevSelectChanged(
    HWND hDlg
)
/*++

Routine Description:

    Change IDC_CHECK_MANUAL_ANSWER check box state
    according to device selection

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/
{
    BOOL  bFaxEnable = FALSE;
    DWORD dwSelectedDeviceId = 0;

    PFAX_PORT_INFO_EX pPortInfo = NULL;
    TCHAR szDeviceNote[MAX_PATH] = {0};

    GetSelectedDeviceId(hDlg, &dwSelectedDeviceId);

    if(dwSelectedDeviceId)
    {
        pPortInfo = FindPortInfo(dwSelectedDeviceId);
        if(!pPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            return;                
        }

        bFaxEnable = pPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pPortInfo->ReceiveMode);
    }

    if(!bFaxEnable)
    {
        if(!LoadString(ghInstance, 
                       0 == dwSelectedDeviceId ? IDS_NO_DEVICES : IDS_NOT_FAX_DEVICE, 
                       szDeviceNote, 
                       MAX_PATH))
        {
            Error(( "LoadString() failed with %d.\n", GetLastError()));
            Assert(FALSE);
        }
    }

    SetDlgItemText(hDlg, IDC_STATIC_DEVICE_NOTE, szDeviceNote);
    ShowWindow(GetDlgItem(hDlg, IDC_STATIC_NOTE_ICON), bFaxEnable ? SW_HIDE : SW_SHOW);

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_MONITOR_ON_SEND),     bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_MONITOR_ON_RECEIVE),  bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_PROGRESS),     bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_IN_COMPLETE),  bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_OUT_COMPLETE), bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_AUTO_OPEN),          bFaxEnable);    
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SOUND),              bFaxEnable);
}


VOID
DoInitStatusOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the Status Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/
{
    HKEY    hRegKey;

    DWORD dw;
    DWORD dwItem;    
    DWORD dwSelectedDeviceId=0;
    DWORD dwSelectedItem=0;
    HWND  hComboModem = NULL;

    BOOL    bDesktopSKU = IsDesktopSKU();

    DWORD   bNotifyProgress      = bDesktopSKU;
    DWORD   bNotifyInCompletion  = bDesktopSKU;
    DWORD   bNotifyOutCompletion = bDesktopSKU;
    DWORD   bMonitorOnSend       = bDesktopSKU;
    DWORD   bMonitorOnReceive    = bDesktopSKU;

    //
    // Open the user info registry key for reading
    //    
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE,KEY_READ)))
    {
        GetRegistryDwordEx(hRegKey, REGVAL_MONITOR_ON_SEND,     &bMonitorOnSend);
        GetRegistryDwordEx(hRegKey, REGVAL_MONITOR_ON_RECEIVE,  &bMonitorOnReceive);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_PROGRESS,     &bNotifyProgress);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_IN_COMPLETE,  &bNotifyInCompletion);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_OUT_COMPLETE, &bNotifyOutCompletion);
        GetRegistryDwordEx(hRegKey, REGVAL_DEVICE_TO_MONITOR,   &dwSelectedDeviceId);
        
        RegCloseKey(hRegKey);
    }

    CheckDlgButton( hDlg, IDC_CHECK_MONITOR_ON_SEND,     bMonitorOnSend       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_MONITOR_ON_RECEIVE,  bMonitorOnReceive    ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_PROGRESS,     bNotifyProgress      ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_IN_COMPLETE,  bNotifyInCompletion  ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_OUT_COMPLETE, bNotifyOutCompletion ? BST_CHECKED : BST_UNCHECKED);            


    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        return;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        dwItem = (DWORD)SendMessage(hComboModem, CB_ADDSTRING, 0, (LPARAM)g_pFaxPortInfo[dw].lpctstrDeviceName);
        if(CB_ERR != dwItem && CB_ERRSPACE != dwItem)
        {
            SendMessage(hComboModem, CB_SETITEMDATA, dwItem, g_pFaxPortInfo[dw].dwDeviceID);
            if(g_pFaxPortInfo[dw].dwDeviceID == dwSelectedDeviceId)
            {
                dwSelectedItem = dwItem;                
            }
        }
        else
        {
            Error(( "SendMessage(hComboModem, CB_ADDSTRING, 0, pPortsInfo[dw].lpctstrDeviceName) failed\n"));
        }

        SendMessage(hComboModem, CB_SETCURSEL, dwSelectedItem, 0);
        OnDevSelectChanged(hDlg);
    }

    return;
}

BOOL
DoSaveStatusOptions(
    HWND    hDlg
    )   

/*++

Routine Description:

    Save the information on the Status Options property sheet page to registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    TRUE for success, FALSE otherwise

--*/

#define SaveStatusOptionsCheckBox(id, pValueName) \
            SetRegistryDword(hRegKey, pValueName, IsDlgButtonChecked(hDlg, id));

{
    HKEY    hRegKey;
    HWND    hWndFaxStat = NULL;
    DWORD   dwSelectedDeviceId = 0;
    DWORD   dwRes = 0;

    //
    // Open the user registry key for writing and create it if necessary
    //
    if (! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
    {
        dwRes = GetLastError();
        Error(("Can't open registry to save data. Error = %d\n", dwRes));
        DisplayErrorMessage(hDlg, 0, dwRes);
        return FALSE;
    }

    SaveStatusOptionsCheckBox(IDC_CHECK_MONITOR_ON_SEND,     REGVAL_MONITOR_ON_SEND);
    SaveStatusOptionsCheckBox(IDC_CHECK_MONITOR_ON_RECEIVE,  REGVAL_MONITOR_ON_RECEIVE);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_PROGRESS,     REGVAL_NOTIFY_PROGRESS);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_IN_COMPLETE,  REGVAL_NOTIFY_IN_COMPLETE);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_OUT_COMPLETE, REGVAL_NOTIFY_OUT_COMPLETE);

    if(GetSelectedDeviceId(hDlg, &dwSelectedDeviceId))
    {
        SetRegistryDword(hRegKey, REGVAL_DEVICE_TO_MONITOR, dwSelectedDeviceId);
    }

    //
    // Close the registry key before returning to the caller
    //
    RegCloseKey(hRegKey);

    //
    // See if faxstat is running
    //
    hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxStat) 
    {
        PostMessage(hWndFaxStat, WM_FAXSTAT_CONTROLPANEL, 0, 0);
    }

    return TRUE;
}


INT_PTR 
CALLBACK 
StatusOptionDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the "status option" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitStatusOptions(hDlg);
            g_hwndTracking = hDlg;
            return TRUE;
        }

    case WM_DESTROY:
        g_hwndTracking = NULL;
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {                        
            case IDC_CHECK_MONITOR_ON_SEND:
            case IDC_CHECK_MONITOR_ON_RECEIVE:
            case IDC_CHECK_NOTIFY_PROGRESS:
            case IDC_CHECK_NOTIFY_IN_COMPLETE:
            case IDC_CHECK_NOTIFY_OUT_COMPLETE:

                if( HIWORD(wParam) == BN_CLICKED ) // notification code
                {
                    Notify_Change(hDlg);
                }

                break;

            case IDC_COMBO_MODEM:

                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    OnDevSelectChanged(hDlg);
                    Notify_Change(hDlg);
                }
                break;

            case IDC_BUTTON_SOUND:
                //
                // open sound dialog
                //
                DialogBoxParam(ghInstance,
                               MAKEINTRESOURCE(IDD_SOUNDS),
                               hDlg,
                               SoundDlgProc,
                               (LPARAM)NULL);
                break; 

            default:
                break;
        }

        break;

    case WM_NOTIFY:
    {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {
            case PSN_SETACTIVE:
                
                OnDevSelectChanged(hDlg);

                break;

            case PSN_APPLY:

                if(!DoSaveStatusOptions(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                }
                else
                {
                    Notify_UnChange(hDlg);
                }

                return TRUE;

            default :
                break;
        } // switch
        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}


INT_PTR 
CALLBACK 
SoundDlgProc(
  HWND hDlg,    
  UINT uMsg,    
  WPARAM wParam,
  LPARAM lParam 
)
/*++

Routine Description:

    Procedure for handling the sound dialog

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/
{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            HKEY  hRegKey;
            DWORD bSoundOnRing    = IsDesktopSKU();
            DWORD bSoundOnReceive = bSoundOnRing;
            DWORD bSoundOnSent    = bSoundOnRing;
            DWORD bSoundOnError   = bSoundOnRing;

            if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE,KEY_READ)))
            {
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_RING,      &bSoundOnRing);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_RECEIVE,   &bSoundOnReceive);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_SENT,      &bSoundOnSent);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_ERROR,     &bSoundOnError);

                RegCloseKey(hRegKey);
            }

            CheckDlgButton( hDlg, IDC_CHECK_RING,    bSoundOnRing ?    BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_RECEIVE, bSoundOnReceive ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_SENT,    bSoundOnSent ?    BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_ERROR,   bSoundOnError ?   BST_CHECKED : BST_UNCHECKED);            

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {   
            case IDOK:
                {
                    HKEY    hRegKey;
                    DWORD   dwRes = 0;

                    //
                    // Open the user registry key for writing and create it if necessary
                    //
                    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
                    {
                        SaveStatusOptionsCheckBox(IDC_CHECK_RING,    REGVAL_SOUND_ON_RING);
                        SaveStatusOptionsCheckBox(IDC_CHECK_RECEIVE, REGVAL_SOUND_ON_RECEIVE);
                        SaveStatusOptionsCheckBox(IDC_CHECK_SENT,    REGVAL_SOUND_ON_SENT);
                        SaveStatusOptionsCheckBox(IDC_CHECK_ERROR,   REGVAL_SOUND_ON_ERROR);

                        RegCloseKey(hRegKey);

                        EndDialog(hDlg, IDOK);
                    }
                    else
                    {
                        dwRes = GetLastError();
                        Error(("Can't open registry to save data. Error = %d\n", dwRes));
                        DisplayErrorMessage(hDlg, 0, dwRes);
                    }
                }
                break;
            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;
        }

        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    }

    return FALSE;
}

DWORD
FindDeviceToMonitor ()
/*++

Routine name : FindDeviceToMonitor

Routine description:

	Attempts to find a device which is either send or receive enabled

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:
    
Return Value:

    Device id, zero if none found.

--*/
{
    DWORD             dwIndex;

    for (dwIndex = 0; dwIndex < g_dwPortsNum; dwIndex++)
    {
        if (g_pFaxPortInfo[dwIndex].bSend                                           ||  // Device is send enabled or
            (FAX_DEVICE_RECEIVE_MODE_OFF != g_pFaxPortInfo[dwIndex].ReceiveMode))       // device is receive enabled    
        {
            //
            // We have a match
            //
            return g_pFaxPortInfo[dwIndex].dwDeviceID;
        }
    }
    return 0;
}   // FindDeviceToMonitor

VOID
NotifyDeviceUsageChanged ()
/*++

Routine name : NotifyDeviceUsageChanged

Routine description:

	A notification function. 
    Called whenever the usage of a device has changed.

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:

Return Value:

    None.

--*/
{
    DWORD dwMonitoredDeviceId;
    
    if (g_hwndTracking)
    {
        //
        // Get data from the combo-box
        //
        if(!GetSelectedDeviceId(g_hwndTracking, &dwMonitoredDeviceId))
        {
            //
            // Can't read monitored device
            //
            return;
        }
    }
    else
    {
        HKEY  hRegKey;
        //
        // Get data from the registry
        //
        if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE, KEY_READ)))
        {
            if (ERROR_SUCCESS != GetRegistryDwordEx(hRegKey, REGVAL_DEVICE_TO_MONITOR, &dwMonitoredDeviceId))
            {
                //
                // Can't read monitored device
                //
                RegCloseKey (hRegKey);
                return;
            }
            RegCloseKey (hRegKey);
        }
        else
        {
            //
            // Can't read monitored device
            //
            return;
        }
    }
    if (IsDeviceInUse(dwMonitoredDeviceId))
    {
        //
        // Monitored device is in use - no action required
        //
        return;
    }
    //
    // Now we know that the monitored device is no longer in use.
    // Try to find another device to monitor.
    // 
    dwMonitoredDeviceId = FindDeviceToMonitor ();
    if (!dwMonitoredDeviceId)
    {
        //
        // Can't find any device to monitor - do nothing.
        //
        return;
    }
    //
    // Set the new device
    //
    if (g_hwndTracking)
    {
        //
        // Set data to the combo-box
        //
        DWORD dwCount = 0;
        DWORD dwIndex = 0;
        HWND  hComboModem = NULL;

        hComboModem = GetDlgItem(g_hwndTracking, IDC_COMBO_MODEM);
        if(!hComboModem)
        {
            Assert(FALSE);
            return;
        }
        dwCount = (DWORD)SendMessage(hComboModem, CB_GETCOUNT,0,0);
        if(CB_ERR == dwCount || 0 == dwCount)
        {
            Error(("SendMessage(hComboModem, CB_GETCOUNT,0,0) failed\n"));
            return;
        }
        for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            DWORD dwDeviceId;
            //
            // Look for the device
            //
            dwDeviceId = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
            if (dwDeviceId != dwMonitoredDeviceId)
            {
                continue;
            }
            //
            // Found the new device in the combo-box.
            // Select it and mark the page as modified.
            //
            SendMessage(hComboModem, CB_SETCURSEL, dwIndex, 0);
            OnDevSelectChanged(g_hwndTracking);
            Notify_Change(g_hwndTracking);
            break;
        }
    }
    else
    {
        HKEY  hRegKey;
        //
        // Set data to the registry
        //
        if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE, KEY_WRITE)))
        {
            if (!SetRegistryDword(hRegKey, REGVAL_DEVICE_TO_MONITOR, dwMonitoredDeviceId))
            {
                //
                // Can't write monitored device
                //
            }
            RegCloseKey (hRegKey);
        }
    }
}   // NotifyDeviceUsageChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\help.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Help related declarations

Environment:

    Windows XP fax driver

Revision History:

    07/30/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _HELP_H_
#define _HELP_H_

//
// Name of the help file for the fax driver
//

#define HELP_FILENAME               TEXT("fax.hlp")

//
// Help indices
//

#define IDH_BILLING_CODE                  2002
#define IDH_IMAGE_QUALITY                 2025
#define IDH_LANDSCAPE                     2026
#define IDH_PAPER_SIZE                    2037
#define IDH_PORTRAIT                      2038
#define IDH_SEND_ASAP                     2046
#define IDH_SEND_AT_CHEAP                 2047
#define IDH_SEND_AT_TIME                  2048
#define IDH_EMAIL                         2049
#define IDH_FAX_SEND_GRP                  2075
#define IDH_DEFAULT_PRINT_SETUP_GRP       2070
#define IDH_ORIENTATION                   2062
#define IDH_SEND_AT_TIME                  2048

#endif  // !_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\forms.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.h

Abstract:

    Declaration of functions for dealing with forms

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FORMS_H_
#define _FORMS_H_

//
// This is defined in winspool.h but we cannot include it from
// kernel mode source. Define it here until DDI header files are fixed.
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

typedef struct _FORM_INFO_1 {

    DWORD   Flags;
    PWSTR   pName;
    SIZEL   Size;
    RECTL   ImageableArea;

} FORM_INFO_1, *PFORM_INFO_1;

#define FORM_BUILTIN    0x00000001

typedef struct _PRINTER_INFO_2 {

    PWSTR   pServerName;
    PWSTR   pPrinterName;
    PWSTR   pShareName;
    PWSTR   pPortName;
    PWSTR   pDriverName;
    PWSTR   pComment;
    PWSTR   pLocation;
    PDEVMODEW pDevMode;
    PWSTR   pSepFile;
    PWSTR   pPrintProcessor;
    PWSTR   pDatatype;
    PWSTR   pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;

} PRINTER_INFO_2, *PPRINTER_INFO_2;

#endif // KERNEL_MODE && !USERMODE_DRIVER

//
// We use the highest order bit of FORM_INFO_1.Flags.
// Make sure the spooler is not using this bits.
//

#define FORM_SUPPORTED      0x80000000

#define IsSupportedForm(pForm)  ((pForm)->Flags & FORM_SUPPORTED)
#define SetSupportedForm(pForm) ((pForm)->Flags |= FORM_SUPPORTED)

//
// Our internal unit for measuring paper size and imageable area is microns.
// Following macros converts between microns and pixels, given a resolution
// measured in dots-per-inch.
//

#define MicronToPixel(micron, dpi)  MulDiv(micron, dpi, 25400)

//
// Validate the form specification in a devmode
//

BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    );

//
// Return a collection of forms in the system database
//

PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    );

#endif // !_FORMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\libproto.h ===
/******************** Function Prototypes file ***************************
 *  libproto.h
 *      Function prototypes for NT printer drivers library.  Also includes
 *      a brief description of the function.
 *
 *  11:04 on Wed 14 Nov 1990    -by-    Lindsay Harris   [lindsayh]
 *
 * Copyright (C) Microsoft Corporation,  1990 - 1992
 *
 ************************************************************************/

#ifndef __LIBPROTO_H__
#define __LIBPROTO_H__

#if defined(NTGDIKM) && !defined(KERNEL_MODE)
#define KERNEL_MODE
#endif

#ifdef NTGDIKM

extern ULONG gulMemID;
#define DbgPrint         DrvDbgPrint
#define HeapAlloc(hHeap,Flags,Size)    DRVALLOC( Size )
#define HeapFree( hHeap, Flags, VBits )  DRVFREE( VBits )

#ifndef FillMemory
#define FillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#endif

//#define DRVALLOC(c) EngAllocMem(0, c,gulMemID)
//#define DRVFREE(p)  EngFreeMem(p)

#endif

/*
 *   Until there is proper error logging:-
 *      WinSetError( "String" );
 *   The String appears on the debug terminal.  A \n is appended.
 */
void  WinSetError( LPSTR );

/*
 *   Function to add a copy of a string to a heap.  Returns address of copy
 *  of string (if successful) or 0 if memory cannot be allocated.
 */

LPSTR   StrToHeap( HANDLE, LPSTR );
PWSTR   StrToWHeap( HANDLE, LPSTR );            /* Expand to Wide too! */
PWSTR   WstrToHeap( HANDLE, PWSTR );            /* WIDE version */

/*
 *   Convert an ascii style string to WCHAR format, appending it to the
 *  end of the wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcat2WChar( PWSTR, LPSTR );


/*
 *   Convert an ascii style string to WCHAR format, copying it to the
 *  wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcpy2WChar( PWSTR, LPSTR );


/*
 *   The WCHAR world's equivalent of strlen():  returns the number of WCHARs
 *  in the string passed in.
 */

int  wchlen( PWSTR );

/*
 *   Concatenate a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcat( PWSTR, PWSTR );

/*
 *   Copy a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcpy( PWSTR, PWSTR );

PVOID MapFile(PWSTR);

#if NTGDIKM
/*
 *   check if two strings are identical
 */

BOOL bSameStringW(
    PWCHAR pwch1,
    PWCHAR pwch2);

/*
 *   Some system function prototypes have vanished - replace them here.
 */

void  DrvDbgPrint( char *, ... );

#if DBG
#define RIP(x) {DrvDbgPrint((PSZ)(x)); EngDebugBreak();}
#define WARNING(s) DrvDbgPrint("warning: %s",(PSZ)(s))

BOOL
SetAllocCounters(
    VOID
    );

#else
#define RIP(x)
#define WARNING(s)
#endif


LPVOID
DRVALLOC(
    DWORD  cbAlloc
    );

BOOL
DRVFREE(
    LPVOID pMem
    );

#else //NTGDIKM

/*
 *   Break into the debugger - Ye olde RIP.
 */
VOID DoRip( LPSTR );

#if DBG

#define WARNING(s) DbgPrint("warning: %s",(PSZ)(s))

#ifdef FIREWALLS
#define RIP(x) DoRip( (PSZ)(x) )
#else
#define RIP(x) {DbgPrint((PSZ)(x)); DbgBreakPoint();}
#endif

#else

#define WARNING(s)
#define RIP(x)

#endif //DBG

//
// Define kernel debugger print prototypes and macros.
// These are defined in ntrtl.h which we should include
// instead. For now, redefine them here to avoid breaking
// other components.
//

#if DBG

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

#endif



PVOID MapFile(PWSTR);


#endif //NTGDIKM

/*
 *   A simplified write function.  Returns TRUE if the WriteFile()
 * call returns TRUE and the number of bytes written equals the
 * number requested.
 *
 *  bWrite( file_handle,  address_of_data,  number_of_bytes );
 */

BOOL   bWrite( HANDLE, void  *, int );

/*
 *  Function to copy the contents of one file to another.  The files
 * are referenced via file handles.  No positioning is done - that is
 * up to the user.
 *  The second form also allows a byte count to limit the amount of data
 * copied.
 */


long  lFICopy( HANDLE, HANDLE );
long  lFInCopy( HANDLE, HANDLE, long );


/*
 *   Spooler interaction functions.  These allow drivers to call the
 * spooler directly,  without going through engine stub functions.
 */

BOOL  bSplGetFormW( HANDLE, PWSTR, DWORD, BYTE *, DWORD, DWORD * );


DWORD dwSplGetPrinterDataW( HANDLE, PWSTR, BYTE *, DWORD, DWORD * );


BOOL  bSplWrite( HANDLE, ULONG,  VOID  * );



/*  Function needed to allow the driver to reach the spooler */

BOOL   bImpersonateClient( void );


/************************** HACK ***************************************
 *   The following function is only required until the DEVMODE contains
 *   a form name rather than an index.  And even then it might be required.
 *
 ***********************************************************************/

char  *_IndexToName( int );

//
// COLORADJUSTMENT validating
//

BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    );

// Generic devmode conversion routine

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifndef KERNEL_MODE

// Copy DEVMODE to an output buffer before return to the
// caller of DrvDocumentProperties

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

// Library routine to handle common cases of DrvConvertDevmode

typedef struct {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 version private devmode

} DRIVER_VERSION_INFO, *PDRIVER_VERSION_INFO;

#define CDM_RESULT_FALSE        0
#define CDM_RESULT_TRUE         1
#define CDM_RESULT_NOT_HANDLED  2

INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    );


UINT
cdecl
DQPsprintf(
    HINSTANCE   hInst,
    LPWSTR      pwBuf,
    DWORD       cchBuf,
    LPDWORD     pcchNeeded,
    LPWSTR      pwszFormat,
    ...
    );

#endif // KERNEL_MODE

#endif // !__LIBPROTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\prnevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnevent.c

Abstract:

    Implementation of DrvPrinterEvent

Environment:

    Fax driver user interface

Revision History:

    05/10/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include <crtdbg.h>

//[RB] #include <gdispool.h>
//[RB] #include <winsprlp.h>


typedef BOOL (WINAPI *PFAXPOINTPRINTINSTALL)(LPWSTR,LPWSTR);



#define POINT_PRINT_SETUP_DLL FAX_POINT_PRINT_SETUP_DLL //[RB] use faxreg.h



LPTSTR
GetFaxServerDirectory(
    LPTSTR ServerName
    )
/*++

Routine Description:

    Find the directory containing the client setup software

Arguments:

    pServerName - Specifies the name of the print/fax server

Return Value:

    Pointer to name of the directory containing the client setup software
    NULL if there is an error

--*/

{

    LPTSTR Dir = MemAllocZ( SizeOfString(ServerName) + SizeOfString(FAX_CLIENTS_SHARE_NAME) + 16 );
    if (Dir) {
        _tcscpy( Dir, ServerName );
        _tcscat( Dir, FAX_CLIENTS_SHARE_NAME );
    }

    return Dir;
}



LPTSTR
GetClientSetupDir(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    )

/*++

Routine Description:

    Find the directory containing the client setup software

Arguments:

    pServerName - Specifies the name of the print server
    pEnvironment - Specifies the client's machine architecture

Return Value:

    Pointer to name of the directory containing the client setup software
    NULL if there is an error

--*/

#define DRIVERENV_I386      TEXT("Windows NT x86")
#define DRIVERENV_ALPHA     TEXT("Windows NT Alpha_AXP")

#define ARCHSUFFIX_I386     TEXT("i386\\")
#define ARCHSUFFIX_ALPHA    TEXT("alpha\\")


{
    LPTSTR  pClientDir, pServerDir, pArchSuffix;

    //
    // Determine the client machine's architecture
    //

    pClientDir = pServerDir = pArchSuffix = NULL;

    if (pEnvironment != NULL) {

        if (_tcsicmp(pEnvironment, DRIVERENV_I386) == EQUAL_STRING)
            pArchSuffix = ARCHSUFFIX_I386;
        else if (_tcsicmp(pEnvironment, DRIVERENV_ALPHA) == EQUAL_STRING)
            pArchSuffix = ARCHSUFFIX_ALPHA;
    }

    if (pArchSuffix == NULL) {

        Error(("Bad driver envirnment: %ws\n", pEnvironment));
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return NULL;
    }

    //
    // Get the server name and the driver directory on the server
    //

    if ((pServerName != NULL) &&
        (pServerDir = GetFaxServerDirectory(pServerName)) &&
        (pClientDir = MemAllocZ(SizeOfString(pServerDir) + SizeOfString(pArchSuffix))))
    {
        //
        // Copy the server driver directory string and truncate the last component
        //

        _tcscpy(pClientDir, pServerDir);
        _tcscat(pClientDir, pArchSuffix);

        Verbose(("Fax client setup directory: %ws\n", pClientDir));
    }

    MemFree(pServerDir);

    return pClientDir;
}




DWORD
GetLocaleDefaultPaperSize(
    VOID
    )

/*++

Routine Description:

    Retrieves the current locale defualt paper size.

Arguments:

    NONE

Return Value:

    One of the following values:  1 = letter, 5 = legal, 9 = a4

--*/

{

    WCHAR   szMeasure[2] = TEXT("9"); // 2 is maximum size for the LOCALE_IPAPERSIZE
                                      // value as defined is MSDN.

    if (!GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IPAPERSIZE, szMeasure,2))
    {
        Error(("GetLocaleDefaultPaperSize: GetLocaleInfo() failed (ec: %ld)",GetLastError()));
    }


    if (!wcscmp(szMeasure,TEXT("9")))
    {
        // A4
        return DMPAPER_A4;
    }

    if (!wcscmp(szMeasure,TEXT("5")))
    {
        // legal
        return DMPAPER_LEGAL;
    }

    //
    // Defualt value is Letter. We do not support A3.
    //
    return DMPAPER_LETTER;
}



BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    int     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
)

/*++

Routine Description:

    Implementation of DrvPrinterEvent entrypoint

Arguments:

    pPrinterName - Specifies the name of the printer involved
    DriverEvent - Specifies what happened
    Flags - Specifies misc. flag bits
    lParam - Event specific parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/

#ifdef DBG
    #define FaxClientSetupError(errMesg) { \
            Error(("%s failed: %d\n", errMesg, GetLastError())); \
            MessageBox(NULL,TEXT("FaxClientSetupError"),errMesg,MB_OK); \
            status = IDS_FAXCLIENT_SETUP_FAILED; \
            goto ExitDrvPrinterEvent; \
        }
#else
#define FaxClientSetupError(errMesg) { \
            Error(("%s failed: %d\n", errMesg, GetLastError())); \
            status = IDS_FAXCLIENT_SETUP_FAILED; \
            goto ExitDrvPrinterEvent; \
        }
#endif

{
#define FUNCTION_NAME "DrvPrinterEvent()"

    HKEY                    hRegKey = NULL;
    HANDLE                  hPrinter = NULL;
    PDRIVER_INFO_2          pDriverInfo2 = NULL;
    PPRINTER_INFO_2         pPrinterInfo2 = NULL;
    HINSTANCE               hInstFaxOcm = NULL;
    PFAXPOINTPRINTINSTALL   FaxPointPrintInstall = NULL;
    LPTSTR                  pClientSetupDir = NULL;
    INT                     status = 0;

    TCHAR                   DestPath[MAX_PATH] = {0};

    BOOL                    bFaxAlreadyInstalled = FALSE;
    BOOL                    bRes = FALSE;
    TCHAR                   FaxOcmPath[MAX_PATH] = {0};


    Verbose(("DrvPrinterEvent: %d\n", DriverEvent));

    DestPath[0] = 0;

    //
    // Ignore any event other than Initialize and AddConnection
    //

    if (DriverEvent == PRINTER_EVENT_INITIALIZE)
    {
        static PRINTER_DEFAULTS printerDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
        HANDLE  hPrinter;

        if (OpenPrinter(pPrinterName, &hPrinter, &printerDefault))
        {
            SetPrinterDataDWord(hPrinter, PRNDATA_PAPER_SIZE, GetLocaleDefaultPaperSize());
            ClosePrinter(hPrinter);
        }
        else
        {
            Error(("OpenPrinter failed: %d\n", GetLastError()));
        }

    }
    else if (DriverEvent == PRINTER_EVENT_ADD_CONNECTION)
    {
        //
        //  client 'point and print' setup is not supported anymore
        //
    }
    else if (DriverEvent == PRINTER_EVENT_ATTRIBUTES_CHANGED)
    {
        //
        // Printer attributes changed.
        // Check if the printer is now shared.
        //
        PPRINTER_EVENT_ATTRIBUTES_INFO pAttributesInfo = (PPRINTER_EVENT_ATTRIBUTES_INFO)lParam;
        Assert (pAttributesInfo);

        if (pAttributesInfo->cbSize >= (3 * sizeof(DWORD)))
        {
            //
            // We are dealing with the correct structure - see DDK
            //
            if (!(pAttributesInfo->dwOldAttributes & PRINTER_ATTRIBUTE_SHARED) &&  // The printer was not shared
                (pAttributesInfo->dwNewAttributes & PRINTER_ATTRIBUTE_SHARED))     // The printer is now shared
            {
                //
                // We shouls start the fax service
                //
                Assert (FALSE == IsDesktopSKU()); // The fax printer can not be shared on Desktop SKUs

                if (!EnsureFaxServiceIsStarted (NULL))
                {
                    Error(("EnsureFaxServiceIsStarted failed: %d\n", GetLastError()));
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\timectrl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timectrl.h

Abstract:

    For implementing a dialog control for setting time values

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _TIMECTRL_H_
#define _TIMECTRL_H_

//
// A time control consist of the following components:
//  a static text field with WS_EX_CLIENTEDGE style - encloses all other fields
//  an editable text field - hour
//  a static text field - time separator
//  an editable text field - minute
//  a listbox - AM/PM
//  a spin control - up/down arrow
//
// A time control is identified by the item ID of the first static text field.
// Rest of the items must have consecutive IDs starting from that.
//

#define TC_BORDER       0
#define TC_HOUR         1
#define TC_TIME_SEP     2
#define TC_MINUTE       3
#define TC_AMPM         4
#define TC_ARROW        5

//
// Enable or disable a time control
//

VOID
EnableTimeControl(
    HWND    hDlg,
    INT     id,
    BOOL    enabled
    );

//
// Setting the current value of a time control
//

VOID
InitTimeControl(
    HWND     hDlg,
    INT      id,
    PFAX_TIME pTimeVal
    );

//
// Retrieve the current value of a time control
//

VOID
GetTimeControlValue(
    HWND     hDlg,
    INT      id,
    PFAX_TIME pTimeVal
    );

//
// Handle dialog messages intended for a time control
//

BOOL
HandleTimeControl(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    INT     id,
    INT     part
    );

#endif // !_TIMECTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\covpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    covpg.h

Abstract:

    Functions for manipulating cover page structures

Environment:

    User mode

Revision History:

    01/04/2000 -LiranL-
              Created it.

    mm/dd/yyyy -author-
              description

--*/


#include "prtcovpg.h"


VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    );

PCOVERPAGEFIELDS
CollectCoverPageFields(
    PFAX_PERSONAL_PROFILE    lpSenderInfo,
    DWORD                    pageCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    utility functions

Environment:

        Fax configuration applet

Revision History:

        05/26/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;

static STRING_TABLE StringTable[] =
{
    { IDS_DEVICE_ENABLED,           NULL},
    { IDS_DEVICE_DISABLED,          NULL},
    { IDS_DEVICE_AUTO_ANSWER,       NULL},
    { IDS_DEVICE_MANUAL_ANSWER,     NULL}

};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))

VOID
InitializeStringTable(
    VOID
    )
/*++

Routine Description:

    Initialize the string table for future use

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    TCHAR szBuffer[256];

    for (i=0; i<CountStringTable; i++) 
    {
        if (LoadString(
            ghInstance,
            StringTable[i].ResourceId,
            szBuffer,
            sizeof(szBuffer)/sizeof(TCHAR))) 
        {
            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( szBuffer ) );
            if (!StringTable[i].String) {
                StringTable[i].String = NULL;
            } else {
                _tcscpy( StringTable[i].String, szBuffer );
            }
        } 
        else 
        {
            Error(( "LoadString failed, resource ID is %d.\n", StringTable[i].ResourceId ));
            StringTable[i].String = NULL;
        }
    }
}

VOID
DeInitializeStringTable(
    VOID
    )
/*++

Routine Description:

    Deinitialize the string table and release allocated memory

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) 
    {
        if(StringTable[i].String)
        {
            MemFree(StringTable[i].String);
            StringTable[i].String = NULL;
        }
    }
}

LPTSTR
GetString(
    DWORD ResourceId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) 
    {
        if (StringTable[i].ResourceId == ResourceId) 
        {
            return StringTable[i].String;
        }
    }

    Assert(FALSE);
    return NULL;
}


INT
DisplayErrorMessage(
    HWND    hwndParent,
    UINT    uiType,
    INT     iErrorCode,
    ...
    )

/*++

Routine Description:

    Display an Error Message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    iErrorCode - Win32 Error Code
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPTSTR      pTitle = NULL;
    LPTSTR      pFormat = NULL;
    LPTSTR      pMessage = NULL;
    INT         result;
    va_list     ap;
    HINSTANCE   hDllInst = NULL;
    INT         iStringID = 0;
    BOOL        bOK = TRUE;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        //  Load Title String
        //
        if (!LoadString(ghInstance, IDS_MSG_TITLE, pTitle, MAX_TITLE_LEN))
        {
            Error(("Failed to load preview message string. (ec: %lc)",GetLastError()));
            bOK = FALSE;
            goto Exit;
        }

        //
        //  Bring Instance of the FaxRes.DLL which contains our Message String Resources
        //
        hDllInst = GetResInstance();

        //
        // Load Error Message 
        //
        iStringID = GetRpcErrorStringId(iErrorCode);
        if (!LoadString(hDllInst, iStringID, pFormat, MAX_STRING_LEN))
        {
            Error(("Failed to load preview message string. (ec: %lc)",GetLastError()));
            bOK = FALSE;
            goto Exit;
        }

        //
        // Compose the message string
        //
        va_start(ap, iErrorCode);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //
        if (uiType == 0)
        {
            uiType = MB_OK | MB_ICONERROR;
        }

        result = AlignedMessageBox(hwndParent, pMessage, pTitle, uiType);
    } 
    else 
    {
        bOK = FALSE;
    }

Exit:
    if (!bOK)
    {
        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);

    return result;
}

BOOL IsLocalPrinter(
    LPTSTR pPrinterName
    )

/*++

Routine Description:

    Check whether given printer is local

Arguments:

    pPrinterName - giver printer name

Return Value:

    TRUE if it's local, FALSE otherwise

--*/

{
    DWORD ErrorCode = 0;
    BOOL Found = FALSE;
    PPRINTER_INFO_4 pPrinterInfo = NULL;
    DWORD BytesNeeded = 0;
    DWORD NumPrinters = 0;
    PPRINTER_INFO_4 pCurrPrinterInfo;

    //
    // enumerate local printers
    //
    if (EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &BytesNeeded, &NumPrinters))
    {
        // if succeeds, there are no printers
        goto CleanUp;
    }
    else if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            || !(pPrinterInfo = (PPRINTER_INFO_4) GlobalAlloc(GMEM_FIXED, BytesNeeded))
            || !EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE) pPrinterInfo,
                BytesNeeded, &BytesNeeded, &NumPrinters))
    {
        ErrorCode = GetLastError();
        goto CleanUp;
    }

    for (pCurrPrinterInfo = pPrinterInfo;
        !Found && (pCurrPrinterInfo < (pPrinterInfo + NumPrinters));
        pCurrPrinterInfo++)
    {
        // check for printer name
        if (!lstrcmpi(pCurrPrinterInfo->pPrinterName, pPrinterName))
        {
            Found = TRUE;
        }
    }

CleanUp:

    if (pPrinterInfo)
    {
        GlobalFree(pPrinterInfo);
    }

    SetLastError(ErrorCode);
    return Found;
}

BOOL
IsFaxServiceRunning(
    LPTSTR  lpMachineName
)

/*++

Routine Description:

    Check whether fax service is started in specified computer

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine

Return Value:

    TRUE if service is started, FALSE if service is not started or error.

--*/

{
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  Status;

    ZeroMemory(&Status, sizeof(Status));

    hSvcMgr = OpenSCManager(lpMachineName, NULL, SC_MANAGER_CONNECT);
    if (!hSvcMgr) {
        goto ExitLevel0;
    }

    hService = OpenService(hSvcMgr, FAX_SERVICE_NAME, SERVICE_QUERY_STATUS);
    if (!hService) {
        goto ExitLevel1;
    }

    QueryServiceStatus(hService, &Status);

ExitLevel1:
    if (hService) {
        CloseServiceHandle(hService);
    }

ExitLevel0:
    if (hSvcMgr) {
        CloseServiceHandle(hSvcMgr);
    }

    return (Status.dwCurrentState == SERVICE_RUNNING) ? TRUE : FALSE;
}


VOID
DisConnect(
)
/*++

Routine Description:

    Close current connection to the fax service

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_hFaxSvcHandle) {
        FaxClose(g_hFaxSvcHandle);
        g_hFaxSvcHandle = NULL;
    }
}

BOOL
Connect(
    HWND    hDlg,
    BOOL    bDisplayErrorMessage
)
/*++

Routine Description:

    Connect to the fax service

Arguments:

    hDlg - the caller window handle
    bDisplayErrorMessage - indicate whether display the error message to the user

Return Value:

    TRUE if successfully connected, FALSE if there is an error.

--*/

{
    DWORD   dwRes = 0;

    //
    // Check if already connected to the fax service
    //
    if (g_hFaxSvcHandle) 
    {
        return TRUE;
    }

    //
    // Connect to the fax service
    //
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        dwRes = GetLastError();

        Error(( "Can't connect to the fax server, ec = %d.\n", dwRes));

        if(bDisplayErrorMessage)
        {
            DisplayErrorMessage(hDlg, 0, dwRes);
        }

        return FALSE;
    }

    return TRUE;
}


BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    TCHAR   pFullDirectoryName[MAX_PATH];
    DWORD   dwFileAttributes;
    DWORD   dwSize;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwSize = ExpandEnvironmentStrings(pDirectoryName, pFullDirectoryName, MAX_PATH);
    if(dwSize == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pFullDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }

    return FALSE;
}

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
)

/*++

Routine Description:

    Get or set the current status of a routing method for specific device

Arguments:

    hFaxHandle - fax handle by FaxConnectFaxServer()
    dwDeviceId - device ID
    pRoutingGuid - GUID that identifies the fax routing method
    Enabled - enabled status for the device and method, if Enabled is QUERY_STATUS, 
            it means return value is the current state

Return Value:

    if Enabled is QUERY_STATUS, return the current state of routing method;
    if Enabled is QUERY_ENABLE or QUERY_DISABLE, return TRUE for success, FALSE for failure.

--*/

{
    HANDLE  hFaxPortHandle = NULL;
    BOOL    bResult = FALSE;
    LPBYTE  pRoutingInfoBuffer = NULL;
    DWORD   dwRoutingInfoBufferSize;

    Assert(hFaxHandle);
    if(!hFaxHandle || !FaxOpenPort(hFaxHandle, dwDeviceId, PORT_OPEN_QUERY | PORT_OPEN_MODIFY, &hFaxPortHandle))
    {
        goto exit;
    }

    if(!FaxGetRoutingInfo(hFaxPortHandle, pRoutingGuid, &pRoutingInfoBuffer, &dwRoutingInfoBufferSize))
    {
        goto exit;
    }

    if(Enabled == QUERY_STATUS)
    {
        //
        // for query status
        // 
        bResult = *((LPDWORD)pRoutingInfoBuffer) > 0 ? TRUE : FALSE;
    }
    else
    {
        //
        // for set status
        // 
        *((LPDWORD)pRoutingInfoBuffer) = (Enabled == STATUS_ENABLE) ? TRUE : FALSE;
        if(FaxSetRoutingInfo(hFaxPortHandle, pRoutingGuid, pRoutingInfoBuffer, dwRoutingInfoBufferSize))
        {
            bResult = TRUE;
        }
    }

exit:
    if(pRoutingInfoBuffer) { FaxFreeBuffer(pRoutingInfoBuffer); }
    if(hFaxPortHandle) { FaxClose(hFaxPortHandle); }
    return bResult;
}

int CALLBACK BrowseCallbackProc(
    HWND    hDlg,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  dwData)

/*++

Routine Description:

    We use this callback function to specify the initial folder

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    uMsg - Value identifying the event. 
    lParam - Value dependent upon the message contained in the uMsg parameter. 
    dwData - Application-defined value that was specified in the lParam member of the BROWSEINFO structure. 

Return Value:

    Returns zero.

--*/

{
    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hDlg, BFFM_SETSELECTION, TRUE, dwData);
            break;

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hDlg, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

    }

    return 0;
}

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    LPTSTR title
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    hResource - resource id to receive the directory 
    title - the title to be shown in the browse dialog

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    BOOL            bResult = FALSE;
    LPMALLOC        pMalloc = NULL;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE,
        BrowseCallbackProc,
        (LPARAM) buffer,
    };

    Verbose(("Entering BrowseForDirectory...\n"));

    if (!GetDlgItemText( hDlg, hResource, buffer, MAX_PATH))
        buffer[0] = 0;

    SHGetMalloc(&pMalloc);

    if (pidl = SHBrowseForFolder(&bi)) 
    {
        if (SHGetPathFromIDList(pidl, buffer)) 
        {
            if (lstrlen(buffer) > MAX_ARCHIVE_DIR)
                DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_NAME_IS_TOO_LONG);
            else 
            {
                SetDlgItemText(hDlg, hResource, buffer);
                bResult = TRUE;
            }
        }

        pMalloc->lpVtbl->Free(pMalloc, (LPVOID)pidl);

    }

    pMalloc->lpVtbl->Release(pMalloc);

    return bResult;
}

LPTSTR
ValidatePath(
    LPTSTR szPath
    )

/*++

Routine Description:

    Check and remove the '\' at the end of the string

Arguments:

    szPath - string pointer

Return Value:

    return the new string pointer

--*/

{
    DWORD i;

    if (szPath == NULL || szPath[0] == 0) 
    {
        return szPath;
    }

    i = lstrlen(szPath)-1;
    for (; i>0; i--) 
    {
        if (szPath[i] == TEXT('\\')) 
        {
            szPath[i] = 0;
        }
        else
        {
            break;
        }
    }

    return szPath;
}

PFAX_PORT_INFO_EX
FindPortInfo(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Find FAX_PORT_INFO_EX by dwDeviceId in g_pFaxPortInfo

Arguments:

    dwDeviceId - [in] device ID to find

Return Value:

    pointer to FAX_PORT_INFO_EX structure if found
    NULL otherwise

--*/
{
    DWORD dw;

    if(!g_pFaxPortInfo || !g_dwPortsNum)
    {
        return NULL;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        if(g_pFaxPortInfo[dw].dwDeviceID == dwDeviceId)
        {
            return &g_pFaxPortInfo[dw];
        }
    }           
    
    return NULL;
}

BOOL 
CALLBACK 
PageEnableProc(
  HWND   hwnd,    
  LPARAM lParam 
)
/*++

Routine Description:

    Disable each control of a property page

Arguments:

    hwnd   - [in] handle to child window
    lParam - [in] BOOL bEnable

Return Value:

    TRUE to continue enumeration

--*/
{
    EnableWindow(hwnd, (BOOL)lParam);
    return TRUE;
}


void
PageEnable(
    HWND hDlg,
    BOOL bEnable
)
/*++

Routine Description:

    Enumerate and enable/disable all controls of a property page

Arguments:

    hDlg    - [in] property page handle
    bEnable - [in] TRUE for enable, FALSE for disable

Return Value:

    none

--*/
{
    if(!EnumChildWindows(hDlg, PageEnableProc, (LPARAM)bEnable))
    {
        Error(( "EnumChildWindows failed with %d\n", GetLastError()));
    }
}

DWORD
CountUsedFaxDevices()
/*++

Routine Description:

    Count the number of the devices configured to send or receive faxes

Arguments:

  none

Return Value:

    Number of the fax devices

--*/
{
    DWORD dw;
    DWORD dwNum=0;

    if(!g_pFaxPortInfo || !g_dwPortsNum)
    {
        return dwNum;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        if(g_pFaxPortInfo[dw].bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != g_pFaxPortInfo[dw].ReceiveMode))
        {
            ++dwNum;
        }
    }           
    return dwNum;
}

BOOL
IsDeviceInUse(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Determine whether the device is configured for send or receive

Arguments:

    dwDeviceId - [in] Device ID

Return Value:

    TRUE if the device is configured for send or receive
    FALSE otherwise

--*/
{
    PFAX_PORT_INFO_EX pPortInfo = FindPortInfo(dwDeviceId);
    if(!pPortInfo)
    {
        return FALSE;
    }

    if(pPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pPortInfo->ReceiveMode))
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\infowzrd.h ===
#ifndef __INFOWZRD_H_
#define __INFOWZRD_H_

#include <windows.h>
#include <fxsapip.h>
#include <faxsendw.h>

HRESULT	WINAPI
FaxFreeSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxSetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxGetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT WINAPI 
FaxSendWizard(
		IN  DWORD					hWndOwner,
		IN  DWORD					dwFlags,
		IN  LPTSTR					lptstrServerName,
		IN	LPTSTR					lptstrPrinterName,
		IN	LPFAX_SEND_WIZARD_DATA	lpInitialData,
		OUT	LPTSTR					lptstrTifName,
		OUT	LPFAX_SEND_WIZARD_DATA	lpFaxSendWizardData
   );

HRESULT WINAPI 
FaxFreeSendWizardData(
		LPFAX_SEND_WIZARD_DATA	lpFaxSendWizardData
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\faxlib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxlib.h

Abstract:

    Fax driver library header file

Environment:

        Fax driver, kernel and user mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXLIB_H_
#define _FAXLIB_H_

#ifdef __cplusplus
extern "C" {
#endif


#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <tchar.h>
#include <shlobj.h>
#include <fxsapip.h>

#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <faxreg.h>

#define FAXUTIL_ADAPTIVE
#define FAXUTIL_DEBUG
#include <faxutil.h>


#else   // !KERNEL_MODE

#include <winddi.h>


//
// Nul terminator for a character string
//

#define NUL             0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)


#ifdef USERMODE_DRIVER
    
#include <windows.h>
#include <winspool.h>

#endif

#endif


#include "devmode.h"
#include "prndata.h"
#include "registry.h"

#define AllocString(cch)    MemAlloc(sizeof(TCHAR) * (cch))
#define AllocStringZ(cch)   MemAllocZ(sizeof(TCHAR) * (cch))

//
// Result of string comparison
//

#define EQUAL_STRING    0

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif

//
// Path separator character
//

#define PATH_SEPARATOR  '\\'

//
// Filename extension character
//

#define FILENAME_EXT    '.'

//
// Deal with the difference between user and kernel mode functions
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    #define WritePrinter        EngWritePrinter
    #define GetPrinterData      EngGetPrinterData
    #define EnumForms           EngEnumForms
    #define GetPrinter          EngGetPrinter
    #define GetForm             EngGetForm
    #define SetLastError        EngSetLastError
    #define GetLastError        EngGetLastError
    #define MulDiv              EngMulDiv
    
    #define MemAlloc(size)      EngAllocMem(0, size, DRIVER_SIGNATURE)
    #define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, DRIVER_SIGNATURE)
    #define MemFree(ptr)        { if (ptr) EngFreeMem(ptr); }

#else // !KERNEL_MODE

    #ifndef MemAlloc  
        #define MemAlloc(size)      ((PVOID) LocalAlloc(LPTR, (size)))
    #endif    
    #ifndef MemAllocZ 
        #define MemAllocZ(size)     ((PVOID) MemAlloc((size)))
    #endif
    #ifndef MemFree   
        #define MemFree(ptr)        { if (ptr) LocalFree((HLOCAL) (ptr)); }
    #endif        

#endif


//
// Copy Unicode or ANSI string from source to destination
//

VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    );

VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    );

#ifdef  UNICODE
#define CopyString  CopyStringW
#else   // !UNICODE
#define CopyString  CopyStringA
#endif

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Strip the directory prefix from a filename (ANSI version)
//

PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    );

//
// Wrapper function for GetPrinter spooler API
//

PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriver spooler API
//

PVOID
MyGetPrinterDriver(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriverDirectory spooler API
//

LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    );


//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  A variable which controls the amount of debug messages. To generate
//  lots of debug messages, enter the following line in the debugger:
//
//      ed _debugLevel 1
//
// Verbose
//  Display a debug message if VERBOSE is set to non-zero.
//
//      Verbose(("Entering XYZ: param = %d\n", param));
//
// Error
//  Display an error message along with the filename and the line number
//  to indicate where the error occurred.
//
//      Error(("XYZ failed"));
//
// ErrorIf
//  Display an error message if the specified condition is true.
//
//      ErrorIf(error != 0, ("XYZ failed: error = %d\n", error));
//
// Assert
//  Verify a condition is true. If not, force a breakpoint.
//
//      Assert(p != NULL && (p->flags & VALID));

#if DBG

extern ULONG __cdecl DbgPrint(CHAR *, ...);
extern INT _debugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
#define DbgBreakPoint EngDebugBreak
#else
extern VOID DbgBreakPoint(VOID);
#endif

#define Warning(arg) {\
            DbgPrint("WRN %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Error(arg) {\
            DbgPrint("ERR %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Verbose(arg) { if (_debugLevel > 0) DbgPrint arg; }
#define ErrorIf(cond, arg) { if (cond) Error(arg); }
#define Assert(cond) {\
            if (! (cond)) {\
                DbgPrint("ASSERT: file %s, line %d\n", StripDirPrefixA(__FILE__), __LINE__);\
                DbgBreakPoint();\
            }\
        }

#else   // !DBG

#define Verbose(arg)
#define ErrorIf(cond, arg)
#define Assert(cond)
#define Warning(arg)
#define Error(arg)

#endif

#ifdef __cplusplus
}
#endif

#endif  //!_FAXLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\halftone.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    halftone.c


Abstract:

    This module contains data and function to validate the COLORADJUSTMENT


Author:

    27-Oct-1995 Fri 15:48:17 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifdef NTGDIKM
#include        <stddef.h>
#include        <stdarg.h>
#include        <windef.h>
#include        <wingdi.h>
#include        <winddi.h>
#else
#include        <stddef.h>
#include        <windows.h>
#include        <winddi.h>
#endif

DEVHTINFO    DefDevHTInfo = {

        HT_FLAG_HAS_BLACK_DYE,
        HT_PATSIZE_6x6_M,
        0,                                  // DevPelsDPI

        {
            { 6380, 3350,       0 },        // xr, yr, Yr
            { 2345, 6075,       0 },        // xg, yg, Yg
            { 1410,  932,       0 },        // xb, yb, Yb
            { 2000, 2450,       0 },        // xc, yc, Yc Y=0=HT default
            { 5210, 2100,       0 },        // xm, ym, Ym
            { 4750, 5100,       0 },        // xy, yy, Yy
            { 3127, 3290,       0 },        // xw, yw, Yw=0=default

            12500,                          // R gamma
            12500,                          // G gamma
            12500,                          // B gamma, 12500=Default

            585,   120,                     // M/C, Y/C
              0,     0,                     // C/M, Y/M
              0, 10000                      // C/Y, M/Y  10000=default
        }
    };


COLORADJUSTMENT  DefHTClrAdj = {

        sizeof(COLORADJUSTMENT),
        0,
        ILLUMINANT_DEVICE_DEFAULT,
        10000,
        10000,
        10000,
        REFERENCE_BLACK_MIN,
        REFERENCE_WHITE_MAX,
        0,
        0,
        0,
        0
    };



#define ADJ_CA(p,a,i,x) if ((p->a<i)||(p->a>x)){Ok=FALSE;p->a=DefHTClrAdj.a;}



BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    )

/*++

Routine Description:

    This function validate and adjust the invalid color adjustment fields

Arguments:

    pca - Pointer to the COLORADJUSTMENT data structure


Return Value:

    TRUE if everything in the range FALSE otherwise


Author:

    02-Dec-1993 Thu 22:45:59 created  -by-  Daniel Chou (danielc)


Revision History:

    02-Apr-1995 Sun 11:19:04 updated  -by-  Daniel Chou (danielc)
        Update the RGB_GAMMA_MIN/MAX checking and make default to 1.0


--*/

{
    BOOL    Ok = TRUE;

    //
    // Validate the color adjustment
    //

    if ((pca->caSize != sizeof(COLORADJUSTMENT)) ||
        (pca->caFlags & ~(CA_NEGATIVE | CA_LOG_FILTER))) {

        *pca = DefHTClrAdj;
        return(FALSE);
    }

    ADJ_CA(pca, caIlluminantIndex,  0,                  ILLUMINANT_MAX_INDEX);
    ADJ_CA(pca, caRedGamma,         RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caGreenGamma,       RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caBlueGamma,        RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caReferenceBlack,   0,                  REFERENCE_BLACK_MAX );
    ADJ_CA(pca, caReferenceWhite,   REFERENCE_WHITE_MIN,10000               );
    ADJ_CA(pca, caContrast,         COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caBrightness,       COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caColorfulness,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caRedGreenTint,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\prndata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.h

Abstract:

    Funtions for dealing with printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _PRNDATA_H_
#define _PRNDATA_H_

//
// Default discount rate period: 8:00pm to 7:00am
//

#define DEFAULT_STARTCHEAP  MAKELONG(20, 0)
#define DEFAULT_STOPCHEAP   MAKELONG(7, 0)

#define PRNDATA_PERMISSION  TEXT("Permission")
#define PRNDATA_PAPER_SIZE  TEXT("PaperSize")

//
// Get a string value from the PrinterData registry key
//

LPTSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey
    );

//
// Save a string value to the PrinterData registry key
//

BOOL
SetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    LPTSTR  pValue
    );

//
// Get a DWORD value from the registry
//

DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   defaultValue
    );

//
// Save a DWORD value to the registry
//

BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   value
    );

#endif // !_PRNDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\devmode.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devmode.h

Abstract:

    DEVMODE related declarations and definitions

Environment:

        Fax driver, user and kernel mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _DEVMODE_H_
#define _DEVMODE_H_

//
// Driver version number and signatures
//
#include <faxreg.h>

#define DRIVER_VERSION      0x400   // driver version number
#define DRIVER_SIGNATURE    'xafD'  // driver signature
#ifndef WIN95
#define DRIVER_NAME         FAX_DRIVER_NAME
#else
#define DRIVER_NAME         "Microsoft Fax Client"

#endif

//
// Maximum length of some strings in the private portion of devmode
//

#define MAX_BILLING_CODE        16
#define MAX_SENDER_NAME         64
#define MAX_RECIPIENT_NAME      64
#define MAX_RECIPIENT_NUMBER    64
#define MAX_SUBJECT_LINE        128
#define MAX_EMAIL_ADDRESS       128

//
// Maximum TIFF file size for a single page
//
#define MAX_TIFF_PAGE_SIZE      0x200000    // 2Mb


//
// Preview map file header
//
typedef struct _MAP_TIFF_PAGE_HEADER
{
    DWORD cb;
    DWORD dwDataSize;
    INT iPageCount;
    BOOL bPreview;
} MAP_TIFF_PAGE_HEADER, *PMAP_TIFF_PAGE_HEADER;


//
// PostScript driver private devmode fields
//

typedef struct {

    DWORD       signature;          // private devmode signature
    DWORD       flags;              // flag bits
    INT         sendCoverPage;      // whether to send cover page
    INT         whenToSend;         // "Time to send" option
    FAX_TIME    sendAtTime;         // specific time to send
    DWORD       reserved[8];        // reserved

    //
    // Private fields used for passing info between kernel and user mode DLLs
    //  pointer to user mode memory
    //

    PVOID       pUserMem;           // PDOCEVENTUSERMEM

    //
    // Billing code
    //

    TCHAR       billingCode[MAX_BILLING_CODE];

    //
    // email address for delivery reports
    //

    TCHAR       emailAddress[MAX_EMAIL_ADDRESS];

    //
    // Mapping file for driver communication (Used by Print preview).
    //

    TCHAR       szMappingFile[MAX_PATH];
} DMPRIVATE, *PDMPRIVATE;

typedef struct {

    DEVMODE     dmPublic;           // public devmode fields
    DMPRIVATE   dmPrivate;          // private devmode fields

} DRVDEVMODE, *PDRVDEVMODE;

//
// Check if a devmode structure is current version
//

#define CurrentVersionDevmode(pDevmode) \
        ((pDevmode) != NULL && \
         (pDevmode)->dmSpecVersion == DM_SPECVERSION && \
         (pDevmode)->dmDriverVersion == DRIVER_VERSION && \
         (pDevmode)->dmSize == sizeof(DEVMODE) && \
         (pDevmode)->dmDriverExtra == sizeof(DMPRIVATE))


//
// Constant flag bits for DMPRIVATE.flags field
//

#define FAXDM_NO_HALFTONE    0x0001 // don't halftone bitmap images
#define FAXDM_1D_ENCODING    0x0002 // use group3 1D encoding
#define FAXDM_NO_WIZARD      0x0004 // bypass wizard
#define FAXDM_DRIVER_DEFAULT 0x0008 // driver default devmode

//
// Default form names and form sizes
//

#define FORMNAME_LETTER     TEXT("Letter")
#define FORMNAME_A4         TEXT("A4")
#define FORMNAME_LEGAL      TEXT("Legal")

#define LETTER_WIDTH        215900  // 8.5" in microns
#define LETTER_HEIGHT       279400  // 11" in microns
#define A4_WIDTH            210000  // 210mm in microns
#define A4_HEIGHT           297000  // 297mm in microns

//
// Default resolutions for fax output
//

#define FAXRES_HORIZONTAL   200
#define FAXRES_VERTICAL     200
#define FAXRES_VERTDRAFT    100

//
// Maximum allowable bitmap size (in pixels) for fax output
//

#define MAX_WIDTH_PIXELS    1728
#define MAX_HEIGHT_PIXELS   2800

//
// Retrieve driver default devmode
//

VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    );

//
// Merge the source devmode into the destination devmode
//

BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    );

//
// NOTE: These are defined in printers\lib directory. Declare them here to
// avoid including libproto.h and dragging in lots of other junk.
//

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifdef KERNEL_MODE

extern DEVHTINFO DefDevHTInfo;
extern COLORADJUSTMENT DefHTClrAdj;

#endif

#endif // !_DEVMODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\coverpg.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for manipulating cover page structures

Environment:

	Fax driver, user mode

Revision History:

	01/04/2000 -LiranL-
		Created it.

	mm/dd/yyyy -author-
		description

--*/


#include "faxlib.h"
#include "faxutil.h"
#include "covpg.h"

VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Free up memory used to hold the cover page information

Arguments:

    pCPFields - Points to a COVERPAGEFIELDS structure

Return Value:

    NONE

--*/

{
    if (pCPFields == NULL)
        return;

    //
    // NOTE: We don't need to free the following fields here because they're
    // allocated and freed elsewhere and we're only using a copy of the pointer:
    //  RecName
    //  RecFaxNumber
    //  Note
    //  Subject
    //

    MemFree(pCPFields->SdrName);
    MemFree(pCPFields->SdrFaxNumber);
    MemFree(pCPFields->SdrCompany);
    MemFree(pCPFields->SdrAddress);
    MemFree(pCPFields->SdrTitle);
    MemFree(pCPFields->SdrDepartment);
    MemFree(pCPFields->SdrOfficeLocation);
    MemFree(pCPFields->SdrHomePhone);
    MemFree(pCPFields->SdrOfficePhone);

    MemFree(pCPFields->NumberOfPages);
    MemFree(pCPFields->TimeSent);

    MemFree(pCPFields);
}



PCOVERPAGEFIELDS
CollectCoverPageFields(
	PFAX_PERSONAL_PROFILE	lpSenderInfo,
    DWORD					pageCount
    )

/*++

Routine Description:

    Collect cover page information into the fields of a newly allocated COVERPAGEFIELDS structure. 
	Fills sender information using the client registry. The following fields are filled:
		SdrName
		SdrCompany
		SdrAddress
		SdrTitle
		SdrDepartment
		SdrOfficeLocation
		SdrHomePhone
		SdrOfficePhone
		SdrFaxNumber
	NumberOfPages = pageCount
	TimeSent = formatted date/time string of the current time (calculated at this point)

Arguments:

    pageCount - Total number of pages (including cover pages)

Return Value:

    Pointer to a newly allocated COVERPAGEFIELDS structure, NULL if there is an error.
	It is up to the caller to free this structure using FreeCoverPageFields() which takes
	care of freeing the fields as well.

--*/

#define FillCoverPageField(DestField, SourceField) { \
			if (lpSenderInfo->SourceField && !(pCPFields->DestField = StringDup(lpSenderInfo->SourceField))) \
			{ \
				Error(("Memory allocation failed\n")); \
				goto error;	\
			} \
        }

{
    PCOVERPAGEFIELDS    pCPFields = NULL;
    INT                 dateTimeLen = 0;

    //
    // Allocate memory to hold the top level structure
    // and open the user info registry key for reading
    //

    if (! (pCPFields = MemAllocZ(sizeof(COVERPAGEFIELDS))))
    {
        return NULL;
    }

	ZeroMemory(pCPFields,sizeof(COVERPAGEFIELDS));

    //
    // Read sender information from the registry
    //

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    FillCoverPageField(SdrName,           lptstrName);
    FillCoverPageField(SdrCompany,        lptstrCompany);
    FillCoverPageField(SdrTitle,          lptstrTitle);
    FillCoverPageField(SdrDepartment,     lptstrDepartment);
    FillCoverPageField(SdrOfficeLocation, lptstrOfficeLocation);
    FillCoverPageField(SdrHomePhone,      lptstrHomePhone);
    FillCoverPageField(SdrOfficePhone,    lptstrOfficePhone);
    FillCoverPageField(SdrFaxNumber,      lptstrFaxNumber);
    FillCoverPageField(SdrAddress,        lptstrStreetAddress);

    //
    // Number of pages and current local system time
    //

    if (pCPFields->NumberOfPages = MemAllocZ(sizeof(TCHAR) * 16))
    {
        wsprintf(pCPFields->NumberOfPages, TEXT("%d"), pageCount);
    }
	else
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }


    //
    // When the fax was sent
    //

    dateTimeLen = 128;

    if (pCPFields->TimeSent = MemAllocZ(sizeof(TCHAR) * dateTimeLen)) 
    {

        LPTSTR  p = pCPFields->TimeSent;
        INT     cch;

        if (!GetY2KCompliantDate(LOCALE_USER_DEFAULT, 0, NULL, p, dateTimeLen))
		{
			Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
			goto error;
		}

        cch = _tcslen(p);
        p += cch;

        if (++cch < dateTimeLen) 
        {

            *p++ = (TCHAR)' ';
            dateTimeLen -= cch;

            FaxTimeFormat(LOCALE_USER_DEFAULT, 0, NULL, NULL, p, dateTimeLen);
        }
    }
	else 
    {
        Error(("Memory allocation failed\n"));
		goto error;
	}

    return pCPFields;
error:

	FreeCoverPageFields(pCPFields);

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\devmode.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    devmode.c


Abstract:

    This module contains devmode conversion


Author:

    08-Jun-1995 Thu 13:47:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI printer drivers, user and kernel mode


[Notes:]


Revision History:

    11/09/95 -davidx-
        New conversion routines

--*/


#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <libproto.h>


//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

//
// size of a device name string
//

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _devicemode320A {
    BYTE    dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    BYTE    dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320A, *PDEVMODE320A, *NPDEVMODE320A, *LPDEVMODE320A;

typedef struct _devicemode320W {
    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320W, *PDEVMODE320W, *NPDEVMODE320W, *LPDEVMODE320W;



#ifdef UNICODE

typedef DEVMODE320W     DEVMODE320;
typedef PDEVMODE320W    PDEVMODE320;
typedef NPDEVMODE320W   NPDEVMODE320;
typedef LPDEVMODE320W   LPDEVMODE320;

#else

typedef DEVMODE320A     DEVMODE320;
typedef PDEVMODE320A    PDEVMODE320;
typedef NPDEVMODE320A   NPDEVMODE320;
typedef LPDEVMODE320A   LPDEVMODE320;

#endif // UNICODE


typedef struct _DMEXTRA400 {
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
} DMEXTRA400;


typedef struct _DMEXTRA401 {
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DMEXTRA401;


#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))

// Current version devmode size - public portion only

#ifdef  UNICODE
#define DM_SIZE_CURRENT sizeof(DEVMODEW)
#else
#define DM_SIZE_CURRENT sizeof(DEVMODEA)
#endif



WORD
CheckDevmodeVersion(
    PDEVMODE pdm
    )

/*++

Routine Description:

    Verify dmSpecVersion and dmSize fields of a devmode

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    0 if the input devmode is unacceptable
    Otherwise, return the expected dmSpecVersion value

--*/

{
    WORD    expectedVersion;

    if (pdm == NULL)
        return 0;

    // Check against known devmode sizes

    switch (pdm->dmSize) {

    case DM_SIZE320:
        expectedVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        expectedVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        expectedVersion = DM_SPECVERSION401;
        break;

    default:
        expectedVersion = pdm->dmSpecVersion;
        break;
    }


    return expectedVersion;
}



LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Convert an input devmode to a different version devmode.

    Whenever driver gets an input devmode, it should call this
    routine to convert it to current version.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized/valid output devmode

Return Value:

    Total number of bytes copied
    -1 if either input or output devmode is invalid

--*/

{
    WORD    dmSpecVersion, dmDriverVersion;
    WORD    dmSize, dmDriverExtra;
    LONG    cbCopied = 0;

    // Look for inconsistency between dmSpecVersion and dmSize

    if (! CheckDevmodeVersion(pdmIn) ||
        ! (dmSpecVersion = CheckDevmodeVersion(pdmOut)))
    {
        return -1;
    }

    // Copy public devmode fields

    dmDriverVersion = pdmOut->dmDriverVersion;
    dmSize = pdmOut->dmSize;
    dmDriverExtra = pdmOut->dmDriverExtra;

    cbCopied = min(dmSize, pdmIn->dmSize);
    memcpy(pdmOut, pdmIn, cbCopied);

    pdmOut->dmSpecVersion = dmSpecVersion;
    pdmOut->dmDriverVersion = dmDriverVersion;
    pdmOut->dmSize = dmSize;
    pdmOut->dmDriverExtra = dmDriverExtra;

    // Copy private devmode fields

    cbCopied += min(dmDriverExtra, pdmIn->dmDriverExtra);
    memcpy((PBYTE) pdmOut + pdmOut->dmSize,
           (PBYTE) pdmIn + pdmIn->dmSize,
           min(dmDriverExtra, pdmIn->dmDriverExtra));

    return cbCopied;
}



#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Copy a source devmode to an output devmode buffer.

    Driver should call this routine before it returns to the caller
    of DrvDocumentProperties.

Arguments:

    pdmSrc - Points to a current version source devmode
    pdmIn - Points to input devmode passed to DrvDocumentProperties
    pdmOut - Output buffer pointer passed to DrvDocumentProperties

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (pdmIn == NULL) {

        memcpy(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;

    } else {

        // We have to deal with the public fields and private fields
        // separately. Also remember pdmIn and pdmOut may point to
        // the same buffer.

        // Public fields: take dmSpecVersion and dmSize from
        // the smaller of pdmSrc and pdmIn

        if (pdmIn->dmSize < pdmSrc->dmSize) {

            pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
            pdmOut->dmSize        = pdmIn->dmSize;

        } else {

            pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
            pdmOut->dmSize        = pdmSrc->dmSize;
        }

        // Similarly for private fields

        if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra) {

            pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;

        } else {

            pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
        }

        return ConvertDevmode(pdmSrc, pdmOut) > 0;
    }
}



INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    )

/*++

Routine Description:

    Library routine to handle common cases of DrvConvertDevMode

Arguments:

    pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode
        Correspond to parameters passed to DrvConvertDevMode
    pDriverVersions - Specifies driver version numbers and private devmode sizes

Return Value:

    CDM_RESULT_TRUE
        If the case is handled by the library routine and driver
        shoud return TRUE to the caller of DrvConvertDevMode.

    CDM_RESULT_FALSE
        If the case is handled by the library routine and driver
        shoud return FALSE to the caller of DrvConvertDevMode.

    CDM_RESULT_NOT_HANDLED
        The case is NOT handled by the library routine and driver
        should continue on with whatever it needs to do.

--*/

{
    LONG    size;

    // Make sure pcbNeeded parameter is not NULL

    if (pcbNeeded == NULL) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return CDM_RESULT_FALSE;
    }

    switch (fMode) {

    case CDM_CONVERT:

        // Convert any input devmode to any output devmode.
        // Both input and output must be valid.

        if (pdmOut != NULL &&
            *pcbNeeded >= (pdmOut->dmSize + pdmOut->dmDriverExtra) &&
            ConvertDevmode(pdmIn, pdmOut) > 0)
        {
            *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
            return CDM_RESULT_TRUE;
        }
        break;

    case CDM_CONVERT351:

        // Convert any input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE320 + pDriverVersions->dmDriverExtra351;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // Do the conversion from input devmode to 3.51 devmode

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = pDriverVersions->dmDriverVersion351;
        pdmOut->dmDriverExtra = pDriverVersions->dmDriverExtra351;

        if (ConvertDevmode(pdmIn, pdmOut) > 0) {

            *pcbNeeded = size;
            return CDM_RESULT_TRUE;
        }

        break;

    case CDM_DRIVER_DEFAULT:

        // Convert any input devmode to current version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE_CURRENT + pDriverVersions->dmDriverExtra;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // This case (getting driver-default devmode) is not handled
        // by the library routine.

        *pcbNeeded = size;

        // FALL THROUGH TO THE DEFAULT CASE!

    default:
        return CDM_RESULT_NOT_HANDLED;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return CDM_RESULT_FALSE;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\inc\registry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reguser.h

Abstract:

    For accessing information stored under registry key:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _REGISTRY_H_
#define _REGISTRY_H_

//
// Maximum length allowed for a string value (including the null terminator)
//

#define MAX_STRING_LEN      MAX_PATH

//
// Open a handle to the specified registry key
//

#define REG_READONLY    KEY_READ
#define REG_READWRITE   KEY_ALL_ACCESS

#define GetUserInfoRegKey(pKeyName, readOnly) \
        OpenRegistryKey(HKEY_CURRENT_USER, pKeyName, FALSE,readOnly)



//
// Get a EXPAND_SZ value from the user info registry key
//

LPTSTR
GetRegistryExpandStr(
    HKEY    hRootKey,
    LPTSTR  pKeyName,
    LPTSTR  pValueName
    );

//
// Get per-user devmode information
//

PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    );

//
// Save per-user devmode information
//

VOID
SavePerUserDevmode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDevmode
    );

//
// Find the cover page editor executable filename
//

LPTSTR
GetCoverPageEditor(
    VOID
    );

//
// Find the directories under which user cover pages are stored
//

LPTSTR
GetUserCoverPageDir(
    VOID
    );

#endif // !_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\faxdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdm.c

Abstract:

    Functions for dealing with devmodes

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    )

/*++

Routine Description:

    Return the driver's default devmode

Arguments:

    pdm - Specifies a buffer for storing driver default devmode
    pDeviceName - Points to device name string
    hPrinter - Handle to the printer object

Return Value:

    NONE

--*/

{
#ifndef KERNEL_MODE
    PDMPRIVATE dmPrivate;
    PDRVDEVMODE dmSource;    
#endif

	short DefualtPaperSize = DMPAPER_LETTER; // Letter
	LPTSTR lptstrDefualtPaperName = FORMNAME_LETTER; 


    //
    // Default value for public devmode fields
    //

    memset(pdm, 0, sizeof(DRVDEVMODE));

    if (pDeviceName == NULL)
        pDeviceName = DRIVER_NAME;

    CopyString(pdm->dmPublic.dmDeviceName, pDeviceName, CCHDEVICENAME);

    pdm->dmPublic.dmDriverVersion = DRIVER_VERSION;
    pdm->dmPublic.dmSpecVersion = DM_SPECVERSION;
    pdm->dmPublic.dmSize = sizeof(DEVMODE);
    pdm->dmPublic.dmDriverExtra = sizeof(DMPRIVATE);

    pdm->dmPublic.dmFields = DM_ORIENTATION  |
                             DM_PAPERSIZE    |
                             DM_FORMNAME     |                             
                             DM_PRINTQUALITY |
                             DM_YRESOLUTION  |
                             DM_DEFAULTSOURCE;

    pdm->dmPublic.dmOrientation = DMORIENT_PORTRAIT;    
    pdm->dmPublic.dmScale = 100;
    pdm->dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
    pdm->dmPublic.dmYResolution = FAXRES_VERTICAL;
    pdm->dmPublic.dmDuplex = DMDUP_SIMPLEX;    
    pdm->dmPublic.dmTTOption = DMTT_BITMAP;
    pdm->dmPublic.dmColor = DMCOLOR_MONOCHROME;
    pdm->dmPublic.dmDefaultSource = DMBIN_ONLYONE;

    if (hPrinter)
	{
		switch (GetPrinterDataDWord(hPrinter, PRNDATA_PAPER_SIZE, DMPAPER_LETTER))
		{
			case DMPAPER_A4:
				DefualtPaperSize = DMPAPER_A4;
				lptstrDefualtPaperName = FORMNAME_A4;
				break;

			case DMPAPER_LEGAL:
				DefualtPaperSize = DMPAPER_LEGAL;
				lptstrDefualtPaperName = FORMNAME_LEGAL;
				break;			
		}
	}

	pdm->dmPublic.dmPaperSize = DefualtPaperSize;
    CopyString(pdm->dmPublic.dmFormName, lptstrDefualtPaperName, CCHFORMNAME);
    

    //
    // Private devmode fields
    //
#ifdef KERNEL_MODE
    pdm->dmPrivate.signature = DRIVER_SIGNATURE;
    pdm->dmPrivate.flags = 0;
    pdm->dmPrivate.sendCoverPage = TRUE;
    pdm->dmPrivate.whenToSend = JSA_NOW;    
#else
    dmSource = (PDRVDEVMODE) GetPerUserDevmode(pDeviceName);
    if (!dmSource) {
        //
        // default values
        //
        pdm->dmPrivate.signature = DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = 0;
        pdm->dmPrivate.sendCoverPage = TRUE;
        pdm->dmPrivate.whenToSend = JSA_NOW;    
    } else {
        dmPrivate = &dmSource->dmPrivate;
        pdm->dmPrivate.signature = dmPrivate->signature;//DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = dmPrivate->flags;// 0;
        pdm->dmPrivate.sendCoverPage = dmPrivate->sendCoverPage; //TRUE;
        pdm->dmPrivate.whenToSend = dmPrivate->whenToSend;//JSA_NOW;
        pdm->dmPrivate.sendAtTime = dmPrivate->sendAtTime;
        CopyString(pdm->dmPrivate.billingCode,dmPrivate->billingCode,MAX_BILLING_CODE);
        CopyString(pdm->dmPrivate.emailAddress,dmPrivate->emailAddress,MAX_EMAIL_ADDRESS);
        MemFree(dmSource);
    }
    
#endif
}



BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    )

/*++

Routine Description:

    Merge the source devmode into the destination devmode

Arguments:

    pdmDest - Specifies the destination devmode
    pdmSrc - Specifies the source devmode
    publicOnly - Only merge public portion of the devmode

Return Value:

    TRUE if successful, FALSE if the source devmode is invalid

[Note:]

    pdmDest must point to a valid current-version devmode

--*/

#define BadDevmode(reason) { Error(("Invalid DEVMODE: %s\n", reason)); valid = FALSE; }

{
    PDEVMODE    pdmIn, pdmOut, pdmAlloced = NULL;
    PDMPRIVATE  pdmPrivate;
    BOOL        valid = TRUE;

    //
    // If there is no source devmode, levae destination devmode untouched
    //

    if ((pdmIn = pdmSrc) == NULL)
        return TRUE;

    //
    // Convert source devmode to current version if necessary
    //

    if (! CurrentVersionDevmode(pdmIn)) {

        Warning(("Converting non-current version DEVMODE ...\n"));
        
        if (! (pdmIn = pdmAlloced = MemAlloc(sizeof(DRVDEVMODE)))) {
    
            Error(("Memory allocation failed\n"));
            return FALSE;
        }
    
        Assert(pdmDest->dmPublic.dmSize == sizeof(DEVMODE) &&
               pdmDest->dmPublic.dmDriverExtra == sizeof(DMPRIVATE));
    
        memcpy(pdmIn, pdmDest, sizeof(DRVDEVMODE));
    
        if (ConvertDevmode(pdmSrc, pdmIn) <= 0) {
    
            Error(("ConvertDevmode failed\n"));
            MemFree(pdmAlloced);
            return FALSE;
        }
    }

    //
    // If the input devmode is the same as the driver default,
    // there is no need to merge it.
    //

    pdmPrivate = &((PDRVDEVMODE) pdmIn)->dmPrivate;

    if (pdmPrivate->signature == DRIVER_SIGNATURE &&
        (pdmPrivate->flags & FAXDM_DRIVER_DEFAULT))
    {
        Verbose(("Merging driver default devmode.\n"));
    }
    else
    {

        //
        // Merge source devmode into destination devmode
        //

        pdmOut = &pdmDest->dmPublic;

        //
        // Device name: Always the same as printer name
        //

        // CopyString(pdmOut->dmDeviceName, pdmIn->dmDeviceName, CCHDEVICENAME);

        //
        // Orientation
        //

        if (pdmIn->dmFields & DM_ORIENTATION) {

            if (pdmIn->dmOrientation == DMORIENT_PORTRAIT ||
                pdmIn->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pdmOut->dmFields |= DM_ORIENTATION;
                pdmOut->dmOrientation = pdmIn->dmOrientation;

            } else
                BadDevmode("orientation");
        }

        //
        // Form selection
        //

        if (pdmIn->dmFields & DM_PAPERSIZE) {

            if (pdmIn->dmPaperSize >= DMPAPER_FIRST) {

                pdmOut->dmFields |= DM_PAPERSIZE;
                pdmOut->dmFields &= ~DM_FORMNAME;
                pdmOut->dmPaperSize = pdmIn->dmPaperSize;
                CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);

            } else
                BadDevmode("paper size");

        } else if (pdmIn->dmFields & DM_FORMNAME) {

            pdmOut->dmFields |= DM_FORMNAME;
            pdmOut->dmFields &= ~DM_PAPERSIZE;
            CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);
        }

        //
        // Paper source
        //

        if (pdmIn->dmFields & DM_DEFAULTSOURCE) {

            if (pdmIn->dmDefaultSource == DMBIN_ONLYONE) {

                pdmOut->dmFields |= DM_DEFAULTSOURCE;
                pdmOut->dmDefaultSource = pdmIn->dmDefaultSource;

            } else
                BadDevmode("paper source");
        }

        //
        // Print quality
        //

        if ((pdmIn->dmFields & DM_PRINTQUALITY) &&
            (pdmIn->dmPrintQuality != FAXRES_HORIZONTAL))
        {
            BadDevmode("print quality");
        }

        if (pdmIn->dmFields & DM_YRESOLUTION)
        {
            if (pdmIn->dmYResolution <= FAXRES_VERTDRAFT)
                pdmOut->dmYResolution = FAXRES_VERTDRAFT;
            else
                pdmOut->dmYResolution = FAXRES_VERTICAL;
        }

        //
        // Private devmode fields
        //

        Assert(pdmDest->dmPrivate.signature == DRIVER_SIGNATURE);

        if (pdmPrivate->signature == DRIVER_SIGNATURE) {

            if (! publicOnly)
                memcpy(&pdmDest->dmPrivate, pdmPrivate, sizeof(DMPRIVATE));

        } else
            BadDevmode("bad signature");
    }

    pdmDest->dmPrivate.flags &= ~FAXDM_DRIVER_DEFAULT;
    MemFree(pdmAlloced);
    return valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\kmfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    kmfuncs.c

Abstract:

    Kernel-mode specific library functions

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



#if DBG

//
// Variable to control the amount of debug messages generated
//

INT _debugLevel = 0;


#ifndef USERMODE_DRIVER

//
// Functions for outputting debug messages
//

ULONG __cdecl
DbgPrint(
    CHAR *  format,
    ...
    )

{
    va_list ap;

    va_start(ap, format);
    EngDebugPrint("", format, ap);
    va_end(ap);

    return 0;
}

#endif // !USERMODE_DRIVER
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\umwin95\umfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umfuncs.c

Abstract:

    User-mode specific library functions

Environment:

    Fax driver, user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\umwinnt\umfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umfuncs.c

Abstract:

    User-mode specific library functions

Environment:

    Fax driver, user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

PRINTERS=$(BASEDIR)\private\ntos\w32\ntgdi\printers

!ifndef NOUNICODE

C_DEFINES=$(C_DEFINES) -DVERSION_4_71


!endif

SOURCES=..\runtime.c    \
        ..\faxdm.c      \
        ..\forms.c      \
        ..\prndata.c    \
        ..\devmode.c    \
        ..\halftone.c	\
	..\timectrl.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\prndata.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    Functions for accessing printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



LPTSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey
    )

/*++

Routine Description:

    Get a string value from the PrinterData registry key

Arguments:

    hPrinter - Identifies the printer object
    pRegKey - Specifies the name of registry value

Return Value:

    pBuffer

--*/

{
    DWORD   type, cb;
    PVOID   pBuffer = NULL;

    //
    // We should really pass NULL for pData parameter here. But to workaround
    // a bug in the spooler API GetPrinterData, we must pass in a valid pointer here.
    //

    if (GetPrinterData(hPrinter, pRegKey, &type, (PBYTE) &type, 0, &cb) == ERROR_MORE_DATA &&
        (pBuffer = MemAlloc(cb)) &&
        GetPrinterData(hPrinter, pRegKey, &type, pBuffer, cb, &cb) == ERROR_SUCCESS &&
        (type == REG_SZ || type == REG_MULTI_SZ || type == REG_EXPAND_SZ))
    {
        return pBuffer;
    }

    Error(("Couldn't get printer data string %ws: %d\n", pRegKey, GetLastError()));
    MemFree(pBuffer);
    return NULL;
}



DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    defaultValue - Specifies the default value to be used if no data exists in registry

Return Value:

    Current value for the requested registry key

--*/

{
    DWORD   dwValue = defaultValue ;	//  prevents returning invalid value even if GetPrinterData(...) fails to initialize it
	DWORD	type;						//	the type of data retrieved
	DWORD	cb;							//  the size, in bytes, of the configuration data

    if (GetPrinterData(hPrinter,
                       pRegKey,
                       &type,
                       (PBYTE) &dwValue,
                       sizeof(dwValue),
                       &cb) == ERROR_SUCCESS)
    {
        return dwValue;
    }

    return defaultValue;
}



PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

#ifdef SPOOLERBUG
    if (level == 9) 
    {
        cbNeeded = sizeof(DRVDEVMODE);
        pPrinterInfo = MemAlloc( cbNeeded );
        if(!pPrinterInfo)
        {
            return NULL;
        }

        if (GetPrinter(hPrinter,9,pPrinterInfo,cbNeeded,&cbNeeded)) 
        {
            return pPrinterInfo;
        }
        
    } else
#endif

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    Error(("GetPrinter failed: %d\n", GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}



#ifndef KERNEL_MODE

BOOL
SetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    LPTSTR  pValue
    )

/*++

Routine Description:

    Save a string value to the PrinterData registry key

Arguments:

    hPrinter - Identifies the printer object
    pRegKey - Specifies the name of registry value
    pValue - Points to string value to be saved

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_SZ,
                       (PBYTE) pValue,
                       sizeof(TCHAR) * (_tcslen(pValue) + 1)) != ERROR_SUCCESS)
    {
        Error(("Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}



BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   value
    )

/*++

Routine Description:

    Save a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    value - Specifies the value to be saved

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_DWORD,
                       (PBYTE) &value,
                       sizeof(value)) != ERROR_SUCCESS)
    {
        Error(("Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}



PVOID
MyGetPrinterDriver(
    HANDLE      hPrinter,
    DWORD       level
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriver spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of DRIVER_INFO_x structure requested

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pDriverInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinterDriver(hPrinter, NULL, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = MemAlloc(cbNeeded)) &&
        GetPrinterDriver(hPrinter, NULL, level, pDriverInfo, cbNeeded, &cbNeeded))
    {
        return pDriverInfo;
    }

    Error(("GetPrinterDriver failed: %d\n", GetLastError()));
    MemFree(pDriverInfo);
    return NULL;
}



LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriverDirectory spooler API

Arguments:

    pServerName - Specifies the name of the print server, NULL for local machine
    pEnvironment - Specifies the processor architecture

Return Value:

    Pointer to the printer driver directory on the specified print server
    NULL if there is an error

--*/

{
    PVOID   pDriverDir = NULL;
    DWORD   cb;
    
    if (! GetPrinterDriverDirectory(pServerName, pEnvironment, 1, NULL, 0, &cb) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverDir = MemAlloc(cb)) &&
        GetPrinterDriverDirectory(pServerName, pEnvironment, 1, pDriverDir, cb, &cb))
    {
        return pDriverDir;
    }

    Error(("GetPrinterDriverDirectory failed: %d\n", GetLastError()));
    MemFree(pDriverDir);
    return NULL;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\runtime.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    runtime.c

Abstract:

    Implementation of runtime library functions

Environment:

    Fax driver, kernel and user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Unicode string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PWSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Ansi string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     strSize;

    if (pSrcStr != NULL) {

        strSize = SizeOfString(pSrcStr);

        if (pDestStr = MemAlloc(strSize))
            CopyMemory(pDestStr, pSrcStr, strSize);
        else
            Error(("Memory allocation failed\n"));

    } else
        pDestStr = NULL;

    return pDestStr;
}



PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pFilename   Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    LPCSTR  pstr;

    if (pstr = strrchr(pFilename, FAX_PATH_SEPARATOR_CHR))
        return pstr + 1;

    return pFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Functions for accessing registry information under:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

        Windows XP fax driver user interface

Revision History:

        01/29/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxlib.h"
#include "registry.h"



typedef BOOL (FAR WINAPI SHGETSPECIALFOLDERPATH)(
    HWND hwndOwner,
    LPTSTR lpszPath,
    int nFolder,
    BOOL fCreate
);

typedef SHGETSPECIALFOLDERPATH FAR *PSHGETSPECIALFOLDERPATH;


LPTSTR
GetRegistryExpandStr(
    HKEY    hRootKey,
    LPTSTR  pKeyName,
    LPTSTR  pValueName
    )

/*++

Routine Description:

    Get a EXPAND_SZ value from the registry

Arguments:

    hRootKey - Specifies a handle to the root registry key
    pKeyName - Specifies the name of the sub registry key
    pValueName - Specifies the name of the registry value

Return Value:

    Pointer to an expanded string, NULL if there is an error

--*/

{
    DWORD   size, type;
    LONG    status;
    HKEY    hRegKey;
    LPTSTR  pRegStr = NULL, pExpandedStr;

    //
    // Get a handle to the user info registry key
    //

    if (! (hRegKey = OpenRegistryKey(hRootKey, pKeyName, FALSE, REG_READONLY)))
        return NULL;

    //
    // Figure out how much memory to allocate
    //

    size = 0;
    status = RegQueryValueEx(hRegKey, pValueName, NULL, &type, NULL, &size);

    if ((status == ERROR_SUCCESS) &&
        (type == REG_EXPAND_SZ || type == REG_SZ) &&
        (pRegStr = MemAlloc(size)))
    {
        //
        // Read the registry value
        //

        status = RegQueryValueEx(hRegKey, pValueName, NULL, NULL, (PBYTE) pRegStr, &size);

        if (status != ERROR_SUCCESS || IsEmptyString(pRegStr)) {

            MemFree(pRegStr);
            pRegStr = NULL;

        } else if (type == REG_EXPAND_SZ) {

            //
            // Substitute any environment variables
            //

            if ((size = ExpandEnvironmentStrings(pRegStr, NULL, 0)) == 0 ||
                (pExpandedStr = MemAlloc(sizeof(TCHAR) * size)) == NULL)
            {
                MemFree(pRegStr);
                pRegStr = NULL;

            } else {

                if (ExpandEnvironmentStrings(pRegStr, pExpandedStr, size) == 0)
                    *pExpandedStr = NUL;

                MemFree(pRegStr);
                pRegStr = pExpandedStr;
            }
        }
    }

    RegCloseKey(hRegKey);
    return pRegStr;
}


PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Get per-user devmode information for the specified printer

Arguments:

    pPrinterName - Specifies the name of the printer we're interested in

Return Value:

    Pointer to per-user devmode information read from the registry

--*/

{
    PVOID  pDevmode = NULL;
    HANDLE hPrinter;
    PPRINTER_INFO_2 pPrinterInfo=NULL;

    //
    // Make sure the printer name is valid
    //

    Assert (pPrinterName);

    //
    // Open the printer
    //
    if (!OpenPrinter(pPrinterName,&hPrinter,NULL) )
    {
        return NULL;
    }

    pPrinterInfo = MyGetPrinter(hPrinter,2);
    if (!pPrinterInfo || !pPrinterInfo->pDevMode)
    {
        MemFree(pPrinterInfo);
        ClosePrinter(hPrinter);
        return NULL;
    }

    pDevmode = MemAlloc(sizeof(DRVDEVMODE) );

    if (!pDevmode)
    {
        MemFree(pPrinterInfo);
        ClosePrinter(hPrinter);
        return NULL;
    }

    CopyMemory((PVOID) pDevmode,
               (PVOID) pPrinterInfo->pDevMode,
                sizeof(DRVDEVMODE) );

    MemFree( pPrinterInfo );
    ClosePrinter( hPrinter );

    return pDevmode;
}


VOID
SavePerUserDevmode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDevmode
    )

/*++

Routine Description:

    Save per-user devmode information for the specified printer

Arguments:

    pPrinterName - Specifies the name of the printer we're interested in
    pDevmode - Points to the devmode to be saved

Return Value:

    NONE

--*/

{
    HKEY    hRegKey;
    INT     size;

    //
    // Make sure the printer name is valid
    //

    if (pPrinterName == NULL) {

        Error(("Bad printer name\n"));
        return;
    }

    //
    // Open the registry key for write access
    //

    if (! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_DEVMODE, REG_READWRITE)))
        return;

    //
    // Save the devmode information as binary data
    //

    size = pDevmode->dmSize + pDevmode->dmDriverExtra;
    RegSetValueEx(hRegKey, pPrinterName, 0, REG_BINARY, (PBYTE) pDevmode, size);
    RegCloseKey(hRegKey);
}

LPTSTR
GetUserCoverPageDir(
    VOID
    )
{
    LPTSTR  CpDir = NULL;
    DWORD   dwBufferSize = MAX_PATH * sizeof(TCHAR);
    
    if (!(CpDir = MemAlloc(dwBufferSize)))
    {
        Error(("MemAlloc failed\n"));
        CpDir = NULL;
        return CpDir;
    }

    if(!GetClientCpDir(CpDir, dwBufferSize / sizeof (TCHAR)))
    {
        Error(("GetClientCpDir failed\n"));
        MemFree(CpDir);
        CpDir = NULL;
        return CpDir;
    }

    return CpDir;
}


LPTSTR
GetCoverPageEditor(
    VOID
    )
{
    LPTSTR CpEd = GetRegistryStringExpand(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_EDITOR);
    if (CpEd == NULL) {
        HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_SETUP,FALSE, REG_READWRITE);
        if (hKey) {
            SetRegistryStringExpand(hKey,REGVAL_CP_EDITOR,DEFAULT_COVERPAGE_EDITOR);
            RegCloseKey(hKey);
            return GetRegistryExpandStr(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, REGVAL_CP_EDITOR);
        }
    }
    return CpEd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\forms.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.c

Abstract:

    Functions for manipulating forms

Environment:

    Fax driver, user and kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"
#include "forms.h"


BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    )

/*++

Routine Description:

    Validate the form specification in a devmode

Arguments:

    hPrinter - Handle to the printer object
    pdm - Pointer to the input devmode
    pFormInfo - FORM_INFO_1 structure for returning form information

Return Value:

    TRUE if the input devmode specifies a valid logical form
    FALSE otherwise

--*/

{
    PFORM_INFO_1 pForm, pFormDB;
    DWORD        cForms;

    //
    // Get a list of forms in the system
    //

    if (! (pForm = pFormDB = GetFormsDatabase(hPrinter, &cForms))) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    if ((pdm->dmFields & DM_PAPERSIZE) && pdm->dmPaperSize >= DMPAPER_FIRST) {

        //
        // Devmode is specifying a form using paper size index
        //

        DWORD index = pdm->dmPaperSize - DMPAPER_FIRST;

        if (index < cForms)
            pForm = pFormDB + index;
        else
            pForm = NULL;

    } else if (pdm->dmFields & DM_FORMNAME) {

        //
        // Devmode is specifying a form using form name: go through the forms database
        // and check if the requested form name matches that of a form in the database
        //

        while (cForms && _tcsicmp(pForm->pName, pdm->dmFormName) != EQUAL_STRING) {

            pForm++;
            cForms--;
        }

        if (cForms == 0)
            pForm = NULL;
    }

    if (pForm && IsSupportedForm(pForm)) {

        if (pFormInfo)
            *pFormInfo = *pForm;

        //
        // Convert paper size unit from microns to 0.1mm
        //

        pdm->dmPaperWidth = (SHORT)(pForm->Size.cx / 100);
        pdm->dmPaperLength = (SHORT)(pForm->Size.cy / 100);

        if ((pdm->dmFields & DM_FORMNAME) == 0) {

            pdm->dmFields |= DM_FORMNAME;
            CopyString(pdm->dmFormName, pForm->pName, CCHFORMNAME);
        }
    }
    else
    {
        //
        // The form is not supported
        //
        pForm = NULL;
    }

    MemFree(pFormDB);
    return pForm != NULL;
}



PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    )

/*++

Routine Description:

    Return a collection of forms in the spooler database

Arguments:

    hPrinter - Handle to a printer object
    pCount - Points to a variable for returning total number of forms

Return Value:

    Pointer to an array of FORM_INFO_1 structures if successful
    NULL otherwise

--*/

{
    PFORM_INFO_1 pFormDB = NULL;
    DWORD        cb=0;

    if (!EnumForms(hPrinter, 1, NULL, 0, &cb, pCount) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pFormDB = MemAlloc(cb)) != NULL &&
        EnumForms(hPrinter, 1, (PBYTE) pFormDB, cb, &cb, pCount))
    {
        PFORM_INFO_1 pForm;
        DWORD        count;
        LONG         maxX, maxY;

        //
        // Calculate the maximum allowable form width and height (in microns)
        //

        maxX = MulDiv(MAX_WIDTH_PIXELS, 25400, FAXRES_HORIZONTAL);
        maxY = MulDiv(MAX_HEIGHT_PIXELS, 25400, FAXRES_VERTICAL);

        for (count=*pCount, pForm=pFormDB; count--; pForm++) {

            //
            // Make sure the highest order bits are not used by the spooler
            //

            Assert(! IsSupportedForm(pForm));

            //
            // Determine if the form in question is supported on the device
            //

            if (pForm->ImageableArea.right - pForm->ImageableArea.left <= maxX &&
                pForm->ImageableArea.bottom - pForm->ImageableArea.top <= maxY)
            {
                SetSupportedForm(pForm);
            }
        }

        return pFormDB;
    }

    Error(("EnumForms failed\n"));
    MemFree(pFormDB);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\lib\timectrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timectrl.c

Abstract:

    For implementing a dialog control for setting time values

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"
#include "timectrl.h"
#include <commctrl.h>
#include <windowsx.h>

//
// Static time format information
//

static BOOL timeCtrlInitialized = FALSE;
static UINT use24Hour;
static UINT hourLeadingZero;

static TCHAR timeSep[8];
static TCHAR amSuffix[8];
static TCHAR pmSuffix[8];

static TCHAR intlApplet[] = TEXT("Intl");
static TCHAR use24HourKey[] = TEXT("iTime");
static TCHAR hourLeadingZeroKey[] = TEXT("iTLZero");
static TCHAR timeSepKey[] = TEXT("sTime");
static TCHAR amSuffixKey[] = TEXT("s1159");
static TCHAR pmSuffixKey[] = TEXT("s2359");

static TCHAR timeSepDefault[] = TEXT(":");
static TCHAR amSuffixDefault[] = TEXT("AM");
static TCHAR pmSuffixDefault[] = TEXT("PM");



VOID
InitStaticValues(
    VOID
    )

/*++

Routine Description:

    One time initialization of the time control module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (! timeCtrlInitialized) {

        //
        // We only need to perform the initialization once.
        // Make sure to modify the global data inside a critical section.
        //

        use24Hour = GetProfileInt(intlApplet, use24HourKey, FALSE);
        hourLeadingZero = GetProfileInt(intlApplet, hourLeadingZeroKey, TRUE);

        GetProfileString(intlApplet,
                         timeSepKey,
                         timeSepDefault,
                         timeSep,
                         sizeof(timeSep) / sizeof(TCHAR));

        GetProfileString(intlApplet,
                         amSuffixKey,
                         amSuffixDefault,
                         amSuffix,
                         sizeof(amSuffix) / sizeof(TCHAR));

        GetProfileString(intlApplet,
                         pmSuffixKey,
                         pmSuffixDefault,
                         pmSuffix,
                         sizeof(pmSuffix) / sizeof(TCHAR));

        timeCtrlInitialized = TRUE;

        Verbose(("Use 24-hour format: %d\n", use24Hour));
        Verbose(("Hour leading zero: %d\n", hourLeadingZero));
        Verbose(("Time separator: %ws\n", timeSep));
        Verbose(("AM suffix: %ws\n", amSuffix));
        Verbose(("PM suffix: %ws\n", pmSuffix));
    }
}


VOID
EnableTimeControl(
    HWND    hDlg,
    INT     id,
    BOOL    enabled
    )

/*++

Routine Description:

    Enable or disable a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    enabled - Whether to enable or disable the time control

Return Value:

    NONE

--*/

{
//    EnableWindow(GetDlgItem(hDlg, IDC_SENDTIME), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_HOUR), enabled);
    InvalidateRect(GetDlgItem(hDlg, id+TC_TIME_SEP), NULL, FALSE);
    EnableWindow(GetDlgItem(hDlg, id+TC_MINUTE), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_AMPM), enabled);
    EnableWindow(GetDlgItem(hDlg, id+TC_ARROW), enabled);
}



VOID
SetHourMinuteValue(
    HWND    hDlg,
    INT     id,
    INT     part,
    INT     value
    )

/*++

Routine Description:

    Set the hour or minute value

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    part - Whether we're setting hour or minute value
    value - Specifies the new hour or minute value

Return Value:

    NONE

--*/

{
    TCHAR   buffer[4];

    if (value < 0 || value > ((part == TC_MINUTE) ? 59 : 23))
        value = 0;

    if (part == TC_HOUR && !use24Hour) {

        SendDlgItemMessage(hDlg, id+TC_AMPM, LB_SETTOPINDEX, value / 12, 0);

        if ((value %= 12) == 0)
            value = 12;
    }

    wsprintf(buffer,
             (part == TC_MINUTE || hourLeadingZero) ? TEXT("%02d") : TEXT("%d"),
             value);

    SetDlgItemText(hDlg, id+part, buffer);
}



VOID
InitTimeControl(
    HWND      hDlg,
    INT       id,
    PFAX_TIME pTimeVal
    )

/*++

Routine Description:

    Setting the current value of a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    pTimeVal - Specifies the new value for the time control

Return Value:

    NONE

--*/

{
    HWND    hwnd, hwndArrow;

    //
    // Make sure the static global information is initialized
    //

    InitStaticValues();

    //
    // Display the time separator
    //

    SetDlgItemText(hDlg, id+TC_TIME_SEP, timeSep);

    //
    // Display the AM/PM suffix if necessary
    //

    if (hwnd = GetDlgItem(hDlg, id+TC_AMPM)) {

        if (! use24Hour) {

            SendMessage(hwnd, LB_INSERTSTRING, 0, (LPARAM) &amSuffix[0]);
            SendMessage(hwnd, LB_INSERTSTRING, 1, (LPARAM) &pmSuffix[0]);

        } else
            EnableWindow(hwnd, FALSE);
    }

    //
    // Display hour and minute values
    //

    SetHourMinuteValue(hDlg, id, TC_HOUR, pTimeVal->Hour);
    SetHourMinuteValue(hDlg, id, TC_MINUTE, pTimeVal->Minute);

    //
    // Connect the updown arrow to the minute field by default
    //

    if ((hwnd = GetDlgItem(hDlg, id+TC_MINUTE)) && (hwndArrow = GetDlgItem(hDlg, id+TC_ARROW))) {

        UDACCEL udAccel[2];

        udAccel[0].nSec = 0;
        udAccel[0].nInc = 1;
        udAccel[1].nSec = 2;
        udAccel[1].nInc = 5;

        SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(59, 0));
        SendMessage(hwndArrow, UDM_SETACCEL, 2, (LPARAM) &udAccel[0]);
        SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
    }
}



BOOL
GetHourMinuteValue(
    HWND    hDlg,
    INT     id,
    INT     part,
    PWORD   pValue
    )

/*++

Routine Description:

    Retrieve the current hour or minute value

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    part - Whether we're interest in hour or minute value
    pValue - Buffer for storing the current hour value

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT     value, minVal, maxVal;
    BOOL    success;

    //
    // Read the text field as an integer value
    //

    value = GetDlgItemInt(hDlg, id+part, &success, FALSE);

    //
    // Make sure the input value is valid
    //

    if (! success)
        value = 0;
    else {

        if (part == TC_MINUTE)
            minVal = 0, maxVal = 59;
        else if (use24Hour)
            minVal = 0, maxVal = 23;
        else
            minVal = 1, maxVal = 12;

        success = FALSE;

        if (value < minVal)
            value = minVal;
        else if (value > maxVal)
            value = maxVal;
        else
            success = TRUE;
    }

    //
    // Convert AM/PM hours to absolute number between 0-23
    //

    if (part == TC_HOUR && !use24Hour) {

        if (SendDlgItemMessage(hDlg, id+TC_AMPM, LB_GETTOPINDEX, 0, 0)) {

            // PM

            if (value != 12)
                value += 12;

        } else {

            // AM

            if (value == 12)
                value = 0;
        }
    }

    *pValue = (WORD) value;
    return success;
}



VOID
GetTimeControlValue(
    HWND      hDlg,
    INT       id,
    PFAX_TIME pTimeVal
    )

/*++

Routine Description:

    Retrieve the current value of a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    id - Identifies the time control
    pTimeVal - Buffer for storing the current time value

Return Value:

    NONE

--*/

{
    if (!GetHourMinuteValue(hDlg, id, TC_HOUR, &pTimeVal->Hour))
	{
		Error(("GetHourMinuteValue failed\n"));
	}
    if (!GetHourMinuteValue(hDlg, id, TC_MINUTE, &pTimeVal->Minute))
	{
		Error(("GetHourMinuteValue failed\n"));
	}
}



BOOL
HandleTimeControl(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    INT     id,
    INT     part
    )

/*++

Routine Description:

    Handle dialog messages intended for a time control

Arguments:

    hDlg - Specifies the dialog window containing the time control
    message, wParam, lParam - Parameters passed to the dialog procedure
    id - Identifies the time control
    part - Identifies what part of the time control in question

Return Value:

    TRUE if the message is handled, FALSE otherwise

--*/

{
    HWND    hwnd, hwndArrow;
    UDACCEL udAccel[2];
    WORD    wMax, wMin;

    switch (message) {

    case WM_COMMAND:

        //
        // Make sure the control is indeed ours
        //

        hwnd = GetDlgItem(hDlg, id+part);
        hwndArrow = GetDlgItem(hDlg, id+TC_ARROW);

        if (hwnd != GET_WM_COMMAND_HWND(wParam, lParam)) {

            Warning(("Bad window handle\n"));
            return FALSE;
        }

        switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

        case LBN_SETFOCUS:

            //
            // AM/PM list box is coming into focus
            //

            Assert(part == TC_AMPM);

            udAccel[0].nSec = 0;
            udAccel[0].nInc = 1;
            SendMessage(hwnd, LB_SETCURSEL, SendMessage(hwnd, LB_GETTOPINDEX, 0, 0), 0);
            SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(1, 0));
            SendMessage(hwndArrow, UDM_SETACCEL, 1, (LPARAM) &udAccel[0]);
            SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
            break;

        case LBN_KILLFOCUS:

            //
            // Leaving AM/PM listbox
            //

            Assert(part == TC_AMPM);

            SendMessage(hwnd, LB_SETCURSEL, (WPARAM) -1, 0);
            SendMessage(hwndArrow, UDM_SETBUDDY, 0, 0);
            break;

        case EN_SETFOCUS:

            //
            // Entering hour or minute text field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            udAccel[0].nSec = 0;
            udAccel[0].nInc = 1;
            udAccel[1].nSec = 2;

            if (part == TC_MINUTE) {

                wMin = 0, wMax = 59;
                udAccel[1].nInc = 5;

            } else {

                udAccel[1].nInc = 1;

                if (use24Hour)
                    wMin = 0, wMax = 23;
                else
                    wMin = 1, wMax = 12;
            }

            SendMessage(hwndArrow, UDM_SETRANGE, 0, MAKELPARAM(wMax, wMin));
            SendMessage(hwndArrow, UDM_SETACCEL, 2, (LPARAM) &udAccel[0]);
            SendMessage(hwndArrow, UDM_SETBUDDY, (WPARAM) hwnd, 0);
            SendMessage(hwnd, EM_SETSEL, 0, -1);
            break;

        case EN_CHANGE:

            //
            // Changing hour or minute field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            if (!GetHourMinuteValue(hDlg, id, part, &wMax) && GetWindowTextLength(hwnd)) {

                MessageBeep(MB_ICONASTERISK);
                SendMessage(hwnd, EM_UNDO, 0, 0);
            }
            break;

        case EN_KILLFOCUS:

            //
            // Leaving hour or minute text field
            //

            Assert(part == TC_HOUR || part == TC_MINUTE);

            GetHourMinuteValue(hDlg, id, part, &wMax);
            SetHourMinuteValue(hDlg, id, part, wMax);
            SendMessage(hwndArrow, UDM_SETBUDDY, 0, 0);
            break;
        }
        return TRUE;

    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLOR:

        //
        // Set the background color of the time control to the color of editable text
        // or static text depending on whether the control is disabled or enabled
        //

        hwnd = GET_WM_CTLCOLOR_HWND(wParam, lParam, message);

        if (hwnd == GetDlgItem(hDlg, id + TC_HOUR) ||
            hwnd == GetDlgItem(hDlg, id + TC_MINUTE) ||
            hwnd == GetDlgItem(hDlg, id + TC_TIME_SEP) ||
            hwnd == GetDlgItem(hDlg, id + TC_AMPM))
        {
            message = part ? WM_CTLCOLOREDIT : WM_CTLCOLORSTATIC;
            return (BOOL)(DefWindowProc(hDlg, message, wParam, lParam)!=0);
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\abobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    abobj.h

Abstract:

    Class definition for CCommonAbObj

Environment:

        Fax send wizard


--*/

#ifndef __ABOBJ_H_
#define	__ABOBJ_H_

#include <set>
using namespace std;

typedef struct 
{
    LPTSTR DisplayName;
    LPTSTR BusinessFax;
    LPTSTR HomeFax;
    LPTSTR OtherFax;
    LPTSTR Country;
} PICKFAX, * PPICKFAX;

struct CRecipCmp
{
/*
    Comparison operator 'less'
    Compare two PRECIPIENT by recipient's name and fax number
*/
    bool operator()(const PRECIPIENT pcRecipient1, const PRECIPIENT pcRecipient2) const;
};


typedef set<PRECIPIENT, CRecipCmp> RECIPIENTS_SET;


class CCommonAbObj {
    
protected:

    LPADRBOOK   m_lpAdrBook;
    LPADRLIST   m_lpAdrList; 

    LPMAILUSER  m_lpMailUser;

    HWND        m_hWnd;

    DWORD       m_PickNumber;

    RECIPIENTS_SET m_setRecipients;

    virtual LPSTR       DupStringUnicodeToAnsi(
                        LPVOID  lpObject,
                        LPWSTR  pUnicodeStr
                        ) = 0;

	virtual LPSTR		DuplicateAnsiString(
                        LPVOID  lpObject,
						LPCSTR pSrcStr
						) = 0;

	virtual	LPENTRYID	DuplicateEntryId(
						ULONG cbSize,           
                        LPVOID		lpObject,
						LPENTRYID	lpEntryId
						) = 0;

	virtual HRESULT		ABAllocateBuffer(
						ULONG cbSize,           
						LPVOID FAR * lppBuffer  
						) = 0;

	virtual ULONG		ABFreeBuffer(
						LPVOID lpBuffer
						) = 0;

	virtual	BOOL		isInitialized() const = 0;

    DWORD        GetRecipientInfo(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT pRecipient,
                    PRECIPIENT pOldRecipList
                    );

	BOOL
				GetOneOffRecipientInfo(
					LPSPropValue SPropVals,
					ULONG cValues,
                    PRECIPIENT pRecipient,
                    PRECIPIENT pOldRecipList
					);

	LPTSTR		GetEmail(
					LPSPropValue SPropVals,
					ULONG cValues
					);


    DWORD        InterpretAddress(
                    LPSPropValue SPropVals,
                    ULONG cValues,
	                PRECIPIENT *ppNewRecipList,
                    PRECIPIENT pOldRecipList
                    );
	LPTSTR
				InterpretEmailAddress(
					LPSPropValue SPropVal,
					ULONG cValues
					);
                
    DWORD        InterpretDistList(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT *ppNewRecipList,
                    PRECIPIENT pOldRecipList
                    );

    PRECIPIENT  FindRecipient(
                    PRECIPIENT   pRecipList,
                    PICKFAX*     pPickFax
                    );

    PRECIPIENT  FindRecipient(
                    PRECIPIENT   pRecipient,
                    PRECIPIENT   pRecipList
                    );

    DWORD AddRecipient(
                    PRECIPIENT* ppNewRecip,
                    PRECIPIENT  pRecipient,
                    BOOL        bFromAddressBook
                    );
                   
public:

    CCommonAbObj(HINSTANCE hInstance);
    ~CCommonAbObj();
    
    BOOL
    Address( 
        HWND hWnd,
        PRECIPIENT pRecip,
        PRECIPIENT * ppNewRecip
        );

	LPTSTR
	AddressEmail(
        HWND hWnd
        );

    static  HINSTANCE   m_hInstance;

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\coverpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for working with cover pages

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        10/20/99 -danl-
                Get server name properly in GetServerCoverPageDirs.

        mm/dd/yy -author-
            description

--*/

#include "faxui.h"
#include <faxreg.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include "faxutil.h"

//
// Suffix string appended to all user cover page filenames
//

static TCHAR PersonalSuffixStr[64];



VOID
InsertOneCoverPageFilenameToList(
    HWND    hwndList,
    LPTSTR  pFilename,
    INT     flags
    )

/*++

Routine Description:

    Insert one cover page filename into the list of cover pages

Arguments:

    hwndList - Handle to list window
    pFilename - Name of the cover page file
    flags - Flags to be associated with the list item

Return Value:

    NONE

--*/

{
    INT     listIndex;
    LPTSTR  pBuffer = NULL;

    //
    // Add " (Personal)" suffix to all user cover pages
    //

    if ((flags & CPFLAG_SERVERCP) == 0) {

        if (IsEmptyString(PersonalSuffixStr))
        {
            if(!LoadString(ghInstance, IDS_USERCP_SUFFIX, PersonalSuffixStr, 64))
            {
                Assert(FALSE);
            }
        }

        if (pBuffer = MemAlloc(SizeOfString(pFilename) + SizeOfString(PersonalSuffixStr))) 
        {
            _tcscpy(pBuffer, pFilename);
            _tcscat(pBuffer, PersonalSuffixStr);

            flags |= CPFLAG_SUFFIX;
            pFilename = pBuffer;
        }
    }

    //
    // Insert the cover page filename into the list
    //

    listIndex = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFilename);

    if (listIndex != CB_ERR)
        SendMessage(hwndList, CB_SETITEMDATA, listIndex, flags);

    MemFree(pBuffer);
}



VOID
AddCoverPagesToList(
    PCPDATA     pCPInfo,
    HWND        hwndList,
    LPTSTR      pSelected,
    INT         nDirs
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a list

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to a list window
    pSelected - Currently selected cover page
    nDirs - Cover page directory index

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           filename[MAX_PATH];
    HANDLE          hFindFile;
    LPTSTR          pDirPath, pFilename, pExtension;
    INT             dirLen, fileLen, flags;
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;

    //
    // Are we working on server or user cover pages?
    //

    flags = nDirs | ((nDirs < pCPInfo->nServerDirs) ? CPFLAG_SERVERCP : 0);
    pDirPath = pCPInfo->pDirPath[nDirs];

    if (IsEmptyString(pDirPath))
        return;

    _tcsncpy(tszPathName, pDirPath, ARR_SIZE(tszPathName));
    pPathEnd = _tcschr(tszPathName, '\0');

    //
    // Look at the directory prefix of the currently selected cover page file
    //

    if ((dirLen = _tcslen(pDirPath)) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        Error(("Directory name too long: %ws\n", pDirPath));
        return;
    }

    _tcscpy(filename, pDirPath);

    if (!pSelected || _tcsnicmp(pDirPath, pSelected, dirLen) != EQUAL_STRING)
        pSelected = NULL;
    else
        pSelected += dirLen;

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    do {

        //
        // Generate a specification for the files we're interested in
        //
		LPCTSTR _extension = (flags & CPFLAG_LINK) ? 
								LNK_FILENAME_EXT : 
								FAX_COVER_PAGE_FILENAME_EXT;

		pFilename = _tcsrchr(filename,TEXT('\0'));
		_tcscat(filename,TEXT("*"));
		_tcscat(filename,_extension);

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile(filename, &findData);

        if (hFindFile != INVALID_HANDLE_VALUE) 
        {
            do 
            {
                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY))
                    continue;

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = _tcslen(findData.cFileName)) <= MAX_FILENAME_EXT)
                    continue;

                if (fileLen + dirLen >= MAX_PATH) 
                {
                    Error(("Filename too long: %ws%ws\n", pDirPath, findData.cFileName));
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (flags & CPFLAG_LINK) 
                {
                    _tcscpy(pFilename, findData.cFileName);

                    if (! IsCoverPageShortcut(filename))
                        continue;
                }

                //
                // Compare with the currently selected cover page filename
                //

                if (pSelected && _tcsicmp(pSelected, findData.cFileName) == EQUAL_STRING) 
                {
                    pSelected = NULL;
                    flags |= CPFLAG_SELECTED;
                } 
                else
                {
                    flags &= ~CPFLAG_SELECTED;
                }


                _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
                if(!IsValidCoverPage(tszPathName))
                {
                    continue;
                }                

                //
                // Don't display the filename extension
                //                 
                if (pExtension = _tcsrchr(findData.cFileName, TEXT(FILENAME_EXT))) {
                    *pExtension = NUL;
                }

                //
                // Add the cover page name to the list window
                //

                InsertOneCoverPageFilenameToList(hwndList, findData.cFileName, flags);

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;

    } while ((flags & CPFLAG_LINK) && ! (flags & CPFLAG_SERVERCP));
}



VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    )

/*++

Routine Description:

    Generate a list of available cover pages (both server and user)

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pSelectedCoverPage - Name of currently selected cover page file

Return Value:

    NONE

--*/

{
    INT itemFlags, index;

    //
    // Validate input parameters
    //

    if (pCPInfo == NULL || hwndList == NULL)
        return;

    //
    // Disable redraw on the list and reset its content
    //

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Add server and user cover pages to the list
    //

    for (index=0; index < pCPInfo->nDirs; index++)
        AddCoverPagesToList(pCPInfo, hwndList, pSelectedCoverPage, index);

    //
    // Highlight the currently selected cover page
    //

    index = (INT)SendMessage(hwndList, CB_GETCOUNT, 0, 0);

    if (index > 0) {

        //
        // Go through each list item and check if it should be selected
        //

        while (--index >= 0) {

            itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, index, 0);

            if (itemFlags != CB_ERR && (itemFlags & CPFLAG_SELECTED)) {

                SendMessage(hwndList, CB_SETCURSEL, index, 0);
                break;
            }
        }

        //
        // If nothing is selected, select the first item by default
        //

        if (index < 0)
            SendMessage(hwndList, CB_SETCURSEL, 0, 0);
    }

    //
    // Enable redraw on the list window
    //

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
}




INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  lptstrFullPath, 
    LPTSTR  lptstrFileName,
	BOOL * pbIsServerPage
    )

/*++

Routine Description:

    Retrieves the currently selected cover page name and returns its flags.

    Provides both its full path and short name and indicates if it is a server cover page or not.
	If the cover page is a personal cover page the returned cover page name is a full path to it.
	If the cover page is a server cover page the returned cover page is just the file name.


Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    lptstrFullPath - Points to a buffer for storing the selected cover page full path.
                     The size of the buffer is assumed to be MAX_PATH characters.
                     if lptstrFullPath is NULL the full path is not returned.
    lptstrFileName - Points to a buffer for storing the selected cover page file name.
                     The size of the buffer is assumed to be MAX_PATH characters.
                     This parameter can be NULL in which case the file name will not be provided.
    pbIsServerPage - Points to a BOOL variable that is set to TRUE if the selected cover page is a server cover page.

Return Value:

    Flags associated with the currently selected item
    Negative (CB_ERR) if there is an error or the CB is empty (no *.COV files)

--*/

{
    LPTSTR      pDirPath, pFilename;
    INT         selIndex, itemFlags, nameLen;

    //
    // Default to empty string in case of an error
    //

    if (lptstrFullPath) {
        lptstrFullPath[0] = NUL;
    }

    if (lptstrFileName) {
        lptstrFileName[0]=NUL;
    }


    if (pCPInfo == NULL || hwndList == NULL) {
        return CB_ERR;
    }


    //
    // Get currently selected item index
    //

    // It's possible if there is no item in the combo-box (in case there are no *.COV files)
    if ((selIndex = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR) {
        return selIndex;
    }


    //
    // Get the flags associated with the currently selected item
    //

    itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0);
	
	//
	// Let the caller know if this is a server cover page
    //
	*pbIsServerPage=itemFlags & CPFLAG_SERVERCP;
	

    if ((itemFlags != CB_ERR) && (lptstrFullPath || lptstrFileName)) {

        Assert((itemFlags & CPFLAG_DIRINDEX) < pCPInfo->nDirs);
        pDirPath = pCPInfo->pDirPath[itemFlags & CPFLAG_DIRINDEX];

        //
        //  assemble the full pathname for the cover page file
        //  directory prefix
        //  display name
        //  filename extension
        //
	
        
        pFilename = NULL;

        if ((nameLen = (INT)SendMessage(hwndList, CB_GETLBTEXTLEN, selIndex, 0)) != CB_ERR &&
            (pFilename = MemAlloc(sizeof(TCHAR) * (nameLen + 1))) &&
            SendMessage(hwndList, CB_GETLBTEXT, selIndex, (LPARAM) pFilename) != CB_ERR)
        {
            //
            // If the cover page filename has a suffix, we need to remove it first
            //

            if (itemFlags & CPFLAG_SUFFIX) {

                INT suffixLen = _tcslen(PersonalSuffixStr);

                if (nameLen >= suffixLen &&
                    _tcscmp(pFilename + (nameLen - suffixLen), PersonalSuffixStr) == EQUAL_STRING)
                {
                    *(pFilename + (nameLen - suffixLen)) = NUL;

                } else
                    Error(("Corrupted cover page filename: %ws\n", pFilename));

            }
            if (lptstrFullPath) {
				_tcscpy(lptstrFullPath, pDirPath);
                _tcscat(lptstrFullPath, pFilename);
                _tcscat(lptstrFullPath, (itemFlags & CPFLAG_LINK) ? LNK_FILENAME_EXT : FAX_COVER_PAGE_FILENAME_EXT);
            }

            if (lptstrFileName) {
              _tcscpy(lptstrFileName,pFilename);
              _tcscat(lptstrFileName, (itemFlags & CPFLAG_LINK) ? LNK_FILENAME_EXT : FAX_COVER_PAGE_FILENAME_EXT);
            }
		
        } else {
            itemFlags = CB_ERR;
        }

        
        MemFree(pFilename);
    }

    return itemFlags;
}



BOOL
GetServerCoverPageDirs(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Find the directories in which the server cover pages are stored

Arguments:

  lptstrServerName - server name

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    BOOL            status = FALSE;    
    LPTSTR          pServerDir = NULL;
    LPTSTR          pServerSubDir, p;

	Assert(pCPInfo);
	Assert(lptstrPrinterName);

	pServerDir = MemAlloc(sizeof(TCHAR) * MAX_PATH); 
	if (!pServerDir) {	
		Error(("Memory allocation failed\n"));
		goto exit;		
	}					


    if ( !GetServerCpDir(lptstrServerName, 
						 pServerDir,
						 MAX_PATH) 
	    )
	{
		Error(("GetServerCpDir failed\n"));
        goto exit;
    }
    
    pCPInfo->pDirPath[pCPInfo->nDirs] = pServerDir;
    pCPInfo->nDirs += 1;
    pCPInfo->nServerDirs += 1;
    status = TRUE;

    //
    // Find a subdirectory for the specified printer
    //

    if (p = _tcsrchr(lptstrPrinterName, FAX_PATH_SEPARATOR_CHR))
        p++;
    else
        p = lptstrPrinterName;

    if ((_tcslen(pServerDir) + _tcslen(p) < MAX_PATH) &&
        (pServerSubDir = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
    {
        _tcscpy(pServerSubDir, pServerDir);
        ConcatenatePaths(pServerSubDir, p);        

        pCPInfo->pDirPath[pCPInfo->nDirs] = pServerSubDir;
        pCPInfo->nDirs += 1;
        pCPInfo->nServerDirs += 1;
    }
    

    //
    // Clean up before returning to caller
    //

exit:
    if (!status) {
        MemFree(pServerDir);
    }


    return status;
}



VOID
AppendPathSeparator(
    LPTSTR  pDirPath
    )

/*++

Routine Description:

    Append a path separator (if necessary) at the end of a directory name

Arguments:

    pDirPath - Points to a directory name

Return Value:

    NONE

--*/

{
    INT length;
	TCHAR* pLast = NULL;

    //
    // Calculate the length of directory string
    //

    length = _tcslen(pDirPath);

    if (length >= MAX_PATH-1 || length < 1)
        return;

    //
    // If the last character is not a path separator,
    // append a path separator at the end
    //
	pLast = _tcsrchr(pDirPath,TEXT('\\'));
	if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
	{
		// the last character is not a separator, add one...
        _tcscat(pDirPath, TEXT("\\"));
	}

}



BOOL
UseServerCp(
	LPTSTR	lptstrServerName
    )
{
    HANDLE FaxHandle = NULL;
    BOOL Rval = FALSE;

    if (!FaxConnectFaxServer( lptstrServerName, &FaxHandle )) 
    {
		Verbose(("Can't connect to the fax server %s",lptstrServerName));
        goto exit;
    }

    if (!FaxGetPersonalCoverPagesOption( FaxHandle, &Rval)) 
    {
		Error(("FaxGetPersonalCoverPagesOption failed: %d\n", GetLastError()));
        goto exit;
    }
    else
    {
        //
        // the return value means server cover pages only
        //
        Rval = !Rval;
    }


exit:
    if (FaxHandle) 
    {
        if (!FaxClose( FaxHandle ))
		{
			Verbose(("Can't close the fax handle %x",FaxHandle));
		}
    }

    return Rval;
}



PCPDATA
AllocCoverPageInfo(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    BOOL    ServerCpOnly
    )

/*++

Routine Description:

    Allocate memory to hold cover page information

Arguments:

    lptstrServerName - server name
	ServerCpOnly	 - flag says if he function should use server CP only

Return Value:

    Pointer to a CPDATA structure, NULL if there is an error

--*/

{
    PCPDATA pCPInfo;
    INT     nDirs;
    LPTSTR  pDirPath, pUserCPDir, pSavedPtr;


    if (pCPInfo = MemAllocZ(sizeof(CPDATA))) {

        //
        // Find the directory in which the server cover pages are stored
        //

        if (! GetServerCoverPageDirs(lptstrServerName, lptstrPrinterName, pCPInfo))
            Error(("Couldn't get server cover page directories\n"));

        //
        // Find the directory in which the user cover pages are stored
        //

        if (ServerCpOnly == FALSE &&
            (pUserCPDir = pSavedPtr = GetUserCoverPageDir()))
        {
            while (pUserCPDir && pCPInfo->nDirs < MAX_COVERPAGE_DIRS) {

                LPTSTR  pNextDir = pUserCPDir;

                //
                // Find the next semicolon character
                //
				
				pNextDir = _tcschr(pNextDir,TEXT(';'));
                if (pNextDir != NUL )
				{
					_tcsnset(pNextDir,TEXT('\0'),1);
					_tcsinc(pNextDir);
				}

                //
                // Make sure the directory name is not too long
                //

                if (_tcslen(pUserCPDir) < MAX_PATH) {

                    if (! (pDirPath = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
                        break;

                    pCPInfo->pDirPath[pCPInfo->nDirs++] = pDirPath;
                    _tcscpy(pDirPath, pUserCPDir);
                }

                pUserCPDir = pNextDir;
            }

            MemFree(pSavedPtr);
        }

        //
        // Append path separators at the end if necessary
        //

        for (nDirs=0; nDirs < pCPInfo->nDirs; nDirs++) {

            AppendPathSeparator(pCPInfo->pDirPath[nDirs]);
            Verbose(("Cover page directory: %ws\n", pCPInfo->pDirPath[nDirs]));
        }
    }

    return pCPInfo;
}



VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Free up memory used for cover page information

Arguments:

    pCPInfo - Points to cover page information to be freed

Return Value:

    NONE

--*/

{
    if (pCPInfo) {

        INT index;

        for (index=0; index < pCPInfo->nDirs; index++)
            MemFree(pCPInfo->pDirPath[index]);

        MemFree(pCPInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\abobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    abobj.cpp

Abstract:

    Interface to the common address book.

Environment:

        Fax send wizard

Revision History:

        09/02/99 -v-sashab-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>
#include <assert.h>
#include <mbstring.h>

#include <mapix.h>

#include "faxui.h"
#include "abobj.h"


/*
    Comparison operator 'less'
    Compare two PRECIPIENT by recipient's name and fax number
*/
bool 
CRecipCmp::operator()(
    const PRECIPIENT pcRecipient1, 
    const PRECIPIENT pcRecipient2) const
{
    bool bRes = false;
    int  nFaxNumberCpm = 0;

    if(!pcRecipient1 ||
       !pcRecipient2 ||
       !pcRecipient1->pAddress || 
       !pcRecipient2->pAddress)
    {
        assert(false);
        return bRes;
    }

    nFaxNumberCpm = _tcscmp(pcRecipient1->pAddress, pcRecipient2->pAddress);

    if(nFaxNumberCpm < 0)
    {
        bRes = true;
    }
    else if(nFaxNumberCpm == 0)
    {
        //
        // The fax numbers are same
        // lets compare the names
        //
        if(pcRecipient1->pName && pcRecipient2->pName)
        {
            bRes = (_tcsicmp(pcRecipient1->pName, pcRecipient2->pName) < 0);
        }
        else
        {
            bRes = (pcRecipient1->pName < pcRecipient2->pName);
        }
    }

    return bRes;
}



static
LPWSTR
DupUnicodeString(
    LPWSTR  pStr
    );

static
LPWSTR
DupStringAnsiToUnicode(
    LPSTR  pAnsiStr
    );

static
LPSTR
DupAnsiString(
    LPSTR  pStr
    );

static
LPSTR
DupStringUnicodeToAnsi(
    LPWSTR  pUnicodeStr
    );

#ifdef  UNICODE
#define	DupString(String)	DupStringAnsiToUnicode(String)
#else   // !UNICODE
#define	DupString(String)	DupAnsiString(String)
#endif

#ifdef  UNICODE
#define	StringToAnsi(String)	::DupStringUnicodeToAnsi(String)
#else   // !UNICODE
#define	StringToAnsi(String)	::DupAnsiString(String)
#endif


static
LPSPropValue
FindProp(
    LPSPropValue rgprop,
    ULONG cprop,
    ULONG ulPropTag
    );

#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)

static SizedSPropTagArray(9, sPropTags) =
{
    9,
    {
        PR_ADDRTYPE_A,
        PR_EMAIL_ADDRESS_A,
        PR_DISPLAY_NAME_A,
        PR_PRIMARY_FAX_NUMBER_A,
        PR_HOME_FAX_NUMBER_A,
        PR_BUSINESS_FAX_NUMBER_A,
        PR_COUNTRY_A,
        PR_OBJECT_TYPE,
        PR_EMS_AB_PROXY_ADDRESSES_A
    }
};

HINSTANCE   CCommonAbObj::m_hInstance = NULL;

CCommonAbObj::CCommonAbObj(
	HINSTANCE hInstance
    ) : m_lpAdrBook(NULL), m_lpMailUser(NULL)
/*++

Routine Description:

    Constructor for CCommonAbObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    m_hInstance = hInstance;
}

CCommonAbObj::~CCommonAbObj()
/*++

Routine Description:

    Destructor for CCommonAbObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
}


BOOL
CCommonAbObj::Address(
    HWND        hWnd,
    PRECIPIENT  pOldRecipList,
    PRECIPIENT* ppNewRecipList
    )
/*++

Routine Description:

    Bring up the address book UI.  Prepopulate the to box with the entries in
    pRecipient.  Return the modified entries in ppNewRecip.

Arguments:

    hWnd            - window handle to parent window
    pOldRecipList   - list of recipients to look up
    ppNewRecipList  - list of new/modified recipients

Return Value:

    TRUE if all recipients had a fax number.
    FALSE if one or more of them didn't.

--*/
{
    ADRPARM AdrParms = { 0 };
    HRESULT hr;
    DWORD i;
    DWORD nRecips;
    PRECIPIENT tmpRecipient;
    ULONG DestComps[1] = { MAPI_TO };
    DWORD cDropped = 0;
    LPSTR pAnsiAddress = NULL;
    LPSTR pAnsiName = NULL;
    UINT  ucPropertiesNum;
    DWORD dwRes = ERROR_SUCCESS;
    TCHAR tszCaption[MAX_PATH] = {0};
    char  szAnsiCaption[MAX_PATH] = {0};

    nRecips = 0;
    tmpRecipient = pOldRecipList;

    m_hWnd = hWnd;
    m_PickNumber = 0;

    //
    // count recipients and set up initial address list
    //
    while (tmpRecipient) 
    {
        nRecips++;
        tmpRecipient = (PRECIPIENT) tmpRecipient->pNext;
    }

    if (nRecips > 0) 
    {
        hr = ABAllocateBuffer( CbNewADRLIST( nRecips ), (LPVOID *) &m_lpAdrList );
        if(!m_lpAdrList)
        {
            goto exit;
        }
        m_lpAdrList->cEntries = nRecips;
    } 
    else 
    {
        m_lpAdrList = NULL;
    }

    for (i = 0, tmpRecipient = pOldRecipList; i < nRecips; i++, tmpRecipient = tmpRecipient->pNext) 
    {
        LPENTRYID       lpEntryId;
        ULONG           cbEntryId;
        LPADRENTRY      lpAdrEntry = &m_lpAdrList->aEntries[i];

        ucPropertiesNum = tmpRecipient->bFromAddressBook ? 5 : 4;

        lpAdrEntry->cValues = ucPropertiesNum;
		lpAdrEntry->ulReserved1 = 0;        

        hr = ABAllocateBuffer(sizeof( SPropValue ) * ucPropertiesNum, 
                              (LPVOID *) &lpAdrEntry->rgPropVals );
        if(!lpAdrEntry->rgPropVals)
        {
            goto exit;
        }
        ZeroMemory( lpAdrEntry->rgPropVals, sizeof( SPropValue ) * ucPropertiesNum );

        if (tmpRecipient->bFromAddressBook)
        {
            assert(tmpRecipient->lpEntryId);
            lpEntryId = (LPENTRYID)tmpRecipient->lpEntryId;
            cbEntryId = tmpRecipient->cbEntryId;

            lpAdrEntry->rgPropVals[4].ulPropTag = PR_OBJECT_TYPE;
            lpAdrEntry->rgPropVals[4].Value.l   = MAPI_MAILUSER;
        }
        else
        {
			if (tmpRecipient->pAddress && !(pAnsiAddress = StringToAnsi(tmpRecipient->pAddress)))
			{
				goto exit;
			}
			if (tmpRecipient->pName && !(pAnsiName = StringToAnsi(tmpRecipient->pName)))
			{
				MemFree(pAnsiAddress);
				goto exit;
			}
			hr = m_lpAdrBook->CreateOneOff(
					(LPTSTR)pAnsiName,
					(LPTSTR)"FAX",
					(LPTSTR)pAnsiAddress,
					0,
					&cbEntryId,
					&lpEntryId
					);
			MemFree(pAnsiAddress);
			MemFree(pAnsiName);
			if (FAILED(hr))
			{
				goto exit;
			}             
		}

        lpAdrEntry->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
        lpAdrEntry->rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
        lpAdrEntry->rgPropVals[2].ulPropTag = PR_PRIMARY_FAX_NUMBER_A;
        lpAdrEntry->rgPropVals[3].ulPropTag = PR_ENTRYID;

        lpAdrEntry->rgPropVals[1].Value.l = MAPI_TO;

#ifdef  UNICODE
        if (tmpRecipient->pName && !(lpAdrEntry->rgPropVals[0].Value.lpszA = DupStringUnicodeToAnsi( lpAdrEntry->rgPropVals, tmpRecipient->pName )))
		{
			goto exit;
		}
        if (tmpRecipient->pAddress && !(lpAdrEntry->rgPropVals[2].Value.lpszA = DupStringUnicodeToAnsi( lpAdrEntry->rgPropVals, tmpRecipient->pAddress )))
		{
			goto exit;
		}

#else   // !UNICODE
        if (tmpRecipient->pName && !(lpAdrEntry->rgPropVals[0].Value.lpszA = DuplicateAnsiString( lpAdrEntry->rgPropVals, tmpRecipient->pName )))
		{
			goto exit;
		}
        if (tmpRecipient->pAddress && !(lpAdrEntry->rgPropVals[2].Value.lpszA = DuplicateAnsiString( lpAdrEntry->rgPropVals, tmpRecipient->pAddress )))
		{
			goto exit;
		}
#endif
		if (lpEntryId && !(lpAdrEntry->rgPropVals[3].Value.bin.lpb =  (LPBYTE)DuplicateEntryId(cbEntryId,lpAdrEntry->rgPropVals,lpEntryId)))
		{
			goto exit;
		}
		lpAdrEntry->rgPropVals[3].Value.bin.cb = cbEntryId;
    }


    if(::LoadString(m_hInstance, 
                    IDS_ADDRESS_BOOK_CAPTION, 
                    tszCaption,
                    ARR_SIZE(tszCaption)))
    {
#ifdef  UNICODE
        if(WideCharToMultiByte(CP_ACP, 
                               0, 
                               tszCaption, 
                               -1, 
                               szAnsiCaption, 
                               sizeof(szAnsiCaption), 
                               NULL, 
                               NULL))
        {
            AdrParms.lpszCaption = (LPTSTR)szAnsiCaption;
        }
#else   // !UNICODE
        AdrParms.lpszCaption = tszCaption;
#endif
    }

    AdrParms.cDestFields = 1;
    AdrParms.ulFlags = DIALOG_MODAL;
    AdrParms.nDestFieldFocus = 0;
    AdrParms.lpulDestComps = DestComps;

    //
    // Bring up the address book UI
    //
    hr = m_lpAdrBook->Address(
                (ULONG_PTR *) &hWnd,
                &AdrParms,
                &m_lpAdrList
                );

	//
	// IAddrBook::Address returns always S_OK (according to MSDN, July 1999), but ...
	//
    if (FAILED (hr) || !m_lpAdrList || m_lpAdrList->cEntries == 0) {
        //
        // in this case the user pressed cancel, so we skip resolving 
        // any of our addresses that aren't listed in the AB
        //
        goto exit;
    }

    //
    // Resolve names
    //
    hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hWnd, 0, NULL, m_lpAdrList);

exit:
    if (m_lpAdrList) 
	{
        m_lpMailUser = NULL;

        __try
        {
            m_setRecipients.clear();
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            goto error;
        }

        for (i = cDropped = 0; i < m_lpAdrList->cEntries; i++) 
		{
            LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[i];

            dwRes = InterpretAddress(lpAdrEntry->rgPropVals, 
                                     lpAdrEntry->cValues, 
                                     ppNewRecipList,
                                     pOldRecipList);
            if(ERROR_SUCCESS == dwRes)
            {
                continue;
            }
            else if(ERROR_INVALID_DATA == dwRes)
            {
                ++cDropped;
            }
            else
            {
                break;
            }
        }

error:
        if(m_lpMailUser)
        {
            m_lpMailUser->Release();
            m_lpMailUser = NULL;
        }

        //
        // Clean up
        //
        for (ULONG iEntry = 0; iEntry < m_lpAdrList->cEntries; ++iEntry)
        {
            if(m_lpAdrList->aEntries[iEntry].rgPropVals)
            {
                ABFreeBuffer(m_lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        ABFreeBuffer(m_lpAdrList);
        m_lpAdrList = NULL;
    }

    m_hWnd = NULL;

    return cDropped == 0;
}

LPTSTR
CCommonAbObj::AddressEmail(
    HWND hWnd
    )
/*++

Routine Description:

    Bring up the address book UI.  Returns an E-mail address.

Arguments:

    hWnd - window handle to parent window

Return Value:

    A choosen E-mail address.
    NULL otherwise.

--*/
{
    ADRPARM AdrParms = { 0 };
    HRESULT hr;
	LPTSTR	lptstrEmailAddress = NULL;

    m_hWnd = hWnd;

    m_lpAdrList = NULL;

    AdrParms.ulFlags = DIALOG_MODAL | ADDRESS_ONE | AB_RESOLVE ;
    AdrParms.lpszCaption = (LPTSTR)( "Address Book" );

    //
    // Bring up the address book UI
    //
	hr = m_lpAdrBook->Address(		
                                (ULONG_PTR *) &hWnd,
				&AdrParms,
				&m_lpAdrList
				);

	//
	// IAddrBook::Address returns always S_OK (according to MSDN, July 1999), but ...
	//

	if (FAILED(hr)) 
	{
		return NULL;	
	}

	if (!m_lpAdrList)
	{
		assert(m_lpAdrList->cEntries==1);
	}

    if (m_lpAdrList && (m_lpAdrList->cEntries != 0) ) {

		LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[0];

		lptstrEmailAddress = InterpretEmailAddress( lpAdrEntry->rgPropVals, lpAdrEntry->cValues);

		ABFreeBuffer(m_lpAdrList->aEntries[0].rgPropVals);
        ABFreeBuffer(m_lpAdrList);

        m_lpAdrList = NULL;
    }

    m_hWnd = NULL;

    return lptstrEmailAddress;
}

DWORD
CCommonAbObj::InterpretAddress(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT *ppNewRecipList,
    PRECIPIENT pOldRecipList
    )
/*++

Routine Description:

    Interpret the address book entry represented by SPropVal.

Arguments:

    SPropVal - Property values for address book entry.
    cValues - number of property values
    ppNewRecip - new recipient list

Return Value:

    ERROR_SUCCESS      - if all of the entries have a fax number.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.

--*/
{
    DWORD dwRes = ERROR_INVALID_DATA;
    LPSPropValue lpSPropVal;

    RECIPIENT NewRecipient = {0};

    //
    // get the object type
    //
    lpSPropVal = FindProp( SPropVal, cValues, PR_OBJECT_TYPE );

    if (lpSPropVal) 
    {
        //
        // If the object is a mail user, get the fax numbers and add the recipient
        // to the list.  If the object is a distribtion list, process it.
        //

        switch (lpSPropVal->Value.l) 
        {
            case MAPI_MAILUSER:

                dwRes = GetRecipientInfo(SPropVal, 
                                         cValues, 
                                         &NewRecipient,
                                         pOldRecipList);                                     
                if(ERROR_SUCCESS == dwRes)
                {
                    dwRes = AddRecipient(ppNewRecipList, 
                                         &NewRecipient,   
                                         TRUE);
                }

                break;

            case MAPI_DISTLIST:

                dwRes = InterpretDistList( SPropVal, 
                                           cValues, 
                                           ppNewRecipList,
                                           pOldRecipList);
        }

        return dwRes;

    } 
    else 
    {

        //
        // If there is no object type then this is valid entry that we queried on that went unresolved.
        // We know that there is a fax number so add it.
        //
        if(GetOneOffRecipientInfo( SPropVal, 
                                   cValues, 
                                   &NewRecipient,
                                   pOldRecipList)) 
		{
            dwRes = AddRecipient(ppNewRecipList,
                                 &NewRecipient,
                                 FALSE);
        }
    }

    return dwRes;
}

LPTSTR
CCommonAbObj::InterpretEmailAddress(
    LPSPropValue SPropVal,
    ULONG cValues
    )
/*++

Routine Description:

    Interpret the address book entry represented by SPropVal.

Arguments:

    SPropVal - Property values for address book entry.
    cValues - number of property values
    
Return Value:

    A choosen E-mail address
    NULL otherwise.

--*/
{
    LPSPropValue lpSPropVal;
    LPTSTR	lptstrEmailAddress = NULL;
    BOOL rVal = FALSE;
	TCHAR tszBuffer[MAX_STRING_LEN];
    //
    // get the object type
    //
    lpSPropVal = FindProp( SPropVal, cValues, PR_OBJECT_TYPE );

	assert(lpSPropVal!=NULL);

    if (lpSPropVal->Value.l == MAPI_MAILUSER) 
    {		
		lptstrEmailAddress = GetEmail( SPropVal, cValues);

        return lptstrEmailAddress;
    } 
    else 
    {
		if (!::LoadString((HINSTANCE )m_hInstance, IDS_ERROR_RECEIPT_DL,tszBuffer, MAX_STRING_LEN))
		{
            assert(FALSE);
		}
		else
        {
		    AlignedMessageBox( m_hWnd, tszBuffer, NULL, MB_ICONSTOP | MB_OK);
        }
    }

    return lptstrEmailAddress;
}


DWORD
CCommonAbObj::InterpretDistList(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT* ppNewRecipList,
    PRECIPIENT pOldRecipList
    )
/*++

Routine Description:

    Process a distribution list.

Arguments:

    SPropVal       - Property values for distribution list.
    cValues        - Number of properties.
    ppNewRecipList - New recipient list.
    pOldRecipList  - Old recipient list.

Return Value:

    ERROR_SUCCESS      - if all of the entries have a fax number.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.

--*/

#define EXIT_IF_FAILED(hr) { if (FAILED(hr)) goto ExitDistList; }

{
    LPSPropValue    lpPropVals;
    LPSRowSet       pRows = NULL;
    LPDISTLIST      lpMailDistList = NULL;
    LPMAPITABLE     pMapiTable = NULL;
    ULONG           ulObjType, cRows;
    HRESULT         hr;
    DWORD           dwRes = ERROR_INVALID_DATA;

    lpPropVals = FindProp( SPropVal, cValues, PR_ENTRYID );

    if (lpPropVals) {
        LPENTRYID lpEntryId = (LPENTRYID) lpPropVals->Value.bin.lpb;
        DWORD cbEntryId = lpPropVals->Value.bin.cb;

        //
        // Open the recipient entry
        //

        hr = m_lpAdrBook->OpenEntry(
                    cbEntryId,
                    lpEntryId,
                    (LPCIID) NULL,
                    0,
                    &ulObjType,
                    (LPUNKNOWN *) &lpMailDistList
                    );

        EXIT_IF_FAILED( hr );

        //
        // Get the contents table of the address entry
        //

        hr = lpMailDistList->GetContentsTable(
                    MAPI_DEFERRED_ERRORS,
                    &pMapiTable
                    );

        EXIT_IF_FAILED(hr);

        //
        // Limit the query to only the properties we're interested in
        //

        hr = pMapiTable->SetColumns((LPSPropTagArray) &sPropTags, 0);

        EXIT_IF_FAILED(hr);

        //
        // Get the total number of rows
        //

        hr = pMapiTable->GetRowCount(0, &cRows);

        EXIT_IF_FAILED(hr);

        //
        // Get the individual entries of the distribution list
        //

        hr = pMapiTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);

        EXIT_IF_FAILED(hr);

        hr = pMapiTable->QueryRows(cRows, 0, &pRows);

        EXIT_IF_FAILED(hr);

        hr = S_OK;


        if (pRows && pRows->cRows) 
        {
            //
            // Handle each entry of the distribution list in turn:
            //  for simple entries, call InterpretAddress
            //  for embedded distribution list, call this function recursively
            //

            for (cRows = 0; cRows < pRows->cRows; cRows++) 
            {
                LPSPropValue lpProps = pRows->aRow[cRows].lpProps;
                ULONG cRowValues = pRows->aRow[cRows].cValues;

                lpPropVals = FindProp( lpProps, cRowValues, PR_OBJECT_TYPE );

                if (lpPropVals) 
                {
                    switch (lpPropVals->Value.l) 
                    {
                        case MAPI_MAILUSER:
                        {                                                       
                            dwRes = InterpretAddress( lpProps, 
                                                      cRowValues, 
                                                      ppNewRecipList,
                                                      pOldRecipList);
                            break;
                        }
                        case MAPI_DISTLIST:
                        {
                            dwRes = InterpretDistList( lpProps, 
                                                       cRowValues, 
                                                       ppNewRecipList,
                                                       pOldRecipList);
                            break;
                        }
                    }
                }
            }

        }
    }

ExitDistList:
    //
    // Perform necessary clean up before returning to caller
    //
    if (pRows) 
    {
        for (cRows = 0; cRows < pRows->cRows; cRows++) 
        {
            ABFreeBuffer(pRows->aRow[cRows].lpProps);
        }

        ABFreeBuffer(pRows);
    }

    if (pMapiTable)
    {
        pMapiTable->Release();
    }

    if (lpMailDistList)
    {
        lpMailDistList->Release();
    }

    return dwRes;
}

INT_PTR
CALLBACK
ChooseFaxNumberDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Dialog proc for choose fax number dialog.

Arguments:

    lParam - pointer to PickFax structure.

Return Value:

    Control id of selection.

--*/

{
    PPICKFAX pPickFax = (PPICKFAX) lParam;

    switch (uMsg) 
    { 
        case WM_INITDIALOG:
        {

            TCHAR szTitle[MAX_PATH]  = {0};
            TCHAR szFormat[MAX_PATH] = {0};

            if(LoadString(CCommonAbObj::m_hInstance, 
                          IDS_CHOOSE_FAX_NUMBER, 
                          szFormat, 
                          MAX_PATH-1))
            {
                _sntprintf(szTitle, MAX_PATH-1, szFormat, pPickFax->DisplayName);
                SetDlgItemText(hDlg, IDC_DISPLAY_NAME, szTitle);
            }
            else
            {
                assert(FALSE);
            }                       

            if(pPickFax->BusinessFax)
            {
                SetDlgItemText(hDlg, IDC_BUSINESS_FAX_NUM, pPickFax->BusinessFax);
                CheckDlgButton(hDlg, IDC_BUSINESS_FAX, BST_CHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_BUSINESS_FAX), FALSE);
            }

            if(pPickFax->HomeFax)
            {
                SetDlgItemText(hDlg, IDC_HOME_FAX_NUM, pPickFax->HomeFax);

                if(!pPickFax->BusinessFax)
                {
                    CheckDlgButton(hDlg, IDC_HOME_FAX, BST_CHECKED);
                }
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_HOME_FAX), FALSE);
            }

            if(pPickFax->OtherFax)
            {
                SetDlgItemText(hDlg, IDC_OTHER_FAX_NUM, pPickFax->OtherFax);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_OTHER_FAX), FALSE);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {            
            switch(LOWORD(wParam))
            {
            case IDOK:
                DWORD dwRes;
                if(IsDlgButtonChecked( hDlg, IDC_BUSINESS_FAX ))
                {
                    dwRes = IDC_BUSINESS_FAX;
                }
                else if(IsDlgButtonChecked( hDlg, IDC_HOME_FAX ))
                {
                    dwRes = IDC_HOME_FAX;
                }
                else
                {
                    dwRes = IDC_OTHER_FAX;
                }

                EndDialog( hDlg, dwRes);
                return TRUE;
                
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL);
                return TRUE;
            }
        }

        default:
            return FALSE;

    }

    return FALSE;
}

PRECIPIENT
CCommonAbObj::FindRecipient(
    PRECIPIENT   pRecipient,
    PRECIPIENT   pRecipList
)
/*++

Routine Description:

    Find recipient (pRecipient) in the recipient list (pRecipList)
    by recipient name and fax number

Arguments:

    pRecipList      - pointer to recipient list
    pRecipient      - pointer to recipient data

Return Value:

    pointer to RECIPIENT structure if found
    NULL - otherwise.
   
--*/
{
    if(!pRecipient || !pRecipList || !pRecipient->pName || !pRecipient->pAddress)
    {
        return NULL;
    }

    while(pRecipList)
    {
        if(pRecipList->pName && pRecipList->pAddress &&
           !_tcscmp(pRecipList->pName, pRecipient->pName) &&
           !_tcscmp(pRecipList->pAddress, pRecipient->pAddress))
        {
            return pRecipList;
        }
        pRecipList = pRecipList->pNext;
    }

    return NULL;
}

PRECIPIENT  
CCommonAbObj::FindRecipient(
    PRECIPIENT   pRecipList,
    PICKFAX*     pPickFax
)
/*++

Routine Description:

    Find recipient (pPickFax) in the recipient list (pRecipList)
    by recipient name and fax number

Arguments:

    pRecipList      - pointer to recipient list
    pPickFax        - pointer to recipient data

Return Value:

    pointer to RECIPIENT structure if found
    NULL - otherwise.
   
--*/
{
    if(!pRecipList || !pPickFax || !pPickFax->DisplayName)
    {
        return NULL;
    }

    while(pRecipList)
    {
        if(pRecipList->pName && pRecipList->pAddress &&
           !_tcscmp(pRecipList->pName, pPickFax->DisplayName))
        {
            if((pPickFax->BusinessFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->BusinessFax)) ||
               (pPickFax->HomeFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->HomeFax))     ||
               (pPickFax->OtherFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->OtherFax)))
            {
                return pRecipList;
            }
        }

        pRecipList = pRecipList->pNext;
    }

    return NULL;
}


#define StrPropOk( strprop )    ((strprop) && (strprop)->Value.lpszA && *(strprop)->Value.lpszA)

DWORD
CCommonAbObj::GetRecipientInfo(
    LPSPropValue SPropVals,
    ULONG        cValues,
    PRECIPIENT   pNewRecip,
    PRECIPIENT   pOldRecipList
    )
/*++

Routine Description:

    Get the fax number and display name properties.

Arguments:

    SPropVal      - Property values for distribution list.
    cValues       - Number of properties.
    pNewRecip     - [out] pointer to the new recipient
    pOldRecipList - [in]  pointer to the old recipient list

Return Value:

    ERROR_SUCCESS      - if there is a fax number and display name.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.
   
--*/

{
    DWORD dwRes = ERROR_SUCCESS;
    LPSPropValue lpPropVals;
    LPSPropValue lpPropArray;
    BOOL Result = FALSE;
    PICKFAX PickFax = { 0 };
    DWORD   dwFaxes = 0;

    assert(pNewRecip);
    ZeroMemory(pNewRecip, sizeof(RECIPIENT));

    //
    // Get the entryid and open the entry.
    //
    lpPropVals = FindProp( SPropVals, cValues, PR_ENTRYID );

    if (lpPropVals) 
    {
        ULONG lpulObjType;
        LPMAILUSER lpMailUser = NULL;
        HRESULT hr;
        ULONG countValues;

        pNewRecip->cbEntryId = lpPropVals->Value.bin.cb;
        ABAllocateBuffer(pNewRecip->cbEntryId, (LPVOID *)&pNewRecip->lpEntryId);
        if(!pNewRecip->lpEntryId)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(pNewRecip->lpEntryId, lpPropVals->Value.bin.lpb, pNewRecip->cbEntryId);
        }


        hr = m_lpAdrBook->OpenEntry(pNewRecip->cbEntryId,
                                    (ENTRYID*)pNewRecip->lpEntryId,
                                    (LPCIID) NULL,
                                    0,
                                    &lpulObjType,
                                    (LPUNKNOWN *) &lpMailUser);
        if (HR_SUCCEEDED(hr)) 
        {
            //
            // Get the properties.
            //
            hr = ((IMailUser *)lpMailUser)->GetProps((LPSPropTagArray)&sPropTags, 
                                                     0, 
                                                     &countValues, 
                                                     &lpPropArray );
            if (HR_SUCCEEDED(hr)) 
            {
                lpPropVals = FindProp( lpPropArray, countValues, PR_PRIMARY_FAX_NUMBER_A );
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.OtherFax = DupString(lpPropVals->Value.lpszA);
                    if(PickFax.OtherFax && _tcslen(PickFax.OtherFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_BUSINESS_FAX_NUMBER_A );
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.BusinessFax = DupString(lpPropVals->Value.lpszA);
                    if(PickFax.BusinessFax && _tcslen(PickFax.BusinessFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_HOME_FAX_NUMBER_A );
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.HomeFax = DupString(lpPropVals->Value.lpszA);
                    if(PickFax.HomeFax && _tcslen(PickFax.HomeFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_DISPLAY_NAME_A );
                if (StrPropOk( lpPropVals )) 
                {
                    pNewRecip->pName = PickFax.DisplayName = DupString(lpPropVals->Value.lpszA);
                }

                lpPropVals = FindProp( lpPropArray, countValues, PR_COUNTRY_A );
                if (StrPropOk( lpPropVals )) 
                {
                    pNewRecip->pCountry = PickFax.Country = DupString(lpPropVals->Value.lpszA);
                }

                if (0 == dwFaxes)  
                {
                    lpPropVals = FindProp( lpPropArray, countValues, PR_ADDRTYPE_A);

                    if(lpPropVals && !strcmp(lpPropVals->Value.lpszA, "FAX"))
                    {
                        lpPropVals = FindProp( lpPropArray, countValues, PR_EMAIL_ADDRESS_A);
                        if (StrPropOk( lpPropVals )) 
                        {
                            pNewRecip->pAddress = DupString(lpPropVals->Value.lpszA);
                            if(pNewRecip->pAddress)
                            {
                                ++dwFaxes;
                            }
                        }
                    }
                }

                PRECIPIENT pRecip = FindRecipient(pOldRecipList, &PickFax);
                if(pRecip)
                {
                    pNewRecip->pAddress     = StringDup(pRecip->pAddress);
                    pNewRecip->dwCountryId  = pRecip->dwCountryId;
                    pNewRecip->bUseDialingRules = pRecip->bUseDialingRules;

                    MemFree(PickFax.BusinessFax);
                    PickFax.BusinessFax = NULL;
                    MemFree(PickFax.HomeFax);
                    PickFax.HomeFax = NULL;
                    MemFree(PickFax.OtherFax);
                    PickFax.OtherFax = NULL;

                    dwFaxes = 1;
                }

                //
                // If there are more then 1 fax numbers, ask the user to pick one.
                //
                if (dwFaxes > 1) 
                {
                    INT_PTR nResult;
                    nResult = DialogBoxParam((HINSTANCE) m_hInstance,
                                             MAKEINTRESOURCE( IDD_CHOOSE_FAXNUMBER ),
                                             m_hWnd,
                                             ChooseFaxNumberDlgProc,
                                             (LPARAM) &PickFax);
                    switch( nResult ) 
                    {
                        case IDC_BUSINESS_FAX:
                            pNewRecip->pAddress = PickFax.BusinessFax;

                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;
                            break;

                        case IDC_HOME_FAX:
                            pNewRecip->pAddress = PickFax.HomeFax;

                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;
                            break;

                        case IDC_OTHER_FAX:
                            pNewRecip->pAddress = PickFax.OtherFax;

                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            break;

                        case IDCANCEL:
                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;

                            dwRes = ERROR_CANCELLED;
                            break;
                    }
                } 
            }

            ABFreeBuffer( lpPropArray );
        }

        if(!m_lpMailUser)
        {
            //
            // Remember the first MailUser and do not release it
            // to avoid release of the MAPI DLLs
            // m_lpMailUser should be released later
            //
            m_lpMailUser = lpMailUser;
        }
        else if(lpMailUser) 
        {
            lpMailUser->Release();
            lpMailUser = NULL;
        }
    } 

    if (0 == dwFaxes)   
    {
        lpPropVals = FindProp( SPropVals, cValues, PR_ADDRTYPE_A);

        if(lpPropVals && !strcmp(lpPropVals->Value.lpszA, "FAX"))
        {
            lpPropVals = FindProp( SPropVals, cValues, PR_EMAIL_ADDRESS_A);
            if (StrPropOk( lpPropVals )) 
            {
                WCHAR* pwAddress = DupStringAnsiToUnicode(lpPropVals->Value.lpszA);
                if(pwAddress)
                {
                    WCHAR* ptr = wcschr(pwAddress, L'@');
                    if(ptr)
                    {
                        ptr++;

                        #ifdef  UNICODE
                            pNewRecip->pAddress = ::StringDup(ptr);
                        #else   // !UNICODE
                            pNewRecip->pAddress = ::DupStringUnicodeToAnsi(ptr);
                        #endif
                    }
                    else
                    {
                        pNewRecip->pAddress = DupString(lpPropVals->Value.lpszA);
                    }
                    MemFree(pwAddress);
                }
            }

            lpPropVals = FindProp( SPropVals, cValues, PR_DISPLAY_NAME_A);
            if (StrPropOk( lpPropVals )) 
            {
                MemFree(pNewRecip->pName);
                pNewRecip->pName = NULL;

                pNewRecip->pName = DupString(lpPropVals->Value.lpszA);
            }
        }
    }

    if (PickFax.BusinessFax) 
    {
        pNewRecip->pAddress = PickFax.BusinessFax;
    } 
    else if (PickFax.HomeFax) 
    {
        pNewRecip->pAddress = PickFax.HomeFax;
    }
    else if (PickFax.OtherFax) 
    {
        pNewRecip->pAddress = PickFax.OtherFax;
    }

    if (ERROR_CANCELLED != dwRes && 
       (!pNewRecip->pAddress || !pNewRecip->pName))
    {
        dwRes = ERROR_INVALID_DATA;
    } 

    if(ERROR_SUCCESS != dwRes)
    {
        MemFree(pNewRecip->pName);
        MemFree(pNewRecip->pAddress);
        MemFree(pNewRecip->pCountry);
        ABFreeBuffer(pNewRecip->lpEntryId);
        ZeroMemory(pNewRecip, sizeof(RECIPIENT));
    }

    return dwRes;
}

BOOL
CCommonAbObj::GetOneOffRecipientInfo(
    LPSPropValue SPropVals,
    ULONG        cValues,
    PRECIPIENT   pNewRecip,
    PRECIPIENT   pOldRecipList
    )
/*++

Routine Description:

    Get the fax number and display name properties.

Arguments:

    SPropVal      - Property values for distribution list.
    cValues       - Number of properties.
    pNewRecip     - [out] pointer to a new recipient
    pOldRecipList - pointer to the old recipient list

Return Value:

    TRUE if there is a fax number and display name.
    FALSE otherwise.

--*/

{
    PRECIPIENT  pRecip = NULL;
    LPSPropValue lpPropVals;

	assert(!pNewRecip);

    lpPropVals = FindProp( SPropVals, cValues, PR_PRIMARY_FAX_NUMBER_A );
    if (lpPropVals) 
    {
        if (!(pNewRecip->pAddress = DupString(lpPropVals->Value.lpszA)))
        {
			goto error;
        }
    }

    lpPropVals = FindProp( SPropVals, cValues, PR_DISPLAY_NAME_A );
    if (lpPropVals) 
    {
        if (!(pNewRecip->pName = DupString(lpPropVals->Value.lpszA)))
        {
			goto error;
        }
    }

    pRecip = FindRecipient(pNewRecip, pOldRecipList);
    if(pRecip)
    {
        pNewRecip->dwCountryId  = pRecip->dwCountryId;
        pNewRecip->bUseDialingRules = pRecip->bUseDialingRules;
    }

	return TRUE;

error:
	MemFree(pNewRecip->pAddress);
	MemFree(pNewRecip->pName);
	return FALSE;
}

LPTSTR
CCommonAbObj::GetEmail(
    LPSPropValue SPropVals,
    ULONG cValues
    )
/*++

Routine Description:

    Get e-mail address

Arguments:

    SPropVal - Property values for distribution list.
    cValues - Number of properties.

Return Value:

    A choosen E-mail address
    NULL otherwise.

--*/

{
    LPSPropValue	lpPropVals;
    LPSPropValue	lpPropArray;
    BOOL			Result = FALSE;
	LPTSTR			lptstrEmailAddress = NULL;
	TCHAR			tszBuffer[MAX_STRING_LEN];

    //
    // Get the entryid and open the entry.
    //

    lpPropVals = FindProp( SPropVals, cValues, PR_ENTRYID );

    if (lpPropVals) 
    {
        ULONG lpulObjType;
        LPMAILUSER lpMailUser = NULL;
        LPENTRYID lpEntryId = (LPENTRYID)lpPropVals->Value.bin.lpb;
        DWORD cbEntryId = lpPropVals->Value.bin.cb;
        HRESULT hr;
        ULONG countValues;

        hr = m_lpAdrBook->OpenEntry(cbEntryId,
                                    lpEntryId,
                                    (LPCIID) NULL,
                                    0,
                                    &lpulObjType,
                                    (LPUNKNOWN *) &lpMailUser);
        if (HR_SUCCEEDED(hr)) 
        {
            //
            // Get the properties.
            //
            hr = ((IMailUser *) lpMailUser)->GetProps((LPSPropTagArray)&sPropTags, 
                                                      0, 
                                                      &countValues, 
                                                      &lpPropArray);
            if (HR_SUCCEEDED(hr)) 
            {
                lpPropVals = FindProp( lpPropArray, countValues, PR_ADDRTYPE_A );

                if (lpPropVals && !_mbscmp((PUCHAR)lpPropVals->Value.lpszA,(PUCHAR)"SMTP"))
                {
                    lpPropVals = FindProp( lpPropArray, countValues, PR_EMAIL_ADDRESS_A );
                    if (StrPropOk( lpPropVals )) 
                    {
                        lptstrEmailAddress = DupString(lpPropVals->Value.lpszA);
                    }
                }
                else if (lpPropVals && !_mbscmp((PUCHAR)lpPropVals->Value.lpszA,(PUCHAR)"EX"))
                {
                    lpPropVals = FindProp( lpPropArray, countValues, PR_EMS_AB_PROXY_ADDRESSES_A );
                    if (lpPropVals) 
                    {
                        for(DWORD dw=0; dw < lpPropVals->Value.MVszA.cValues; ++dw)
                        {
                            if(strstr(lpPropVals->Value.MVszA.lppszA[dw], "SMTP:"))
                            {
                                char* ptr = strchr(lpPropVals->Value.MVszA.lppszA[dw], ':');
                                ptr++;
                                lptstrEmailAddress = DupString(ptr);
                            }                            
                        }
                    }
                }
            }

            ABFreeBuffer( lpPropArray );
        }

        if (lpMailUser) 
        {
            lpMailUser->Release();
        }

    } 

    if(!lptstrEmailAddress)
    {                
        if (!::LoadString((HINSTANCE )m_hInstance, IDS_ERROR_RECEIPT_SMTP,tszBuffer, MAX_STRING_LEN))
        {
            assert(FALSE);
        }
        else
        {
            AlignedMessageBox( m_hWnd, tszBuffer, NULL, MB_ICONSTOP | MB_OK); 
        }
    }

	return	lptstrEmailAddress;
 }

LPSPropValue
FindProp(
    LPSPropValue rgprop,
    ULONG cprop,
    ULONG ulPropTag
    )
/*++

Routine Description:

    Searches for a given property tag in a propset. If the given
    property tag has type PT_UNSPECIFIED, matches only on the
    property ID; otherwise, matches on the entire tag.

Arguments:

    rgprop - Property values.
    cprop - Number of properties.
    ulPropTag - Property to search for.

Return Value:

    Pointer to property desired property value or NULL.
--*/

{
    BOOL f = PROP_TYPE(ulPropTag) == PT_UNSPECIFIED;
    LPSPropValue pprop = rgprop;

    if (!cprop || !rgprop)
    {
        return NULL;
    }

    while (cprop--)
    {
        if (pprop->ulPropTag == ulPropTag ||
           (f && PROP_ID(pprop->ulPropTag) == PROP_ID(ulPropTag)))
        {
            return pprop;
        }
        ++pprop;
    }

    return NULL;
}


LPWSTR
DupStringAnsiToUnicode(
    LPSTR  pAnsiStr
    )

/*++

Routine Description:

    Convert a multi-byte string to a Unicode string

Arguments:

    pAnsiStr - Pointer to the Ansi string to be duplicated

Return Value:

    Pointer to the duplicated Unicode string

NOTE:

    This is only need because MAPI is not Unicode enabled on NT.

    This routine uses MemAlloc to allocate memory so the caller needs
    to use MemFree.
--*/

{
    INT     nChar;
    LPWSTR  pUnicodeStr;

    //
    // Figure out how much memory to allocate for the Unicode string
    //

	if (!pAnsiStr)
		return NULL;

    if (! (nChar = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAnsiStr, -1, NULL, 0)) ||
        ! ( pUnicodeStr = (LPWSTR) MemAlloc( nChar * sizeof(WCHAR) ) ))
    {
        return NULL;
    }

    //
    // Convert multi-byte string to Unicode string
    //

    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAnsiStr, -1, pUnicodeStr, nChar);

    return pUnicodeStr;
}

LPWSTR
DupUnicodeString(
    LPWSTR  pStr
    )
/*++

Routine Description:

    Duplicate a Unicode string.

Arguments:

    pStr - pointer to string to duplicate.

Return Value:

    pointer to duplicated string.
--*/

{
    LPWSTR NewStr;

	if (!pStr)
		return NULL;

    if (!(NewStr = (LPWSTR) MemAlloc( (wcslen( pStr ) + 1) * sizeof (WCHAR))))
		return NULL;
    wcscpy( NewStr, pStr );
    return NewStr;
}

LPSTR
DupStringUnicodeToAnsi(
    LPWSTR  pUnicodeStr
    )

/*++

Routine Description:

    Convert a Unicode string to a multi-byte string

Arguments:

    pUnicodeStr - Pointer to the Unicode string to be duplicated

Return Value:

    Pointer to the duplicated multi-byte string

NOTE:

    This is only need because the MAPI is not Unicode enabled on NT.

    This uses the MAPI memory allocator so it must be freed with FreeBuffer.
--*/

{
    INT     nChar;
    LPSTR   pAnsiStr;

    //
    // Figure out how much memory to allocate for the multi-byte string
    //

    if (! (nChar = WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, NULL, 0, NULL, NULL)) ||
        ! (pAnsiStr = (LPSTR)MemAlloc( nChar )))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, pAnsiStr, nChar, NULL, NULL);
    return pAnsiStr;
}

LPSTR
DupAnsiString(
    LPSTR  pStr
    )
/*++

Routine Description:

    Duplicate an Ansi string.

Arguments:

    pStr - pointer to string to duplicate.

Return Value:

    pointer to duplicated string.
--*/

{
    LPSTR NewStr;

	if (!pStr) {
		return NULL;
	}

    if (!(NewStr = (LPSTR) MemAlloc( (strlen( pStr ) + 1) * sizeof (CHAR))))
		return NULL;
    _mbscpy( (PUCHAR)NewStr, (PUCHAR)pStr );
    return NewStr;
}

DWORD
CCommonAbObj::AddRecipient(
    PRECIPIENT *ppNewRecipList,
    PRECIPIENT pRecipient,
	BOOL	   bFromAddressBook
    )
/*++

Routine Description:

    Add a recipient to the recipient list.

Arguments:

    ppNewRecip       - pointer to pointer to list to add item to.
    pRecipient       - pointer to the new recipient data
	bFromAddressBook - boolean says if this recipient is from address book

Return Value:

    NA
--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PRECIPIENT pNewRecip = NULL;

    pNewRecip = (PRECIPIENT)MemAllocZ(sizeof(RECIPIENT));
    if(!pNewRecip)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    else
    {
        pNewRecip->pName        = pRecipient->pName;
        pNewRecip->pAddress     = pRecipient->pAddress;
        pNewRecip->pCountry     = pRecipient->pCountry;
        pNewRecip->cbEntryId    = pRecipient->cbEntryId;
        pNewRecip->lpEntryId    = pRecipient->lpEntryId;
        pNewRecip->dwCountryId  = pRecipient->dwCountryId;
        pNewRecip->bUseDialingRules = pRecipient->bUseDialingRules;
        pNewRecip->bFromAddressBook = bFromAddressBook;
        pNewRecip->pNext = *ppNewRecipList;
    }

    __try
    {
        //
        // Try to insert a recipient into the set
        //
        if(m_setRecipients.insert(pNewRecip).second == false)
        {
            //
            // Such recipient already exists
            //
            goto error;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    //
    // Add the recipient into the list
    //
    *ppNewRecipList = pNewRecip;

    return dwRes;

error:

    MemFree(pRecipient->pName);
    MemFree(pRecipient->pAddress);
    MemFree(pRecipient->pCountry);
    ABFreeBuffer(pRecipient->lpEntryId);
    ZeroMemory(pRecipient, sizeof(RECIPIENT));

    MemFree(pNewRecip);

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\async.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    async.c

Abstract:

    Functions for asynch send wizard actions

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxui.h"
#include "tapiutil.h"
#include "faxsendw.h"


DWORD
AsyncWizardThread(
    PBYTE param
    )
/*++

Routine Description:

    Do some agonizingly slow tasks asynchronously so the wizard seems faster to the user.

Arguments:

    none.

Return Value:

    not used.

--*/
{
    PWIZARDUSERMEM pWizardUserMem = (PWIZARDUSERMEM) param;
    HANDLE  FaxHandle = NULL;
    PFAX_TAPI_LINECOUNTRY_LIST  pLineCountryList = NULL;
    DWORD dwRights = 0;
    DWORD dwFaxQueueState = 0;

    Assert(pWizardUserMem);

    InitTapi ();
    if (!SetEvent(pWizardUserMem->hTAPIEvent))
    {
        Error(("Can't set hTAPIEvent. ec = 0x%X", GetLastError()));
    }
    
    if (FaxConnectFaxServer(pWizardUserMem->lptstrServerName,&FaxHandle)) 
    {
        if (!FaxAccessCheckEx (FaxHandle, MAXIMUM_ALLOWED, &dwRights))
        {
            dwRights = 0;
            Error(("FaxAccessCheckEx: failed. ec = 0X%x\n",GetLastError()));
        }
        pWizardUserMem->dwRights = dwRights;
        
        pWizardUserMem->dwSupportedReceipts = 0;
        if(!FaxGetReceiptsOptions(FaxHandle, &pWizardUserMem->dwSupportedReceipts))
        {
            Error(("FaxGetReceiptsOptions: failed. ec = 0X%x\n",GetLastError()));
        }

        if (!FaxGetQueueStates(FaxHandle,&dwFaxQueueState) )
        {
            dwFaxQueueState = 0;
            Error(("FaxGetQueueStates: failed. ec = 0X%x\n",GetLastError()));
        }
        pWizardUserMem->dwQueueStates = dwFaxQueueState;

        if (!FaxGetCountryList(FaxHandle,&pLineCountryList))
        {
            Verbose(("Can't get a country list from the server %s",
                    pWizardUserMem->lptstrServerName));
        }
        else {
            Assert(pWizardUserMem->pCountryList==NULL);
            pWizardUserMem->pCountryList = pLineCountryList;
        }

        if (FaxHandle) {
            if (!FaxClose(FaxHandle))
            {
                Verbose(("Can't close the fax handle %x",FaxHandle));
            }
        }
    }
    else {
        Verbose(("Can't connect to the fax server %s",pWizardUserMem->lptstrServerName));
    }

    if (!SetEvent(pWizardUserMem->hCountryListEvent))
    {
        Error(("Can't set hCountryListEvent. ec = 0x%X",GetLastError()));
    }

    //
    // use server coverpages (may startup fax service, which is slow)
    //
    pWizardUserMem->ServerCPOnly = UseServerCp(pWizardUserMem->lptstrServerName);
    if (!SetEvent(pWizardUserMem->hCPEvent))
    {
        Error(("Can't set hCPEvent. ec = 0x%X",GetLastError()));
    }
       
#ifdef FAX_SCAN_ENABLED
    //
    // look for twain stuff
    //
    if (!(pWizardUserMem->dwFlags & FSW_USE_SCANNER) ){
        pWizardUserMem->TwainAvail = FALSE;
    } else {
        pWizardUserMem->TwainAvail = InitializeTwain(pWizardUserMem);
    }
    if (!SetEvent(pWizardUserMem->hTwainEvent))
    {
        Error(("Can't set hTwainEvent. ec = 0x%X",GetLastError()));
    }
#endif //  FAX_SCAN_ENABLED

    return ERROR_SUCCESS;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\coverpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.h

Abstract:

    Functions for working with cover pages

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _COVERPAGE_H_
#define _COVERPAGE_H_

//
// Cover page filename extension and link filename extension
//

#define LNK_FILENAME_EXT    TEXT(".lnk")
#define MAX_FILENAME_EXT    4

//
// Data structure for representing a list of cover pages:
//  the first nServerDirs paths refer to the server cover page directory
//  remaining paths contain user cover page directories
//

#define MAX_COVERPAGE_DIRS  8

typedef struct {

    INT     nDirs;
    INT     nServerDirs;
    LPTSTR  pDirPath[MAX_COVERPAGE_DIRS];

} CPDATA, *PCPDATA;

//
// Flag bits attached to each cover page in a listbox
//

#define CPFLAG_DIRINDEX 0x00FF
#define CPFLAG_SERVERCP 0x0100
#define CPFLAG_LINK     0x0200
#define CPFLAG_SELECTED 0x0400
#define CPFLAG_SUFFIX   0x0800

//
// Generate a list of available cover pages (both server and user)
//

VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    );

//
// Retrieve the currently selected cover page name
//

INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  lptstrFullPath,
	LPTSTR  lptstrFileName,
	BOOL * pbIsServerPage
    );

//
// Allocate memory to hold cover page information
//

PCPDATA
AllocCoverPageInfo(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    BOOL	ServerCpOnly
    );

//
// must clients use server coverpages?
//

BOOL
UseServerCp(
	LPTSTR	lptstrServerName
    );

//
// Free up memory used for cover page information
//

VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    );

//
// Resolve a shortcut to find the destination file
//

BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

//
// Function to determine whether CoInitialize was called
//

BOOL
IsOleInitialized(
    VOID
    );

//
// Perform OLE initialization if necessary
//

VOID
DoOleInitialization(
    VOID
    );

#endif  // !_COVERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\help.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Help related declarations

Environment:

    Windows XP fax driver

Revision History:

    07/30/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _HELP_H_
#define _HELP_H_

//
// Name of the help file for the fax driver
//

#define HELP_FILENAME               TEXT("fax.hlp")

//
// Help indices
//

#define IDH_BILLING_CODE                  2002
#define IDH_IMAGE_QUALITY                 2025
#define IDH_LANDSCAPE                     2026
#define IDH_PAPER_SIZE                    2037
#define IDH_PORTRAIT                      2038
#define IDH_SEND_ASAP                     2046
#define IDH_SEND_AT_CHEAP                 2047
#define IDH_SEND_AT_TIME                  2048
#define IDH_EMAIL                         2049
#define IDH_FAX_SEND_GRP                  2075
#define IDH_DEFAULT_PRINT_SETUP_GRP       2070
#define IDH_ORIENTATION                   2062
#define IDH_SEND_AT_TIME                  2048

#endif  // !_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\cwabobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.h

Abstract:

    Class definition for CWabObj

Environment:

        Fax send wizard

Revision History:

        10/23/97 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#ifndef __CWABOBJ__H_
#define __CWABOBJ__H_

#include "abobj.h"

#define REGVAL_WABPATH  TEXT("Software\\Microsoft\\WAB\\DLLPath")

class CWabObj : public CCommonAbObj{
private:    
    HINSTANCE   m_hWab;
    LPWABOPEN   m_lpWabOpen;
    LPWABOBJECT m_lpWABObject;

    BOOL        m_Initialized;

    LPSTR       DupStringUnicodeToAnsi(
                        LPVOID  lpObject,
                        LPWSTR  pUnicodeStr
                        );

	LPSTR		DuplicateAnsiString(
                        LPVOID  lpObject,
						LPCSTR pSrcStr
						);

	LPENTRYID	DuplicateEntryId(
					ULONG cbSize,           
                    LPVOID		lpObject,
					LPENTRYID	lpEntryId
					) ;

	HRESULT		ABAllocateBuffer(
						ULONG cbSize,           
						LPVOID FAR * lppBuffer  
						) ;

public:

	BOOL isInitialized() const	{	return m_Initialized;	}

    CWabObj(HINSTANCE hInstance);
    ~CWabObj();
    
	ULONG ABFreeBuffer(LPVOID lpBuffer) ;

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\cwabobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.cpp

Abstract:

    Interface to the windows address book.

Environment:

        Fax send wizard

Revision History:

        10/23/97 -GeorgeJe-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>

#include <wab.h>

#include "faxui.h"
#include "cwabobj.h"


CWabObj::CWabObj(
    HINSTANCE hInstance
) : CCommonAbObj(hInstance),
    m_Initialized(FALSE),
    m_hWab(NULL),
    m_lpWabOpen(NULL),
    m_lpWABObject(NULL)
/*++

Routine Description:

    Constructor for CWabObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    TCHAR szDllPath[MAX_PATH];
    HKEY hKey = NULL;
    LONG rVal;
    DWORD dwType;
    DWORD cbData = MAX_PATH * sizeof(TCHAR);
    HRESULT hr;

    m_lpAdrBook = NULL;
    m_lpAdrList = NULL;

    //
    // get the path to wab32.dll
    //
    rVal = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGVAL_WABPATH,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if (rVal == ERROR_SUCCESS) 
    {
        rVal = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    &dwType,
                    (LPBYTE) szDllPath,
                    &cbData
                    );
    }

    if (rVal != ERROR_SUCCESS) 
    {
        _tcscpy( szDllPath, TEXT("wab32.dll") );
    }

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    m_hWab = LoadLibrary( szDllPath );
    if (m_hWab == NULL) 
    {
        return;
    }

    m_lpWabOpen = (LPWABOPEN) GetProcAddress( m_hWab , "WABOpen" );
    if(m_lpWabOpen == NULL)
    {
        return;
    }

    //
    // open the wab
    //
    hr = m_lpWabOpen( &m_lpAdrBook, &m_lpWABObject, 0, 0 );
    if (HR_SUCCEEDED(hr))         
    {
        m_Initialized = TRUE;
    }
}

CWabObj::~CWabObj()
/*++

Routine Description:

    Destructor for CWabObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    if (m_lpAdrBook) {
        m_lpAdrBook->Release();
    }

    if (m_lpWABObject) {
        m_lpWABObject->Release();
    }

    FreeLibrary( m_hWab );
}

LPSTR
CWabObj::DupStringUnicodeToAnsi(
    LPVOID  lpObject,
    LPWSTR  pUnicodeStr
    )

/*++

Routine Description:

    Convert a Unicode string to a multi-byte string

Arguments:

    pUnicodeStr - Pointer to the Unicode string to be duplicated

Return Value:

    Pointer to the duplicated multi-byte string

NOTE:

    This is only need because the WAB is not Unicode enabled on NT.

    This uses the WAB memory allocator so it must be freed with FreeBuffer.
--*/

{
    INT     nChar;
    LPSTR   pAnsiStr;

    //
    // Figure out how much memory to allocate for the multi-byte string
    //

    if (! (nChar = WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, NULL, 0, NULL, NULL)) ||
        ! HR_SUCCEEDED( m_lpWABObject->AllocateMore( nChar, lpObject, (LPVOID *) &pAnsiStr )))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, pAnsiStr, nChar, NULL, NULL);
    return pAnsiStr;
}



LPSTR
CWabObj::DuplicateAnsiString(
    LPVOID  lpObject,
    LPCSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPSTR  pDestStr;
    INT    nChar;

    if (pSrcStr != NULL) {

        nChar = (strlen(pSrcStr) + 1 )*sizeof(char);

		if ( nChar && HR_SUCCEEDED( m_lpWABObject->AllocateMore( nChar, lpObject, (LPVOID *) &pDestStr )))
            CopyMemory(pDestStr, pSrcStr, nChar);
        else
            return NULL;

    } else
        pDestStr = NULL;

    return pDestStr;
}

LPENTRYID	
CWabObj::DuplicateEntryId(
	ULONG		cbSize,           
    LPVOID		lpObject,
	LPENTRYID	lpEntryId
)
/*++

Routine Description:

    Duplicates EntryID

Arguments:

	cbSize -    [in] Size, in bytes, of the new buffer to be allocated. 
	lpObject -	[in] Pointer to an existing MAPI buffer allocated using MAPIAllocateBuffer. 
    lpEntryId - [in] Pointer to the source

Return Value:

    Pointer to new ENTRYID

--*/
{
	LPENTRYID	lpNewEntryID = NULL;

	if (!cbSize || !lpObject || !lpEntryId)
		return NULL;

	if (HR_SUCCEEDED(m_lpWABObject->AllocateMore ( cbSize, lpObject, (LPVOID *) &lpNewEntryID )))
	{
		CopyMemory(lpNewEntryID, lpEntryId, cbSize);
	}

	return lpNewEntryID;
}


HRESULT
CWabObj::ABAllocateBuffer(
	ULONG cbSize,           
	LPVOID FAR * lppBuffer  
    )

/*++

Routine Description:


Arguments:


Return Value:
--*/

{
    return m_lpWABObject->AllocateBuffer( cbSize, lppBuffer );
}


ULONG
CWabObj::ABFreeBuffer(
	LPVOID lpBuffer
	)
{
	return m_lpWABObject->FreeBuffer(lpBuffer);
}

extern "C"
VOID
FreeWabEntryID(
    PWIZARDUSERMEM	pWizardUserMem,
	LPVOID			lpEntryId
				)
/*++

Routine Description:

    C wrapper for WAB Free

Arguments:

    pWizardUserMem - pointer to WIZARDUSERMEM structure
    lpEntryID - pointer to EntryId

Return Value:
	
	  NONE

--*/
{
    CWabObj * lpCWabObj = (CWabObj *) pWizardUserMem->lpWabInit;
	lpCWabObj->ABFreeBuffer(lpEntryId);		
}

extern "C"
BOOL
CallWabAddress(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT * ppNewRecipient
    )
/*++

Routine Description:

    C wrapper for CWabObj->Address

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure
    ppNewRecipient - list to add new recipients to.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

{
    CWabObj*  lpCWabObj = (CWabObj*) pWizardUserMem->lpWabInit;

    return lpCWabObj->Address(
                hDlg,
                pWizardUserMem->pRecipients,
                ppNewRecipient
                );

}

extern "C"
LPTSTR
CallWabAddressEmail(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    C wrapper for CWabObj->AddressEmail

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    TRUE if found one appropriate E-mail
    FALSE otherwise.

--*/

{
    CWabObj*	lpCWabObj = (CWabObj*) pWizardUserMem->lpWabInit;

    return lpCWabObj->AddressEmail(
                hDlg
                );

}

extern "C"
LPVOID
InitializeWAB(
    HINSTANCE hInstance
    )
/*++

Routine Description:

    Initialize the WAB.

Arguments:

    hInstance - instance handle.

Return Value:

    NONE
--*/

{
    CWabObj* lpWabObj = new CWabObj( hInstance );

	if ((lpWabObj!=NULL) && (!lpWabObj->isInitialized()))	// constructor failed
	{
		delete lpWabObj;
		lpWabObj = NULL;
	}

    return (LPVOID) lpWabObj;
}

extern "C"
VOID
UnInitializeWAB(
    LPVOID lpVoid
    )
/*++

Routine Description:

    UnInitialize the WAB.

Arguments:

    NONE

Return Value:

    NONE
--*/

{
    CWabObj* lpWabObj = (CWabObj*) lpVoid;

    delete lpWabObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\cwabutil.h ===
#ifndef _CWABUTIL_H_
#define _CWABUTIL_H_

LPVOID 
InitializeWAB(
    HINSTANCE hInstance
    );

VOID 
UnInitializeWAB( 
    LPVOID 
    );

BOOL
CallWabAddress(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem,
    PRECIPIENT *    ppNewRecipient
    );

LPTSTR
CallWabAddressEmail(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\edkmdb.h ===
/*
 *	EDKMDB.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef	EDKMDB_INCLUDED
#define	EDKMDB_INCLUDED

/*
 *	WARNING: Many of the property id values contained within this
 *  file are subject to change.  For best results please use the
 *	literals declared here instead of the numerical values.
 */

#define pidExchangeXmitReservedMin		0x3FE0
#define pidExchangeNonXmitReservedMin	0x65E0
#define	pidProfileMin					0x6600
#define	pidStoreMin						0x6618
#define	pidFolderMin					0x6638
#define	pidMessageReadOnlyMin			0x6640
#define	pidMessageWriteableMin			0x6658
#define	pidAttachReadOnlyMin			0x666C
#define	pidSpecialMin					0x6670
#define	pidAdminMin						0x6690
#define pidSecureProfileMin				PROP_ID_SECURE_MIN

/*------------------------------------------------------------------------
 *
 *	PROFILE properties
 *
 *	These are used in profiles which contain the Exchange Messaging
 *	Service.  These profiles contain a "global section" used to store
 *	common data, plus individual sections for the transport provider,
 *	one store provider for the user, one store provider for the public
 *	store, and one store provider for each additional mailbox the user
 *	has delegate access to.
 *
 *-----------------------------------------------------------------------*/

/* GUID of the global section */

#define	pbGlobalProfileSectionGuid	"\x13\xDB\xB0\xC8\xAA\x05\x10\x1A\x9B\xB0\x00\xAA\x00\x2F\xC4\x5A"


/* Properties in the global section */

#define	PR_PROFILE_VERSION				PROP_TAG( PT_LONG, pidProfileMin+0x00)
#define	PR_PROFILE_CONFIG_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x01)
#define	PR_PROFILE_HOME_SERVER			PROP_TAG( PT_STRING8, pidProfileMin+0x02)
#define	PR_PROFILE_HOME_SERVER_DN		PROP_TAG( PT_STRING8, pidProfileMin+0x12)
#define	PR_PROFILE_HOME_SERVER_ADDRS	PROP_TAG( PT_MV_STRING8, pidProfileMin+0x13)
#define	PR_PROFILE_USER					PROP_TAG( PT_STRING8, pidProfileMin+0x03)
#define	PR_PROFILE_CONNECT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x04)
#define PR_PROFILE_TRANSPORT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x05)
#define	PR_PROFILE_UI_STATE				PROP_TAG( PT_LONG, pidProfileMin+0x06)
#define	PR_PROFILE_UNRESOLVED_NAME		PROP_TAG( PT_STRING8, pidProfileMin+0x07)
#define	PR_PROFILE_UNRESOLVED_SERVER	PROP_TAG( PT_STRING8, pidProfileMin+0x08)
#define PR_PROFILE_BINDING_ORDER		PROP_TAG( PT_STRING8, pidProfileMin+0x09)
#define PR_PROFILE_MAX_RESTRICT			PROP_TAG( PT_LONG, pidProfileMin+0x0D)
#define	PR_PROFILE_AB_FILES_PATH		PROP_TAG( PT_STRING8, pidProfileMin+0xE)
#define PR_PROFILE_OFFLINE_STORE_PATH	PROP_TAG( PT_STRING8, pidProfileMin+0x10)
#define PR_PROFILE_OFFLINE_INFO			PROP_TAG( PT_BINARY, pidProfileMin+0x11)
#define PR_PROFILE_ADDR_INFO			PROP_TAG( PT_BINARY, pidSpecialMin+0x17)
#define PR_PROFILE_OPTIONS_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x19)
#define PR_PROFILE_SECURE_MAILBOX		PROP_TAG( PT_BINARY, pidSecureProfileMin + 0)
#define PR_DISABLE_WINSOCK				PROP_TAG( PT_LONG, pidProfileMin+0x18)

/* Properties passed through the Service Entry to the OST */
#define PR_OST_ENCRYPTION				PROP_TAG(PT_LONG, 0x6702)

/* Values for PR_OST_ENCRYPTION */
#define OSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define OSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define OSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/* Properties in each profile section */

#define	PR_PROFILE_OPEN_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x09)
#define	PR_PROFILE_TYPE					PROP_TAG( PT_LONG, pidProfileMin+0x0A)
#define	PR_PROFILE_MAILBOX				PROP_TAG( PT_STRING8, pidProfileMin+0x0B)
#define	PR_PROFILE_SERVER				PROP_TAG( PT_STRING8, pidProfileMin+0x0C)
#define	PR_PROFILE_SERVER_DN			PROP_TAG( PT_STRING8, pidProfileMin+0x14)

/* Properties in the Public Folders section */

#define PR_PROFILE_FAVFLD_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x0F)
#define PR_PROFILE_FAVFLD_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x15)
#define PR_PROFILE_ALLPUB_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x16)
#define PR_PROFILE_ALLPUB_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x17)

// Current value for PR_PROFILE_VERSION
#define	PROFILE_VERSION						((ULONG)0x501)

// Bit values for PR_PROFILE_CONFIG_FLAGS

#define	CONFIG_SERVICE						((ULONG)1)
#define	CONFIG_SHOW_STARTUP_UI				((ULONG)2)
#define	CONFIG_SHOW_CONNECT_UI				((ULONG)4)
#define	CONFIG_PROMPT_FOR_CREDENTIALS		((ULONG)8)

// Bit values for PR_PROFILE_CONNECT_FLAGS

#define	CONNECT_USE_ADMIN_PRIVILEGE			((ULONG)1)
#define	CONNECT_NO_RPC_ENCRYPTION			((ULONG)2)

// Bit values for PR_PROFILE_TRANSPORT_FLAGS

#define	TRANSPORT_DOWNLOAD					((ULONG)1)
#define TRANSPORT_UPLOAD					((ULONG)2)

// Bit values for PR_PROFILE_OPEN_FLAGS

#define	OPENSTORE_USE_ADMIN_PRIVILEGE		((ULONG)1)
#define OPENSTORE_PUBLIC					((ULONG)2)
#define	OPENSTORE_HOME_LOGON				((ULONG)4)
#define OPENSTORE_TAKE_OWNERSHIP			((ULONG)8)
#define OPENSTORE_OVERRIDE_HOME_MDB			((ULONG)16)
#define OPENSTORE_TRANSPORT					((ULONG)32)
#define OPENSTORE_REMOTE_TRANSPORT			((ULONG)64)

// Values for PR_PROFILE_TYPE

#define	PROFILE_PRIMARY_USER				((ULONG)1)
#define	PROFILE_DELEGATE					((ULONG)2)
#define	PROFILE_PUBLIC_STORE				((ULONG)3)
#define	PROFILE_SUBSCRIPTION				((ULONG)4)


/*------------------------------------------------------------------------
 *
 *	MDB object properties
 *
 *-----------------------------------------------------------------------*/

/* PR_MDB_PROVIDER GUID in stores table */

#define pbExchangeProviderPrimaryUserGuid	"\x54\x94\xA1\xC0\x29\x7F\x10\x1B\xA5\x87\x08\x00\x2B\x2A\x25\x17"
#define pbExchangeProviderDelegateGuid		"\x9e\xb4\x77\x00\x74\xe4\x11\xce\x8c\x5e\x00\xaa\x00\x42\x54\xe2"
#define pbExchangeProviderPublicGuid		"\x78\xb2\xfa\x70\xaf\xf7\x11\xcd\x9b\xc8\x00\xaa\x00\x2f\xc4\x5a"
#define pbExchangeProviderXportGuid			"\xa9\x06\x40\xe0\xd6\x93\x11\xcd\xaf\x95\x00\xaa\x00\x4a\x35\xc3"

// All properties in this section are readonly

// Identity of store
	// All stores
#define	PR_USER_ENTRYID					PROP_TAG( PT_BINARY, pidStoreMin+0x01)
#define	PR_USER_NAME					PROP_TAG( PT_STRING8, pidStoreMin+0x02)

	// All mailbox stores
#define	PR_MAILBOX_OWNER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x03)
#define	PR_MAILBOX_OWNER_NAME			PROP_TAG( PT_STRING8, pidStoreMin+0x04)
#define PR_OOF_STATE					PROP_TAG( PT_BOOLEAN, pidStoreMin+0x05)

	// Public stores -- name of hierarchy server
#define	PR_HIERARCHY_SERVER				PROP_TAG( PT_TSTRING, pidStoreMin+0x1B)

// Entryids of special folders
	// All mailbox stores
#define	PR_SCHEDULE_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x06)

	// All mailbox and gateway stores
#define PR_IPM_DAF_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x07)

	// Public store
#define	PR_NON_IPM_SUBTREE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x08)
#define	PR_EFORMS_REGISTRY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x09)
#define	PR_SPLUS_FREE_BUSY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0A)
#define	PR_OFFLINE_ADDRBOOK_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0B)
#define	PR_EFORMS_FOR_LOCALE_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x0C)
#define	PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0D)
#define	PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0E)
#define	PR_OFFLINE_MESSAGE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0F)
#define PR_IPM_FAVORITES_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x18)
#define PR_IPM_PUBLIC_FOLDERS_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x19)

	// Gateway stores
#define	PR_GW_MTSIN_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x10)
#define	PR_GW_MTSOUT_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x11)
#define	PR_TRANSFER_ENABLED				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x12)

// This property is preinitialized to 256 bytes of zeros
// GetProp on this property is guaranteed to RPC.  May be used
// to determine line speed of connection to server.
#define	PR_TEST_LINE_SPEED				PROP_TAG( PT_BINARY, pidStoreMin+0x13)

// Used with OpenProperty to get interface, also on folders
#define	PR_HIERARCHY_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x14)
#define	PR_CONTENTS_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x15)
#define	PR_COLLECTOR					PROP_TAG( PT_OBJECT, pidStoreMin+0x16)

// Used with OpenProperty to get interface for folders, messages, attachmentson
#define	PR_FAST_TRANSFER				PROP_TAG( PT_OBJECT, pidStoreMin+0x17)

// This property is available on mailbox and public stores.  If it exists
// and its value is TRUE, the store is connected to the offline store provider.
#define PR_STORE_OFFLINE				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x1A)

// In transit state for store object.  This state is
// set when mail is being moved and it pauses mail delivery
// to the mail box
#define	PR_IN_TRANSIT					PROP_TAG( PT_BOOLEAN, pidStoreMin)

// Writable only with Admin rights, available on public stores and folders
#define PR_REPLICATION_STYLE			PROP_TAG( PT_LONG, pidAdminMin)
#define PR_REPLICATION_SCHEDULE			PROP_TAG( PT_BINARY, pidAdminMin+0x01)
#define PR_REPLICATION_MESSAGE_PRIORITY PROP_TAG( PT_LONG, pidAdminMin+0x02)

// Writable only with Admin rights, available on public stores
#define PR_OVERALL_MSG_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x03 )
#define PR_REPLICATION_ALWAYS_INTERVAL	PROP_TAG( PT_LONG, pidAdminMin+0x04 )
#define PR_REPLICATION_MSG_SIZE			PROP_TAG( PT_LONG, pidAdminMin+0x05 )

// default replication style=always interval (minutes)
#define STYLE_ALWAYS_INTERVAL_DEFAULT	(ULONG) 15

// default replication message size limit (KB)
#define REPLICATION_MESSAGE_SIZE_LIMIT_DEFAULT	(ULONG) 100

// Values for PR_REPLICATION_STYLE
#define STYLE_NEVER				(ULONG) 0	// never replicate
#define STYLE_NORMAL			(ULONG) 1	// use 84 byte schedule TIB
#define STYLE_ALWAYS			(ULONG) 2	// replicate at fastest rate
#define STYLE_DEFAULT			(ULONG) -1	// default value

/*------------------------------------------------------------------------
 *
 *	INCREMENTAL CHANGE SYNCHRONIZATION
 *	folder and message properties
 *
 *-----------------------------------------------------------------------*/

#define PR_SOURCE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x0)
#define PR_PARENT_SOURCE_KEY			PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x1)
#define PR_CHANGE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x2)
#define PR_PREDECESSOR_CHANGE_LIST		PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x3)

/*------------------------------------------------------------------------
 *
 *	FOLDER object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, available on all folders
#define	PR_FOLDER_CHILD_COUNT			PROP_TAG( PT_LONG, pidFolderMin)
#define	PR_RIGHTS						PROP_TAG( PT_LONG, pidFolderMin+0x01)
#define	PR_ACL_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin)
#define	PR_RULES_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin+0x1)
#define	PR_HAS_RULES				PROP_TAG( PT_BOOLEAN, pidFolderMin+0x02)

//Read only, available only for public folders
#define	PR_ADDRESS_BOOK_ENTRYID		PROP_TAG( PT_BINARY, pidFolderMin+0x03)

//Writable, available on folders in all stores
#define	PR_ACL_DATA					PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin)
#define	PR_RULES_DATA				PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x1)
#define	PR_FOLDER_DESIGN_FLAGS		PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x2)
#define	PR_DESIGN_IN_PROGRESS		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x4)
#define	PR_SECURE_ORIGINATION		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x5)

//Writable, available only for public folders
#define	PR_PUBLISH_IN_ADDRESS_BOOK	PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x6)
#define	PR_RESOLVE_METHOD			PROP_TAG( PT_LONG,  pidExchangeXmitReservedMin+0x7)
#define	PR_ADDRESS_BOOK_DISPLAY_NAME	PROP_TAG( PT_TSTRING, pidExchangeXmitReservedMin+0x8)

//Writable, used to indicate locale id for eforms registry subfolders
#define	PR_EFORMS_LOCALE_ID			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x9)

// Writable only with Admin rights, available only for public folders
#define PR_REPLICA_LIST				PROP_TAG( PT_BINARY, pidAdminMin+0x8)
#define PR_OVERALL_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x9)

//PR_RESOLVE_METHOD values
#define	RESOLVE_METHOD_DEFAULT			((LONG)0)	// default handling attach conflicts
#define	RESOLVE_METHOD_LAST_WRITER_WINS	((LONG)1)	// the last writer will win conflict
#define	RESOLVE_METHOD_NO_CONFLICT_NOTIFICATION ((LONG)2) // no conflict notif

//Read only, available only for public folder favorites
#define PR_PUBLIC_FOLDER_ENTRYID	PROP_TAG( PT_BINARY, pidFolderMin+0x04)

/*------------------------------------------------------------------------
 *
 *	MESSAGE object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, automatically set on all messages in all stores
#define	PR_HAS_NAMED_PROPERTIES			PROP_TAG(PT_BOOLEAN, pidMessageReadOnlyMin+0x0A)

// Read only but outside the provider specific range for replication thru GDK-GWs
#define	PR_CREATOR_NAME					PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x18)
#define	PR_CREATOR_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x19)
#define	PR_LAST_MODIFIER_NAME			PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x1A)
#define	PR_LAST_MODIFIER_ENTRYID		PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x1B)

// Read only, appears on messages which have DAM's pointing to them
#define PR_HAS_DAMS						PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0xA)
#define PR_RULE_TRIGGER_HISTORY			PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x12)
#define	PR_MOVE_TO_STORE_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x13)
#define	PR_MOVE_TO_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x14)

// Read only, available only on messages in the public store
#define	PR_REPLICA_SERVER				PROP_TAG(PT_TSTRING, pidMessageReadOnlyMin+0x4)

// Writeable, used for recording send option dialog settings
#define	PR_DEFERRED_SEND_NUMBER			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xB)
#define	PR_DEFERRED_SEND_UNITS			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xC)
#define	PR_EXPIRY_NUMBER				PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xD)
#define	PR_EXPIRY_UNITS					PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xE)

// Writeable, deferred send time
#define PR_DEFERRED_SEND_TIME			PROP_TAG( PT_SYSTIME, pidExchangeXmitReservedMin+0xF)

//Writeable, intended for both folders and messages in gateway mailbox
#define	PR_GW_ADMIN_OPERATIONS			PROP_TAG( PT_LONG, pidMessageWriteableMin)

//Writeable, used for DMS messages
#define PR_P1_CONTENT					PROP_TAG( PT_BINARY, 0x1100)
#define PR_P1_CONTENT_TYPE				PROP_TAG( PT_BINARY, 0x1101)

// Properties on deferred action messages
#define	PR_CLIENT_ACTIONS		  		PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x5)
#define	PR_DAM_ORIGINAL_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x6)
#define PR_DAM_BACK_PATCHED				PROP_TAG( PT_BOOLEAN, pidMessageReadOnlyMin+0x7)

// Properties on deferred action error messages
#define	PR_RULE_ERROR					PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x8)
#define	PR_RULE_ACTION_TYPE				PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x9)
#define	PR_RULE_ACTION_NUMBER			PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x10)
#define PR_RULE_FOLDER_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x11)

// Property on conflict notification indicating entryid of conflicting object
#define	PR_CONFLICT_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x10)

// Property on messages to indicate the language client used to create this message
#define	PR_MESSAGE_LOCALE_ID			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x11)

// Properties on Quota warning messages to indicate Storage quota and Excess used
#define	PR_STORAGE_QUOTA_LIMIT			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x15)
#define	PR_EXCESS_STORAGE_USED			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x16)
#define PR_SVR_GENERATING_QUOTA_MSG		PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x17)

// Property affixed by delegation rule and deleted on forwards
#define PR_DELEGATED_BY_RULE			PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x3)

// Message status bit used to indicate message is in conflict
#define	MSGSTATUS_IN_CONFLICT			((ULONG) 0x800)

/*------------------------------------------------------------------------
 *
 *	ATTACHMENT object properties
 *
 *-----------------------------------------------------------------------*/

// Appears on attachments to a message marked to be in conflict.  Identifies
// those attachments which are conflicting versions of the top level message
#define	PR_IN_CONFLICT					PROP_TAG(PT_BOOLEAN, pidAttachReadOnlyMin)


/*------------------------------------------------------------------------
 *
 *	TABLE object properties
 *
 *	Id Range: 0x662F-0x662F
 *
 *-----------------------------------------------------------------------*/

//This property can be used in a contents table to get PR_ENTRYID returned
//as a long term entryid instead of a short term entryid.
#define	PR_LONGTERM_ENTRYID_FROM_TABLE	PROP_TAG(PT_BINARY, pidSpecialMin)


/*------------------------------------------------------------------------
 *
 *	Gateway "MTE" ENVELOPE properties
 *
 *	Id Range:  0x66E0-0x66FF
 *
 *-----------------------------------------------------------------------*/

#define PR_ORIGINATOR_NAME				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x3)
#define PR_ORIGINATOR_ADDR				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x4)
#define PR_ORIGINATOR_ADDRTYPE			PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x5)
#define PR_ORIGINATOR_ENTRYID			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x6)
#define PR_ARRIVAL_TIME					PROP_TAG( PT_SYSTIME, pidMessageWriteableMin+0x7)
#define PR_TRACE_INFO					PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x8)
#define PR_INTERNAL_TRACE_INFO 			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x12)
#define PR_SUBJECT_TRACE_INFO			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x9)
#define PR_RECIPIENT_NUMBER				PROP_TAG( PT_LONG, pidMessageWriteableMin+0xA)
#define PR_MTS_SUBJECT_ID				PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xB)
#define PR_REPORT_DESTINATION_NAME		PROP_TAG(PT_TSTRING, pidMessageWriteableMin+0xC)
#define PR_REPORT_DESTINATION_ENTRYID	PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xD)
#define PR_CONTENT_SEARCH_KEY			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xE)
#define PR_FOREIGN_ID					PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xF)
#define PR_FOREIGN_REPORT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x10)
#define PR_FOREIGN_SUBJECT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x11)
#define PR_MTS_ID						PR_MESSAGE_SUBMISSION_ID
#define PR_MTS_REPORT_ID				PR_MESSAGE_SUBMISSION_ID


/*------------------------------------------------------------------------
 *
 *	Trace properties format
 *		PR_TRACE_INFO
 *		PR_INTERNAL_TRACE_INFO
 *
 *-----------------------------------------------------------------------*/

#define MAX_ADMD_NAME_SIZ       17
#define MAX_PRMD_NAME_SIZ       17
#define MAX_COUNTRY_NAME_SIZ    4
#define MAX_MTA_NAME_SIZ		33

#define	ADMN_PAD				3
#define	PRMD_PAD				3
#define	COUNTRY_PAD				0
#define	MTA_PAD					3

typedef struct {
    LONG     lAction;                // The routing action the tracing site
                                     // took.
    FILETIME ftArrivalTime;          // The time at which the communique
                                     // entered the tracing site.
    FILETIME ftDeferredTime;         // The time are which the tracing site
                                     // released the message.
    char     rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];           	// ADMD
    char     rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 	// Country
    char     rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];              	// PRMD
    char     rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       	// Attempted ADMD
    char     rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];  // Attempted Country
    char     rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];				// Attempted PRMD
}   TRACEENTRY, FAR * LPTRACEENTRY;

typedef struct {
    ULONG       cEntries;               // Number of trace entries
    TRACEENTRY  rgtraceentry[MAPI_DIM]; // array of trace entries
} TRACEINFO, FAR * LPTRACEINFO;

typedef struct
{
	LONG		lAction;				// The routing action the tracing domain took.
	FILETIME	ftArrivalTime;			// The time at which the communique entered the tracing domain.
	FILETIME	ftDeferredTime;			// The time are which the tracing domain released the message.

    char        rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];				// ADMD
    char        rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 		// Country
    char        rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];             	// PRMD
    char        rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       		// Attempted ADMD
    char        rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];	// Attempted Country
    char        rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];		        // Attempted PRMD
    char        rgchMTAName[MAX_MTA_NAME_SIZ+MTA_PAD]; 		            // MTA Name
    char        rgchAttMTAName[MAX_MTA_NAME_SIZ+MTA_PAD];		        // Attempted MTA Name
}INTTRACEENTRY, *PINTTRACEENTRY;

typedef	struct
{
	ULONG  			cEntries;					// Number of trace entries
	INTTRACEENTRY	rgIntTraceEntry[MAPI_DIM];	// array of internal trace entries
}INTTRACEINFO, *PINTTRACEINFO;


/*------------------------------------------------------------------------
 *
 *	"IExchangeModifyTable" Interface Declaration
 *
 *	Used for get/set rules and access control on folders.
 *
 *-----------------------------------------------------------------------*/


/* ulRowFlags */
#define ROWLIST_REPLACE		((ULONG)1)

#define ROW_ADD				((ULONG)1)
#define ROW_MODIFY			((ULONG)2)
#define ROW_REMOVE			((ULONG)4)
#define ROW_EMPTY			(ROW_ADD|ROW_REMOVE)

typedef struct _ROWENTRY
{
	ULONG			ulRowFlags;
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ROWENTRY, FAR * LPROWENTRY;

typedef struct _ROWLIST
{
	ULONG			cEntries;
	ROWENTRY		aEntries[MAPI_DIM];
} ROWLIST, FAR * LPROWLIST;

#define EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(IPURE)					\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPROWLIST					lpMods) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeModifyTable
DECLARE_MAPI_INTERFACE_(IExchangeModifyTable, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeModifyTable,	LPEXCHANGEMODIFYTABLE);

/* Access Control Specifics */

//Properties
#define	PR_MEMBER_ID					PROP_TAG( PT_I8, pidSpecialMin+0x01)
#define	PR_MEMBER_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x02)
#define	PR_MEMBER_ENTRYID				PR_ENTRYID
#define	PR_MEMBER_RIGHTS				PROP_TAG( PT_LONG, pidSpecialMin+0x03)

//Security bits
typedef DWORD RIGHTS;
#define frightsReadAny			0x0000001L
#define	frightsCreate			0x0000002L
#define	frightsEditOwned		0x0000008L
#define	frightsDeleteOwned		0x0000010L
#define	frightsEditAny			0x0000020L
#define	frightsDeleteAny		0x0000040L
#define	frightsCreateSubfolder	0x0000080L
#define	frightsOwner			0x0000100L
#define	frightsContact			0x0000200L	// NOTE: not part of rightsAll
#define	rightsNone				0x00000000
#define	rightsReadOnly			frightsReadAny
#define	rightsReadWrite			(frightsReadAny|frightsEditAny)
#define	rightsAll				0x00001FBL

/* Rules specifics */

//Property types
#define	PT_SRESTRICTION				((ULONG) 0x00FD)
#define	PT_ACTIONS					((ULONG) 0x00FE)

//Properties in rule table
#define	PR_RULE_ID						PROP_TAG( PT_I8, pidSpecialMin+0x04)
#define	PR_RULE_IDS						PROP_TAG( PT_BINARY, pidSpecialMin+0x05)
#define	PR_RULE_SEQUENCE				PROP_TAG( PT_LONG, pidSpecialMin+0x06)
#define	PR_RULE_STATE					PROP_TAG( PT_LONG, pidSpecialMin+0x07)
#define	PR_RULE_USER_FLAGS				PROP_TAG( PT_LONG, pidSpecialMin+0x08)
#define	PR_RULE_CONDITION				PROP_TAG( PT_SRESTRICTION, pidSpecialMin+0x09)
#define	PR_RULE_ACTIONS					PROP_TAG( PT_ACTIONS, pidSpecialMin+0x10)
#define	PR_RULE_PROVIDER				PROP_TAG( PT_STRING8, pidSpecialMin+0x11)
#define	PR_RULE_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x12)
#define	PR_RULE_LEVEL					PROP_TAG( PT_LONG, pidSpecialMin+0x13)
#define	PR_RULE_PROVIDER_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x14)

//PR_STATE property values
#define ST_DISABLED			0x0000
#define ST_ENABLED			0x0001
#define ST_ERROR			0x0002
#define ST_ONLY_WHEN_OOF	0x0004
#define ST_KEEP_OOF_HIST	0x0008
#define ST_EXIT_LEVEL		0x0010

#define ST_CLEAR_OOF_HIST	0x80000000

//Empty restriction
#define NULL_RESTRICTION	0xff

// special RELOP for Member of DL
#define RELOP_MEMBER_OF_DL	100

//Action types
typedef enum
{
	OP_MOVE = 1,
	OP_COPY,
	OP_REPLY,
	OP_OOF_REPLY,
	OP_DEFER_ACTION,
	OP_BOUNCE,
	OP_FORWARD,
	OP_DELEGATE,
	OP_TAG,
	OP_DELETE,
	OP_MARK_AS_READ
} ACTTYPE;

// action flavors

// for OP_REPLY
#define	DO_NOT_SEND_TO_ORIGINATOR		1

//scBounceCode values
#define	BOUNCE_MESSAGE_SIZE_TOO_LARGE	(SCODE) MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD
#define BOUNCE_FORMS_MISMATCH			(SCODE) MAPI_DIAG_RENDITION_UNSUPPORTED
#define BOUNCE_ACCESS_DENIED			(SCODE) MAPI_DIAG_MAIL_REFUSED

//Message class prefix for Reply and OOF Reply templates
#define szReplyTemplateMsgClassPrefix	"IPM.Note.Rules.ReplyTemplate."
#define szOofTemplateMsgClassPrefix		"IPM.Note.Rules.OofTemplate."

//Action structure
typedef struct _action
{
	ACTTYPE		acttype;

	// to indicate which flavour of the action.
	ULONG		ulActionFlavor;

	// Action restriction
	// currently unsed and must be set to NULL
	LPSRestriction	lpRes;

	// currently unused, must be set to 0.
	LPSPropTagArray	lpPropTagArray;

	// User defined flags
	ULONG		ulFlags;

	// padding to align the union on 8 byte boundary
	ULONG		dwAlignPad;

	union
	{
		// used for OP_MOVE and OP_COPY actions
		struct
		{
			ULONG		cbStoreEntryId;
			LPENTRYID	lpStoreEntryId;
			ULONG		cbFldEntryId;
			LPENTRYID	lpFldEntryId;
		} actMoveCopy;

		// used for OP_REPLY and OP_OOF_REPLY actions
		struct
		{
			ULONG		cbEntryId;
			LPENTRYID	lpEntryId;
			GUID		guidReplyTemplate;
		} actReply;

		// used for OP_DEFER_ACTION action
		struct
		{
			ULONG		cbData;
			BYTE		*pbData;
		} actDeferAction;

		// Error code to set for OP_BOUNCE action
		SCODE			scBounceCode;

		// list of address for OP_FORWARD and OP_DELEGATE action
		LPADRLIST		lpadrlist;

		// prop value for OP_TAG action
		SPropValue		propTag;
	};
} ACTION, FAR * LPACTION;

// Rules version
#define EDK_RULES_VERSION		1

//Array of actions
typedef struct _actions
{
	ULONG		ulVersion;		// use the #define above
	UINT		cActions;
	LPACTION	lpAction;
} ACTIONS;

// message class definitions for Deferred Action and Deffered Error messages
#define szDamMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Action"
#define szDemMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Error"

/*
 *	Rule error codes
 *	Values for PR_RULE_ERROR
 */
#define	RULE_ERR_UNKNOWN		1			//general catchall error
#define	RULE_ERR_LOAD			2			//unable to load folder rules
#define	RULE_ERR_DELIVERY		3			//unable to deliver message temporarily
#define	RULE_ERR_PARSING		4			//error while parsing
#define	RULE_ERR_CREATE_DAE		5			//error creating DAE message
#define	RULE_ERR_NO_FOLDER		6			//folder to move/copy doesn't exist
#define	RULE_ERR_NO_RIGHTS		7			//no rights to move/copy into folder
#define	RULE_ERR_CREATE_DAM		8			//error creating DAM
#define RULE_ERR_NO_SENDAS		9			//can not send as another user
#define RULE_ERR_NO_TEMPLATE	10			//reply template is missing
#define RULE_ERR_EXECUTION		11			//error in rule execution
#define RULE_ERR_QUOTA_EXCEEDED	12

#define RULE_ERR_FIRST		RULE_ERR_UNKNOWN
#define RULE_ERR_LAST		RULE_ERR_QUOTA_EXCEEDED

/*------------------------------------------------------------------------
 *
 *	"IExchangeRuleAction" Interface Declaration
 *
 *	Used for get actions from a Deferred Action Message.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGERULEACTION_METHODS(IPURE)						\
	MAPIMETHOD(ActionCount)												\
		(THIS_	ULONG FAR *					lpcActions) IPURE;			\
	MAPIMETHOD(GetAction)												\
		(THIS_	ULONG						ulActionNumber,				\
				LARGE_INTEGER	*			lpruleid,					\
				LPACTION FAR *				lppAction) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeRuleAction
DECLARE_MAPI_INTERFACE_(IExchangeRuleAction, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGERULEACTION_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeRuleAction,	LPEXCHANGERULEACTION);

/*------------------------------------------------------------------------
 *
 *	"IExchangeManageStore" Interface Declaration
 *
 *	Used for store management functions.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(IPURE)					\
	MAPIMETHOD(CreateStoreEntryID)										\
		(THIS_	LPSTR						lpszMsgStoreDN,				\
				LPSTR						lpszMailboxDN,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(EntryIDFromSourceKey)									\
		(THIS_	ULONG						cFolderKeySize,				\
				BYTE FAR *					lpFolderSourceKey,			\
				ULONG						cMessageKeySize,			\
				BYTE FAR *					lpMessageSourceKey,			\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(GetRights)												\
		(THIS_	ULONG						cbUserEntryID,				\
				LPENTRYID					lpUserEntryID,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG FAR *					lpulRights) IPURE;			\
	MAPIMETHOD(GetMailboxTable)											\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetPublicFolderTable)									\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeManageStore
DECLARE_MAPI_INTERFACE_(IExchangeManageStore, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeManageStore, LPEXCHANGEMANAGESTORE);


// Properties for GetMailboxTable
#define PR_NT_USER_NAME                         PROP_TAG( PT_TSTRING, pidAdminMin+0x10)
#define PR_LOCALE_ID                            PROP_TAG( PT_LONG, pidAdminMin+0x11 )
#define PR_LAST_LOGON_TIME                      PROP_TAG( PT_SYSTIME, pidAdminMin+0x12 )
#define PR_LAST_LOGOFF_TIME                     PROP_TAG( PT_SYSTIME, pidAdminMin+0x13 )
#define PR_STORAGE_LIMIT_INFORMATION			PROP_TAG( PT_LONG, pidAdminMin+0x14 )

// Properties for GetPublicFolderTable
#define PR_FOLDER_FLAGS                         PROP_TAG( PT_LONG, pidAdminMin+0x18 )
#define	PR_LAST_ACCESS_TIME						PROP_TAG( PT_SYSTIME, pidAdminMin+0x19 )
#define PR_RESTRICTION_COUNT                    PROP_TAG( PT_LONG, pidAdminMin+0x1A )
#define PR_CATEG_COUNT                          PROP_TAG( PT_LONG, pidAdminMin+0x1B )
#define PR_CACHED_COLUMN_COUNT                  PROP_TAG( PT_LONG, pidAdminMin+0x1C )
#define PR_NORMAL_MSG_W_ATTACH_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x1D )
#define PR_ASSOC_MSG_W_ATTACH_COUNT             PROP_TAG( PT_LONG, pidAdminMin+0x1E )
#define PR_RECIPIENT_ON_NORMAL_MSG_COUNT        PROP_TAG( PT_LONG, pidAdminMin+0x1F )
#define PR_RECIPIENT_ON_ASSOC_MSG_COUNT 		PROP_TAG( PT_LONG, pidAdminMin+0x20 )
#define PR_ATTACH_ON_NORMAL_MSG_COUNT   		PROP_TAG( PT_LONG, pidAdminMin+0x21 )
#define PR_ATTACH_ON_ASSOC_MSG_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x22 )
#define PR_NORMAL_MESSAGE_SIZE                  PROP_TAG( PT_LONG, pidAdminMin+0x23 )
#define PR_NORMAL_MESSAGE_SIZE_EXTENDED         PROP_TAG( PT_I8, pidAdminMin+0x23 )
#define PR_ASSOC_MESSAGE_SIZE                   PROP_TAG( PT_LONG, pidAdminMin+0x24 )
#define PR_ASSOC_MESSAGE_SIZE_EXTENDED          PROP_TAG( PT_I8, pidAdminMin+0x24 )
#define PR_FOLDER_PATHNAME                      PROP_TAG(PT_TSTRING, pidAdminMin+0x25 )
#define PR_OWNER_COUNT							PROP_TAG( PT_LONG, pidAdminMin+0x26 )
#define PR_CONTACT_COUNT						PROP_TAG( PT_LONG, pidAdminMin+0x27 )

// PT_I8 version of PR_MESSAGE_SIZE defined in mapitags.h
#define	PR_MESSAGE_SIZE_EXTENDED			PROP_TAG(PT_I8, PROP_ID(PR_MESSAGE_SIZE))

/* Bits in PR_FOLDER_FLAGS */
#define MDB_FOLDER_IPM                  0x1
#define MDB_FOLDER_SEARCH               0x2
#define MDB_FOLDER_NORMAL               0x4
#define MDB_FOLDER_RULES                0x8

/* Bits used in ulFlags in GetPublicFolderTable() */
#define MDB_NON_IPM                     0x10
#define MDB_IPM                         0x20

/* Bits in PR_STORAGE_LIMIT_INFORMATION */
#define MDB_LIMIT_BELOW					0x1
#define MDB_LIMIT_ISSUE_WARNING			0x2
#define MDB_LIMIT_PROHIBIT_SEND			0x4
#define MDB_LIMIT_NO_CHECK				0x8


/*------------------------------------------------------------------------
 *
 *	"IExchangeFastTransfer" Interface Declaration
 *
 *	Used for fast transfer interface used to
 *	implement CopyTo, CopyProps, CopyFolder, and
 *	CopyMessages.
 *
 *-----------------------------------------------------------------------*/

// Transfer flags
// Use MAPI_MOVE for move option

// Transfer methods
#define	TRANSFER_COPYTO			1
#define	TRANSFER_COPYPROPS		2
#define	TRANSFER_COPYMESSAGES	3
#define	TRANSFER_COPYFOLDER		4


#define EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(IPURE)			\
	MAPIMETHOD(Config)											\
		(THIS_	ULONG				ulFlags,					\
				ULONG				ulTransferMethod) IPURE;	\
	MAPIMETHOD(TransferBuffer)									\
		(THIS_	ULONG				cb,							\
				LPBYTE				lpb,						\
				ULONG				*lpcbProcessed) IPURE;		\
	STDMETHOD_(BOOL, IsInterfaceOk)								\
		(THIS_	ULONG				ulTransferMethod,			\
				REFIID				refiid,						\
				LPSPropTagArray		lpptagList,					\
				ULONG				ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFastTransfer
DECLARE_MAPI_INTERFACE_(IExchangeFastTransfer, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeFastTransfer, LPEXCHANGEFASTTRANSFER);



/*------------------------------------------------------------------------
 *
 *	"IExchangeExportChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)								\
		(THIS_	HRESULT				hResult,				\
		 	    ULONG				ulFlags,				\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;	\
	MAPIMETHOD(Config)										\
		(THIS_	LPSTREAM			lpStream,				\
				ULONG				ulFlags,				\
				LPUNKNOWN			lpUnk,					\
		 		LPSRestriction		lpRestriction,			\
		 	    LPSPropTagArray		lpIncludeProps,			\
		 	    LPSPropTagArray		lpExcludeProps,			\
		 		ULONG				ulBufferSize) IPURE;	\
	MAPIMETHOD(Synchronize)									\
		(THIS_	ULONG FAR *			lpulSteps,				\
				ULONG FAR *			lpulProgress) IPURE;	\
	MAPIMETHOD(UpdateState)									\
		(THIS_	LPSTREAM			lpStream) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeExportChanges
DECLARE_MAPI_INTERFACE_(IExchangeExportChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeExportChanges, LPEXCHANGEEXPORTCHANGES);


typedef struct _ReadState
{
	ULONG		cbSourceKey;
	BYTE	*	pbSourceKey;
	ULONG		ulFlags;
} READSTATE, *LPREADSTATE;

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportContentsChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder contents (i.e. messages)
 *
 *-----------------------------------------------------------------------*/


#define EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
		 	    ULONG				ulFlags,						\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportMessageChange)									\
		(THIS_	ULONG					cpvalChanges,				\
				LPSPropValue			ppvalChanges,				\
				ULONG					ulFlags,					\
				LPMESSAGE				*lppmessage) IPURE;			\
	MAPIMETHOD(ImportMessageDeletion)								\
		(THIS_	ULONG					ulFlags,					\
		 		LPENTRYLIST				lpSrcEntryList) IPURE;		\
	MAPIMETHOD(ImportPerUserReadStateChange)						\
		(THIS_	ULONG					cElements,					\
		 		LPREADSTATE			 	lpReadState) IPURE;			\
	MAPIMETHOD(ImportMessageMove)									\
		(THIS_	ULONG					cbSourceKeySrcFolder,		\
		 		BYTE FAR *				pbSourceKeySrcFolder,		\
		 		ULONG					cbSourceKeySrcMessage,		\
		 		BYTE FAR *				pbSourceKeySrcMessage,		\
		 		ULONG					cbPCLMessage,				\
		 		BYTE FAR *				pbPCLMessage,				\
		 		ULONG					cbSourceKeyDestMessage,		\
		 		BYTE FAR *				pbSourceKeyDestMessage,		\
		 		ULONG					cbChangeNumDestMessage,		\
		 		BYTE FAR *				pbChangeNumDestMessage) IPURE;


#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportContentsChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportContentsChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportContentsChanges,
						   LPEXCHANGEIMPORTCONTENTSCHANGES);

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportHierarchyChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder hierarchy
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
				ULONG 				ulFlags,						\
				LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportFolderChange)									\
		(THIS_	ULONG						cpvalChanges,			\
				LPSPropValue				ppvalChanges) IPURE;	\
	MAPIMETHOD(ImportFolderDeletion)								\
		(THIS_	ULONG						ulFlags,				\
		 		LPENTRYLIST					lpSrcEntryList) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportHierarchyChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportHierarchyChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportHierarchyChanges,
						   LPEXCHANGEIMPORTHIERARCHYCHANGES);

/*------------------------------------------------------------------------
 *
 *	Errors returned by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define MAKE_SYNC_E(err)	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, err))
#define MAKE_SYNC_W(warn)	(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, warn))

#define SYNC_E_UNKNOWN_FLAGS			MAPI_E_UNKNOWN_FLAGS
#define SYNC_E_INVALID_PARAMETER		E_INVALIDARG
#define SYNC_E_ERROR					E_FAIL
#define SYNC_E_OBJECT_DELETED			MAKE_SYNC_E(0x800)
#define SYNC_E_IGNORE					MAKE_SYNC_E(0x801)
#define SYNC_E_CONFLICT					MAKE_SYNC_E(0x802)
#define SYNC_E_NO_PARENT				MAKE_SYNC_E(0x803)
#define SYNC_E_INCEST					MAKE_SYNC_E(0x804)
#define SYNC_E_UNSYNCHRONIZED			MAKE_SYNC_E(0x805)

#define SYNC_W_PROGRESS					MAKE_SYNC_W(0x820)
#define SYNC_W_CLIENT_CHANGE_NEWER		MAKE_SYNC_W(0x821)

/*------------------------------------------------------------------------
 *
 *	Flags used by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define	SYNC_UNICODE				0x01
#define SYNC_NO_DELETIONS			0x02
#define SYNC_NO_SOFT_DELETIONS		0x04
#define	SYNC_READ_STATE				0x08
#define SYNC_ASSOCIATED				0x10
#define SYNC_NORMAL					0x20
#define	SYNC_NO_CONFLICTS			0x40
#define SYNC_ONLY_SPECIFIED_PROPS	0x80
#define SYNC_NO_FOREIGN_KEYS		0x100
#define SYNC_LIMITED_IMESSAGE		0x200


/*------------------------------------------------------------------------
 *
 *	Flags used by ImportMessageDeletion and ImportFolderDeletion methods
 *
 *-----------------------------------------------------------------------*/

#define SYNC_SOFT_DELETE			0x01
#define SYNC_EXPIRY					0x02

/*------------------------------------------------------------------------
 *
 *	Flags used by ImportPerUserReadStateChange method
 *
 *-----------------------------------------------------------------------*/

#define SYNC_READ					0x01

/*------------------------------------------------------------------------
 *
 *	"IExchangeFavorites" Interface Declaration
 *
 *	Used for adding or removing favorite folders from the public store.
 *	This interface is obtained by calling QueryInterface on the folder
 *	whose EntryID is specified by PR_IPM_FAVORITES_ENTRYID on the public
 *	store.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEFAVORITES_METHODS(IPURE)						\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(AddFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\
	MAPIMETHOD(DelFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFavorites
DECLARE_MAPI_INTERFACE_(IExchangeFavorites, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFAVORITES_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IExchangeFavorites,	LPEXCHANGEFAVORITES);


/*------------------------------------------------------------------------
 *
 *	Properties used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/
											  
#define PR_OFFLINE_FLAGS				PROP_TAG( PT_LONG, pidFolderMin + 0x5)
#define PR_SYNCHRONIZE_FLAGS			PROP_TAG( PT_LONG, pidExchangeNonXmitReservedMin + 0x4)
							

/*------------------------------------------------------------------------
 *
 *	Flags used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/

#define OF_AVAILABLE_OFFLINE					((ULONG) 0x00000001)
#define OF_FORCE								((ULONG) 0x80000000)

#define SF_DISABLE_STARTUP_SYNC					((ULONG) 0x00000001)


#endif	//EDKMDB_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\faxui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.c

Abstract:

    Common routines for fax driver user interface

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include <shlobj.h>
#ifdef UNICODE
    #include <shfusion.h>
#endif // UNICODE


HANDLE              ghInstance;         // DLL instance handle
INT                 _debugLevel = 1;    // for debuggping purposes


BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
#ifdef UNICODE
    static      BOOL bSHFusionInitialized = FALSE;
#endif // UNICODE
    TCHAR       DllName[MAX_PATH];
    INITCOMMONCONTROLSEX CommonControlsEx = {sizeof(INITCOMMONCONTROLSEX),
                                             ICC_WIN95_CLASSES|ICC_DATE_CLASSES };

    switch (ulReason) {

    case DLL_PROCESS_ATTACH:
        //
        // Keep our driver UI dll always loaded in memory
        //

        if (! GetModuleFileName(hModule, DllName, MAX_PATH) ||
            ! LoadLibrary(DllName))
        {
            return FALSE;
        }
        ghInstance = hModule;
        
#ifdef UNICODE
        if (!SHFusionInitializeFromModuleID(hModule, SXS_MANIFEST_RESOURCE_ID))
        {
            Verbose(("SHFusionInitializeFromModuleID failed"));
        }
        else
        {
            bSHFusionInitialized = TRUE;
        }
#endif // UNICODE

	    if (!InitCommonControlsEx(&CommonControlsEx))
		{
			Verbose(("InitCommonControlsEx failed"));
		}
        break;

    case DLL_PROCESS_DETACH:
#ifdef UNICODE
        if (bSHFusionInitialized)
        {
            SHFusionUninitialize();
            bSHFusionInitialized = FALSE;
        }
#endif // UNICODE
        break;
    }
    return TRUE;
}


INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    NONE

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_DLGTITLE;

        if(!LoadString(ghInstance, titleStrId, pTitle, MAX_TITLE_LEN))
        {
            Assert(FALSE);
        }

        //
        // Load message format string resource
        //

        if(!LoadString(ghInstance, formatStrId, pFormat, MAX_STRING_LEN))
        {
            Assert(FALSE);
        }

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = AlignedMessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\faxui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.h

Abstract:

    Print Wizard user interface header file

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXUI_H_
#define _FAXUI_H_

#include <windows.h>
#include <fxsapip.h>

#include "faxlib.h"

#include <winddiui.h>
#include <commctrl.h>
#include <windowsx.h>
#include <prsht.h>

#ifdef FAX_SCAN_ENABLED
#include <twain.h>
#endif

#include "registry.h"
#include "timectrl.h"
#include "coverpg.h"
#include "resource.h"
#include "faxsendw.h"


//
// Display an error message dialog
//

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     formatStrId,
    INT     titleStrId,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_FORMAT_LEN      128
#define MAX_MESSAGE_LEN     512

//
// Information about each recipient
//

typedef struct RECIPIENT_TAG 
{
    struct RECIPIENT_TAG*  pNext;   // Points to next recipient

    LPTSTR      pName;              // Recipient name
    LPTSTR      pAddress;           // Recipient address
    LPTSTR      pCountry;           // Recipient country
    DWORD       dwCountryId;        // Recipient country ID
    BOOL        bUseDialingRules;   // Don't dial the number as entered - use dialing rules (TAPI / Outbound routing) instead
    DWORD       dwDialingRuleId;    // If bUseDialingRules==TRUE, holds the dialing rule to use (see lineSetCurrentLocation)
    LPVOID      lpEntryId;          // Recipient MAPI/WAB EntryId after resolution
    DWORD       cbEntryId;          // Size of EntryId
    BOOL        bFromAddressBook;   // TRUE if the recipient is from address book
} RECIPIENT, *PRECIPIENT;


// Data structures used by the user mode DLL to associate private
// information with a printer device context (PDEV to be exactly)
//


typedef struct {

    BOOL            finishPressed;          // User pressed Finish in fax wizard pages
    PVOID           pCPInfo;                // For managing cover pages
    LPVOID          lpWabInit;              // pointer to wab object
    LPVOID          lpMAPIabInit;           // pointer to MPAI ab object
    DWORD           noteSubjectFlag;        // Whether note/subject fields are present on cover page
    SHORT           cpPaperSize;            // Cover page paper size
    SHORT           cpOrientation;          // Cover page orientation
#ifdef FAX_SCAN_ENABLED
    HWND            hDlgScan;               // scanning wizard page
    HMODULE         hTwain;                 // module handle for twain dll
    DSMENTRYPROC    pDsmEntry;              // pointer to the twain data source manager proc
    TW_IDENTITY     AppId;                  // application id/handle for twain
    TW_IDENTITY     DataSource;             // application id/handle for twain
    HWND            hWndTwain;              // window handle for twain
    HANDLE          hEvent;                 //
    HANDLE          hEventQuit;             //
    HANDLE          hEventXfer;             //
    HANDLE          hThread;                //
    BOOL            TwainCancelled;         // TRUE if twain UI was canceled
    HANDLE          hTwainEvent;            // signals twain detection complete
    BOOL            TwainAvail;             //
    BOOL            TwainActive;            //
    DWORD           State;                  //
#endif

    BOOL            ServerCPOnly;           //
    HANDLE          hCPEvent;               // signals fax service query for cp complete
    HANDLE          hCountryListEvent;      // signals country list enumeration complete
    HANDLE          hTAPIEvent;             // signals TAPI init complete
    TCHAR           FileName[MAX_PATH];     //
    DWORD           PageCount;              //
    HFONT           hLargeFont;             // large bold font for wizard 97

    PVOID           signature;              // Signature

    BOOL            isLocalPrinter;         // whether the printer is local
    BOOL            bSendCoverPage;

    PRECIPIENT      pRecipients;            // List of recipients
    UINT            nRecipientCount;        // Number of recipients

    DWORD           dwFlags;
    DWORD           dwRights;               // Access rights
    DWORD           dwQueueStates;          // Queue state

    DWORD           dwSupportedReceipts;            // Receipts supported by server

    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList;

    LPTSTR          lptstrServerName;
    LPTSTR          lptstrPrinterName;

    LPFAX_SEND_WIZARD_DATA  lpInitialData;
    LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData;

    WNDPROC wpOrigStaticControlProc; // Pointer to the original static control window procedure
                                     // we subclass to support cover page preview.

    DWORD dwComCtrlVer; // The version of COMCTRL32.DLL
    HFONT hTitleFont;
    TCHAR szTempPreviewTiff[MAX_PATH]; // The name of the temp preview tiff we pass to the viewer
    HANDLE hFaxPreviewProcess; // The process handle of the tiff viewer
} WIZARDUSERMEM, *PWIZARDUSERMEM;


#define ValidPDEVWizardUserMem(p) \
        ((p) && (p) == (p)->signature)

//
// Mark the user mode memory structure
//

#define MarkPDEVWizardUserMem(p)  \
        { (p)->signature = (p); }

//
// Free up the list of recipients associated with each fax job
//

VOID
FreeRecipientList(
    PWIZARDUSERMEM    pStrUserMem
    );

#define FreeRecipient(pRecipient) { \
            MemFree(pRecipient->pName); \
            MemFree(pRecipient->pAddress); \
            MemFree(pRecipient->pCountry); \
            if (!pRecipient->bFromAddressBook && pRecipient->lpEntryId)\
                FreeEntryID(pWizardUserMem,pRecipient->lpEntryId); \
            MemFree(pRecipient); \
        }

//
// Global variable declarations
//

extern HANDLE   ghInstance;
extern BOOL     oleInitialized;


DWORD
AsyncWizardThread(
    PBYTE param
    );

BOOL
InitializeTwain(
    PWIZARDUSERMEM pWizardUserMem
    );


HRESULT WINAPI
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    );

HRESULT WINAPI
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    );

HRESULT WINAPI
FaxFreeSendWizardData(
        LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
    );

HRESULT WINAPI
FaxSendWizardUI(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   );




#define MyHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#endif // !_FAXUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\mapiabutil.h ===
#ifndef _MAPIABUTIL_H_
#define _MAPIABUTIL_H_

LPVOID 
InitializeMAPIAB(
    HINSTANCE hInstance,
	HWND	  hDlg
    );

VOID 
UnInitializeMAPIAB( 
    LPVOID 
    );

BOOL
CallMAPIabAddress(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PRECIPIENT *    ppNewRecipient
    );

LPTSTR
CallMAPIabAddressEmail(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem
    );

BOOL
FreeMapiEntryID(
    PWIZARDUSERMEM  pWizardUserMem,
    LPVOID			lpEntryId
    );

BOOL
FreeWabEntryID(
    PWIZARDUSERMEM  pWizardUserMem,
    LPVOID			lpEntryId
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\mapiabobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mapiabobj.h

Abstract:

    Class definition for CWabObj

Environment:

        Fax send wizard

Revision History:

        10/23/97 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/
#ifndef	__MAPIABOBJ_H_
#define	__MAPIABOBJ_H_


#include "abobj.h"

#define	MAX_PROFILE_NAME	(64)

extern "C"
{
typedef HRESULT(STDAPICALLTYPE * LPHrQueryAllRows) (LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);

}
class CMAPIabObj : public CCommonAbObj{
private:    
	static HINSTANCE 			m_hInstMapi;

	static LPMAPISESSION        m_lpMapiSession;
	static LPMAPILOGONEX		m_lpfnMAPILogonEx;
	static LPMAPILOGOFF         m_lpfnMAPILogoff;
	static LPMAPIADDRESS        m_lpfnMAPIAddress;
	static LPMAPIFREEBUFFER     m_lpfnMAPIFreeBuffer;
	static LPMAPIINITIALIZE     m_lpfnMAPIInitialize;
	static LPMAPIUNINITIALIZE	m_lpfnMAPIUninitialize;
	static LPMAPIALLOCATEBUFFER	m_lpfnMAPIAllocateBuffer;
	static LPMAPIALLOCATEMORE	m_lpfnMAPIAllocateMore;
	static LPMAPIADMINPROFILES	m_lpfnMAPIAdminProfiles;
	static LPHrQueryAllRows		m_lpfnHrQueryAllRows;

	static BOOL					m_Initialized;

	IMsgStore * m_lpIMsgStore;			// Used to keep a referent to the exchange store
										// to work around a bug in office 2000. The bug causes
										// store to be released by the address book when in offline mode.


	// overloaded virual functions
    LPSTR       DupStringUnicodeToAnsi(
                        LPVOID  lpObject,
                        LPWSTR  pUnicodeStr
                        );

	LPSTR		DuplicateAnsiString(
                        LPVOID  lpObject,
						LPCSTR  pSrcStr
						);

	LPENTRYID	DuplicateEntryId(
						ULONG cbSize,           
                        LPVOID		lpObject,
						LPENTRYID	lpEntryId
						) ;

	HRESULT		ABAllocateBuffer(
						ULONG cbSize,           
						LPVOID FAR * lppBuffer  
						) ;

	// internal implementation
	BOOL	DoMapiLogon(HWND hDlg);
	BOOL	InitMapiService(HWND hDlg);
	VOID	DeinitMapiService(VOID);
	BOOL	GetDefaultMapiProfile(LPSTR);
	VOID	FreeProws(LPSRowSet prows);
	BOOL    OpenExchangeStore();

public:

    CMAPIabObj(HINSTANCE hInstance,HWND	hDlg);
    ~CMAPIabObj();
    
	BOOL isInitialized() const	{	return m_Initialized;	}

	ULONG	ABFreeBuffer(LPVOID lpBuffer) ;

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\mapiabobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cmapiabobj.cpp

Abstract:

    Interface to the MAPI address book.

Environment:

        Fax send wizard

Revision History:


--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>

#include <mapiwin.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapi.h>

#include "faxui.h"
#include "mapiabobj.h"
#include <mapitags.h>
#include "edkmdb.h"


// initialize static variables
HINSTANCE				CMAPIabObj::m_hInstMapi				 = NULL;
LPMAPISESSION			CMAPIabObj::m_lpMapiSession			 = NULL;
LPMAPILOGONEX			CMAPIabObj::m_lpfnMAPILogonEx		 = NULL;
LPMAPILOGOFF			CMAPIabObj::m_lpfnMAPILogoff		 = NULL;
LPMAPIADDRESS			CMAPIabObj::m_lpfnMAPIAddress		 = NULL;
LPMAPIFREEBUFFER		CMAPIabObj::m_lpfnMAPIFreeBuffer	 = NULL;
LPMAPIINITIALIZE		CMAPIabObj::m_lpfnMAPIInitialize	 = NULL;
LPMAPIUNINITIALIZE		CMAPIabObj::m_lpfnMAPIUninitialize   = NULL;
LPMAPIALLOCATEBUFFER	CMAPIabObj::m_lpfnMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE		CMAPIabObj::m_lpfnMAPIAllocateMore   = NULL;
LPMAPIADMINPROFILES		CMAPIabObj::m_lpfnMAPIAdminProfiles  = NULL;
LPHrQueryAllRows		CMAPIabObj::m_lpfnHrQueryAllRows	 = NULL;

BOOL					CMAPIabObj::m_Initialized			 = FALSE;


CMAPIabObj::CMAPIabObj(
    HINSTANCE	hInstance,
	HWND		hDlg
    ) : CCommonAbObj(hInstance)
/*++

Routine Description:

    Constructor for CMAPIabObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
	m_Initialized = InitMapiService(hDlg);
}



VOID
CMAPIabObj::FreeProws(
    LPSRowSet prows
    )

/*++

Routine Description:

    Destroy SRowSet structure.  Copied from MAPI.

Arguments:

    hFile      - Pointer to SRowSet

Return value:

    NONE

--*/

{
    ULONG irow;

    if (!prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        m_lpfnMAPIFreeBuffer(prows->aRow[irow].lpProps);
    }

    m_lpfnMAPIFreeBuffer( prows );
}

BOOL
CMAPIabObj::GetDefaultMapiProfile(
    LPSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    DWORD j;

    if (m_lpfnMAPIAdminProfiles( 0, &lpProfAdmin )) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
                //
                // this is the default profile
	            //
				strncpy(ProfileName,pval[0].Value.lpszA,MAX_PROFILE_NAME);
                rVal = TRUE;
                break;
            }
        }
    }

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

	if (lpProfAdmin)
		lpProfAdmin->Release();

    return rVal;
}


BOOL
CMAPIabObj::DoMapiLogon(
    HWND        hDlg
    )

/*++

Routine Description:

    Logon MAPI to in order to access address book

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    CHAR    strProfileName[MAX_PROFILE_NAME];
    HRESULT status;


	status = m_lpfnMAPIInitialize(NULL);

	if (status != SUCCESS_SUCCESS)
		return FALSE;


	if (!GetDefaultMapiProfile(strProfileName)) 
    {
		m_lpfnMAPIUninitialize();
		return FALSE;
	}

    status = m_lpfnMAPILogonEx((ULONG_PTR) hDlg,
                           (LPTSTR)strProfileName,
                           NULL,
                           MAPI_USE_DEFAULT,
						   &m_lpMapiSession);
    if (status != SUCCESS_SUCCESS || !m_lpMapiSession ) 
	{
		m_lpfnMAPIUninitialize();
		return FALSE;
	}

	OpenExchangeStore(); // If it fails it might just indicate that exchagne is not here. 
						 // We don't fail the function in this case.

	status = m_lpMapiSession->OpenAddressBook((ULONG_PTR) hDlg,
										NULL,
										0,
										&m_lpAdrBook);
    if (HR_FAILED(status) || !m_lpAdrBook) 
    {
        if (m_lpMapiSession) 
        {
			m_lpMapiSession->Logoff(0,0,0);
            m_lpMapiSession->Release();
			m_lpIMsgStore->Release();
		}
		m_lpIMsgStore=NULL;
        m_lpMapiSession = NULL;
		m_lpfnMAPIUninitialize();
        return FALSE;
    }

	return TRUE;
}





BOOL CMAPIabObj::OpenExchangeStore()
{
	/*++

Routine Description:

    Open the Exchange message store and place a pointer to the IMsgStore interface 
	in CMAPIabObj::m_lpIMsgStore.
	This is done to keep the store loaded as long as we have the address book opened.
	This resolves an exchange issue where sometimes the address book is released
	alrhough we still have reference count on its interfaces.

Arguments:

    None

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

	ULONG ulRow=0;
	HRESULT hr = S_OK;
	LPMAPITABLE lpStoreTable = NULL;
	LPSRowSet lprowsStores = NULL;
	SizedSPropTagArray(3, propStoreProperties)=
	{
		3,
		{PR_DISPLAY_NAME_A, PR_ENTRYID, PR_MDB_PROVIDER}

	};

	
	hr = m_lpMapiSession->GetMsgStoresTable(
						0, // NO UNICODE
						&lpStoreTable);


	if (FAILED(hr))
	{
		Error(("IMAPISession::GetMsgStoresTable failed. hr = 0x%08X", hr));
		goto Exit;
	}

	//
	// Now we have a pointer to the message store table. Lets find the exchange store.
	//

	Assert(NULL!=lpStoreTable);
	hr = m_lpfnHrQueryAllRows
		(
			lpStoreTable,		  // pointer to the table being queried
			(LPSPropTagArray)&propStoreProperties, // properties to return in each row
			NULL,				  // no restrictions get the entire table
			NULL,				  // use default sort order
			0,					  // No limit on the number of rows retrieved
			&lprowsStores
		);

	if (FAILED(hr))
	{
		 Error(("HrQueryAllRows on the stores table failed. hr = 0x%08X", hr));
		goto Exit;
	}



	//
	// Go over the rows and look for the one with PR_MDB_PROVIDER = pbExchangeProviderPrimaryUserGuid
	//

	for (ulRow=0;ulRow<lprowsStores->cRows;ulRow++)
	{

		if ( (sizeof(pbExchangeProviderPrimaryUserGuid)-1 == lprowsStores->aRow[ulRow].lpProps[2].Value.bin.cb))
		{
			
			 if (!memcmp(lprowsStores->aRow[ulRow].lpProps[2].Value.bin.lpb, pbExchangeProviderPrimaryUserGuid,	lprowsStores->aRow[ulRow].lpProps[2].Value.bin.cb))

			 {

				 //
				 // If this is the Exchange store.
				 // Open the information store using the value of PR_ENTRYID
				 //
				 hr = m_lpMapiSession->OpenMsgStore(
					 NULL,
					 lprowsStores->aRow[ulRow].lpProps[1].Value.bin.cb,
					 (LPENTRYID)lprowsStores->aRow[ulRow].lpProps[1].Value.bin.lpb,
					 NULL, // get the standard interface IMsgStore
					 MAPI_BEST_ACCESS,
					 &m_lpIMsgStore);
				 {
					 if (FAILED(hr))
					 {
						 Error(("OpenMsgStore failed for store [%s]. hr = 0x%08X",
							    lprowsStores->aRow[ulRow].lpProps[0].Value.lpszA,
								hr));
						 goto Exit;
					 }
				 }
			 }
		}
	}
	
Exit:

	if (lpStoreTable)
	{
		lpStoreTable->Release();
		lpStoreTable = NULL;
	}

	if (lprowsStores)
	{
		FreeProws(lprowsStores);
		lprowsStores = NULL;
	}

	return SUCCEEDED(hr);
}


BOOL
CMAPIabObj::InitMapiService(
    HWND    hDlg
    )

/*++

Routine Description:

    Initialize Simple MAPI services 

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Every successful call to this function must be balanced
    by a call to DeinitMapiService.

--*/

{
    BOOL result = FALSE;

	m_lpIMsgStore=NULL;
    if(!IsOutlookDefaultClient())
    {
        return result;
    }

    //
    // Load MAPI32.DLL into memory if necessary
    //

    if ((m_hInstMapi == NULL) &&
        (m_hInstMapi = LoadLibrary(TEXT("MAPI32.DLL"))))
    {
        //
        // Get pointers to various Simple MAPI functions
        //

        m_lpfnMAPILogonEx = (LPMAPILOGONEX) GetProcAddress(m_hInstMapi, "MAPILogonEx");
        m_lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(m_hInstMapi, "MAPILogoff");
        m_lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress(m_hInstMapi, "MAPIAddress");
        m_lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(m_hInstMapi, "MAPIFreeBuffer");
        m_lpfnMAPIInitialize = (LPMAPIINITIALIZE) GetProcAddress(m_hInstMapi, "MAPIInitialize");
		m_lpfnMAPIUninitialize = (LPMAPIUNINITIALIZE) GetProcAddress(m_hInstMapi, "MAPIUninitialize");
		m_lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)	GetProcAddress(m_hInstMapi, "MAPIAllocateBuffer");
		m_lpfnMAPIAllocateMore = (LPMAPIALLOCATEMORE)	GetProcAddress(m_hInstMapi, "MAPIAllocateMore");
		m_lpfnMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress( m_hInstMapi,"MAPIAdminProfiles" );
		m_lpfnHrQueryAllRows = (LPHrQueryAllRows)GetProcAddress(m_hInstMapi,"HrQueryAllRows@24");


        //
        // Begins a simple MAPI session and obtain session handle and pointer
        //

        if (m_lpfnMAPILogonEx == NULL ||
            m_lpfnMAPILogoff == NULL ||
            m_lpfnMAPIAddress == NULL ||
            m_lpfnMAPIFreeBuffer == NULL ||
			m_lpfnMAPIInitialize == NULL || 
			m_lpfnMAPIUninitialize == NULL ||
			m_lpfnMAPIAllocateBuffer == NULL ||
			m_lpfnMAPIAllocateMore == NULL ||
			m_lpfnMAPIAdminProfiles == NULL ||
			m_lpfnHrQueryAllRows == NULL ||
            !DoMapiLogon(hDlg))
        {
            //
            // Clean up properly in case of error
            //

            m_lpMapiSession = NULL;
            FreeLibrary(m_hInstMapi);
            m_hInstMapi = NULL;
        }
        else
        {
            result = TRUE;
        }
    }

    return result;
}

VOID
CMAPIabObj::DeinitMapiService(
    VOID
    )

/*++

Routine Description:

    Deinitialize Simple MAPI services if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
	if (m_hInstMapi != NULL) 
        {
            if (m_lpAdrBook)
            {
                m_lpAdrBook->Release();
                m_lpAdrBook = NULL;
            }
			if (m_lpIMsgStore)
			{	
				m_lpIMsgStore->Release();
				m_lpIMsgStore = NULL;
			}
            if (m_lpMapiSession) 
            {
                m_lpMapiSession->Logoff(0,0,0);	
                m_lpMapiSession->Release();
                m_lpMapiSession = NULL;
            }

            m_lpfnMAPIUninitialize();
            FreeLibrary(m_hInstMapi);
            m_hInstMapi = NULL;
	}
}

CMAPIabObj::~CMAPIabObj()
/*++

Routine Description:

    Destructor for CMAPIabObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
	DeinitMapiService();
}

LPSTR
CMAPIabObj::DupStringUnicodeToAnsi(
    LPVOID  lpObject,
    LPWSTR  pUnicodeStr
    )

/*++

Routine Description:

    Convert a Unicode string to a multi-byte string

Arguments:

    pUnicodeStr - Pointer to the Unicode string to be duplicated

Return Value:

    Pointer to the duplicated multi-byte string

NOTE:

    This is only need because the MAPI is not Unicode enabled on NT.

    This uses the MAPI memory allocator so it must be freed with FreeBuffer.
--*/

{
    INT     nChar;
    LPSTR   pAnsiStr;

    //
    // Figure out how much memory to allocate for the multi-byte string
    //

    if (! (nChar = WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, NULL, 0, NULL, NULL)) ||
        ! HR_SUCCEEDED( m_lpfnMAPIAllocateMore ( nChar, lpObject, (LPVOID *) &pAnsiStr )))
    {
        return NULL;
    }

    //
    // Convert Unicode string to multi-byte string
    //

    WideCharToMultiByte(CP_ACP, 0, pUnicodeStr, -1, pAnsiStr, nChar, NULL, NULL);
    return pAnsiStr;
}

LPENTRYID	
CMAPIabObj::DuplicateEntryId(
	ULONG		cbSize,           
    LPVOID		lpObject,
	LPENTRYID	lpEntryId
)
/*++

Routine Description:

    Duplicates EntryID

Arguments:

	cbSize -    [in] Size, in bytes, of the new buffer to be allocated. 
	lpObject -	[in] Pointer to an existing MAPI buffer allocated using MAPIAllocateBuffer. 
    lpEntryId - [in] Pointer to the source

Return Value:

    Pointer to new ENTRYID

--*/
{
	LPENTRYID	lpNewEntryID = NULL;

    if (!cbSize || !lpObject || !lpEntryId)
		return NULL;

	if (HR_SUCCEEDED(m_lpfnMAPIAllocateMore ( cbSize, lpObject, (LPVOID *) &lpNewEntryID )))
	{
		CopyMemory(lpNewEntryID, lpEntryId, cbSize);
	}

	return lpNewEntryID;
}


LPSTR
CMAPIabObj::DuplicateAnsiString(
    LPVOID  lpObject,
    LPCSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPSTR  pDestStr;
    INT    nChar;

    if (pSrcStr != NULL) {

        nChar = (strlen(pSrcStr) + 1 )*sizeof(char);

		if ( nChar && HR_SUCCEEDED( m_lpfnMAPIAllocateMore ( nChar, lpObject, (LPVOID *) &pDestStr )))
            CopyMemory(pDestStr, pSrcStr, nChar);
        else
            return NULL;

    } else
        pDestStr = NULL;

    return pDestStr;
}

HRESULT
CMAPIabObj::ABAllocateBuffer(
	ULONG cbSize,           
	LPVOID FAR * lppBuffer  
    )

/*++

Routine Description:


Arguments:


Return Value:
--*/

{
    return m_lpfnMAPIAllocateBuffer( cbSize, lppBuffer );
}


ULONG
CMAPIabObj::ABFreeBuffer(
	LPVOID lpBuffer
	)
{
	return m_lpfnMAPIFreeBuffer(lpBuffer);
}


extern "C"
VOID
FreeMapiEntryID(
    PWIZARDUSERMEM	pWizardUserMem,
	LPENTRYID		lpEntryId
				)
/*++

Routine Description:

    C wrapper for MAPI Free

Arguments:

    pWizardUserMem - pointer to WIZARDUSERMEM structure
    lpEntryID - pointer to EntryId

Return Value:
	
	  NONE

--*/
{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;
	lpCMAPIabObj->ABFreeBuffer(lpEntryId);		
}

extern "C"
BOOL
CallMAPIabAddress(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT * ppNewRecipient
    )
/*++

Routine Description:

    C wrapper for CMAPIabObj->Address

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure
    ppNewRecipient - list to add new recipients to.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;

    return lpCMAPIabObj->Address(
                hDlg,
                pWizardUserMem->pRecipients,
                ppNewRecipient
                );

}

extern "C"
LPTSTR
CallMAPIabAddressEmail(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    C wrapper for CMAPIabObj->AddressEmail

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    TRUE if found one appropriate E-mail
    FALSE otherwise.

--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;

    return lpCMAPIabObj->AddressEmail(
                hDlg
                );

}

extern "C"
LPVOID
InitializeMAPIAB(
    HINSTANCE hInstance,
	HWND	  hDlg
    )
/*++

Routine Description:

    Initialize the MAPI.

Arguments:

    hInstance - instance handle.

Return Value:

    NONE
--*/

{
    CMAPIabObj * lpCMAPIabObj = new CMAPIabObj ( hInstance, hDlg );

	if ((lpCMAPIabObj!=NULL) && (!lpCMAPIabObj->isInitialized()))	// constructor failed
	{
		delete lpCMAPIabObj;
		lpCMAPIabObj = NULL;
	}

    return (LPVOID) lpCMAPIabObj ;
}

extern "C"
VOID
UnInitializeMAPIAB(
    LPVOID lpVoid
    )
/*++

Routine Description:

    UnInitialize the MAPI.

Arguments:

    NONE

Return Value:

    NONE
--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) lpVoid;

    delete lpCMAPIabObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\mapiwrap.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapiwrap.h

Abstract:

    Utility functions for working with MAPI

Environment:

	Windows XP fax driver user interface

Revision History:

	09/18/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _MAPIWRAP_H_
#define _MAPIWRAP_H_

#include <mapix.h>
#include <mapi.h>

#define MAPICALL(p) (p)->lpVtbl


//
// MAPI address type for fax addresses
//

//#define FAX_ADDRESS_TYPE    TEXT("FAX:")

//
// Determine whether MAPI is available
//

BOOL
IsMapiAvailable(
    VOID
    );

//
// Initialize Simple MAPI services if necessary
//

BOOL
InitMapiService(
    HWND    hDlg
    );

//
// Deinitialize Simple MAPI services if necessary
//

VOID
DeinitMapiService(
    VOID
    );

//
// Call MAPIAddress to display the address dialog
//

BOOL
CallMapiAddress(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PULONG          pnRecips,
    lpMapiRecipDesc *ppRecips
    );

//
// Expanded the selected addresses and insert them into the recipient list view
//

BOOL
InterpretSelectedAddresses(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    HWND            hwndLV,
    ULONG           nRecips,
    lpMapiRecipDesc pRecips
    );

//
// Function points to Simple MAPI entrypoints
//

typedef SCODE (*LPSCMAPIXFROMSMAPI)(LHANDLE, ULONG, LPCIID, LPMAPISESSION *);

extern LPMAPILOGONEX        lpfnMAPILogon;
extern LPMAPILOGOFF         lpfnMAPILogoff;
extern LPMAPIADDRESS        lpfnMAPIAddress;
extern LPMAPIFREEBUFFER     lpfnMAPIFreeBuffer;
extern LPSCMAPIXFROMSMAPI   lpfnScMAPIXFromSMAPI;
extern ULONG                lhMapiSession;
extern LPMAPISESSION        lpMapiSession;

#endif	// !_MAPIWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\registry.h ===
#ifndef __REGISTRY_H_
#define __REGISTRY_H_


#include <windows.h>
#include <fxsapip.h>
#include <faxsendw.h>

#ifdef __cplusplus
extern "C"{
#endif 

HRESULT
SaveLastReciptInfo(
	DWORD	dwReceiptDeliveryType,
	LPTSTR	szReceiptAddress
);
HRESULT	
RestoreLastReciptInfo(
    DWORD* pdwReceiptDeliveryType,
    LPTSTR * lpptReceiptDeliveryProfile
);

HRESULT	
SaveLastRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppRecipient,
    DWORD                 dwLastRecipientCountryId
);
HRESULT 
RestoreLastRecipientInfo(
    DWORD*                 pdwNumberOfRecipients,
    PFAX_PERSONAL_PROFILE* lppFaxSendWizardData,
    DWORD*                 pdwLastRecipientCountryId
);

HRESULT 
RestoreCoverPageInfo(
    LPTSTR* lpptstrCoverPageFileName
);
HRESULT	
SaveCoverPageInfo(
    LPTSTR lptstrCoverPageFileName
);

HRESULT	
RestoreUseDialingRules(
    BOOL* pbUseDialingRules,
    BOOL* pbUseOutboundRouting
);

HRESULT	
SaveUseDialingRules(
    BOOL bUseDialingRules,
    BOOL bUseOutboundRouting
);

BOOL IsOutlookDefaultClient();

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\registry.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

Environment:
        Fax driver

Revision History:
    10/13/99 -v-sashab-
        Created it.


--*/


#include "faxui.h"
#include "Registry.h"

#include "faxreg.h"
#include "registry.h"
#include "faxlib.h"

HRESULT
SaveLastReciptInfo(
    DWORD   dwReceiptDeliveryType,
    LPTSTR  szReceiptAddress
    )

/*++

Routine Description:

    Save the information about the last recipt in the registry

Arguments:
    
      dwReceiptDeliveryType - specifice delivery type: REGVAL_RECEIPT_MSGBOX, REGVAL_RECEIPT_EMAIL, REGVAL_RECEIPT_NO_RECEIPT
      szReceiptDeliveryProfile - specifies delivery profile (e-mail address)
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

   
    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE)  ) 
    {
        if (dwReceiptDeliveryType == DRT_NONE)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT, 0);
        }

        if (dwReceiptDeliveryType & DRT_GRP_PARENT)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT, 0);
        }

        if (dwReceiptDeliveryType & DRT_MSGBOX)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX, 0);
        }

        if (dwReceiptDeliveryType & DRT_EMAIL)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL, 0);
        }

        if (dwReceiptDeliveryType & DRT_ATTACH_FAX)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX, 0);
        }

        if ((dwReceiptDeliveryType & DRT_EMAIL) && szReceiptAddress)
        {
            //
            // Save profile (address) only for mail receipt types
            //
            // if this function failes, it prints a warning message inside
            SetRegistryString(hRegKey, REGVAL_RECEIPT_ADDRESS, szReceiptAddress);
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastReciptInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}


HRESULT
RestoreLastReciptInfo(
    DWORD  * pdwReceiptDeliveryType,
    LPTSTR * lpptReceiptAddress
    )

/*++

Routine Description:

    Restores the information about the last receipt from the registry

Arguments:

    pdwReceiptDeliveryType   - specifice delivery type: REGVAL_RECEIPT_MSGBOX, REGVAL_RECEIPT_EMAIL, REGVAL_RECEIPT_NO_RECEIPT
    szReceiptDeliveryProfile - specifies delivery profile (e-mail address)

Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pdwReceiptDeliveryType);
    Assert(lpptReceiptAddress);

    *pdwReceiptDeliveryType = DRT_NONE;
    *lpptReceiptAddress = NULL;

    if ((hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
    {
        if (!GetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT) &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT) &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX)      &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL)) 
        {
            Verbose (("RestoreLastReciptInfo runs for the very first time\n"));
        }
        else 
        {
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_GRP_PARENT;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_MSGBOX;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_EMAIL;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_ATTACH_FAX;
            }
            if (!(*lpptReceiptAddress = GetRegistryString(hRegKey, REGVAL_RECEIPT_ADDRESS, TEXT(""))))
            {
                Error(("Memory allocation failed\n"));
                hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto error;
            }
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastReciptInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }
    goto exit;
error:
    if (hRegKey)
    {
        RegCloseKey(hRegKey);
    }
    if (*lpptReceiptAddress)
    {
        MemFree(*lpptReceiptAddress);
    }
exit:
    return hResult;
}


HRESULT
SaveLastRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppRecipient,
    DWORD                 dwLastRecipientCountryId
    )

/*++

Routine Description:

    Save the information about the last recipient in the registry

Arguments:

  pfppRecipient             [in] - Recipient personal info
  dwLastRecipientCountryId  [in] - Last recipient country ID
    
Return Value:

    S_OK   - if success
    E_FAIL - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pfppRecipient);

    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE) ) 
    {
        SetRegistryString(hRegKey, REGVAL_LAST_RECNAME, pfppRecipient->lptstrName);
        SetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, pfppRecipient->lptstrFaxNumber);
        SetRegistryDword( hRegKey, REGVAL_LAST_COUNTRYID, dwLastRecipientCountryId);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastRecipientInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}


HRESULT
RestoreLastRecipientInfo(
    DWORD*                  pdwNumberOfRecipients,
    PFAX_PERSONAL_PROFILE*  lppFaxSendWizardData,
    DWORD*                 pdwLastRecipientCountryId
    )

/*++

Routine Description:

    Restores the information about the last recipient from the registry

Arguments:

  pdwNumberOfRecipients      [out] - Number of recipients
  lppFaxSendWizardData       [out] - Recipient personal info
  pdwLastRecipientCountryId  [out] - Last recipient country ID

Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    LPTSTR  lptstrName = NULL, lptstrFaxNumber = NULL;
    HRESULT hResult = S_OK;

    //
    // validate parameters
    //

    Assert (pdwNumberOfRecipients);
    Assert (lppFaxSendWizardData);
    Assert (pdwLastRecipientCountryId);

    *pdwNumberOfRecipients = 0;
    *lppFaxSendWizardData = NULL;
    *pdwLastRecipientCountryId = 0;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) 
    {
        if (!(lptstrName    = GetRegistryString(hRegKey, REGVAL_LAST_RECNAME, TEXT(""))) ||
            !(lptstrFaxNumber = GetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, TEXT(""))))
        {
             Error(("GetRegistryString failed\n"));
             hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
             goto error;
        }
        if (!(*lppFaxSendWizardData = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }
        
        *pdwLastRecipientCountryId = GetRegistryDword(hRegKey, REGVAL_LAST_COUNTRYID);

        *pdwNumberOfRecipients = 1;
        (*lppFaxSendWizardData)[0].lptstrName = lptstrName;
        (*lppFaxSendWizardData)[0].lptstrFaxNumber = lptstrFaxNumber;


        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreLastRecipientInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }

    goto exit;
error:
    MemFree ( lptstrName    );
    MemFree ( lptstrFaxNumber );
    if (hRegKey)
        RegCloseKey(hRegKey);
exit:
    return hResult;

}


HRESULT
RestoreCoverPageInfo(
    LPTSTR * lpptstrCoverPageFileName
    )
/*++

Routine Description:

    Restores the information about the cover page from the registry

Arguments:

    lpptstrCoverPageFileName - pointer to restore coverd page file name

Return Value:

    S_OK if success
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    //
    // validate parameter
    //

    Assert(lpptstrCoverPageFileName);

    //
    // Retrieve the most recently used cover page settings
    //


    *lpptstrCoverPageFileName = NULL;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) 
    {
        if (!(*lpptstrCoverPageFileName = GetRegistryString(hRegKey, REGVAL_COVERPG, TEXT("") )))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreCoverPageInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }
    goto exit;
error:
    if (hRegKey)
        RegCloseKey(hRegKey);
exit:
    return hResult;
}

HRESULT
SaveCoverPageInfo(
    LPTSTR lptstrCoverPageFileName
    )
/*++

Routine Description:

    Save the information about the cover page settings in the registry

Arguments:
    
      lptstrCoverPageFileName - pointer to cover page file name
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE)  ) {

        SetRegistryString(hRegKey, REGVAL_COVERPG, lptstrCoverPageFileName);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveCoverPageInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}

HRESULT 
RestoreUseDialingRules(
    BOOL* pbUseDialingRules,
    BOOL* pbUseOutboundRouting
)
/*++

Routine Description:

    Restore UseDialingRules / UseOutboundRouting option from the registry

Arguments:
    
      pbUseDialingRules    - [out] TRUE if the option is selected
      pbUseOutboundRouting - [out] TRUE if the option is selected
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pbUseDialingRules && pbUseOutboundRouting);

    *pbUseDialingRules = FALSE;
    hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY);
    if(hRegKey)
    {
        *pbUseDialingRules = GetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES);
        *pbUseOutboundRouting = GetRegistryDword(hRegKey, REGVAL_USE_OUTBOUND_ROUTING);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreUseDialingRules: GetUserInfoRegKey failed\n"));
        hResult = E_FAIL;
    }
    return hResult;
}

HRESULT 
SaveUseDialingRules(
    BOOL bUseDialingRules,
    BOOL bUseOutboundRouting
)
/*++

Routine Description:

    Save UseDialingRules / UseOutboundRouting option in the registry

Arguments:
    
      bUseDialingRules    - [in] TRUE if the option selected
      bUseOutboundRouting - [in] TRUE if the option selected
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE);
    if(hRegKey)
    {
        if(!SetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES, bUseDialingRules))
        {
            Error(("SaveUseDialingRules: SetRegistryDword failed\n"));
            hResult = E_FAIL;
        }
        if(!SetRegistryDword(hRegKey, REGVAL_USE_OUTBOUND_ROUTING, bUseOutboundRouting))
        {
            Error(("SaveUseDialingRules: SetRegistryDword failed\n"));
            hResult = E_FAIL;
        }
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveUseDialingRules: GetUserInfoRegKey failed\n"));
        hResult = E_FAIL;
    }
    return hResult;
}

BOOL 
IsOutlookDefaultClient()
/*++

Routine Description:

    Determine if the Microsoft Outlook is default mail client    
    
Return Value:

    TRUE   - if yes
    FALSE  - otherwise

--*/
{
    BOOL  bRes = FALSE;
    DWORD dwRes = ERROR_SUCCESS;
    HKEY  hRegKey = NULL;
    TCHAR tszMailClient[64] = {0};
    DWORD dwType;
    DWORD dwSize = sizeof(tszMailClient)-2;

    dwRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGKEY_MAIL_CLIENT,
                         0,
                         KEY_READ,
                         &hRegKey);
    if(ERROR_SUCCESS != dwRes)
    {
        Error(("IsOutlookDefaultClient: RegOpenKeyEx failed: ec = 0x%X\n", GetLastError()));
        return bRes;
    }

    dwRes = RegQueryValueEx(hRegKey,
                            NULL,
                            NULL,
                            &dwType,
                            (LPBYTE)tszMailClient,
                            &dwSize);
    if(ERROR_SUCCESS != dwRes)
    {
        Error(("IsOutlookDefaultClient: RegQueryValueEx failed: ec = 0x%X\n", GetLastError()));
    }
    else
    {
        if((REG_SZ == dwType) && !_tcsicmp(tszMailClient, REGVAL_MS_OUTLOOK))
        {
            bRes = TRUE;
        }
    }

    RegCloseKey(hRegKey);

    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

!include ..\..\..\..\faxsrc.inc

TARGETNAME=$(FAXWZRD)
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=$O\PrnWzrd.DEF

C_DEFINES = $(C_DEFINES) -DTARGET_NAME=$(TARGETNAME)


DLLENTRY=DllEntryPoint
!if 0
NTPROFILEINPUT=yes
!endif

UMTYPE=windows

SYNCHRONIZE_BLOCK=1

USE_CRTDLL=1
NTKEEPRESOURCETMPFILES=1

USE_STL=1

PRECOMPILED_INCLUDE=..\faxui.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

INCLUDES=\
  ..\; \
  $(INCLUDES); \
  ..\res; \
  ..\..\inc; \
  $(FAXROOT)\faxcover\renderer; \
  $(FAXROOT)\admin\faxclient\cfg; \
  $(FAXROOT)\tiff\inc



!ifndef NOUNICODE

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
  $(BASEDIR)\public\sdk\lib\*\user32.lib   \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib  \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib \
  $(BASEDIR)\public\sdk\lib\*\tapi32.lib   \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib    \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib     \
  $(BASEDIR)\public\sdk\lib\*\imm32.lib    \
  $(FAXLIB)\*\$(WINFAX).lib                \
  $(FAXLIB)\*\faxrend.lib                  \
  $(FAXLIB)\*\$(FAXTIFF).lib               \
  $(FAXROOT)\util\unicode\obj\*\faxutil.lib

LINKLIBS=..\..\lib\umwinnt\$O\faxlib.lib $(LINKLIBS)

!else
NO_NTDLL=1
C_DEFINES=$(C_DEFINES) -DWIN__95

LINKLIBS_INT=\
  $(BASEDIR)\public\sdk\lib\*\user32.lib   \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib  \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
  $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib \
  $(BASEDIR)\public\sdk\lib\*\tapi32.lib   \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib    \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib     \
  $(BASEDIR)\public\sdk\lib\*\imm32.lib    \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib   \
  $(FAXLIB)\win95\*\faxrend.lib	           \
  $(FAXLIB)\win95\*\$(WINFAX).lib          \
  $(FAXLIB)\*\$(FAXTIFF).lib               \
  $(FAXROOT)\util\ansii\obj\*\faxutil.lib

LINKLIBS=..\..\lib\umwin95\$O\faxlib.lib $(LINKLIBS)

!endif

TARGETLIBS=\
  $(LINKLIBS_INT)

SOURCES=\
  ..\faxui.c     \
  ..\wizard.c    \
  ..\coverpg.c   \
  ..\tapiutil.c  \
  ..\mapiabobj.cpp \
  ..\cwabobj.cpp \
  ..\abobj.cpp \
  ..\async.c     \
  ..\registry.c	\
  ..\faxui.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\tapiutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.h

Abstract:

    Utility functions for working with TAPI

Environment:

        Windows fax driver user interface

Revision History:

        09/18/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <shellapi.h>


//
// Initialize the country list box
//

VOID
InitCountryListBox(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    HWND						hwndList,
    HWND						hwndAreaCode,
	LPTSTR						lptstrCountry,
    DWORD						countryCode,
	BOOL                        bAddCountryCode
    );

//
// Handle selection changes in the country list box
//

VOID
SelChangeCountryListBox(
    HWND						hwndList,
    HWND						hwndAreaCode,
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList
    );

//
// Return the current selection of country list box
//

DWORD
GetCountryListBoxSel(
    HWND    hwndList
    );

//
// Return the default country ID for the current location
//

DWORD
GetDefaultCountryID(
    VOID
    );

//
// Given a FAX_TAPI_LINECOUNTRY_ENTRY structure, determine if area code is needed in that country
//

INT
AreaCodeRules(
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry
    );

#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

//
// Find the specified country from a list of all countries and
// return a pointer to the corresponding FAX_TAPI_LINECOUNTRY_ENTRY structure
//

PFAX_TAPI_LINECOUNTRY_ENTRY
FindCountry(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    DWORD					    countryId
    );

//
// Assemble a canonical phone number given the following:
//  country code, area code, and phone number
//

VOID
AssemblePhoneNumber(
    LPTSTR  pAddress,
    DWORD   countryCode,
    LPTSTR  pAreaCode,
    LPTSTR  pPhoneNumber
    );


//
// bring country id from the country code
//
DWORD
GetCountryIdFromCountryCode(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    DWORD						dwCountryCode
    );

BOOL
DoTapiProps(
    HWND hDlg
    );

BOOL
SetCurrentLocation(
    DWORD   locationID
    );


LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    );

void
ShutdownTapi ();

BOOL
InitTapi ();

BOOL
TranslateAddress (
    LPCTSTR lpctstrCanonicalAddress,
    DWORD   dwLocationId,
    LPTSTR *lpptstrDialableAndDisplayableAddress
);





#endif  // !_TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\resource.h ===
#define IDS_ERR_TAPI_CPL_LAUNCH         247
#define IDS_SEND_SPECIFIC               248
#define IDS_MULTIPLE_RECIPIENTS         249
#define IDS_NONE                        250
#define IDS_SCAN_ERROR_TITLE            251
#define IDS_SCAN_ERROR_BW               252
#define IDS_WIZARD_TITLE                253
#define IDS_ERR_CPL_LAUNCH              255
#define IDS_NO_COUNTRY                  259
#define IDS_ERROR_DLGTITLE              260
#define IDS_BAD_RECIPIENT_NAME          262
#define IDS_BAD_RECIPIENT_NUMBER        263
#define IDS_BAD_RECIPIENT_AREACODE      264
#define IDS_BAD_ADDRESS_TYPE            265
#define IDS_COVERPAGE_FOR               266
#define IDS_ERROR_RECEIPT_DL            267
#define IDS_ERROR_RECEIPT_SMTP          268
#define IDS_NOTE_SUBJECT_EMPTY          271
#define IDS_COLUMN_RECIPIENT_NAME       272
#define IDS_COLUMN_RECIPIENT_NUMBER     273
#define IDS_FAX_SERVER                  274
#define IDS_ERROR_SERVER_RETRIEVE       275
#define IDS_USERCP_SUFFIX               276
#define IDS_NO_FAXSERVER                277
#define IDS_HOME                        278
#define IDS_BUSINESS                    279
#define IDS_ERROR_RECIPIENT_NAME        280
#define IDS_ERROR_AREA_CODE             282
#define IDS_WIZ_RECIPIENT_TITLE         283
#define IDS_WIZ_RECIPIENT_SUB           284
#define IDS_WIZ_COVERPAGE_TITLE         285
#define IDS_WIZ_COVERPAGE_SUB           286
#define IDS_WIZ_SCAN_TITLE              287
#define IDS_WIZ_SCAN_SUB                288
#define IDS_WIZ_FAXOPTS_TITLE           289
#define IDS_WIZ_FAXOPTS_SUB             290
#define IDS_WIZ_FINISH_TITLE            291
#define IDS_WIZ_FINISH_SUB              292
#define IDS_WIZ_WELCOME_TITLE           293
#define IDS_WIZ_WELCOME_SUB             294
#define IDS_WIZ_TIME_FORMAT             295
#define IDS_LARGEFONT_NAME              296
#define IDS_LARGEFONT_SIZE              297
#define IDS_SEND_DISCOUNT               298
#define IDS_SEND_ASAP                   299



//
// Icon and bitmap resource IDs
//

#define IDI_FAX_OPTIONS                 1001
#define IDI_ARROW                       1002
#define IDB_FAXWIZ_BITMAP               1003
#define IDB_WATERMARK_16                1004
#define IDB_WATERMARK_256               1005
#define IDB_FAXWIZ_WATERMARK            1006
#define IDI_USERINFO                    1007

#define IDC_SEND_ASAP                   300
#define IDC_SEND_AT_CHEAP               301
#define IDC_SEND_AT_TIME                302
#define IDC_PAPER_SIZE                  303
#define IDC_IMAGE_QUALITY               304
#define IDC_PORTRAIT                    305
#define IDC_LANDSCAPE                   306
#define IDC_BILLING_CODE                307
#define IDC_RUN_FAXCFG                  308
#define IDC_EMAIL                       309

#define IDC_SENDTIME                    310

#define IDC_TITLE                       326
#define IDC_FAX_SEND_GRP                327
#define IDC_DEFAULT_PRINT_SETUP_GRP     328
#define IDC_ORIENTATION                 329

#define IDC_STATIC_ATTACH_NOTE          330
#define IDI_FAX_INFO                    331
#define IDC_STATIC_NOTE_ICON            332

#define IDC_STATIC                      -1

#define IDD_WIZARD_WELCOME              1000
#define IDD_WIZARD_CHOOSE_WHO           1001
#define IDD_WIZARD_CHOOSE_CP            1002
#define IDD_WIZARD_SCAN                 1003
#define IDD_WIZARD_FAXOPTS              1004
#define IDD_WIZARD_CONGRATS             1005
#define IDD_CHOOSE_FAXNUMBER            1006
#define IDD_WIZFIRSTTIME                1007
#define IDD_WIZARD_USERINFO             1008
#define IDD_WIZARD_FAXRECEIPT           1009
#define IDD_WIZ_ADDRESS                 1010

#define IDD_WIZARD_WELCOME_NOWIZARD97              1020
#define IDD_WIZARD_CHOOSE_WHO_NOWIZARD97           1021
#define IDD_WIZARD_CHOOSE_CP_NOWIZARD97            1022
#define IDD_WIZARD_SCAN_NOWIZARD97                 1023
#define IDD_WIZARD_FAXOPTS_NOWIZARD97              1024
#define IDD_WIZARD_CONGRATS_NOWIZARD97             1025
#define IDD_WIZARD_FAXRECEIPT_NOWIZARD97           1026

#define IDC_STATIC_HEADER_TITLE         1050
#define IDC_STATIC_HEADER_SUB           1051

#define IDC_BITMAP_STATIC               1300

#define IDC_WIZ_WELCOME_BMP             1301
#define IDC_WIZ_WELCOME_TITLE           1302
#define IDC_WIZ_WELCOME_DESCR           1303
#define IDC_WIZ_WELCOME_FAXSEND         1304
#define IDC_WIZ_WELCOME_NOFAXSEND       1306

#define IDC_CHOOSE_NAME_EDIT            1311
#define IDC_CHOOSE_ADDRBOOK             1312
#define IDC_CHOOSE_COUNTRY_COMBO        1313
#define IDC_CHOOSE_AREA_CODE_EDIT       1314
#define IDC_CHOOSE_NUMBER_EDIT          1315
#define IDC_USE_DIALING_RULE            1316
#define IDC_CHOOSE_ADD                  1317
#define IDC_CHOOSE_REMOVE               1318
#define IDC_CHOOSE_RECIPIENT_LIST       1319
#define IDC_CHOOSE_CP_USER_INFO         1320
#define IDC_CHOOSE_EDIT                 1321
#define IDC_COMBO_DIALING_RULES         1322
#define IDC_DIALING_RULES               1323
#define IDC_BRACKET_LEFT                1324
#define IDC_BRACKET_RIGHT               1325

#define IDC_CHOOSE_CP_CHECK             1400
#define IDC_CHOOSE_CP_LIST              1401
#define IDC_STATIC_CHOOSE_CP_SUBJECT    1402
#define IDC_CHOOSE_CP_SUBJECT           1403
#define IDC_STATIC_CHOOSE_CP_NOTE       1404
#define IDC_CHOOSE_CP_NOTE              1405
#define IDC_STATIC_CHOOSE_TEMPLATE      1406
#define IDC_STATIC_CP_PREVIEW           1407

#define IDC_STATIC_WIZ_FAXOPTS_WHEN     1500
#define IDC_WIZ_FAXOPTS_ASAP            1501
#define IDC_WIZ_FAXOPTS_DISCOUNT        1502
#define IDC_WIZ_FAXOPTS_SPECIFIC        1503
#define IDC_WIZ_FAXOPTS_SENDTIME        1504
#define IDC_STATIC_WIZ_FAXOPTS_BILLING  1505
#define IDC_WIZ_FAXOPTS_BILLING         1506
#define IDC_WIZ_FAXOPTS_DATE            1508
#define IDC_WIZ_FAXOPTS_NONE_RECEIPT    1509
#define IDC_WIZ_FAXOPTS_MSGBOX          1510
#define IDC_WIZ_FAXOPTS_EMAIL           1511
#define IDC_WIZ_FAXOPTS_ADDRBOOK        1512
#define IDC_WIZ_FAXOPTS_EMAIL_EDIT      1513
#define IDC_WIZ_FAXOPTS_GRP_PARENT      1514
#define IDS_WIZ_FAXRECEIPT_TITLE        1515
#define IDS_WIZ_FAXRECEIPT_SUB          1516
#define IDC_HORIZONTAL_SEPARATOR        1517
#define IDC_STATIC_WIZ_PRIORITY         1518
#define IDC_WIZ_FAXOPTS_PRIORITY_HIGH   1519    
#define IDC_WIZ_FAXOPTS_PRIORITY_NORMAL 1520
#define IDC_WIZ_FAXOPTS_PRIORITY_LOW    1521
#define IDC_WIZ_FAXOPTS_ATTACH_FAX      1524

#define IDC_SCAN_PAGE                   1601
#define IDC_PAGE_COUNT                  1602
#define IDC_DATA_SOURCE                 1603

#define IDC_DISPLAY_NAME                1700
#define IDC_BUSINESS_FAX                1701
#define IDC_HOME_FAX                    1702
#define IDC_OTHER_FAX                   1703
#define IDC_ALLBUS                      1704
#define IDC_ALLHOME                     1705
#define IDC_ALLOTHER                    1706
#define IDC_BUSINESS_FAX_NUM            1707
#define IDC_HOME_FAX_NUM                1708
#define IDC_OTHER_FAX_NUM               1709
#define IDS_CHOOSE_FAX_NUMBER           1710

#define IDC_WIZ_CONGRATS_BMP            1800
#define IDC_STATIC_WIZ_CONGRATS_READY   1801
#define IDC_STATIC_WIZ_CONGRATS_FROM    1802
#define IDC_WIZ_CONGRATS_FROM           1803
#define IDC_STATIC_WIZ_CONGRATS_TIME    1806
#define IDC_WIZ_CONGRATS_TIME           1807
#define IDC_WIZ_CONGRATS_SUBJECT        1810
#define IDC_STATIC_WIZ_CONGRATS_SUBJECT 1811
#define IDC_STATIC_WIZ_CONGRATS_COVERPG 1812
#define IDC_WIZ_CONGRATS_COVERPG        1813
#define IDC_WIZ_CONGRATS_RECIPIENT_LIST 1814
#define IDC_WIZ_CONGRATS_PREVIEW_FAX    1815

#define IDS_PREVIEW_TITLE               1816 
#define IDS_PREVIEW_FAILURE             1817
#define IDS_PLEASE_CLOSE_FAX_PREVIEW    1818
#define IDS_PREVIEW_NOTHING_TO_PREVIEW  1819



#define     IDC_STATIC_WIZ_USERINFO_FULLNAME        1901
#define     IDC_WIZ_USERINFO_FULLNAME               1902
#define     IDC_STATIC_WIZ_USERINFO_FAX_NUMBER      1903
#define     IDC_WIZ_USERINFO_FAX_NUMBER             1904
#define     IDC_STATIC_WIZ_USERINFO_MAILBOX         1905
#define     IDC_WIZ_USERINFO_MAILBOX                1906
#define     IDC_STATIC_WIZ_USERINFO_TITLE           1907
#define     IDC_WIZ_USERINFO_TITLE                  1908
#define     IDC_STATIC_WIZ_USERINFO_COMPANY         1909
#define     IDC_WIZ_USERINFO_COMPANY                1910
#define     IDC_STATIC_WIZ_USERINFO_OFFICE          1911
#define     IDC_WIZ_USERINFO_OFFICE                 1912
#define     IDC_STATIC_WIZ_USERINFO_DEPT            1913
#define     IDC_WIZ_USERINFO_DEPT                   1914
#define     IDC_STATIC_WIZ_USERINFO_HOME_PHONE      1915
#define     IDC_WIZ_USERINFO_HOME_PHONE             1916
#define     IDC_STATIC_WIZ_USERINFO_WORK_PHONE      1917
#define     IDC_WIZ_USERINFO_WORK_PHONE             1918
#define     IDC_BUT_WIZ_ADDRESS                     1919
#define     IDC_WIZ_USERINFO_ADDRESS                1920
#define     IDC_STATIC_WIZ_USERINFO_BILLING_CODE            1921
#define     IDC_WIZ_USERINFO_BILLING_CODE           1922
#define     IDS_WIZ_USERINFO_TITLE              1923
#define     IDS_WIZ_USERINFO_SUB                1924
#define     IDCSTATIC_USERINFO_ICON                 1925
#define     IDC_USER_INFO_JUST_THIS_TIME                1926


#define     IDD_CHECK_FAX_NUMBER            2000
#define     IDC_CHECK_FAX_NUMBER            2001
#define     IDC_CHECK_FAX_COUNTRY           2002
#define     IDC_CHECK_FAX_CITY              2003
#define     IDC_CHECK_FAX_LOCAL             2004
#define     IDC_CHECK_FAX_RECIPIENT_NAME    2005

#define     IDS_BAD_RECIPIENT_COUNTRY_CODE          2100
#define     IDS_BAD_RECEIPT_FORM                    2101
#define     IDS_BAD_RECEIPT_EMAIL_ADD               2102

#define     IDR_MENU                2300
#define     IDM_RECIPT_EDIT         2301
#define     IDM_RECIPT_DELETE       2302

#define         IDS_ERROR_SERVER_BLOCKED    3000
#define         IDS_ERROR_NO_SUBMIT_ACCESS  3001

#define     IDS_CPPREVIEW_NAME          400
#define     IDS_CPPREVIEW_FAXNUMBER     401
#define     IDS_CPPREVIEW_COMPANY       402
#define     IDS_CPPREVIEW_ADDRESS       403
#define     IDS_CPPREVIEW_CITY          404
#define     IDS_CPPREVIEW_STATE         405
#define     IDS_CPPREVIEW_ZIP           406
#define     IDS_CPPREVIEW_COUNTRY       407
#define     IDS_CPPREVIEW_TITLE         408
#define     IDS_CPPREVIEW_DEPARTMENT    409
#define     IDS_CPPREVIEW_OFFICE        410
#define     IDS_CPPREVIEW_TOLIST        411
#define     IDS_CPPREVIEW_NUMPAGES      412
#define     IDS_CPPREVIEW_TIMESENT      413
#define     IDS_CPPREVIEW_SUBJECT       414
#define     IDS_CPPREVIEW_NOTE          415
#define     IDS_ADDRESS_BOOK_CAPTION    416
#define     IDS_USE_OUTBOUND_ROUTING    417
#define     IDS_INVALID_RECIPIENT_NUMBER 418
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\tapiutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.c

Abstract:

    Utility functions for working with TAPI

Environment:

    Windows fax driver user interface

Revision History:

    09/18/96 -davidx-
        Created it.

    22/07/99 -v-sashab-
        Replaced a direct access to TAPI by Server calls

  mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "tapiutil.h"

#define  UNKNOWN_DIALING_LOCATION       (0xffffffff)

static HLINEAPP          g_hLineApp = 0;
static DWORD             g_dwTapiVersion = 0x00020000;
static DWORD             g_dwDefaultDialingLocation = UNKNOWN_DIALING_LOCATION;

BOOL
CurrentLocationUsesCallingCard ();


VOID CALLBACK
TapiLineCallback(
    DWORD     hDevice,
    DWORD     dwMessage,
    ULONG_PTR dwInstance,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    ULONG_PTR dwParam3
    )

/*++

Routine Description:

    TAPI line callback function: Even though we don't actually have anything
    to do here, we must provide a callback function to keep TAPI happy.

Arguments:

    hDevice     - Line or call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO index
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    NONE

--*/

{
}

BOOL
InitTapi ()
{
    DWORD   nLineDevs;
    LONG    status;
    LINEINITIALIZEEXPARAMS lineInitParams;

    Assert (!g_hLineApp);
    if (g_hLineApp)
    {
        return TRUE;
    }

    ZeroMemory(&lineInitParams, sizeof(lineInitParams));
    lineInitParams.dwTotalSize =
    lineInitParams.dwNeededSize =
    lineInitParams.dwUsedSize = sizeof(lineInitParams);

    status = lineInitializeEx (&g_hLineApp,
                               ghInstance,
                               TapiLineCallback,
                               TEXT("Fax Send Wizard"),
                               &nLineDevs,
                               &g_dwTapiVersion,
                               &lineInitParams);

    if (NO_ERROR != status) 
    {
        Error(("lineInitializeEx failed: %x\n", status));
        g_hLineApp = 0;
        return FALSE;
    }
    return TRUE;
}

void
ShutdownTapi ()
{
    if (!g_hLineApp)
    {
        return;
    }
    //
    // Restore the last dialing location the user selected
    //
    if (UNKNOWN_DIALING_LOCATION != g_dwDefaultDialingLocation)
    {
        SetCurrentLocation (g_dwDefaultDialingLocation);
    }
    lineShutdown (g_hLineApp);
    g_hLineApp = 0;
}   // ShutdownTapi


DWORD
GetDefaultCountryID(
    VOID
    )

/*++

Routine Description:

    Return the default country ID for the current location

Arguments:

    NONE

Return Value:

    The current ID for the current location

--*/

{
    //
    // We assume the correct information has already been saved to the
    // registry during the installation process.
    //

    return 0;
}



PFAX_TAPI_LINECOUNTRY_ENTRY
FindCountry(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       countryId
    )

/*++

Routine Description:

    Find the specified country from a list of all countries and
    return a pointer to the corresponding FAX_TAPI_LINECOUNTRY_ENTRY structure

Arguments:

    pCountryList - pointer to the country list
    countryId - Specifies the country ID we're interested in

Return Value:

    Pointer to a FAX_TAPI_LINECOUNTRY_ENTRY structure corresponding to the specified country ID
    NULL if there is an error

--*/

{
    DWORD   dwIndex;

    if (pCountryList == NULL || countryId == 0)
        return NULL;

    //
    // Look at each FAX_TAPI_LINECOUNTRY_ENTRY structure and compare its country ID with
    // the specified country ID
    //

    for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) {

        if (pCountryList->LineCountryEntries[dwIndex].dwCountryID == countryId)
            return &pCountryList->LineCountryEntries[dwIndex];
    }

    return NULL;
}

DWORD
GetCountryIdFromCountryCode(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       dwCountryCode
    )

/*++

Routine Description:


Arguments:

    pCountryList - pointer to the country list
    dwCountryCode - Specifies the country code we're interested in

Return Value:

    Country ID
--*/

{
    DWORD               dwIndex;

    if (pCountryList == NULL || dwCountryCode == 0)
        return 0;

    //
    // Look at each FAX_TAPI_LINECOUNTRY_ENTRY structure and compare its country ID with
    // the specified country ID
    //

    for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) {

        if (pCountryList->LineCountryEntries[dwIndex].dwCountryCode == dwCountryCode)
            return pCountryList->LineCountryEntries[dwIndex].dwCountryID;
    }

    return 0;
}


INT
AreaCodeRules(
    PFAX_TAPI_LINECOUNTRY_ENTRY  pEntry
    )

/*++

Routine Description:

    Given a FAX_TAPI_LINECOUNTRY_ENTRY structure, determine if area code is needed in that country

Arguments:

    pEntry - Points to a FAX_TAPI_LINECOUNTRY_ENTRY structure

Return Value:

    AREACODE_DONTNEED - Area code is not used in the specified country
    AREACODE_OPTIONAL - Area code is optional in the specified country
    AREACODE_REQUIRED - Area code is required in the specified country

--*/

{
    if ((pEntry != NULL) &&
        (pEntry->lpctstrLongDistanceRule != 0))
    {

        //
        // Area code is required in this country
        //

        if (_tcschr(pEntry->lpctstrLongDistanceRule, TEXT('F')) != NULL)
            return AREACODE_REQUIRED;

        //
        // Area code is not needed in this country
        //

        if (_tcschr(pEntry->lpctstrLongDistanceRule, TEXT('I')) == NULL)
            return AREACODE_DONTNEED;
    }

    //
    // Default case: area code is optional in this country
    //

    return AREACODE_OPTIONAL;
}



VOID
AssemblePhoneNumber(
    LPTSTR  pAddress,
    DWORD   countryCode,
    LPTSTR  pAreaCode,
    LPTSTR  pPhoneNumber
    )

/*++

Routine Description:

    Assemble a canonical phone number given the following:
        country code, area code, and phone number

Arguments:

    pAddress - Specifies a buffer to hold the resulting fax address
    countryCode - Specifies the country code
    pAreaCode - Specifies the area code string
    pPhoneNumber - Specifies the phone number string

Return Value:

    NONE

Note:

    We assume the caller has allocated a large enough destination buffer.

--*/

{
    //
    // Country code if neccessary
    //

    if (countryCode != 0) {

        *pAddress++ = TEXT('+');
        wsprintf(pAddress, TEXT("%d "), countryCode);
        pAddress += _tcslen(pAddress);
    }

    //
    // Area code if necessary
    //

    if (pAreaCode && !IsEmptyString(pAreaCode)) {

        if (countryCode != 0)
            *pAddress++ = TEXT('(');

        _tcscpy(pAddress, pAreaCode);
        pAddress += _tcslen(pAddress);

        if (countryCode != 0)
            *pAddress++ = TEXT(')');

        *pAddress++ = TEXT(' ');
    }

    //
    // Phone number at last
    //

    Assert(pPhoneNumber != NULL);
    _tcscpy(pAddress, pPhoneNumber);
}



VOID
UpdateAreaCodeField(
    HWND                        hwndAreaCode,
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       countryId
    )

/*++

Routine Description:

    Update any area code text field associated with a country list box

Arguments:

    hwndAreaCode - Specifies the text field associated with the country list box
    pCountryList - pointer to the country list
    countryId - Currently selected country ID

Return Value:

    NONE

--*/

{
    if (hwndAreaCode == NULL)
        return;

    if (AreaCodeRules(FindCountry(pCountryList,countryId)) == AREACODE_DONTNEED) {

        SendMessage(hwndAreaCode, WM_SETTEXT, 0, (LPARAM) TEXT(""));
        EnableWindow(hwndAreaCode, FALSE);

    } else
        EnableWindow(hwndAreaCode, TRUE);
}


VOID
InitCountryListBox(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    HWND                        hwndList,
    HWND                        hwndAreaCode,
    LPTSTR                      lptstrCountry,
    DWORD                       countryId,
    BOOL                        bAddCountryCode
    )

/*++

Routine Description:

    Initialize the country list box

Arguments:

    pCountryList - pointer to the country list
    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field
    lptstrCountry - Country that should be selected or NULL
    countryId - Initially selected country ID
    bAddCountryCode - if TRUE add a country code to a country name

Return Value:

    NONE

--*/

#define MAX_COUNTRY_NAME    256

{
    DWORD   dwIndex;
    TCHAR   buffer[MAX_COUNTRY_NAME];
    TCHAR   tszLocalCountryCode[16] = {0};
    TCHAR   tszLocalCityCode[16] = {0};
    HMODULE hTapi = NULL;

    typedef LONG (WINAPI *TAPI_GET_LOCATION_INFO)(LPTSTR, LPTSTR);
    TAPI_GET_LOCATION_INFO pfnTapiGetLocationInfo;

    if(0 == countryId)
    {
        //
        // if no country selected, select the local
        //
        hTapi = LoadLibrary(TEXT("tapi32.dll"));
        if(hTapi)
        {
#ifdef UNICODE
            pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfoW");
#else
            pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfoA");
            if(!pfnTapiGetLocationInfo)
            {
                pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfo");
            }
#endif
            if(pfnTapiGetLocationInfo)
            {
                if(0 == pfnTapiGetLocationInfo(tszLocalCountryCode, tszLocalCityCode))
                {
                    _stscanf(tszLocalCountryCode, TEXT("%u"), &countryId);
                }
            }
            else
            {
                Error(("tapiGetLocationInfo failed. ec = 0x%X\n",GetLastError()));
            }

            if(!FreeLibrary(hTapi))
            {
                Error(("FreeLibrary(tapi32.dll) failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            Error(("LoadLibrary(tapi32.dll) failed. ec = 0x%X\n",GetLastError()));
        }
    }

    //
    // Disable redraw on the list box and reset its content
    //
    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Loop through FAX_TAPI_LINECOUNTRY_ENTRY structures and add the available selections to
    // the country list box.
    //
    if (pCountryList) 
    {
        TCHAR szFormat[64] = { TEXT("%s (%d)") };
#ifdef UNICODE
        if(pCountryList->dwNumCountries && 
           IsWindowRTL(hwndList)        &&
           !StrHasRTLChar(LOCALE_SYSTEM_DEFAULT, pCountryList->LineCountryEntries[0].lpctstrCountryName))
        {
            //
            // The Combo Box has RTL layout
            // but the country name has not RTL characters.
            // So, we add LEFT-TO-RIGHT OVERRIDE UNICODE character.
            //
            _tcscpy(szFormat, TEXT("\x202D%s (%d)"));
        }
#endif

        for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) 
        {
            if (pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName) 
            {
                if(bAddCountryCode)
                {
                    wsprintf(buffer, 
                             szFormat,
                             pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName,
                             pCountryList->LineCountryEntries[dwIndex].dwCountryCode);
                }
                else
                {
                    wsprintf(buffer, TEXT("%s"),
                             pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName);
                }

                if (lptstrCountry && _tcsstr(buffer,lptstrCountry) && !countryId)   
                {
                    // search for a first occurence of lptstrCountry
                    countryId = pCountryList->LineCountryEntries[dwIndex].dwCountryID;
                }

                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer),
                            pCountryList->LineCountryEntries[dwIndex].dwCountryID);
            }
        }
    }
    //
    // Figure out which item in the list should be selected
    //
    if (pCountryList != NULL) 
    {
        for (dwIndex=0; dwIndex <= pCountryList->dwNumCountries; dwIndex++) 
        {
            if ((DWORD) SendMessage(hwndList, CB_GETITEMDATA, dwIndex, 0) == countryId)
                break;
        }

        if (dwIndex > pCountryList->dwNumCountries)
        {
            dwIndex = countryId = 0;
        }
    } 
    else    
    {
        dwIndex = countryId = 0;    
    }
    SendMessage(hwndList, CB_SETCURSEL, dwIndex, 0);
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    //
    // Update the associated area code text field
    //
    UpdateAreaCodeField(hwndAreaCode, pCountryList, countryId);
}


VOID
SelChangeCountryListBox(
    HWND                        hwndList,
    HWND                        hwndAreaCode,
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList
    )

/*++

Routine Description:

    Handle dialog selection changes in the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field
    pCountryList - pointer to the country list

Return Value:

    NONE

--*/

{
    UpdateAreaCodeField(hwndAreaCode, pCountryList, GetCountryListBoxSel(hwndList));
}



DWORD
GetCountryListBoxSel(
    HWND    hwndList
    )

/*++

Routine Description:

    Return the current selection of country list box

Arguments:

    hwndList - Handle to the country list box window

Return Value:

    Currently selected country ID

--*/

{
    INT msgResult;

    if ((msgResult = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR ||
        (msgResult = (INT)SendMessage(hwndList, CB_GETITEMDATA, msgResult, 0)) == CB_ERR)
    {
        return 0;
    }

    return msgResult;
}

BOOL
DoTapiProps(
    HWND hDlg
    )
{
    DWORD dwRes;

    dwRes = lineTranslateDialog(g_hLineApp, 
                                0,                  // Device ID
                                g_dwTapiVersion,
                                hDlg,
                                NULL);              // Address
    if(0 != dwRes)
    {
        Error(("lineTranslateDialog failed. ec = 0x%X\n", dwRes));
        return FALSE;
    }

    return TRUE;
}   // DoTapiProps

LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    )
/*++

Routine Description:

    Get a list of locations from TAPI

Arguments:

    NONE

Return Value:

    Pointer to a LINETRANSLATECAPS structure,
    NULL if there is an error

--*/

#define INITIAL_LINETRANSLATECAPS_SIZE  5000

{
    DWORD               cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;
    LONG                status;
    INT                 i;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;

    if (!g_hLineApp)
    {
        return NULL;
    }

    for (i = 0; i < 2; i++)
    {
        //
        // Free any existing buffer and allocate a new one with larger size
        //
        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = MemAlloc(cbNeeded))) 
        {
            Error(("Memory allocation failed\n"));
            return NULL;
        }
        //
        // Get the LINETRANSLATECAPS structure from TAPI
        //
        pTranslateCaps->dwTotalSize = cbNeeded;
        status = lineGetTranslateCaps(g_hLineApp, g_dwTapiVersion, pTranslateCaps);
        //
        // Try to bring up UI if there are no locations.
        // 
        if (LINEERR_INIFILECORRUPT == status) 
        {
            if (lineTranslateDialog( g_hLineApp, 0, g_dwTapiVersion, hWnd, NULL )) 
            { 
                MemFree(pTranslateCaps);
                return NULL;
            }
            continue;
        }
        if ((pTranslateCaps->dwNeededSize > pTranslateCaps->dwTotalSize) ||
            (LINEERR_STRUCTURETOOSMALL == status)                        ||
            (LINEERR_NOMEM == status))
        {
            //
            // Retry since our initial estimated buffer size was too small
            //
            if (cbNeeded >= pTranslateCaps->dwNeededSize)
            {
                cbNeeded = cbNeeded * 5;
            }
            else
            {
                cbNeeded = pTranslateCaps->dwNeededSize;
            }
            Warning(("LINETRANSLATECAPS resized to: %d\n", cbNeeded));
        }
        else 
        {
            //
            // Either success of real error - break now and let the code after the loop handle it.
            //
            break;
        }
    }

    if (NO_ERROR != status) 
    {
        Error(("lineGetTranslateCaps failed: %x\n", status));
        MemFree(pTranslateCaps);
        SetLastError (status);
        pTranslateCaps = NULL;
    }
    if (pTranslateCaps)
    {
        //
        // Update the current default dialing location.
        // We save it here and restore it when the wizard exists in ShutdownTapi().
        //
        g_dwDefaultDialingLocation = pTranslateCaps->dwCurrentLocationID;
    }
    return pTranslateCaps;
}   // GetTapiLocationInfo


BOOL
SetCurrentLocation(
    DWORD   locationID
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    locationID - The permanant ID for the new default TAPI location

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LONG lResult;

    Assert (g_hLineApp);
    if (!g_hLineApp)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    lResult = lineSetCurrentLocation(g_hLineApp, locationID);
    if (NO_ERROR == lResult)
    {
        Verbose(("Current location changed: ID = %d\n", locationID));
        return TRUE;
    } 
    else 
    {
        Error(("Couldn't change current TAPI location\n"));
        SetLastError (lResult);
        return FALSE;
    }
}   // SetCurrentLocation


BOOL
TranslateAddress (
    LPCTSTR lpctstrCanonicalAddress,
    DWORD   dwLocationId,
    LPTSTR *lpptstrDialableAndDisplayableAddress
)
/*++

Routine name : TranslateAddress

Routine description:

    Translates a canonical address

Author:

    Eran Yariv (EranY), Feb, 2001

Arguments:

    lpctstrCanonicalAddress               [in]     - Canonical address string
    dwLocationId                          [in]     - Location id to use
    lpptstrDialableAndDisplayableAddress  [out]    - Allocated string holding a combination of translated 
                                                     dialable and displayable addresses

Return Value:

    TRUE if successful, FALSE otherwise (sets last error0.

--*/
{
    DWORD                   dwLineTransOutSize = sizeof(LINETRANSLATEOUTPUT) + 4096;
    LPLINETRANSLATEOUTPUT   lpTranslateOutput = NULL;
    LONG                    lRslt = ERROR_SUCCESS;
    DWORD                   dwRes;
    LPTSTR                  lptstrTranslatedDialableString;    
    LPTSTR                  lptstrTranslatedDisplayableString;
    DWORD                   dwTranslatedStringsSize;
    BOOL                    bCanonicCheck;

    dwRes = IsCanonicalAddress(lpctstrCanonicalAddress, &bCanonicCheck, NULL, NULL, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    Assert (bCanonicCheck);
    if (!bCanonicCheck)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    Assert (g_hLineApp);
    if (!g_hLineApp)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    if (!SetCurrentLocation(dwLocationId))
    {
        return FALSE;
    }

    lpTranslateOutput = MemAlloc (dwLineTransOutSize);
    if (!lpTranslateOutput)
    {
        Error(("Couldn't allocate translation results buffer\n"));
        return FALSE;
    }
    lpTranslateOutput->dwTotalSize = dwLineTransOutSize;
    lRslt = lineTranslateAddress(
        g_hLineApp,
        0,
        g_dwTapiVersion,
        lpctstrCanonicalAddress,
        0,
        0,
        lpTranslateOutput
        );
    if ((lpTranslateOutput->dwNeededSize > lpTranslateOutput->dwTotalSize) ||
        (LINEERR_STRUCTURETOOSMALL == lRslt)                               ||
        (LINEERR_NOMEM == lRslt))
    {
        //
        // Retry since our initial estimated buffer size was too small
        //
        if (dwLineTransOutSize >= lpTranslateOutput->dwNeededSize)
        {
            dwLineTransOutSize = dwLineTransOutSize * 5;
        }
        else
        {
            dwLineTransOutSize = lpTranslateOutput->dwNeededSize;
        }
        //
        // Re-allocate the LineTransCaps structure
        //
        dwLineTransOutSize = lpTranslateOutput->dwNeededSize;

        MemFree(lpTranslateOutput);

        lpTranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc(dwLineTransOutSize);
        if (!dwLineTransOutSize)
        {
            Error(("Couldn't allocate translation results buffer\n"));
            return FALSE;
        }

        lpTranslateOutput->dwTotalSize = dwLineTransOutSize;

        lRslt = lineTranslateAddress(
            g_hLineApp,
            0,
            g_dwTapiVersion,
            lpctstrCanonicalAddress,
            0,
            0,
            lpTranslateOutput
            );
        
    }
    if (ERROR_SUCCESS != lRslt)
    {
        //
        // Other error
        //
        Error(("lineGetTranslateAddress() failed, ec=0x%08x\n", lRslt));
        MemFree (lpTranslateOutput);
        SetLastError (lRslt);
        return FALSE;
    }
    //
    // We now hold the valid translated address in lpTranslateOutput
    //

    //
    // Calc required buffer size to hold combined strings.    
    //
    if (CurrentLocationUsesCallingCard ())
    {
        //
        // Calling card is used.
        // TAPI returns credit card numbers in the displayable string.
        // return the input canonical number as the displayable string.
        //      
        lptstrTranslatedDisplayableString = (LPTSTR)lpctstrCanonicalAddress;
    }
    else
    {
        //
        // Calling card isn't used - use displayable string as is.
        //
        Assert (lpTranslateOutput->dwDisplayableStringSize > 0);
        lptstrTranslatedDisplayableString = (LPTSTR)((LPBYTE)lpTranslateOutput + lpTranslateOutput->dwDisplayableStringOffset);
    }

    dwTranslatedStringsSize = _tcslen (lptstrTranslatedDisplayableString);
    Assert (lpTranslateOutput->dwDialableStringSize > 0);
    lptstrTranslatedDialableString = (LPTSTR)((LPBYTE)lpTranslateOutput + lpTranslateOutput->dwDialableStringOffset);
    dwTranslatedStringsSize += _tcslen (lptstrTranslatedDialableString);
    //
    // Add NULL + Formatting extra length
    //
    dwTranslatedStringsSize += COMBINED_TRANSLATED_STRING_EXTRA_LEN + 1;
    //
    // Allocate return buffer
    //
    *lpptstrDialableAndDisplayableAddress = (LPTSTR)MemAlloc (dwTranslatedStringsSize * sizeof (TCHAR));
    if (!*lpptstrDialableAndDisplayableAddress)
    {
        MemFree (lpTranslateOutput);
        Error(("Couldn't allocate translation results buffer\n"));
        return FALSE;
    }
    _stprintf (*lpptstrDialableAndDisplayableAddress,
               COMBINED_TRANSLATED_STRING_FORMAT,
               lptstrTranslatedDialableString,
               lptstrTranslatedDisplayableString);
    MemFree (lpTranslateOutput);
    return TRUE;
}   // TranslateAddress

BOOL
CurrentLocationUsesCallingCard ()
{
    LPLINETRANSLATECAPS pTranslateCaps = GetTapiLocationInfo (NULL);
    DWORD dwIndex;
    BOOL  bRes = TRUE;
    LPLINELOCATIONENTRY pLocationEntry = NULL;

    if (!pTranslateCaps)
    {
        return TRUE;
    }

    //
    // Find current location
    //
    pLocationEntry = (LPLINELOCATIONENTRY)
        ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);
    for (dwIndex = 0; dwIndex < pTranslateCaps->dwNumLocations; dwIndex++)
    {
        if (pLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID)
        {
            //
            // We found the current calling location
            // Let's see if it uses calling cards.
            //
            if (pLocationEntry->dwPreferredCardID)
            {
                bRes = TRUE;
                goto exit;
            }
            else
            {
                //
                // Not using calling card
                //
                bRes = FALSE;
                goto exit;
            }
        }
        pLocationEntry++;
    }
exit:
    MemFree (pTranslateCaps);
    return bRes;
}   // CurrentLocationUsesCallingCard
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\cl2and20\cl2spec.h ===
#define STARTSENDMODE_TIMEOUT 40000L     // Sending Timeout needs to be pretty long!!!
#define LOCALCOMMAND_TIMEOUT  6000L    // for commands sent to modem  but not when connected
#define ANS_LOCALCOMMAND_TIMEOUT  1000L    // for commands sent to modem when answering (during ringing)

#define         CLASS2_BAUDRATE         19200
#define         NUMBER_OF_DIS_VALUES    8
#define         NUMBER_OF_DCS_VALUES    8
#define         MORE_PAGES              10
#define         NO_MORE_PAGES           20

// Note this comes from icomfile.h!!!!
#define         MAXUSERATCMDLEN         80



//  Class 2 DCE Response Codes.
#define CL2DCE_CONNECT          1
#define CL2DCE_OK               2
#define CL2DCE_XON              3
#define CL2DCE_FDCS             4
#define CL2DCE_FDIS             5
#define CL2DCE_FDTC             6
#define CL2DCE_FPOLL            7
#define CL2DCE_FCFR             8
#define CL2DCE_FTSI             9
#define CL2DCE_FCSI             10
#define CL2DCE_FCIG             11
#define CL2DCE_FNSF             12
#define CL2DCE_FNSS             13
#define CL2DCE_FNSC             14
#define CL2DCE_FHT              15
#define CL2DCE_FHR              16
#define CL2DCE_FCON             17
#define CL2DCE_FVOICE           18
#define CL2DCE_FET              19
#define CL2DCE_FPTS             20
#define CL2DCE_FHNG             21
#define CL2DCE_FDM              22


#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03


BOOL ParseFPTS_SendAck(PThrdGlbl pTG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\sendnote\sendnote.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendnote.h

Abstract:

    Send fax utility header file

Environment:

    Window NT fax driver

Revision History:

    02/15/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _SENDNOTE_H_
#define _SENDNOTE_H_

//
// String resource IDs
//

#define IDS_NO_FAX_PRINTER      256
#define IDS_FAX_ACCESS_FAILED   257
#define IDS_SENDNOTE            258
#define IDS_PRINTER_OFFLINE     259

//
// Icon resource IDs
//

#define IDI_FAX_NOTE            256

//
// Dialog resource IDs
//

#define IDD_SELECT_FAXPRINTER   100
#define IDC_STATIC              -1
#define IDC_FAXPRINTER_LIST     1000

#endif // !_SENDNOTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\sendnote\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\..\faxsrc.inc

TARGETNAME=$(FAXSEND)
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_CRTDLL=1
NTKEEPRESOURCETMPFILES=1
UMTYPE=windows

!ifdef NOUNICODE
UMENTRY=winmain
!else
UMENTRY=wwinmain
!endif

INCLUDES=$(INCLUDES);..\..\inc

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
    ..\..\lib\umwinnt\$O\faxlib.lib	\
!else
NO_NTDLL=1
LINKLIBS_INT=\
    ..\..\lib\umwin95\$O\faxlib.lib	\
!endif

LINKLIBS=$(LINKLIBS)\
    $(BASEDIR)\public\sdk\lib\*\winspool.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib   \
    $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib    \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib    \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib     \
    $(BASEDIR)\public\sdk\lib\*\shell32.lib  \
    $(LINKLIBS_INT)

SOURCES=\
    ..\sendnote.c  \
    ..\sendnote.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\sendnote\sendnote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendnote.c

Abstract:

    Utility program to send fax notes

Environment:

        Windows XP fax driver

Revision History:

        02/15/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <faxuiconstants.h>
#include "..\..\..\admin\cfgwzrd\FaxCfgWzExp.h"
#include <faxutil.h>
#include "sendnote.h"
#include "tiff.h"
#include "faxreg.h"

VOID
DisplayErrorMessage(
    INT     errId
    );

//
// Data structure used to pass parameters to "Select Fax Printer" dialog
//

typedef struct 
{
    LPTSTR          pPrinterName;
    INT             cPrinters;
    INT             iSelectedPrinterIndex;
    PRINTER_INFO_2 *pPrinterInfo2;

} DLGPARAM, *PDLGPARAM;

//
// Global instance handle
//

HMODULE ghInstance = NULL;
INT     _debugLevel = 0;

//
// Maximum length of message strings
//
#define MAX_MESSAGE_LEN     256

//
// Maximum length for a printer name
//
#define MAX_PRINTER_NAME    MAX_PATH

//
// Window NT fax driver name - currently printer driver name cannot be localized
// so it shouldn't be put into the string resource.
//
static TCHAR faxDriverName[] = FAX_DRIVER_NAME;


VOID
InitSelectFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )
/*++

Routine Description:

    Initialize the "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    NONE

--*/
{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Insert all fax printers into a listbox. Note that we've already filtered
    // out non-fax printers earlier by setting their pDriverName field to NULL.
    //

    if (!(hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)))
    {
        return;
    }
    for (printerIndex=0; printerIndex < pDlgParam->cPrinters; printerIndex++) 
    {
        if (pDlgParam->pPrinterInfo2[printerIndex].pDriverName) 
        {
            selIndex = (INT)SendMessage(hwndList,
                                        LB_ADDSTRING,
                                        0,
                                        (LPARAM) pDlgParam->pPrinterInfo2[printerIndex].pPrinterName);

            if (selIndex != LB_ERR) 
            {
                if (SendMessage(hwndList, LB_SETITEMDATA, selIndex, printerIndex) == LB_ERR)
                {
                    SendMessage(hwndList, LB_DELETESTRING, selIndex, 0);
                }
            }
        }
    }
    //
    // Select the first fax printer in the list by default
    //
    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
}


BOOL
GetSelectedFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )
/*++

Routine Description:

    Remember the name of currently selected fax printer

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Get current selection index
    //
    if ((hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)) == NULL ||
        (selIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
    {
        return FALSE;
    }
    //
    // Retrieve the selected printer index
    //
    printerIndex = (INT)SendMessage(hwndList, LB_GETITEMDATA, selIndex, 0);
    if (printerIndex < 0 || printerIndex >= pDlgParam->cPrinters)
    {
        return FALSE;
    }
    //
    // Remember the selected fax printer name
    //
    _tcsncpy(pDlgParam->pPrinterName,
             pDlgParam->pPrinterInfo2[printerIndex].pPrinterName,
             MAX_PRINTER_NAME);
    pDlgParam->iSelectedPrinterIndex = printerIndex;
    return TRUE;
}


VOID
CenterWindowOnScreen(
    HWND    hwnd
    )
/*++

Routine Description:

    Place the specified windows in the center of the screen

Arguments:

    hwnd - Specifies a window to be centered

Return Value:

    NONE

--*/
{
    HWND    hwndDesktop;
    RECT    windowRect, screenRect;
    INT     windowWidth, windowHeight, screenWidth, screenHeight;

    //
    // Get screen dimension
    //
    hwndDesktop = GetDesktopWindow();
    GetWindowRect(hwndDesktop, &screenRect);
    screenWidth = screenRect.right - screenRect.left;
    screenHeight = screenRect.bottom - screenRect.top;
    //
    // Get window position
    //
    GetWindowRect(hwnd, &windowRect);
    windowWidth = windowRect.right - windowRect.left;
    windowHeight = windowRect.bottom - windowRect.top;
    //
    // Center the window on screen
    //
    MoveWindow(hwnd,
               screenRect.left + (screenWidth - windowWidth) / 2,
               screenRect.top + (screenHeight - windowHeight) / 2,
               windowWidth,
               windowHeight,
               FALSE);
}


INT_PTR CALLBACK
SelectPrinterDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   )
/*++

Routine Description:

    Dialog procedure for handling "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the dialog window
    uMsg, wParam, lParam - Dialog message and message parameters

Return Value:

    Depends on dialog message

--*/
{
    PDLGPARAM   pDlgParam;

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        //
        // Remember the pointer to DLGPARAM structure
        //

        pDlgParam = (PDLGPARAM) lParam;
        Assert(pDlgParam != NULL);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        CenterWindowOnScreen(hDlg);
        InitSelectFaxPrinter(hDlg, pDlgParam);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDC_FAXPRINTER_LIST:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
            {
                break;
            }
            //
            // Fall through - double-clicking in the fax printer list
            // is treated the same as clicking OK button
            //

        case IDOK:

            //
            // User pressed OK to proceed
            //
            pDlgParam = (PDLGPARAM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pDlgParam != NULL);

            if (GetSelectedFaxPrinter(hDlg, pDlgParam))
            {
                LPTSTR lptstrServerName = pDlgParam->pPrinterInfo2[pDlgParam->iSelectedPrinterIndex].pServerName;
                if (lptstrServerName &&                                     // Server name exists and
                    _tcslen(lptstrServerName) > 0 &&                        // not empty (remote printer) and
                    !VerifyPrinterIsOnline (pDlgParam->pPrinterName))       // printer is inaccessible.
                {
                    DisplayErrorMessage(IDS_PRINTER_OFFLINE);
                }
                else
                {
                    // 
                    // All is ok
                    //
                    EndDialog (hDlg, IDOK);
                }
            }
            else
            {
                MessageBeep(MB_OK);
            }
            return TRUE;

        case IDCANCEL:

            //
            // User pressed Cancel to dismiss the dialog
            //
            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
        return TRUE;

    }
    return FALSE;
}


VOID
DisplayErrorMessage(
    INT     errId
    )
/*++

Routine Description:

    Display an error message dialog

Arguments:

    errId - Specifies the resource ID of the error message string

Return Value:

    NONE

--*/
{
    TCHAR   errMsg[MAX_MESSAGE_LEN];
    TCHAR   errTitle[MAX_MESSAGE_LEN];

    DEBUG_FUNCTION_NAME(TEXT("DisplayErrorMessage"));

    if(!LoadString(ghInstance, errId, errMsg, MAX_MESSAGE_LEN))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadString failed. ec = 0x%X"), GetLastError());
        return;
    }

    if(!LoadString(ghInstance, IDS_SENDNOTE, errTitle, MAX_MESSAGE_LEN))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadString failed. ec = 0x%X"), GetLastError());
        return;
    }    
    AlignedMessageBox(NULL, errMsg, errTitle, MB_OK | MB_ICONERROR);
}


BOOL
SelectFaxPrinter(
    LPTSTR      pPrinterName
    )
/*++

Routine Description:

    Select a fax printer to send note to

Arguments:

    pPrinterName - Points to a buffer for storing selected printer name

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PRINTER_INFO_2 *pPrinterInfo2;
    DWORD           index, cPrinters, cFaxPrinters;
    DLGPARAM        dlgParam;

    //
    // Enumerate the list of printers available on the system
    //

    pPrinterInfo2 = (PPRINTER_INFO_2) MyEnumPrinters(
        NULL,
        2,
        &cPrinters,
        PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
        );

    if (pPrinterInfo2 == NULL || cPrinters == 0) 
    {

        MemFree(pPrinterInfo2);
        DisplayErrorMessage(IDS_NO_FAX_PRINTER);
        return FALSE;
    }
    //
    // Find out how many fax printers there are:
    //  case 1: no fax printer at all - display an error message
    //  case 2: only one fax printer - use it
    //  case 3: more than one fax printer - display a dialog to let user choose one
    //
    cFaxPrinters = 0;

    for (index=0; index < cPrinters; index++) 
    {
        if (_tcscmp(pPrinterInfo2[index].pDriverName, faxDriverName) != EQUAL_STRING)
        {
            pPrinterInfo2[index].pDriverName = NULL;
        }
        else if (cFaxPrinters++ == 0)
        {
            _tcsncpy(pPrinterName, pPrinterInfo2[index].pPrinterName, MAX_PRINTER_NAME);
        }
    }

    switch (cFaxPrinters) 
    {
    case 0:
        //
        // No fax printer is installed - display an error message
        //
        DisplayErrorMessage(IDS_NO_FAX_PRINTER);
        break;

    case 1:
        //
        // Exactly one fax printer is installed - use it
        //
        break;

    default:
        //
        // More than one fax printer is available - let use choose one
        //
        dlgParam.pPrinterInfo2 = pPrinterInfo2;
        dlgParam.cPrinters = cPrinters;
        dlgParam.pPrinterName = pPrinterName;

        if (DialogBoxParam(ghInstance,
                           MAKEINTRESOURCE(IDD_SELECT_FAXPRINTER),
                           NULL,
                           SelectPrinterDlgProc,
                           (LPARAM) &dlgParam) != IDOK)
        {
            cFaxPrinters = 0;
        }
        break;
    }

    pPrinterName[MAX_PRINTER_NAME-1] = NUL;
    MemFree(pPrinterInfo2);
    return cFaxPrinters > 0;
}

BOOL 
LaunchConfigWizard(
    BOOL bExplicit
)
/*++

Routine name : LaunchConfigWizard

Routine description:

    launch Fax Configuration Wizard for Windows XP platform only

Arguments:

    bExplicit     [in] - TRUE if it's an explicit launch

Return Value:

    TRUE if the send wizard should continue.
    If FALSE, the user failed to set a dialing location and the client console should quit.

--*/
{
    HMODULE hConfigWizModule = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LaunchConfigWizard"));

    if(!IsWinXPOS())
    {
        return TRUE;
    }

    hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        FAX_CONFIG_WIZARD fpFaxConfigWiz;
        BOOL bAbort = FALSE;
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, 
                                                           FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(bExplicit, &bAbort))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxConfigWizard() failed with %ld"),
                    GetLastError());
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetProcAddress(FaxConfigWizard) failed with %ld"),
                GetLastError());
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreeLibrary(FxsCgfWz.dll) failed with %ld"),
                GetLastError());
        }
        if (bAbort)
        {
            //
            // User refused to enter a dialing location - stop the client console.
            //
            return FALSE;
        }
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadLibrary(FxsCgfWz.dll) failed with %ld"),
            GetLastError());
    }
    return TRUE;
}   // LaunchConfigWizard    


#ifdef UNICODE
INT
wWinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )
#else
INT
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )
#endif
/*++

Routine Description:

    Application entry point

Arguments:

    hInstance - Identifies the current instance of the application
    hPrevInstance - Identifies the previous instance of the application
    lpCmdLine - Specifies the command line for the application.
    nCmdShow - Specifies how the window is to be shown

Return Value:

    0

--*/
{
    TCHAR       printerName[MAX_PRINTER_NAME];
    HDC         hdc;
    TCHAR       sendNote[100];
    DOCINFO     docInfo = 
    {
        sizeof(DOCINFO),
        NULL,
        NULL,
        NULL,
        0,
    };

    DEBUG_FUNCTION_NAME(TEXT("WinMain"));

    InitCommonControls ();
    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        if(!SetProcessDefaultLayout(LAYOUT_RTL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetProcessDefaultLayout failed with %ld"),
                GetLastError());
        }
    }

    //
    // Implicit launch of fax configuration wizard
    //
    if (!LaunchConfigWizard(FALSE))
    {
        //
        // User refused to enter a dialing location - stop the client console.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("User refused to enter a dialing location - stop now"));
        return 0;
    }

    ghInstance = hInstance;
    sendNote[0] = TEXT(' ');
    LoadString( ghInstance, IDS_SENDNOTE, sendNote, sizeof(sendNote)/sizeof(sendNote[0]));
    docInfo.lpszDocName = sendNote ;
    //
    // Check if a printer name is specified on the command line
    //
    ZeroMemory(printerName, sizeof(printerName));

    if (lpCmdLine) 
    {
        _tcsncpy(printerName, lpCmdLine, MAX_PRINTER_NAME);
        printerName[MAX_PRINTER_NAME-1] = NUL;
    }
    //
    // Select a fax printer to send note to if necessary
    //
    if (IsEmptyString(printerName) && !SelectFaxPrinter(printerName))
    {
        return 0;
    }
    DebugPrintEx(DEBUG_MSG, TEXT("Send note to fax printer: %ws"), printerName);
    //
    // Set an environment variable so that the driver knows
    // the current application is "Send Note" utility.
    //
    SetEnvironmentVariable(TEXT("NTFaxSendNote"), TEXT("1"));
    //
    // Create a printer DC and print an empty job
    //
    if (! (hdc = CreateDC(NULL, printerName, NULL, NULL))) 
    {
        DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
    } 
    else 
    {
        if (StartDoc(hdc, &docInfo) > 0) 
        {
            if(EndDoc(hdc) <= 0)
            {
                DebugPrintEx(DEBUG_ERR, TEXT("EndDoc failed. ec = 0x%X"), GetLastError());
                DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
            }
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("StartDoc failed. ec = 0x%X"), GetLastError());
            DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
        }
        DeleteDC(hdc);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\prnwzrd\wizard.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Send fax wizard dialogs

Environment:

    Fax driver user interface

Revision History:

    01/19/96 -davidx-
        Created it.

    08/99 - 11/99 -v-sashab-
        Ported to ANSI.
        Changed UI.
        Added external interface for drivers.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include "tapiutil.h"
#include "Registry.h"
#include <fxsapip.h>
#include "prtcovpg.h"
#include "tiff.h"
#include "cwabutil.h"
#include "mapiabutil.h"
#include  <shellapi.h>
#include  <imm.h>
#include "faxutil.h"
#include "faxsendw.h"
#include "shlwapi.h"
#include <MAPI.H>
#include <tifflib.h>
#include <faxuiconstants.h>

#include "..\..\..\admin\cfgwzrd\FaxCfgWzExp.h"

#define USE_LOCAL_SERVER_OUTBOUND_ROUTING       0xfffffffe

#define PACKVERSION(major,minor) MAKELONG(minor,major)
#define IE50_COMCTRL_VER PACKVERSION(5,80)

DWORD GetDllVersion(LPCTSTR lpszDllName);


enum {  DEFAULT_INITIAL_DATA     = 1,
        DEFAULT_RECEIPT_INFO     = 2,
        DEFAULT_RECIPIENT_INFO   = 4,
        DEFAULT_CV_INFO          = 8,
        DEFAULT_SENDER_INFO      = 16
     };

#define REGVAL_FAKE_COVERPAGE       TEXT("FakeCoverPage")
#define REGVAL_FAKE_TESTS_COUNT     TEXT("FakeTestsCount")
#define REGVAL_KEY_FAKE_TESTS       REGKEY_FAX_USERINFO TEXT("\\WzrdHack")

//
// Globals
//

PWIZARDUSERMEM  g_pWizardUserMem;
HWND            g_hwndPreview = NULL;

static DWORD    g_dwCurrentDialingLocation = USE_LOCAL_SERVER_OUTBOUND_ROUTING;
static DWORD    g_dwMiniPreviewLandscapeWidth;
static DWORD    g_dwMiniPreviewLandscapeHeight;
static DWORD    g_dwMiniPreviewPortraitWidth;
static DWORD    g_dwMiniPreviewPortraitHeight;
static WORD     g_wCurrMiniPreviewOrientation;
static BOOL     g_bPreviewRTL = FALSE;


BOOL FillCoverPageFields(PWIZARDUSERMEM pWizardUserMem, PCOVERPAGEFIELDS pCPFields);

BOOL
ErrorMessageBox(
    HWND hwndParent,
    UINT nErrorMessage,
    UINT uIcon
    );

BOOL
DisplayFaxPreview(
            HWND hWnd,
            PWIZARDUSERMEM pWizardUserMem,
            LPTSTR lptstrPreviewFile);

LRESULT APIENTRY PreviewSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL DrawCoverPagePreview(
            HDC hdc,
            HWND hwndPrev,
            LPCTSTR lpctstrCoverPagePath,
            WORD wCPOrientation);

BOOL EnableCoverDlgItems(PWIZARDUSERMEM pWizardUserMem, HWND hDlg);

BOOL IsCanonicalNumber(LPCTSTR lptstrNumber);

static BOOL IsNTSystemVersion();
static BOOL GetTextualSid( const PSID pSid, LPTSTR tstrTextualSid, LPDWORD cchSidSize);
static DWORD FormatCurrentUserKeyPath( const PTCHAR tstrRegRoot,
                                       PTCHAR* ptstrCurrentUserKeyPath);

DWORD GetControlRect(HWND  hCtrl, PRECT pRc);

INT_PTR
CALLBACK
FaxUserInfoProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );


static HRESULT
FreeRecipientInfo(
        DWORD * pdwNumberOfRecipients,
        PFAX_PERSONAL_PROFILE lpRecipientsInfo
    )
/*++

Routine Description:

    Frees array of recipients.

Arguments:

    pdwNumberOfRecipients - number of recipients in array [IN/OUT]
    lpRecipientsInfo - pointer to array of recipients

Return Value:

    S_OK    - if success
    HRESULT error otherwise

--*/
{
    HRESULT hResult;
    DWORD i;

    Assert(pdwNumberOfRecipients);

    if (*pdwNumberOfRecipients==0)
        return S_OK;

    Assert(lpRecipientsInfo);

    for(i=0;i<*pdwNumberOfRecipients;i++)
    {
        if (hResult = FaxFreePersonalProfileInformation(&lpRecipientsInfo[i]) != S_OK)
            return hResult;
    }

    MemFree(lpRecipientsInfo);

    *pdwNumberOfRecipients = 0;

    return S_OK;
}

VOID
FillInPropertyPage(
    PROPSHEETPAGE  *psp,
    BOOL             bWizard97,
    INT             dlgId,
    DLGPROC         dlgProc,
    PWIZARDUSERMEM  pWizardUserMem,
    INT             TitleId,
    INT             SubTitleId
    )

/*++

Routine Description:

    Fill out a PROPSHEETPAGE structure with the supplied parameters

Arguments:

    psp - Points to the PROPSHEETPAGE structure to be filled out
    dlgId - Dialog template resource ID
    dlgProc - Dialog procedure
    pWizardUserMem - Pointer to the user mode memory structure
    TitleId - resource id for wizard subtitle
    SubTitleId - resource id for wizard subtitle

Return Value:

    NONE

--*/

{

    LPTSTR WizardTitle = NULL;
    LPTSTR WizardSubTitle = NULL;


    Assert(psp);
    Assert(pWizardUserMem);

    Verbose(("FillInPropertyPage %d 0x%x\n",dlgId , pWizardUserMem));

    psp->dwSize = sizeof(PROPSHEETPAGE);
    //
    // Don't show titles if it's the first or last page
    //
    if (bWizard97)
    {
        if (TitleId==0 && SubTitleId ==0) {
            psp->dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
        } else {
            psp->dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        }
    }
    else
    {
       psp->dwFlags = PSP_DEFAULT ;
    }


    psp->hInstance = ghInstance;
    psp->pszTemplate = MAKEINTRESOURCE(dlgId);
    psp->pfnDlgProc = dlgProc;
    psp->lParam = (LPARAM) pWizardUserMem;

    if (bWizard97)
    {
        if (TitleId)
        {
            WizardTitle = MemAlloc(MAX_PATH * sizeof(TCHAR) );
            if(WizardTitle)
            {
                if (!LoadString(ghInstance, TitleId, WizardTitle, MAX_PATH))
                {
                    Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                    WizardTitle[0] = 0;
                }
            }
            else
            {
                Error(("MemAlloc failed."));
            }
        }
        if (SubTitleId)
        {
            WizardSubTitle = MemAlloc(MAX_PATH * sizeof(TCHAR));
            if(WizardSubTitle)
            {
                if (!LoadString(ghInstance, SubTitleId, WizardSubTitle, MAX_PATH))
                {
                    Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                    WizardSubTitle[0] = 0;
                }
            }
            else
            {
                Error(("MemAlloc failed."));
            }
        }

        psp->pszHeaderTitle = WizardTitle;
        psp->pszHeaderSubTitle = WizardSubTitle;
    }

}



LPTSTR
GetTextStringValue(
    HWND    hwnd
    )

/*++

Routine Description:

    Retrieve the string value in a text field

Arguments:

    hwnd - Handle to a text window

Return Value:

    Pointer to a string representing the current content of the text field
    NULL if the text field is empty or if there is an error

--*/

{
    INT     length;
    LPTSTR  pString;

    //
    // Find out how many characters are in the text field
    // and allocate enough memory to hold the string value
    //

    if ((length = GetWindowTextLength(hwnd)) == 0 ||
        (pString = MemAlloc(sizeof(TCHAR) * (length + 1))) == NULL)
    {
        return NULL;
    }

    //
    // Actually retrieve the string value
    //

    if (GetWindowText(hwnd, pString, length + 1) == 0) {

        MemFree(pString);
        return NULL;
    }

    return pString;
}



VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}


PWIZARDUSERMEM
CommonWizardProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    DWORD   buttonFlags
    )

/*++

Routine Description:

    Common procedure for handling wizard pages:

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information
    buttonFlags - Indicate which buttons should be enabled

Return Value:

    NULL - Message is processed and the dialog procedure should return FALSE
    Otherwise - Message is not completely processed and
        The return value is a pointer to the user mode memory structure

--*/

{
    PWIZARDUSERMEM    pWizardUserMem;

    pWizardUserMem = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            //
            // Store the pointer to user mode memory structure
            //
            lParam = ((PROPSHEETPAGE *) lParam)->lParam;
            pWizardUserMem = (PWIZARDUSERMEM) lParam;
            Verbose(("CommonWizardProc 0x%x 0x%x\n",pWizardUserMem , pWizardUserMem->signature));

            Assert(ValidPDEVWizardUserMem(pWizardUserMem));
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            //
            // Make the title text bold
            //
            if (pWizardUserMem->dwComCtrlVer < IE50_COMCTRL_VER)
            {
                HWND hwndTitle;

                hwndTitle = GetDlgItem(hDlg,IDC_STATIC_HEADER_TITLE);
                if (hwndTitle)
                {
                    SendMessage(hwndTitle,WM_SETFONT,(WPARAM)pWizardUserMem->hTitleFont ,MAKELPARAM((DWORD)FALSE,0));
                }

            }

            break;

        case WM_NOTIFY:

            pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
            Verbose(("CommonWizardProc 0x%x 0x%x\n",pWizardUserMem , pWizardUserMem->signature));
            Assert(ValidPDEVWizardUserMem(pWizardUserMem));

            switch (((NMHDR *) lParam)->code)
            {
                case PSN_WIZFINISH:
                    pWizardUserMem->finishPressed = TRUE;
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), buttonFlags);
                    break;

                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                case PSN_KILLACTIVE:
                case LVN_KEYDOWN:
                case LVN_ITEMCHANGED:
                case NM_RCLICK:
                    break;

                default:
                    return NULL;
            }
            break;

        //
        // We wish all dialogs to recieve and handle the following commands:
        //
        case WM_DESTROY:
        case WM_COMMAND:
        case WM_CONTEXTMENU:
            pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidPDEVWizardUserMem(pWizardUserMem));
            break;

        default:
            return NULL;
    }
    return pWizardUserMem;
}   // CommonWizardProc

INT
GetCurrentRecipient(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PRECIPIENT      *ppRecipient
    )

/*++

Routine Description:

    Extract the current recipient information in the dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure
    ppRecipient - Buffer to receive a pointer to a newly created RECIPIENT structure
        NULL if caller is only interested in the validity of recipient info

Return Value:

    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList = NULL;
    PFAX_TAPI_LINECOUNTRY_ENTRY pLineCountryEntry = NULL;
    DWORD                       countryId=0, countryCode=0;
    PRECIPIENT                  pRecipient = NULL;
    TCHAR                       areaCode[MAX_RECIPIENT_NUMBER];
    TCHAR                       phoneNumber[MAX_RECIPIENT_NUMBER];
    INT                         nameLen=0, areaCodeLen=0, numberLen=0;
    LPTSTR                      pName = NULL, pAddress = NULL;
    BOOL                        bUseDialingRules = FALSE;

    Assert(pWizardUserMem);

    pCountryList = pWizardUserMem->pCountryList;
    bUseDialingRules = pWizardUserMem->lpFaxSendWizardData->bUseDialingRules;

    //
    // Default value in case of error
    //
    if (ppRecipient)
    {
        *ppRecipient = NULL;
    }

    //
    // Find the current country code
    //
    if(bUseDialingRules)
    {
        countryId = GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO));

        if (countryId && (pLineCountryEntry = FindCountry(pCountryList,countryId)))
        {
            countryCode = pLineCountryEntry->dwCountryCode;
        }

        areaCodeLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT));

        if ((areaCodeLen <= 0 && AreaCodeRules(pLineCountryEntry) == AREACODE_REQUIRED) ||
            (areaCodeLen >= MAX_RECIPIENT_NUMBER))
        {
            return IDS_BAD_RECIPIENT_AREACODE;
        }

        if (0 == countryId)
        {
            return IDS_BAD_RECIPIENT_COUNTRY_CODE;
        }
    }

    nameLen   = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));
    numberLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT));

    //
    // Validate the edit text fields
    //
    if (nameLen <= 0)
    {
        return IDS_BAD_RECIPIENT_NAME;
    }

    if (numberLen <= 0 || numberLen >= MAX_RECIPIENT_NUMBER)
    {
        return IDS_BAD_RECIPIENT_NUMBER;
    }

    if (NULL == ppRecipient)
    {
        return 0;
    }

    //
    // Calculate the amount of memory space we need and allocate it
    //
    pRecipient = MemAllocZ(sizeof(RECIPIENT));
    if(pRecipient)
    {
        ZeroMemory(pRecipient,sizeof(RECIPIENT));
    }
    pName = MemAllocZ((nameLen + 1) * sizeof(TCHAR));
    pAddress = MemAllocZ((areaCodeLen + numberLen + 20) * sizeof(TCHAR));

    if (!pRecipient || !pName || !pAddress)
    {
        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return -1;
    }

    *ppRecipient = pRecipient;
    pRecipient->pName = pName;
    pRecipient->pAddress = pAddress;
    pRecipient->dwCountryId = countryId;
    pRecipient->bUseDialingRules = bUseDialingRules;
    pRecipient->dwDialingRuleId = g_dwCurrentDialingLocation;

    //
    // Get the recipient's name
    //
    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT), pName, nameLen+1);
    //
    // Get the recipient's number
    //  AddressType
    //  [+ CountryCode Space]
    //  [( AreaCode ) Space]
    //  SubscriberNumber
    //
    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT), phoneNumber, MAX_RECIPIENT_NUMBER);
    if (!IsValidFaxAddress (phoneNumber, !bUseDialingRules))
    {
        //
        // Fax address is invalid
        //
        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return IDS_INVALID_RECIPIENT_NUMBER;
    }

    if(!bUseDialingRules)
    {
        _tcscpy(pAddress, phoneNumber);
    }
    else
    {
        GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                      areaCode, MAX_RECIPIENT_NUMBER);
        AssemblePhoneNumber(pAddress,
                            countryCode,
                            areaCode,
                            phoneNumber);
    }

    return 0;
}


BOOL
InitRecipientListView(
    HWND    hwndLV
    )

/*++

Routine Description:

    Initialize the recipient list view on the first page of Send Fax wizard

Arguments:

    hwndLV - Window handle to the list view control

Return Value:

    TRUE is success
    FALSE otherwise

--*/

{
    LV_COLUMN   lvc;
    RECT        rect;
    TCHAR       buffer[MAX_TITLE_LEN];

    if (hwndLV == NULL) {
        return FALSE;
    }

    if (!GetClientRect(hwndLV, &rect))
    {
        Error(("GetClientRect failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }

    ZeroMemory(&lvc, sizeof(lvc));

    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_FULLROWSELECT);

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = buffer;
    lvc.cx = (rect.right - rect.left) / 2;

    lvc.iSubItem = 0;
    if (!LoadString(ghInstance, IDS_COLUMN_RECIPIENT_NAME, buffer, MAX_TITLE_LEN))
    {
        Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }


    if (ListView_InsertColumn(hwndLV, 0, &lvc) == -1)
    {
        Error(("ListView_InsertColumn failed\n"));
        return FALSE;
    }
    lvc.cx -= GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 1;
    if (!LoadString(ghInstance, IDS_COLUMN_RECIPIENT_NUMBER, buffer, MAX_TITLE_LEN))
    {
        Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }

    if (ListView_InsertColumn(hwndLV, 1, &lvc) == -1)
    {
        Error(("ListView_InsertColumn failed\n"));
        return FALSE;
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

    return TRUE;
}

typedef struct {
    DWORD                       dwSizeOfStruct;
    LPTSTR                      lptstrName;
    LPTSTR                      lptstrAddress;
    LPTSTR                      lptstrCountry;
    DWORD                       dwCountryId;
    DWORD                       dwDialingRuleId;
    BOOL                        bUseDialingRules;
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList;
} CHECKNUMBER, * PCHECKNUMBER;


VOID
FreeCheckNumberFields(OUT PCHECKNUMBER pCheckNumber)
/*++

Routine Description:

    Frees CHECKNUMBER structure

Arguments:

    pCheckNumber    - out pointer to CHECKNUMBER structure

Return Value:

    NONE
--*/
{
    MemFree(pCheckNumber->lptstrName);
    MemFree(pCheckNumber->lptstrAddress);
    MemFree(pCheckNumber->lptstrCountry);
    ZeroMemory(pCheckNumber,sizeof(CHECKNUMBER));
}

BOOL
InitCheckNumber(IN  LPTSTR                      lptstrName,
                IN  LPTSTR                      lptstrAddress,
                IN  LPTSTR                      lptstrCountry,
                IN  DWORD                       dwCountryId,
				IN  DWORD						dwDialingRuleId,
                IN  BOOL                        bUseDialingRules,
                IN  PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
                OUT PCHECKNUMBER                pCheckNumber)
/*++

Routine Description:

    Initializes CHECKNUMBER structure

Arguments:

    lptstrName      - recipient name
    lptstrAddress   - recipient address
    lptstrCountry   - recipient country
    dwCountryID     - recipient country ID
    bUseDialingRules- Use Dialing Rules
    pCountryList    - TAPI country list
    pCheckNumber    - out pointer to CHECKNUMBER structure

Return Value:

    TRUE if success
    FALSE otherwise
--*/
{

    ZeroMemory(pCheckNumber,sizeof(CHECKNUMBER));
    pCheckNumber->dwSizeOfStruct = sizeof(CHECKNUMBER);

    if (lptstrName && !(pCheckNumber->lptstrName = StringDup(lptstrName)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    if (lptstrAddress && !(pCheckNumber->lptstrAddress = StringDup(lptstrAddress)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    if (lptstrCountry  && !(pCheckNumber->lptstrCountry = StringDup(lptstrCountry)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    pCheckNumber->dwCountryId      = dwCountryId;
    pCheckNumber->bUseDialingRules = bUseDialingRules;
    pCheckNumber->pCountryList     = pCountryList;
	pCheckNumber->dwDialingRuleId  = dwDialingRuleId;

    return TRUE;
error:
    FreeCheckNumberFields(pCheckNumber);

    return FALSE;
}


INT
ValidateCheckFaxRecipient(
    HWND         hDlg,
    PCHECKNUMBER pCheckNumber
    )

/*++

Routine Description:

    Validates the current recipient information in the dialog

Arguments:

    hDlg         - Handle to the fax recipient wizard page
    pCheckNumber - Pointer to the CHECKNUMBER struct

Return Value:

    = 0 if successful
    > 0 error message string resource ID otherwise

--*/

{
    DWORD                        countryId, countryCode;
    INT                          areaCodeLen, numberLen, nameLen;
    PFAX_TAPI_LINECOUNTRY_LIST   pCountryList = pCheckNumber->pCountryList;
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry;

    numberLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_LOCAL));

    if (numberLen <= 0 || numberLen >= MAX_RECIPIENT_NUMBER)
    {
        return IDS_BAD_RECIPIENT_NUMBER;
    }

    if(!pCheckNumber->bUseDialingRules)
    {
        return 0;
    }

    //
    // Find the current country code
    //

    countryCode = 0;
    pLineCountryEntry = NULL;
    countryId = GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY));

    if ((countryId != 0) &&
        (pLineCountryEntry = FindCountry(pCountryList,countryId)))
    {
        countryCode = pLineCountryEntry->dwCountryCode;
    }

    nameLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_RECIPIENT_NAME));
    areaCodeLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY));

    //
    // Validate the edit text fields
    //

    if (nameLen <= 0)
    {
        return IDS_BAD_RECIPIENT_NAME;
    }

    if ((areaCodeLen <= 0 && AreaCodeRules(pLineCountryEntry) == AREACODE_REQUIRED) ||
        (areaCodeLen >= MAX_RECIPIENT_NUMBER))
    {
        return IDS_BAD_RECIPIENT_AREACODE;
    }

    if (countryId==0)
    {
        return IDS_BAD_RECIPIENT_COUNTRY_CODE;
    }

    return 0;

}

VOID
CheckFaxSetFocus(HWND hDlg,
                 INT errId
                 )
{
    HWND hDglItem;
    switch (errId) {

        case IDS_ERROR_AREA_CODE:
            if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_CITY, _T("")))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        case IDS_BAD_RECIPIENT_AREACODE:

            errId = IDC_CHECK_FAX_CITY;
            break;

        case IDS_BAD_RECIPIENT_COUNTRY_CODE:

            errId = IDC_CHECK_FAX_COUNTRY;
            break;

        case IDS_INVALID_RECIPIENT_NUMBER:
            if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_LOCAL, _T("")))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        case IDS_BAD_RECIPIENT_NUMBER:

            errId = IDC_CHECK_FAX_LOCAL;
            break;

        case IDS_BAD_RECIPIENT_NAME:
        default:

            errId = IDC_CHECK_FAX_RECIPIENT_NAME;
            break;
    }

    if (!(hDglItem = GetDlgItem(hDlg, errId)))
    {
        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
    }
    else if (!SetFocus(hDglItem))
    {
        Error(("SetFocus failed. ec = 0x%X\n",GetLastError()));
    }

}

DWORD
GetCountryCode(
        HWND                        hDlg,
        PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
        INT                         nIDCountryItem
        )
{
/*++

Routine Description:

    Retrieves country code.

Arguments:

    hDlg - - Specifies the handle to the dialog window
    nIDCountryItem  - Specifies the identifier of the control of country code

Return Value:

    Coutry code if the country exists
    0 otherwise

--*/
    PFAX_TAPI_LINECOUNTRY_ENTRY pLineCountryEntry;
    DWORD                       dwCountryId, dwCountryCode;

    //
    // Find the current country code
    //

    dwCountryCode = 0;
    pLineCountryEntry = NULL;
    dwCountryId = GetCountryListBoxSel(GetDlgItem(hDlg, nIDCountryItem));

    if ((dwCountryId != 0) &&
        (pLineCountryEntry = FindCountry(pCountryList,dwCountryId)))
    {
        dwCountryCode = pLineCountryEntry->dwCountryCode;
    }
    return dwCountryCode;
}

LPTSTR
GetAreaCodeOrFaxNumberFromControl(
        IN  HWND    hDlg,
        IN  INT     nIDItem,
        OUT LPTSTR  szNumber
        )
{
/*++

Routine Description:

    Gets area code or phone number from an appropriate control

Arguments:

    hDlg - - Specifies the handle to the dialog window
    nIDItem - Specifies the identifier of the control to be retrieved. (area code/fax number)
    szNumber - Output buffer

Return Value:

    Area code/local fax number if the string is the number
    Or empty string otherwise

--*/
    HWND    hControl;
    Assert(szNumber);

    if (!(hControl = GetDlgItem(hDlg, nIDItem)))
    {
        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
        return _T( "" );
    }

    if (!GetWindowText(hControl, szNumber, MAX_RECIPIENT_NUMBER)&&GetLastError())
    {
        Error(("GetWindowText failed. ec = 0x%X\n",GetLastError()));
        return _T( "" );
    }
    return szNumber;
}

LPTSTR
StripSpaces(
            IN LPTSTR   lptstrPhoneNumber)
{
/*++

Routine Description:

    Strips spaces from the beginning of lptstrPhoneNumber

Arguments:

    lptstrPhoneNumber - phone number with spaces in the beginning

Return Value:

    lptstrPhoneNumber without spaces in the beginning

--*/
    TCHAR   szSpaces[MAX_STRING_LEN];
    szSpaces[0] = (TCHAR) '\0';

    if (!lptstrPhoneNumber)
        return NULL;

    if (_stscanf(lptstrPhoneNumber,_T("%[ ]"),szSpaces))
        return lptstrPhoneNumber + _tcslen(szSpaces);

    return lptstrPhoneNumber;
}

LPTSTR
StripCodesFromNumber(
            IN  LPTSTR   lptstrPhoneNumber,
            OUT DWORD  * pdwCountryCode,
            OUT LPTSTR   lptstrAreaCode)
{
/*++

Routine Description:

    Extracts, if possible,  area code. country code and local phone number from the phone number.
    This function considers three possibilities:
    1. The number is canonical and has area code
    2. The number is canonical and has no area code
    3. The number is not canonical

Arguments:

    lptstrPhoneNumber - assembled phone number
    pdwCountryCode  - adress of country code
    lptstrAreaCode - address of area code

Return Value:

    local phone number if the number was assembled or complete lptstrPhoneNumber otherwise

--*/
    LPTSTR  lptstrTmpCode, lptstrLocalPhoneNumber;
    lptstrTmpCode = lptstrLocalPhoneNumber = NULL;

    if (!lptstrPhoneNumber)
        return NULL;

    Assert(pdwCountryCode);
    Assert(lptstrAreaCode);

    // initialization
    *pdwCountryCode = 0 ;
    lptstrAreaCode[0] = NUL;

    // Strips country code
    if (IsCanonicalNumber(lptstrPhoneNumber))
    {
        _stscanf((lptstrPhoneNumber+1),_T("%d"),pdwCountryCode);
    }
    // Try to strip area code if the number contains "(...)"
    if (lptstrTmpCode = _tcschr(lptstrPhoneNumber,'('))
    {
        _stscanf((lptstrTmpCode+1),_T("%[^)]"),lptstrAreaCode);
    }

    // Set pointer to point to a local number if the number contains "(...)"
    lptstrLocalPhoneNumber = _tcsstr(lptstrPhoneNumber,_T(")"));

    if (lptstrLocalPhoneNumber)
    {   // lptstrPhoneNumber contains the tail of area code + local number
        return StripSpaces(lptstrLocalPhoneNumber + _tcslen(_T(")")));
    }

    lptstrTmpCode = NULL;
    if (IsCanonicalNumber(lptstrPhoneNumber))
    {   // Set up lptstrTmpCode to the beginning of local number
        lptstrTmpCode = _tcschr(lptstrPhoneNumber,' ');
    }

    if (lptstrTmpCode)
    {   // lptstrPhoneNumber is canonical, but doesn't contain area code
        return StripSpaces(lptstrTmpCode);
    }

    return lptstrPhoneNumber;   // lptstrPhoneNumber is not canonical and doesn't contain area code

}

INT_PTR
CALLBACK
CheckFaxNumberDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Dialog proc for check of fax number.

Arguments:

    lParam - pointer to CHECKNUMBER structure.

Return Value:

    0 - if cancel
    1 - if ok

--*/

{
    INT         errId;
    INT         cmd;
    PCHECKNUMBER pCheckNumber = (PCHECKNUMBER) lParam;
    TCHAR       tszBuffer[MAX_STRING_LEN];
    TCHAR       szAddress[MAX_STRING_LEN];
    TCHAR       szAreaCode[MAX_RECIPIENT_NUMBER];
    TCHAR       szPoneNumber[MAX_RECIPIENT_NUMBER];
    TCHAR       szName[MAX_STRING_LEN];
    DWORD       dwErrorCode;
    DWORD       dwCountryId=0;
    DWORD       dwCountryCode=0 ;
    LPTSTR      lptstrLocalPhoneNumber=NULL;
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry;
    HWND        hControl;

    //
    // Maximum length for various text fields
    //

    static INT  textLimits[] = {

        IDC_CHECK_FAX_RECIPIENT_NAME,   64,
        IDC_CHECK_FAX_CITY,             11,
        IDC_CHECK_FAX_LOCAL,            51,
        0
    };

    ZeroMemory(szAreaCode, sizeof(szAreaCode));


    switch (uMsg)
    {
        case WM_INITDIALOG:

            LimitTextFields(hDlg, textLimits);

            if (pCheckNumber->lptstrName)
            {
                if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_RECIPIENT_NAME, pCheckNumber->lptstrName))
                    Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }

            // store pointer for futher proceeding
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            //
            // A numeric edit control should be LTR
            //
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_NUMBER);
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_CITY);
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_LOCAL);

            if(!pCheckNumber->bUseDialingRules)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY), FALSE);
            }
            else
            {
                lptstrLocalPhoneNumber = StripCodesFromNumber( pCheckNumber->lptstrAddress,
                                                               &dwCountryCode,
                                                               szAreaCode );
                dwCountryId = pCheckNumber->dwCountryId;
                if(!dwCountryId)
                {
                    dwCountryId = GetCountryIdFromCountryCode(pCheckNumber->pCountryList,
                                                              dwCountryCode);
                }

                // init country combo box and try to identify the country
                if (!(hControl=GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)))
                {
                    Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                }
                else
                {
                    InitCountryListBox(pCheckNumber->pCountryList,
                                       hControl,
                                       NULL,
                                       pCheckNumber->lptstrCountry,
                                       dwCountryId,
                                       TRUE);
                }

                if  (dwCountryCode==0)
                {   // country code wasn't indentified
                    if (!(hControl=GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)))
                    {
                        Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                    }
                    else
                    {
                        dwCountryId = GetCountryListBoxSel(hControl);
                    }

                    if ((dwCountryId != 0) &&
                        (pLineCountryEntry = FindCountry(pCheckNumber->pCountryList,dwCountryId)))
                    {
                        dwCountryCode = pLineCountryEntry->dwCountryCode;
                    }
                }

                Assert (lptstrLocalPhoneNumber);

                SetDlgItemText(hDlg, IDC_CHECK_FAX_CITY , szAreaCode);
                AssemblePhoneNumber(szAddress,
                                    dwCountryCode,
                                    szAreaCode,
                                    lptstrLocalPhoneNumber ? lptstrLocalPhoneNumber : _T(""));
            }

            SetDlgItemText(hDlg,
                           IDC_CHECK_FAX_NUMBER,
                           !(pCheckNumber->bUseDialingRules) ?
                           pCheckNumber->lptstrAddress : szAddress);

            SetDlgItemText(hDlg,
                           IDC_CHECK_FAX_LOCAL,
                           !(pCheckNumber->bUseDialingRules) ?
                           pCheckNumber->lptstrAddress : lptstrLocalPhoneNumber);


            return TRUE;

        case WM_COMMAND:

            cmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_CHECK_FAX_COUNTRY:
                    pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                    Assert(pCheckNumber);

                    if (cmd == CBN_SELCHANGE)
                    {
                        if (!(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)) ||
                            !(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY)))
                        {
                            Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        }
                        else
                        {
                            SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY),
                                                    GetDlgItem(hDlg, IDC_CHECK_FAX_CITY),
                                                    pCheckNumber->pCountryList);
                        }
                        AssemblePhoneNumber(szAddress,
                                            GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode),
                                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber));

                        SetDlgItemText(hDlg, IDC_CHECK_FAX_NUMBER, szAddress);
                    }
                break;
                case IDC_CHECK_FAX_CITY:

                    if (cmd == EN_CHANGE)
                    {

                        pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                        Assert(pCheckNumber);

                       // Read the text from the edit control.

                       if (!GetDlgItemText( hDlg, IDC_CHECK_FAX_CITY, tszBuffer, MAX_STRING_LEN))
                       {
                          dwErrorCode = GetLastError();
                          if ( dwErrorCode != (DWORD) ERROR_SUCCESS )
                          {
                             // Error reading the edit control.
                          }
                       }
                       AssemblePhoneNumber(szAddress,
                            GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode),
                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber));

                       SetDlgItemText(hDlg, IDC_CHECK_FAX_NUMBER, szAddress);
                    }

                break;
                case IDC_CHECK_FAX_LOCAL:

                    if (cmd == EN_CHANGE)
                    {

                        pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                        Assert(pCheckNumber);
                        //
                        // Read the text from the edit control.
                        //
                        if(!GetDlgItemText(hDlg,
                                           IDC_CHECK_FAX_LOCAL,
                                           tszBuffer,
                                           MAX_STRING_LEN))
                        {
                            tszBuffer[0] = 0;
                            Warning(("GetDlgItemText(IDC_CHECK_FAX_LOCAL) failed. ec = 0x%X\n",GetLastError()));
                        }

                        if(pCheckNumber->bUseDialingRules)
                        {
                            AssemblePhoneNumber(szAddress,
                                    GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                                    GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode),
                                    GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber));
                        }

                        SetDlgItemText(hDlg,
                                       IDC_CHECK_FAX_NUMBER,
                                       !pCheckNumber->bUseDialingRules ?
                                       tszBuffer : szAddress);
                    }

                break;

            }

            switch(LOWORD( wParam ))
            {
                case IDOK:
                    pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                    Assert(pCheckNumber);

                    errId = ValidateCheckFaxRecipient(hDlg, pCheckNumber);
                    if (errId > 0)
                    {
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, errId);
                        CheckFaxSetFocus(hDlg,errId);
                        return FALSE;
                    }

                    if(!GetDlgItemText(hDlg,
                                       IDC_CHECK_FAX_LOCAL,
                                       tszBuffer,
                                       MAX_STRING_LEN))
                    {
                        tszBuffer[0] = 0;
                        Warning(("GetDlgItemText(IDC_CHECK_FAX_LOCAL) failed. ec = 0x%X\n",GetLastError()));
                    }
                    if (!IsValidFaxAddress (tszBuffer, !pCheckNumber->bUseDialingRules))
                    {
                        //
                        // Fax address is invalid
                        //
                        DisplayMessageDialog(hDlg, 0, 0, IDS_INVALID_RECIPIENT_NUMBER);
                        return FALSE;
                    }

                    ZeroMemory(szName,sizeof(TCHAR)*MAX_STRING_LEN);
                    if (!GetDlgItemText(hDlg,
                                        IDC_CHECK_FAX_RECIPIENT_NAME,
                                        szName,
                                        MAX_STRING_LEN)
                         && GetLastError())
                    {
                        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECIPIENT_NAME);
                        CheckFaxSetFocus(hDlg,IDS_BAD_RECIPIENT_NAME);
                        return FALSE;
                    }

                    MemFree(pCheckNumber->lptstrName);
                    pCheckNumber->lptstrName = NULL;
                    if ((szName[0] != '\0') &&
                        !(pCheckNumber->lptstrName = StringDup(szName)))
                    {
                        Error(("Memory allocation failed\n"));
                        return FALSE;
                    }

                    ZeroMemory(szAddress,sizeof(TCHAR)*MAX_STRING_LEN);
                    if (!GetDlgItemText(hDlg,
                                        IDC_CHECK_FAX_NUMBER,
                                        szAddress,
                                        MAX_STRING_LEN)
                         && GetLastError())
                    {
                        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECIPIENT_NUMBER);
                        CheckFaxSetFocus(hDlg,IDS_BAD_RECIPIENT_NUMBER);
                        return FALSE;
                    }

                    MemFree(pCheckNumber->lptstrAddress);
                    pCheckNumber->lptstrAddress = NULL;
                    if ((szAddress[0] != '\0') &&
                        !(pCheckNumber->lptstrAddress = StringDup(szAddress)))
                    {
                        Error(("Memory allocation failed\n"));
                        MemFree(pCheckNumber->lptstrName);
                        return FALSE;
                    }

                    pCheckNumber->dwCountryId = GetCountryListBoxSel(GetDlgItem(hDlg,
                                                                IDC_CHECK_FAX_COUNTRY));

                    EndDialog(hDlg,1);
                    return TRUE;

                case IDCANCEL:

                    EndDialog( hDlg,0 );
                    return TRUE;

            }
            break;

        default:
            return FALSE;

    }

    return FALSE;
}

BOOL
IsCanonicalNumber(LPCTSTR lptstrNumber)
{
    if (!lptstrNumber)
    {
        return FALSE;
    }
    if ( _tcsncmp(lptstrNumber,TEXT("+"),1) != 0 )
        return FALSE;

    return TRUE;
}


BOOL
InsertRecipientListItem(
    HWND        hwndLV,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Insert an item into the recipient list view

Arguments:

    hwndLV - Window handle to the recipient list view
    pRecipient - Specifies the recipient to be inserted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LV_ITEM lvi = {0};
    INT     index;
    TCHAR*  pAddress = NULL;

    lvi.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.lParam = (LPARAM) pRecipient;
    lvi.pszText = pRecipient->pName;
    lvi.state = lvi.stateMask = LVIS_SELECTED;

    if ((index = ListView_InsertItem(hwndLV, &lvi)) == -1)
    {
        Error(("ListView_InsertItem failed\n"));
        return FALSE;
    }

    pAddress = pRecipient->pAddress;

#ifdef UNICODE

    if(IsWindowRTL(hwndLV))
    {
        pAddress = (TCHAR*)MemAlloc(sizeof(TCHAR)*(_tcslen(pRecipient->pAddress)+2));
        if(!pAddress)
        {
            Error(("MemAlloc failed\n"));
            return FALSE;
        }

        _stprintf(pAddress, TEXT("%c%s"), UNICODE_LRO, pRecipient->pAddress);
    }

#endif

    ListView_SetItemText(hwndLV, index, 1, pAddress);

    if(pAddress != pRecipient->pAddress)
    {
        MemFree(pAddress);
    }

    return TRUE;
}


PRECIPIENT
GetRecipientListItem(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Retrieve the recipient associated with an item in the list view

Arguments:

    hwndLV - Window handle to the recipient list view
    index - Specifies the index of the interested item

Return Value:

    Pointer to the requested recipient information
    NULL if there is an error

--*/

{
    LV_ITEM lvi;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;
    lvi.iItem = index;

    if (ListView_GetItem(hwndLV, &lvi))
        return (PRECIPIENT) lvi.lParam;

    Error(("ListView_GetItem failed\n"));
    return NULL;
}

VOID
FreeEntryID(
        PWIZARDUSERMEM  pWizardUserMem,
        LPVOID          lpEntryId
            )
{
    if (pWizardUserMem->lpMAPIabInit)
    {
        FreeMapiEntryID(pWizardUserMem,lpEntryId);
    }
    else
    {
        FreeWabEntryID(pWizardUserMem,lpEntryId);
    }

}


INT
AddRecipient(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
    )

/*++

Routine Description:

    Add the current recipient information entered by the user
    into the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    Same meaning as return value from GetCurrentRecipient, i.e.
    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    PRECIPIENT  pRecipient = NULL;
    PRECIPIENT  pRecipientList = NULL;
    INT         errId = 0;
    HWND        hwndLV;
    BOOL        bNewRecipient = TRUE;

    //
    // Collect information about the current recipient
    //

    if ((errId = GetCurrentRecipient(hDlg, pWizardUserMem, &pRecipient)) != 0)
    {
        return errId;
    }

    for(pRecipientList = pWizardUserMem->pRecipients; pRecipientList; pRecipientList = pRecipientList->pNext)
    {
        if(pRecipient->pAddress     &&
           pRecipient->pName        &&
           pRecipientList->pAddress &&
           pRecipientList->pName    &&
           !_tcscmp(pRecipient->pAddress, pRecipientList->pAddress) &&
           !_tcsicmp(pRecipient->pName,   pRecipientList->pName))
        {
            //
            // The recipient is already in list
            //
            bNewRecipient = FALSE;
            FreeRecipient(pRecipient);
            pRecipient = NULL;
            break;
        }
    }


    if(bNewRecipient && pRecipient)
    {
        //
        // save last recipient country ID
        //
        pWizardUserMem->lpFaxSendWizardData->dwLastRecipientCountryId =
                 GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO));

        //
        // Insert the current recipient to the recipient list
        //
        hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST);
        if(!hwndLV)
        {
            Assert(hwndLV);
            errId = -1;
            goto error;
        }

        if(!InsertRecipientListItem(hwndLV, pRecipient))
        {
            errId = -1;
            goto error;
        }

        //
        // Autosize the last column to get rid of unnecessary horizontal scroll bar
        //
        ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

        //
        // Add the recipient into the list
        //
        pRecipient->pNext = pWizardUserMem->pRecipients;
        pWizardUserMem->pRecipients = pRecipient;
    }

    //
    // Clear the name and number fields
    //
    if (!SetDlgItemText(hDlg, IDC_CHOOSE_NAME_EDIT,   TEXT("")) ||
        !SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, TEXT("")))
    {
        Warning(("SetWindowText failed. ec = 0x%X\n",GetLastError()));
    }

    return errId;

error:

    FreeRecipient(pRecipient);

    return errId;
}

static
HRESULT
CopyRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppDestination,
    PRECIPIENT            prSource,
    BOOL                  bLocalServer)
{
    if ((pfppDestination->lptstrName = DuplicateString(prSource->pName)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if ((prSource->bUseDialingRules) &&                                     // We have a canonical address and
        bLocalServer                 &&                                     // and it's a local server
        (USE_LOCAL_SERVER_OUTBOUND_ROUTING != prSource->dwDialingRuleId))   // we don't use server's outbound routing
    {
        //
        // We need to translate the address ourseleves, using the specified dialing location
        //
        if (!TranslateAddress (prSource->pAddress,
                               prSource->dwDialingRuleId,
                               &pfppDestination->lptstrFaxNumber))
        {
            MemFree(pfppDestination->lptstrName);
            pfppDestination->lptstrName = NULL;
            return GetLastError ();
        }
    }
    else
    {
        //
        // Either 'Dial as entered' mode or using the server's outbound routing.
        // Just copy the address as is.
        //
        if ((pfppDestination->lptstrFaxNumber = DuplicateString(prSource->pAddress)) == NULL)
        {
            MemFree(pfppDestination->lptstrName);
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    Verbose(("Copied %ws from %ws\n", pfppDestination->lptstrName,pfppDestination->lptstrFaxNumber));
    return S_OK;
}

static HRESULT
StoreRecipientInfoInternal(
        PWIZARDUSERMEM  pWizardUserMem
     )
{
    DWORD   dwIndex;
    HRESULT hResult = S_OK;
    PRECIPIENT  pCurrentRecip = NULL,pNewRecip = NULL;
    PFAX_PERSONAL_PROFILE   pCurrentPersonalProfile = NULL;

    Assert(pWizardUserMem);
    Assert(pWizardUserMem->lpInitialData);
    Assert(pWizardUserMem->pRecipients == NULL);

    if (!pWizardUserMem->lpInitialData->dwNumberOfRecipients)   // zero recipients
        return S_OK;

    for (dwIndex = 0; dwIndex < pWizardUserMem->lpInitialData->dwNumberOfRecipients; dwIndex++)
    {

        if (!(pNewRecip = MemAlloc(sizeof(RECIPIENT))))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        ZeroMemory(pNewRecip,sizeof(RECIPIENT));

        if (dwIndex == 0)
            pWizardUserMem->pRecipients = pNewRecip;

        pCurrentPersonalProfile = &pWizardUserMem->lpInitialData->lpRecipientsInfo[dwIndex];

        if (pCurrentPersonalProfile->lptstrName && !(pNewRecip->pName = DuplicateString(pCurrentPersonalProfile->lptstrName)))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        if (pCurrentPersonalProfile->lptstrFaxNumber && !(pNewRecip->pAddress = DuplicateString(pCurrentPersonalProfile->lptstrFaxNumber)))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        pNewRecip->pCountry = NULL;
        pNewRecip->pNext = NULL;
        pNewRecip->lpEntryId = NULL;
        pNewRecip->lpEntryId = 0;
        pNewRecip->bFromAddressBook = FALSE;
        if (!pCurrentRecip)
            pCurrentRecip = pNewRecip;
        else {
            pCurrentRecip->pNext = pNewRecip;
            pCurrentRecip = pCurrentRecip->pNext;
        }
    }


    goto exit;

error:
    FreeRecipientList(pWizardUserMem);
exit:
    return hResult;
}

VOID
FreeRecipientList(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Free up the list of recipients associated with each fax job

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    PRECIPIENT  pNextRecipient, pFreeRecipient;

    Assert(pWizardUserMem);
    //
    // Free the list of recipients
    //

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {

        pFreeRecipient = pNextRecipient;
        pNextRecipient = pNextRecipient->pNext;
        FreeRecipient(pFreeRecipient);
    }

    pWizardUserMem->pRecipients = NULL;
}

INT
SizeOfRecipientList(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Calculates size of the list of recipients associated with each fax job

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    size of the list

--*/

{
    PRECIPIENT  pNextRecipient;
    INT iCount = 0;

    Assert(pWizardUserMem);

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {
        iCount++;
        pNextRecipient = pNextRecipient->pNext;
    }

    return iCount;
}

INT
FillRecipientListView(
    PWIZARDUSERMEM  pWizardUserMem,
    HWND            hWndList
    )

/*++

Routine Description:

    Fills recipient list view

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    PRECIPIENT  pNextRecipient;

    Assert(pWizardUserMem);

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {
        if (!InsertRecipientListItem(hWndList,pNextRecipient))
        {
            Warning(("InsertRecipientListItem failed"));
        }
        pNextRecipient = pNextRecipient->pNext;
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);

    return TRUE;
}

BOOL
IsAreaCodeMandatory(
    DWORD               dwCountryCode,
    PFAX_TAPI_LINECOUNTRY_LIST pFaxCountryList
    )
/*++

Routine name : IsAreaCodeMandatory

Routine description:

    Checks if an area code is mandatory for a specific long distance rule

Author:

    Oded Sacher (OdedS),    May, 2000

Arguments:

    dwCountryCode                       [in] - The country country code.
    pFaxCountryList                     [in] - The country list obtained by a call to FaxGetCountryList()

Return Value:

    TRUE - The area code is needed.
    FALSE - The area code is not mandatory.

--*/
{
    DWORD dwIndex;

    Assert (pFaxCountryList);

    for (dwIndex=0; dwIndex < pFaxCountryList->dwNumCountries; dwIndex++)
    {
        if (pFaxCountryList->LineCountryEntries[dwIndex].dwCountryCode == dwCountryCode)
        {
            //
            // Matching country code - Check long distance rule.
            //
            if (pFaxCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule)
            {
                if (_tcschr(pFaxCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule, TEXT('F')) != NULL)
                {
                    return TRUE;
                }
                return FALSE;
            }
        }
    }
    return FALSE;
}


BOOL
AddRecipientsToList(
    IN      HWND            hDlg,
    IN OUT  PWIZARDUSERMEM  pWizardUserMem
    )
{
/*++

Routine Description:

    Adds recipients to list control. Checks addresses of each
    recipient form the list. Inserts to the GUI list and new recipient list
    canonical adresses or confirmed addresses by user only.
    Returns a new list of recipients in PWIZARDUSERMEM struct.

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/
    HWND            hwndLV = NULL;
    PRECIPIENT      tmpRecip = NULL, pPrevRecip=NULL;

    if (! (hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
        return FALSE;

    if (!ListView_DeleteAllItems(hwndLV))
    {
        Warning(("ListView_DeleteAllItems failed\n"));
    }

    for (tmpRecip = pWizardUserMem->pRecipients; tmpRecip; tmpRecip = tmpRecip->pNext)
    {
        DWORD dwRes;
        BOOL bCanonicalAdress;
        DWORD dwCountryCode, dwAreaCode;

        dwRes = IsCanonicalAddress( tmpRecip->pAddress,
                                    &bCanonicalAdress,
                                    &dwCountryCode,
                                    &dwAreaCode,
                                    NULL);
        if (ERROR_SUCCESS != dwRes)
        {
            Error(("IsCanonicalAddress failed\n"));
        }
        else
        {
            tmpRecip->bUseDialingRules = TRUE;
            tmpRecip->dwDialingRuleId = g_dwCurrentDialingLocation;

            if (bCanonicalAdress)
            {
                if (IsAreaCodeMandatory(dwCountryCode, pWizardUserMem->pCountryList) &&
                    ROUTING_RULE_AREA_CODE_ANY == dwAreaCode)
                {
                    tmpRecip->bUseDialingRules = FALSE;
                }
            }
            else
            {
                tmpRecip->bUseDialingRules = FALSE;
            }
        }

        if (!InsertRecipientListItem(hwndLV, tmpRecip))
        {
            Warning(("InsertRecipientListItem failed"));
        }
    }

    // remove empty recipients
    for (tmpRecip = pWizardUserMem->pRecipients,pPrevRecip=NULL; tmpRecip; )
    {
        if ((tmpRecip->pAddress == NULL) && (tmpRecip->pName == NULL))
        {
            // Should be removed
            if (pPrevRecip==NULL)
            {
                pWizardUserMem->pRecipients = tmpRecip->pNext;
                MemFree(tmpRecip);
                tmpRecip = pWizardUserMem->pRecipients;
            }
            else
            {
                pPrevRecip->pNext= tmpRecip->pNext;
                MemFree(tmpRecip);
                tmpRecip = pPrevRecip->pNext;
            }
        }
        else
        {
            pPrevRecip = tmpRecip;
            tmpRecip = tmpRecip->pNext;
        }
    }

    return TRUE;
}

BOOL
DoAddressBook(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
    )

/*++

Routine Description:

    Display the MAPI address book dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HWND            hwndLV = NULL;
    BOOL            result = TRUE;
    PRECIPIENT      pNewRecip = NULL;

    if ( !pWizardUserMem->lpMAPIabInit &&
        !(pWizardUserMem->lpMAPIabInit = InitializeMAPIAB(ghInstance,hDlg)))
    {
        if (! pWizardUserMem->lpWabInit &&
            ! (pWizardUserMem->lpWabInit = InitializeWAB(ghInstance)))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADDRBOOK), FALSE);
            return FALSE;
        }
    }
    //
    // Add current recipient to the list if necessary
    //

    AddRecipient(hDlg, pWizardUserMem);


    if (pWizardUserMem->lpMAPIabInit)
    {
        result = CallMAPIabAddress(
                    hDlg,
                    pWizardUserMem,
                    &pNewRecip
                    );
    }
    else
    {
        result = CallWabAddress(
                    hDlg,
                    pWizardUserMem,
                    &pNewRecip
                    );
    }

    FreeRecipientList(pWizardUserMem);

    // copy new list of recipients from Address book to the pWizardUserMem
    pWizardUserMem->pRecipients = pNewRecip;

    if (!AddRecipientsToList(
                    hDlg,
                    pWizardUserMem))
    {
        Error(("Failed to add recipients to the list\n"));
    }

    if (!result)
    {
        DisplayMessageDialog( hDlg, MB_OK, IDS_WIZARD_TITLE, IDS_BAD_ADDRESS_TYPE );
    }

    return result;
}


LPTSTR
GetEMailAddress(
    HWND        hDlg,
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Display the MAPI address book dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    LPTSTR          result;
    if (! pWizardUserMem->lpMAPIabInit &&
        !(pWizardUserMem->lpMAPIabInit = InitializeMAPIAB(ghInstance,hDlg)))
    {
        if (! pWizardUserMem->lpWabInit &&
            ! (pWizardUserMem->lpWabInit = InitializeWAB(ghInstance)))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ADDRBOOK), FALSE);
            return FALSE;
        }
    }
    //
    // Get a handle to the recipient list window
    //

    if (pWizardUserMem->lpMAPIabInit)
    {
        result = CallMAPIabAddressEmail(
                    hDlg,
                    pWizardUserMem
                    );
    }
    else
    {
        result = CallWabAddressEmail(
                    hDlg,
                    pWizardUserMem
                    );
    }

    return result;
}

BOOL
ValidateRecipients(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )

/*++

Routine Description:

    Validate the list of fax recipients entered by the user

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT errId;

    //
    // Add current recipient to the list if necessary
    //

    errId = AddRecipient(hDlg, pWizardUserMem);

    //
    // There must be at least one recipient
    //

    if (pWizardUserMem->pRecipients)
        return TRUE;

    //
    // Display an error message
    //

    if (errId > 0)
    {
        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, errId);
    }
    else
    {
        //
        // Memory failures
        //
        MessageBeep(MB_OK);
    }

    //
    // Set current focus to the appropriate text field as a convenience
    //

    switch (errId)
    {
        case IDS_INVALID_RECIPIENT_NUMBER:
            SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, _T(""));
        case IDS_BAD_RECIPIENT_NUMBER:
            errId = IDC_CHOOSE_NUMBER_EDIT;
            break;

        case IDS_ERROR_AREA_CODE:
            SetDlgItemText(hDlg, IDC_CHOOSE_AREA_CODE_EDIT, _T(""));
        case IDS_BAD_RECIPIENT_AREACODE:
            errId = IDC_CHOOSE_AREA_CODE_EDIT;
            break;

        case IDS_BAD_RECIPIENT_COUNTRY_CODE:
            errId = IDC_CHOOSE_COUNTRY_COMBO;
            break;

        case IDS_BAD_RECIPIENT_NAME:
        default:
            errId = IDC_CHOOSE_NAME_EDIT;
            break;
    }

    SetFocus(GetDlgItem(hDlg, errId));
    return FALSE;
}


PRECIPIENT *
FindRecipient(
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Check if the specified recipient is in the list of recipients

Arguments:

    pWizardUserMem - Points to user mode memory structure
    pRecipient - Specifies the recipient to be found

Return Value:

    Address of the link pointer to the specified recipient
    NULL if the specified recipient is not found

--*/

{
    PRECIPIENT  pCurrent, *ppPrevNext;

    //
    // Search for the specified recipient in the list
    //

    ppPrevNext = (PRECIPIENT *) &pWizardUserMem->pRecipients;
    pCurrent = pWizardUserMem->pRecipients;

    while (pCurrent && pCurrent != pRecipient) {

        ppPrevNext = (PRECIPIENT *) &pCurrent->pNext;
        pCurrent = pCurrent->pNext;
    }

    //
    // Return the address of the link pointer to the specified recipient
    // or NULL if the specified recipient is not found
    //

    return pCurrent ? ppPrevNext : NULL;
}


BOOL
RemoveRecipient(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )

/*++

Routine Description:

    Remove the currently selected recipient from the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PRECIPIENT  pRecipient, *ppPrevNext;
    INT         selIndex;
    HWND        hwndLV;

    //
    // Get the currently selected recipient, and
    // Find the current recipient in the list, then
    // Delete the current recipient and select the next one below it
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)) &&
        (selIndex = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) != -1 &&
        (pRecipient = GetRecipientListItem(hwndLV, selIndex)) &&
        (ppPrevNext = FindRecipient(pWizardUserMem, pRecipient)) &&
        ListView_DeleteItem(hwndLV, selIndex))
    {
        ListView_SetItemState(hwndLV,
                              selIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED);

        //
        // Delete the recipient from the internal list
        //

        *ppPrevNext = pRecipient->pNext;
        FreeRecipient(pRecipient);

        //
        // Autosize the last column to get rid of unnecessary horizontal scroll bar
        //
        ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

        return TRUE;
    }

    MessageBeep(MB_ICONHAND);
    return FALSE;
}


VOID
EditRecipient(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    Edit the currently selected recipient in the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    NONE

--*/
{
    INT_PTR     dlgResult;
    CHECKNUMBER checkNumber = {0};
    DWORD       dwListIndex;
    LV_ITEM     lvi;
    HWND        hListWnd;
    PRECIPIENT  pRecip,pNewRecip;
    TCHAR       szCountry[MAX_STRING_LEN],szName[MAX_STRING_LEN],szAddress[MAX_STRING_LEN];

    ZeroMemory(szName,sizeof(TCHAR)*MAX_STRING_LEN);
    ZeroMemory(szAddress,sizeof(TCHAR)*MAX_STRING_LEN);
    ZeroMemory(szCountry,sizeof(TCHAR)*MAX_STRING_LEN);

    hListWnd = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST);
    dwListIndex = ListView_GetNextItem(hListWnd , -1, LVNI_ALL | LVNI_SELECTED);
    while (dwListIndex != -1)
    {
        // Initialize lvi
        lvi.mask = LVIF_PARAM;
        // Set the item number
        lvi.iItem = dwListIndex;
        // Get the selected item from the list view
        if (ListView_GetItem(hListWnd, &lvi))
        {
            pRecip = (PRECIPIENT) lvi.lParam;
            Assert(pRecip);
            if (!pRecip)
            {
                Error(("Failed to get recipient from recipient list"));
                return;
            }
            if (InitCheckNumber(_tcscpy(szName,pRecip->pName ? pRecip->pName : _T("")),
                                _tcscpy(szAddress,pRecip->pAddress ? pRecip->pAddress : _T("")),
                                _tcscpy(szCountry,pRecip->pCountry ? pRecip->pCountry : _T("")),
                                pRecip->dwCountryId,
								pRecip->dwDialingRuleId,
                                pRecip->bUseDialingRules,
                                pWizardUserMem->pCountryList,
                                &checkNumber))
            {

                dlgResult = DialogBoxParam(
                                     (HINSTANCE) ghInstance,
                                     MAKEINTRESOURCE( IDD_CHECK_FAX_NUMBER ),
                                     hDlg,
                                     CheckFaxNumberDlgProc,
                                     (LPARAM) &checkNumber
                                     );
                if (dlgResult)
                {
                    RemoveRecipient(hDlg, pWizardUserMem);
                    if (!(pNewRecip = MemAllocZ(sizeof(RECIPIENT))))
                    {
                        Error(("Memory allocation failed"));
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    ZeroMemory(pNewRecip,sizeof(RECIPIENT));

                    if (checkNumber.lptstrName && !(pNewRecip->pName    = StringDup(checkNumber.lptstrName)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    if (checkNumber.lptstrAddress && !(pNewRecip->pAddress = StringDup(checkNumber.lptstrAddress)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip->pName);
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    if (szCountry && !(pNewRecip->pCountry = StringDup(szCountry)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip->pName);
                        MemFree(pNewRecip->pAddress);
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }

                    pNewRecip->dwCountryId      = checkNumber.dwCountryId;
                    pNewRecip->bUseDialingRules = checkNumber.bUseDialingRules;
					pNewRecip->dwDialingRuleId  = checkNumber.dwDialingRuleId;

                    if (InsertRecipientListItem(hListWnd, pNewRecip))
                    {
                        pNewRecip->pNext = pWizardUserMem->pRecipients;
                        pWizardUserMem->pRecipients = pNewRecip;
                    }
                    else
                    {
                        FreeRecipient(pNewRecip);
                    }
                }
                FreeCheckNumberFields(&checkNumber);
            }
            else
            {
                Error(("Failed to initialize CHECKNUMBER structure"));
            }
        }

        dwListIndex = ListView_GetNextItem(hListWnd, dwListIndex, LVNI_ALL | LVNI_SELECTED);
    }
}


VOID
LocationListSelChange(
    HWND            hDlg,
    PWIZARDUSERMEM  pUserMem
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    hDlg     - Handle to "Compose New Fax" wizard window
    pUserMem - Pointer to user mode memory structure

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    LRESULT selIndex;
    DWORD   dwLocationID;

    if ((hwndList = GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES)) &&
        (selIndex = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR &&
        (dwLocationID = (DWORD)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0)) != CB_ERR)
    {
        if (USE_LOCAL_SERVER_OUTBOUND_ROUTING != dwLocationID)
        {
            //
            // User selected a real location - set it (in TAPI)
            //
            SetCurrentLocation(dwLocationID);
            pUserMem->lpFaxSendWizardData->bUseOutboundRouting = FALSE;
        }
        else
        {
            //
            // User selected to use the server's outbound routing rules - mark that.
            // We use that information next time we run the wizard, to select the location in the combo-box.
            //
            pUserMem->lpFaxSendWizardData->bUseOutboundRouting = TRUE;
        }
        //
        // Save it globally, will be used by AddRecipient
        //
        g_dwCurrentDialingLocation = dwLocationID;
    }
}   // LocationListSelChange

VOID
LocationListInit(
    HWND              hDlg,
    PWIZARDUSERMEM    pUserMem
)
/*++

Routine Description:

    Initialize the list of TAPI locations

Arguments:

    hDlg - Handle to "Compose New Fax" wizard window
    pUserMem - Pointer to user mode memory structure

Return Value:

    NONE

--*/

{
    HWND                hwndList;
    DWORD               dwIndex;
    LRESULT             listIdx;
    LPTSTR              lptstrLocationName;
    LPTSTR              lptstrSelectedName = NULL;
    DWORD               dwSelectedLocationId;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;
    LPLINELOCATIONENTRY pLocationEntry;

    Assert (pUserMem);
    Assert (pUserMem->isLocalPrinter)

    //
    // Get the list of locations from TAPI and use it
    // to initialize the location combo-box.
    //
    hwndList = GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES);
    Assert (hwndList);

    if (WaitForSingleObject( pUserMem->hTAPIEvent, INFINITE ) != WAIT_OBJECT_0)
    {
        Error(("WaitForSingleObject failed. ec = 0x%X\n", GetLastError()));
        Assert(FALSE);
        return;
    }

    if (pTranslateCaps = GetTapiLocationInfo(hDlg))
    {
        SendMessage(hwndList, CB_RESETCONTENT, 0, 0);

        pLocationEntry = (LPLINELOCATIONENTRY)
            ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);

        for (dwIndex=0; dwIndex < pTranslateCaps->dwNumLocations; dwIndex++)
        {
            lptstrLocationName = (LPTSTR)
                ((PBYTE) pTranslateCaps + pLocationEntry->dwLocationNameOffset);

            if (pLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID)
            {
                lptstrSelectedName = lptstrLocationName;
                dwSelectedLocationId = pLocationEntry->dwPermanentLocationID;
            }

            listIdx = SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) lptstrLocationName);

            if (listIdx != CB_ERR)
            {
                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            listIdx,
                            pLocationEntry->dwPermanentLocationID);
            }
            pLocationEntry++;
        }
    }
    //
    // Let's see if we should add the "Use Outbound Routing Rules" option to the list
    //
    if (!IsDesktopSKU())
    {
        //
        // Not consumer SKU.
        // There's a chance we have outbound routing rules.
        // Add this option to the combo-box
        //
        TCHAR tszUseOutboundRouting[MAX_PATH];
        if (LoadString (ghInstance, IDS_USE_OUTBOUND_ROUTING, tszUseOutboundRouting, ARR_SIZE(tszUseOutboundRouting)))
        {
            SendMessage(hwndList,
                        CB_INSERTSTRING,
                        0,
                        (LPARAM)tszUseOutboundRouting);
            SendMessage(hwndList,
                        CB_SETITEMDATA,
                        0,
                        USE_LOCAL_SERVER_OUTBOUND_ROUTING);
            //
            // Restore last 'use outbound routing' option
            //
            if (pUserMem->lpFaxSendWizardData->bUseOutboundRouting)
            {
                lptstrSelectedName = NULL;
                g_dwCurrentDialingLocation = USE_LOCAL_SERVER_OUTBOUND_ROUTING;
                SendMessage(hwndList,
                            CB_SETCURSEL,
                            0,
                            0);
            }
        }
        else
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
        }
    }

    if (lptstrSelectedName != NULL)
    {
        //
        // Select the current dialing location in the combo-box
        //
        SendMessage(hwndList,
                    CB_SELECTSTRING,
                    (WPARAM) -1,
                    (LPARAM) lptstrSelectedName);
        g_dwCurrentDialingLocation = dwSelectedLocationId;
    }
    MemFree(pTranslateCaps);
}   // LocationListInit



void
CalcRecipientButtonsState(
    HWND    hDlg,
    PWIZARDUSERMEM    pWizardUserMem
)
/*++

Routine Description:

    calculate Add, Remove and Edit buttons state

Arguments:

    hDlg           - Identifies the wizard page
    pWizardUserMem - pointer to WIZARDUSERMEM struct

Return Value:

    none

--*/
{

    BOOL bEnable;

    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADD),
                 GetCurrentRecipient(hDlg,pWizardUserMem, NULL) == 0);

    bEnable = (ListView_GetNextItem(GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST),
                                    -1, LVNI_ALL | LVNI_SELECTED) != -1);

    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_EDIT), bEnable);
}

DWORD
GetControlRect(
    HWND  hCtrl,
    PRECT pRc
)
/*++

Routine Description:

    Retrieves the dimensions of the dialog control in dialog coordinates

Arguments:

    hCtrl    [in]  - Identifies the dialog control
    pRc      [out] - control dimensions rect

Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    POINT pt;

    if(!pRc || !hCtrl)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the control rect
    //
    if(!GetWindowRect(hCtrl, pRc))
    {
        dwRes = GetLastError();
        Error(("GetWindowRect failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }

    //
    // Convert the control dimensions to the dialog coordinates
    //
    pt.x = pRc->left;
    pt.y = pRc->top;
    if(!ScreenToClient (GetParent(hCtrl), &pt))
    {
        dwRes = GetLastError();
        Error(("ScreenToClient failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }
    pRc->left = pt.x;
    pRc->top  = pt.y;

    pt.x = pRc->right;
    pt.y = pRc->bottom;
    if(!ScreenToClient (GetParent(hCtrl), &pt))
    {
        dwRes = GetLastError();
        Error(("ScreenToClient failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }
    pRc->right  = pt.x;
    pRc->bottom = pt.y;

    return dwRes;

} // GetControlRect


INT_PTR
RecipientWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page: selecting the fax recipient

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    PWIZARDUSERMEM    pWizardUserMem;
    DWORD       countryId = 0;
    INT         cmd;
    NMHDR      *pNMHdr;
    HANDLE hEditControl;
    DWORD               dwMessagePos;
    static HMENU        hMenu = NULL;
    // hReciptMenu is the handle to the receipt menu
    static HMENU        hReciptMenu;
    BOOL                bEnable;

    //
    // Maximum length for various text fields
    //
    static INT  textLimits[] =
    {
        IDC_CHOOSE_NAME_EDIT,       64,
        IDC_CHOOSE_AREA_CODE_EDIT,  11,
        IDC_CHOOSE_NUMBER_EDIT,     51,
        0
    };
    //
    // Handle common messages shared by all wizard pages
    //
    if (! (pWizardUserMem = CommonWizardProc(hDlg,
                                             message,
                                             wParam,
                                             lParam,
                                             PSWIZB_BACK | PSWIZB_NEXT)))
    {
         return FALSE;
    }

    switch (message)
    {

    case WM_DESTROY:
        if (hMenu)
        {
            DestroyMenu (hMenu);
            hMenu = NULL;
        }
        break;

    case WM_INITDIALOG:
        //
        // check if the user has run the wizard before so they can fill in the coverpage info.
        //
        if (!(hMenu = LoadMenu(ghInstance,  MAKEINTRESOURCE(IDR_MENU) )))
        {
            Error(("LoadMenu failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }
        else if (!(hReciptMenu = GetSubMenu(hMenu,0)))
        {
            Error(("GetSubMenu failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }
        LimitTextFields(hDlg, textLimits);
        //
        // Initialize the recipient list view
        //
        if (!GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST))
        {
            Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
        }
        else
        {
            if (!InitRecipientListView(GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
            {
                Warning(("InitRecipientListView failed\n"));
            }
        }

        // Disable the IME for the area code edit control.

        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_AREA_CODE_EDIT );

        if ( hEditControl != NULL )
        {
            ImmAssociateContext( hEditControl, (HIMC)0 );
        }
        // Disable the IME for the fax phone number edit control.
        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_NUMBER_EDIT );

        if ( hEditControl != NULL )
        {
           ImmAssociateContext( hEditControl, (HIMC)0 );
        }


        if(IsWindowRTL(hDlg))
        {
            //
            // Area code field always should be on the left side of the fax number field
            // So, we switch them when the layout is RTL
            //
            int   nShift;
            RECT  rcNum, rcCode;
            HWND  hNum,  hCode;
            DWORD dwRes;

            //
            // A numeric edit control should be LTR
            //
            SetLTREditDirection(hDlg, IDC_CHOOSE_NUMBER_EDIT);
            SetLTREditDirection(hDlg, IDC_CHOOSE_AREA_CODE_EDIT);

            //
            // Calculate the area code shift value
            //
            hNum  = GetDlgItem( hDlg, IDC_CHOOSE_NUMBER_EDIT );
            dwRes = GetControlRect(hNum, &rcNum);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }

            hCode = GetDlgItem( hDlg, IDC_CHOOSE_AREA_CODE_EDIT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }

            nShift = rcNum.left - rcCode.left;

            //
            // Move the fax number on the place of the crea code
            //
            SetWindowPos(hNum, 0,
                         rcCode.right,
                         rcNum.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code
            //
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code left bracket
            //
            hCode = GetDlgItem( hDlg, IDC_BRACKET_LEFT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code right bracket
            //
            hCode = GetDlgItem( hDlg, IDC_BRACKET_RIGHT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        } rtl_exit:
        //
        // Initialize the list of countries
        // Init country combo box and try to identify the country
        //
        Assert(pWizardUserMem->pCountryList != NULL);

        InitCountryListBox(pWizardUserMem->pCountryList,
                           GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                           GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                           NULL,
                           countryId,
                           TRUE);

        CalcRecipientButtonsState(hDlg, pWizardUserMem);

        if (pWizardUserMem->isLocalPrinter)
        {
            //
            // On local printers, we have dialing rules capabilities
            // Init the combo-box of dialing rules
            //
            LocationListInit (hDlg, pWizardUserMem);
        }
        else
        {
            //
            // When faxing remotely, we never use dialing rules (security issue with credit card info).
            // Hide the dialing rules combo-box and button
            //
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES), FALSE);
            ShowWindow (GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES), SW_HIDE);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES), FALSE);
            ShowWindow (GetDlgItem(hDlg, IDC_DIALING_RULES), SW_HIDE);
        }
        //
        // Restore the 'Use dialing rules' checkbox state
        //
        if (pWizardUserMem->lpFaxSendWizardData->bUseDialingRules)
        {
            if (!CheckDlgButton(hDlg, IDC_USE_DIALING_RULE, BST_CHECKED))
            {
                Warning(("CheckDlgButton(IDC_USE_DIALING_RULE) failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            //
            // 'Use dialing rule' is off - this implies 'Dial as entered'
            //
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),  FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES),   FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES),         FALSE);
        }
        break;

    case WM_CONTEXTMENU:
        {
            //
            // Also handle keyboard-originated context menu (<Shift>+F10 or VK_APP)
            //
            HWND hListWnd;
            if (!(hListWnd = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
            {
                Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                break;
            }
            if (hListWnd != GetFocus())
            {
                //
                // Only show context sensitive menu if the focus is on the list control
                //
                break;
            }
            if (ListView_GetSelectedCount(hListWnd) != 1)
            {
                //
                // No item is selected in the list control ==> no menu
                //
                break;
            }
            //
            // Get the cursor position
            //
            dwMessagePos = GetMessagePos();
            //
            // Display the document context menu
            //
            if (!TrackPopupMenu(hReciptMenu,
                                TPM_LEFTALIGN | TPM_LEFTBUTTON,
                                GET_X_LPARAM (dwMessagePos),
                                GET_Y_LPARAM (dwMessagePos),
                                0,
                                hDlg,
                                NULL))
            {
                Warning(("TrackPopupMenu failed. ec = 0x%X\n",GetLastError()));
            }
            break;
        }


    case WM_NOTIFY:

        pNMHdr = (LPNMHDR ) lParam;

        Assert(pNMHdr);

        switch (pNMHdr->code)
        {

        case LVN_KEYDOWN:

            if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST) &&
                ((LV_KEYDOWN *) pNMHdr)->wVKey == VK_DELETE)
            {
                if (!RemoveRecipient(hDlg, pWizardUserMem))
                {
                    Warning(("RemoveRecipient failed\n"));
                }
            }
            break;

        case LVN_ITEMCHANGED:

            CalcRecipientButtonsState(hDlg, pWizardUserMem);

            break;

        case PSN_WIZNEXT:

            pWizardUserMem->lpFaxSendWizardData->bUseDialingRules =
                (IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULE) == BST_CHECKED);

            if (! ValidateRecipients(hDlg, pWizardUserMem))
            {
                //
                // Validate the list of recipients and prevent the user
                // from advancing to the next page if there is a problem
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }
            break;

        case PSN_SETACTIVE:
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
            break;
        }

        return FALSE;

    case WM_COMMAND:

        cmd = GET_WM_COMMAND_CMD(wParam, lParam);

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {

        case IDC_DIALING_RULES:
            //
            // Use pressed the 'Dialing rules...' button
            //
            DoTapiProps(hDlg);
            LocationListInit(hDlg, pWizardUserMem);
            break;

        case IDC_COMBO_DIALING_RULES:

            if (CBN_SELCHANGE == cmd)
            {
                LocationListSelChange(hDlg, pWizardUserMem);
            }
            break;

        case IDC_USE_DIALING_RULE:
            pWizardUserMem->lpFaxSendWizardData->bUseDialingRules =
                            (IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULE) == BST_CHECKED);

            bEnable = pWizardUserMem->lpFaxSendWizardData->bUseDialingRules;
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),  bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES),  bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES),  bEnable);

            CalcRecipientButtonsState(hDlg, pWizardUserMem);

            break;

        case IDC_CHOOSE_COUNTRY_COMBO:

            if (cmd == CBN_SELCHANGE)
            {

                //
                // Update the area code edit box if necessary
                //

                if (!(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO)) ||
                    !(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT)))
                {
                    Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                }
                else
                {
                    SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                                            GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                                            pWizardUserMem->pCountryList);
                }

                CalcRecipientButtonsState(hDlg, pWizardUserMem);

            }
            break;

        case IDC_CHOOSE_NAME_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }

            break;

        case IDC_CHOOSE_AREA_CODE_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }
            break;

        case IDC_CHOOSE_NUMBER_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }

            break;

        case IDC_CHOOSE_ADDRBOOK:

            if (!DoAddressBook(hDlg, pWizardUserMem))
            {
                Error(("DoAddressBook failed\n"));
            }
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
            break;


        case IDC_CHOOSE_ADD:

            if ((cmd = AddRecipient(hDlg, pWizardUserMem)) != 0)
            {

                if (cmd > 0)
                    DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, cmd);
                else
                    MessageBeep(MB_OK);

            }
            else
            {
                SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));

                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }
            break;
         case IDC_CHOOSE_REMOVE:
            RemoveRecipient(hDlg, pWizardUserMem);
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
            SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE));
            break;
         case IDC_CHOOSE_EDIT:
            EditRecipient(hDlg, pWizardUserMem);
            SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_EDIT));
            break;
        }

        switch (LOWORD(wParam))
        {

            case IDM_RECIPT_DELETE:
                RemoveRecipient(hDlg, pWizardUserMem);
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
                break;
            case IDM_RECIPT_EDIT:
                EditRecipient(hDlg, pWizardUserMem);
                break;
        }
        break;
    }

    return TRUE;
}



VOID
ValidateSelectedCoverPage(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    If a cover page is selected, then do the following:
        if the cover page file is a link resolve it
        check if the cover page file contains note/subject fields

Arguments:

    pWizardUserMem - Points to user mode memory structure

Return Value:

    NONE

--*/

{
    TCHAR       filename[MAX_PATH];
    COVDOCINFO  covDocInfo;
    DWORD       ec;

    if (ResolveShortcut(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, filename))
    {
        _tcscpy(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, filename);
    }
    Verbose(("Cover page selected: %ws\n", pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName));
    ec = RenderCoverPage(NULL,
        NULL,
        NULL,
        pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
        &covDocInfo,
        FALSE);

    if (ERROR_SUCCESS == ec)
    {
        pWizardUserMem->noteSubjectFlag = covDocInfo.Flags;
        pWizardUserMem->cpPaperSize = covDocInfo.PaperSize;
        pWizardUserMem->cpOrientation = covDocInfo.Orientation;
    }
    else
    {
        Error(("Cannot examine cover page file '%ws': %d\n",
               pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
               ec));
    }
}





INT_PTR
CoverPageWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the second wizard page:
    selecting cover page and setting other fax options

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
#define PREVIEW_BITMAP_WIDTH    (850)
#define PREVIEW_BITMAP_HEIGHT   (1098)

    static INT  textLimits[] = {

        IDC_CHOOSE_CP_SUBJECT,   256,
        IDC_CHOOSE_CP_NOTE,   8192,
        0
    };

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    HWND            hwnd;
    RECT            rc;
    double          dRatio;
    LONG_PTR        numOfCoverPages = 0;

    HDC             hDC = NULL;
    TCHAR           szCoverFileName[MAX_PATH];

    //
    // Handle common messages shared by all wizard pages
    //
    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
          return FALSE;

    //
    // Handle anything specific to the current wizard page
    //

    switch (message) {

    case WM_INITDIALOG:
        //
        // Measure the mini-preview current (portrait) dimensions
        //

        g_bPreviewRTL = IsWindowRTL(hDlg);

        SetLTRControlLayout(hDlg, IDC_STATIC_CP_PREVIEW);

        GetControlRect(GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), &rc);
        g_dwMiniPreviewPortraitWidth  = abs(rc.right - rc.left) + 1;
        g_dwMiniPreviewPortraitHeight = rc.bottom - rc.top + 1;
        //
        // By default, the mini-preview is set to portrait
        //
        g_wCurrMiniPreviewOrientation = DMORIENT_PORTRAIT;
        //
        // Now, derive the landscape dimensions from the portrait ones
        //
        g_dwMiniPreviewLandscapeWidth = (DWORD)((double)1.2 * (double)g_dwMiniPreviewPortraitWidth);
        dRatio = (double)(g_dwMiniPreviewPortraitWidth) / (double)(g_dwMiniPreviewPortraitHeight);
        Assert (dRatio < 1.0);
        g_dwMiniPreviewLandscapeHeight = (DWORD)((double)(g_dwMiniPreviewLandscapeWidth) * dRatio);
        //
        // Initialize the list of cover pages
        //
        if (WaitForSingleObject( pWizardUserMem->hCPEvent, INFINITE ) != WAIT_OBJECT_0)
        {
            Error(("WaitForSingleObject failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);

            //
            //  We cannot wait for this flag to be set, so make it default TRUE
            //
            pWizardUserMem->ServerCPOnly = TRUE;
        }

        pWizardUserMem->pCPInfo = AllocCoverPageInfo(pWizardUserMem->lptstrServerName,
                                                     pWizardUserMem->lptstrPrinterName,
                                                     pWizardUserMem->ServerCPOnly);
        if (pWizardUserMem->pCPInfo)
        {

            InitCoverPageList(pWizardUserMem->pCPInfo,
                              GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                              pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);
        }



        //
        // Indicate whether cover page should be sent
        //

        numOfCoverPages = SendDlgItemMessage(hDlg, IDC_CHOOSE_CP_LIST, CB_GETCOUNT, 0, 0);
        if ( numOfCoverPages <= 0)
        {
            pWizardUserMem->bSendCoverPage  = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_CHECK), FALSE);
        }

        //
        // make sure the user selects a coverpage if this is the fax send utility
        //
        if (pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE)
        {
            pWizardUserMem->bSendCoverPage  = TRUE;
            // hide the checkbox
            CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, BST_INDETERMINATE );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_CHECK), FALSE);
            // If there are no cover pages, we should not allow to proceed. So we flag it here
            if ( numOfCoverPages <= 0)
            {
                pWizardUserMem->bSendCoverPage = FALSE;
            }
            else
            {
                // In case there are cover pages, then
                pWizardUserMem->bSendCoverPage = TRUE;
            }
        }

        CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, pWizardUserMem->bSendCoverPage );

        if (!EnableCoverDlgItems(pWizardUserMem,hDlg))
        {
            Error(("Failed to enable/disable note and subject field by selected cover page on Init."));
        }

        LimitTextFields(hDlg, textLimits);

        g_hwndPreview = GetDlgItem(hDlg,IDC_STATIC_CP_PREVIEW);
        //
        // Subclass the static control we use for preview. This allows us to handle its WM_PAINT messages
        //
        pWizardUserMem->wpOrigStaticControlProc = (WNDPROC) SetWindowLongPtr(g_hwndPreview,GWLP_WNDPROC, (LONG_PTR) PreviewSubclassProc);
        //
        // Allow the preview control to have access to the WizardUserMem structure
        //
        g_pWizardUserMem = pWizardUserMem;
        //
        // Simulate cover page selection
        //
        SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_CHOOSE_CP_LIST,LBN_SELCHANGE),0);

        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_CHOOSE_CP_CHECK:
            if (!EnableCoverDlgItems(pWizardUserMem,hDlg)) {
                    Error(("Failed to enable/disable note and subject field on CP_CHECK."));
            }
            break;
        case IDC_CHOOSE_CP_LIST:
            if (HIWORD(wParam)==LBN_SELCHANGE) {
                //
                // Disable the subject and note edit boxes if the cover page does not contain the fields
                //
                if (!EnableCoverDlgItems(pWizardUserMem,hDlg)) {
                    Error(("Failed to enable/disable note and subject field by selected cover page."));
                }
                //
                // Get the full path to the cover page so we can get its information.
                //
                if (GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                         GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                         pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, //full path
                         szCoverFileName, //file name
                         &pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->bServerBased) == CB_ERR)
                {
                    Warning(("GetSelectedCoverPage failed or no *.COV files"));
                }

                InvalidateRect(g_hwndPreview, NULL, TRUE);
            }

            break;

        case IDC_CHOOSE_CP_USER_INFO:
            if (! (hwnd = GetDlgItem(hDlg, IDC_CHOOSE_CP_USER_INFO))) {
                Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                break;
            }
            DialogBoxParam(
                (HINSTANCE) ghInstance,
                MAKEINTRESOURCE( IDD_WIZARD_USERINFO ),
                hwnd,
                FaxUserInfoProc,
                (LPARAM) pWizardUserMem
                );
            break;


        };


        break;

    case WM_NOTIFY:

        if ((pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) && (!pWizardUserMem->bSendCoverPage)) {
            // Here is a good place to add pop-up or something for the user.
            PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK);
        }

        switch (((NMHDR *) lParam)->code)
        {
        case PSN_WIZNEXT:

            //
            // Remember the cover page settings selected
            //

            pWizardUserMem->noteSubjectFlag = 0;
            pWizardUserMem->cpPaperSize = 0;
            pWizardUserMem->cpOrientation = 0;
            pWizardUserMem->bSendCoverPage  = IsDlgButtonChecked(hDlg, IDC_CHOOSE_CP_CHECK);


            //
            // Get the full path to the cover page so we can get its information.
            //
            if (GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                     GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                     pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, //full path
                     szCoverFileName, //file name
                     &pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->bServerBased) == CB_ERR)
            {
                Warning(("GetSelectedCoverPage failed or no *.COV files"));
            }


            if (pWizardUserMem->bSendCoverPage )
            {
                //  if the cover page file is a link resolve it
                //  check if the cover page file contains note/subject fields
                //
                ValidateSelectedCoverPage(pWizardUserMem);
            }
            else
            {
                 //
                 // pWizardUserMem->coverPage must be set to "" when no cover page is to be sent
                 //
                 _tcscpy(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,TEXT(""));
            }



            //
            // Collect the current values of other dialog controls
            //

            if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
                MemFree(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject);
            if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)
                MemFree(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote);
            pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
            pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE));


            //
            // If the current application is "Send Note" utility,
            // then the subject or note field must not be empty.
            //
            if((pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) &&
              ((pWizardUserMem->noteSubjectFlag & COVFP_NOTE) ||
               (pWizardUserMem->noteSubjectFlag & COVFP_SUBJECT)))
            {
                if(!pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote &&
                   !pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
                {
                    DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_NOTE_SUBJECT_EMPTY);

                    if(pWizardUserMem->noteSubjectFlag & COVFP_SUBJECT)
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
                    }
                    else
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE));
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }
            }
            break;
        }
        break;

    }

    return TRUE;
}


BOOL
ValidateReceiptInfo(
                HWND    hDlg
                )
{
    TCHAR tcBuffer[MAX_STRING_LEN];
    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT))
        goto ok;

    if (!IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_MSGBOX) &&
        !IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL))
    {
        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECEIPT_FORM );
        return FALSE;
    }

    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL) &&
       (GetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, tcBuffer, MAX_STRING_LEN) == 0))
    {
        if(GetLastError() != ERROR_SUCCESS)
        {
            Error(("GetDlgItemText failed. ec = 0x%X\n",GetLastError()));
        }

        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECEIPT_EMAIL_ADD );
        SetFocus(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT));
        return FALSE;
    }

ok:
    return TRUE;
}

INT_PTR
FaxOptsWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page: entering subject and note information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    BOOL            bEnabled;
    SYSTEMTIME      st;
    HANDLE          hFax = NULL;


    static HWND     hTimeControl;


    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
        return FALSE;


    switch (message)
    {
    case WM_INITDIALOG:

        hTimeControl = GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_SENDTIME);
        Assert(hTimeControl);
        //
        // restore time to send controls
        //
        cmdId = (pWizardUserMem->lpInitialData->dwScheduleAction == JSA_DISCOUNT_PERIOD) ? IDC_WIZ_FAXOPTS_DISCOUNT :
                (pWizardUserMem->lpInitialData->dwScheduleAction == JSA_SPECIFIC_TIME  ) ? IDC_WIZ_FAXOPTS_SPECIFIC :
                IDC_WIZ_FAXOPTS_ASAP;

        if (!CheckDlgButton(hDlg, cmdId, TRUE))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }
        GetLocalTime(&st);


        EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
        if (pWizardUserMem->dwFlags & FSW_USE_SCHEDULE_ACTION) {
            st.wHour = pWizardUserMem->lpInitialData->tmSchedule.wHour;
            st.wMinute = pWizardUserMem->lpInitialData->tmSchedule.wMinute;
        }
        else
        {
            // use local time
        }
        if (!DateTime_SetSystemtime( hTimeControl, GDT_VALID, &st ))
        {
            Warning(("DateTime_SetFormat failed\n"));
        }

        //
        // Init priority
        //

        //
        // Low
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT) == FAX_ACCESS_SUBMIT);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_LOW), bEnabled);

        //
        // Normal
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_NORMAL) == FAX_ACCESS_SUBMIT_NORMAL);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_NORMAL), bEnabled);
        if (bEnabled)
        {
            //
            // Normal is our default priority
            //
            CheckDlgButton (hDlg, IDC_WIZ_FAXOPTS_PRIORITY_NORMAL, BST_CHECKED);
        }
        else
        {
            Assert ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT) == FAX_ACCESS_SUBMIT);
            //
            // Low is enabled - use it as default
            //
            CheckDlgButton (hDlg, IDC_WIZ_FAXOPTS_PRIORITY_LOW, BST_CHECKED);
        }

        //
        // High
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_HIGH) == FAX_ACCESS_SUBMIT_HIGH);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_HIGH), bEnabled);

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            //
            //
            // retrieve the sending time
            //
            pWizardUserMem->lpFaxSendWizardData->dwScheduleAction =
                                     IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_DISCOUNT) ? JSA_DISCOUNT_PERIOD :
                                     IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_SPECIFIC) ? JSA_SPECIFIC_TIME :
                                     JSA_NOW;

            if (pWizardUserMem->lpFaxSendWizardData->dwScheduleAction == JSA_SPECIFIC_TIME) {
#ifdef DEBUG
                DWORD rVal;
                TCHAR TimeBuffer[128];
#endif
                //
                // get specific time
                //

                if (DateTime_GetSystemtime(hTimeControl,
                                           &pWizardUserMem->lpFaxSendWizardData->tmSchedule) == GDT_ERROR )
                {
                    Error(("DateTime_GetSystemtime failed\n"));
                    return FALSE;
                }



#ifdef DEBUG
                if (!(rVal = GetY2KCompliantDate(
                    LOCALE_USER_DEFAULT,
                    0,
                    &pWizardUserMem->lpFaxSendWizardData->tmSchedule,
                    TimeBuffer,
                    ARR_SIZE(TimeBuffer)
                    )))
                {
                    Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
                    return FALSE;
                }


                TimeBuffer[rVal - 1] = TEXT(' ');

                if(!FaxTimeFormat(
                                    LOCALE_USER_DEFAULT,
                                    0,
                                    &pWizardUserMem->lpFaxSendWizardData->tmSchedule,
                                    NULL,
                                    &TimeBuffer[rVal],
                                    ARR_SIZE(TimeBuffer)
                                  ))
                {
                    Error(("FaxTimeFormat: failed. ec = 0X%x\n",GetLastError()));
                    return FALSE;
                }

                Verbose(("faxui - Fax Send time %ws", TimeBuffer));
#endif
            }

            //
            // save priority
            //
            pWizardUserMem->lpFaxSendWizardData->Priority =
                IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_HIGH)   ? FAX_PRIORITY_TYPE_HIGH   :
                IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_NORMAL) ? FAX_PRIORITY_TYPE_NORMAL :
                FAX_PRIORITY_TYPE_LOW;

            if(0 == pWizardUserMem->dwSupportedReceipts)
            {
                //
                // skip notifications page
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_CONGRATS);
                return TRUE;
            }
        }

        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_WIZ_FAXOPTS_SPECIFIC:
        case IDC_WIZ_FAXOPTS_DISCOUNT:
        case IDC_WIZ_FAXOPTS_ASAP:
            EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
            break;
        };

        break;
    default:
        return FALSE;
    } ;
    return TRUE;
}

void
CalcReceiptButtonsState(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
)
/*++

Routine Description:

    Calculates receipt page button state

Arguments:

    hDlg           - Identifies the wizard page
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    none

--*/

{
    BOOL     bMailReceipt;

    Assert(hDlg);
    Assert(pWizardUserMem);

    if((IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT) != BST_CHECKED) &&
       (SizeOfRecipientList(pWizardUserMem) > 1))
    {
        //
        // wish receipt, multiple recipients
        //
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT),  TRUE);
    }
    else
    {
        CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT, BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT),  FALSE);
    }

    bMailReceipt = IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL) == BST_CHECKED;

    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ADDRBOOK),    bMailReceipt);
    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT),  bMailReceipt);

    if (bMailReceipt)
    {
        //
        // Receipt by e-mail
        //
        if (! ((SizeOfRecipientList(pWizardUserMem) > 1)       &&
               (pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) &&
               IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT)
              )
           )
        {
            //
            // NOT the case of (multiple recipients AND no attachment AND single receipt)
            //
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX),  TRUE);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_HIDE);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_NOTE_ICON), SW_HIDE);
        }
        else
        {
            //
            // The case of (multiple recipients AND no attachment AND single receipt)
            //
            CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_ATTACH_FAX, BST_UNCHECKED);
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX),  FALSE);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_SHOW);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_NOTE_ICON), SW_SHOW);
        }
    }
    else
    {
        //
        // No receipt by e-mail
        //
        ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_HIDE);
        ShowWindow (GetDlgItem (hDlg, IDC_STATIC_NOTE_ICON), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX), FALSE);
    }
}


INT_PTR
FaxReceiptWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page: receipt information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    LPTSTR          lptstrEmailAddress;
    DWORD           dwReceiptDeliveryType;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
    {
        return FALSE;
    }

    switch (message)
    {

    case WM_INITDIALOG:

        dwReceiptDeliveryType = pWizardUserMem->lpInitialData->dwReceiptDeliveryType;
        //
        // data is initializated without validation of correctness
        // it is up to caller to check that the receipt data is correct and consistent
        //

        //
        // no receipt
        //
        if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT,
                       (dwReceiptDeliveryType == DRT_NONE) ? BST_CHECKED : BST_UNCHECKED))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }
        //
        // single receipt
        //
        if((dwReceiptDeliveryType != DRT_NONE) && (SizeOfRecipientList(pWizardUserMem) > 1))
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT,
                           (dwReceiptDeliveryType & DRT_GRP_PARENT) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT), FALSE);
        }

        //
        // message box receipt
        //
        if(pWizardUserMem->dwSupportedReceipts & DRT_MSGBOX)
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_MSGBOX,
                           (dwReceiptDeliveryType & DRT_MSGBOX) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_MSGBOX), FALSE);

            if(dwReceiptDeliveryType & DRT_MSGBOX)
            {
                //
                // If the previous choice was inbox
                // but by now this option is disabled
                // check no receipt option
                //
                CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT, BST_CHECKED);
            }
        }

        //
        // email receipt
        //
        if(pWizardUserMem->dwSupportedReceipts & DRT_EMAIL)
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_EMAIL,
                           (dwReceiptDeliveryType & DRT_EMAIL) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL), FALSE);

            if(dwReceiptDeliveryType & DRT_EMAIL)
            {
                //
                // If the previous choice was email
                // but by now this option is disabled
                // check no receipt option
                //
                CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT, BST_CHECKED);
            }
        }

        if (pWizardUserMem->lpInitialData->szReceiptDeliveryAddress && (dwReceiptDeliveryType & DRT_EMAIL))
        {
            if (!SetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT,
                           pWizardUserMem->lpInitialData->szReceiptDeliveryAddress))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        }

        if (dwReceiptDeliveryType & DRT_ATTACH_FAX)
        {
            //
            // Initial data has 'Attach fax' option set - check the checkbox
            //
            if (!CheckDlgButton(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX, BST_CHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }

        CalcReceiptButtonsState(hDlg, pWizardUserMem);

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            if (! ValidateReceiptInfo(hDlg))
            {
                //
                // Validate the list of recipients and prevent the user
                // from advancing to the next page if there is a problem
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }

            pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType = DRT_NONE;

            if (!IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT))
            {
                TCHAR tcBuffer[MAX_STRING_LEN];
                if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT))
                {
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_GRP_PARENT;
                }
                if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_MSGBOX))
                {
                    DWORD dwBufSize = ARR_SIZE (tcBuffer);
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_MSGBOX;
                    if (!GetComputerName (tcBuffer, &dwBufSize))
                    {
                        Error(("GetComputerName failed (ec=%ld)\n", GetLastError()));
                        return FALSE;
                    }
                    if (!(pWizardUserMem->lpFaxSendWizardData->szReceiptDeliveryAddress = StringDup(tcBuffer)))
                    {
                        Error(("Allocation of szReceiptDeliveryProfile failed!!!!\n"));
                        return FALSE;
                    }
                }
                else if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL))
                {
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_EMAIL;
                    GetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, tcBuffer, MAX_STRING_LEN);
                    if (!(pWizardUserMem->lpFaxSendWizardData->szReceiptDeliveryAddress = StringDup(tcBuffer)))
                    {
                        Error(("Allocation of szReceiptDeliveryProfile failed!!!!\n"));
                        return FALSE;
                    }
                    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_ATTACH_FAX))
                    {
                        pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_ATTACH_FAX;
                    }
                }
            }
        }

        if (((NMHDR *) lParam)->code == PSN_SETACTIVE)
        {
            CalcReceiptButtonsState(hDlg, pWizardUserMem);
        }
        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam))
        {

        case IDC_WIZ_FAXOPTS_NONE_RECEIPT:
        case IDC_WIZ_FAXOPTS_EMAIL:
        case IDC_WIZ_FAXOPTS_MSGBOX:
        case IDC_WIZ_FAXOPTS_GRP_PARENT:

            CalcReceiptButtonsState(hDlg, pWizardUserMem);

            break;

        case IDC_WIZ_FAXOPTS_ADDRBOOK:
            if (lptstrEmailAddress = GetEMailAddress(hDlg,pWizardUserMem))
            {
                SetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, lptstrEmailAddress);
                MemFree(lptstrEmailAddress);
            }
            break;
        };

        break;

    default:
        return FALSE;
    } ;
    return TRUE;
}


#define FillEditCtrlWithInitialUserInfo(nIDDlgItem,field)   \
    if (pWizardUserMem->lpInitialData->lpSenderInfo->field && \
        !IsEmptyString(pWizardUserMem->lpInitialData->lpSenderInfo->field)) { \
        SetDlgItemText(hDlg, nIDDlgItem, pWizardUserMem->lpInitialData->lpSenderInfo->field); \
    }

#define FillEditCtrlWithSenderWizardUserInfo(nIDDlgItem,field)  \
    if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field && \
        !IsEmptyString(pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field)) { \
        SetDlgItemText(hDlg, nIDDlgItem, pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field); \
    }

#define FillUserInfoFromEditCrtl(nIDDlgItem,field)                                          \
            tcBuffer[0] = 0;                                                                \
            GetDlgItemText(hDlg, nIDDlgItem, tcBuffer, MAX_STRING_LEN);                     \
            pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field = StringDup(tcBuffer); \
            if (!pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field)                  \
            {                                                                               \
                Error(("Memory allocation failed"));                                        \
            }


INT_PTR
CALLBACK
FaxUserInfoProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the info page: sender information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    //
    // Maximum length for various text fields
    //

    PWIZARDUSERMEM        pWizardUserMem;
    FAX_PERSONAL_PROFILE* pSenderInfo;
    TCHAR                 tcBuffer[MAX_STRING_LEN];

    static INT  textLimits[] = {
        IDC_WIZ_USERINFO_FULLNAME,      MAX_USERINFO_FULLNAME,
        IDC_WIZ_USERINFO_FAX_NUMBER,    MAX_USERINFO_FAX_NUMBER,
        IDC_WIZ_USERINFO_COMPANY,       MAX_USERINFO_COMPANY,
        IDC_WIZ_USERINFO_ADDRESS,       MAX_USERINFO_ADDRESS,
        IDC_WIZ_USERINFO_TITLE,         MAX_USERINFO_TITLE,
        IDC_WIZ_USERINFO_DEPT,          MAX_USERINFO_DEPT,
        IDC_WIZ_USERINFO_OFFICE,        MAX_USERINFO_OFFICE,
        IDC_WIZ_USERINFO_HOME_PHONE,    MAX_USERINFO_HOME_PHONE,
        IDC_WIZ_USERINFO_WORK_PHONE,    MAX_USERINFO_WORK_PHONE,
        IDC_WIZ_USERINFO_BILLING_CODE,  MAX_USERINFO_BILLING_CODE,
        IDC_WIZ_USERINFO_MAILBOX,       MAX_USERINFO_MAILBOX,
        0
    };


    switch (message) {

    case WM_INITDIALOG:

        pWizardUserMem = (PWIZARDUSERMEM) lParam;
        Assert(pWizardUserMem);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        LimitTextFields(hDlg, textLimits);

        Assert(pWizardUserMem->lpInitialData);
        Assert(pWizardUserMem->lpInitialData->lpSenderInfo);
        Assert(pWizardUserMem->lpFaxSendWizardData->lpSenderInfo);

        // init Sender Name
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_FULLNAME, lptstrName);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_FULLNAME,  lptstrName);
        }

        //
        // init Sender Fax Number
        //
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_FAX_NUMBER);

        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrFaxNumber)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_FAX_NUMBER, lptstrFaxNumber);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_FAX_NUMBER,lptstrFaxNumber);
        }

        // init Sender Company
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrCompany)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_COMPANY,  lptstrCompany);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_COMPANY,lptstrCompany);
        }

        // init Sender Address
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrStreetAddress)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_ADDRESS,  lptstrStreetAddress);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_ADDRESS,lptstrStreetAddress);
        }

        // init Sender Title
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrTitle)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_TITLE,lptstrTitle);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_TITLE, lptstrTitle);
        }

        // init Sender Department
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrDepartment)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_DEPT,lptstrDepartment);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_DEPT,lptstrDepartment);
        }

        // init Sender Office Location
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficeLocation)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_OFFICE,lptstrOfficeLocation);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_OFFICE,lptstrOfficeLocation);
        }

        // init Sender Home Phone
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_HOME_PHONE);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrHomePhone)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_HOME_PHONE,lptstrHomePhone);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_HOME_PHONE,lptstrHomePhone);
        }

        // init Sender Office Phone
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_WORK_PHONE);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficePhone)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_WORK_PHONE,lptstrOfficePhone);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_WORK_PHONE,lptstrOfficePhone);
        }

        // init Sender Billing Code
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_BILLING_CODE,lptstrBillingCode);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_BILLING_CODE,lptstrBillingCode);
        }

        // init Sender Internet Mail
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_MAILBOX);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrEmail)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_MAILBOX,lptstrEmail);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_MAILBOX,lptstrEmail);
        }

        if (!CheckDlgButton(hDlg, IDC_USER_INFO_JUST_THIS_TIME, !pWizardUserMem->lpFaxSendWizardData->bSaveSenderInfo))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }

        return TRUE;

    case WM_COMMAND:
        switch(LOWORD( wParam ))
        {
            case IDOK:
                pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
                Assert(pWizardUserMem);
                pSenderInfo = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo;

                //
                // free sender fields except address
                //
                MemFree(pSenderInfo->lptstrName);
                pSenderInfo->lptstrName = NULL;
                MemFree(pSenderInfo->lptstrFaxNumber);
                pSenderInfo->lptstrFaxNumber = NULL;
                MemFree(pSenderInfo->lptstrCompany);
                pSenderInfo->lptstrCompany = NULL;
                MemFree(pSenderInfo->lptstrTitle);
                pSenderInfo->lptstrTitle = NULL;
                MemFree(pSenderInfo->lptstrDepartment);
                pSenderInfo->lptstrDepartment = NULL;
                MemFree(pSenderInfo->lptstrOfficeLocation);
                pSenderInfo->lptstrOfficeLocation = NULL;
                MemFree(pSenderInfo->lptstrHomePhone);
                pSenderInfo->lptstrHomePhone = NULL;
                MemFree(pSenderInfo->lptstrOfficePhone);
                pSenderInfo->lptstrOfficePhone = NULL;
                MemFree(pSenderInfo->lptstrEmail);
                pSenderInfo->lptstrEmail = NULL;
                MemFree(pSenderInfo->lptstrBillingCode);
                pSenderInfo->lptstrBillingCode = NULL;
                MemFree(pSenderInfo->lptstrStreetAddress);
                pSenderInfo->lptstrStreetAddress = NULL;

                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_FULLNAME,     lptstrName);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_FAX_NUMBER,   lptstrFaxNumber);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_COMPANY,      lptstrCompany);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_TITLE,        lptstrTitle);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_DEPT,         lptstrDepartment);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_OFFICE,       lptstrOfficeLocation);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_HOME_PHONE,   lptstrHomePhone);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_WORK_PHONE,   lptstrOfficePhone);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_BILLING_CODE, lptstrBillingCode);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_MAILBOX,      lptstrEmail);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_ADDRESS,      lptstrStreetAddress);

                pWizardUserMem->lpFaxSendWizardData->bSaveSenderInfo =
                    IsDlgButtonChecked(hDlg, IDC_USER_INFO_JUST_THIS_TIME) != BST_CHECKED;

                EndDialog(hDlg,1);
                return TRUE;

            case IDCANCEL:

                EndDialog( hDlg,0 );
                return TRUE;

        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    case WM_CONTEXTMENU:
        WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);
        return TRUE;

    default:
        return FALSE;
    } ;
    return TRUE;
}




LPTSTR
FormatTime(
    WORD Hour,
    WORD Minute,
    LPTSTR Buffer,
    LPDWORD lpdwBufferSize)
{
    SYSTEMTIME SystemTime;

    ZeroMemory(&SystemTime,sizeof(SystemTime));
    SystemTime.wHour = Hour;
    SystemTime.wMinute = Minute;
    if (!FaxTimeFormat(LOCALE_USER_DEFAULT,
                  TIME_NOSECONDS,
                  &SystemTime,
                  NULL,
                  Buffer,
                  *lpdwBufferSize
                  ))
    {
        Error(("FaxTimeFormat failed. ec = 0x%X\n",GetLastError()));

        //
        //  Indicate about the error
        //
        *lpdwBufferSize = 0;
        Buffer[0] = '\0';

    }

    return Buffer;
}


INT_PTR
FinishWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the last wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM    pWizardUserMem;
    HWND        hPreview;
    TCHAR       TmpTimeBuffer[64];
    TCHAR       TimeBuffer[64] = {0};
    TCHAR       SendTimeBuffer[64];
    TCHAR       NoneBuffer[64];
    TCHAR       CoverpageBuffer[64];
    LPTSTR      Coverpage;
    DWORD       dwBufferSize = 0;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_FINISH)) )
        return FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            //
            // Init recipient list
            //
            if (!InitRecipientListView(GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
            {
                Warning(("InitRecipientListView failed\n"));
            }

            //
            // Apply the print preview option if we where requested and default to show preview
            //
            hPreview = GetDlgItem(hDlg, IDC_WIZ_CONGRATS_PREVIEW_FAX);
            if (pWizardUserMem->dwFlags & FSW_PRINT_PREVIEW_OPTION)
            {
                Button_Enable(hPreview, TRUE);
                ShowWindow(hPreview, SW_SHOW);
            }
            else
            {
                Button_Enable(hPreview, FALSE);
                ShowWindow(hPreview, SW_HIDE);
            }
            return TRUE;
        case WM_COMMAND:
            switch(LOWORD( wParam ))
            {
                case IDC_WIZ_CONGRATS_PREVIEW_FAX:
                    {
                        if (pWizardUserMem->hFaxPreviewProcess)
                        {
                            //
                            // Preview is in progress we can not continue.
                            //
                            ErrorMessageBox(hDlg, IDS_PLEASE_CLOSE_FAX_PREVIEW, MB_ICONINFORMATION);
                        }
                        else
                        {
                            DisplayFaxPreview(
                                hDlg,
                                pWizardUserMem,
                                pWizardUserMem->lpInitialData->lptstrPreviewFile
                                );
                        }

                        return TRUE;
                    }
                    break;
                default:
                    break;

            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR *) lParam)->code)
            {
            case PSN_WIZBACK :
                if(0 == pWizardUserMem->dwSupportedReceipts)
                {
                    //
                    // skip notifications page
                    //
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_FAXOPTS);
                    return TRUE;
                }
                break;
            case PSN_WIZFINISH:
                if (pWizardUserMem->hFaxPreviewProcess)
                {
                    //
                    // Preview is in progress we can not continue.
                    //
                    ErrorMessageBox(hDlg, IDS_PLEASE_CLOSE_FAX_PREVIEW, MB_ICONINFORMATION);

                    //
                    // prevent the propsheet from closing
                    //
                    SetWindowLong(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;

                }
                else
                {
                    return FALSE; // allow the propsheet to close
                }

            case PSN_SETACTIVE:
                ZeroMemory(NoneBuffer,sizeof(NoneBuffer));
                if (!LoadString(ghInstance,
                                IDS_NONE,
                                NoneBuffer,
                                ARR_SIZE(NoneBuffer)))
                {
                    Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                }
                //
                // large title font on last page
                //
                SetWindowFont(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_READY), pWizardUserMem->hLargeFont, TRUE);

                //
                // set the sender name if it exists
                //
                if ( pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName )
                {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName );
                        EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),TRUE);
                } else {
                    if (NoneBuffer[0] != NUL)
                    {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, NoneBuffer );
                        EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),FALSE);
                    }
                }

                //
                // set the recipient name
                //
                if (!ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
                {
                    Warning(("ListView_DeleteAllItems failed\n"));
                }

                if (!FillRecipientListView(pWizardUserMem,GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
                {
                    Warning(("FillRecipientListView failed\n"));
                }


                //
                // when to send
                //
                switch (pWizardUserMem->lpFaxSendWizardData->dwScheduleAction)
                {
                case JSA_SPECIFIC_TIME:
                    if (!LoadString(ghInstance,
                                    IDS_SEND_SPECIFIC,
                                    TmpTimeBuffer,
                                    ARR_SIZE(TmpTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                    dwBufferSize = ARR_SIZE(TimeBuffer);

                    wsprintf(SendTimeBuffer,
                             TmpTimeBuffer,
                             FormatTime(pWizardUserMem->lpFaxSendWizardData->tmSchedule.wHour,
                                        pWizardUserMem->lpFaxSendWizardData->tmSchedule.wMinute,
                                        TimeBuffer,
                                        &dwBufferSize));
                      break;
                case JSA_DISCOUNT_PERIOD:
                    if (!LoadString(ghInstance,
                                    IDS_SEND_DISCOUNT,
                                    SendTimeBuffer,
                                    ARR_SIZE(SendTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                    break;
                case JSA_NOW:
                    if (!LoadString(ghInstance,
                                    IDS_SEND_ASAP,
                                    SendTimeBuffer,
                                    ARR_SIZE(SendTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                };

                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_TIME, SendTimeBuffer );

                //
                // Coverpage
                //
                if (pWizardUserMem->bSendCoverPage ) {
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),TRUE);

                    //
                    // format the coverpage for display to the user
                    //

                    // drop path
                    Coverpage = _tcsrchr(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, FAX_PATH_SEPARATOR_CHR);
                    if (!Coverpage) {
                        Coverpage = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName;
                    } else {
                        Coverpage++;
                    }
                    _tcscpy(CoverpageBuffer,Coverpage);

                    // crop file extension
                    Coverpage = _tcschr(CoverpageBuffer,TEXT(FILENAME_EXT));

                    if (Coverpage && *Coverpage) {
                        *Coverpage = (TCHAR) NUL;
                    }

                    SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, CoverpageBuffer );
                    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject) {
                        if (!SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject ))
                        {
                            Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
                        }
                    } else {
                        if (NoneBuffer[0] != NUL)
                        {

                            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
                            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
                            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );
                        }
                    }
                } else {
                    if (NoneBuffer[0] != NUL)
                    {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, NoneBuffer );
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );
                    }
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
                }
                break;

                default:
                    ;
            }

        default:
            return FALSE;
    } ;

    return TRUE;

}

INT_PTR
WelcomeWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    PWIZARDUSERMEM  pWizardUserMem;
    UINT ResourceString = IDS_ERROR_SERVER_RETRIEVE;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_NEXT)))
            return FALSE;

    switch (message) {

    case WM_INITDIALOG:
        //
        // set the large fonts
        //
        SetWindowFont(GetDlgItem(hDlg,IDC_WIZ_WELCOME_TITLE), pWizardUserMem->hLargeFont, TRUE);

        //
        // show this text only if we're running the send wizard
        //
        if ((pWizardUserMem->dwFlags & FSW_USE_SEND_WIZARD) != FSW_USE_SEND_WIZARD)
        {
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_FAXSEND) );
        }
        else
        {
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_NOFAXSEND) );
        }

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            //
            // tapi is asynchronously initialized, wait for it to finish spinning up.
            //
            if (WaitForSingleObject( pWizardUserMem->hCountryListEvent, INFINITE ) != WAIT_OBJECT_0)
            {
                Error(("WaitForSingleObject failed. ec = 0x%X\n",GetLastError()));
                Assert(FALSE);
                goto close_wizard;
            }

            //
            // Check that pCountryList is filled. Otherwise some error occured, e.g. can not
            // connect to Fax Server or TAPI initialization failed. In this case we show an
            // error pop up and close an application.
            //
            if (pWizardUserMem->dwQueueStates & FAX_OUTBOX_BLOCKED )
            {
                ResourceString = IDS_ERROR_SERVER_BLOCKED;
                goto close_wizard;
            }

            if (!pWizardUserMem->pCountryList)
            {
                ResourceString = IDS_ERROR_SERVER_RETRIEVE;
                goto close_wizard;
            }

            if((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT)        != FAX_ACCESS_SUBMIT           &&
               (pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_NORMAL) != FAX_ACCESS_SUBMIT_NORMAL    &&
               (pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_HIGH)   != FAX_ACCESS_SUBMIT_HIGH)
            {
                ResourceString = IDS_ERROR_NO_SUBMIT_ACCESS;
                goto close_wizard;
            }
        }
    } ;

    return FALSE;

close_wizard:

    ErrorMessageBox(hDlg, ResourceString, MB_ICONSTOP);

    PropSheet_PressButton(((NMHDR *) lParam)->hwndFrom,PSBTN_CANCEL);

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );

    return TRUE;

}



BOOL
GetFakeRecipientInfo( PWIZARDUSERMEM  pWizardUserMem)

/*++

Routine Description:

    Skip send fax wizard and get faked recipient information from the registry

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    TRUE if successful.
    FALSE and last error is qual ERROR_SUCCESS, some of the registry values are missing.
    FALSE and last error is not ERROR_SUCCESS, if error occured.

--*/

{
    LPTSTR  pRecipientEntry;
    DWORD   index;
    TCHAR   buffer[MAX_STRING_LEN];
    BOOL    fSuccess = FALSE;
    HKEY    hRegKey;
    DWORD   dwRes = ERROR_SUCCESS;
    DWORD   dwStringSize;
    LPTSTR  pCoverPage;
    TCHAR* tstrCurrentUserKeyPath = NULL;
    DWORD dwTestsNum;
    const char* strDebugPrefix = "[******REGISTRY HACK******]:";

    Verbose(("%s Send Fax Wizard skipped...\n", strDebugPrefix));

    Assert(pWizardUserMem);

    SetLastError(0);

    if(IsNTSystemVersion())
    {
        Verbose(("%s NT Platform\n", strDebugPrefix));

        dwRes =  FormatCurrentUserKeyPath( REGVAL_KEY_FAKE_TESTS,
                                           &tstrCurrentUserKeyPath);
        if(dwRes != ERROR_SUCCESS)
        {
            Error(("%s FormatCurrentUserKeyPath failed with ec = 0x%X\n",strDebugPrefix,dwRes));
            SetLastError(dwRes);
            return FALSE;
        }
    }
    else
    {
        Verbose(("%s Win9x Platform\n", strDebugPrefix));

        tstrCurrentUserKeyPath = DuplicateString(REGVAL_KEY_FAKE_TESTS);
        if(!tstrCurrentUserKeyPath)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    #ifdef UNICODE
        Verbose(("%s Registry entry - %S\n", strDebugPrefix,tstrCurrentUserKeyPath));
    #else

        Verbose(("%s Registry entry - %s\n", strDebugPrefix,tstrCurrentUserKeyPath));
    #endif


    // Open user registry key
    dwRes = RegOpenKey (  HKEY_LOCAL_MACHINE ,
                          tstrCurrentUserKeyPath,
                          &hRegKey );

    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Failed to open key
        //
        Error(("%s RegOpenKey failed with. ec = 0x%X\n",strDebugPrefix,dwRes));
        MemFree(tstrCurrentUserKeyPath);
        return FALSE;
    }

    MemFree(tstrCurrentUserKeyPath);

    //
    // UserInfo key was successfully openened
    //
    dwTestsNum = GetRegistryDword (hRegKey, REGVAL_FAKE_TESTS_COUNT);
    if (!dwTestsNum)
    {
        Verbose(("%s No tests to execute\n", strDebugPrefix));
        RegCloseKey (hRegKey);
        return FALSE;
    }

    Verbose(("%s %d tests to execute\n",strDebugPrefix, dwTestsNum));

    index = GetRegistryDword (hRegKey, REGVAL_STRESS_INDEX);

    if (index >= dwTestsNum)
    {
        index = 0;
    }

    wsprintf(buffer, TEXT("FakeRecipient%d"), index);

    pRecipientEntry = GetRegistryStringMultiSz (hRegKey,
                                                buffer,
                                                TEXT("NOT FOUND\0"),
                                                &dwStringSize );
    if(!pRecipientEntry || !_tcscmp(pRecipientEntry , TEXT("NOT FOUND")))
    {
        RegCloseKey (hRegKey);
        return FALSE;
    }

    FreeRecipientList(pWizardUserMem);

    pCoverPage = GetRegistryString (hRegKey,
                                    REGVAL_FAKE_COVERPAGE,
                                    TEXT("")
                                    );
    //
    // Update an index so that next time around we'll pick a different fake recipient
    //
    if (++index >= dwTestsNum)
    {
        index = 0;
    }

    SetRegistryDword(hRegKey, REGVAL_STRESS_INDEX, index);
    RegCloseKey(hRegKey);

    //
    // Each fake recipient entry is a REG_MULTI_SZ of the following format:
    //  recipient name #1
    //  recipient fax number #1
    //  recipient name #2
    //  recipient fax number #2
    //  ...
    //

    if(pRecipientEntry)
    {

        __try {

            PRECIPIENT  pRecipient = NULL;
            LPTSTR      pName, pAddress, p = pRecipientEntry;
            pName = pAddress = NULL;

            while (*p) {

                pName = p;
                pAddress = pName + _tcslen(pName);
                pAddress = _tcsinc(pAddress);
                p = pAddress + _tcslen(pAddress);
                p = _tcsinc(p);

                pRecipient = MemAllocZ(sizeof(RECIPIENT));
                if(pRecipient)
                {
                    ZeroMemory(pRecipient,sizeof(RECIPIENT));
                }
                pName = DuplicateString(pName);

                pAddress = DuplicateString(pAddress);

                if (!pRecipient || !pName || !pAddress)
                {

                    Error(("%s Invalid fake recipient information\n", strDebugPrefix));

                    SetLastError(ERROR_INVALID_DATA);

                    MemFree(pRecipient);
                    MemFree(pName);
                    MemFree(pAddress);
                    break;
                }

                pRecipient->pNext = pWizardUserMem->pRecipients;
                pWizardUserMem->pRecipients = pRecipient;
                pRecipient->pName = pName;
                pRecipient->pAddress = pAddress;
            }

        } __finally
        {

            if (fSuccess = (pWizardUserMem->pRecipients != NULL))
            {

                //
                // Determine whether a cover page should be used
                //
                pWizardUserMem->bSendCoverPage = FALSE;
                if ((pCoverPage != NULL) && lstrlen (pCoverPage))
                {
                    //
                    // Use the cover page
                    //
                    pWizardUserMem->bSendCoverPage = TRUE;
                    CopyString(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                               pCoverPage,
                               MAX_PATH);
                }
            }
            else
            {
                SetLastError(ERROR_INVALID_DATA);
            }
        }
    }

    MemFree(pRecipientEntry);
    MemFree(pCoverPage);
    return fSuccess;
}

static HRESULT
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    )
{
    if (lpPersonalProfileInfo) {
        MemFree(lpPersonalProfileInfo->lptstrName);
        lpPersonalProfileInfo->lptstrName = NULL;
        MemFree(lpPersonalProfileInfo->lptstrFaxNumber);
        lpPersonalProfileInfo->lptstrFaxNumber = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCompany);
        lpPersonalProfileInfo->lptstrCompany = NULL;
        MemFree(lpPersonalProfileInfo->lptstrStreetAddress);
        lpPersonalProfileInfo->lptstrStreetAddress = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCity);
        lpPersonalProfileInfo->lptstrCity = NULL;
        MemFree(lpPersonalProfileInfo->lptstrState);
        lpPersonalProfileInfo->lptstrState = NULL;
        MemFree(lpPersonalProfileInfo->lptstrZip);
        lpPersonalProfileInfo->lptstrZip = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCountry);
        lpPersonalProfileInfo->lptstrCountry = NULL;
        MemFree(lpPersonalProfileInfo->lptstrTitle);
        lpPersonalProfileInfo->lptstrTitle = NULL;
        MemFree(lpPersonalProfileInfo->lptstrDepartment);
        lpPersonalProfileInfo->lptstrDepartment = NULL;
        MemFree(lpPersonalProfileInfo->lptstrOfficeLocation);
        lpPersonalProfileInfo->lptstrOfficeLocation = NULL;
        MemFree(lpPersonalProfileInfo->lptstrHomePhone);
        lpPersonalProfileInfo->lptstrHomePhone = NULL;
        MemFree(lpPersonalProfileInfo->lptstrOfficePhone);
        lpPersonalProfileInfo->lptstrOfficePhone = NULL;
        MemFree(lpPersonalProfileInfo->lptstrEmail);
        lpPersonalProfileInfo->lptstrEmail = NULL;
        MemFree(lpPersonalProfileInfo->lptstrBillingCode);
        lpPersonalProfileInfo->lptstrBillingCode = NULL;
        MemFree(lpPersonalProfileInfo->lptstrTSID);
        lpPersonalProfileInfo->lptstrTSID = NULL;
    }
    return S_OK;
}

static HRESULT
FaxFreeCoverPageInformation(
        PFAX_COVERPAGE_INFO_EX  lpCoverPageInfo
    )
{
    if (lpCoverPageInfo) {
        MemFree(lpCoverPageInfo->lptstrCoverPageFileName);
        MemFree(lpCoverPageInfo->lptstrNote);
        MemFree(lpCoverPageInfo->lptstrSubject);
        MemFree(lpCoverPageInfo);
    }
    return S_OK;
}


HRESULT WINAPI
FaxFreeSendWizardData(
        LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
    )
{
    if (lpFaxSendWizardData) {
        FaxFreeCoverPageInformation(lpFaxSendWizardData->lpCoverPageInfo) ;
        FaxFreePersonalProfileInformation(lpFaxSendWizardData->lpSenderInfo);
        MemFree(lpFaxSendWizardData->lpSenderInfo);

        FreeRecipientInfo(&lpFaxSendWizardData->dwNumberOfRecipients,lpFaxSendWizardData->lpRecipientsInfo);

        MemFree(lpFaxSendWizardData->szReceiptDeliveryAddress);
        MemFree(lpFaxSendWizardData->lptstrPreviewFile);
    }
    return S_OK;
}


BOOL
SendFaxWizardInternal(
    PWIZARDUSERMEM    pWizardUserMem
    );


HRESULT
FaxSendWizardUI(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   )
/*++

Routine Description:

    This function shows the fax send wizard

Arguments:

    hWndOwner - pointer to owner's window
    dwFlags - flags modified behavior of the fax send wizard. The flag can be combined from
            the following values:
            FSW_FORCE_COVERPAGE,
            FSW_USE_SCANNER,
            FSW_USE_SCHEDULE_ACTION,
            FSW_USE_RECEIPT,
            FSW_SEND_WIZARD_FROM_SN,
            FSW_RESEND_WIZARD,
            FSW_PRINT_PREVIEW_OPTION

            for more information about this flags see win9xfaxprinterdriver.doc

    lptstrServerName    -   pointer to the server name
    lptstrPrinterName   -   pointer to the printer name
    lpInitialData       -   pointer to the initial data (not NULL!!!)
    lptstrTifName       -   pointer to the output scanned tiff file (must be allocated)
    lpFaxSendWizardData -   pointer to received data

Return Value:

    S_OK if success,
    S_FALSE if CANCEL was pressed
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                                HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))

--*/

{
    PWIZARDUSERMEM      pWizardUserMem = NULL;
    BOOL                bResult = FALSE;
    HRESULT             hResult = S_FALSE;
    INT                 i,iCount;
    PRECIPIENT          pRecipient;

    //
    // Validate parameters
    //

    Assert(lpInitialData);
    Assert(lpFaxSendWizardData);
    Assert(lptstrTifName);

    if (!lpInitialData || !lpFaxSendWizardData || !lptstrTifName ||
        lpFaxSendWizardData->dwSizeOfStruct != sizeof(FAX_SEND_WIZARD_DATA))
    {
        Error(("Invalid parameter passed to function FaxSendWizardUI\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    if ((pWizardUserMem = MemAllocZ(sizeof(WIZARDUSERMEM))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    ZeroMemory(pWizardUserMem, sizeof(WIZARDUSERMEM));

    pWizardUserMem->lptstrServerName  = lptstrServerName;
    pWizardUserMem->lptstrPrinterName = lptstrPrinterName;
    pWizardUserMem->dwFlags = dwFlags;
    pWizardUserMem->lpInitialData = lpInitialData;
    pWizardUserMem->lpFaxSendWizardData = lpFaxSendWizardData;
    pWizardUserMem->isLocalPrinter = (lptstrServerName == NULL);
    pWizardUserMem->szTempPreviewTiff[0] = TEXT('\0');


    if ( (lpFaxSendWizardData->lpCoverPageInfo =
        MemAllocZ(sizeof(FAX_COVERPAGE_INFO_EX))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));
    lpFaxSendWizardData->lpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
    lpFaxSendWizardData->lpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;

    if ( (lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName =
        MemAllocZ(sizeof(TCHAR)*MAX_PATH)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, sizeof(TCHAR) * MAX_PATH);

    if ( (lpFaxSendWizardData->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpSenderInfo, sizeof(FAX_PERSONAL_PROFILE));
    lpFaxSendWizardData->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    if (!CopyPersonalProfile(lpFaxSendWizardData->lpSenderInfo, lpInitialData->lpSenderInfo))
    {
        hResult = HRESULT_FROM_WIN32(GetLastError());
        Error((
                "CopyPersonalProflie() for SenderInfo failed (hr: 0x%08X)\n",
                hResult
                ));
       goto error;
    }

    FreeRecipientList(pWizardUserMem);
    //
    // copies recipient information to internal structure
    //

    if (!SUCCEEDED(StoreRecipientInfoInternal(pWizardUserMem)))
    {
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }

    pWizardUserMem->bSendCoverPage = (pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName &&
                                      pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName[0] != NUL);

    bResult = SendFaxWizardInternal(pWizardUserMem);

    if (bResult)
    {
        for (iCount=0,pRecipient=pWizardUserMem->pRecipients;
             pRecipient;
             pRecipient=pRecipient->pNext )
        {
            iCount++;
        }
        if ((lpFaxSendWizardData->dwNumberOfRecipients = iCount) > 0)
        {
            if ( (lpFaxSendWizardData->lpRecipientsInfo
                = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE)*iCount)) == NULL)
            {
                Error(("Memory allocation failed\n"));
                hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto error;
            }

            ZeroMemory(lpFaxSendWizardData->lpRecipientsInfo,sizeof(FAX_PERSONAL_PROFILE)*iCount);
            for (i=0,pRecipient=pWizardUserMem->pRecipients;
                 pRecipient && i<iCount ;
                 pRecipient=pRecipient->pNext , i++)
            {
                lpFaxSendWizardData->lpRecipientsInfo[i].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
                hResult = CopyRecipientInfo(&lpFaxSendWizardData->lpRecipientsInfo[i],
                                            pRecipient,
                                            pWizardUserMem->isLocalPrinter);
                if (hResult != S_OK)
                {
                    goto error;
                }
            }
        }
        if (pWizardUserMem->bSendCoverPage == FALSE)
        {
            Assert(lpFaxSendWizardData->lpCoverPageInfo);
            MemFree(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName);
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName = NULL;
        }

        _tcscpy(lptstrTifName,pWizardUserMem->FileName);
    }


    hResult = bResult ? S_OK : S_FALSE;
    goto exit;
error:
    if (lpFaxSendWizardData)
    {
        FaxFreeSendWizardData(lpFaxSendWizardData);
    }

exit:

    if (pWizardUserMem)
    {
        FreeRecipientList(pWizardUserMem);
        if (pWizardUserMem->lpWabInit)
        {
            UnInitializeWAB( pWizardUserMem->lpWabInit);
        }

        if (pWizardUserMem->lpMAPIabInit)
        {
            UnInitializeMAPIAB(pWizardUserMem->lpMAPIabInit);
        }
        MemFree(pWizardUserMem);
    }

    return hResult;
}

HRESULT WINAPI
FaxSendWizard(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   )
/*++

Routine Description:

    This function prepares initial data and shows the fax send wizard.
    This is invoked during CREATEDCPRE document event.

Arguments:

    hWndOwner - pointer to owner's window
    dwFlags - flags modified behavior of the fax send wizard. The flag can be combined from
            the following values:
            FSW_FORCE_COVERPAGE,
            FSW_USE_SCANNER,
            FSW_USE_SCHEDULE_ACTION,
            FSW_USE_RECEIPT,
            FSW_SEND_WIZARD_FROM_SN,
            FSW_RESEND_WIZARD,
            FSW_PRINT_PREVIEW_OPTION

            for more information about this flags see win9xfaxprinterdriver.doc

    lptstrServerName    -   pointer to the server name
    lptstrPrinterName   -   pointer to the printer name
    lpInitialData       -   pointer to the initial data (if NULL default values are created)
                            this is IN parameter, but it used as a local variable and may be changed
                            during the execution of the function. Though this parameter remains unchanged
                            at the end of function.
    lpFaxSendWizardData -   pointer to received data

Return Value:

    S_OK if success,
    S_FALSE if CANCEL was pressed
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                                HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))

--*/
{
    HRESULT             hResult;
    DWORD               dwIndex;
    DWORD               dwDeafultValues = 0;
    HMODULE             hConfigWizModule=NULL;
    FAX_CONFIG_WIZARD   fpFaxConfigWiz=NULL;
    DWORD               dwVersion, dwMajorWinVer, dwMinorWinVer;
    BOOL                bAbort = FALSE; // Do we abort because the user refused to enter a dialing location?

    // Validate parameters
    Assert(lpFaxSendWizardData);
    Assert(lptstrTifName);

    if (!lpFaxSendWizardData || !lptstrTifName ||
        lpFaxSendWizardData->dwSizeOfStruct != sizeof(FAX_SEND_WIZARD_DATA))
    {
        Error(("Invalid parameter passed to function FaxSendWizard\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    //
    // launch Fax Configuration Wizard
    //
    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));
    if(dwMajorWinVer != 5 || dwMinorWinVer < 1)
    {
        //
        // Configuration Wizard enable for Windows XP only
        //
        goto no_config_wizard;
    }
    if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
    {
        //
        // Running from within the Fax Send Note (fxssend.exe) - config wizard alerady launched implicitly.
        //
        goto no_config_wizard;
    }

    hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(FALSE, &bAbort))
            {
                Error(("FaxConfigWizard failed (ec: %ld)",GetLastError()));
            }
        }
        else
        {
            Error(("GetProcAddress(FaxConfigWizard) failed (ec: %ld)",GetLastError()));
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            Error(("FreeLibrary(FxsCgfWz.dll) failed (ec: %ld)",GetLastError()));
        }
    }
    else
    {
        Error(("LoadLibrary(FxsCgfWz.dll) failed (ec: %ld)",GetLastError()));
    }
    if (bAbort)
    {
        //
        // User refused to enter a dialing location - stop the wizard now
        //
        return E_ABORT;
    }

no_config_wizard:

    //
    // save the user info when finish
    //
    lpFaxSendWizardData->bSaveSenderInfo = TRUE;

    //
    // restore UseDialingRules flag for local fax
    //
    lpFaxSendWizardData->bUseDialingRules = FALSE;
    lpFaxSendWizardData->bUseOutboundRouting = FALSE;
    if(S_OK != RestoreUseDialingRules(&lpFaxSendWizardData->bUseDialingRules,
                                      &lpFaxSendWizardData->bUseOutboundRouting))
    {
        Error(("RestoreUseDialingRules failed\n"));
    }

    //
    // Allocates memory for initial data if lpInitialData is NULL
    //
    if (!lpInitialData)
    {
        if (!(lpInitialData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) )
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        ZeroMemory(lpInitialData, sizeof(FAX_SEND_WIZARD_DATA));
        lpInitialData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);
        dwDeafultValues |= DEFAULT_INITIAL_DATA;
    }

    //
    // Restores receipt info
    //
    if (!(dwFlags & FSW_USE_RECEIPT))
    {
        RestoreLastReciptInfo(&lpInitialData->dwReceiptDeliveryType,
                              &lpInitialData->szReceiptDeliveryAddress);

        dwDeafultValues |= DEFAULT_RECEIPT_INFO;
    }

    //
    // Restores cover page inforamtion
    //
    if (!lpInitialData->lpCoverPageInfo)
    {
        if (!(lpInitialData->lpCoverPageInfo = MemAllocZ(sizeof(FAX_COVERPAGE_INFO_EX))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        ZeroMemory(lpInitialData->lpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));
        lpInitialData->lpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
        lpInitialData->lpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;

        hResult = RestoreCoverPageInfo(&lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);

        if (FAILED(hResult))
        {
            // Then continue to run and don't initialize cover page's fields
        }

        dwDeafultValues |= DEFAULT_CV_INFO;
    }

    //
    // Restores sender information
    //

    if (!lpInitialData->lpSenderInfo)
    {
        if (!(lpInitialData->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }

        ZeroMemory(lpInitialData->lpSenderInfo, sizeof(FAX_PERSONAL_PROFILE));
        lpInitialData->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

        hResult = FaxGetSenderInformation(lpInitialData->lpSenderInfo);

        if (FAILED(hResult))
        {
            // Then continue to run and don't initialize sender info's fields
        }

        dwDeafultValues |= DEFAULT_SENDER_INFO;
    }



    hResult = FaxSendWizardUI(  hWndOwner,
                                dwFlags,
                                lptstrServerName,
                                lptstrPrinterName,
                                lpInitialData,
                                lptstrTifName,
                                lpFaxSendWizardData
                );

    if (hResult == S_OK)
    {
        SaveLastReciptInfo(lpFaxSendWizardData->dwReceiptDeliveryType,
                           lpFaxSendWizardData->szReceiptDeliveryAddress);
        //
        // Save the information about the last recipient as a convenience
        //

        if (lpFaxSendWizardData->dwNumberOfRecipients)
        {
            SaveLastRecipientInfo(&lpFaxSendWizardData->lpRecipientsInfo[0],
                                  lpFaxSendWizardData->dwLastRecipientCountryId);
        }

        if(lpFaxSendWizardData->bSaveSenderInfo)
        {
            FaxSetSenderInformation(lpFaxSendWizardData->lpSenderInfo);
        }

        //
        // save UseDialingRules flag for local fax
        //
        if(S_OK != SaveUseDialingRules(lpFaxSendWizardData->bUseDialingRules,
                                       lpFaxSendWizardData->bUseOutboundRouting))
        {
            Error(("SaveUseDialingRules failed\n"));
        }

        if (lpFaxSendWizardData->lpCoverPageInfo &&
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName)
        {
            SaveCoverPageInfo(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName);

            //
            //  If Server Based Cover Page File Name has full path, cut it off
            //
            if ( lpFaxSendWizardData->lpCoverPageInfo->bServerBased )
            {
                LPTSTR lptstrDelimiter = NULL;

                if ( lptstrDelimiter =
                    _tcsrchr(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                             FAX_PATH_SEPARATOR_CHR))
                {
                    lptstrDelimiter = _tcsinc(lptstrDelimiter);

                    _tcscpy(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                            lptstrDelimiter);
                }
                else
                {
                    //
                    //  Cover Page should always contain full path
                    //
                    Assert(FALSE);
                }
            }
        }
    }

exit:

    ShutdownTapi();

    if ( dwDeafultValues & DEFAULT_RECEIPT_INFO )
    {
        MemFree(lpInitialData->szReceiptDeliveryAddress);
        lpInitialData->szReceiptDeliveryAddress = NULL;
    }

    if ( dwDeafultValues & DEFAULT_RECIPIENT_INFO )
    {
        for(dwIndex = 0; dwIndex < lpInitialData->dwNumberOfRecipients; dwIndex++)
        {
            FaxFreePersonalProfileInformation(&lpInitialData->lpRecipientsInfo [dwIndex]);
        }
        MemFree(lpInitialData->lpRecipientsInfo);
        lpInitialData->lpRecipientsInfo = NULL;
        lpInitialData->dwNumberOfRecipients = 0;
    }

    if ( dwDeafultValues & DEFAULT_CV_INFO )
    {
        if (lpFaxSendWizardData->lpCoverPageInfo)
        {
            MemFree(lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);
            lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName = NULL;
        }
        MemFree(lpInitialData->lpCoverPageInfo);
        lpInitialData->lpCoverPageInfo = NULL;
    }

    if ( dwDeafultValues & DEFAULT_SENDER_INFO )
    {
        if (lpInitialData->lpSenderInfo)
        {
            FaxFreeSenderInformation(lpInitialData->lpSenderInfo);
            MemFree(lpInitialData->lpSenderInfo);
            lpInitialData->lpSenderInfo = NULL;
        }
    }

    if (dwDeafultValues & DEFAULT_INITIAL_DATA)
    {
        MemFree(lpInitialData);
        lpInitialData = NULL;
    }
    //
    // Remove left of temp preview files
    //
    DeleteTempPreviewFiles (NULL, FALSE);
    return hResult;
}

BOOL
SendFaxWizardInternal(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Present the Send Fax Wizard to the user.

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error or the user pressed Cancel.

--*/

#define NUM_PAGES   6  // Number of wizard pages

{
    PROPSHEETPAGE  *ppsp = NULL;
    PROPSHEETHEADER psh;
    INT             result = FALSE;
    HDC             hdc = NULL;
    INT             i;
    LOGFONT         LargeFont;
    LOGFONT         lfTitleFont;
    LOGFONT         lfSubTitleFont;
    NONCLIENTMETRICS ncm = {0};
    TCHAR           FontName[100];
    TCHAR           FontSize[30];
    INT             iFontSize;
    DWORD           ThreadId;
    HANDLE          hThread = NULL;
    BOOL            bSkipReceiptsPage = FALSE;

    LPTSTR          lptstrResource = NULL;


    //
    // A shortcut to skip fax wizard for debugging/testing purposes
    //
    if(!GetFakeRecipientInfo(pWizardUserMem))
    {
        if(GetLastError())
        {
            return FALSE;
        }
        // else continue

    }
    else
    {
        return TRUE;
    }

    Verbose(("Presenting Send Fax Wizard\n"));

    if (IsDesktopSKU() && pWizardUserMem->isLocalPrinter)
    {
        //
        // For desktop SKUs, we don't show the receipts page if faxing locally
        //
        bSkipReceiptsPage = TRUE;
        Assert (pWizardUserMem->lpInitialData);
        pWizardUserMem->lpInitialData->dwReceiptDeliveryType = DRT_NONE;
        pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType = DRT_NONE;
    }

    if (! (ppsp = MemAllocZ(sizeof(PROPSHEETPAGE) * NUM_PAGES))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // fire off a thread to do some slow stuff later on in the wizard.
    //
    pWizardUserMem->hCPEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hCPEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hCPEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }
    pWizardUserMem->hCountryListEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hCountryListEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hCountryListEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }

    pWizardUserMem->hTAPIEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hTAPIEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hTAPIEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }

    pWizardUserMem->pCountryList = NULL;

    MarkPDEVWizardUserMem(pWizardUserMem);


    hThread = CreateThread(NULL,0,AsyncWizardThread,pWizardUserMem,0,&ThreadId);
    if (!hThread)
    {
        Error(("CreateThread failed. ec = 0x%X\n",GetLastError()));
        goto Error;
    }

    //
    // Fill out one PROPSHEETPAGE structure for every page:
    //  The first page is a welcome page
    //  The first page is for choose the fax recipient
    //  The second page is for choosing cover page, subject and note
    //  The third page is for entering time to send
    //  The fourth page is for choosing of receipt form
    //  The fifth page is for scanning pages (optional)
    //  The last page gives the user a chance to confirm or cancel the dialog
    //

    pWizardUserMem->dwComCtrlVer = GetDllVersion(TEXT("comctl32.dll"));
    Verbose(("COMCTL32.DLL Version is : 0x%08X", pWizardUserMem->dwComCtrlVer));


    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        FillInPropertyPage( ppsp,  TRUE, IDD_WIZARD_WELCOME,    WelcomeWizProc,    pWizardUserMem ,0,0);
        FillInPropertyPage( ppsp+1,TRUE, IDD_WIZARD_CHOOSE_WHO, RecipientWizProc,  pWizardUserMem ,IDS_WIZ_RECIPIENT_TITLE,IDS_WIZ_RECIPIENT_SUB);
        FillInPropertyPage( ppsp+2, TRUE, IDD_WIZARD_CHOOSE_CP,  CoverPageWizProc,  pWizardUserMem ,IDS_WIZ_COVERPAGE_TITLE,IDS_WIZ_COVERPAGE_SUB );
        FillInPropertyPage( ppsp+3, TRUE, IDD_WIZARD_FAXOPTS,    FaxOptsWizProc,    pWizardUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
        if (!bSkipReceiptsPage)
        {
            FillInPropertyPage( ppsp+4, TRUE, IDD_WIZARD_FAXRECEIPT, FaxReceiptWizProc, pWizardUserMem ,IDS_WIZ_FAXRECEIPT_TITLE,IDS_WIZ_FAXRECEIPT_SUB);
        }
        FillInPropertyPage( ppsp + 4 + (bSkipReceiptsPage ? 0 : 1),
                            TRUE, IDD_WIZARD_CONGRATS,   FinishWizProc,     pWizardUserMem ,0,0);
    }
    else
    {
        FillInPropertyPage( ppsp, FALSE,   IDD_WIZARD_WELCOME_NOWIZARD97,    WelcomeWizProc,    pWizardUserMem ,0,0);
        FillInPropertyPage( ppsp+1, FALSE, IDD_WIZARD_CHOOSE_WHO_NOWIZARD97, RecipientWizProc,  pWizardUserMem ,IDS_WIZ_RECIPIENT_TITLE,IDS_WIZ_RECIPIENT_SUB);
        FillInPropertyPage( ppsp+2, FALSE, IDD_WIZARD_CHOOSE_CP_NOWIZARD97,  CoverPageWizProc,  pWizardUserMem ,IDS_WIZ_COVERPAGE_TITLE,IDS_WIZ_COVERPAGE_SUB );
        FillInPropertyPage( ppsp+3, FALSE, IDD_WIZARD_FAXOPTS_NOWIZARD97,    FaxOptsWizProc,    pWizardUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
        if (!bSkipReceiptsPage)
        {
            FillInPropertyPage( ppsp+4, FALSE, IDD_WIZARD_FAXRECEIPT_NOWIZARD97, FaxReceiptWizProc, pWizardUserMem ,IDS_WIZ_FAXRECEIPT_TITLE,IDS_WIZ_FAXRECEIPT_SUB);
        }
        FillInPropertyPage( ppsp + 4 + (bSkipReceiptsPage ? 0 : 1),
                            FALSE, IDD_WIZARD_CONGRATS_NOWIZARD97,   FinishWizProc,     pWizardUserMem ,0,0);
    }
    //
    // Fill out the PROPSHEETHEADER structure
    //
    ZeroMemory(&psh, sizeof(psh));

    if(pWizardUserMem->dwComCtrlVer >= PACKVERSION(4,71))
    {
        psh.dwSize = sizeof(PROPSHEETHEADER);
    }
    else
    {
        psh.dwSize = PROPSHEETHEADER_V1_SIZE;
    }



    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    }
    else
    {
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD ;
    }

    psh.hwndParent = GetActiveWindow();
    psh.hInstance = ghInstance;
    psh.hIcon = NULL;
    psh.pszCaption = TEXT("");
    psh.nPages = NUM_PAGES;
    psh.nStartPage = 0;
    psh.ppsp = ppsp;

    if(hdc = GetDC(NULL)) {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8) {
            lptstrResource = MAKEINTRESOURCE(IDB_WATERMARK_256);
        }
        else lptstrResource = MAKEINTRESOURCE(IDB_WATERMARK_16);
        ReleaseDC(NULL,hdc);
    }

 if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
 {
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK);
    psh.pszbmWatermark = lptstrResource;
 }
    //
    // get the large fonts for wizard97
    //
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
    {
        Error(("SystemParametersInfo failed. ec = 0x%X\n",GetLastError()));
        goto Error;
    }
    else
    {

        CopyMemory((LPVOID* )&LargeFont,     (LPVOID *) &ncm.lfMessageFont,sizeof(LargeFont) );
        CopyMemory((LPVOID* )&lfTitleFont,   (LPVOID *) &ncm.lfMessageFont,sizeof(lfTitleFont) );
        CopyMemory((LPVOID* )&lfSubTitleFont,(LPVOID *) &ncm.lfMessageFont,sizeof(lfSubTitleFont) );

        if (!LoadString(ghInstance,IDS_LARGEFONT_NAME,FontName,ARR_SIZE(FontName)))
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }

        if (!LoadString(ghInstance,IDS_LARGEFONT_SIZE,FontSize,ARR_SIZE(FontSize)))
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }

        iFontSize = _tcstoul( FontSize, NULL, 10 );

        // make sure we at least have some basic font
        if (*FontName == 0 || iFontSize == 0) {
            lstrcpy(FontName,TEXT("MS Shell Dlg") );
            iFontSize = 18;
        }

        lstrcpy(LargeFont.lfFaceName, FontName);
        LargeFont.lfWeight   = FW_BOLD;

        lstrcpy(lfTitleFont.lfFaceName,    _T("MS Shell Dlg"));
        lfTitleFont.lfWeight = FW_BOLD;
        lstrcpy(lfSubTitleFont.lfFaceName, _T("MS Shell Dlg"));
        lfSubTitleFont.lfWeight = FW_NORMAL;
        hdc = GetDC(NULL);
        if (!hdc)
        {
            Error((
                    "GetDC() failed (ec: ld)",
                    GetLastError()
                 ));
            goto Error;
        }

        LargeFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * iFontSize / 72);
        lfTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 9 / 72);
        lfSubTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 9 / 72);
        pWizardUserMem->hLargeFont    = CreateFontIndirect(&LargeFont);
        if (!pWizardUserMem->hLargeFont)
        {
            Error((
                   "CreateFontIndirect(&LargeFont) failed (ec: %ld)",
                   GetLastError()
                   ));
            goto Error;
        }

        pWizardUserMem->hTitleFont    = CreateFontIndirect(&lfTitleFont);
        if (!pWizardUserMem->hTitleFont )
        {
            Error((
                   "CreateFontIndirect(&lfTitleFont) failed (ec: %ld)",
                   GetLastError()
                   ));
            goto Error;
        }
        ReleaseDC( NULL, hdc);
        hdc = NULL;

    }

    //
    // Display the wizard pages
    //
    if (PropertySheet(&psh) > 0)
        result = pWizardUserMem->finishPressed;
    else
    {
        Error(("PropertySheet() failed (ec: %ld)",GetLastError()));
        result = FALSE;
    }

    //
    // Cleanup properly before exiting
    //

    goto Exit;
    //
    // free headings
    //
Error:
    result = FALSE;
Exit:

    if (hThread)
    {
        DWORD dwRes = WaitForSingleObject(hThread, INFINITE);
        if(WAIT_OBJECT_0 != dwRes)
        {
            Error(("WaitForSingleObject for AsyncWizardThread failed. ec = 0x%X\n",GetLastError()));
        }

        if(!CloseHandle(hThread))
        {
            Error(("CloseHandle failed. ec = 0x%X\n",GetLastError()));
        }
    }

    if (pWizardUserMem->hCPEvent)
    {
        if (!CloseHandle(pWizardUserMem->hCPEvent))
        {
            Error((
                    "CloseHandle(pWizardUserMem->hCPEvent) failed (ec: %ld)",
                    GetLastError()
                  ));

        }

    }

    if (pWizardUserMem->hCountryListEvent)
    {
        if(!CloseHandle(pWizardUserMem->hCountryListEvent))
        {
            Error(("CloseHandle(pWizardUserMem->hCountryListEvent) failed (ec: %ld)",
                    GetLastError()));
        }
    }

    if (pWizardUserMem->hTAPIEvent)
    {
        if(!CloseHandle(pWizardUserMem->hTAPIEvent))
        {
            Error(("CloseHandle(pWizardUserMem->hTAPIEvent) failed (ec: %ld)",
                    GetLastError()));
        }
    }

    if (hdc)
    {
         ReleaseDC( NULL, hdc);
         hdc = NULL;
    }

    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        for (i = 0; i< NUM_PAGES; i++) {
            MemFree( (PVOID)(ppsp+i)->pszHeaderTitle );
            MemFree( (PVOID)(ppsp+i)->pszHeaderSubTitle );
        }
    }


    if (pWizardUserMem->pCountryList)
    {
        FaxFreeBuffer(pWizardUserMem->pCountryList);
    }

    MemFree(ppsp);
    if (pWizardUserMem->hLargeFont)
    {
        DeleteObject(pWizardUserMem->hLargeFont);
        pWizardUserMem->hLargeFont = NULL;
    }


    if (pWizardUserMem->hTitleFont)
    {
        DeleteObject(pWizardUserMem->hTitleFont);
        pWizardUserMem->hTitleFont = NULL;
    }


    if (pWizardUserMem->pCPInfo)
    {
        FreeCoverPageInfo(pWizardUserMem->pCPInfo);
        pWizardUserMem->pCPInfo = NULL;
    }

    Verbose(("Wizard finished...\n"));
    return result;
}



//*****************************************************************************
//* Name:   EnableCoverDlgItems
//* Author: Ronen Barenboim / 4-Feb-1999
//*****************************************************************************
//* DESCRIPTION:
//*     Enables or disables the cover page related dialog item in the cover
//*     page selection dialog.
//*     The selection is based on the following rules:
//*     If the "select cover page" checkbox is off all the other dialog items
//*     are off.
//*     Otherwise,
//*     The subject edit box is enabled only if the cover page has an embedded
//*     subject field.
//*     The note edit box is enabled only if the cover page has an embedded
//*     subject field.
//* PARAMETERS:
//*     [IN]    PWIZARDUSERMEM pWizardUserMem:
//*                 A pointer USERMEM struct that contains information used by the wizard.
//                  Specifically USERMEM.pCPDATA is used to get the selected page path.
//*     [IN]    HWND hDlg:
//*                 A handle to the cover page dialog window.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL EnableCoverDlgItems(PWIZARDUSERMEM pWizardUserMem, HWND hDlg)
{

    //
    // Disable the subject and note edit boxes if the cover page does not contain the fields
    //
    TCHAR szCoverPage[MAX_PATH];
    DWORD bServerCoverPage;
    BOOL bCPSelected;

    Assert(pWizardUserMem);
    Assert(hDlg);

    if (IsDlgButtonChecked(hDlg,IDC_CHOOSE_CP_CHECK)==BST_INDETERMINATE)
        CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, BST_UNCHECKED );

    bCPSelected = (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_CHOOSE_CP_CHECK));
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_USER_INFO), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), bCPSelected);
    ShowWindow (GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), bCPSelected ? SW_SHOW : SW_HIDE);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_TEMPLATE), bCPSelected);

    if (!bCPSelected)
    {
        return TRUE;
    }
    //
    // We have a CP
    //
    if (CB_ERR!=GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                         GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                         szCoverPage,
                         NULL,
                         &bServerCoverPage))
    {
        DWORD ec;
        TCHAR       filename[MAX_PATH];
        COVDOCINFO  covDocInfo;
        //
        // If the page path is a shortuct (.LNK extension) we need to resolve it to the actual path.
        //
        if (ResolveShortcut(szCoverPage, filename))
        {
            _tcscpy(szCoverPage, filename);
            Verbose(("Cover page is .LNK file. Resolved file name is %s",szCoverPage));
        }
        //
        // Get cover page information. The NULL parameter for hDC causes RenderCoverPage
        // to just return the cover page information in covDocInfo. It does not actually
        // create the cover page TIFF.
        //
        ec = RenderCoverPage(NULL,
            NULL,
            NULL,
            szCoverPage,
            &covDocInfo,
            FALSE);
        if (ERROR_SUCCESS == ec)
        {
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_TEMPLATE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), (covDocInfo.Flags & COVFP_NOTE) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), (covDocInfo.Flags & COVFP_NOTE) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), (covDocInfo.Flags & COVFP_SUBJECT) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), (covDocInfo.Flags & COVFP_SUBJECT) ? TRUE : FALSE);

                pWizardUserMem->noteSubjectFlag = covDocInfo.Flags;
                pWizardUserMem->cpPaperSize = covDocInfo.PaperSize;
                pWizardUserMem->cpOrientation = covDocInfo.Orientation;
        }
        else
        {
            Error(("Cannot examine cover page file '%ws': %d\n", szCoverPage, ec));
            return FALSE;
        }
    }
    else
    {
        Error(("Failed to get cover page name"));
        Assert(FALSE); // This should neverhappen
        return FALSE;
    }
    return TRUE;
}   // EnableCoverDlgItems

#ifdef DBG
#ifdef  WIN__95
ULONG __cdecl
DbgPrint(
    CHAR *  format,
    ...
    )

{
#define MAX_LINE    256
    va_list va;
    char sz[MAX_LINE];

    va_start(va, format);
    _vsnprintf(sz,sizeof(sz),format,va);
    va_end(va);

    OutputDebugString(sz);
    return 0;
}

VOID DbgBreakPoint(VOID)
{
    DebugBreak();
}

#endif
#endif // DBG
//*****************************************************************************
//* Name:   DrawCoverPagePreview
//* Author: Ronen Barenboim / 31-Dec-99
//*****************************************************************************
//* DESCRIPTION:
//*     Draws the specified coverpage template into the specified window using
//*     the specified device context.
//*     The coverpage template is drawn within the client area of the window
//*     and is surrounded by a 1 pixel wide black frame.
//*     The device context is required to support partial redraw due to
//*     WM_PAINT messages.
//*
//* PARAMETERS:
//*     [IN]    hDc
//*         The device context on which to draw the preview.
//*
//*     [IN]    hwndPrev
//*         The window into which the preview will be drawn.
//*
//*     [IN]    lpctstrCoverPagePath
//*         The full path to the cover page template to be drawn
//*
//*     [IN]    wCPOrientation
//*         The orientation of the cover page template to be drawn
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE otherwise. Call GetLastError() to get the last error.
//*****************************************************************************


BOOL DrawCoverPagePreview(
            HDC     hdc,
            HWND    hwndPrev,
            LPCTSTR lpctstrCoverPagePath,
            WORD    wCPOrientation)
{

    RECT rectPreview;
    BOOL rVal = TRUE;
    HGDIOBJ hOldPen = 0;

    COVDOCINFO  covDocInfo;
    DWORD       ec;
    //
    // Dummy data for preview.
    //

    COVERPAGEFIELDS UserData;

    Assert ((DMORIENT_PORTRAIT == wCPOrientation) || (DMORIENT_LANDSCAPE == wCPOrientation));

    ZeroMemory(&UserData,sizeof(COVERPAGEFIELDS));
    UserData.ThisStructSize = sizeof(COVERPAGEFIELDS);

    UserData.RecName = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_NAME);
    UserData.RecFaxNumber = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);
    UserData.RecCompany = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_COMPANY);
    UserData.RecStreetAddress = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_ADDRESS);
    UserData.RecCity = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_CITY);
    UserData.RecState = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_STATE);
    UserData.RecZip = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_ZIP);
    UserData.RecCountry = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_COUNTRY);
    UserData.RecTitle = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_TITLE);
    UserData.RecDepartment = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_DEPARTMENT);
    UserData.RecOfficeLocation = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_OFFICE);
    UserData.RecHomePhone = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);
    UserData.RecOfficePhone = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);

      //
      // Senders stuff...
      //

    UserData.SdrName = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_NAME);
    UserData.SdrFaxNumber = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);
    UserData.SdrCompany = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_COMPANY);
    UserData.SdrAddress = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_ADDRESS);
    UserData.SdrTitle = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_TITLE);
    UserData.SdrDepartment = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_DEPARTMENT);
    UserData.SdrOfficeLocation = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_OFFICE);
    UserData.SdrHomePhone = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);
    UserData.SdrOfficePhone = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_FAXNUMBER);

      //
      // Misc Stuff...
      //
    UserData.Note = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_NOTE);
    UserData.Subject = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_SUBJECT);
    UserData.TimeSent = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_TIMESENT);
    UserData.NumberOfPages = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_NUMPAGES);
    UserData.ToList = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_TOLIST);
    UserData.CCList = AllocateAndLoadString(ghInstance, IDS_CPPREVIEW_TOLIST);

    if (!UserData.RecName           ||  !UserData.RecFaxNumber ||
        !UserData.RecCompany        ||  !UserData.RecStreetAddress ||
        !UserData.RecCity           ||  !UserData.RecState ||
        !UserData.RecZip            ||  !UserData.RecCountry ||
        !UserData.RecTitle          ||  !UserData.RecDepartment ||
        !UserData.RecOfficeLocation ||  !UserData.RecHomePhone      ||
        !UserData.RecOfficePhone    ||  !UserData.SdrName ||
        !UserData.SdrFaxNumber      ||  !UserData.SdrCompany ||
        !UserData.SdrAddress        ||  !UserData.SdrTitle ||
        !UserData.SdrDepartment     ||  !UserData.SdrOfficeLocation ||
        !UserData.SdrHomePhone      ||  !UserData.SdrOfficePhone ||
        !UserData.Note              ||  !UserData.Subject ||
        !UserData.TimeSent          ||  !UserData.NumberOfPages ||
        !UserData.ToList            ||  !UserData.CCList)
    {
        rVal = FALSE;
        Error(("AllocateAndLoadString() is failed. ec = %ld\n", GetLastError()));
        goto exit;
    }

    if (wCPOrientation != g_wCurrMiniPreviewOrientation)
    {
        DWORD dwWidth;
        DWORD dwHeight;
        //
        // Time to change the dimensions of the mini-preview control
        //
        if (DMORIENT_LANDSCAPE == wCPOrientation)
        {
            //
            // Landscape
            //
            dwWidth  = g_dwMiniPreviewLandscapeWidth;
            dwHeight = g_dwMiniPreviewLandscapeHeight;
        }
        else
        {
            //
            // Portrait
            //
            dwWidth  = g_dwMiniPreviewPortraitWidth;
            dwHeight = g_dwMiniPreviewPortraitHeight;
        }
        //
        // Resize the mini-preview control according to the new width and height
        //
        ec = GetControlRect(hwndPrev,&rectPreview);
        if(ERROR_SUCCESS != ec)
        {
            rVal = FALSE;
            Error(("GetControlRect failed. ec = 0x%X\n", ec));
            goto exit;
        }

        //
        // Resize and hide window to avoid fliking during rendering
        //
        SetWindowPos(hwndPrev,
                     0,
                     g_bPreviewRTL ? rectPreview.right : rectPreview.left,
                     rectPreview.top,
                     dwWidth,
                     dwHeight,
                     SWP_NOZORDER | SWP_HIDEWINDOW);

        g_wCurrMiniPreviewOrientation = wCPOrientation;
    }
    //
    //
    // Get the preview window rectangle (again) that will serve as the limit for the preview.
    //
    GetClientRect(hwndPrev,&rectPreview);
    //
    // Draw frame
    //
    if ((hOldPen = SelectPen (hdc,GetStockPen(BLACK_PEN))) == HGDI_ERROR)
    {
        rVal = FALSE;
        Error(("SelectPen failed.\n"));
        goto exit;
    }
    if (!Rectangle(
            hdc,
            0,
            0,
            rectPreview.right-rectPreview.left,
            rectPreview.bottom-rectPreview.top)
            )
    {
        rVal = FALSE;
        Error(("Rectangle failed. ec = 0x%X\n",GetLastError()));
        goto exit;
    }

    //
    // Shrink the rectangle so we draw inside the frame
    //
    rectPreview.left += 1;
    rectPreview.top += 1;
    rectPreview.right -= 1;
    rectPreview.bottom -= 1;

    ec = RenderCoverPage(
            hdc,
            &rectPreview,
            &UserData,
            lpctstrCoverPagePath,
            &covDocInfo,
            TRUE);
    if (ERROR_SUCCESS != ec)
    {
        Error(("Failed to print cover page file '%s' (ec: %ld)\n",
                lpctstrCoverPagePath,
                ec)
             );
        rVal = FALSE;
        goto exit;
    }

    ShowWindow(hwndPrev, SW_SHOW);

exit:
    //
    // restore pen
    //
    if (hOldPen) {
        SelectPen (hdc,(HPEN)hOldPen);
    }

    MemFree(UserData.RecName);
    MemFree(UserData.RecFaxNumber);
    MemFree(UserData.RecCompany);
    MemFree(UserData.RecStreetAddress);
    MemFree(UserData.RecCity);
    MemFree(UserData.RecState);
    MemFree(UserData.RecZip);
    MemFree(UserData.RecCountry);
    MemFree(UserData.RecTitle);
    MemFree(UserData.RecDepartment);
    MemFree(UserData.RecOfficeLocation);
    MemFree(UserData.RecHomePhone);
    MemFree(UserData.RecOfficePhone);
    MemFree(UserData.SdrName);
    MemFree(UserData.SdrFaxNumber);
    MemFree(UserData.SdrCompany);
    MemFree(UserData.SdrAddress);
    MemFree(UserData.SdrTitle);
    MemFree(UserData.SdrDepartment);
    MemFree(UserData.SdrOfficeLocation);
    MemFree(UserData.SdrHomePhone);
    MemFree(UserData.SdrOfficePhone);
    MemFree(UserData.Note);
    MemFree(UserData.Subject);
    MemFree(UserData.TimeSent);
    MemFree(UserData.NumberOfPages);
    MemFree(UserData.ToList);
    MemFree(UserData.CCList);

    return rVal;

}

//
// Subclass procedure for the static control in which we draw the coverpage preview
// see win32 SDK for prototype description.
//
LRESULT APIENTRY PreviewSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{

     PWIZARDUSERMEM  pWizardUserMem = NULL;
     //
     // We store a pointer to the WIZARDUSERMEM in the window of the sublclassed
     // static cotntrol window. (see WM_INITDIALOG).
     //
     pWizardUserMem = g_pWizardUserMem;

     Assert(ValidPDEVWizardUserMem(pWizardUserMem));

    //
    // We only care about WM_PAINT messages.
    // Everything else is delegated to the window procedure of the class we subclassed.
    //
    if (WM_PAINT == uMsg)
    {
        PAINTSTRUCT ps;
        HDC hdc;



        hdc = BeginPaint(hwnd,&ps);
        if (!hdc)
        {
           Error(("BeginPaint failed (hWnd = 0x%X) (ec: %ld)\n",hwnd,GetLastError()));
           return FALSE;
        }

        if (!DrawCoverPagePreview(
                hdc,
                hwnd,
                pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                pWizardUserMem->cpOrientation));
        {
            Error(("Failed to draw preview window (hWnd = 0x%X)\n",hwnd));
        }
        EndPaint(hwnd,&ps);
        return FALSE; // Notify windows that we handled the paint message. We don't delegate
                      // this to the static control
    }
    else
    {
        Assert(pWizardUserMem->wpOrigStaticControlProc);

        return CallWindowProc(
                    pWizardUserMem->wpOrigStaticControlProc,
                    hwnd,
                    uMsg,
                    wParam,
                    lParam);
    }
}


/*

    Concatenates tstrRegRoot path and a the string representation of the current user's SID.

   [in]   tstrRegRoot - Registry root prefix.
   [out]  ptstrCurrentUserKeyPath - Returns a string that represents the current
          user's root key in the Registry.  Caller must call MemFree
          to free the buffer when done with it.

   Returns win32 error.

*/
static DWORD
FormatCurrentUserKeyPath( const PTCHAR tstrRegRoot,
                          PTCHAR* ptstrCurrentUserKeyPath)
{
    HANDLE hToken = NULL;
    BYTE* bTokenInfo = NULL;
    TCHAR* tstrTextualSid = NULL;
    DWORD cchSidSize = 0;
    DWORD dwFuncRetStatus = ERROR_SUCCESS;
    DWORD cbBuffer = 0;
    SID_AND_ATTRIBUTES SidUser;
    TCHAR* pLast = NULL;

    // Open impersonated token
    if(!OpenThreadToken( GetCurrentThread(),
                         TOKEN_READ,
                         TRUE,
                         &hToken))
    {
        dwFuncRetStatus = GetLastError();
    }

    if(dwFuncRetStatus != ERROR_SUCCESS)
    {
        if(dwFuncRetStatus != ERROR_NO_TOKEN)
        {
            return dwFuncRetStatus;
        }

        // Thread is not impersonating a user, get the process token
        if(!OpenProcessToken( GetCurrentProcess(),
                              TOKEN_READ,
                              &hToken))
        {
            return GetLastError();
        }
    }

    // Get user's token information
    if(!GetTokenInformation( hToken,
                             TokenUser,
                             NULL,
                             0,
                             &cbBuffer))
    {
        dwFuncRetStatus = GetLastError();
        if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Exit;
        }

        dwFuncRetStatus = ERROR_SUCCESS;
    }

    bTokenInfo = MemAlloc(cbBuffer);
    if(!bTokenInfo)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    if(!GetTokenInformation( hToken,
                             TokenUser,
                             bTokenInfo,
                             cbBuffer,
                             &cbBuffer))
    {

        dwFuncRetStatus = GetLastError();
        goto Exit;
    }

    SidUser = (*(TOKEN_USER*)bTokenInfo).User;


    if(!GetTextualSid( SidUser.Sid, NULL, &cchSidSize))
    {
        dwFuncRetStatus = GetLastError();
        if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Exit;
        }
        dwFuncRetStatus = ERROR_SUCCESS;
    }

    tstrTextualSid = MemAlloc(sizeof(TCHAR) * cchSidSize);
    if(!tstrTextualSid)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    if(!GetTextualSid( SidUser.Sid, tstrTextualSid, &cchSidSize))
    {
        dwFuncRetStatus = GetLastError();
        goto Exit;
    }

    // allocate an extra char for '\'
    *ptstrCurrentUserKeyPath = MemAlloc( sizeof(TCHAR) * (_tcslen(tstrRegRoot) + cchSidSize + 2));
    if(!*ptstrCurrentUserKeyPath)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    *ptstrCurrentUserKeyPath[0] = TEXT('\0');
    if(tstrRegRoot[0] != TEXT('\0'))
    {
        _tcscat(*ptstrCurrentUserKeyPath,tstrRegRoot);
        pLast = _tcsrchr(tstrRegRoot,TEXT('\\'));
        if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
        {
            // the last character is not a backslash, add one...
            _tcscat(*ptstrCurrentUserKeyPath, TEXT("\\"));
        }
    }

    _tcscat(*ptstrCurrentUserKeyPath,tstrTextualSid);

Exit:
    if(hToken)
    {
        if(!CloseHandle(hToken))
        {
            Error(("CloseHandle failed. ec = 0x%X\n",GetLastError()));
        }
    }
    MemFree(bTokenInfo);
    MemFree(tstrTextualSid);

    return dwFuncRetStatus;

}

// ------------------------------------------
// This function was copied from SDK samples
//  ------------------------------------------
/*
    This function obtain the textual representation
    of a binary Sid.

    A standardized shorthand notation for SIDs makes it simpler to
    visualize their components:

    S-R-I-S-S...

    In the notation shown above,

    S identifies the series of digits as an SID,
    R is the revision level,
    I is the identifier-authority value,
    S is subauthority value(s).

    An SID could be written in this notation as follows:
    S-1-5-32-544

    In this example,
    the SID has a revision level of 1,
    an identifier-authority value of 5,
    first subauthority value of 32,
    second subauthority value of 544.
    (Note that the above Sid represents the local Administrators group)

    The GetTextualSid() function will convert a binary Sid to a textual
    string.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then the SID
    will be in the form:

    S-1-5-21-2127521184-1604012920-1887927527-19009
      ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      | | |      |          |          |        |
      +-+-+------+----------+----------+--------+--- Decimal

    Otherwise it will take the form:

    S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
      ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      |       |        |      |          |          |        |
      |   Hexidecimal  |      |          |          |        |
      +----------------+------+----------+----------+--------+--- Decimal

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended
    error information, call the Win32 API GetLastError().
*/


static BOOL
GetTextualSid( const PSID pSid,          // binary Sid
               LPTSTR tstrTextualSid,    // buffer for Textual representaion of Sid
               LPDWORD cchSidSize        // required/provided TextualSid buffersize
               )
{
    PSID_IDENTIFIER_AUTHORITY pSia;
    DWORD dwSubAuthorities;
    DWORD cchSidCopy;
    DWORD dwCounter;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid))
    {
        return FALSE;
    }

    SetLastError(0);

    // obtain SidIdentifierAuthority
    //
    pSia = GetSidIdentifierAuthority(pSid);

    if(GetLastError())
    {
        return FALSE;
    }

    // obtain sidsubauthority count
    //
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    if(GetLastError())
    {
        return FALSE;
    }

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
    {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(tstrTextualSid, TEXT("S-%lu-"), SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (pSia->Value[0] != 0) || (pSia->Value[1] != 0) )
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
                               TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                               (USHORT)pSia->Value[0],
                               (USHORT)pSia->Value[1],
                               (USHORT)pSia->Value[2],
                               (USHORT)pSia->Value[3],
                               (USHORT)pSia->Value[4],
                               (USHORT)pSia->Value[5]);
    }
    else
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
                               TEXT("%lu"),
                               (ULONG)(pSia->Value[5])       +
                               (ULONG)(pSia->Value[4] <<  8) +
                               (ULONG)(pSia->Value[3] << 16) +
                               (ULONG)(pSia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy, TEXT("-%lu"),
                              *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}

/*
    Function returns TRUE if the current runing OS is NT platform.
    If function returned false and GetLastError() returned an error value
    the call GetVersionEx() failed.
*/
static BOOL
IsNTSystemVersion()
{
    OSVERSIONINFO osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (! GetVersionEx( &osvi))
    {
         return FALSE;
    }

    if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        return TRUE;
    }

    SetLastError(0);
    return FALSE;
}




/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).

Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.

--*/
DWORD GetDllVersion(LPCTSTR lpszDllName)
{

    HINSTANCE hinstDll;
    DWORD dwVersion = 0;

    hinstDll = LoadLibrary(lpszDllName);

    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;

        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");

    // Because some DLLs may not implement this function, you
    // must test for it explicitly. Depending on the particular
    // DLL, the lack of a DllGetVersion function may
    // be a useful indicator of the version.

        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }

        FreeLibrary(hinstDll);
    }
    return dwVersion;
}


DWORD 
ViewFile (
    LPCTSTR lpctstrFile
)
/*++

Routine Description:

    Launches the application associated with a given file to view it.
    We first attempt to use the "open" verb.
    If that fails, we try the NULL (default) verb.
    
Arguments:

    lpctstrFile [in]  - File name

Return Value:

    Standard Win32 error code
    
--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    SHELLEXECUTEINFO executeInfo = {0};

    executeInfo.cbSize = sizeof(executeInfo);
    executeInfo.fMask  = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT;
    executeInfo.lpVerb = TEXT("open");
    executeInfo.lpFile = lpctstrFile;
    executeInfo.nShow  = SW_SHOWNORMAL;
    //
    // Execute the associated application with the "open" verb
    //
    if(!ShellExecuteEx(&executeInfo))
    {
        Error(("ShellExecuteEx(open) failed (ec: %ld)\n", GetLastError()));
        //
        // "open" verb is not supported. Try the NULL (default) verb.
        //
        executeInfo.lpVerb = NULL;
        if(!ShellExecuteEx(&executeInfo))
        {
            dwRes = GetLastError();
            Error(("ShellExecuteEx(NULL) failed (ec: %ld)\n", dwRes));
        }
    }
    return dwRes;
}   // ViewFile    




BOOL
DisplayFaxPreview(
            HWND hWnd,
            PWIZARDUSERMEM pWizardUserMem,
            LPTSTR lptstrPreviewFile
            )

/*++

Routine Description:

    Create a temporary TIFF file of the whole job (cover page + body), pop the registered
    TIFF viewer and ask the user whether to continue sending the fax.

    TODO: Once we have our own TIFF viewer, we can use only the temporary file created by
          the driver so far. The security issue of executing an unknown TIFF viewer on a
          different copy of the preview TIFF won't exist anymore...

Arguments:

    hWnd - Parent window handle.
    pWizardUserMem        - Points to the user mode memory structure.
    lptstrPreviewFile   - Full path to the file to be previewed.

Return Value:

    TRUE to continue printing
    FALSE to cancel the job

--*/

{
    HDC hdc = NULL;
    BOOL bRet = TRUE;
    BOOL bPrintedCoverPage = FALSE;
	short Orientation = DMORIENT_PORTRAIT;

    DWORD dwSize;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD ec = ERROR_SUCCESS;
    COVERPAGEFIELDS cpFields = {0};

    Assert(pWizardUserMem);
    Assert(lptstrPreviewFile);
    Assert(lptstrPreviewFile[0]);
    //
    // Get the body TIFF file size
    //
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
                                              lptstrPreviewFile,
                                              GENERIC_READ,
                                              0,
                                              NULL,
                                              OPEN_EXISTING,
                                              FILE_ATTRIBUTE_NORMAL,
                                              NULL)))
    {
        ec = GetLastError();
        Error(("Couldn't open preview file to get the file size. Error: %d\n", ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        goto Err_Exit;
    }

    dwSize = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == dwSize)
    {
        ec = GetLastError();
        Error(("Failed getting file size (ec: %ld).\n",ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        goto Err_Exit;
    }

    if (!CloseHandle(hFile))
    {
        Error(("CloseHandle() failed: (ec: %ld).\n", GetLastError()));
        Assert(INVALID_HANDLE_VALUE == hFile); // assert false
    }
    hFile = INVALID_HANDLE_VALUE;
    //
    // Create a temporary file for the complete preview TIFF - This file will contain the
    // rendered cover page (if used) and the document body
    //
    if (!GenerateUniqueFileNameWithPrefix(
                        TRUE,                           // Use process id
                        NULL,                           // Create in the system temporary directory
                        WIZARD_PREVIEW_TIFF_PREFIX,     // Prefix
                        NULL,                           // Use FAX_TIF_FILE_EXT as extension
                        pWizardUserMem->szTempPreviewTiff,
                        MAX_PATH))
    {
        ec = GetLastError();
        Error(("Failed creating temporary cover page TIFF file (ec: %ld)", ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        pWizardUserMem->szTempPreviewTiff[0] = TEXT('\0');
        goto Err_Exit;
    }

	//
	// Change the default orientation if needed
	//
	if (pWizardUserMem->cpOrientation == DMORIENT_LANDSCAPE)
	{
		Orientation = DMORIENT_LANDSCAPE;
	}

    //
    // If we have a cover page merge it with the body
    //
    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName &&
        pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName[0])
    {
        FillCoverPageFields(pWizardUserMem, &cpFields); // does not allocate any memory and can not fail

        ec = PrintCoverPageToFile(
                pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                pWizardUserMem->szTempPreviewTiff,
                pWizardUserMem->lptstrPrinterName,
                Orientation,
                0,   // Default resolution
                &cpFields);
        if (ERROR_SUCCESS != ec)
        {
                   Error(("PrintCoverPageToFile() failed (ec: %ld)", ec));
                   ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
                   goto Err_Exit;
        }

        //
        // Check if we have a non-empty body TIFF file (this happens when an empty document
        // is printed - such as our "Send cover page" utility).
        //
        if (dwSize)
        {
            //
            // Merge the document body TIFF to our cover page TIFF
            //
            if (!MergeTiffFiles(pWizardUserMem->szTempPreviewTiff, lptstrPreviewFile))
            {
                ec = GetLastError();
                Error(("Failed merging cover page and preview TIFF files (ec: %ld).\n", ec));
                ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
                goto Err_Exit;
            }
        }
    }
    else
    {
        //
        // No cover page was supplied
        //

        if (!dwSize)
        {
            //
            // No cover page was included and we recieved an empty preview file !? In this
            // case there is actually no preview to display so just exit.
            // Note: This can happen when an empty notepad document is printed with no
            //       cover page.
            //
            Warning(("Empty preview file recieved with no cover page.\n"));

            ErrorMessageBox(hWnd,IDS_PREVIEW_NOTHING_TO_PREVIEW, MB_ICONERROR);
            goto Err_Exit;
        }

        //
        // Just copy the driver body file to our temporary preview file
        //
        if (!CopyFile(lptstrPreviewFile, pWizardUserMem->szTempPreviewTiff, FALSE))
        {
            ec = GetLastError();
            Error(("Failed copying TIFF file. Error: %d.\n", ec));
            ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
            goto Err_Exit;
        }

    }

    //
    // Pop the registered TIFF viewer
    //
    ec = ViewFile (pWizardUserMem->szTempPreviewTiff);
    if (ERROR_SUCCESS != ec)
    {
        Error(("ShellExecuteEx failed\n"));
        ErrorMessageBox(hWnd, IDS_PREVIEW_FAILURE, MB_ICONERROR);
        goto Err_Exit;
    }
  
    goto Exit;

Err_Exit:

    if (pWizardUserMem->szTempPreviewTiff[0] != TEXT('\0'))
    {
        //
        // Delete the file (it is possible that the function failed with the file already created)
        //
        if(!DeleteFile(pWizardUserMem->szTempPreviewTiff))
        {
            Error(("DeleteFile failed. ec = 0x%X\n",GetLastError()));
        }
        //
        // Ignore errors since the file might not be there
        //
        pWizardUserMem->szTempPreviewTiff[0]=TEXT('\0');
    }
    bRet = FALSE;

Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!CloseHandle(hFile))
        {
            Error(("CloseHandle() failed: (ec: %ld).\n", GetLastError()));
            Assert(INVALID_HANDLE_VALUE == hFile); // assert false
        }
    }
    return bRet;
}



BOOL
FillCoverPageFields(
    IN PWIZARDUSERMEM pWizardUserMem,
    OUT PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Ronen Barenboim 25-March-2000

Routine Description:

    Fills a COVERPAGEFIELDS structure from the content of a WIZARDUSERMEM structure.
    Used to prepare a COVERPAGEFIELDS structure for cover page rendering before cover page
    preview.

Arguments:

    [IN] pWizardUserMem - Pointer to a WIZARDUSERMEM that holds the information to be extracted.

    [OUT] pCPFields - Pointer to a COVERPAGEFIELDS structure that gets filled with
                                      the information from WIZARDUSERMEM.

Return Value:

    BOOL

Comments:
    The function DOES NOT ALLOCATE any memory. It places in COVERPAGEFIELDS pointers to already
    allocated memory in WIZARDUSERMEM.



--*/
{
    static TCHAR szTime[256];
    static TCHAR szNumberOfPages[10];
    DWORD dwPageCount;
    int iRet;

    Assert(pWizardUserMem);
    Assert(pCPFields);

    memset(pCPFields,0,sizeof(COVERPAGEFIELDS));

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    //
    // Recipient stuff... (we use the first recipient)
    //

    pCPFields->RecName = pWizardUserMem->pRecipients->pName;
    pCPFields->RecFaxNumber = pWizardUserMem->pRecipients->pAddress;

    //
    // Senders stuff...
    //

    pCPFields->SdrName = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName;
    pCPFields->SdrFaxNumber = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrFaxNumber;
    pCPFields->SdrCompany = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrCompany;
    pCPFields->SdrAddress = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrStreetAddress;
    pCPFields->SdrTitle = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrTitle;
    pCPFields->SdrDepartment = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrDepartment;
    pCPFields->SdrOfficeLocation = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficeLocation;
    pCPFields->SdrHomePhone = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrHomePhone;
    pCPFields->SdrOfficePhone = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficePhone;

    //
    // Misc Stuff...
    //
    pCPFields->Note = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote;
    pCPFields->Subject = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject;

    if(!GetY2KCompliantDate(LOCALE_USER_DEFAULT,
                            0,
                            NULL,
                            szTime,
                            ARR_SIZE(szTime)))
    {
        Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
        return FALSE;
    }

    _tcscat(szTime, TEXT(" "));

    if(!FaxTimeFormat(LOCALE_USER_DEFAULT,
                      0,
                      NULL,
                      NULL,
                      _tcsninc(szTime, _tcslen(szTime)),
                      ARR_SIZE(szTime) - _tcslen(szTime)))
    {
        Error(("FaxTimeFormat: failed. ec = 0X%x\n",GetLastError()));
        return FALSE;
    }

    pCPFields->TimeSent = szTime;
    dwPageCount = pWizardUserMem->lpInitialData->dwPageCount;
    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName &&
        pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName[0])
    {
        dwPageCount++;
    }

    iRet= _sntprintf( szNumberOfPages,
                ARR_SIZE(szNumberOfPages),
                TEXT("%d"),
                dwPageCount);
    Assert(iRet>0);

    //
    // make sure it is allways null terminated
    //
    szNumberOfPages[ARR_SIZE(szNumberOfPages) - 1] = TEXT('\0');
    pCPFields->NumberOfPages = szNumberOfPages;

    return TRUE;
}




BOOL
ErrorMessageBox(
    HWND hwndParent,
    UINT nErrorMessage,
    UINT uIcon
    )
{
    static TCHAR szMessage[MAX_MESSAGE_LEN];
    static TCHAR szTitle[MAX_MESSAGE_LEN];

    Assert(nErrorMessage);

    if (!LoadString(ghInstance, nErrorMessage, szMessage, MAX_MESSAGE_LEN))
    {
        Error(("Failed to load  message string id %ld. (ec: %ld)", nErrorMessage, GetLastError()));
        return FALSE;
    }

    if (!LoadString(ghInstance, IDS_WIZARD_TITLE, szTitle, MAX_MESSAGE_LEN))
    {
        Error(("Failed to load  IDS_WIZARD_TITLE. (ec: %ld)", GetLastError()));
        return FALSE;
    }

    AlignedMessageBox(hwndParent, szMessage, szTitle, MB_OK | uIcon);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\cl2and20\cl2and20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Classes 2 and 2.0 fax-modem T.30 driver
    
Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    

Revision History:

--*/

   
#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2                                           
                                              
                                              
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CL2AND20
#include "pssframe.h"

WORD Class2CodeToBPS[16] =
{
/* V27_2400             0 */    2400,
/* V27_4800             1 */    4800,
/* V29_V17_7200         2 */    7200,
/* V29_V17_9600         3 */    9600,
/* V33_V17_12000        4 */    12000,
/* V33_V17_14400        5 */    14400,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
};
          
// Speeds for Class2HayesSyncSpeed to try
UWORD rguwClass2Speeds[] = {19200, 9600, 2400, 1200, 0};





BOOL ParseFPTS_SendAck(PThrdGlbl pTG)
{
    BOOL fPageAck = FALSE;
    BOOL fFoundFPTS = FALSE;
    UWORD count;

    DEBUG_FUNCTION_NAME("ParseFPTS_SendAck");
    // Acknowledge that we sent the page
    // Parse the FPTS response and see if the page is good or bad.
    pTG->class2_commands.parameters[0][1] = 0;
    pTG->class2_commands.parameters[1][1] = 0;
    pTG->class2_commands.parameters[2][1] = 0;

    if (pTG->ModemClass == MODEM_CLASS2) 
    {
       Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }
    else 
    {
       Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }

    for (count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        switch (pTG->class2_commands.command[count])
        {
        case  CL2DCE_FPTS:
                fFoundFPTS = TRUE;
                switch(pTG->class2_commands.parameters[count][0])
                {
                case 1: DebugPrintEx(DEBUG_MSG,"Found good FPTS");
                        fPageAck = TRUE;
                        // Exar hack!!!
                        // Exar modems give FPTS:1 for good pages and
                        // FPTS:1,2,0,0 for bad. So, look for the 1,2
                        // if this is an EXAR. Otherwise, 1 means good.
                        if (pTG->CurrentMFRSpec.bIsExar)
                        {
                            if (pTG->class2_commands.parameters[count][1] == 2)
                            {
                                DebugPrintEx(DEBUG_ERR,"Nope - really Found bad FPTS");
                                fPageAck = FALSE;
                            }
                        }
                        else
                        {
                            PSSLogEntry(PSS_MSG, 1, "Received MCF");
                        }
                        break;
                case 2: PSSLogEntry(PSS_WRN, 1, "Received RTN");
                        fPageAck = FALSE;
                        break;
                case 3: PSSLogEntry(PSS_WRN, 1, "Received RTP");
                        break;
                case 4: PSSLogEntry(PSS_WRN, 1, "Received PIN");
                        break;
                case 5: PSSLogEntry(PSS_WRN, 1, "Received PIP");
                        break;
                default:PSSLogEntry(PSS_WRN, 1, "Received unknown response");
                } 
                break;
        default:
                break;
        }
    }

    if (!fFoundFPTS)
    {
        PSSLogEntry(PSS_WRN, 1, "Didn't receive FPTS");
    }
    ICommSendPageAck(pTG, fPageAck);
    return fPageAck;
}


USHORT Class2Dial(PThrdGlbl pTG, LPSTR lpszDial)
{
    UWORD   uwLen, 
            uwDialStringLen;
    ULONG   ulTimeout;
    SWORD   swLen;
    USHORT  uRet;
    BYTE    bBuf[DIALBUFSIZE];
    char    chMod = pTG->NCUParams2.chDialModifier;

    DEBUG_FUNCTION_NAME("Class2Dial");

    BG_CHK(lpszDial);

    // Send the predial command
    if (pTG->lpCmdTab->szPreDial && (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreDial)))
    {
        if (Class2iModemDialog( pTG, 
                                (LPSTR)pTG->lpCmdTab->szPreDial, 
                                swLen,
                                10000L, 
                                TRUE, 
                                0,
                                pTG->cbszCLASS2_OK, 
                                pTG->cbszCLASS2_ERROR, 
                                (C2PSTR)NULL) != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Error on User's PreDial string: %s", (LPSTR)pTG->lpCmdTab->szPreDial);
        }
    }

    // If the dial string already has a T or P prefix, we use that
    // instead.
    {
        char c = 0;
        while ((c=*lpszDial) && c==' ')
        {
            *lpszDial++;
        }
        if (c=='t'|| c=='T' || c=='p'|| c=='P')
        {
            chMod = c;
            lpszDial++;
            while((c=*lpszDial) && c==' ')
            {
                *lpszDial++;
            }
        }
    }

    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszCLASS2_DIAL,chMod, (LPSTR)lpszDial);

// Need to set an approriate timeout here. A minimum of 15secs is too short
// (experiment calling machines within a PABX), plus one has to give extra
// time for machines that pick up after 2 or 4 rings and also for long distance
// calls. I take a minumum of 30secs and add 3secs for each digits over 7
// (unless it's pulse dial in which case I add 8secs/digit).
// (I'm assuming that a long-distance call will take a minimum of 8 digits
// anywhere in ths world!). Fax machines I've tested wait about 30secs
// independent of everything.

    uwDialStringLen = (SWORD)_fstrlen(lpszDial);
    ulTimeout = 60000L;
    if (uwDialStringLen > 7)
    {
        ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000) * (uwDialStringLen - 7);
    }

    if (pTG->NCUParams2.AnswerTimeout != -1 &&
        (((ULONG)pTG->NCUParams2.AnswerTimeout * 1000L) > ulTimeout))
    {
        ulTimeout = 1000L * (ULONG)pTG->NCUParams2.AnswerTimeout;
        DebugPrintEx(DEBUG_MSG,"Dial String: %s size is %d",(LPB)bBuf,uwLen);
    }

    if(pTG->fAbort)
    {
        DebugPrintEx(DEBUG_ERR,"Class2Dial aborting");
        pTG->fAbort = FALSE;
        Class2ModemHangup(pTG);
        return CONNECT_ERROR;
    }

    ICommStatus(pTG, T30STATS_DIALING, 0, 0, 0);

    uRet = Class2iModemDialog(  pTG, 
                                (LPB)bBuf, 
                                uwLen,
                                ulTimeout, 
                                TRUE, 
                                0,
                                pTG->cbszFCON, 
                                pTG->cbszCLASS2_BUSY, 
                                pTG->cbszCLASS2_NOANSWER,
                                pTG->cbszCLASS2_NODIALTONE, 
                                pTG->cbszCLASS2_ERROR, 
                                (NPSTR)NULL);

    // If it was "ERROR", try again - maybe the predial command screwed
    // up somehow and left and ERROR hanging around?
    if (uRet == 5)
    {
        uRet = Class2iModemDialog(  pTG, 
                                    (LPB)bBuf, 
                                    uwLen,
                                    ulTimeout, 
                                    TRUE, 
                                    0,
                                    pTG->cbszFCON, 
                                    pTG->cbszCLASS2_BUSY, 
                                    pTG->cbszCLASS2_NOANSWER,
                                    pTG->cbszCLASS2_NODIALTONE, 
                                    pTG->cbszCLASS2_ERROR, 
                                    (NPSTR)NULL);
    }


#if ((CONNECT_TIMEOUT==NCUDIAL_ERROR) && (CONNECT_BUSY==NCUDIAL_BUSY) && (CONNECT_NOANSWER==NCUDIAL_NOANSWER))
#       if ((CONNECT_NODIALTONE==NCUDIAL_NODIALTONE) && (CONNECT_ERROR==NCUDIAL_MODEMERROR))
#               pragma message("verified CONNECT defines")
#       else
#               error CONNECT defines not correct
#       endif
#else
#       error CONNECT defines not correct
#endif

    switch(uRet)
    {

    case CONNECT_TIMEOUT:       PSSLogEntry(PSS_ERR, 1, "Response - timeout");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    case CONNECT_OK:            PSSLogEntry(PSS_MSG, 1, "Response - +FCON");
                                break;
    case CONNECT_BUSY:          PSSLogEntry(PSS_ERR, 1, "Response - BUSY");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_BUSY);
                                break;
    case CONNECT_NOANSWER:      PSSLogEntry(PSS_ERR, 1, "Response - NOANSWER");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    case CONNECT_NODIALTONE:    PSSLogEntry(PSS_ERR, 1, "Response - NODIALTONE");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_DIAL_TONE);
                                break;
    case CONNECT_ERROR:         PSSLogEntry(PSS_ERR, 1, "Response - ERROR");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    default:                    uRet = CONNECT_ERROR;
                                BG_CHK(FALSE);
                                break;
    }

    BG_CHK(uRet>=0 && uRet<=5);

    if (uRet != CONNECT_OK)
    {
        if (!Class2ModemHangup(pTG ))
        {
            return CONNECT_ERROR;
        }
    }

    return uRet;
}


// ACTIVESLICE defined in msched.h
#define IDLESLICE       500


// fImmediate indicates a manual answer
USHORT Class2Answer(PThrdGlbl pTG, BOOL fImmediate)
{
    USHORT  uRet;
    SWORD   swLen;
    int     i, PrevRings, Rings;
    NPSTR   sz;
    ULONG   ulWaitTime;

    DEBUG_FUNCTION_NAME("Class2Answer");

    // Default time we will wait after getting right number of rings
    // to allow input buffer to flush
    ulWaitTime = 500L;
    if (!fImmediate && pTG->NCUParams2.RingsBeforeAnswer>3)
    {
        startTimeOut(pTG, &pTG->toAnswer, (6000L * (pTG->NCUParams2.RingsBeforeAnswer-3)));
        for (PrevRings=0;;)
        {
            if (pTG->fAbort)
            {
                DebugPrintEx(DEBUG_ERR,"Class2Answer aborting");
                pTG->fAbort = FALSE;
                Class2ModemHangup(pTG);
                return CONNECT_ERROR;
            }

            // get S1 value & check it here.
            // If we get an error don't look
            // at return value. Just try again
            if ((uRet=Class2iModemDialog(   pTG, 
                                            pTG->cbszQUERY_S1,
                                            (UWORD)(strlen(pTG->cbszQUERY_S1)),
                                            2000L, 
                                            TRUE, 
                                            0,
                                            pTG->cbszCLASS2_OK, 
                                            pTG->cbszZERO, 
                                            pTG->cbszRING, 
                                            pTG->cbszCLASS2_ERROR,
                                            (C2PSTR)NULL) ) > 2)
            {
                    goto xxxx;
            }

            // If the OK was matched, the answer to the ATS1 is in pTG->bLastReply2.
            // If a string like "001" was matched, the answer is in
            // pTG->bFoundReply.
            if (uRet == 2)
            {
                sz=pTG->bFoundReply;
            }
            else 
            {
                sz=pTG->bLastReply2;
            }
            for (i=0, Rings=0;i<REPLYBUFSIZE && sz[i]; i++)
            {
                if (sz[i] >= '0' &&  sz[i] <= '9')
                {
                    Rings = Rings*10 + (sz[i] - '0');
                }
                // ignore all non-numeric chars
            }
            DebugPrintEx(   DEBUG_MSG,
                            "Got %d Rings. Want %d", 
                            Rings, 
                            pTG->NCUParams2.RingsBeforeAnswer);

            // See if the number of rings we have is more than the
            // Autoanswer number of rings. Also, for those stupid
            // modems that always return 000 to ATS1, we will answer
            // right away. 000 cannot be correct, and we don't want
            // to get stuck looking at 000.
            if (Rings >= (pTG->NCUParams2.RingsBeforeAnswer-3))
            {
                break;
            }

            // If we saw a 000, estimate how much time we had to wait
            // to get to the total number of rings we wanted. Figure
            // we were already at three rings or so.
            // If we counted the rings, we will still wait 1/2 second
            // to allow any "OK" that might be coming from the modem to
            // appear. We then will flush the queue.
            if (Rings == 0)
            {
                if (pTG->NCUParams2.RingsBeforeAnswer >= 4)
                {
                    ulWaitTime = (pTG->NCUParams2.RingsBeforeAnswer-3)*6000L;
                }
                else 
                {
                    ulWaitTime = 500L;
                }
                break;
            }

            Sleep(IDLESLICE);

    xxxx:
            if ((Rings < PrevRings) || !checkTimeOut(pTG, &pTG->toAnswer))
            {
                break;  // some screwup, but answer anyway!!
            }

            PrevRings = Rings;
        }
    }

    // We may still have an "OK" coming from the modem as a result of the
    // ATS1 command. We need to wait a bit and flush it. In most cases we
    // just wait 500 milliseconds. But, if we saw a 000 from the ATS1, we
    // broke immediately out of the loop above, setting ulWaitTime to be
    // the approximate wait we need before answering the phone.

    startTimeOut(pTG, &pTG->toAnswer, ulWaitTime);
    while (checkTimeOut(pTG, &pTG->toAnswer)) 
    {
    }
    FComFlush(pTG );

    // Send the preanswer command
    if (pTG->lpCmdTab->szPreAnswer && (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreAnswer)))
    {
        if (Class2iModemDialog( pTG, 
                                (LPSTR)pTG->lpCmdTab->szPreAnswer, 
                                swLen,
                                10000L, 
                                TRUE, 
                                0,
                                pTG->cbszCLASS2_OK, 
                                pTG->cbszCLASS2_ERROR, 
                                (C2PSTR)NULL) != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Error on User's PreAnswer str: %s", (LPSTR)pTG->lpCmdTab->szPreAnswer);
        }
    }


#define ANSWER_TIMEOUT 35000
// Need to wait reasonably long, so that we don't give up too easily
// 7/25/95 JosephJ This used to be 15000. Changed to 35000 because
// MWAVE devices needed that timeout. Also, T.30 says that callee
// should try to negotiate for T1 seconds. T1 = 35 +/- 5s.

    /*
    * Send ATA command. The result will be stored in the global
    * variable pTG->lpbResponseBuf2. We will parse that in the Class2Receive
    * routine.
    */

    ICommStatus(pTG, T30STATR_ANSWERING, 0, 0, 0);

    // Look for ERROR return first and try again if it happened
    if ((uRet = Class2iModemDialog( pTG, 
                                    pTG->cbszATA, 
                                    (UWORD)(strlen(pTG->cbszATA)),
                                    ANSWER_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK, 
                                    pTG->cbszCLASS2_ERROR,
                                    pTG->cbszCLASS2_FHNG, 
                                    (C2PSTR) NULL)) == 2)
    {
        DebugPrintEx(DEBUG_ERR,"ATA returned ERROR on first try");
        // dunno why we try this a 2nd time. But this time if we get ERROR
        // dont exit. The Racal modem (bug#1982) gives ERROR followed by a
        // good response! Cant ignore ERROR the first time otherwise we'll
        // change the ATA--ERROR--ATA(repeat) behaviour which seems to be
        // explicitly desired for some cases. However we dont take any
        // action based on the return value of the 2nd try, so it's safe to
        // ignore ERROR here. Worst case we take longer to timeout.
        uRet = Class2iModemDialog(  pTG, 
                                    pTG->cbszATA, 
                                    (UWORD)(strlen(pTG->cbszATA)),
                                    ANSWER_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_FHNG, 
                                    (C2PSTR) NULL);
    }

    if (uRet != 1) // a '1' return indicates OK.
    {
        DebugPrintEx(DEBUG_ERR,"Can't get OK after ATA");
        PSSLogEntry(PSS_ERR, 1, "Failed to answer - aborting");
        // try to hangup and sync with modem. This should work
        // even if phone is not really off hook

        if (!Class2ModemHangup(pTG))
        {
            // In WFW this can occur if an external modem has been
            // powered down. so just drop thru & return ERROR
            DebugPrintEx(DEBUG_ERR,"Can't Hangup after ANSWERFAIL");
        }
        return CONNECT_ERROR;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"ATA Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));
        return CONNECT_OK;
    }
}


SWORD Class2ModemSync(PThrdGlbl pTG)
{
    // The command used here must be guaranteed to be harmless,
    // side-effect free & non-dstructive. i.e. we can issue it
    // at any point in command mode without chnageing the state
    // of teh modem or disrupting anything.
    // ATZ does not qualify. AT does, I think.....
    SWORD ret_value;

    DEBUG_FUNCTION_NAME("Class2ModemSync");

    DebugPrintEx(DEBUG_MSG,"Calling Class2HayesSyncSpeed");
    ret_value = Class2HayesSyncSpeed(   pTG,  
                                        TRUE, 
                                        pTG->cbszCLASS2_ATTEN,
                                        (UWORD)(strlen(pTG->cbszCLASS2_ATTEN)));
    DebugPrintEx(DEBUG_MSG,"Class2HayesSyncSpeed returned %d ", ret_value);
    return ret_value;
}


BOOL Class2ModemHangup(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME("Class2ModemHangup");

    PSSLogEntry(PSS_MSG, 0, "Phase E - Hang-up");
    PSSLogEntry(PSS_MSG, 1, "Hanging up");
    if (Class2HayesSyncSpeed(   pTG,  
                                TRUE, 
                                pTG->cbszCLASS2_HANGUP,
                                (UWORD)(strlen(pTG->cbszCLASS2_HANGUP))) < 0)
    {
        DebugPrintEx(DEBUG_WRN,"Failed once");

        FComDTR(pTG, FALSE);    // Lower DTR on stubborn hangups in ModemHangup
        MY_TWIDDLETHUMBS(1000); // pause 1 second
        FComDTR(pTG, TRUE);     // raise it again. Some modems return to cmd state
                                // only when this is raised again

        if (Class2HayesSyncSpeed(   pTG, 
                                    TRUE, 
                                    pTG->cbszCLASS2_HANGUP,
                                    (UWORD)(strlen(pTG->cbszCLASS2_HANGUP))) < 0)
        {
            DebugPrintEx(DEBUG_ERR,"Failed again");
            return FALSE;
        }
    }
    DebugPrintEx(DEBUG_MSG,"HANGUP Completed");

    if (!iModemGoClass(pTG, 0))
    {
        return FALSE;
    }
    // Can also ignore this return value. Just for tidier cleanup
    DebugPrintEx(DEBUG_MSG,"Completed GoClass0");

    // Bug1982: Racal modem, doesnt accept ATA. So we send it a PreAnswer
    // command of ATS0=1, i.r. turning ON autoanswer. And we ignore the
    // ERROR response it gives to the subsequent ATAs. It then answers
    // 'automatically' and gives us all the right responses. On hangup
    // however we need to send an ATS0=0 to turn auto-answer off. The
    // ExitCommand is not sent at all in Class2 and in Class1 it is only
    // sent on releasing the modem, not between calls. So send an S0=0
    // after ATH0. If the modem doesnt like it we ignore the resp anyway.
    Class2iModemDialog( pTG, 
                        pTG->cbszCLASS2_CALLDONE, 
                        (UWORD)(strlen(pTG->cbszCLASS2_CALLDONE)),
                        LOCALCOMMAND_TIMEOUT, 
                        TRUE, 
                        0, 
                        pTG->cbszCLASS2_OK, 
                        pTG->cbszCLASS2_ERROR,
                        (C2PSTR)NULL);
    return TRUE;
}


void Class2Abort(PThrdGlbl pTG, BOOL fEnable)
{
    // Called when user invokes an abort - simply set the
    // abort flag to be true. Various places in the code look
    // for this flag and perform an abort. Flag was originally
    // set to false in LibMain (called upon startup).
    pTG->fAbort = fEnable;
}


BOOL Class2ModemAbort(PThrdGlbl pTG)
{
    // Try to abort modem in reasonable fashion - send the
    // abort command and then send hangup. The abort command
    // should hangup, but I am not convinced it always does!!!
    // It should not hurt to hang up again (I hope).

    DEBUG_FUNCTION_NAME("Class2ModemAbort");

    // We'll use a long timeout here to let the abort take place.
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszCLASS2_ABORT, 
                            (UWORD)(strlen(pTG->cbszCLASS2_ABORT)),
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            1, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        //Ignore failure
        DebugPrintEx(DEBUG_ERR,"FK Failed");
    }

    return Class2ModemHangup(pTG );
}



SWORD Class2HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, C2PSTR cbszCommand, UWORD uwLen)
{
    /* 
    Internal routine to synchronize with the modem's speed.  Tries to
    get a response from the modem by trying the speeds in rglSpeeds
    in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
    a response before trying to reset the speeds.

    Returns the speed it found, 0 if they're in sync upon entry (only
    checked if fTryCurrent!=0), or -1 if it couldn't sync.
    */
    // short i;

    /*  
    This was initially set to -1, which has to be wrong, since you
    do a BG_CHK to make sure fTryCurrent is TRUE, meaning you want
    to try the current speed.  In this case, -1 would be an invalid
    index.   KDB  
    */
    short ilWhich = 0;

    DEBUG_FUNCTION_NAME("Class2HayesSyncSpeed");

    BG_CHK( fTryCurrent);
    // has to be TRUE, or we won't work with autobauding modems

    /*  I don't understand how this would ever get executed.  KDB */
    if (!fTryCurrent)
    {
        if (!FComSetBaudRate(pTG,rguwClass2Speeds[++ilWhich]))
        {
                return -1;
        }
    }

    for(;;)
    {
        if (Class2SyncModemDialog(pTG,cbszCommand,uwLen,pTG->cbszCLASS2_OK))
        {
            return (ilWhich>=0 ? rguwClass2Speeds[ilWhich] : 0);
        }

        /* failed.  try next speed. */
        if (rguwClass2Speeds[++ilWhich]==0)
        {
            // Tried all speeds. No response
            DebugPrintEx(DEBUG_ERR,"Cannot Sync with Modem on Command %s", (LPSTR)cbszCommand);
            return -1;
        }
        if (!FComSetBaudRate(pTG,  rguwClass2Speeds[ilWhich]))
        {
            return -1;
        }
    }
}



USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME("Class2ModemRecvBuf");

    *lplpbf = MyAllocBuf(pTG, MY_BIGBUF_SIZE);
    if (*lplpbf == NULL)
    {
        DebugPrintEx(DEBUG_ERR, "MyAllocBuf failed trying to allocate %d bytes", MY_BIGBUF_SIZE);
        return RECV_OUTOFMEMORY;
    }

    uRet = Class2ModemRecvData( pTG,  
                                (*lplpbf)->lpbBegBuf,
                                (*lplpbf)->wLengthBuf, 
                                uTimeout, 
                                &((*lplpbf)->wLengthData));

    if  (!((*lplpbf)->wLengthData))
    {
        MyFreeBuf(pTG, *lplpbf);
        *lplpbf = NULL;
    }
    else
    {
        // If necessary, bit-reverse...
        if (pTG->CurrentMFRSpec.fSWFBOR && pTG->CurrentMFRSpec.iReceiveBOR==1)
        {
            DebugPrintEx(DEBUG_WRN,"SWFBOR Enabled. bit-reversing data");
            cl2_flip_bytes( (*lplpbf)->lpbBegBuf, ((*lplpbf)->wLengthData));
        }
    }

    return uRet;
}


USHORT Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout, USHORT far* lpcbRecv)
{
    SWORD   swEOF;

    BG_CHK(lpb && cbMax && lpcbRecv);

    startTimeOut(pTG, &pTG->toRecv, uTimeout);
    // 4th arg must be TRUE for Class2
    *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &pTG->toRecv, TRUE, &swEOF);

    switch(swEOF)
    {
    case 1:         // Class1 eof
    case -1:        // Class2 eof
                    return RECV_EOF;
    case 0:
                    return RECV_OK;
    default:
                    BG_CHK(FALSE);
                    // fall through
    case -2:
                    return RECV_ERROR;
    case -3:
                    return RECV_TIMEOUT;
    }
}


BOOL  Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount)
{
    DEBUG_FUNCTION_NAME("Class2ModemSendMem");

    BG_CHK(lpb);

    if (!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
    {
        goto error;
    }

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR,"Failed on AsyncWrite");
    FComOutFilterClose(pTG);
    FComXon(pTG, FALSE);
    return FALSE;
}

/*
output:
0 - timeout
1 - OK
2 - ERROR
*/        
DWORD Class2ModemDrain(PThrdGlbl pTG)
{
    DWORD dwResult = 0;
    DEBUG_FUNCTION_NAME("Class2ModemDrain");

    if (!FComDrain(pTG, TRUE, TRUE))
    {
        return FALSE;
    }

    // Must turn XON/XOFF off immediately *after* drain, but before we
    // send the next AT command, since Received frames have 0x13 or
    // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

    dwResult = Class2iModemDialog(pTG, 
                                  NULL, 
                                  0,
                                  STARTSENDMODE_TIMEOUT, 
                                  FALSE, 
                                  0, 
                                  pTG->cbszCLASS2_OK, 
                                  pTG->cbszCLASS2_ERROR,
                                  (C2PSTR)NULL);
    // Must change FlowControl State *after* getting OK because in Windows
    // this call takes 500 ms & resets chips, blows away data etc.
    // So do this *only* when you *know* both RX & TX are empty.

    // Turn off flow control.
    FComXon(pTG, FALSE);

    return dwResult;
}

void Class2TwiddleThumbs( ULONG ulTime)
{
    MY_TWIDDLETHUMBS(ulTime);
}


LPSTR Class2_fstrstr(LPSTR sz1, LPSTR sz2)
{
    int i, len1, len2;

    len1 = _fstrlen(sz1);
    len2 = _fstrlen(sz2);

    for(i=0; i<=(len1-len2); i++)
    {
        if(_fmemcmp(sz1+i, sz2, len2) == 0)
        {
            return sz1+i;
        }
    }
    return NULL;
}
                                                      

UWORD Class2iModemDialog
(
    PThrdGlbl pTG, 
    LPSTR szSend, 
    UWORD uwLen, 
    ULONG ulTimeout,
    BOOL fMultiLine, 
    UWORD uwRepeatCount,
    ...
)
{
/** Takes a command string, and it's lengt writes it out to the modem
    and tries to get one of the allowed responses. It writes the command
        out, waits ulTimeOut millisecs for a response. If it gets one of the
        expected responses it returns immediately.

        If it gets an unexpected/illegal response it tries (without any
        waiting) for subsequent lines to the same response.     When all the
        lines (if > 1) of the response lines are exhausted, if none is among the
        expected responses, it writes the command again and tries again,
        until ulTimeout has expired. Note that if no response is received,
        the command will be written just once.

        The whole above thing will be repeated upto uwRepeatCount times
        if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

        It returns when (a) one of the specified responses is received or
        (b) uwRepeatCount tries have failed (each having returned an
        illegal response or having returned no response in ulTimeout
        millsecs) or (c) the command write failed, in which
        case it returns immediately.

        It flushes the modem inque before each Command Write.

        Returns 0 on failure and the 1 based index of the successful
        response on     success.

        This can be used in the following way:-

        for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
        value, of the order of the transmission time of the longest
        possible (erroneous or correct) line of response plus the size
        of the command. eg. at 1200baud we have about 120cps = about
        10ms/char. Therefore a timeout of about 500ms is more than
        adequate, except for really long command lines.

        for Local Sync dialogs, used to sync up with the modem which may
        be in an unsure state, use the same timeout, but also a repeat
        count of 2 or 3.

        for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
        after the flags have been received, and which may incur a delay
        before a response (ATDT is teh same. CONNECT is issued after a
        long delay & anything the DTE sends will abort the process).
        For these cases the caller should supply a long timeout and
        probably a repeatcount of 1, so that the
        routine will timeout after one try but go on issuing teh command
        as long as an error repsonse is received.

        For +FRH etc, the long timeout should be T1 or T2 in teh case of
        CommandRecv and ResponseRecv respectively.

**/
    BYTE bReply[REPLYBUFSIZE];
    UWORD   i, j, uwRet, uwWantCount;
    SWORD   swNumRead;
    C2PSTR  rgcbszWant[10];
    va_list args;
    LPTO    lpto, lptoRead, lpto0;
    BOOL    fTimedOut;


    DEBUG_FUNCTION_NAME("Class2iModemDialog");
    // extract the (variable length) list of acceptable responses.
    // each is a C2SZ, code based 2 byte ptr

    va_start(args, uwRepeatCount);  // Ansi Defintion

    for(j=1; j<10; j++)
    {
        if((rgcbszWant[j] = va_arg(args, C2PSTR)) == NULL)
        {
            break;
        }
    }
    uwWantCount = j-1;
    va_end(args);

    pTG->lpbResponseBuf2[0] = 0;
    BG_CHK(uwWantCount>0);

    lpto = &pTG->toDialog;
    lpto0 = &pTG->toZero;
    // Try the dialog upto uwRepeatCount times
    for (uwRet=0, i=0; i<=uwRepeatCount; i++)
    {
        startTimeOut(pTG, lpto, ulTimeout);
        fTimedOut = FALSE;
        do
        {
            if (fTimedOut)
            {
                // Need to send anychar to abort the previous command.
                // We could recurse on this function, but the function
                // uses static (lpto vars etc)!!

                fTimedOut = FALSE;
                BG_CHK(swNumRead == 0);
                // use random 20ms timeout
                FComDirectSyncWriteFast(pTG, "\r", 1);
                startTimeOut(pTG, lpto0, 500);
                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
                DebugPrintEx(DEBUG_MSG,"AnykeyAbort got<<%s>>", (LPSTR)bReply);
            }

            if(szSend)
            {
                // If a command is supplied, write it out, flushing input
                // first to get rid of spurious input.

                // FComInputFlush();
                FComFlush(pTG, );            // Need to flush output too?

                // Need to check that we are sending only ASCII or pre-stuffed data here
                PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", szSend);
                if (!FComDirectSyncWriteFast(pTG,  szSend, uwLen))
                {
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Write timed Out");
                    uwRet = 0;
                    goto done;
                    // If Write fails, fail & return immediately.
                    // SetMyError() will already have been called.
                }
            }

            // Try to get a response until timeout or bad response
            pTG->bLastReply2[0] = 0;
            for (lptoRead=lpto;;startTimeOut(pTG, lpto0, ulTimeout), lptoRead=lpto0)
            {
                // First, check for abort. If we are aborting,
                // return failure from here. That will cause
                // many commands to stop.
                if (pTG->fAbort)
                {
                    DebugPrintEx(DEBUG_ERR,"ABORTING...");
                    pTG->fAbort = FALSE;
                    uwRet = 0;
                    goto end;
                }

                // get a CR-LF terminated line
                // for the first line use macro timeout, for multi-line
                // responses use 0 timeout.

                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);
                if(swNumRead < 0)
                {
                    swNumRead = (-swNumRead);       // error-but lets see what we got anyway
                }
                else if (swNumRead == 0)
                {
                    break;                                          // Timeout -- restart dialog or exit
                }
                if (swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                {
                    continue;                                       // blank line -- throw away & get another
                }

                // COPIED THIS FROM DUP FUNCTION IN MODEM.C!!
                // Fix Bug#1226. Elsa Microlink returns this garbage line in
                // response to AT+FDIS?, followed by the real reply. Since
                // we only look at the first line, we see only this garbage line
                // and we never see the real reply
                if (swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                {
                    continue;
                }

                PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);

                for(bReply[REPLYBUFSIZE-1]=0, j=1; j<=uwWantCount; j++)
                {
                    if(Class2_fstrstr(bReply, rgcbszWant[j]) != NULL)
                    {
                        uwRet = j;
                        // It matched!!!
                        // Save this reply. This is used when checking
                        // ATS1 responses
                        _fmemcpy(pTG->bFoundReply, bReply, REPLYBUFSIZE);
                        goto end;
                    }
                }
                if(!fMultiLine)
                {
                    continue;
                }
                // go to ulTimeout check. i.e. *don't* set fTimedOut
                // but don't exit either. Retry command and response until
                // timeout


                // We reach here it IFF we got a non blank reply, but it wasn't what
                // we wanted. Squirrel teh first line away somewhere so that we can
                // retrieve is later. We use this hack to get multi-line informational
                // responses to things like +FTH=? Very important to ensure that
                // blank-line replies don't get recorded here. (They may override
                // the preceding line that we need!).

                // Use the far pointer version
                _fmemcpy(pTG->bLastReply2, bReply, REPLYBUFSIZE);
                // In pTG->lpbResponseBuf2, all received lines are
                // saved, not just the last one. This is used
                // for multiline responses, like the response
                // to a Class 2 ATD command
                // pTG->lpbResponseBuf2[0] was initialized at the
                // start of this routine.
                // Ignore lines past the buffer size...
                // no valid response would be that long anyway
                if ( (_fstrlen((LPB)pTG->lpbResponseBuf2)+_fstrlen((LPB)bReply) ) < RESPONSE_BUF_SIZE)
                {
                    _fstrcat((LPB)pTG->lpbResponseBuf2, (LPB)bReply);
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Response too long!");
                    uwRet = 0;
                    goto end;
                }
            }
            // we come here only on timeout.
            fTimedOut = TRUE;
        }
        while (checkTimeOut(pTG, lpto));
    }

end:
    if (uwRet == 0)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "(%s) --> (%d)(%s, etc) Failed", 
                        (LPSTR)(szSend?szSend:"null"), 
                        uwWantCount,
                        (LPSTR)rgcbszWant[1]);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"GOT IT %d (%s)", uwRet, (LPSTR)(rgcbszWant[uwRet]));
    }

done:
    return uwRet;
}


/* Converts the code for a speed to the speed in BPS */
// These are in the same order as the return values
// for DIS/DCS frames defined in the Class 2 spec in
// Table 8.4


/* Converts a DCS min-scan field code into millisecs */
// One array is for normal (100 dpi) res, the other for high (200 dpi) res...
// The ordering of the arraies is based on the values that
// are defined in filet30.h - THEY ARE NOT THE SAME AS THE VALUES
// RETURNED IN THE DCS FRAME!!!! This is inconsistent with baud rate
// but it is consistent with the Class 1 code...
BYTE msPerLineNormalRes[8] = { 20, 5, 10, 20, 40, 40, 10, 0 };
BYTE msPerLineHighRes[8] =   { 20, 5, 10, 10, 40, 20, 5, 0 };





USHORT Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution)
{
    USHORT uStuff;
    BYTE ms;

    DEBUG_FUNCTION_NAME("Class2MinScanToBytesPerLine");

    uStuff = Class2CodeToBPS[Baud];
    BG_CHK(uStuff);
    if ( Resolution & AWRES_mm080_077)
    {
        ms = msPerLineHighRes[Minscan];
    }
    else 
    {
        ms = msPerLineNormalRes[Minscan];
    }
    uStuff /= 100;          // StuffBytes = (BPS * ms)/8000
    uStuff *= ms;           // take care not to use longs
    uStuff /= 80;           // or overflow WORD or lose precision
    uStuff += 1;            // Rough fix for truncation problems

    DebugPrintEx(DEBUG_MSG,"Stuffing %d bytes", uStuff);
    return uStuff;
}

// Convert the SEND_CAPS or SEND_PARAMS BC structure into values used by
// the +FDCC, +FDIS, and +FDT commands
                          
                                                        
                                                                                    
void Class2SetDIS_DCSParams
(
    PThrdGlbl pTG, 
    BCTYPE bctype, 
    LPUWORD Encoding, 
    LPUWORD Resolution,
    LPUWORD PageWidth, 
    LPUWORD PageLength, 
    LPSTR szID
)
{
    LPBC lpbc;

    DEBUG_FUNCTION_NAME("Class2SetDIS_DCSParams");

    DebugPrintEx(DEBUG_MSG,"Type = %d", (USHORT)bctype);

    if (bctype == SEND_PARAMS)
    {
        lpbc = (LPBC)&pTG->bcSendParams;
    }
    else
    {
        lpbc = (LPBC)&pTG->bcSendCaps;
    }

    // Set the ID
    szID[0] = '\0';

    BG_CHK(lpbc->wTotalSize >= sizeof(BC));
    BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendCaps));
    BG_CHK(sizeof(pTG->bcSendCaps) == sizeof(pTG->bcSendParams));

    // GetNumId(lpbc, szID, 21); else
    //GetTextId(lpbc, szID, 21); // 20 + 1 for 0-term

    if (pTG->LocalID) 
    {
       strcpy (szID, pTG->LocalID);
    }

    switch(lpbc->Fax.Encoding)
    {
    case MH_DATA:                           *Encoding = 0;
                                            break;
    case MR_DATA:
    case (MR_DATA | MH_DATA):               *Encoding = 1;
                                            break;
    case MMR_DATA:
    case (MMR_DATA | MH_DATA):
    case (MMR_DATA | MR_DATA):
    case (MMR_DATA | MR_DATA | MH_DATA):    *Encoding = 3;
                                            break;

    default:                                DebugPrintEx(DEBUG_ERR,"Bad Encoding type %x",lpbc->Fax.Encoding);
                                            break;
    }

    if ( (lpbc->Fax.AwRes) & AWRES_mm080_077)
    {
        *Resolution = 1;
    }
    else if ( (lpbc->Fax.AwRes) & AWRES_mm080_038)
    {
        *Resolution = 0;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"Bad Resolution type %x",lpbc->Fax.AwRes);
    }

    switch (lpbc->Fax.PageWidth & 0x3)
    {
    case WIDTH_A4:      // 1728 pixels
                        *PageWidth = 0;
                        break;
    case WIDTH_B4:      // 2048 pixels
                        *PageWidth = 1;
                        break;
    case WIDTH_A3:      // 2432 pixels
                        *PageWidth = 2;
                        break;
    default:            DebugPrintEx(DEBUG_ERR,"Bad PageWidth type %x", lpbc->Fax.PageWidth);
                        break;
    }

    switch(lpbc->Fax.PageLength)
    {
    case LENGTH_A4:         *PageLength = 0;
                            break;
    case LENGTH_B4:         *PageLength = 1;
                            break;
    case LENGTH_UNLIMITED:  *PageLength = 2;
                            break;
    default:                DebugPrintEx(DEBUG_ERR,"Bad PageLength type %x", lpbc->Fax.PageLength);
                            break;
    }
}



BOOL Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb)
{
    USHORT count, i;
    BOOL   fFoundDIS_DCS;

    DEBUG_FUNCTION_NAME("Class2ResponseAction");

    fFoundDIS_DCS = FALSE;

    _fmemset(lpPcb, 0, sizeof(PCB));

    if (pTG->ModemClass == MODEM_CLASS2) 
    {
        Class2Parse( pTG, &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }
    else 
    {
       Class20Parse( pTG, &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }

    DebugPrintEx(   DEBUG_MSG, 
                    "Number of commands is %d",
                    pTG->class2_commands.comm_count);
    for (count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        // (MyDebugPrint (pTG, LOG_ALL, "Loading PCB for command %d\n\r",
        // pTG->class2_commands.command[count]));
        switch (pTG->class2_commands.command[count])
        {
            case  CL2DCE_FDIS:
            case  CL2DCE_FDCS:

                    DebugPrintEx(DEBUG_MSG,"Found DCS or DIS");
                    fFoundDIS_DCS = TRUE;
                    //  Assign resolution.
                    if( pTG->class2_commands.parameters[count][0] == 0)
                    {
                        lpPcb->Resolution = AWRES_mm080_038;
                        DebugPrintEx(DEBUG_MSG,"Normal resolution");
                    }
                    else if (pTG->class2_commands.parameters[count][0] & 1 )
                    {
                        // Resolution when reported by a DIS frame indicates
                        // it accepts either fine or normal. When reported
                        // in a DCS, it means the negotiated value is FINE.
                        if (pTG->class2_commands.command[count] == CL2DCE_FDIS)
                        {
                            // we received a DIS
                            lpPcb->Resolution = AWRES_mm080_038 | AWRES_mm080_077;
                            DebugPrintEx(DEBUG_MSG,"Normal & Fine resolution");
                        }
                        else
                        {
                            // we received a DCS
                            lpPcb->Resolution = AWRES_mm080_077;
                            DebugPrintEx(DEBUG_MSG,"Fine resolution");
                        }
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_MSG,"Fall through - Fine resolution");
                        lpPcb->Resolution = AWRES_mm080_077;
                    }

                    //  Assign encoding scheme.
                    if( pTG->class2_commands.parameters[count][4] == 0)
                    {
                        lpPcb->Encoding = MH_DATA;
                        DebugPrintEx(DEBUG_MSG,"MH Encoding");
                    }
                    else if ((pTG->class2_commands.parameters[count][4] == 1) ||
                             (pTG->class2_commands.parameters[count][4] == 2) ||
                             (pTG->class2_commands.parameters[count][4] == 3) )
                    {
                        lpPcb->Encoding = MH_DATA | MR_DATA;
                        DebugPrintEx(DEBUG_MSG,"MR Encoding");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Failed to assign encoding");
                        return FALSE;
                    }

                    //  Assign page width.
                    if( pTG->class2_commands.parameters[count][2] == 0)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 1)
                    {
                        lpPcb->PageWidth = WIDTH_B4;
                        DebugPrintEx(DEBUG_MSG,"B4 Width");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 2)
                    {
                        lpPcb->PageWidth = WIDTH_A3;
                        DebugPrintEx(DEBUG_MSG,"A3 Width");
                    }
                    // We don't support 3 and 4 (A5, A6)
                    // but we'll still allow them and map them to A4
                    // This is for Elliot bug #1252 - it should have
                    // no deleterious effect, since this width field
                    // is not used for anything at the point in where
                    // bug 1252 occurs. FrankFi
                    else if (pTG->class2_commands.parameters[count][2] == 3)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width - we don't support A5");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 4)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width - we don't support A6");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Failed to assign width");
                        return FALSE;
                    }

                    //  Assign page length.
                    if( pTG->class2_commands.parameters[count][3] == 0)
                    {
                        lpPcb->PageLength = LENGTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Length");
                    }
                    else if (pTG->class2_commands.parameters[count][3] == 1)
                    {
                        lpPcb->PageLength = LENGTH_B4;
                        DebugPrintEx(DEBUG_MSG,"B4 Length");
                    }
                    else if (pTG->class2_commands.parameters[count][3] == 2)
                    {
                        lpPcb->PageLength = LENGTH_UNLIMITED;
                        DebugPrintEx(DEBUG_MSG,"Unlimited Length");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Invalid length");
                        // assume it is unlimited! Some modems
                        // screw up on length.
                        lpPcb->PageLength = LENGTH_UNLIMITED;
                    }

                    //  Assign baud rate
                    //  For now, we will use the raw numbers returned in the
                    //  DCS command. Dangerous - should fix later!
                    //  These numbers will be tied to the baud rate array in
                    //  the routine that figures out zero byte stuffing from
                    //  the scan line and baud rate.

                    // Fixed the Hack--added a Baud field
                    lpPcb->Baud = pTG->class2_commands.parameters[count][1];

                    //  Assign minimum scan time - the first number
                    //  in the MINSCAN_num_num_num constant
                    //  refers to scan time in ms for 100dpi, the
                    //  second for 200dpi, and the last for 400dpi
                    //  Class 2 does not use the 400dpi number,
                    //  but these variables are shared with Class 1
                    if( pTG->class2_commands.parameters[count][7] == 0)
                    {
                        lpPcb->MinScan = MINSCAN_0_0_0;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 1)
                    {
                        lpPcb->MinScan = MINSCAN_5_5_5;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 2)
                    {
                        lpPcb->MinScan = MINSCAN_10_5_5;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 3)
                    {
                        lpPcb->MinScan = MINSCAN_10_10_10;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 4)
                    {
                        lpPcb->MinScan = MINSCAN_20_10_10;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 5)
                    {
                        lpPcb->MinScan = MINSCAN_20_20_20;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 6)
                    {
                        lpPcb->MinScan = MINSCAN_40_20_20;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 7)
                    {
                        lpPcb->MinScan = MINSCAN_40_40_40;
                    }
                    
                    break;

            case  CL2DCE_FCSI:
            case  CL2DCE_FTSI:
                    for (i=0; (lpPcb->szID[i]=pTG->class2_commands.parameters[count][i])!='\0'; ++i);

                    // prepare CSID for logging by FaxSvc

                    pTG->RemoteID = AnsiStringToUnicodeString(lpPcb->szID);
                    if (pTG->RemoteID) 
                    {
                        pTG->fRemoteIdAvail = 1;
                    }
                    break;
            default:
                    // (MyDebugPrint (pTG, LOG_ALL, "Class2ResponseAction: Unknown token.\r\n"));
                    break;
        }
    }

    return fFoundDIS_DCS;
}

USHORT Class2EndPageResponseAction(PThrdGlbl pTG)
{
    USHORT csi_count = 0,count;

    DEBUG_FUNCTION_NAME("Class2EndPageResponseAction");

    if (pTG->ModemClass == MODEM_CLASS2) 
    {
        Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }
    else 
    {
       Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }

    for(count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        switch (pTG->class2_commands.command[count])
        {
        case CL2DCE_FET:
            switch (pTG->class2_commands.parameters[count][0])
            {
            case 0:  PSSLogEntry(PSS_MSG, 1, "Received MPS");
                     DebugPrintEx(DEBUG_MSG,"More pages coming");
                     return MORE_PAGES;
            case 1:  PSSLogEntry(PSS_MSG, 1, "Received EOM");
                     DebugPrintEx(DEBUG_MSG,"No more pages coming");
                     return NO_MORE_PAGES;
            case 2:  PSSLogEntry(PSS_MSG, 1, "Received EOP");
                     DebugPrintEx(DEBUG_MSG,"No more pages coming");
                     return NO_MORE_PAGES;
            default: PSSLogEntry(PSS_MSG, 1, "Received unknown response");
                     DebugPrintEx(DEBUG_MSG,"No more pages coming");
                     return NO_MORE_PAGES;
            }
            break;
        case CL2DCE_FPTS:
            pTG->FPTSreport = pTG->class2_commands.parameters[count][0];
            DebugPrintEx(DEBUG_MSG, "FPTS returned %d", pTG->FPTSreport);
            break;
        }
    }
    return FALSE;
}

void Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype)
{
        _fmemset(lpbc, 0, uSize);
        lpbc->bctype = bctype;
        lpbc->wBCVer = VER_AWFXPROT100;
        lpbc->wBCSize = sizeof(BC);
        lpbc->wTotalSize = sizeof(BC);

/********* This is incorrect ****************************
        lpbc->Std.GroupNum              = GROUPNUM_STD;
        lpbc->Std.GroupLength   = sizeof(BCSTD);
        // set Protocol Ver etc (everything else) to 00
        // set all IDs to 0 also. Fax stuff set later
********* This is incorrect ****************************/

/**
        lpbc->Fax.AwRes = (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300);
        lpbc->Fax.Encoding   = MH_DATA;    // ENCODE_ALL eventually!
        lpbc->Fax.PageWidth  = WIDTH_A4;
        lpbc->Fax.PageLength = LENGTH_UNLIMITED;
        lpbc->Fax.MinScan    = MINSCAN_0_0_0;
**/

}

void Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb)
{
    USHORT uLen;

    lpbc->Fax.AwRes         = lppcb->Resolution;
    lpbc->Fax.Encoding      = lppcb->Encoding;
    lpbc->Fax.PageWidth     = lppcb->PageWidth;
    lpbc->Fax.PageLength    = lppcb->PageLength;
    // lpbc->Fax.MinScan    = lppcb->MinScan;

    BG_CHK(lpbc->wTotalSize >= sizeof(BC));
    BG_CHK(lpbc->wTotalSize < uMaxSize);

    if (uLen = (SWORD)_fstrlen(lppcb->szID))
    {
        PutTextId( lpbc, uMaxSize, lppcb->szID, uLen, TEXTCODE_ASCII);
        // PutNumId(lpbc, szID, uLen);
    }
}

BOOL Class2GetBC(PThrdGlbl pTG, BCTYPE bctype)
{
    USHORT  uLen;
    LPBC    lpbc;

    DEBUG_FUNCTION_NAME("Class2GetBC");

    if(bctype == BC_NONE)
    {
        DebugPrintEx(DEBUG_MSG,"entering, type = BC_NONE");
        Class2InitBC(pTG, (LPBC)&pTG->bcSendCaps, sizeof(pTG->bcSendCaps), SEND_CAPS);
        pTG->bcSendCaps.Fax.AwRes      = (AWRES_mm080_038 | AWRES_mm080_077);
        pTG->bcSendCaps.Fax.Encoding   = MH_DATA;
        pTG->bcSendCaps.Fax.PageWidth  = WIDTH_A4;
        pTG->bcSendCaps.Fax.PageLength = LENGTH_UNLIMITED;
        return TRUE;
    }

    if(!(lpbc = ICommGetBC(pTG, bctype, TRUE)))
    {
        BG_CHK(FALSE);
        return FALSE;
    }

    DebugPrintEx(DEBUG_MSG, "Class2GetBC: entering, type = %d\n\r", bctype);
    DebugPrintEx(DEBUG_MSG, "Some params: encoding = %d, res = %d\n\r", lpbc->Fax.Encoding, lpbc->Fax.AwRes);

    // Depending on the type, pick the correct global BC structure

    BG_CHK(lpbc->wTotalSize >= sizeof(BC));

    if (bctype == SEND_CAPS)
    {
        BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendCaps));
        uLen = min(sizeof(pTG->bcSendCaps), lpbc->wTotalSize);
        _fmemcpy(&pTG->bcSendCaps, lpbc, uLen);
        return TRUE;
    }
    else if (bctype == SEND_PARAMS)
    {
        BG_CHK(lpbc->wTotalSize < sizeof(pTG->bcSendParams));
        uLen = min(sizeof(pTG->bcSendParams), lpbc->wTotalSize);
        _fmemcpy(&pTG->bcSendParams, lpbc, uLen);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL  Class2NCUSet(PThrdGlbl pTG, LPNCUPARAMS NCUParams2)
{
    DEBUG_FUNCTION_NAME("Class2NCUSet");

    BG_CHK(NCUParams2);

    // Copy params into our local pTG->NCUParams2 struct
    pTG->NCUParams2 = *NCUParams2;

    return TRUE;
}

BOOL Class2SetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp)
{
    DEBUG_FUNCTION_NAME("Class2SetProtParams");

    pTG->ProtParams2 = *lp;

    DebugPrintEx(   DEBUG_MSG, 
                    "Set Class2ProtParams: fV17Send=%d fV17Recv=%d uMinScan=%d", 
                    " HighestSend=%d LowestSend=%d",
                    pTG->ProtParams2.fEnableV17Send, 
                    pTG->ProtParams2.fEnableV17Recv,
                    pTG->ProtParams2.uMinScan, 
                    pTG->ProtParams2.HighestSendSpeed,
                    pTG->ProtParams2.LowestSendSpeed);

    return TRUE;
}

void iNCUParamsReset(PThrdGlbl pTG)
{
    _fmemset(&pTG->NCUParams2, 0, sizeof(pTG->NCUParams2));
    pTG->lpCmdTab = 0;

    pTG->NCUParams2.uSize = sizeof(pTG->NCUParams2);
    // These are used to set S regs etc.
    // -1 means leave modem at default
    pTG->NCUParams2.DialtoneTimeout = -1;
    pTG->NCUParams2.DialPauseTime   = pTG->NCUParams2.FlashTime         = -1;
    // pTG->NCUParams2.PulseMakeBreak  = pTG->NCUParams2.DialBlind         = -1;
    pTG->NCUParams2.DialBlind         = -1;
    pTG->NCUParams2.SpeakerVolume   = pTG->NCUParams2.SpeakerControl    = -1;
    pTG->NCUParams2.SpeakerRing     = -1;

    // should be used in answer
    pTG->NCUParams2.RingsBeforeAnswer = 0;
    // should be used in Dial
    pTG->NCUParams2.AnswerTimeout = 60;
    // used in Dial
    pTG->NCUParams2.chDialModifier  = 'T';
}


BYTE rgbFlip256[256]  = {
        0x0,    0x80,   0x40,   0xc0,   0x20,   0xa0,   0x60,   0xe0,
        0x10,   0x90,   0x50,   0xd0,   0x30,   0xb0,   0x70,   0xf0,
        0x8,    0x88,   0x48,   0xc8,   0x28,   0xa8,   0x68,   0xe8,
        0x18,   0x98,   0x58,   0xd8,   0x38,   0xb8,   0x78,   0xf8,
        0x4,    0x84,   0x44,   0xc4,   0x24,   0xa4,   0x64,   0xe4,
        0x14,   0x94,   0x54,   0xd4,   0x34,   0xb4,   0x74,   0xf4,
        0xc,    0x8c,   0x4c,   0xcc,   0x2c,   0xac,   0x6c,   0xec,
        0x1c,   0x9c,   0x5c,   0xdc,   0x3c,   0xbc,   0x7c,   0xfc,
        0x2,    0x82,   0x42,   0xc2,   0x22,   0xa2,   0x62,   0xe2,
        0x12,   0x92,   0x52,   0xd2,   0x32,   0xb2,   0x72,   0xf2,
        0xa,    0x8a,   0x4a,   0xca,   0x2a,   0xaa,   0x6a,   0xea,
        0x1a,   0x9a,   0x5a,   0xda,   0x3a,   0xba,   0x7a,   0xfa,
        0x6,    0x86,   0x46,   0xc6,   0x26,   0xa6,   0x66,   0xe6,
        0x16,   0x96,   0x56,   0xd6,   0x36,   0xb6,   0x76,   0xf6,
        0xe,    0x8e,   0x4e,   0xce,   0x2e,   0xae,   0x6e,   0xee,
        0x1e,   0x9e,   0x5e,   0xde,   0x3e,   0xbe,   0x7e,   0xfe,
        0x1,    0x81,   0x41,   0xc1,   0x21,   0xa1,   0x61,   0xe1,
        0x11,   0x91,   0x51,   0xd1,   0x31,   0xb1,   0x71,   0xf1,
        0x9,    0x89,   0x49,   0xc9,   0x29,   0xa9,   0x69,   0xe9,
        0x19,   0x99,   0x59,   0xd9,   0x39,   0xb9,   0x79,   0xf9,
        0x5,    0x85,   0x45,   0xc5,   0x25,   0xa5,   0x65,   0xe5,
        0x15,   0x95,   0x55,   0xd5,   0x35,   0xb5,   0x75,   0xf5,
        0xd,    0x8d,   0x4d,   0xcd,   0x2d,   0xad,   0x6d,   0xed,
        0x1d,   0x9d,   0x5d,   0xdd,   0x3d,   0xbd,   0x7d,   0xfd,
        0x3,    0x83,   0x43,   0xc3,   0x23,   0xa3,   0x63,   0xe3,
        0x13,   0x93,   0x53,   0xd3,   0x33,   0xb3,   0x73,   0xf3,
        0xb,    0x8b,   0x4b,   0xcb,   0x2b,   0xab,   0x6b,   0xeb,
        0x1b,   0x9b,   0x5b,   0xdb,   0x3b,   0xbb,   0x7b,   0xfb,
        0x7,    0x87,   0x47,   0xc7,   0x27,   0xa7,   0x67,   0xe7,
        0x17,   0x97,   0x57,   0xd7,   0x37,   0xb7,   0x77,   0xf7,
        0xf,    0x8f,   0x4f,   0xcf,   0x2f,   0xaf,   0x6f,   0xef,
        0x1f,   0x9f,   0x5f,   0xdf,   0x3f,   0xbf,   0x7f,   0xff
};

#define FLIP(index) (lpb[(index)] = rgbFlip256[lpb[(index)]])

void    cl2_flip_bytes(LPB lpb, DWORD dw)
{
        while (dw>8)
        {
                FLIP(0); FLIP(1); FLIP(2); FLIP(3);
                FLIP(4); FLIP(5); FLIP(6); FLIP(7);
                dw-=8;
                lpb+=8;
        }

        while(dw)
        {
                FLIP(0);
                dw--;
                lpb++;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\cl2and20\class2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class2.c

Abstract:

    This is the main source for Class2 specific functions for fax-modem T.30 driver

Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    
                     
Revision History:

--*/

 
#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2                                           

 
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CLASS2
#include "pssframe.h"

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];
extern DWORD PageWidthInPixelsFromDCS[];

          
// Here is the table we are using so far for manufacturer specific stuff

MFRSPEC Class2ModemTable[] = {
        { "", "Practical Peripherals", "PM14400FXPPM", "", 1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "Practical Peripherals", "PM9600FXMT", "",   1, 2, "", FALSE, FALSE, FALSE ,FALSE},
        { "", "Everex Systems", "Everfax 24/96E", "",      0, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "ROCKWELL", "V.32AC", "",                    1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "ROCKWELL", "RC9624AC", "",                  1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "", "Multi-Tech", "MT1432BA", "",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "", "SIERRA", "SX196", "",                       1, 0, "", TRUE,  FALSE, FALSE, FALSE },
        { "", "EXAR", "ROCKWELL 144DP", "",                1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "ELSA", "MicroLink 2460TL", "",              1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "GVC", "ROCKWELL 144DP", "",                 1, 0, "", FALSE, TRUE,  TRUE , FALSE }, // Intel144Ex
        { "", "ADC", "SL144V32", "",                       1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "UMC", "", "",                               1, 0, "", FALSE, TRUE,  FALSE ,FALSE},
        { "", "NetComm", "", "",                           1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "", "HALCYON", "Bit Blitzer", "",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "", "", "", "",                                  1, 0, "", FALSE, FALSE, FALSE, FALSE }
        };




void
Class2Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;


   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszINITIAL_FDT,  "AT+FDT=%%1d,%%1d,%%1d,%%1d\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPTS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBOR=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FDCC=1,%%d,,,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FDCC=1,%%d,0,2,0,0,0,\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,0,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=1,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FDIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FDCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FDIS" );
   sprintf( pTG->cbszFDIS,          "AT+FDIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszZERO,          "0" );
   sprintf( pTG->cbszONE,           "1" );
   sprintf( pTG->cbszQUERY_S1,      "ATS1?\r" );
   sprintf( pTG->cbszRING,          "RING" );
   
   
   sprintf( pTG->cbszCLASS2_ATI,        "ATI\r" );
   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMFR?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMDL?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFDT_CNTL_Q,        "" );
   sprintf( pTG->cbszFCON,              "+FCON" );
   sprintf( pTG->cbszGO_CLASS2,         "AT+FCLASS=2\r" );
   sprintf( pTG->cbszFLID,              "AT+FLID=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_QUERY_CLASS,"AT+FCLASS=?\r" );
   sprintf( pTG->cbszCLASS2_GO_CLASS0,  "AT+FCLASS=0\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );      
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );    
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FK\r" );     
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );  
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIAL" ); 
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );        
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );   
   sprintf( pTG->cbszCLASS2_OK,         "OK" );          
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHNG" );    
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}



//  If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
//
BOOL T30Cl2Tx(PThrdGlbl pTG,LPSTR szPhone)
{
    LPSTR   lpszSection = pTG->FComModem.rgchKey;
    USHORT  uRet1, uRet2;
    BYTE    bBuf[200];
    BYTE    bTempBuf[200+RESPONSE_BUF_SIZE];
    LPBYTE  lpbyte;
    UWORD   Encoding, Res, PageWidth, PageLength, uwLen, uwRet;
    BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR    szTSI[max(MAXTOTALIDLEN,20)+4] = {0};
    BOOL    fBaudChanged;
    BOOL    RetCode;

    DEBUG_FUNCTION_NAME("T30Cl2Tx");

    uRet2 = 0;
    if (!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS if possible. If using PSI (IFAX/Winpad) then we
    // can't make callback this on the Sender. Only on Receiver! Otherwise
    // we deadlock & hang in PSI

    if (!Class2GetBC(pTG, SEND_CAPS)) // get send caps
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2
    if (!iModemGoClass(pTG, 2))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the send strings needed for
    // this modem.
    if (!Class2GetModemMaker(pTG ))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG, lpszSection);

    // Get the capabilities of the software. I am only using this
    // right now for the TSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    Class2SetDIS_DCSParams( pTG, 
                            SEND_CAPS, 
                            (LPUWORD)&Encoding, 
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength, 
                            (LPSTR) szTSI);

    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);

    if (!Class2iModemDialog(pTG, 
                            bIDBuf, 
                            uwLen,
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }

    // Turn off Bug mode
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszFBUG, 
                            (UWORD)(strlen(pTG->cbszFBUG)),
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FBUG failed");
        // Ignore FBUG failure!!!
    }

    // Find out what the default DIS is
    if (!pTG->CurrentMFRSpec.bIsExar)
    {
        if (!(uwRet=Class2iModemDialog( pTG, 
                                        pTG->cbszFDIS_IS, 
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0, 
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDIS failed");
            // ignore
        }
    }

    // See if the reply was ERROR or timeout, if so try a different command
    // Exar modems, for example, don't take AT+FDIS?
    if ((uwRet==2)||(uwRet==0)||pTG->CurrentMFRSpec.bIsExar)
    {
        // FDIS did not work!!! Try FDCC?
        if (!(uwRet=Class2iModemDialog( pTG, 
                                        pTG->cbszFDCC_IS,
                                        (UWORD)(strlen(pTG->cbszFDCC_IS)),
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0,
                                        pTG->cbszCLASS2_OK, 
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDCC_IS failed");
                // Ignore
        }

        if ((uwRet==2)||(uwRet==0))
        {
            // The FDCC failed - maybe it is an Exar that likes FDIS?
            // try that
            if (!(uwRet=Class2iModemDialog( pTG, 
                                            pTG->cbszFDIS_IS,
                                            (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                            LOCALCOMMAND_TIMEOUT, 
                                            TRUE, 
                                            0,
                                            pTG->cbszCLASS2_OK, 
                                            pTG->cbszCLASS2_ERROR, 
                                            (C2PSTR) NULL)))
            {
                DebugPrintEx(DEBUG_WRN,"FDIS_IS failed");
                //ignore
            }
            // Maybe it is the Class 2 modem referred to in
            // Elliot bug #1238 that wants FDIS without a
            // question mark
            if ((uwRet==2)||(uwRet==0))
            {
                if (!(uwRet=Class2iModemDialog( pTG, 
                                                pTG->cbszFDIS_NOQ_IS,
                                                (UWORD)(strlen(pTG->cbszFDIS_NOQ_IS)), 
                                                LOCALCOMMAND_TIMEOUT, 
                                                TRUE, 
                                                0,
                                                pTG->cbszCLASS2_OK, 
                                                (C2PSTR) NULL)))
                {
                    // No FDIS, FDCC worked - quit!
                    DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
                    uRet1 = T30_CALLFAIL;

                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                    RetCode = FALSE;

                    goto done;
                }
            }
        }

        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,lpbyte);
                _fstrcpy(lpbyte, bTempBuf);
                DebugPrintEx(DEBUG_MSG, "Leading comma in DCC string =%s", (LPSTR)&pTG->lpbResponseBuf2);
            }

            if ((*lpbyte>='0')&&(*lpbyte<='9'))
            {
                break;
            }
        }
    }

    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (Class2_fstrstr((LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        bTempBuf[0] = '\0';
        _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
        wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,(LPSTR)pTG->lpbResponseBuf2);
        _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
    }

    DebugPrintEx(DEBUG_MSG, "Received %s from FDIS", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if (Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE)
    {
        DebugPrintEx(DEBUG_WRN,"Failed to process FDIS Response");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"pTG->DISPcb baud value is %d",pTG->DISPcb.Baud);

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string constraining
    // the high end speed or if the user turned off V.17 for sending
    // Check the V.17 inhibit and lower baud if necessary
    if ((pTG->DISPcb.Baud>3)&&(!pTG->ProtParams2.fEnableV17Send))
    {
        DebugPrintEx(DEBUG_MSG, "Lowering baud from %d for V.17 inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }


    // Now see if the high end baud rate has been constrained
    if  (   (pTG->ProtParams2.HighestSendSpeed != 0) &&
            (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Have to lower baud from %d to %d", 
                        CodeToBPS[pTG->DISPcb.Baud], 
                        pTG->ProtParams2.HighestSendSpeed);

        fBaudChanged = TRUE;
        switch (pTG->ProtParams2.HighestSendSpeed)
        {
        case 2400:  pTG->DISPcb.Baud = 0;
                    break;
        case 4800:  pTG->DISPcb.Baud = 1;
                    break;
        case 7200:  pTG->DISPcb.Baud = 2;
                    break;
        case 9600:  pTG->DISPcb.Baud = 3;
                    break;
        case 12000: pTG->DISPcb.Baud = 4;
                    break;
        default:    DebugPrintEx(DEBUG_MSG,"Bad HighestSpeed");
                    uRet1 = T30_CALLFAIL;
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                    RetCode = FALSE;
                    goto done;                                               
                    break;
        }
    }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can send high res and we are not
    // claiming that we are sending MR or MMR. Also, see if we changed
    // the baud rate.

    if (    (pTG->DISPcb.Resolution & AWRES_mm080_077) && 
            ( pTG->DISPcb.Encoding == MH_DATA) && 
            (!fBaudChanged) )
    {
        //Do nothing - leave DIS alone!
        DebugPrintEx(DEBUG_MSG,"no need to change DIS");
    }
    else
    {
        // Send DCC command to the modem to set it up
        // Do the minimum necessary - only set resoultion if possible
        // (Again, this is because some modems don't like FDCC).
        if ((pTG->DISPcb.Encoding==MH_DATA)&&(!fBaudChanged))
        {
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszFDCC_RES, 
                                    (UWORD)(strlen(pTG->cbszFDCC_RES)),
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RES failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
        else if ( (pTG->DISPcb.Encoding == MH_DATA) && (fBaudChanged) )
        {
            // Changed the baud rate, but Encoding is OK.
            uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
            if (!Class2iModemDialog(pTG, 
                                    bBuf, 
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_BAUD failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
        else // the encoding format has changed
        {
            uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
            if (!Class2iModemDialog(  pTG, 
                                    bBuf, 
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_ALL failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
    }


    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
    if (!Class2iModemDialog(pTG, 
                            bBuf, 
                            uwLen, 
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE,
                            0, 
                            pTG->cbszCLASS2_OK, 
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBOR failed");
        // Ignore BOR failure!!!
    }

    // Dial the number

    // have to call hangup on every path out of here
    // after Dial is called. If Dial fails, it calls Hangup
    // if it succeeds we have to call Hangup when we're done

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

    SignalStatusChange(pTG, FS_DIALING);

    PSSLogEntry(PSS_MSG, 1, "Dialing %s", szPhone);

    if ((uRet2=Class2Dial(pTG, szPhone))!=CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR,"Class2Dial failed");
        uRet1 = T30_DIALFAIL;

        if (!pTG->fFatalErrorWasSignaled) 
        {
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;

        goto done;
    }

    ICommGotAnswer(pTG );
    // we should be using the sender msg here but that says Training
    // at speed=xxxx etc which we don't know, so we just use the
    // Recvr message which just says "negotiating"
    ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

    // Send the data
    uRet1 = (USHORT)Class2Send(pTG);
    if (uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"DONE WITH CALL, ALL OK");
        ICommStatus(pTG, T30STATS_SUCCESS, 0, 0, 0);

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG);

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"DONE WITH CALL, FAILED");
        ICommStatus(pTG, T30STATS_FAIL, 0, 0, 0);

        // Make sure Modem is in OK state
        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Class2ModemABort calls Hangup
        Class2ModemAbort(pTG );

        if (! pTG->fFatalErrorWasSignaled)  
        {
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_FATAL_ERROR);
        }
        
        RetCode = FALSE;
    }
    BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
    uRet2 = 0;

done:
    BG_CHK((uRet1 & 0xFF) == uRet1);
    BG_CHK((uRet2 & 0xFF) == uRet2);

    return RetCode;
}

BOOL Class2Send(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000;
    BOOL            err_status, fAllPagesOK = TRUE;
    BCwithTEXT      bc;

    UWORD           Encoding, Res, PageWidth, PageLength, uwLen;
    BYTE            bFDISBuf[200];
    CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
    BYTE            bNull = 0;
    DWORD           TiffConvertThreadId;

    DEBUG_FUNCTION_NAME("Class2Send");
    /*
    * We have just dialed... Now we have to look for the FDIS response from
    * the modem. It will be followed by an OK - hunt for the OK.
    */

    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    if (!Class2iModemDialog(pTG, 
                            NULL, 
                            0, 
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0,
                            pTG->cbszCLASS2_OK, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to get OK for FDIS");
        PSSLogEntry(PSS_ERR, 1, "Failed to receive DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // The response will be in pTG->lpbResponseBuf2 - this is loaded in
    // Class2iModemDialog.

    // (MyDebugPrint (pTG, LOG_ALL, "Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

    // Parse through the received strings, looking for the DIS, CSI,
    // NSF

    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        DebugPrintEx(DEBUG_MSG, "Failed to process ATD Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse received DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "DIS specified the following capabilities:");
    LogClass2DISDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    // Class2 modems do their own negotiation & we need to stay in sync
    // Otherwise, we might send MR data while the modem sends a DCS
    // saying it is MH. This happens a lot with Exar modems because
    // they dont accept an FDIS= command during the call.
    // FIX: On all Class2 sends force remote caps to always be MH
    // Then in efaxrun we will always negotiate MH & encode MH
    // We are relying on the fact that (a) it seems that all/most
    // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
    // negotiate MH and (c) We will override all non-Exar modem's
    // intrinsic negotiation by sending an AT+FDIS= just before the FDT
    // Also (d) This change makes our behaviour match Snowball exactly
    // so we will work no better or worse than it :-)
    bc.Fax.Encoding = MH_DATA;

    if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvCaps");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // now get the SEND_PARAMS
    if (!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC Failed");
        err_status = T30_CALLFAIL;
        return err_status;
    }

#ifdef FILET30
    // Send the raw capabilities string - most values
    // will be null, since CAS does not tell us things like
    // DIS, NSF, etc. But, we can put in the CSI.
    ICommRawCaps(pTG, (LPBYTE) &bNull, (LPBYTE) &bNull, 0, NULL, 0);
#endif

    ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);

    // Turn off flow control.
    FComXon(pTG, FALSE);

    // The Send params were set during the call to Class2GetBC
    // We'll use these to set the ID (for the TSI) and the DCS params

    // Send the FDT and get back the DCS. The FDT must be followed by
    // CONNECT and a ^Q (XON)
    // The FDT string must have the correct resolution and encoding
    // for this session. FDT=Encoding, Res, width, length
    // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
    // Res 0=200x100 (normal), 1=200x200 (fine)
    // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
    //              3=1216/151,4=864/107
    // PageLength 0=A4,1=B4,2=unlimited

    Class2SetDIS_DCSParams( pTG, 
                            SEND_PARAMS, 
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res, 
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI);

    //
    // Current Win95 version of Class2 TX is limited to MH only.
    // While not changing this, we will at least allow MR selection in future.
    //

    if (!pTG->fTiffThreadCreated) 
    {
        if (Encoding) 
        {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
        }
        else 
        {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
        }
    
        if (Res) 
        {
            pTG->TiffConvertThreadParams.HiRes = 1;
        }
        else 
        {
            pTG->TiffConvertThreadParams.HiRes = 0;
            // use LoRes TIFF file prepared by FaxSvc
            // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
        }

        _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
        pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

        DebugPrintEx(DEBUG_MSG,"Creating TIFF helper thread");
        pTG->hThread = CreateThread(NULL,
                                    0,
                                   (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                                   (LPVOID) pTG,
                                   0,
                                   &TiffConvertThreadId);
        if (!pTG->hThread) 
        {
            DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");

            err_status = T30_CALLFAIL;
            return err_status;
        }

        pTG->fTiffThreadCreated = 1;
        pTG->AckTerminate = 0;
        pTG->fOkToResetAbortReqEvent = 0;

        if ((pTG->RecoveryIndex >=0)&&(pTG->RecoveryIndex < MAX_T30_CONNECT)) 
        {
            T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
            T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum((LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                    sizeof(T30_RECOVERY_GLOB)/sizeof(DWORD)-1);
        }
    }

    // Even modems that take FDT=x,x,x,x don't seem to really do it
    // right. So, for now, just send FDIS followed by FDT except for
    // the EXAR modems!!
    if (pTG->CurrentMFRSpec.bIsExar)
    {
        if (!Class2iModemDialog(pTG, 
                                pTG->cbszFDT, 
                                (UWORD)(strlen(pTG->cbszFDT)),
                                STARTSENDMODE_TIMEOUT, 
                                TRUE, 
                                0,
                                pTG->cbszFDT_CONNECT,
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_ERR,"Failed get response from initial FDT!!");
            err_status =  T30_CALLFAIL;
            return err_status;
        }
    }
    else
    {
        uwLen = (WORD)wsprintf( bFDISBuf, 
                                pTG->cbszFDIS, 
                                Res,
                                min(Pcb.Baud, pTG->DISPcb.Baud), 
                                PageWidth, 
                                PageLength, 
                                Encoding);

        if (!Class2iModemDialog(pTG, 
                                bFDISBuf, 
                                uwLen, 
                                LOCALCOMMAND_TIMEOUT,
                                TRUE, 
                                0, 
                                pTG->cbszCLASS2_OK, 
                                pTG->cbszCLASS2_ERROR, 
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_ERR,"Failed get response from FDIS!!");
            // Ignore it -we are going to send what we have!
        }

        if (!Class2iModemDialog(pTG, 
                                pTG->cbszFDT, 
                                (UWORD)(strlen(pTG->cbszFDT)),
                                STARTSENDMODE_TIMEOUT,
                                TRUE, 
                                0,
                                pTG->cbszFDT_CONNECT,
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_MSG,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));
            DebugPrintEx(DEBUG_ERR,"FDT to start first PAGE Failed!");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        DebugPrintEx(DEBUG_MSG,"FDT Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }

    if (pTG->CurrentMFRSpec.fSkipCtrlQ)
    {
        DebugPrintEx(DEBUG_WRN,"Skipping <XON> - sending immedaitely after CONNECT");
    }
    // Get the  from the COMM driver
    else if (!FComGetOneChar(pTG, 0x11))
    {
        PSSLogEntry(PSS_WRN, 1, "Didn't receive <XON> - continuing anyway");
    }
    else
    {
        PSSLogEntry(PSS_MSG, 2, "recv:     <XON>");
    }

    // Turn on flow control.
    FComXon(pTG, TRUE);

    // Search through Response for the DCS frame - need it so set
    // the correct zero stuffing
    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDT Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse sent DCS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is \"%s\"", szTSI);
    PSSLogEntry(PSS_MSG, 1, "DCS was sent as follows:");
    LogClass2DCSDetails(pTG, &Pcb);

    // Got a response - see if baud rate is OK
    DebugPrintEx(   DEBUG_MSG,
                    "Negotiated Baud Rate = %d, lower limit is %d", 
                    Pcb.Baud, 
                    pTG->ProtParams2.LowestSendSpeed);

    if (CodeToBPS[Pcb.Baud]<(WORD)pTG->ProtParams2.LowestSendSpeed)
    {
        DebugPrintEx(DEBUG_ERR,"Aborting due to too low baud rate!");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // Use values obtained from the DCS frame to set zero stuffing.
    // (These were obtained by call to Class2ResponseAction above).
    // Zero stuffing is a function of minimum scan time (determined
    // by resolution and the returned scan minimum) and baud.
    // Fixed the Hack--added a Baud field

    // Init must be BEFORE SetStuffZero!
    FComOutFilterInit(pTG);
    FComSetStuffZERO(   pTG, 
                        Class2MinScanToBytesPerLine(pTG, 
                                                    Pcb.MinScan, 
                                                    (BYTE)Pcb.Baud, 
                                                    Pcb.Resolution));


    err_status =  T30_CALLDONE;
    while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
    {
        PSSLogEntry(PSS_MSG, 0, "Phase C - Page Transmission");
        PSSLogEntry(PSS_MSG, 1, "Sending page %d data...", pTG->PageCount);

        lTotalLen = 0;

        FComOverlappedIO(pTG, TRUE); // TRUE
        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
        {
            BG_CHK(lpbf && lpbf->wLengthData > 0);

            lTotalLen += lpbf->wLengthData;
            DebugPrintEx(DEBUG_MSG,"Total length: %ld",lTotalLen);

            if (!   (Class2ModemSendMem(   pTG, 
                                        lpbf->lpbBegData,
                                        lpbf->wLengthData) & 
                    (MyFreeBuf(pTG, lpbf))))
            {
                DebugPrintEx(DEBUG_ERR,"Class2ModemSendBuf Failed");
                PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }

            if (pTG->fAbort)
            {
                DebugPrintEx(DEBUG_WRN,"Abort during Send loop");
                pTG->fAbort = FALSE;
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }
        } // end of SEND_SEQ while

        FComOverlappedIO(pTG, FALSE);
        PSSLogEntry(PSS_MSG, 2, "send: page %d data, %d bytes", pTG->PageCount, lTotalLen);

        PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");
        // Terminate the Page with DLE-ETX
        if (!FComDirectAsyncWrite(pTG, pTG->Class2bDLEETX, 2))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><etx> - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully sent page data");

        if (1 != Class2ModemDrain(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"Failed to drain");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        //See if more pages to send...
        if (ICommNextSend(pTG) == NEXTSEND_MPS)
        {
            // We are about to send a second or more page. Terminate the
            // last page with FET=0, signalling a new one to come
            PSSLogEntry(PSS_MSG, 1, "Sending MPS");
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszENDPAGE, 
                                    (UWORD)(strlen(pTG->cbszENDPAGE)),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK, 
                                    (C2PSTR)NULL))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send MPS - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        else
        {
            // Purge input COM queue to purge all OKs 
            FComFlushInput(pTG);

            // Send end of message sequence
            PSSLogEntry(PSS_MSG, 1, "Sending EOP");
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszENDMESSAGE, 
                                    (UWORD)(strlen(pTG->cbszENDMESSAGE)),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK, 
                                    (C2PSTR)NULL))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send EOP - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        
        // Acknowledge that we sent the page
        // Parse the FPTS response and see if the page is good or bad.
        // Keep track of any bad pages in fAllPagesOK
        if (!ParseFPTS_SendAck(pTG ))
        {
            // fAllPagesOK = FALSE;  // It's still ok - we'll retransmit the page
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the same page again
            pTG->T30.ifrResp = ifrRTN;   
        }
        else
        {
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the next page
            pTG->T30.ifrResp = ifrMCF;   
        }

        if ((ICommNextSend(pTG) == NEXTSEND_MPS) || (pTG->T30.ifrResp == ifrRTN))
        {
            // Now, Send the FDT to start the next page (this was done for
            // the first page before entering the multipage loop).
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszFDT, 
                                    (UWORD)(strlen(pTG->cbszFDT)),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR)NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDT to start next PAGE Failed!");
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Get the  from the COMM driver
            if (!FComGetOneChar(pTG, 0x11))
            {
                PSSLogEntry(PSS_WRN, 1, "Didn't receive <XON> - proceeding to next page anyway");
            }
            else
            {
                PSSLogEntry(PSS_MSG, 2, "recv:     <XON>");
            }

            // Turn on flow control.
            FComXon(pTG, TRUE);
        } //if we do not have another page, do the else...
        else 
        {
            break; // All done sending pages...
        }

        if (err_status==T30_CALLFAIL)
        {
            break;
        }
    } //End of multipage while

    DebugPrintEx(DEBUG_MSG,"out of while multipage loop.");

    FComOutFilterClose(pTG);
    FComXon(pTG, FALSE);

    // If *any* page failed to send correctly, the call failed!
    if (!fAllPagesOK) 
    {
        err_status = T30_CALLFAIL;
    }
    return err_status;
}


/**************************************************************
        Receive specific routines start here
***************************************************************/

//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
BOOL  T30Cl2Rx(PThrdGlbl pTG)
{
    LPSTR           lpszSection = pTG->FComModem.rgchKey;
    USHORT          uRet1, uRet2;
    BYTE            bBuf[200],
                    bTempBuf[200+RESPONSE_BUF_SIZE];
    UWORD           uwLen, uwRet;
    UWORD           Encoding, Res, PageWidth, PageLength;
    BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
    LPBYTE          lpbyte;
    BOOL            fBaudChanged;
    BOOL            RetCode;

    DEBUG_FUNCTION_NAME("T30Cl2Rx");

    uRet2 = 0;
    if (!(pTG->lpCmdTab=iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS
    if (!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2
    // Elliot Bug#3421 -- incoming RING sometimes clobbers AT+FCLASS=1/2 cmd.
    if (pTG->lpCmdTab->dwFlags & fMDMSP_ANS_GOCLASS_TWICE)
    {
        iModemGoClass(pTG, 2);
    }
    if(!iModemGoClass(pTG, 2))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the receive strings needed for
    // this modem.
    if (!Class2GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG, lpszSection);

    // Get the capabilities of the software. I am only using this
    // right now for the CSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    _fmemset((LPB)szCSI, 0, sizeof(szCSI));
    Class2SetDIS_DCSParams( pTG, 
                            SEND_CAPS, 
                            (LPUWORD)&Encoding, 
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength, 
                            (LPSTR) szCSI);

    // Find out what the default DIS is
    if (!pTG->CurrentMFRSpec.bIsExar)
    {
        if (!(uwRet=Class2iModemDialog( pTG, 
                                        pTG->cbszFDIS_IS, 
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0, 
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDIS? failed");
            // ignore
        }
    }

    // See if the reply was ERROR or timeout, if so try a different command
    // Exar modems, for example, don't take AT+FDIS?
    if ((uwRet==2)||(uwRet==0)||pTG->CurrentMFRSpec.bIsExar)
    {
        // FDIS did not work!!! Try FDCC?
        if (!(uwRet=Class2iModemDialog( pTG, 
                                        pTG->cbszFDCC_IS,
                                        (UWORD)(strlen(pTG->cbszFDCC_IS)), 
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0,
                                        pTG->cbszCLASS2_OK, 
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDCC_IS failed");
                // Ignore
        }

        if ((uwRet==2)||(uwRet==0))
        {
            // The FDCC failed - maybe it is an Exar that likes FDIS?
            // try that
            if (!(uwRet=Class2iModemDialog( pTG, 
                                            pTG->cbszFDIS_IS,
                                            (UWORD)(strlen(pTG->cbszFDIS_IS)), 
                                            LOCALCOMMAND_TIMEOUT, 
                                            TRUE, 
                                            0,
                                            pTG->cbszCLASS2_OK, 
                                            pTG->cbszCLASS2_ERROR, 
                                            (C2PSTR) NULL)))
            {
                DebugPrintEx(DEBUG_WRN,"FDIS_IS failed");
                //ignore
            }
            // Maybe it is the Class 2 modem referred to in
            // Elliot bug #1238 that wants FDIS without a
            // question mark
            if ((uwRet==2)||(uwRet==0))
            {
                if (!(uwRet=Class2iModemDialog( pTG, 
                                                pTG->cbszFDIS_NOQ_IS,
                                                (UWORD)(strlen(pTG->cbszFDIS_NOQ_IS)),
                                                LOCALCOMMAND_TIMEOUT, 
                                                TRUE, 
                                                0,
                                                pTG->cbszCLASS2_OK, 
                                                (C2PSTR) NULL)))
                {
                    // No FDIS, FDCC worked - quit!
                    DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
                    uRet1 = T30_CALLFAIL;

                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                    RetCode = FALSE;

                    goto done;
                }
            }
        }

        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,lpbyte);
                _fstrcpy(lpbyte, bTempBuf);
                DebugPrintEx(DEBUG_MSG,"Leading comma in DCC string =%s",(LPSTR)&pTG->lpbResponseBuf2);
            }

            if ((*lpbyte>='0') && (*lpbyte<='9'))
            {
                break;
            }
        }
    }

    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (Class2_fstrstr( (LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        bTempBuf[0] = '\0';
        _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
        wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,(LPSTR)pTG->lpbResponseBuf2);
        _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
    }

    DebugPrintEx(DEBUG_MSG,"Received %s from FDIS?", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if (Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE)
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDIS Response");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string inhibiting
    // V.17 receive
    if ((pTG->DISPcb.Baud>3) && (!pTG->ProtParams2.fEnableV17Recv))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Lowering baud from %d for V.17 receive inihibit", 
                        CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }
// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can receive high res and we are not
    // claiming that we are capable of MR or MMR. Also, see if we changed
    // the baud rate. Also make sure we can receive wide pages.

    if (    (pTG->DISPcb.Resolution & AWRES_mm080_077)  && 
            ( pTG->DISPcb.Encoding == MH_DATA)          && 
            (!fBaudChanged)                             && 
            (pTG->DISPcb.PageLength == 2)               && 
            (pTG->DISPcb.PageWidth == 0)                )
    {
        //Do nothing - leave DIS alone!
        DebugPrintEx(DEBUG_MSG,"no need to change DIS");
    }
    else
    {
        // Send DCC command to the modem to set it up
        // Do the minimum necessary - only set resoultion if possible
        // (Again, this is because some modems don't like FDCC).
        if (    (pTG->DISPcb.Encoding == MH_DATA)   && 
                (!fBaudChanged)                     && 
                (pTG->DISPcb.PageLength == 2)       && 
                (pTG->DISPcb.PageWidth == 0)        )
        {
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszFDCC_RES, 
                                    (UWORD)(strlen(pTG->cbszFDCC_RES)),
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RES Failed");
                //Ignore it
            }
        }
        else if (   (pTG->DISPcb.Encoding == MH_DATA)   && 
                    (fBaudChanged)                      && 
                    (pTG->DISPcb.PageLength == 2)       && 
                    (pTG->DISPcb.PageWidth == 0)        )
        {
            // Changed the baud rate, but Encoding is OK.
            uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
            if(!Class2iModemDialog( pTG, 
                                    bBuf, 
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_BAUD Failed");
                //Ignore it
            }
        }
        else // the encoding format has changed or page size is bad
        {
            uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_RECV_ALL, pTG->DISPcb.Baud);
            if (!(uwRet=Class2iModemDialog( pTG, 
                                            bBuf, 
                                            uwLen,
                                            LOCALCOMMAND_TIMEOUT, 
                                            TRUE, 
                                            0, 
                                            pTG->cbszCLASS2_OK,
                                            pTG->cbszCLASS2_ERROR, 
                                            (C2PSTR) NULL)))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RECV_ALL Failed");
                // ignore it.
            }

            // If the FDCC failed, try FDIS.
            if ((uwRet == 0)||(uwRet == 2))
            {
                uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_RECV_ALL, pTG->DISPcb.Baud);
                if (!Class2iModemDialog(pTG, 
                                        bBuf, 
                                        uwLen,
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0, 
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL))
                {
                    DebugPrintEx(DEBUG_ERR,"FDIS_RECV_ALL Failed");
                    // ignore it.
                }

                // if the above failed, try just setting the baud
                // rate and resolution with FDCC.
                if ((uwRet == 0)||(uwRet == 2))
                {
                    uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, pTG->DISPcb.Baud);
                    if (!(uwRet=Class2iModemDialog( pTG, 
                                                    bBuf, 
                                                    uwLen,
                                                    LOCALCOMMAND_TIMEOUT, 
                                                    TRUE, 
                                                    0, 
                                                    pTG->cbszCLASS2_OK,
                                                    pTG->cbszCLASS2_ERROR, 
                                                    (C2PSTR) NULL)))
                    {
                        DebugPrintEx(DEBUG_ERR,"FDCC_BAUD Failed");
                        // Ignore it
                    }
                }

                // if the above failed, try just setting the baud
                // rate and resolution with FDIS.
                if ((uwRet == 0)||(uwRet == 2))
                {
                    uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_BAUD, pTG->DISPcb.Baud);
                    if (!(uwRet=Class2iModemDialog( pTG, 
                                                    bBuf, 
                                                    uwLen,
                                                    LOCALCOMMAND_TIMEOUT, 
                                                    TRUE, 
                                                    0, 
                                                    pTG->cbszCLASS2_OK,
                                                    pTG->cbszCLASS2_ERROR, 
                                                    (C2PSTR) NULL)))
                    {
                        DebugPrintEx(DEBUG_ERR,"FDIS_BAUD Failed");
                        // Ignore it
                    }
                }
            }
        }
    }

    // Enable Reception
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszFCR, 
                            (UWORD)(strlen(pTG->cbszFCR)),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FCR failed");
        // ignore failure
    }

    // // Turn off ECM - don't do for sierra type modems!
    // if (!pTG->CurrentMFRSpec.bIsSierra)
    //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
    //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
    //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
    //      {
    //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
    //              // Ignore ECM failure!!!
    //      }

    // Turn off Copy Quality Checking - also skip for Sierra type modems
    if (!pTG->CurrentMFRSpec.bIsSierra)
    {
        if (!Class2iModemDialog(pTG, 
                                pTG->cbszFCQ, 
                                (UWORD)(strlen(pTG->cbszFCQ)),
                                ANS_LOCALCOMMAND_TIMEOUT, 
                                TRUE, 
                                0, 
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR, 
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_ERR,"FCQ failed");
            // Ignore CQ failure!!!
        }
    }
    // Turn off Bug mode
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszFBUG, 
                            (UWORD)(strlen(pTG->cbszFBUG)),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBUG failed");
        // Ignore FBUG failure!!!
    }

    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    bBuf[0] = '\0';
    {
        UINT uBOR = pTG->CurrentMFRSpec.iReceiveBOR;
        if (pTG->CurrentMFRSpec.fSWFBOR && uBOR==1)
        {
            DebugPrintEx(DEBUG_WRN,"SWFBOR Enabled. Using AT+FBOR=0 instead of AT+FBOR=1");
            uBOR = 0;
        }
        uwLen = (USHORT)wsprintf(bBuf, pTG->cbszSET_FBOR, uBOR);
    }
    if (!Class2iModemDialog(pTG, 
                            bBuf, 
                            uwLen, 
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE,
                            0, 
                            pTG->cbszCLASS2_OK, 
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBOR failed");
        // Ignore BOR failure!!!
    }

    // Set the local ID - need ID from above to do this.
    bIDBuf[0] = '\0';
    uwLen = (USHORT)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
    if (!Class2iModemDialog(pTG, 
                            bIDBuf, 
                            uwLen,
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Local ID failed");
        // ignore failure
    }

    // Answer the phone

    // have to call hangup on every path out of here
    // after Answer is called. If Answer fails, it calls Hangup.
    // if it succeeds we have to call Hangup when we're done

    SignalStatusChange(pTG, FS_ANSWERED);

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");
    PSSLogEntry(PSS_MSG, 1, "Answering...");

    if((uRet2 = Class2Answer(pTG, FALSE)) != CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR, "Failed to answer - aborting");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"Done with Class2 Answer - succeeded");
    ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

    // Receive the data
    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", szCSI);

    PSSLogEntry(PSS_MSG, 1, "DIS was composed with the following capabilities:");
    LogClass2DISDetails(pTG, &pTG->DISPcb);
    
    uRet1 = (USHORT)Class2Receive(pTG );

    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE), but not 
    // PutRecvBuf(RECV_ENDPAGE / DOC), then InFileHandleNeedsBeClosed==1, meaning
    // there's a .RX file that hasn't been copied to the .TIF file. Since the
    // call was disconnected, there will be no chance to send RTN. Therefore, we call
    // PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial page and tell 
    // rx_thrd to terminate.
    if (pTG->InFileHandleNeedsBeClosed)
    {
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
    }

    if (uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"DONE WITH CALL, ALL OK");
        ICommStatus(pTG, T30STATR_SUCCESS, 0, 0, 0);

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"DONE WITH CALL, FAILED");
        ICommStatus(pTG, T30STATR_FAIL, 0, 0, 0);

        // Make sure modem is in an OK state!
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Abort calls Hangup
        Class2ModemAbort(pTG );

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
    }
    BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
    uRet2 = 0;

done:
    BG_CHK((uRet1 & 0xFF) == uRet1);
    BG_CHK((uRet2 & 0xFF) == uRet2);
    
    return RetCode;
}

BOOL Class2Receive(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    UWORD           uwLen;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000, uRet, uEndPageAction=NO_MORE_PAGES;
    BOOL            err_status;
    BCwithTEXT      bc;
    BYTE            bBuf[200];
    DWORD           tiffCompression;
    LPSTR           lpsTemp;
    DWORD           HiRes;

    DEBUG_FUNCTION_NAME("Class2Receive");

    // FComCriticalNeg(TRUE);


    /*
    * We have just answered!
    */

    // The repsonse to the ATA command is in the global variable
    // pTG->lpbResponseBuf2.

    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to parse response from ATA - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
    LogClass2DCSDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveParams to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    if (ICommRecvParams(pTG, (LPBC)&bc) == FALSE)
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvParams");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    //
    // once per RX - create TIFF file as soon as we know the compression / resolution.
    //

    pTG->Encoding   = Pcb.Encoding;
    pTG->Resolution = Pcb.Resolution;

    if (Pcb.Encoding == MR_DATA) 
    {
        tiffCompression =  TIFF_COMPRESSION_MR;
    }
    else 
    {
        tiffCompression =  TIFF_COMPRESSION_MH;
    }

    if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) 
    {
        HiRes = 1;
    }
    else 
    {
        HiRes = 0;
    }

    if ( !pTG->fTiffOpenOrCreated) 
    {
        //
        // top 32bits of 64bit handle are guaranteed to be zero
        //
        pTG->TiffInfo.ImageWidth = PageWidthInPixelsFromDCS[Pcb.PageWidth];
        pTG->Inst.hfile =  TiffCreateW ( pTG->lpwFileName,
                                         tiffCompression,
                                         pTG->TiffInfo.ImageWidth,
                                         FILLORDER_LSB2MSB,
                                         HiRes
                                         );

        if (! (pTG->Inst.hfile)) 
        {
            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
            DebugPrintEx(   DEBUG_ERR, 
                            "ERROR:Can't create tiff file %s compr=%d",
                            lpsTemp,
                            tiffCompression);

            MemFree(lpsTemp);
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        pTG->fTiffOpenOrCreated = 1;

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

        DebugPrintEx(   DEBUG_MSG, 
                        "Created tiff file %s compr=%d HiRes=%d",
                        lpsTemp,
                        tiffCompression, 
                        HiRes);

        MemFree(lpsTemp);
    }

    // **** Apparently, we don't want flow control on, so we'll turn
    // it off. Is this true???? If I turn it on, fcom.c fails a
    // debug check in filterreadbuf.
    FComXon(pTG, FALSE);

    // Send the FDR. The FDR must be responded to by a CONNECT.

    if (!Class2iModemDialog(pTG, 
                            pTG->cbszFDR, 
                            (UWORD)(strlen(pTG->cbszFDR)),
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Failed get response from initial FDR");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    DebugPrintEx(DEBUG_MSG,"FDR Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Might have to search through FDR response, but I doubt it.

    // Now we need to send a DC2 (0x12) to tell the modem it is OK
    // to give us data.
    // Some modems use ^Q instead of ^R - The correct value was written
    // into the DC@ string in Class2Callee where we checked for
    // manufacturer

    PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");

    PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));

    FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

    // Now we can receive the data and give it to the icomfile routine

    err_status =  T30_CALLDONE;

    while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
    {
        PSSLogEntry(PSS_MSG, 1, "Receiving page %d data...", pTG->PageCount+1);

        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
        #define READ_TIMEOUT    15000

        lTotalLen = 0;
        do
        {
            DebugPrintEx(DEBUG_MSG,"In receiving a page loop");
            uRet = Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);
            DebugPrintEx(DEBUG_MSG,"Class2ModemRecvBuf returned uRet=%x",uRet);
            if(lpbf)
            {
                lTotalLen += lpbf->wLengthData;
                DebugPrintEx(   DEBUG_MSG, 
                                "In lpbf if. length = %ld, Total Length %ld", 
                                lpbf->wLengthData, 
                                lTotalLen);

                if (!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                {
                    DebugPrintEx(DEBUG_ERR,"Bad return - PutRecvBuf in page");
                    err_status=T30_CALLFAIL;
                    return err_status;
                }
                lpbf = 0;
            }
        }
        while(uRet == RECV_OK);

        PSSLogEntry(PSS_MSG, 2, "recv:     page %d data, %d bytes", pTG->PageCount+1, lTotalLen);
        
        if(uRet == RECV_EOF)
        {
            DebugPrintEx(DEBUG_MSG,"Got EOF from RecvBuf");
            // FComCriticalNeg(TRUE);
    
            // RSL needed interface to TIFF thread
            pTG->fLastReadBlock = 1;
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
        }
        else
        {
            // Timeout from ModemRecvBuf
            DebugPrintEx(DEBUG_ERR,"ModemRecvBuf Timeout or Error=%d",uRet);
            PSSLogEntry(PSS_ERR, 1, "Failed to receive page data - aborting");
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
            err_status = T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully received page data");
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        // See if more pages to receive by parsing the FDR response...
        // After the DLEETX was received by Class2ModemRecvBuf, the
        // FPTS and FET response should be coming from the modem, terminated
        // by an OK. Let's go read that!

        if ((uRet=Class2iModemDialog(pTG, 
                                NULL,
                                0,
                                STARTSENDMODE_TIMEOUT, 
                                TRUE, 
                                0, 
                                pTG->cbszCLASS2_OK, 
                                pTG->cbszCLASS2_FHNG,
                                (C2PSTR)NULL)) != 1)
        {
            PSSLogEntry(PSS_ERR, 1, (uRet==2) ? 
                "Call was disconnected" : "Failed to receive EOP or MPS or EOM - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        DebugPrintEx(DEBUG_MSG,"EOP Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));

        // Process the response and see if more pages are coming
        uEndPageAction = Class2EndPageResponseAction(pTG);
        if (uEndPageAction == MORE_PAGES)
        {
            ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);
        }
        else
        {
            ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
        }

        // Send the FPTS - don't do this for Exar modems!
        if (!pTG->CurrentMFRSpec.bIsExar)
        {
            if (pTG->fPageIsBad) 
            {
                PSSLogEntry(PSS_MSG, 1, "Page was bad - sending RTN");
            }
            else 
            {
                PSSLogEntry(PSS_MSG, 1, "Page was good - sending MCF");
            }
            uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, pTG->fPageIsBad ? 2 : 1);
            if (!Class2iModemDialog(pTG, 
                                    bBuf, 
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0,
                                    pTG->cbszCLASS2_OK, 
                                    pTG->cbszCLASS2_ERROR, 
                                    (C2PSTR) NULL))
            {
                PSSLogEntry(PSS_WRN, 1, "Failed to send MCF/RTN - continuing anyway");
                // Ignore FPTS failure!!!
            }
        }

        if ((uEndPageAction==MORE_PAGES) || (pTG->fPageIsBad))
        {
            // Now, Send the FDR to start the next page (this was done for
            // the first page before entering the multipage loop).
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszFDR, 
                                    (UWORD)(strlen(pTG->cbszFDR)),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDR to start next PAGE Failed");
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");
            PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
            // Now send the correct DC2 string set in Class2Callee
            // (DC2 is standard, some use ^q instead)
            FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

        } //if we do not have another page, do the else...
        else 
        {
            // Send last FDR
            if (!Class2iModemDialog(pTG, 
                                    pTG->cbszFDR, 
                                    (UWORD)(strlen(pTG->cbszFDR)),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK, 
                                    (C2PSTR)NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDR failed");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            break; // All done receiving pages...
        }
    } //End of multipage while

	FComXon(pTG, FALSE);
    return err_status;
}


BOOL Class2GetModemMaker(PThrdGlbl pTG)
{
    USHORT i;

    DEBUG_FUNCTION_NAME("Class2GetModemMaker");
    // Initialize the current modem variable's (global) strings.
    pTG->CurrentMFRSpec.szATI[0] = '\0';
    pTG->CurrentMFRSpec.szMFR[0] = '\0';
    pTG->CurrentMFRSpec.szMDL[0] = '\0';
    // pTG->CurrentMFRSpec.szREV[0] = '\0';

//      // Get the ATI - repsonse is in pTG->lpbResponseBuf2
//      // For all responses, "ERROR" may come back - that is OK - we will
//      // never match ERROR to an acceptable modem manufacturer name, model,
//      // revision, etc.
//      if(!Class2iModemDialog(cbszCLASS2_ATI, sizeof(cbszCLASS2_ATI)-1,
//                      ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, cbszCLASS2_OK,
//                      cbszCLASS2_ERROR, (C2PSTR) NULL))
//      {
//              (MyDebugPrint (pTG, LOG_ALL, "ATI failed\n\r"));
//              // Ignore ATI failure!!!
//      }
//      else
//      {
//              // copy ATI answer into ATI variable
//              for (i=0; i<MFR_SIZE; i++)
//                      pTG->CurrentMFRSpec.szATI[i] = pTG->lpbResponseBuf2[i];
//      }
//
//      (MyDebugPrint (pTG, LOG_ALL, "Received ATI %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));


    // Get the FMFR - repsonse is in pTG->lpbResponseBuf2
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszCLASS2_FMFR, 
                            (UWORD)(strlen(pTG->cbszCLASS2_FMFR)),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FMFR failed");
        // Ignore FMFR failure!!!
    }
    else
    {
        // copy FMFR answer into FMFR variable
        for (i=0; i<MFR_SIZE; i++)
        {
            pTG->CurrentMFRSpec.szMFR[i] = pTG->lpbResponseBuf2[i];
        }
        DebugPrintEx(DEBUG_MSG,"Received FMFR %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // Get the FMDL - repsonse is in pTG->lpbResponseBuf2
    if (!Class2iModemDialog(pTG, 
                            pTG->cbszCLASS2_FMDL, 
                            (UWORD)(strlen(pTG->cbszCLASS2_FMDL)),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FMDL failed");
        // Ignore FMDL failure!!!
    }
    else
    {
        // copy FMDL answer into FMDL variable
        for (i=0; i<MFR_SIZE; i++)
        {
            pTG->CurrentMFRSpec.szMDL[i] = pTG->lpbResponseBuf2[i];
        }
        DebugPrintEx(DEBUG_MSG,"Received FMDL %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // // Get the FREV - repsonse is in pTG->lpbResponseBuf2
    // if(!Class2iModemDialog(cbszCLASS2_FREV, sizeof(cbszCLASS2_FREV)-1,
    //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, cbszCLASS2_OK,
    //              cbszCLASS2_ERROR, (C2PSTR) NULL))
    // {
    //      (MyDebugPrint (pTG, LOG_ALL, "FREV failed\n\r"));
    //      // Ignore FREV failure!!!
    // }
    // else
    // {
    //      // copy FREV answer into REV variable
    //      for (i=0; i<MFR_SIZE; i++)
    //              pTG->CurrentMFRSpec.szREV[i] = pTG->lpbResponseBuf2[i];
    // }
    // (MyDebugPrint (pTG, LOG_ALL, "Received REV %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

    return TRUE;
}


void Class2SetMFRSpecific(PThrdGlbl pTG, LPSTR lpszSection)
{

    USHORT iIndex, iFoundMFR,iFoundMDL;
    LPMFRSPEC lpmfrMatched;

    DEBUG_FUNCTION_NAME("Class2SetMFRSpecific");

    // Find the index into the table that corresponds most closely
    // to the modem. If we can't find the mfr and model, find a mfr
    // that matches (use the last one). If neither, use the default
    // last entry.

    // Look for Manufacturer name
    iIndex = 0;
    iFoundMFR = 0;
    iFoundMDL = 0;
    DebugPrintEx(DEBUG_MSG,"Entering search table loop");
    while (Class2ModemTable[iIndex].szMFR[0] != '\0')
    {
        lpmfrMatched = &(Class2ModemTable[iIndex]);
        // Look and see if the current name matches
        // the name in the list.
        if (Class2_fstrstr( (LPSTR)pTG->CurrentMFRSpec.szMFR,
                            (LPSTR)lpmfrMatched->szMFR) != NULL)
        {
            // Found a match!
            DebugPrintEx(   DEBUG_MSG, 
                            "Matched manufacturer name: %s %s",
                            (LPSTR)(&pTG->CurrentMFRSpec.szMFR),
                            (LPSTR)(&(lpmfrMatched->szMFR)));

            iFoundMFR = iIndex;
            //Now see if this matches the model number, too.
            if(Class2_fstrstr(  (LPSTR) pTG->CurrentMFRSpec.szMDL,
                                (LPSTR) lpmfrMatched->szMDL) != NULL)
            {
                //Got a MDL match, too! Stop looking.
                iFoundMDL = iIndex;
                DebugPrintEx(   DEBUG_MSG,
                                "Matched model: %s %s", 
                                (LPSTR)(&pTG->CurrentMFRSpec.szMDL), 
                                (LPSTR)(&(lpmfrMatched->szMDL)));
                break;
            }
        }

        iIndex++;
    }


    // We now either have the modem match or are using the defaults!
    if (iFoundMFR != 0) 
    {
        lpmfrMatched = &Class2ModemTable[iFoundMFR];
    }
    else 
    {
        lpmfrMatched = &Class2ModemTable[iIndex];
    }

    // Set proper BOR for receive and send

    pTG->CurrentMFRSpec.iSendBOR = lpmfrMatched->iSendBOR;
    pTG->CurrentMFRSpec.iReceiveBOR = lpmfrMatched->iReceiveBOR;
    pTG->CurrentMFRSpec.fSWFBOR  = lpmfrMatched->fSWFBOR;

    // Set the DC2 string - this is used in receive mode
    // after sending the FDR to tell the modem we are ready
    // to receive data. The standard says it should be a Dc2
    // (^R). But, some modems use ^Q

    pTG->CurrentMFRSpec.szDC2[0] = lpmfrMatched->szDC2[0];

    // Set the Sierra  and Exar flags flag

    pTG->CurrentMFRSpec.bIsSierra = lpmfrMatched->bIsSierra;
    pTG->CurrentMFRSpec.bIsExar = lpmfrMatched->bIsExar;
    pTG->CurrentMFRSpec.fSkipCtrlQ = lpmfrMatched->fSkipCtrlQ;
}


BOOL Class2Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
    int     i,
            j,
            comm_numb = 0,
            parameters;
    BYTE    switch_char,
            char_1,
            char_2;
    char    c;

    BOOL    found_command = FALSE;

    DEBUG_FUNCTION_NAME("Class2Parse");

    #define STRING_PARAMETER        1
    #define NUMBER_PARAMETERS       2
    for (i = 0; lpbBuf[i] != '\0'; ++i)
    {
        switch (lpbBuf[i])
        {
        case 'C':
                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad First C values");
                    return FALSE;
                }
                break;

        case 'O':
                if (lpbBuf[++i] == 'K' )
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_OK;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad O values");
                    return FALSE;
                }
                break;

        case 0x11:
                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                break;

        case '+':
                if( lpbBuf[++i] != 'F' )
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad + values");
                    return FALSE;
                }
                switch_char = lpbBuf[++i];
                char_1 = lpbBuf[++i];
                char_2 = lpbBuf[++i];
                // (MyDebugPrint (pTG, LOG_ALL, "Parse: in + command - %c%c%c \n\r",
                //      switch_char, char_1, char_2));
                switch ( switch_char )
                {
                case 'C':
                        //  Connect Message +FCON.
                        if ( char_1 == 'O' && char_2 == 'N' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCON;
                            parameters = FALSE;
                        }

                        // Report of Remote ID. +FCIG.
                        else if (char_1 == 'I' && char_2 == 'G' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                            parameters = STRING_PARAMETER;
                        }

                        // Prepare to receive prompt.  +FCFR.
                        else if ( char_1 == 'F' && char_2 == 'R' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCFR;
                            parameters = FALSE;
                        }
                        // Report the Remote ID CSI +FCSI.
                        else if ( char_1 == 'S' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                            parameters = STRING_PARAMETER;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad C values");
                            return FALSE;
                        }
                        break;

                case 'D':
                        // Report DCS frame information +FDCS.
                        if ( char_1 == 'C' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report DIS frame information +FDIS.
                        else if ( char_1 == 'I' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report DTC frame information +FDTC.
                        else if ( char_1 == 'T' && char_2 == 'C' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad D values");
                            return FALSE;
                        }
                        break;

                case 'E':
                        // Post page message report. +FET.
                        if ( char_1 == 'T' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FET;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad E values");
                            return FALSE;
                        }
                        break;

                case 'H':
                        // Debug report transmitted HDLC frames +FHT
                        if ( char_1 == 'T' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FHT;
                            parameters = STRING_PARAMETER;
                        }
                        // Debug report received HDLC frames +FHR
                        else if ( char_1 == 'R' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FHR;
                            parameters = STRING_PARAMETER;
                        }
                        // Report hang up.  +FHNG.
                        else if ( char_1 == 'N' && char_2 == 'G' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad H values");
                            return FALSE;
                        }
                        break;
                case 'N':
                        // Report NSF frame reciept.
                        if ( char_1 == 'S' && char_2 == 'F' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report NSS frame reciept.
                        else if ( char_1 == 'S' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report NSC frame reciept.
                        else if ( char_1 == 'S' && char_2 == 'C' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad N values");
                            return FALSE;
                        }
                        break;

                case 'P':
                        // Report poll request. +FPOLL
                        if ( char_1 == 'O' && char_2 == 'L' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                            parameters = FALSE;
                        }
                        // Page Transfer Status Report +FPTS.
                        else if ( char_1 == 'T' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad P values");
                            return FALSE;
                        }
                        break;
                case 'T':
                        // Report remote ID +FTSI.
                        if ( char_1 == 'S' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                            parameters = STRING_PARAMETER;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad T values");
                            return FALSE;
                        }
                        break;
                case 'V':
                        // Report voice request +FVOICE.
                        if ( char_1 == 'O' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                            parameters = FALSE;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad V values");
                            return FALSE;
                        }
                }

                //  Transfer the associated paramters to the parameter array.
                if (parameters == NUMBER_PARAMETERS)
                {
                    for (i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                    {
                        //  Skip past the non numeric characters.
                        if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' ) 
                        {
                            continue;
                        }

                        /*  Convert the character representation of the numeric
                                 parameter into a true number, and store in the
                                parameter list.  */
                        cl2_comm->parameters[comm_numb][j] = 0;
                        for (; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                        {
                            cl2_comm->parameters[comm_numb][j] *= 10;
                            cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                        }
                        i--; // the last for loop advanced 'i' past the numeric.
                        j++; // get set up for next parameter
                    }
                }
                else if (parameters == STRING_PARAMETER )
                {
                    // Skip the : that follows the +f command (eg +FTSI:)
                    if (lpbBuf[i+1] == ':') 
                    {
                        i++;
                    }
                    // Also skip leading blanks
                    while (lpbBuf[i+1] == ' ') 
                    {
                        i++;
                    }
                    for (i+=1, j=0; (c = lpbBuf[i])  != '\r' && c != '\n' && c != '\0'; ++i, ++j)
                    {
                        cl2_comm->parameters[comm_numb][j] = c;
                        if ( lpbBuf[i] == '\"' )
                        {
                            --j;
                        }
                    }
                    cl2_comm->parameters[comm_numb][j] = '\0';
                }
                //  No parameters, so just skip to end of line.
                else
                {
                    for(; (c=lpbBuf[i]) != '\r' && c != '\n' && c != '\0'; ++i)
                            ;
                }

                //  Increment command count.
                ++comm_numb;
                break;

        default:
                break;
        }
    }
    cl2_comm->comm_count = (USHORT)comm_numb;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\class1.h ===
/***************************************************************************
 Name     :     CLASS1.H
 Comment  :     Main include file for Windows Comm Class-1 Modem driver

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 60 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 60+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/



/**---------------------- #define of other things ---------------------

        FAX_CLASSn      is used in Modem.FaxClass.

        CHECK_PATTERN is used in the Guard elements.
        ECM_FRAMESIZE in T30.C

---------------------- #define of other things ---------------------**/

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

extern BYTE                             bDLEETX[];
extern BYTE                             bDLEETXOK[];


#define EndMode(pTG)         { pTG->Class1Modem.DriverMode = IDLE;      \
                                                pTG->Class1Modem.ModemMode = COMMAND;        \
                                                pTG->Class1Modem.CurMod = 0; }


/****************** begin prototypes from framing.c *****************/
BOOL SWFramingSendSetup(PThrdGlbl pTG, BOOL fOn);
BOOL SWFramingRecvSetup(PThrdGlbl pTG, BOOL fOn);
BOOL SWFramingSendFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount, USHORT uFlags);
BOOL SWFramingSendFlags(PThrdGlbl pTG, USHORT uHowMany);
USHORT SWFramingRecvFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
BOOL SWFramingSendPreamble(PThrdGlbl pTG, USHORT uCurMod);
BOOL SWFramingSendPostamble(PThrdGlbl pTG, USHORT uCurMod);
/***************** end of prototypes from framing.c *****************/

// from ddi.c
void SendZeros1(PThrdGlbl pTG, USHORT uCount);

BOOL iModemDrain(PThrdGlbl pTG);


#define iModemNoPauseDialog(pTG, s, l, t, w)                 \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemNoPauseDialog2(pTG, s, l, t, w1, w2)   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemNoPauseDialog3(pTG, s, l, t, w1, w2, w3)       \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))

#define iModemPauseDialog(pTG, s, l, t, w)                   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemPauseDialog2(pTG, s, l, t, w1, w2)     \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemPauseDialog3(pTG, s, l, t, w1, w2, w3) \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))


#define iModemResp1( pTG, t, w)                              \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemResp2(pTG, t, w1, w2)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemResp3(pTG,  t, w1, w2, w3)             \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))
#define iModemResp4( pTG, t, w1, w2, w3, w4)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)w4, (CBPSTR)(NULL))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\decoder.h ===
/***************************************************************************
 Name     :     DECODER.H
 Comment  :     HDLC decoding structs

        Copyright (c) Microsoft Corp. 1991 1992 1993

***************************************************************************/

#ifdef WIN32
#       define CODEBASED
#else
#       define CODEBASED        __based(__segname("_CODE"))
#endif

#ifdef SWECM
#       define SWECMEXP _export FAR PASCAL
#else
#       define SWECMEXP
#endif




USHORT SWECMEXP HDLC_Decode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, USHORT far* lpcbDst, LPDECODESTATE lpState);
#define InitDecoder(pTG, State)      { State.carry=State.dec_width=State.len=0; State.flagabort=NORMAL; }


/***------------------ also prototype from crc.c --------------------***/

WORD SWECMEXP CalcCRC(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\cl2and20\class20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Class2.0 specific functions for fax-modem T.30 driver

Author: 
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT    
       
Revision History:

--*/


#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2                                           

               
#include "prep.h"
#include "oemint.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CLASS20
#include "pssframe.h"

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];
extern DWORD PageWidthInPixelsFromDCS[];
          
BYTE   bClass20DLE_nextpage[3] = { DLE, 0x2c, 0 };
BYTE   bClass20DLE_enddoc[3] =   { DLE, 0x2e, 0 };
BYTE   bMRClass20RTC[10] =  { 0x01, 0x30, 0x00, 0x06, 0xc0, 0x00, 0x18, 0x00, 0x03, 0x00};
BYTE   bMHClass20RTC[9] =   { 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00, 0x08, 0x00};



void
Class20Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;

   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszINITIAL_FDT,  "AT+FDT=%%1d,%%1d,%%1d,%%1d\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFNR,          "AT+FNR=1,1,1,1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0,0\r" );
   sprintf( pTG->cbszFLO,          "AT+FLO=1\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBO=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FCC=1,%%d,,,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FDCC=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=1,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FIS" );
   sprintf( pTG->cbszFDIS,          "AT+FIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszZERO,          "0" );
   sprintf( pTG->cbszONE,           "1" );
   sprintf( pTG->cbszQUERY_S1,      "ATS1?\r" );
   sprintf( pTG->cbszRING,          "RING" );
   
   
   sprintf( pTG->cbszCLASS2_ATI,        "ATI\r" );
   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMI?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMM?\r" );
   sprintf( pTG->cbszCLASS2_FREV,       "AT+FMR?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFDT_CNTL_Q,        "" );
   sprintf( pTG->cbszFCON,              "+FCO" );
   sprintf( pTG->cbszGO_CLASS2,         "AT+FCLASS=2.0\r" );
   sprintf( pTG->cbszFLID,              "AT+FLI=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_QUERY_CLASS,"AT+FCLASS=?\r" );
   sprintf( pTG->cbszCLASS2_GO_CLASS0,  "AT+FCLASS=0\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszCLASS2_RESET,      "AT&F\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );      
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );    
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FKS\r" );     
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );  
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIAL" ); 
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );        
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );   
   sprintf( pTG->cbszCLASS2_OK,         "OK" );          
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHNG" );    
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );
   sprintf( pTG->cbszCLASS2_ATE0,       "ATE0\r" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}


//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
//
BOOL T30Cl20Tx(PThrdGlbl pTG,LPSTR szPhone)
{
    LPSTR   lpszSection = pTG->FComModem.rgchKey;
    USHORT  uRet1, uRet2;
    
    BYTE    bBuf[200],
            bTempBuf[200+RESPONSE_BUF_SIZE];
    
    LPBYTE  lpbyte;

    UWORD   Encoding, Res, PageWidth, PageLength, uwLen, uwRet;
    BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR    szTSI[max(MAXTOTALIDLEN,20)+4] = {0};
    BOOL    fBaudChanged;
    BOOL    RetCode;

    DEBUG_FUNCTION_NAME("T30Cl20Tx");

    uRet2 = 0;
    if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed.");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    // first get SEND_CAPS if possible. If using PSI (IFAX/Winpad) then we
    // can't make callback this on the Sender. Only on Receiver! Otherwise
    // we deadlock & hang in PSI

#ifdef PSI
    if(!Class2GetBC(pTG, BC_NONE)) // Set it to some defaults!
#else
    if(!Class2GetBC(pTG, SEND_CAPS)) // get send caps
#endif
    {
        uRet1 = T30_CALLFAIL;
    
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2.0
    if(!iModemGoClass(pTG, 3))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2.0");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the send strings needed for
    // this modem.
    if(!Class20GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // Get the capabilities of the software. I am only using this
    // right now for the TSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!

    _fmemset((LPB)szTSI, 0, strlen(szTSI));
    Class2SetDIS_DCSParams( pTG, 
                            SEND_CAPS, 
                            (LPUWORD)&Encoding, 
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength, 
                            (LPSTR) szTSI);

    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);
    
    if(!Class2iModemDialog( pTG, 
                            bIDBuf, 
                            uwLen,
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }

    // // Turn off ECM - don't do for sierra type modems!
    // if (!pTG->CurrentMFRSpec.bIsSierra)
    //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
    //              LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
    //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
    //      {
    //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
    //              // Ignore ECM failure!!!
    //      }


    if(!(uwRet=Class2iModemDialog(  pTG, 
                                    pTG->cbszFDIS_IS, 
                                    (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_ERROR, 
                                    (C2PSTR) NULL)))
    {
        DebugPrintEx(DEBUG_WRN,"FDIS failed");
        // ignore
    }

    // See if the reply was ERROR or timeout, if so try a different command
    // Exar modems, for example, don't take AT+FDIS?
    if ( uwRet == 2) 
    {
        if(!(uwRet=Class2iModemDialog(  pTG, 
                                        pTG->cbszFDIS_IS,
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)), 
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0,
                                        pTG->cbszCLASS2_OK, 
                                        (C2PSTR) NULL)))
        {
             // No FDIS, FDCC worked - quit!
             DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
             uRet1 = T30_CALLFAIL;

             pTG->fFatalErrorWasSignaled = 1;
             SignalStatusChange(pTG, FS_FATAL_ERROR);
             RetCode = FALSE;
             goto done;
        }

        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,lpbyte);
                _fstrcpy(lpbyte, bTempBuf);
                DebugPrintEx(DEBUG_MSG,"Leading comma in DCC string = %s", (LPSTR)&pTG->lpbResponseBuf2);
            }

            if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) 
                break;
        }
    }


    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (Class2_fstrstr((LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        bTempBuf[0] = '\0';
        _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
        wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,(LPSTR)pTG->lpbResponseBuf2);
        _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
    }

    DebugPrintEx(DEBUG_MSG,"Received %s from FDIS", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDIS Response");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"pTG->DISPcb baud value is %d", pTG->DISPcb.Baud);

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string constraining
    // the high end speed or if the user turned off V.17 for sending
    // Check the V.17 inhibit and lower baud if necessary
    if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Send) )
    {
        DebugPrintEx(DEBUG_MSG,"Lowering baud from %d for V.17 inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }


    // Now see if the high end baud rate has been constrained
    if  ( (pTG->ProtParams2.HighestSendSpeed != 0) &&
            (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Have to lower baud from %d to %d", 
                        CodeToBPS[pTG->DISPcb.Baud], 
                        pTG->ProtParams2.HighestSendSpeed);

        fBaudChanged = TRUE;
        switch (pTG->ProtParams2.HighestSendSpeed)
        {
                case 2400:
                        pTG->DISPcb.Baud = 0;
                        break;
                case 4800:
                        pTG->DISPcb.Baud = 1;
                        break;
                case 7200:
                        pTG->DISPcb.Baud = 2;
                        break;
                case 9600:
                        pTG->DISPcb.Baud = 3;
                        break;
                case 12000:
                        pTG->DISPcb.Baud = 4;
                        break;
                default:
                        DebugPrintEx(DEBUG_ERR,"Bad HighestSpeed");
                        
                        uRet1 = T30_CALLFAIL;
                        pTG->fFatalErrorWasSignaled = 1;
                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                        RetCode = FALSE;
                        goto done;

                        break;
        }
    }


    uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
    if(!Class2iModemDialog( pTG, 
                            bBuf, 
                            uwLen,
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            (C2PSTR) NULL))
    {
          uRet1 = T30_CALLFAIL;

          pTG->fFatalErrorWasSignaled = 1;
          SignalStatusChange(pTG, FS_FATAL_ERROR);
          RetCode = FALSE;
          goto done;
    }


    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
    if(!Class2iModemDialog( pTG, 
                            bBuf, 
                            uwLen, 
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE,
                            0, 
                            pTG->cbszCLASS2_OK, 
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FBOR failed");
        // Ignore BOR failure!!!
    }

    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFNR, 
                            (UWORD)(strlen(pTG->cbszFNR)),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FNR failed");
        // ignore error
    }

    // Dial the number

            // have to call hangup on every path out of here
            // after Dial is called. If Dial fails, it calls Hangup
            // if it succeeds we have to call Hangup when we're done

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

    SignalStatusChange(pTG, FS_DIALING);

    PSSLogEntry(PSS_MSG, 1, "Dialing %s", szPhone);

    if((uRet2 = Class2Dial(pTG, szPhone)) != CONNECT_OK)
    {
        uRet1 = T30_DIALFAIL;

        if (! pTG->fFatalErrorWasSignaled) 
        {
             pTG->fFatalErrorWasSignaled = 1;
             SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;

        goto done;
    }

    ICommGotAnswer(pTG );
    // we should be using the sender msg here but that says Training
    // at speed=xxxx etc which we don't know, so we just use the
    // Recvr message which just says "negotiating"
    ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

    // Send the data
    uRet1 = (USHORT)Class20Send(pTG );
    if ( uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"******* DONE WITH CALL, ALL OK");
        ICommStatus(pTG, T30STATS_SUCCESS, 0, 0, 0);

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"******* DONE WITH CALL, **** FAILED *****");
        ICommStatus(pTG, T30STATS_FAIL, 0, 0, 0);

        // Make sure Modem is in OK state
        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Class2ModemABort calls Hangup
        Class2ModemAbort(pTG );

        if (! pTG->fFatalErrorWasSignaled)  
        {
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;

    }
    BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
    uRet2 = 0;

done:
    BG_CHK((uRet1 & 0xFF) == uRet1);
    BG_CHK((uRet2 & 0xFF) == uRet2);
    
    return RetCode;
}

BOOL Class20Send(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000;
    BOOL            err_status, fAllPagesOK = TRUE;
    BCwithTEXT      bc;

    UWORD           Encoding, Res, PageWidth, PageLength, uwLen;
    BYTE            bFDISBuf[200];
    CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
    BYTE            bNull = 0;
    DWORD           TiffConvertThreadId;

    DEBUG_FUNCTION_NAME("Class20Send");
    // FComCriticalNeg(TRUE);

    /*
    * We have just dialed... Now we have to look for the FDIS response from
    * the modem. It will be followed by an OK - hunt for the OK.
    */
    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    if(!Class2iModemDialog( pTG, 
                            NULL, 
                            0, 
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0,
                            pTG->cbszCLASS2_OK, 
                            (C2PSTR) NULL))
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to receive DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // The response will be in pTG->lpbResponseBuf2 - this is loaded in
    // Class2iModemDialog.

    // (MyDebugPrint (pTG, LOG_ALL, "Received %s\r", (LPSTR)(&(pTG->lpbResponseBuf2))));

    // Parse through the received strings, looking for the DIS, CSI,
    // NSF

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process ATD Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse received DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "DIS specified the following capabilities:");
    LogClass2DISDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    // Class2 modems do their own negotiation & we need to stay in sync
    // Otherwise, we might send MR data while the modem sends a DCS
    // saying it is MH. This happens a lot with Exar modems because
    // they dont accept an FDIS= command during the call.
    // FIX: On all Class2 sends force remote caps to always be MH
    // Then in efaxrun we will always negotiate MH & encode MH
    // We are relying on the fact that (a) it seems that all/most
    // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
    // negotiate MH and (c) We will override all non-Exar modem's
    // intrinsic negotiation by sending an AT+FDIS= just before the FDT
    // Also (d) This change makes our behaviour match Snowball exactly
    // so we will work no better or worse than it :-)
    bc.Fax.Encoding = MH_DATA;

    if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvCaps.");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // now get the SEND_PARAMS
    if(!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
    {
        err_status = T30_CALLFAIL;
        return err_status;
    }


#ifdef FILET30
    // Send the raw capabilities string - most values
    // will be null, since CAS does not tell us things like
    // DIS, NSF, etc. But, we can put in the CSI.
    ICommRawCaps(pTG, (LPBYTE) &bNull, (LPBYTE) &bNull, 0, NULL, 0);
#endif

    ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);


    // Turn off flow control.
    FComXon(pTG, FALSE);

    // The Send params were set during the call to Class2GetBC
    // We'll use these to set the ID (for the TSI) and the DCS params

    // Send the FDT and get back the DCS. The FDT must be followed by
    // CONNECT and a ^Q (XON)
    // The FDT string must have the correct resolution and encoding
    // for this session. FDT=Encoding, Res, width, length
    // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
    // Res 0=200x100 (normal), 1=200x200 (fine)
    // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
    //              3=1216/151,4=864/107
    // PageLength 0=A4,1=B4,2=unlimited

    Class2SetDIS_DCSParams( pTG, 
                            SEND_PARAMS, 
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res, 
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI);

    //
    // Current Win95 version of Class2 TX is limited to MH only.
    // While not changing this, we will at least allow MR selection in future.
    //

    if (!pTG->fTiffThreadCreated) 
    {
         if (Encoding) 
         {
           pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
         }
         else 
         {
           pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
         }
        
        
         if (Res) 
         {
           pTG->TiffConvertThreadParams.HiRes = 1;
         }
         else 
         {
           pTG->TiffConvertThreadParams.HiRes = 0;
        
           // use LoRes TIFF file prepared by FaxSvc
        
           // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
        
         }

         _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
         pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

         DebugPrintEx(DEBUG_MSG,"Creating TIFF helper thread");
         pTG->hThread = CreateThread(   NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                                        (LPVOID) pTG,
                                        0,
                                        &TiffConvertThreadId);

         if (!pTG->hThread) 
         {
             DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");
             
             err_status = T30_CALLFAIL;
             return err_status;
         }

         pTG->fTiffThreadCreated = 1;
         pTG->AckTerminate = 0;
         pTG->fOkToResetAbortReqEvent = 0;

         if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) 
         {
             T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
             T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum((LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                    sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

         }
    }


    // Even modems that take FDT=x,x,x,x don't seem to really do it
    // right. So, for now, just send FDIS followed by FDT except for
    // the EXAR modems!!
    uwLen = (UWORD)wsprintf(bFDISBuf, 
                            pTG->cbszFDIS, 
                            Res,
                            min(Pcb.Baud, pTG->DISPcb.Baud), 
                            PageWidth, 
                            PageLength, 
                            Encoding);
    if(!Class2iModemDialog( pTG, 
                            bFDISBuf, 
                            uwLen, 
                            LOCALCOMMAND_TIMEOUT,
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK, 
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Failed get response from FDIS");
        // Ignore it -we are going to send what we have!
    }

    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFDT, 
                            (UWORD)(strlen(pTG->cbszFDT)),
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));

        DebugPrintEx(DEBUG_ERR,"FDT to start first PAGE Failed!");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    DebugPrintEx(DEBUG_MSG,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));

    // Turn on flow control.
    FComXon(pTG, TRUE);

    // Search through Response for the DCS frame - need it so set
    // the correct zero stuffing

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDT Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse sent DCS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is \"%s\"", pTG->LocalID);
    PSSLogEntry(PSS_MSG, 1, "DCS was sent as follows:");
    LogClass2DCSDetails(pTG, &Pcb);

    // Got a response - see if baud rate is OK
    DebugPrintEx(   DEBUG_MSG,
                    "Negotiated Baud Rate = %d, lower limit is %d", 
                    Pcb.Baud, 
                    pTG->ProtParams2.LowestSendSpeed);

    if (CodeToBPS[Pcb.Baud] < (WORD)pTG->ProtParams2.LowestSendSpeed)
    {
        DebugPrintEx(DEBUG_MSG,"Aborting due to too low baud rate!");
        err_status =  T30_CALLFAIL;
        return err_status;
    }


    // Use values obtained from the DCS frame to set zero stuffing.
    // (These were obtained by call to Class2ResponseAction above).
    // Zero stuffing is a function of minimum scan time (determined
    // by resolution and the returned scan minimum) and baud.
    // Fixed the Hack--added a Baud field

    // Init must be BEFORE SetStuffZero!
    FComOutFilterInit(pTG );
    FComSetStuffZERO(pTG, Class2MinScanToBytesPerLine(pTG, Pcb.MinScan, (BYTE) Pcb.Baud, Pcb.Resolution));

    err_status =  T30_CALLDONE;

    while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
    {
        PSSLogEntry(PSS_MSG, 0, "Phase C - Page Transmission");
        PSSLogEntry(PSS_MSG, 1, "Sending page %d data...", pTG->PageCount);

        lTotalLen = 0;

        FComOverlappedIO(pTG, TRUE); // TRUE
        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
        {
            BG_CHK(lpbf && lpbf->wLengthData > 0);

            lTotalLen += lpbf->wLengthData;
            DebugPrintEx(DEBUG_MSG,"total length: %ld", lTotalLen);

            if(!(Class2ModemSendMem(pTG, lpbf->lpbBegData,lpbf->wLengthData) & (MyFreeBuf(pTG, lpbf))))
            {
                DebugPrintEx(DEBUG_ERR,"Class2ModemSendBuf Failed");
                PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }

            if (pTG->fAbort)
            {
                DebugPrintEx(DEBUG_ERR,"Abort during Send loop");
                pTG->fAbort = FALSE;
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }

        } // end of SEND_SEQ while

      //
      // Send RTC (Class2.0 specific)
      //

        PSSLogEntry(PSS_MSG, 2, "send: page %d data, %d bytes", pTG->PageCount, lTotalLen);
        PSSLogEntry(PSS_MSG, 2, "send: <RTC>");
        if (Encoding) 
        {
            if (! FComDirectAsyncWrite(pTG, bMRClass20RTC, 10) ) 
            {
                DebugPrintEx(DEBUG_ERR,"Failed to terminate page with MR RTC");
                PSSLogEntry(PSS_ERR, 1, "Failed to send RTC - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        else 
        {
            if (! FComDirectAsyncWrite(pTG, bMHClass20RTC, 9) ) 
            {
                DebugPrintEx(DEBUG_ERR,"Failed to terminate page with MH RTC");
                PSSLogEntry(PSS_ERR, 1, "Failed to send RTC - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }

        DebugPrintEx(DEBUG_MSG,"out of while send_seq loop.");
        // Acknowledge that we sent the page
        ICommSendPageAck(pTG, TRUE);
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        //See if more pages to send...
        if ( ICommNextSend(pTG) == NEXTSEND_MPS )
        {
            // Terminate the Page with DLE-,
            DebugPrintEx(DEBUG_MSG,"Another page to send...");

            PSSLogEntry(PSS_MSG, 1, "Sending MPS");
            PSSLogEntry(PSS_MSG, 2, "send: <dle><mps>");
            // Terminate the Page with DLE-ETX
            if(!FComDirectAsyncWrite(pTG, bClass20DLE_nextpage, 2))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><mps> - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Flow control is turned off inside of ModemDrain.
            switch (Class2ModemDrain(pTG))
            {
            case 0:
                DebugPrintEx(DEBUG_ERR,"Failed to drain");
                err_status =  T30_CALLFAIL;
                return err_status;
            case 1:
                PSSLogEntry(PSS_MSG, 1, "Received MCF");
                // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the next page
                pTG->T30.ifrResp = ifrMCF;   
                break;
            default:
                PSSLogEntry(PSS_MSG, 1, "Received RTN");
                // fAllPagesOK = FALSE;  // This page was bad, but we retransmit it
                // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the same page again
                pTG->T30.ifrResp = ifrRTN;   
            }

            // Now, Send the FDT to start the next page (this was done for
            // the first page before entering the multipage loop).

            if(!Class2iModemDialog( pTG, 
                                    pTG->cbszFDT, 
                                    (UWORD) strlen(pTG->cbszFDT), 
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDT to start next PAGE Failed!");
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Turn on flow control.
            FComXon(pTG, TRUE);

        } //if we do not have another page, do the else...
        else 
        {
            break; // All done sending pages...
        }

        if ( err_status == T30_CALLFAIL) 
        {
            break;
        }
    } //End of multipage while

    DebugPrintEx(DEBUG_MSG,"out of while multipage loop. about to send final.");

    //
    // Purge input COM queue to purge all OKs 
    //

    FComFlushInput(pTG);

    // Send end of message sequence
    // Terminate the document with DLE-0x2e
    PSSLogEntry(PSS_MSG, 1, "Sending EOP");
    PSSLogEntry(PSS_MSG, 2, "send: <dle><eop>");
    if(!FComDirectAsyncWrite(pTG, bClass20DLE_enddoc, 2))
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><eop> - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    switch (Class2ModemDrain(pTG))
    {
    case 0:
        DebugPrintEx(DEBUG_ERR,"Failed to drain");
        err_status =  T30_CALLFAIL;
        return err_status;
    case 1:
        PSSLogEntry(PSS_MSG, 1, "Received MCF");
        // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the next page
        pTG->T30.ifrResp = ifrMCF;   
        break;
    default:
        PSSLogEntry(PSS_MSG, 1, "Received RTN");
        // fAllPagesOK = FALSE;  // This page was bad, but we retransmit it
        // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the same page again
        pTG->T30.ifrResp = ifrRTN;   
    }

    FComOutFilterClose(pTG );
    FComXon(pTG, FALSE);

    // If *any* page failed to send correctly, the call failed!
    if (!fAllPagesOK) 
    {
        err_status = T30_CALLFAIL;
    }
    return err_status;

}


/**************************************************************
        Receive specific routines start here
***************************************************************/

//      If lpszSection is NON-NULL, we will override our internal CurrentMSPEC
//  structure based on the settings in the specified section.
BOOL  T30Cl20Rx (PThrdGlbl pTG)
{
    LPSTR           lpszSection = pTG->FComModem.rgchKey;
    USHORT          uRet1, uRet2;
    BYTE            bBuf[200],
                    bTempBuf[200+RESPONSE_BUF_SIZE];
    UWORD           uwLen, uwRet;
    UWORD           Encoding, Res, PageWidth, PageLength;
    BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
    LPBYTE          lpbyte;
    BOOL            fBaudChanged;
    BOOL            RetCode;

    DEBUG_FUNCTION_NAME("T30Cl20Rx");

    uRet2 = 0;
    if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG )))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed.");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS
    if(!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
    {
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2.0
    if(!iModemGoClass(pTG, 3))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2.0");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the receive strings needed for
    // this modem.
    if(!Class20GetModemMaker(pTG ))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings

    Class2SetMFRSpecific(pTG, lpszSection);

    // Get the capabilities of the software. I am only using this
    // right now for the CSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    _fmemset((LPB)szCSI, 0, sizeof(szCSI));
    Class2SetDIS_DCSParams( pTG, 
                            SEND_CAPS, 
                            (LPUWORD)&Encoding, 
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth, 
                            (LPUWORD)&PageLength, 
                            (LPSTR) szCSI);

    // Find out what the default DIS is
    if(!(uwRet=Class2iModemDialog(  pTG, 
                                    pTG->cbszFDIS_IS, 
                                    (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                    LOCALCOMMAND_TIMEOUT, 
                                    TRUE, 
                                    0, 
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_ERROR, 
                                    (C2PSTR) NULL)))
    {
        DebugPrintEx(DEBUG_WRN,"FDIS? failed");
        // ignore
    }

    // See if the reply was ERROR or timeout, if so try a different command
    if ( uwRet == 2) 
    {
       if(!(uwRet=Class2iModemDialog(   pTG, 
                                        pTG->cbszFDIS_IS,
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0,
                                        pTG->cbszCLASS2_OK, 
                                        (C2PSTR) NULL)))
       {
            // No FDIS, FDCC worked - quit!
            DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
            uRet1 = T30_CALLFAIL;

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;

            goto done;
       }
       
        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                bTempBuf[0] = '\0';
                _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszONE);
                wsprintf((LPSTR)bTempBuf, "%s%s",(LPSTR)bBuf,lpbyte);
                _fstrcpy(lpbyte, bTempBuf);
                DebugPrintEx(DEBUG_MSG,"Leading comma in DCC string =%s", (LPSTR)&pTG->lpbResponseBuf2);
            }

            if ( (*lpbyte >= '0') && (*lpbyte <= '9') ) 
            {
                break;
            }
        }
    }

    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (Class2_fstrstr( (LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        bTempBuf[0] = '\0';
        _fstrcpy((LPSTR)bBuf, (LPSTR)pTG->cbszFDIS_STRING);
        wsprintf((LPSTR)bTempBuf, "%s: %s",(LPSTR)bBuf,(LPSTR)pTG->lpbResponseBuf2);
        _fstrcpy(pTG->lpbResponseBuf2, bTempBuf);
    }

    DebugPrintEx(DEBUG_MSG,"Received %s from FDIS?", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDIS Response");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string inhibiting
    // V.17 receive
    if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Recv) )
    {
        DebugPrintEx(DEBUG_MSG,"Lowering baud from %d for V.17 receive inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }
// - commented out 3/6/95 by JosephJ (this code was never checked in -- it
//                                                      fixed one modem and didn't fix another.
//      else if (pTG->DISPcb.Baud == 5)
//      {
//              // Several 14.4K modems require us to explicitly set
//              // +FDCC=1,5 or ,5 to work, else they send at 2400!
//              // So force the specification of +FDCC
//              (MyDebugPrint (pTG, LOG_ALL, "Faking fBaudChanged for 14.4K modems\n\r"));
//              fBaudChanged=TRUE;
//      }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can receive high res and we are not
    // claiming that we are capable of MR or MMR. Also, see if we changed
    // the baud rate. Also make sure we can receive wide pages.

    // Set the current session parameters
    uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, pTG->DISPcb.Baud);
    if(!Class2iModemDialog( pTG, 
                            bBuf, 
                            uwLen, 
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK, 
                            (C2PSTR) NULL))
    {
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }


    // Enable Reception
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFCR, 
                            (UWORD)(strlen(pTG->cbszFCR) ),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FCR failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFNR, 
                            (UWORD) (strlen(pTG->cbszFNR) ),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FNR failed");
        // ignore error
    }


    // // Turn off ECM - don't do for sierra type modems!
    // if (!pTG->CurrentMFRSpec.bIsSierra)
    //      if(!Class2iModemDialog(pTG->cbszFECM, sizeof(pTG->cbszFECM)-1,
    //              ANS_LOCALCOMMAND_TIMEOUT, TRUE, 0, pTG->cbszCLASS2_OK,
    //              pTG->cbszCLASS2_ERROR, (C2PSTR) NULL))
    //      {
    //              (MyDebugPrint (pTG, LOG_ALL, "FECM failed\n\r"));
    //              // Ignore ECM failure!!!
    //      }

    // Turn off Copy Quality Checking - also skip for Sierra type modems
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFCQ, 
                            (UWORD) (strlen(pTG->cbszFCQ) ),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FCQ failed");
        // Ignore CQ failure!!!
    }


    // Set the local ID - need ID from above to do this.
    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
    if(!Class2iModemDialog( pTG, 
                            bIDBuf, 
                            uwLen,
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }

    // Answer the phone

            // have to call hangup on every path out of here
            // after Answer is called. If Answer fails, it calls Hangup.
            // if it succeeds we have to call Hangup when we're done

    SignalStatusChange(pTG, FS_ANSWERED);

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");
    PSSLogEntry(PSS_MSG, 1, "Answering...");

    if((uRet2 = Class2Answer(pTG, FALSE)) != CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR,"Answer failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"Done with Class2 Answer - succeeded");
    ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");
    PSSLogEntry(PSS_MSG, 1, "CSI is %s", szCSI);
    PSSLogEntry(PSS_MSG, 1, "DIS was composed with the following capabilities:");
    LogClass2DISDetails(pTG, &pTG->DISPcb);

    // Receive the data
    uRet1 = (USHORT)Class20Receive(pTG );

    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE), but not 
    // PutRecvBuf(RECV_ENDPAGE / DOC), then InFileHandleNeedsBeClosed==1, meaning
    // there's a .RX file that hasn't been copied to the .TIF file. Since the
    // call was disconnected, there will be no chance to send RTN. Therefore, we call
    // PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial page and tell 
    // rx_thrd to terminate.
    if (pTG->InFileHandleNeedsBeClosed)
    {
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
    }

    if ( uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"******* DONE WITH CALL, ALL OK");
        ICommStatus(pTG, T30STATR_SUCCESS, 0, 0, 0);

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;

    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"******* DONE WITH CALL, **** FAILED *****");
        ICommStatus(pTG, T30STATR_FAIL, 0, 0, 0);

        // Make sure modem is in an OK state!
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Abort calls Hangup
        Class2ModemAbort(pTG );

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

    }
    BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
    uRet2 = 0;

done:
    BG_CHK((uRet1 & 0xFF) == uRet1);
    BG_CHK((uRet2 & 0xFF) == uRet2);
    
    return RetCode;
}


BOOL Class20Receive(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    UWORD           uwLen;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000, uRet;
    BOOL            err_status;
    BCwithTEXT      bc;
    BYTE            bBuf[200];
    DWORD           tiffCompression;
    LPSTR           lpsTemp;
    DWORD           HiRes;


    DEBUG_FUNCTION_NAME("Class20Receive");
    // FComCriticalNeg(TRUE);


    /*
    * We have just answered!
    */

    // The repsonse to the ATA command is in the global variable
    // pTG->lpbResponseBuf2.

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to parse response from ATA - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
    LogClass2DCSDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveParams to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    if( ICommRecvParams(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvParams.");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    //
    // once per RX - create TIFF file as soon as we know the compression / resolution.
    //

    pTG->Encoding   = Pcb.Encoding;
    pTG->Resolution = Pcb.Resolution;


    if (Pcb.Encoding == MR_DATA) 
    {
        tiffCompression =  TIFF_COMPRESSION_MR;
    }
    else 
    {
        tiffCompression =  TIFF_COMPRESSION_MH;
    }

    if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) 
    {
        HiRes = 1;
    }
    else 
    {
        HiRes = 0;
    }


    if ( !pTG->fTiffOpenOrCreated) 
    {
        //
        // top 32bits of 64bit handle are guaranteed to be zero
        //
        pTG->TiffInfo.ImageWidth = PageWidthInPixelsFromDCS[Pcb.PageWidth];
        pTG->Inst.hfile =  TiffCreateW ( pTG->lpwFileName,
                                         tiffCompression,
                                         pTG->TiffInfo.ImageWidth,
                                         FILLORDER_LSB2MSB,
                                         HiRes
                                         );

        if (! (pTG->Inst.hfile)) 
        {
            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
            DebugPrintEx(   DEBUG_ERR,
                            "Can't create tiff file %s compr=%d",
                            lpsTemp,
                            tiffCompression);

            MemFree(lpsTemp);
            err_status =  T30_CALLFAIL;
            return err_status;

        }

        pTG->fTiffOpenOrCreated = 1;

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

        DebugPrintEx(   DEBUG_MSG,
                        "Created tiff file %s compr=%d HiRes=%d",
                        lpsTemp,  
                        tiffCompression, 
                        HiRes);

        MemFree(lpsTemp);
    }

    // **** Apparently, we don't want flow control on, so we'll turn
    // it off. Is this true???? If I turn it on, fcom.c fails a
    // debug check in filterreadbuf.
    FComXon(pTG, FALSE);


    // Send the FDR. The FDR must be responded to by a CONNECT.

    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFDR, 
                            (UWORD) (strlen(pTG->cbszFDR) ),
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Failed get response from initial FDR");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    DebugPrintEx(DEBUG_MSG,"FDR Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    // Might have to search through FDR response, but I doubt it.

    PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");

    // Now we need to send a DC2 (0x12) to tell the modem it is OK
    // to give us data.
    // Some modems use ^Q instead of ^R - The correct value was written
    // into the DC@ string in Class20Callee where we checked for
    // manufacturer
    PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
    FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);


    // Now we can receive the data and give it to the icomfile routine

    err_status =  T30_CALLDONE;

    while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
    {
        PSSLogEntry(PSS_MSG, 1, "Receiving page %d data...", pTG->PageCount+1);

        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
        #define READ_TIMEOUT    15000

        lTotalLen = 0;
        do
        {
            DebugPrintEx(DEBUG_MSG,"In receiving a page loop");
            uRet=Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);
            if(lpbf)
            {
                lTotalLen += lpbf->wLengthData;
                DebugPrintEx(DEBUG_MSG,"In lpbf if. Total Length %ld", lTotalLen);

                if(!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                {
                    DebugPrintEx(DEBUG_ERR,"Bad return - PutRecvBuf in page");
                    err_status=T30_CALLFAIL;
                    return err_status;
                }
                lpbf = 0;
            }
        }
        while(uRet == RECV_OK);

        PSSLogEntry(PSS_MSG, 2, "recv:     page %d data, %d bytes", pTG->PageCount+1, lTotalLen);

        if(uRet == RECV_EOF)
        {
            DebugPrintEx(DEBUG_MSG,"Got EOF from RecvBuf");
            // FComCriticalNeg(TRUE);
    
            // RSL needed interface to TIFF thread
            pTG->fLastReadBlock = 1;
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
        }
        else
        {
            // Timeout from ModemRecvBuf
            DebugPrintEx(DEBUG_ERR,"ModemRecvBuf Timeout or Error=%d", uRet);
            PSSLogEntry(PSS_ERR, 1, "Failed to receive page data - aborting");
            err_status = T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully received page data");
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        // See if more pages to receive by parsing the FDR response...
        // After the DLEETX was received by Class2ModemRecvBuf, the
        // FPTS and FET response should be coming from the modem, terminated
        // by an OK. Let's go read that!

        if(!Class2iModemDialog( pTG, 
                                NULL, 
                                0,
                                STARTSENDMODE_TIMEOUT, 
                                TRUE, 
                                0, 
                                pTG->cbszCLASS2_OK, 
                                (C2PSTR)NULL))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to receive EOP or MPS or EOM - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        DebugPrintEx(DEBUG_MSG,"EOP Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));

        // Process the response and see if more pages are coming

        if (Class2EndPageResponseAction(pTG ) == MORE_PAGES)
        {
            // t-jonb: Here, we should be sending AT+FPS=1 or AT+FPS=2, according to fPageIsBad.
            // However, some modems (observed on USR Courier V.34 and USR Sportster 33.6)
            // don't understand it. So, we have to work with the modem's own quality assessment.
            // For class 2.0, ICommPutRecvBuf will decide whether to save the page based the
            // value from modem's +FPS: response (Saved in pTG->FPTSreport by
            // Class2EndPageResponseAction).
            ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);

            if (pTG->fPageIsBadOverride)
            {
                err_status = T30_CALLFAIL;  // User will see "partially received"
            }

            if (0)
            {
                uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, pTG->fPageIsBad ? 2 : 1);
                if(!Class2iModemDialog( pTG, 
                                        bBuf, 
                                        uwLen,
                                        LOCALCOMMAND_TIMEOUT, 
                                        TRUE, 
                                        0,
                                        pTG->cbszCLASS2_OK, 
                                        pTG->cbszCLASS2_ERROR, 
                                        (C2PSTR) NULL))
                {
                    DebugPrintEx(DEBUG_WRN,"FPTS= failed");
                    // Ignore FPTS failure!!!
                }
            }

            PSSLogEntry(PSS_MSG, 1, "sent MCF");   // Sending RTN is not yet implemented

            // Now, Send the FDR to start the next page (this was done for
            // the first page before entering the multipage loop).

            if(!Class2iModemDialog( pTG, 
                                    pTG->cbszFDR, 
                                    (UWORD)(strlen(pTG->cbszFDR) ),
                                    STARTSENDMODE_TIMEOUT, 
                                    TRUE, 
                                    0,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDR to start next PAGE Failed!");
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");
            PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
            // Now send the correct DC2 string set in Class20Callee
            // (DC2 is standard, some use ^q instead)
            FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

        } //if we do not have another page, do the else...
        else 
        {
            break; // All done receiving pages...
        }
    } //End of multipage while

    DebugPrintEx(DEBUG_MSG,"out of while multipage loop. about to send final FDR.");
    //RSL
    ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
    if (pTG->fPageIsBadOverride)
    {
        err_status = T30_CALLFAIL;  // User will see "partially received"
    }
    

    // Send end of message sequence
    // Send the last FPTS - do we really need to do this???
#if 0
    uwLen = wsprintf(bBuf, pTG->cbszFPTS, fPageIsBad ? 2 : 1);
    if(!Class2iModemDialog( pTG, 
                            bBuf, 
                            uwLen, 
                            LOCALCOMMAND_TIMEOUT, 
                            TRUE,
                            0, 
                            pTG->cbszCLASS2_OK, 
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FPTS= failed");
        // Ignore FPTS failure!!!
    }
#endif        

    // Send last FDR
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszFDR, 
                            (UWORD) (strlen(pTG->cbszFDR) ),
                            STARTSENDMODE_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK, 
                            (C2PSTR)NULL))
    {
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "sent MCF");   // Sending RTN is not yet implemented

    FComXon(pTG, FALSE);

    return err_status;

}

// ACTIVESLICE defined in msched.h
#define IDLESLICE       500


BOOL Class20GetModemMaker(PThrdGlbl pTG)
{
    USHORT i;

    DEBUG_FUNCTION_NAME("Class20GetModemMaker");

    // Initialize the current modem variable's (global) strings.
    pTG->CurrentMFRSpec.szATI[0] = '\0';
    pTG->CurrentMFRSpec.szMFR[0] = '\0';
    pTG->CurrentMFRSpec.szMDL[0] = '\0';
    // pTG->CurrentMFRSpec.szREV[0] = '\0';

//      // Get the ATI - repsonse is in pTG->lpbResponseBuf2
//      // For all responses, "ERROR" may come back - that is OK - we will
//      // never match ERROR to an acceptable modem manufacturer name, model,
//      // revision, etc.
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszCLASS2_ATI, 
                            (UWORD) strlen(pTG->cbszCLASS2_ATI),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"ATI failed");
        // Ignore ATI failure!!!
    }
    else
    {
        // copy ATI answer into ATI variable
        for (i=0; i<MFR_SIZE; i++)
        {
            pTG->CurrentMFRSpec.szATI[i] = pTG->lpbResponseBuf2[i];
        }
        DebugPrintEx(DEBUG_MSG,"Received ATI %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // Get the FMFR - repsonse is in pTG->lpbResponseBuf2
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszCLASS2_FMFR, 
                            (UWORD) (strlen(pTG->cbszCLASS2_FMFR) ),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FMFR failed");
        // Ignore FMFR failure!!!
    }
    else
    {
        // copy FMFR answer into FMFR variable
        for (i=0; i<MFR_SIZE; i++)
        {
            pTG->CurrentMFRSpec.szMFR[i] = pTG->lpbResponseBuf2[i];
        }
        DebugPrintEx(DEBUG_MSG,"Received FMFR %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // Get the FMDL - repsonse is in pTG->lpbResponseBuf2
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszCLASS2_FMDL, 
                            (UWORD) (strlen(pTG->cbszCLASS2_FMDL) ),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FMDL failed");
        // Ignore FMDL failure!!!
    }
    else
    {
        // copy FMDL answer into FMDL variable
        for (i=0; i<MFR_SIZE; i++)
        {
            pTG->CurrentMFRSpec.szMDL[i] = pTG->lpbResponseBuf2[i];
        }
        DebugPrintEx(DEBUG_MSG,"Received FMDL %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // Get the FREV - repsonse is in pTG->lpbResponseBuf2
    if(!Class2iModemDialog( pTG, 
                            pTG->cbszCLASS2_FREV, 
                            (UWORD) strlen (pTG->cbszCLASS2_FREV),
                            ANS_LOCALCOMMAND_TIMEOUT, 
                            TRUE, 
                            0, 
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR, 
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FREV failed");
        // Ignore FREV failure!!!
    }
    else
    {
         // copy FREV answer into REV variable
         for (i=0; i<MFR_SIZE; i++)
         {
             pTG->CurrentMFRSpec.szREV[i] = pTG->lpbResponseBuf2[i];
         }
        DebugPrintEx(DEBUG_MSG,"Received REV %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }

    return TRUE;
}
                         
                                                      

BOOL Class20Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
    int     i,
            j,
            comm_numb = 0,
            parameters;
    BYTE    switch_char,
            char_1,
            char_2;
    char    c;

    BOOL    found_command = FALSE;

    DEBUG_FUNCTION_NAME("Class20Parse");


    #define STRING_PARAMETER        1
    #define NUMBER_PARAMETERS       2
    for(i = 0; lpbBuf[i] != '\0'; ++i)
    {
        switch ( lpbBuf[i] )
        {
        case 'C':
                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad First C values");
                    return FALSE;
                }
                break;

        case 'O':
                if (lpbBuf[++i] == 'K' )
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_OK;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR, "Parse: Bad O values");
                    return FALSE;
                }
                break;

        case 0x11:
                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                break;

        case '+':
                if( lpbBuf[++i] != 'F' )
                {
                    DebugPrintEx(DEBUG_ERR, "Parse: Bad + values");
                    return FALSE;
                }
                switch_char = lpbBuf[++i];
                char_1 = lpbBuf[++i];
                char_2 = lpbBuf[++i];
                switch ( switch_char )
                {
                        case 'C':
                                //  Connect Message +FCON.
                                if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCON;
                                    parameters = FALSE;
                                }

                                // Report of Remote ID. +FCIG.
                                else if (char_1 == 'I' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report DCS frame information +FCS - Clanged for Class2.0
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad C values");
                                    return FALSE;
                                }
                                break;

                        case 'D':
                                if ( char_1 == 'M' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDM;
                                      parameters = NUMBER_PARAMETERS;
                                }
                                else 
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad D values");
                                      return FALSE;
                                }
                                break;

                        case 'E':
                                // Post page message report. +FET.
                                if ( char_1 == 'T' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FET;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad E values");
                                    return FALSE;
                                }
                                break;

                        case 'H':
                        // Debug report transmitted HDLC frames +FHT
                                if ( char_1 == 'T' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FHT;
                                    parameters = STRING_PARAMETER;
                                }
                        // Debug report received HDLC frames +FHR
                                if ( char_1 == 'R' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FHR;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report hang up.  +FHNG.
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad H values");
                                    return FALSE;
                                }
                                break;

                        case 'I':
                                // Report DIS frame information +FIS - Changed for Class2.0
                                if ( char_1 == 'S' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                                      parameters = NUMBER_PARAMETERS;
                                }                                               
                                else 
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad I values");
                                      return FALSE;
                                }
                                break;

                        case 'N':
                                // Report NSF frame reciept.
                                if ( char_1 == 'F' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                // Report NSS frame reciept.
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                // Report NSC frame reciept.
                                else if ( char_1 == 'C' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad N values");
                                    return FALSE;
                                }
                                break;

                       case 'P':

                                // Report of Remote ID. +FPI - Changed for Class2.0
                                if (char_1 == 'I')
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report poll request. +FPO - Changed for Class2.0
                                else if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                                    parameters = FALSE;
                                }
                                // Page Transfer Status Report +FPS - Changed for Class2.0
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else 
                                {
                                    DebugPrintEx(DEBUG_ERR,"Parse: Bad P values");
                                    return FALSE;
                                }
                                break;

                        case 'T':

                                // Report DTC frame information +FTC - Changed for Class2.0
                                if ( char_1 == 'C' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                                      parameters = NUMBER_PARAMETERS;
                                }
                                // Report remote ID +FTI - Changed for Class2.0
                                else if ( char_1 == 'I' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                                      parameters = STRING_PARAMETER;
                                }
                                else 
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad T values");
                                      return FALSE;
                                }
                                break;

                        case 'V':
                                // Report voice request +FVOICE.
                                if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                                    parameters = FALSE;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad V values");
                                    return FALSE;
                                }
                }

                //  Transfer the associated paramters to the parameter array.
                if ( parameters == NUMBER_PARAMETERS)
                {
                    for(i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                    {
                            //  Skip past the non numeric characters.
                            if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' ) 
                            {
                                continue;
                            }

                            /*  Convert the character representation of the numeric
                                     parameter into a true number, and store in the
                                    parameter list.  */
                            cl2_comm->parameters[comm_numb][j] = 0;
                            for(; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                            {
                                cl2_comm->parameters[comm_numb][j] *= 10;
                                cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                            }
                            i--; // the last for loop advanced 'i' past the numeric.
                            j++; // get set up for next parameter
                    }
                }
                else if (parameters == STRING_PARAMETER )
                {
                    // Skip the : that follows the +f command (eg +FTSI:)
                    if (lpbBuf[i+1] == ':')
                    {
                        i++;
                    }
                    // Also skip leading blanks
                    while (lpbBuf[i+1] == ' ') 
                    {
                        i++;
                    }
                    for(i+=1, j=0; (c = lpbBuf[i])  != '\r' && c != '\n' &&
                            c != '\0'; ++i, ++j)
                    {
                            cl2_comm->parameters[comm_numb][j] = c;
                            if ( lpbBuf[i] == '\"' )
                            {
                                    --j;
                            }
                    }
                    cl2_comm->parameters[comm_numb][j] = '\0';
                }

                //  No parameters, so just skip to end of line.
                else
                {
                    for(; (c=lpbBuf[i]) != '\r'
                            && c != '\n' && c != '\0'; ++i)
                            ;
                }

                //  Increment command count.
                ++comm_numb;
                break;

        default:
                break;
        }
    }
    cl2_comm->comm_count = (USHORT)comm_numb;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\encoder.h ===
/***************************************************************************
 Name     :     ENCODER.H
 Comment  :     HDLC encoding structs

        Copyright (c) Microsoft Corp. 1991 1992 1993

***************************************************************************/

#ifdef WIN32
#       define CODEBASED
#else
#       define CODEBASED        __based(__segname("_CODE"))
#endif

#ifdef SWECM
#       define SWECMEXP _export FAR PASCAL
#else
#       define SWECMEXP
#endif


USHORT SWECMEXP HDLC_Encode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, LPENCODESTATE lpState);
USHORT SWECMEXP HDLC_AddFlags(PThrdGlbl pTG, LPBYTE lpbDst, USHORT cbFlags, LPENCODESTATE lpState);

/******
#define HDLC_End(lpbDst, lpState)                                                                       \
        {       (lpState)->len = 0;                                                                                     \
                *lpbDst = (lpState)->carry;                                                                     \
                *lpbDst++ |= (0xFF << ((lpState)->enc_width));                                  \
                (lpState)->carry = (lpState)->enc_width = 0; }
******/

#define InitEncoder(pTG, State)      { State.carry=State.enc_width=State.len=0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\ddi.c ===
/***************************************************************************
        Name      :     DDI.C

        Copyright (c) Microsoft Corp. 1991 1992 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#pragma warning(disable:4100)   // unreferenced formal param

#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"

#include "mmsystem.h"
#include "comdevi.h"
#include "class1.h"
// #include "modem.h"
#include "debug.h"
#include "decoder.h"

///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID        FILE_ID_DDI


#define FILEID                  FILEID_DDI

/* Converts a the T30 code for a speed to the Class1 code
 * Generates V.17 with Long Training.
 * Add 1 to V.17 codes to get teh Short-train version
 */
BYTE T30toC1[16] =
{
/* V27_2400             0 */    24,
/* V29_9600             1 */    96,
/* V27_4800             2 */    48,
/* V29_7200             3 */    72,
/* V33_14400    4 */    145,    // 144, // V33==V17_long_train FTM=144 is illegal
                                                0,
/* V33_12000    6 */    121,    // 120, // V33==V17_long_train FTM=120 is illegal
/* V21 squeezed in */   3,
/* V17_14400    8 */    145,
/* V17_9600             9 */    97,
/* V17_12000    10 */   121,
/* V17_7200             11 */   73,
                                                0,
                                                0,
                                                0,
                                                0
};



int T30toSpeed[16] =
{
/* V27_2400             0 */    2400,
/* V29_9600             1 */    9600,
/* V27_4800             2 */    4800,
/* V29_7200             3 */    7200,
/* V33_14400    4 */    14400,    // 144, // V33==V17_long_train FTM=144 is illegal
                                                0,
/* V33_12000    6 */    12000,    // 120, // V33==V17_long_train FTM=120 is illegal
/* V21 squeezed in */   300,
/* V17_14400    8 */    14400,
/* V17_9600             9 */    9600,
/* V17_12000    10 */   12000,
/* V17_7200             11 */   7200,
                                                0,
                                                0,
                                                0,
                                                0
};

// used only for checking

static BYTE SpeedtoCap[16] =
{
/* V27_2400             0 */    0,
/* V29_9600             1 */    V29,    // 1
/* V27_4800             2 */    V27,    // 2
/* V29_7200             3 */    V29,    // 1
/* V33_14400    4 */    V33,    // 4
                                                0,
/* V33_12000    6 */    V33,    // 4
/* V21 squeezed in */   0,
/* V17_14400    8 */    V17,    // 8
/* V17_9600             9 */    V17,    // 8
/* V17_12000    10 */   V17,    // 8
/* V17_7200             11 */   V17,    // 8
                                                0,
                                                0,
                                                0,
                                                0
};


CBSZ cbszFTH3   = "AT+FTH=3\r";
CBSZ cbszFRH3   = "AT+FRH=3\r";

CBSZ cbszFRS    = "AT+FRS=%d\r";
CBSZ cbszFTS    = "AT+FTS=%d\r";
CBSZ cbszFTM    = "AT+FTM=%d\r";
CBSZ cbszFRM    = "AT+FRM=%d\r";

#ifdef MDRV
        CBSZ cbszOK, cbszCONNECT, cbszNOCARRIER, cbszERROR, cbszFCERROR;
#else //MDRV

// echo off, verbose response, no auto answer, hangup on DTR drop
// 30 seconds timer on connect, speaker always off, speaker volume=0
// busy&dialtone detect enabled
extern  CBSZ cbszOK       ;
extern  CBSZ cbszCONNECT   ;
extern  CBSZ cbszNOCARRIER  ;
extern  CBSZ cbszERROR       ;
extern  CBSZ cbszFCERROR      ;

#endif //MDRV



#define         ST_MASK         (0x8 | ST_FLAG)         // 8 selects V17 only. 16 selects ST flag

/******************** Global Vars *********/
BYTE                            bDLEETX[3] = { DLE, ETX, 0 };
BYTE                            bDLEETXOK[9] = { DLE, ETX, '\r', '\n', 'O', 'K', '\r', '\n', 0 };
/******************** Global Vars *********/




/****************** begin prototypes from ddi.c *****************/
void iModemParamsReset(PThrdGlbl pTG);
void iModemInitGlobals(PThrdGlbl pTG);

// If defined, iModemRecvFrame retries FTH until timeout,
// if it receiving a null frame followed by ERROR or NO_CARRIER.
//#define USR_HACK

#ifdef USR_HACK
USHORT iModemFRHorM(PThrdGlbl pTG, ULONG ulTimeout);
#endif // USR_HACK

/****************** begin prototypes from ddi.c *****************/


#ifndef MDRV

#ifdef DEBUG
        DBGPARAM dpCurSettings = {
                    "Modem Driver", 
                    0x0000, 
                    {   "DDI", 
                        "Frames", 
                        "", 
                        "",
                        "Class0", 
                        "", 
                        "", 
                        "",
                        "", 
                        "", 
                        "SW Framing", 
                        "SW Framing Hi"
                        "Debug", 
                        "", 
                        "", 
                        "" 
                    },
                    // 0x00000FFF
                    // 0x00000001
                    // 0x0000000F0
                    // 0x00000400   // too much for 14400 ECM
                    // 0x00000F01
                    0x00000000
                    // 0xFFFFFFFF
        };
#endif


#define szMODULENAME    "awcl1_32"


#endif //MDRV

void iModemInitGlobals(PThrdGlbl pTG)
{
    _fmemset(&pTG->Class1Modem, 0, sizeof(CLASS1_MODEM));
    _fmemset(&pTG->Class1Status, 0, sizeof(CLASS1_STATUS));

    pTG->Class1Modem.eRecvFCS = RECV_FCS_NO;

#if 0 /// RSL #ifndef MDDI
    {
        LPCMDTAB lpCmdTab = iModemGetCmdTabPtr(pTG);
        pTG->Class1Modem.eRecvFCS = RECV_FCS_DUNNO;
        if (lpCmdTab)
        {
            if (lpCmdTab->dwFlags&fMDMSP_C1_FCS_NO)
            {
                pTG->Class1Modem.eRecvFCS = RECV_FCS_NO;
            }
            else if (lpCmdTab->dwFlags&fMDMSP_C1_FCS_YES_BAD)
            {
                pTG->Class1Modem.eRecvFCS = RECV_FCS_NOCHK;
            }
        }
    }
#endif //!MDDI
}

void iModemParamsReset(PThrdGlbl pTG)
{
    _fmemset(&pTG->ModemParams, 0 , sizeof(pTG->ModemParams));

    pTG->ModemParams.uSize = sizeof(pTG->ModemParams);
    pTG->ModemParams.Class = FAXCLASS1;

    // Don't use this. Need differnet number of flags according to speed
    // pTG->ModemParams.PreambleFlags = 400;     // 200ms @ 14400bps
    pTG->ModemParams.InterframeFlags = 3;        // random. one or two may do!
    // pTG->ModemParams.InterframeFlags = 10;    // too much!

    // must be **less* than 50, so need a
    // different length for each speed
    // pTG->ModemParams.ClosingFlags = 50;
    // pTG->ModemParams.fCEDOff = 0;
    // pTG->ModemParams.fCNGOff = 0;
    // pTG->ModemParams.InactivityTimer = 0;

    // pTG->ModemParams.cbLineMin = 0;
    // pTG->ModemParams.hJob = 0;
}

// added for CLASS0
BOOL ModemSetParams(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParams)
{
    BG_CHK((uModem==1||uModem==5) && lpParams->uSize >= sizeof(MODEMPARAMS));

    if(lpParams->Class && lpParams->Class != (-1))
    {
        BG_CHK(lpParams->Class == FAXCLASS1);
        pTG->ModemParams.Class = lpParams->Class;
    }
    return TRUE;
}

USHORT NCUDial(PThrdGlbl pTG, HLINE hLine, LPSTR szPhoneNum)
{
    USHORT uRet;

    iModemInitGlobals(pTG);

    pTG->ModemParams.Class = FAXCLASS1;
    if((uRet = iModemDial(pTG, szPhoneNum, pTG->ModemParams.Class)) == CONNECT_OK)
    {
        pTG->Class1Modem.ModemMode = FRH;
    }

    return uRet;
}

USHORT NCULink
(
    PThrdGlbl pTG, 
    HLINE hLine, 
    HMODEM hModem, 
    USHORT uHandset, 
    USHORT uFlags
)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("NCULink"));

    switch(uFlags & NCULINK_MODEMASK)
    {
    case NCULINK_HANGUP:
                                    if(iModemHangup(pTG))
                                    {
                                        uRet = CONNECT_OK;
                                    }
                                    else
                                    {
                                        uRet = CONNECT_ERROR;
                                    }
                                    break;
    case NCULINK_TX:
                                    uRet = CONNECT_OK;
                                    break;
    case NCULINK_RX:
                                    iModemInitGlobals(pTG);
                                    pTG->ModemParams.Class = FAXCLASS1;  //RSL
                                    if((uRet = iModemAnswer(pTG, (uFlags & NCULINK_IMMEDIATE), pTG->ModemParams.Class)) == CONNECT_OK)
                                    {
                                        pTG->Class1Modem.ModemMode = FTH;
                                    }
                                    break;
    case NCULINK_OFFHOOK:
                                    // fall through. Can't handle yet
    default:                        BG_CHK(FALSE);
                                    uRet = CONNECT_ERROR;
                                    break;
    }

    DebugPrintEx(   DEBUG_MSG,  
                    "uRet=%d Linked=%d", 
                    uRet, 
                    pTG->DDI.fNCUModemLinked);
    return uRet;
}

// dangerous. May get 2 OKs, may get one. Generally avoid
// CBSZ cbszATAT                        = "AT\rAT\r";
CBSZ cbszAT1                    = "AT\r";

BOOL iModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags);

BOOL   ModemSync(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout)
{
    return iModemSyncEx(pTG, hModem, ulTimeout, 0);
}

BOOL   ModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags)
{
    return iModemSyncEx(pTG, hModem, ulTimeout, dwFlags);
}

BOOL iModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG ulTimeout, DWORD dwFlags)
{
    DEBUG_FUNCTION_NAME(("iModemSyncEx"));

    DebugPrintEx(   DEBUG_MSG,
                    "fModemOpen=%d fLineInUse=%d", 
                    pTG->DDI.fModemOpen, 
                    pTG->DDI.fLineInUse);

    ///// Do cleanup of global state //////
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    SWFramingSendSetup(pTG, FALSE);
    SWFramingRecvSetup(pTG, FALSE);
    FComXon(pTG, FALSE);
    EndMode(pTG);
    ///// Do cleanup of global state //////

    {
        LPCMDTAB lpCmdTab = iModemGetCmdTabPtr(pTG);
        if (
                (dwFlags & fMDMSYNC_DCN) &&
                    pTG->Class1Modem.ModemMode == COMMAND
                &&  lpCmdTab
            &&  (lpCmdTab->dwFlags&fMDMSP_C1_NO_SYNC_IF_CMD) )
        {
                DebugPrintEx(DEBUG_WRN, "NOT Syching modem (MSPEC)");
#ifdef WIN32
                Sleep(100); // +++ 4/12 JosephJ -- try to elim this -- it's juse
#endif // WIN32
                                        // that we used to always issue an AT here, which
                                        // we now don't, so I issue a 100ms delay here instead.
                                        // MOST probably unnessary. The AT was issued by
                                        // accident on 4/94 -- as a side effect of
                                        // a change in T.30 code -- when ModemSync was
                                        // called just before a normal dosconnect. Unfortunately
                                        // we discovered in 4/95, 2 weeks before code freeze,
                                        // that the AT&T DataPort express (TT14), didn't
                                        // like this AT.
                return TRUE;
        }
        else
        {
            return (iModemPauseDialog(pTG, (LPSTR)cbszAT1, sizeof(cbszAT1)-1, ulTimeout, cbszOK)==1);
        }
    }
}

// Does nothing in this driver
BOOL ModemFlush(PThrdGlbl pTG, HMODEM hModem)
{
    return TRUE;
}

// #if (PAGE_PREAMBLE_DIV != 0)

// length of TCF = 1.5 * bpscode * 100 / 8 == 75 * bpscode / 4
USHORT TCFLen[16] =
{
/* V27_2400             0 */    450,
/* V29_9600             1 */    1800,
/* V27_4800             2 */    900,
/* V29_7200             3 */    1350,
/* V33_14400    4 */    2700,
                                                0,
/* V33_12000    6 */    2250,
                                                0,
/* V17_14400    8 */    2700,
/* V17_9600             9 */    1800,
/* V17_12000    10 */   2250,
/* V17_7200             11 */   1350,
                                                0,
                                                0,
                                                0,
                                                0
};


#define min(x,y)        (((x) < (y)) ? (x) : (y))
#define ZERO_BUFSIZE    256

void SendZeros1(PThrdGlbl pTG, USHORT uCount)
{
    BYTE    bZero[ZERO_BUFSIZE];
    short   i;              // must be signed

    DEBUG_FUNCTION_NAME(_T("SendZeros1"));

    PSSLogEntry(PSS_MSG, 2, "send: %d zeroes", uCount);  

    _fmemset(bZero, 0, ZERO_BUFSIZE);
    for(i=uCount; i>0; i -= ZERO_BUFSIZE)
    {
        // no need to stuff. They're all zeros!
        FComDirectAsyncWrite(pTG, bZero, (UWORD)(min((UWORD)i, (UWORD)ZERO_BUFSIZE)));
    }
    DebugPrintEx(DEBUG_MSG,"Sent %d zeros",uCount);
}
// #endif //PAGE_PREAMBLE_DIV != 0

BOOL ModemSendMode
(
    PThrdGlbl pTG, 
    HMODEM hModem, 
    USHORT uMod, 
    BOOL fHDLC, 
    USHORT ifrHint
)
{
    DEBUG_FUNCTION_NAME(_T("ModemSendMode"));

    BG_CHK(ifrHint && ifrHint < ifrEND);

    pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

    pTG->CurrentCommSpeed = T30toSpeed[uMod & 0xF];

    BG_CHK(pTG->Class1Modem.CurMod);

    if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
    {
        pTG->Class1Modem.CurMod++;
    }
    // BG_CHK((pTG->Class1Modem.CurMod>24 && ModemCaps.uSendSpeeds!=V27_V29_V33_V17) ?
    //                      (SpeedtoCap[uMod & 0xF] & ModemCaps.uSendSpeeds) : 1);

    DebugPrintEx(   DEBUG_MSG,
                    "uMod=%d CurMod=%d fHDLC=%d", 
                    uMod, 
                    pTG->Class1Modem.CurMod, 
                    fHDLC);

    if(uMod == V21_300)
    {
        BG_CHK(pTG->Class1Modem.CurMod == 3);
        _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFTH3);
        pTG->Class1Modem.uCmdLen = sizeof(cbszFTH3)-1;
        pTG->Class1Modem.fHDLC = TRUE;
        FComXon(pTG, FALSE);                 // for safety. _May_ be critical
    }
    else
    {
        pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFTM, pTG->Class1Modem.CurMod);
        pTG->Class1Modem.fHDLC = FALSE;
        FComXon(pTG, TRUE);          // critical!! Start of PhaseC
        // no harm doing it here(i.e before issuing +FTM)

        if(fHDLC)
        {
            if(!SWFramingSendSetup(pTG, TRUE))
            {
                BG_CHK(FALSE);
                goto error2;
            }
        }
    }
    FComOutFilterInit(pTG);    // _not_ used for 300bps HDLC
                                                    // but here just in case
    // want to do all the work _before_ issuing command

    pTG->Class1Modem.DriverMode = SEND;
    pTG->Class1Status.ifrHint = ifrHint; // need this before ModemDialog

    if(pTG->Class1Modem.ModemMode == FTH)
    {
        // already in send mode. This happens on Answer only
        BG_CHK(fHDLC && uMod==V21_300);
        BG_CHK(pTG->Class1Modem.CurMod==3 && pTG->Class1Modem.fHDLC == TRUE);
        return TRUE;
    }

#define STARTSENDMODE_TIMEOUT 5000                              // Random Timeout

    //// Try to cut down delay between getting CONNECT and writing the
    // first 00s (else modems can quit because of underrun).
    // Can do this by not sleeping in this. Only in fatal
    // cases will it lock up for too long (max 5secs). In those cases
    // the call is trashed too.

    FComCritical(pTG, TRUE);     // start Crit in ModemSendMode

    if(!iModemNoPauseDialog(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, STARTSENDMODE_TIMEOUT, cbszCONNECT))
    {
        FComCritical(pTG, FALSE);    // end Crit in ModemSendMode
        goto error;
    }

    // can't set this earlier. We'll trash previous value
    pTG->Class1Modem.ModemMode = ((uMod==V21_300) ? FTH : FTM);

    // Turn OFF overlapped I/O if in V.21 else ON
    FComOverlappedIO(pTG, uMod != V21_300);

    if(pTG->Class1Modem.fSendSWFraming)  // set in SWFramingSendSetup
    {
        SWFramingSendPreamble(pTG, pTG->Class1Modem.CurMod);
    }

#if (PAGE_PREAMBLE_DIV != 0)
    else if(pTG->Class1Modem.ModemMode == FTM)
    {
        // don't send 00s if ECM
        BG_CHK(ifrHint==ifrPIX_MH || ifrHint==ifrPIX_MR || ifrHint==ifrTCF);
        BG_CHK(PAGE_PREAMBLE_DIV);
        SendZeros1(pTG, (USHORT)(TCFLen[uMod & 0x0F] / PAGE_PREAMBLE_DIV));
    }
#else
    else if(ifrHint==ifrPIX_MH || ifrHint==ifrPIX_MR)
    {
        // even if MDDI is on need to send some 00s otherwise
        // some modems underrun and hangup
        SendZeros1(pTG, TCFLen[uMod & 0x0F] / 2);
    }
#endif

    // FComDrain(-,FALSE) causes fcom to write out any internally-
    // maintained buffers, but not to drain the comm-driver buffers.
    FComDrain(pTG, TRUE,FALSE);

    FComCritical(pTG, FALSE);    // end Crit in ModemSendMode

    DebugPrintEx(   DEBUG_MSG,
                    "Starting Send at %d", 
                    pTG->Class1Modem.CurMod);
    return TRUE;

error:
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    SWFramingSendSetup(pTG, FALSE);
error2:
    FComXon(pTG, FALSE);         // important. Cleanup on error
    EndMode(pTG);
    return FALSE;
}

BOOL iModemDrain(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("iModemDrain"));

    if(!FComDrain(pTG, TRUE, TRUE))
            return FALSE;

            // Must turn XON/XOFF off immediately *after* drain, but before we
            // send the next AT command, since recieved frames have 0x13 or
            // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

// increase this---see bug number 495. Must be big enough for
// COM_OUTBUFSIZE to safely drain at 2400bps(300bytes/sec = 0.3bytes/ms)
// let's say (COM_OUTBUFSIZE * 10 / 3) == (COM_OUTBUFSIZE * 4)
// can be quite long, because on failure we just barf anyway

#define POSTPAGEOK_TIMEOUT (10000L + (((ULONG)COM_OUTBUFSIZE) << 2))

    // Here we were looking for OK only, but some modems (UK Cray Quantun eg)
    // give me an ERROR after sending TCF or a page (at speeds < 9600) even
    // though the page was sent OK. So we were timing out here. Instead look
    // for ERROR (and NO CARRIER too--just in case!), and accept those as OK
    // No point returning ERROR from here, since we just abort. We can't/don't
    // recover from send errors
    // if(!iModemResp1(POSTPAGEOK_TIMEOUT, cbszOK))

    if(iModemResp3(pTG, POSTPAGEOK_TIMEOUT, cbszOK, cbszERROR, cbszNOCARRIER) == 0)
            return FALSE;

            // Must change FlowControl State *after* getting OK because in Windows
            // this call takes 500 ms & resets chips, blows away data etc.
            // So do this *only* when you *know* both RX & TX are empty.
            // check this in all usages of this function

    return TRUE;
}


BOOL iModemSendData(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
    DEBUG_FUNCTION_NAME(("iModemSendData"));

    BG_CHK((uFlags & SEND_ENDFRAME) == 0);
    BG_CHK(lpb);
    BG_CHK(!pTG->Class1Modem.fSendSWFraming);

    // if(uFlags & SEND_STUFF)
    {
        // always DLE-stuff here. Sometimes zero-stuff

        DebugPrintEx(DEBUG_MSG,"calling FComFilterAsyncWrite");

        if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
                goto error;
    }
/*******
    else
    {
            if(!FComDirectAsyncWrite(pTG, lpb, uCount))
                    goto error;
    }
*******/

    if(uFlags & SEND_FINAL)
    {
        DebugPrintEx(DEBUG_MSG,"FComDIRECTAsyncWrite");

        // if(!FComDirectAsyncWrite(bDLEETXCR, 3))
        if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                goto error;

        if(!iModemDrain(pTG))
                goto error;

        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        FComXon(pTG, FALSE);         // critical. End of PhaseC
                                                // must come after Drain
        EndMode(pTG);
    }

    return TRUE;

error:
    FComXon(pTG, FALSE);                 // critical. End of PhaseC (error)
    FComFlush(pTG);                    // clean out the buffer if we got an error
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    EndMode(pTG);
    return FALSE;
}

BOOL iModemSendFrame(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
    UWORD   uwResp=0;

    DEBUG_FUNCTION_NAME(("iModemSendFrame"));

    BG_CHK(uFlags & SEND_ENDFRAME);
    BG_CHK(lpb && uCount);
    BG_CHK(!pTG->Class1Modem.fSendSWFraming);

    // always DLE-stuff here. Never zero-stuff
    // This is only called for 300bps HDLC
    BG_CHK(pTG->Class1Modem.fHDLC && pTG->Class1Modem.CurMod == 3);

    if(pTG->Class1Modem.ModemMode != FTH)        // Special case on just answering!!
    {
#define FTH_TIMEOUT 5000                                // Random Timeout
        if(!iModemNoPauseDialog(    pTG, 
                                    (LPB)pTG->Class1Modem.bCmdBuf, 
                                    pTG->Class1Modem.uCmdLen, 
                                    FTH_TIMEOUT, 
                                    cbszCONNECT))
                goto error;
    }

    // if(uFlags & SEND_STUFF)
    {
        // always DLE-stuff here. Never zero-stuff
        if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEONLY))
                goto error;
    }
/***
    else
    {
            if(!FComDirectAsyncWrite(pTG, lpb, uCount))
                    goto error;
    }
***/


    // if(uFlags & SEND_STUFF)
    {
            // SyncWrite call Drain here which we should not need
            // as we are immediately waiting for a response
            // if(!FComDirectSyncWrite(bDLEETX, 2))
            //              goto error;

        PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");

        if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                goto error;
    }

// 2000 is too short because PPRs can be 32+7 bytes long and
// preamble is 1 sec, so set this to 3000
// 3000 is too short because NSFs and CSIs can be arbitrarily long
// MAXFRAMESIZE is defined in et30type.h. 30ms/byte at 300bps
// async (I think V.21 is syn though), so use N*30+1000+slack

#define WRITEFRAMERESP_TIMEOUT  (1000+30*MAXFRAMESIZE+500)
    if(!(uwResp = iModemResp2(pTG, WRITEFRAMERESP_TIMEOUT, cbszOK, cbszCONNECT)))
            goto error;
    pTG->Class1Modem.ModemMode = ((uwResp == 2) ? FTH : COMMAND);


    if(uFlags & SEND_FINAL)
    {
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        // FComXon(FALSE);      // at 300bps. no Xon-Xoff in use

        // in some weird cases (Practical Peripherals PM14400FXMT) we get
        // CONNECT<cr><lf>OK, but we get the CONNECT here. Should we
        // just set pTG->Class1Modem.ModemMode=COMMAND?? (EndMode does that)
        // Happens on PP 144FXSA also. Ignore it & just set mode to COMMAND
        // BG_CHK(pTG->Class1Modem.ModemMode == COMMAND);
        EndMode(pTG);
    }
    // ST_FRAMES(TRACE((SZMOD "FRAME SENT-->\r\n")); D_PrintFrame(lpb, uCount));
    return TRUE;

error:
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    FComXon(pTG, FALSE);         // just for safety. cleanup on error
    EndMode(pTG);
    return FALSE;
}

BOOL ModemSendMem
(
    PThrdGlbl pTG, 
    HMODEM hModem, 
    LPBYTE lpb, 
    USHORT uCount, 
    USHORT uFlags
)
{
        
    DEBUG_FUNCTION_NAME(_T("ModemSendMem"));

    BG_CHK(pTG->Class1Modem.CurMod);
    BG_CHK(lpb);
    DebugPrintEx(   DEBUG_MSG,
                    "lpb=%08lx uCount=%d wFlags=%04x",
                    lpb, 
                    uCount, 
                    uFlags);

    if(pTG->Class1Modem.DriverMode != SEND)
    {
        BG_CHK(FALSE);
        return FALSE;
    }

    if(pTG->Class1Modem.fSendSWFraming) 
    {
        DebugPrintEx(DEBUG_MSG,"(fSendSWFraming) calling: SWFramingSendFrame");
        return SWFramingSendFrame(pTG, lpb, uCount, uFlags);
    }
    else if(pTG->Class1Modem.fHDLC)
    {
        DebugPrintEx(DEBUG_MSG,"(fHDLC) calling: iModemSendFrame");
        return iModemSendFrame(pTG, lpb, uCount, uFlags);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"(Else) calling: iModemSendData");
        return iModemSendData(pTG, lpb, uCount, uFlags);
    }
}

void TwiddleThumbs(ULONG ulTime);

#ifndef MDRV
void TwiddleThumbs(ULONG ulTime)
{
    MY_TWIDDLETHUMBS(ulTime);
}
#endif //MDRV

BOOL ModemSendSilence(PThrdGlbl pTG, HMODEM hModem, USHORT uMillisecs, ULONG ulTimeout)
{
    //USHORT uTemp;

    DEBUG_FUNCTION_NAME(_T("ModemSendSilence"));

    DebugPrintEx(   DEBUG_MSG,
                    "Before uMillsecs=%d ulTimeout=%ld",
                    uMillisecs, 
                    ulTimeout);

    // we're so slow it seems we don't need to and should not do this
    // I measured teh dealy due to this (FTS=10) to be about 500ms,
    // all of it on our side (dunno why?) except exactly the 100ms
    // by the modem. If we really want to insert teh delay we should
    // use TwiddleThumbs
    // Can't just return here, because we do _need_ the delay between
    // send DCS and send TCF so that receiver is not overwhelmed
    // return TRUE;

    // use TwiddleThumbs
    TwiddleThumbs(uMillisecs);

    DebugPrintEx(DEBUG_MSG,"After");

    return TRUE;

    // uTemp = wsprintf(pTG->Class1Modem.bCmdBuf, cbszFTS, uMillisecs/10);
    // return (iModemNoPauseDialog((LPB)pTG->Class1Modem.bCmdBuf, uTemp, ulTimeout, cbszOK) == 1);
}

BOOL ModemRecvSilence(PThrdGlbl pTG, HMODEM hModem, USHORT uMillisecs, ULONG ulTimeout)
{
    // USHORT  uTemp;
    // CBPSTR  cbpstr;

    DEBUG_FUNCTION_NAME(_T("ModemRecvSilence"));

    DebugPrintEx(   DEBUG_MSG,
                    "Before uMillsecs=%d ulTimeout=%ld",
                    uMillisecs, 
                    ulTimeout);

    // can't use AT+FRS -- see above for why. Basically, we take so long
    // sending the command and getting teh reply etc, that we can't use
    // it accurately. So use TwiddleThumbs.

    TwiddleThumbs(uMillisecs);

    DebugPrintEx(DEBUG_MSG,"After");

    return TRUE;

    // uTemp = wsprintf(pTG->Class1Modem.bCmdBuf, cbpstr, uMillisecs/10);
    // return (iModemNoPauseDialog((LPB)pTG->Class1Modem.bCmdBuf, uTemp, ulTimeout, cbszOK)==1);
}

#define MINRECVMODETIMEOUT      500
#define RECVMODEPAUSE           200

USHORT ModemRecvMode(PThrdGlbl pTG, HMODEM hModem, USHORT uMod, BOOL fHDLC, ULONG ulTimeout, USHORT ifrHint)
{
    USHORT  uRet;
    ULONG ulBefore, ulAfter;

    DEBUG_FUNCTION_NAME(_T("ModemRecvMode"));
    // Here we should watch for a different modulation scheme from what we expect.
    // Modems are supposed to return a +FCERROR code to indicate this condition,
    // but I have not seen it from any modem yet, so we just scan for ERROR
    // (this will catch +FCERROR too since iiModemDialog does not expect whole
    // words or anything silly like that!), and treat both the same.

    pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

    pTG->CurrentCommSpeed = T30toSpeed[uMod & 0xF];

    BG_CHK(pTG->Class1Modem.CurMod);
    if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
    {
        pTG->Class1Modem.CurMod++;
    }

    if(uMod == V21_300)
    {
        BG_CHK(fHDLC && pTG->Class1Modem.CurMod==3);
        _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFRH3);
        pTG->Class1Modem.uCmdLen = sizeof(cbszFRH3)-1;
    }
    else
    {
        pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFRM, pTG->Class1Modem.CurMod);
    }

    pTG->Class1Status.ifrHint = ifrHint; // need this before ModemDialog

    if(pTG->Class1Modem.ModemMode == FRH)
    {
        // already in receive mode. This happens upon Dial only
        BG_CHK(fHDLC && uMod==V21_300);
        BG_CHK(pTG->Class1Modem.CurMod == 3);

        pTG->Class1Modem.fHDLC = TRUE;
        pTG->Class1Modem.DriverMode = RECV;
        pTG->Class1Modem.fRecvNotStarted = TRUE;     // fNoFlags = FALSE;
        // pTG->Class1Modem.sRecvBufSize = sBufSize;
        FComInFilterInit(pTG);
        return RECV_OK;
    }


#ifdef WIN32
    // On Win32, we have a problem going into 2400baud recv.
    // +++ remember to put this into iModemFRHorM when that code is enabled.
    if (pTG->Class1Modem.CurMod==24) TwiddleThumbs(80);
#endif // WIN32

#ifdef USR_HACK
    uRet = iModemFRHorM(pTG, ulTimeout);
#else // !USR_HACK (iModemFRHorM contains the following code..)
retry:

    ulBefore=GetTickCount();
    // Don't look for NO CARRIER. Want it to retry until FRM timeout on NO CARRIER
    // ----This is changed. See below----
    uRet = iModemNoPauseDialog3(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR, cbszNOCARRIER);
    // uRet = iModemNoPauseDialog2(pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR);
    ulAfter=GetTickCount();

    if(uRet==2 || uRet==3)  // uRet==FCERROR or uRet==NOCARRIER
    {
        if( (ulAfter <= ulBefore) ||    // wraparound or 0 time elapsed (timer broke)
                (ulTimeout < ((ulAfter-ulBefore) + MINRECVMODETIMEOUT)))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Giving up on RecvMode. uRet=%d ulTimeout=%ld",
                            uRet, 
                            ulTimeout);
        }
        else
        {
            ulTimeout -= (ulAfter-ulBefore);

            // need this pause for NO CARRIER for USR modems. See bug#1516
            // for the RC229DP, dunno if it's reqd because I dunno why theyre
            // giving the FCERROR. Don't want to miss the carrier so currently
            // don't pause. (Maybe we can achieve same effect by simply taking
            // FCERROR out of the response list above--but that won't work for
            // NOCARRIER because we _need_ teh pause. iiModemDialog is too fast)
            if(uRet == 3)
                    TwiddleThumbs(RECVMODEPAUSE);
            BG_CHK(ulTimeout >= MINRECVMODETIMEOUT);

            goto retry;
        }
    }
#endif // !USR_HACK

    DebugPrintEx(   DEBUG_MSG,
                    "uMod=%d CurMod=%d fHDLC=%d ulTimeout=%ld: Got=%d", 
                    uMod, 
                    pTG->Class1Modem.CurMod, 
                    fHDLC, 
                    ulTimeout, 
                    uRet);
    if(uRet != 1)
    {
        EndMode(pTG);
        if(uRet == 2)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Got FCERROR after %ldms", 
                            ulAfter-ulBefore);
            return RECV_WRONGMODE;  // need to return quickly
        }
        else
        {
            BG_CHK(uRet == 0);
            DebugPrintEx(   DEBUG_WRN,
                            "Got Timeout after %ldms",
                            ulAfter-ulBefore);
            return RECV_TIMEOUT;
        }
    }

    BG_CHK(ifrHint && ifrHint < ifrEND);
    BG_CHK(pTG->Class1Modem.CurMod);
    // BG_CHK((pTG->Class1Modem.CurMod>24 && ModemCaps.uRecvSpeeds!=V27_V29_V33_V17) ?
    //                      (SpeedtoCap[uMod & 0xF] & ModemCaps.uRecvSpeeds) : 1);

    if(uMod==V21_300)
    {
        pTG->Class1Modem.ModemMode = FRH;
        pTG->Class1Modem.fHDLC = TRUE;
    }
    else
    {
        pTG->Class1Modem.ModemMode = FRM;
        pTG->Class1Modem.fHDLC = FALSE;
        if(fHDLC)
        {
            if(!SWFramingRecvSetup(pTG, TRUE))
            {
                BG_CHK(FALSE);
                EndMode(pTG);
                return RECV_ERROR;
            }
        }
    }
    // pTG->Class1Modem.sRecvBufSize = sBufSize;
    pTG->Class1Modem.DriverMode = RECV;
    pTG->Class1Modem.fRecvNotStarted = TRUE;     // fNoFlags = FALSE;
    FComInFilterInit(pTG);
    DebugPrintEx(DEBUG_MSG, "Starting Recv at %d", pTG->Class1Modem.CurMod);
    return RECV_OK;
}

USHORT iModemRecvData
(   
    PThrdGlbl pTG, 
    LPB lpb, 
    USHORT cbMax, 
    ULONG ulTimeout, 
    USHORT far* lpcbRecv
)
{
    SWORD   swEOF;
    USHORT  uRet;

    DEBUG_FUNCTION_NAME(("iModemRecvData"));

    BG_CHK(pTG->Class1Modem.ModemMode == FRM);
    BG_CHK(lpb && cbMax && lpcbRecv);
    BG_CHK(!pTG->Class1Modem.fRecvSWFraming);

    startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
    // 4th arg must be FALSE for Class1
    *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv), FALSE, &swEOF);
    if(swEOF == -1)
    {
        // we got a DLE-ETX _not_ followed by OK or NO CARRIER. So now
        // we have to decide whether to (a) declare end of page (swEOF=1)
        // or (b) ignore it & assume page continues on (swEOF=0).
        //
        // The problem is that some modems produce spurious EOL during a page
        // I believe this happens due a momentary loss of carrier that they
        // recover from. For example IFAX sending to the ATI 19200. In those
        // cases we want to do (b). The opposite problem is that we'll run
        // into a modem whose normal response is other than OK or NO CARRIER.
        // Then we want to do (a) because otherwise we'll _never_ work with
        // that modem.
        //
        // So we have to either do (a) always, or have an INI setting that
        // can force (a), which could be set thru the AWMODEM.INF file. But
        // we also want to do (b) if possible because otehrwise we'll not be
        // able to recieve from weak or flaky modems or machines or whatever
        //
        // Snowball does (b). I believe best soln is an INI setting, with (b)
        // as default

        // option (a)
        // ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Assuming END OF PAGE!!!\r\n"));
        // swEOF = 1;

        // option (b)
        DebugPrintEx(DEBUG_WRN,"Got arbitrary DLE-ETX. Ignoring");
        swEOF = 0;
    }
    BG_CHK(swEOF == 0 || swEOF == 1 || swEOF == -2 || swEOF == -3);

    switch(swEOF)
    {
    case 1:         uRet = RECV_EOF; 
                    break;
    case 0:         return RECV_OK;
    default:        BG_CHK(FALSE);  // fall through
    case -2:        uRet = RECV_ERROR; 
                    break;
    case -3:        uRet = RECV_TIMEOUT; 
                    break;
    }

    EndMode(pTG);
    return uRet;
}

const static BYTE LFCRETXDLE[4] = { LF, CR, ETX, DLE };
#define MUNGECRC(crc) MAKEWORD(LOBYTE(crc),(HIBYTE(crc)<<2)|(LOBYTE(crc)>>6))

USHORT iModemRecvFrame
(
    PThrdGlbl pTG, 
    LPB lpb, 
    USHORT cbMax, 
    ULONG ulTimeout, 
    USHORT far* lpcbRecv
)
{
    SWORD swRead, swRet;
    USHORT i;
    BOOL fRestarted=0;
    USHORT uRet;
    BOOL fGotGoodCRC = 0;   // see comment-block below

    DEBUG_FUNCTION_NAME(_T("iModemRecvFrame"));
    /** Sometimes modems give use ERROR even when thr frame is good.
            Happens a lot from Thought to PP144MT on CFR. So we check
            the CRC. If the CRc was good and everything else looks good
            _except_ the "ERROR" response from teh modem then return
            RECV_OK, not RECV_BADFRAME.
            This should fix BUG#1218
    **/

    BG_CHK(lpb && cbMax && lpcbRecv);
restart:
    *lpcbRecv=0;
    if(pTG->Class1Modem.ModemMode!= FRH)
    {
#ifdef USR_HACK
        swRet = iModemFRHorM(pTG, ulTimeout);
#else // !USR_HACK
        swRet=iModemNoPauseDialog2(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszNOCARRIER);
#endif // !USR_HACK
        if(swRet==2||swRet==3)
        {
            DebugPrintEx(DEBUG_MSG,"Got NO CARRIER from FRH=3");
            EndMode(pTG);
            return RECV_EOF;
        }
        else if(swRet != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Can't get CONNECT from FRH=3, got %d",swRet);
            EndMode(pTG);
            return RECV_TIMEOUT;    // may not need this, since we never got flags??
            // actually we dont know what the heck we got!!
        }
    }

    pTG->Class1Modem.fRecvNotStarted = FALSE;    // fNoFlags = FALSE;

    /*** Got CONNECT (i.e. flags). Now try to get a frame ***/

    /****************************************************************
     * Using 3 secs here is a misinterpretation of the T30 CommandReceived?
     * flowchart. WE want to wait here until we get something or until T2
     * or T4 timeout. It would have been best if we started T2 ot T4 on
     * entry into the search routine (t30.c), but starting it here is good
     * enough.
     * Using this 3secs timeout fails when Genoa simulates a bad frame
     * because Zoom PKT modem gives us a whole raft of bad frames for one
     * bad PPS-EOP and then gives a CONNECT that we timeout below exactly
     * as the sender's T4 timeout expires and he re-sends the PPS-EOP
     * so we miss all of them.
     * Alternately, we could timeout here on 2sec & retry. But that's risky
     * If less than 2sec then we'll timeout on modems that give connect
     * first flag, then 2sec elapse before CR-LF (1sec preamble & 1sec for
     * long frames, e.g. PPR!)
     ****************************************************************/

    // #define TIMEOUT_3SECS        3000L
    // startTimeOut(&(pTG->Class1Modem.toRecv), TIMEOUT_3SECS);

    startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
    swRead = FComFilterReadLine(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv));

    pTG->Class1Modem.ModemMode = COMMAND;
    // may change this to FRH if we get CONNECT later.
    // but set it here just in case we short circuit out due to errors

    if(swRead<=0)
    {
        // Timeout
        DebugPrintEx(DEBUG_WRN,"Can't get frame after connect. Got-->%d",(WORD)-swRead);
        D_HexPrint(lpb, (WORD)-swRead);
        EndMode(pTG);
        *lpcbRecv = -swRead;
        return RECV_ERROR;              // goto error;        
    }

    PSSLogEntryHex(PSS_MSG, 2, lpb, swRead, "recv:     HDLC frame, %d bytes,", swRead);

    if (pTG->fLineTooLongWasIgnored)
    {
        // the following case is dealt with here:
        // we get an HDLC frame which is longer than 132 bytes, a bad frame.
        // the problem is that we might have skipped it and read the 'ERROR' 
        // after it as the actual data.
        // since no HDLC frame can be that long, let's return an error.
        // it's important NOT to ask the modem for a response here
        // we might have already read it.
        DebugPrintEx(DEBUG_WRN,"the received frame was too long, BAD FRAME!", swRead);
        (*lpcbRecv) = 0;
        uRet = RECV_BADFRAME;
        return uRet;
    }

    if (swRead<10)
    {
        D_HexPrint(lpb, swRead);
    }

    for(i=0, swRead--; i<4 && swRead>=0; i++, swRead--)
    {
        if(lpb[swRead] != LFCRETXDLE[i])
                break;
    }
    // exits when swRead is pointing to last non-noise char
    // or swRead == -1
    // incr by 1 to give actual non-noise data size.
    // (size = ptr to last byte + 1!)
    swRead++;


    // Hack for AT&T AK144 modem that doesn't send us the CRC
    // only lop off last 2 bytes IFF the frame is >= 5 bytes long
    // that will leave us at least the FF 03/13 FCF
    // if(i==4 && swRead>=2)        // i.e. found all of DLE-ETX_CR-LF

    // 09/25/95 This code was changed to never lop of the CRC.
    // All of the routines except NSxtoBC can figure out the correct length,
    // and that way if the modem doesn't pass on the CRC, we no longer
    // lop off the data.
    // NSxtoBC has been changed to expect the CRC.

    // we really want this CRC-checking in the MDDI case too
    if(i==4)// i.e. found all of DLE-ETX_CR-LF
    {
        // Determine if the frame has the CRC or not..
        // (AT&T and NEC modems don't have them)
        if (pTG->Class1Modem.eRecvFCS != RECV_FCS_NO)
        {
            if (swRead > 2)
            {
                WORD wCRCgot = *(UNALIGNED WORD FAR*)(lpb+swRead-2); // +++alignment
                WORD wCRCcalc;

                // Elliot bug 1811: TI PCMCIA modem TI1411 sends control byte twice
                // instead of address (0xff) followed by control.
                // So we correct for that here...
                if  (lpb[0]==lpb[1] && (*lpb==0x3 || *lpb==0x13))
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "V.21 w/ wrong address:%04x."
                                    " Zapping 1st byte with 0xff.",
                                    (unsigned)*lpb);
                    *lpb = 0xff;
                }

                wCRCcalc = CalcCRC(pTG, lpb, (USHORT) (swRead-2));
                if  (wCRCgot==wCRCcalc)
                {
                    fGotGoodCRC = TRUE;
                }
                else
                {
                        DebugPrintEx(   DEBUG_WRN,
                                        "V.21 CRC mismatch. Got 0x%04x."
                                        " Want 0x%04x",
                                        (unsigned) wCRCgot, 
                                        (unsigned) wCRCcalc);
                        // MC1411, MH9611 hack...
                        if (wCRCgot == MUNGECRC(wCRCcalc))
                        {
                            DebugPrintEx(   DEBUG_WRN,
                                            "mutant V.21 CRC:%04x",
                                            MUNGECRC(wCRCcalc));
                            fGotGoodCRC = TRUE;
                        }
// Elliot bug 2659: PP PM288MT II V.34 adds a flag (0x7e) to the END
// Of every V.21 flag it receives! So we check for this special case.
                        else if (swRead>3 && *(lpb+swRead-1)==0x7e)
                        {
                            DebugPrintEx(DEBUG_WRN,"Last byte == 0x7e");
                            wCRCgot = *(UNALIGNED WORD FAR*)(lpb+swRead-3);
                            wCRCcalc = CalcCRC(pTG, lpb, (USHORT) (swRead-3));
                            DebugPrintEx(   DEBUG_WRN,
                                            "Final flag? New Calc:%04x;Got=%04x",
                                            (unsigned) wCRCcalc,
                                            (unsigned) wCRCgot);
                                if (wCRCgot==wCRCcalc)
                                {
                                    swRead--;
                                    fGotGoodCRC = TRUE;
                                }
                        }
                        else if (pTG->Class1Modem.eRecvFCS == RECV_FCS_NOCHK)
                        {
                            DebugPrintEx(   DEBUG_WRN,
                                            "ASSUMING BAD V.21 CRC");
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_WRN,"no/bad V.21 CRC");
                        }
                    }
                }
            }

            uRet = RECV_OK;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"Frame doesn't end in dle-etx-cr-lf");
        // leave tast two bytes in. We don't *know* it's a CRC, since
        // frame ending was non-standard
        uRet = RECV_BADFRAME;
    }
    *lpcbRecv = swRead;

    // check if it is the NULL frame (i.e. DLE-ETX-CR-LF) first.
    // (check is: swRead==0 and uRet==RECV_OK (see above))
    // if so AND if we get OK or CONNECT or ERROR below then ignore
    // it completely. The Thought modem and the PP144MT generate
    // this idiotic situation! Keep a flag to avoid a possible
    // endless loop

    // broaden this so that we Restart on either a dle-etx-cr-lf
    // NULL frame or a simple cr-lf NULL frame. But then we need
    // to return an ERROR (not BADFRAME) after restarting once,
    // otheriwse there is an infinite loop with T30 calling us
    // again and again (see bug#834)

    // chnage yet again. This takes too long, and were trying to tackle
    // a specific bug (the PP144MT) bug here, so let's retsrat only
    // on dle-etx-cr-lf (not just cr-lf), and in teh latter case
    // return a response according to what we get


    BG_CHK(uRet==RECV_OK || uRet==RECV_BADFRAME);

    /*** Got Frame. Now try to get OK or ERROR. Timeout=0! ***/

    switch(swRet = iModemResp4(pTG,0, cbszOK, cbszCONNECT, cbszNOCARRIER, cbszERROR))
    {
    case 2:         pTG->Class1Modem.ModemMode = FRH;
                    // fall through and do exactly like OK!!
    case 1: // ModemMode already == COMMAND
                    if(swRead<=0 && uRet==RECV_OK && !fRestarted)
                    {
                        DebugPrintEx(DEBUG_WRN,"Got %d after frame. RESTARTING", swRet);
                        fRestarted = 1;
                        goto restart;
                    }
                    //uRet already set
                    break;

    case 3:         // NO CARRIER. If got null-frame or no frame return
                    // RECV_EOF. Otherwise if got OK frame then return RECV_OK
                    // and return frame as usual. Next time around it'll get a
                    // NO CARRIER again (hopefully) or timeout. On a bad frame
                    // we can return RECV_EOF, but this will get into trouble if
                    // the recv is not actually done. Or return BADFRAME, and hope
                    // for a NO CARRIER again next time. But next time we may get a
                    // timeout. ModemMode is always set to COMMAND (already)
                    DebugPrintEx(   DEBUG_WRN,
                                    "Got NO CARRIER after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    if(swRead <= 0)
                            uRet = RECV_EOF;
                    // else uRet is already BADFRAME or OK
                    break;

                    // this is bad!!
                    // alternately:
                    // if(swRead<=0 || uRet==RECV_BADFRAME)
                    // {
                    //              uRet = RECV_EOF;
                    //              *lpcbRecv = 0;          // must return 0 bytes with RECV_EOF
                    // }

    case 4: // ERROR
                    if(swRead<=0)
                    {
                        // got no frame
                        if(uRet==RECV_OK && !fRestarted)
                        {
                            // if we got dle-etx-cr-lf for first time
                            DebugPrintEx(   DEBUG_WRN,
                                            "Got ERROR after frame. RESTARTING");
                            fRestarted = 1;
#ifdef USR_HACK
                            TwiddleThumbs(RECVMODEPAUSE);
#endif //USR_HACK
                            goto restart;
                        }
                        else
                        {
                            uRet = RECV_ERROR;
                        }
                    }
                    else
                    {
                        // if everything was OK until we got the "ERROR" response from
                        // the modem and we got a good CRC then treat it as "OK"
                        // This should fix BUG#1218
                        if(uRet==RECV_OK && fGotGoodCRC)
                        {
                            uRet = RECV_OK;
                        }
                        else
                        {
                            uRet = RECV_BADFRAME;
                        }
                    }

                    DebugPrintEx(   DEBUG_WRN,
                                    "Got ERROR after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    break;

    case 0: // timeout
                    DebugPrintEx(   DEBUG_WRN,
                                    "Got TIMEOUT after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    // if everything was OK until we got the timeout from
                    // the modem and we got a good CRC then treat it as "OK"
                    // This should fix BUG#1218
                    if(uRet==RECV_OK && fGotGoodCRC)
                    {
                        uRet = RECV_OK;
                    }
                    else
                    {
                        uRet = RECV_BADFRAME;
                    }
                    break;
    }
    return uRet;
}

USHORT ModemRecvMem(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("ModemRecvMem"));

    BG_CHK(pTG->Class1Modem.CurMod);
    BG_CHK(lpb && cbMax && lpcbRecv);
    DebugPrintEx(   DEBUG_MSG,
                    "lpb=%08lx cbMax=%d ulTimeout=%ld", 
                    lpb, 
                    cbMax, 
                    ulTimeout);

    if(pTG->Class1Modem.DriverMode != RECV)
    {
        BG_CHK(FALSE);
        return RECV_ERROR;      // see bug#1492
    }
    *lpcbRecv=0;

    if(pTG->Class1Modem.fRecvSWFraming)
    {
        uRet = SWFramingRecvFrame(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
    }
    else if(pTG->Class1Modem.fHDLC)
    {
        uRet = iModemRecvFrame(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
    }
    else
    {
        uRet = iModemRecvData(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
    }

    DebugPrintEx(   DEBUG_MSG,
                    "lpbf=%08lx uCount=%d uRet=%d", 
                    lpb, 
                    *lpcbRecv, 
                    uRet);
    return uRet;
}


#ifdef USR_HACK
USHORT iModemFRHorM(PThrdGlbl pTG, ULONG ulTimeout)
{
    ULONG   ulBefore, ulAfter;
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("iModemFRHorM"));
retry:

    ulBefore=GetTickCount();

    // Don't look for NO CARRIER. Want it to retry until FRM timeout on NO CARRIER
    // ----This is changed. See below----
    uRet = iModemNoPauseDialog3(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR, cbszNOCARRIER);
    // uRet = iModemNoPauseDialog2(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR);
    ulAfter=GetTickCount();

    if(uRet==2 || uRet==3)  // uRet==FCERROR or uRet==NOCARRIER
    {
        if( (ulAfter <= ulBefore) ||    // wraparound or 0 time elapsed (timer broke)
                (ulTimeout < ((ulAfter-ulBefore) + MINRECVMODETIMEOUT)))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Giving up on RecvMode. uRet=%d ulTimeout=%ld", 
                            uRet, 
                            ulTimeout);
        }
        else
        {
            ulTimeout -= (ulAfter-ulBefore);

            // need this pause for NO CARRIER for USR modems. See bug#1516
            // for the RC229DP, dunno if it's reqd because I dunno why theyre
            // giving the FCERROR. Don't want to miss the carrier so currently
            // don't pause. (Maybe we can achieve same effect by simply taking
            // FCERROR out of the response list above--but that won't work for
            // NOCARRIER because we _need_ teh pause. iiModemDialog is too fast)
            if(uRet == 3)
                TwiddleThumbs(RECVMODEPAUSE);

            BG_CHK(ulTimeout >= MINRECVMODETIMEOUT);

            goto retry;
        }
    }

    return uRet;
}
#endif // USR_HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\fcomint.h ===
/***************************************************************************
        Name      :     FCOMINt.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define WRITEQUANTUM    (pTG->Comm.cbOutSize / 8)            // totally arbitrary

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03





#define FComGetError(pTG)                                                                                                          \
        { GetCommErrorNT ( pTG, (HANDLE) pTG->Comm.nCid, &pTG->Comm.CommErr, &(pTG->Comm.comstat));                    \
          if(pTG->Comm.CommErr) D_GotError(pTG, pTG->Comm.nCid, pTG->Comm.CommErr, &(pTG->Comm.comstat));\
                iModemSetError(pTG, MODEMERR_COMPORT, 0, 0); }

#ifdef WIN32 // WIN32 Overlapped I/O internal routines...
BOOL            ov_init(PThrdGlbl pTG);
BOOL            ov_deinit(PThrdGlbl pTG);
OVREC *         ov_get(PThrdGlbl pTG);
BOOL            ov_write(PThrdGlbl  pTG, OVREC *lpovr, LPDWORD lpdwcbWrote);
BOOL            ov_drain(PThrdGlbl pTG, BOOL fLongTO);
BOOL            ov_unget(PThrdGlbl pTG, OVREC *lpovr);
BOOL            iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO);
#endif // WIN32

        BOOL FComGetSettings(PThrdGlbl pTG, LPFCOMSETTINGS);
        BOOL FComSetSettings(PThrdGlbl pTG, LPFCOMSETTINGS);
// nothing
#define iModemSetError(pTG, a,b,c)

#ifdef WIN32
#       define MONINBASE
#       define MONOUTBASE
#       define MONINOUTBASE
#else
#       define MONINBASE        __based(__segname("_MONIN"))
#       define MONOUTBASE       __based(__segname("_MONOUT"))
#       define MONINOUTBASE     __based(__segname("_MONINOUT"))
#endif





/****************** begin prototypes from filter.c *****************/
/****************** end of prototypes from filter.c *****************/


/****************** begin prototypes from ncuparms.c *****************/
void iNCUParamsReset(PThrdGlbl pTG);
void FComInitGlobals(PThrdGlbl pTG);
/***************** end of prototypes from ncuparms.c *****************/

#ifdef DEBUG
# ifndef WIN32
#       define SLIPMULT         2
#       define SLIPDIV          2
# else
#       define SLIPMULT         1
#       define SLIPDIV          4
# endif
#       define BEFORESLEEP       DWORD t1, t2; t1=GetTickCount();
#       define AFTERSLEEP(x) t2=GetTickCount();                         \
                if((t2-t1) > (((x)*SLIPMULT)+((x)/SLIPDIV)))    \
                        DEBUGMSG(1, ("!!!SLEPT %ld. Wanted only %d!!!\r\n", (t2-t1), (x)));
#else
#       define BEFORESLEEP
#       define AFTERSLEEP(arg)
#endif

////////// Variables controlling Sleep ///////////
//
// Comm.fBG -- used only in WFW, because can't call DllSleep in FG!
// Comm.bDontYield -- enabled during T30 "critical" sections. In non-premptive
//                                              systems this should disable sleeping completely
//
//////////////////////////////////////////////////

// ACTIVESLICE defined in mysched.h
#define IDLESLICE       500




#if defined(WIN32) && defined(THREAD)
#       define MySleep(x)                                                                                                       \
                {BG_CHK(x);                                                                                                             \
                { BEFORESLEEP; Sleep(pTG->Comm.bDontYield?0:(x)); AFTERSLEEP(x); }}
// Note. Until 12/9/94, we used to call Sleep(1) if bDontYield as in :
//      if (Comm.bDontYield) { BEFORESLEEP; Sleep(1); AFTERSLEEP(x); }
#endif //WIN32 && THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\fdebug.h ===
/***************************************************************************
 Name     :     FDEBUG.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/****************** begin prototypes from debug.c *****************/
void InitCommErrCount(PThrdGlbl pTG);
extern void   far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs);
extern void   far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid);
extern void   far D_HexPrint(LPB b1, UWORD incnt);

#ifdef DEBUG
        void D_ChkMsg(LPSTR func, LPMSG lpmsg, UWORD wTimer, UWORD errevents, UWORD expected);
        void D_PrintIE(int err);        
        void D_PrintCE(int err);
        void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs);
        void D_PrintEvent(UWORD uwEvent);
        void D_FComCheck(PThrdGlbl pTG, LONG_PTR nCid);
        void D_FComDumpFlush(PThrdGlbl pTG, int nCid, int queue);
        void D_SafePrint(PThrdGlbl pTG, LPB b1, UWORD incnt);
        void D_PrintFrame(LPB npb, UWORD cb);
#else
#       define D_ChkMsg(f, l, t, er, ex)        {}
#       define D_PrintIE(err)                           {}
#       define D_PrintCE(err)                           {}
#       define D_PrintCOMSTAT(pTG, lpcs)                     {}
#       define D_PrintEvent(uwEvent)            {}
// #    define D_GotError(nCid, err, lpcs)      {}
#       define D_FComCheck(pTG, nCid)                        {}
// #    define D_FComPrint(nCid)                        {}
#       define D_FComDumpFlush(pTG, nCid, queue)     {}
#       define D_SafePrint(PTG, b1, incnt)           {}
// #    define D_HexPrint(b1, incnt)            {}
#       define D_PrintFrame(npb, cb)            {}
#endif
/***************** end of prototypes from debug.c *****************/



#ifndef MON3
#       define  PUTEVENT(wFlags, ID, SubID, dw0, dw1, lpsz) 0
#ifdef MON


#       define MONBUFSIZE       0x00010000L             // 65536 decimal

/****
#       define MONBUFSIZE       0x00004000L             // 16384 decimal
#       define CHKMONMASK       0x00003FFFL             // want it aligned to multiple of it's size
#       define WRAPMONMASK      (~(MONBUFSIZE)) // zap the 15th bit
****/
        extern void InitMonBufs(PThrdGlbl pTG);
        extern void PutMonBufs(PThrdGlbl pTG);
        extern void FreeMonBufs(PThrdGlbl pTG);

#ifdef MON2
#       define INMON(pTG, lpb, cb)   { lpbCurrIn = WrapCopy(pTG,lpbCurrIn,lpb,cb, lpbMonIn);             \
                                                          lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#       define OUTMON(pTG, lpb, cb)  { lpbCurrOut = WrapCopy(pTG,lpbCurrOut,lpb,cb, lpbMonOut);  \
                                                          lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#else //MON2
#       define INMON(pTG, lpb, cb)   { lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#       define OUTMON(pTG, lpb, cb)  { lpbCurrInOut = WrapCopy(pTG,lpbCurrInOut,lpb,cb, lpbMonInOut); }
#endif //MON2

        extern LPBYTE   lpbCurrIn, lpbCurrOut, lpbCurrInOut;
        extern LPB              WrapCopy(PThrdGlbl pTG, LPB lpbDest, LPB lpbSrc, UWORD cbSrc, LPB lpbStart);
#else
#       define InitMonBufs()                            {}
#       define PutMonBufs()                                     {}
#       define FreeMonBufs()                            {}
#       define INMON(lpb, cb)   { }
#       define OUTMON(lpb, cb)  { }
#endif // MON
#endif //!MON3




#define SZMOD                   "FCom: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;
#endif

// #define ZONE_FRAMES          ((1L << 1) & dpCurSettings.ulZoneMask)
#define ZONE_FC                 ((1L << 2) & dpCurSettings.ulZoneMask)
#define ZONE_FC2                ((1L << 3) & dpCurSettings.ulZoneMask)
#define ZONE_FC3                ((1L << 4) & dpCurSettings.ulZoneMask)
#define ZONE_FC4                ((1L << 5) & dpCurSettings.ulZoneMask)
#define ZONE_MD                 ((1L << 6) & dpCurSettings.ulZoneMask)
#define ZONE_DIA                ((1L << 7) & dpCurSettings.ulZoneMask)

#define ZONE_FIL                ((1L << 9) & dpCurSettings.ulZoneMask)
#define ZONE_ID                 ((1L << 10) & dpCurSettings.ulZoneMask)
#define ZONE_ID2                        ((1L << 11) & dpCurSettings.ulZoneMask)

#define ZONE_DB                 ((1L << 12) & dpCurSettings.ulZoneMask)
#define ZONE_DB3                ((1L << 13) & dpCurSettings.ulZoneMask)
#define ZONE_TIMEOUT    ((1L << 14) & dpCurSettings.ulZoneMask)
#define ZONE_TO                 ((1L << 15) & dpCurSettings.ulZoneMask)

// #ifdef DEBUG
// #    define ST_FRAMES(x)     if(ZONE_FRAMES) { x; }
// #else
// #    define ST_FRAMES(x)     { }
// #endif



#define TRACE(m)                DEBUGMSG(1, m)

#define MODID                   MODID_MODEMDRV

#define FILEID_FCOM                     21
#define FILEID_FDEBUG           22
#define FILEID_FILTER           23
#define FILEID_IDENTIFY         24
#define FILEID_MODEM            25
#define FILEID_NCUPARMS         26
#define FILEID_TIMEOUTS         27
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\crc.c ===
/***************************************************************************
 Name     :     CRC.C
 Comment  :     HDLC encoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"



#include "decoder.h"
#include "debug.h"

#include "glbproto.h"

#define FILEID                  FILEID_CRC

WORD CODEBASED CRCTab[16] =
        {       0x0000, 0x1081, 0x2102, 0x3183,
                0x4204, 0x5285, 0x6306, 0x7387,
                0x8408, 0x9489, 0xa50a, 0xb58b,
                0xc60c, 0xd68d, 0xe70e, 0xf78f };







WORD SWECMEXP CalcCRC(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc)
{
    USHORT   wTempChar=0, j=0, wTempCRC=(USHORT)-1;
    USHORT SourceIndex;
    LPBYTE SourceAddress;

    DEBUG_FUNCTION_NAME(_T("CalcCRC"));

    SourceAddress = lpbSrc;

    for(SourceIndex = cbSrc;SourceIndex > 0; SourceIndex--) 
    {
        wTempChar = (USHORT) *SourceAddress++;
        j = (wTempCRC ^ wTempChar) & 0x0f;
        wTempCRC = (wTempCRC >> 4) ^ CRCTab[j];
        wTempChar >>= 4;
        j = (wTempCRC ^ wTempChar) & 0x0f;
        wTempCRC = (wTempCRC >> 4) ^ CRCTab[j];
    }

    wTempCRC = ~wTempCRC;
    return wTempCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\debug.h ===
#define	SZMOD			"Class1: "

#ifdef DEBUG
	extern DBGPARAM dpCurSettings;
#endif

#define ZONE_DDI		((1L << 0) & dpCurSettings.ulZoneMask)
#define ZONE_FRAMES		((1L << 1) & dpCurSettings.ulZoneMask)
#define ZONE_CLASS0		((1L << 4) & dpCurSettings.ulZoneMask)

#define ZONE_SWFRAME	((1L << 10) & dpCurSettings.ulZoneMask)
#define ZONE_SWFRAME2	((1L << 11) & dpCurSettings.ulZoneMask)


#ifdef DEBUG
#	define ST_FRAMES(x)	if(ZONE_FRAMES) { x; }
#else
#	define ST_FRAMES(x)	{ }
#endif

#define TRACE(m)	DEBUGMSG(1, m)

#define MODID		MODID_MODEMDRV

#define FILEID_DDI		1
#define FILEID_CRC		2
#define FILEID_DECODER	3
#define FILEID_ENCODER	4
#define FILEID_FRAMING	5
#define FILEID_IFDDI	6
#define FILEID_CLASS0	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\decoder.c ===
/***************************************************************************
 Name     :     DECODER.C
 Comment  :     HDLC decoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------

***************************************************************************/

#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1


#include "prep.h"


#include "decoder.h"
#include "debug.h"


#include "glbproto.h"



#define FILEID                  FILEID_DECODER

extern  BYTE CODEBASED DecLen[8][256], CODEBASED DecOut[8][256], CODEBASED DecWidth[8][256];





USHORT SWECMEXP HDLC_Decode
(
    PThrdGlbl pTG, 
    LPBYTE lpbSrc, 
    USHORT cbSrc, 
    LPBYTE lpbDst, 
    USHORT far* lpcbDst, 
    LPDECODESTATE lpState
)
{

   BYTE FlagAbort = lpState->flagabort != FALSE;

   BYTE StateLen = lpState->len;
   BYTE StateWidth = lpState->dec_width;
   USHORT SrcSize;
   BYTE InByte;
   LPBYTE CurrentSrc = lpbSrc;
   LPBYTE CurrentDst = lpbDst;
   USHORT ProcessWord = (USHORT) lpState->carry;      //carry-in at the start of each loop iteration
   BYTE TmpLen;
   USHORT ExitLoop = FALSE;


        // Processes input bytes until flag, abort or idle or cbSrc
        // Returns number of bytes written to lpbDst in *lpcbDst
        // Return value is number of bytes read
        // Returns reason in lpState->flagabort


   for (SrcSize = cbSrc;((SrcSize > 0) && !ExitLoop); SrcSize--) 
   {
      InByte = *CurrentSrc++;
      ProcessWord |=   (((USHORT) DecOut[StateLen][InByte]) << StateWidth);  //Processed Inbyte Leftshift width or carryin
      StateWidth += DecWidth[StateLen][InByte];
      TmpLen = DecLen[StateLen][InByte];
      if ( TmpLen < 8)  
      {                 //Normal Case
         StateLen = TmpLen;
         if (StateWidth >= 8) 
         {
            *CurrentDst++ = LOBYTE(ProcessWord);
            ProcessWord >>= 8;
            FlagAbort = 0;
            StateWidth -= 8;
         }
      }
      else 
      {                                     //GotFlagAbort
         ProcessWord = (USHORT) DecOut[StateLen][InByte];
         StateWidth = DecWidth[StateLen][InByte];
         StateLen = TmpLen & 0x3f;
         switch (TmpLen & 0xc0) 
         {
         case 0x40:
                    if (FlagAbort != ABORT) 
                    {
                       FlagAbort = ABORT;
                       ExitLoop = TRUE;
                    }
                    break;
         case 0x80:
                    if (StateWidth > 8) 
                    {
                        BG_CHK(FALSE);
                    }
                    else 
                    {
                       if (FlagAbort != FLAG) 
                       {
                          FlagAbort = FLAG;
                          ExitLoop = TRUE;
                       }
                    }
                    break;
         default:
                // only time 0x40 and 0x80 are together is when inlen=7 and inbyte=0x7E.
                    BG_CHK(FALSE);
            break;
         }
      }
   }

   lpState->carry = LOBYTE(ProcessWord);
   lpState->dec_width = StateWidth;
   lpState->len = StateLen;
   lpState->flagabort = FlagAbort;
   *lpcbDst = (USHORT)(CurrentDst - lpbDst);
   cbSrc = (USHORT)(CurrentSrc - lpbSrc);



    return cbSrc;

}


BYTE CODEBASED DecLen[8][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 130,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 66,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 131, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 3
{0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64,
 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 128, 64,
 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65,
 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65, 1, 1, 1, 1, 1, 1, 1, 129, 1, 1, 1, 1, 1, 1, 1, 65,
 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 66, 2, 2, 2, 2, 2, 2, 2, 130, 2, 2, 2, 2, 2, 2, 2, 66,
 3, 3, 3, 3, 3, 3, 3, 131, 3, 3, 3, 3, 3, 3, 3, 67, 4, 4, 4, 4, 4, 4, 4, 132, 5, 5, 5, 5, 6, 6, 7, 71 },
// Input Len = 4
{0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64,
 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 128, 64,
 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65,
 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65, 1, 1, 1, 129, 1, 1, 1, 65,
 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66, 2, 2, 2, 130, 2, 2, 2, 66,
 3, 3, 3, 131, 3, 3, 3, 67, 3, 3, 3, 131, 3, 3, 3, 67, 4, 4, 4, 132, 4, 4, 4, 68, 5, 5, 5, 133, 6, 6, 7, 71 },
// Input Len = 5
{0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64,
 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 0, 64, 0, 128, 128, 64,
 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65,
 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65, 1, 129, 1, 65,
 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66, 2, 130, 2, 66,
 3, 131, 3, 67, 3, 131, 3, 67, 3, 131, 3, 67, 3, 131, 3, 67, 4, 132, 4, 68, 4, 132, 4, 68, 5, 133, 5, 69, 6, 134, 7, 71 },
// Input Len = 6
{128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64, 128, 64,
 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65,
 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65, 129, 65,
 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66, 130, 66,
 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 131, 67, 132, 68, 132, 68, 132, 68, 132, 68, 133, 69, 133, 69, 134, 70, 135, 71 },
// Input Len = 7
{64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 71, 71 }
}; // Len


BYTE CODEBASED DecOut[8][256] = {
// Input Len = 0
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x3f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x5f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x01,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x7f,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 1
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x1f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x2f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x01,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x3f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x4f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x02,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0x5f,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0x6f,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x03,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x7f,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 2
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x00,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x0f, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x17, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x01,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x1f, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x27, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x02,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x2f, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x02,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x37, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x03,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x3f, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x47, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x04,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x4f, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x04,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0x57, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0x05,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0x5f, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0x67, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0x06,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0x6f, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x06,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0x77, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x07,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x7f, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 3
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x08, 0x09, 0x0a, 0x07, 0x0c, 0x0d, 0x0e, 0x00,
 0x10, 0x11, 0x12, 0x0b, 0x14, 0x15, 0x16, 0x01, 0x18, 0x19, 0x1a, 0x0f, 0x1c, 0x1d, 0x1e, 0x00,
 0x20, 0x21, 0x22, 0x13, 0x24, 0x25, 0x26, 0x02, 0x28, 0x29, 0x2a, 0x17, 0x2c, 0x2d, 0x2e, 0x02,
 0x30, 0x31, 0x32, 0x1b, 0x34, 0x35, 0x36, 0x03, 0x38, 0x39, 0x3a, 0x1f, 0x3c, 0x3d, 0x3e, 0x00,
 0x40, 0x41, 0x42, 0x23, 0x44, 0x45, 0x46, 0x04, 0x48, 0x49, 0x4a, 0x27, 0x4c, 0x4d, 0x4e, 0x04,
 0x50, 0x51, 0x52, 0x2b, 0x54, 0x55, 0x56, 0x05, 0x58, 0x59, 0x5a, 0x2f, 0x5c, 0x5d, 0x5e, 0x02,
 0x60, 0x61, 0x62, 0x33, 0x64, 0x65, 0x66, 0x06, 0x68, 0x69, 0x6a, 0x37, 0x6c, 0x6d, 0x6e, 0x06,
 0x70, 0x71, 0x72, 0x3b, 0x74, 0x75, 0x76, 0x07, 0x78, 0x79, 0x7a, 0x3f, 0x7c, 0x7d, 0x00, 0x00,
 0x80, 0x81, 0x82, 0x43, 0x84, 0x85, 0x86, 0x08, 0x88, 0x89, 0x8a, 0x47, 0x8c, 0x8d, 0x8e, 0x08,
 0x90, 0x91, 0x92, 0x4b, 0x94, 0x95, 0x96, 0x09, 0x98, 0x99, 0x9a, 0x4f, 0x9c, 0x9d, 0x9e, 0x04,
 0xa0, 0xa1, 0xa2, 0x53, 0xa4, 0xa5, 0xa6, 0x0a, 0xa8, 0xa9, 0xaa, 0x57, 0xac, 0xad, 0xae, 0x0a,
 0xb0, 0xb1, 0xb2, 0x5b, 0xb4, 0xb5, 0xb6, 0x0b, 0xb8, 0xb9, 0xba, 0x5f, 0xbc, 0xbd, 0x7e, 0x02,
 0xc0, 0xc1, 0xc2, 0x63, 0xc4, 0xc5, 0xc6, 0x0c, 0xc8, 0xc9, 0xca, 0x67, 0xcc, 0xcd, 0xce, 0x0c,
 0xd0, 0xd1, 0xd2, 0x6b, 0xd4, 0xd5, 0xd6, 0x0d, 0xd8, 0xd9, 0xda, 0x6f, 0xdc, 0xdd, 0xde, 0x06,
 0xe0, 0xe1, 0xe2, 0x73, 0xe4, 0xe5, 0xe6, 0x0e, 0xe8, 0xe9, 0xea, 0x77, 0xec, 0xed, 0xee, 0x0e,
 0xf0, 0xf1, 0xf2, 0x7b, 0xf4, 0xf5, 0xf6, 0x0f, 0xf8, 0xf9, 0xfa, 0x7f, 0xfc, 0xfd, 0xfe, 0x00 },
// Input Len = 4
{0x00, 0x01, 0x02, 0x00, 0x04, 0x03, 0x06, 0x00, 0x08, 0x05, 0x0a, 0x01, 0x0c, 0x07, 0x0e, 0x00,
 0x10, 0x09, 0x12, 0x02, 0x14, 0x0b, 0x16, 0x02, 0x18, 0x0d, 0x1a, 0x03, 0x1c, 0x0f, 0x1e, 0x00,
 0x20, 0x11, 0x22, 0x04, 0x24, 0x13, 0x26, 0x04, 0x28, 0x15, 0x2a, 0x05, 0x2c, 0x17, 0x2e, 0x02,
 0x30, 0x19, 0x32, 0x06, 0x34, 0x1b, 0x36, 0x06, 0x38, 0x1d, 0x3a, 0x07, 0x3c, 0x1f, 0x3e, 0x00,
 0x40, 0x21, 0x42, 0x08, 0x44, 0x23, 0x46, 0x08, 0x48, 0x25, 0x4a, 0x09, 0x4c, 0x27, 0x4e, 0x04,
 0x50, 0x29, 0x52, 0x0a, 0x54, 0x2b, 0x56, 0x0a, 0x58, 0x2d, 0x5a, 0x0b, 0x5c, 0x2f, 0x5e, 0x02,
 0x60, 0x31, 0x62, 0x0c, 0x64, 0x33, 0x66, 0x0c, 0x68, 0x35, 0x6a, 0x0d, 0x6c, 0x37, 0x6e, 0x06,
 0x70, 0x39, 0x72, 0x0e, 0x74, 0x3b, 0x76, 0x0e, 0x78, 0x3d, 0x7a, 0x0f, 0x7c, 0x3f, 0x00, 0x00,
 0x80, 0x41, 0x82, 0x10, 0x84, 0x43, 0x86, 0x10, 0x88, 0x45, 0x8a, 0x11, 0x8c, 0x47, 0x8e, 0x08,
 0x90, 0x49, 0x92, 0x12, 0x94, 0x4b, 0x96, 0x12, 0x98, 0x4d, 0x9a, 0x13, 0x9c, 0x4f, 0x9e, 0x04,
 0xa0, 0x51, 0xa2, 0x14, 0xa4, 0x53, 0xa6, 0x14, 0xa8, 0x55, 0xaa, 0x15, 0xac, 0x57, 0xae, 0x0a,
 0xb0, 0x59, 0xb2, 0x16, 0xb4, 0x5b, 0xb6, 0x16, 0xb8, 0x5d, 0xba, 0x17, 0xbc, 0x5f, 0x7e, 0x02,
 0xc0, 0x61, 0xc2, 0x18, 0xc4, 0x63, 0xc6, 0x18, 0xc8, 0x65, 0xca, 0x19, 0xcc, 0x67, 0xce, 0x0c,
 0xd0, 0x69, 0xd2, 0x1a, 0xd4, 0x6b, 0xd6, 0x1a, 0xd8, 0x6d, 0xda, 0x1b, 0xdc, 0x6f, 0xde, 0x06,
 0xe0, 0x71, 0xe2, 0x1c, 0xe4, 0x73, 0xe6, 0x1c, 0xe8, 0x75, 0xea, 0x1d, 0xec, 0x77, 0xee, 0x0e,
 0xf0, 0x79, 0xf2, 0x1e, 0xf4, 0x7b, 0xf6, 0x1e, 0xf8, 0x7d, 0xfa, 0x1f, 0xfc, 0x7f, 0xfe, 0x00 },
// Input Len = 5
{0x00, 0x00, 0x01, 0x00, 0x02, 0x01, 0x03, 0x00, 0x04, 0x02, 0x05, 0x02, 0x06, 0x03, 0x07, 0x00,
 0x08, 0x04, 0x09, 0x04, 0x0a, 0x05, 0x0b, 0x02, 0x0c, 0x06, 0x0d, 0x06, 0x0e, 0x07, 0x0f, 0x00,
 0x10, 0x08, 0x11, 0x08, 0x12, 0x09, 0x13, 0x04, 0x14, 0x0a, 0x15, 0x0a, 0x16, 0x0b, 0x17, 0x02,
 0x18, 0x0c, 0x19, 0x0c, 0x1a, 0x0d, 0x1b, 0x06, 0x1c, 0x0e, 0x1d, 0x0e, 0x1e, 0x0f, 0x1f, 0x00,
 0x20, 0x10, 0x21, 0x10, 0x22, 0x11, 0x23, 0x08, 0x24, 0x12, 0x25, 0x12, 0x26, 0x13, 0x27, 0x04,
 0x28, 0x14, 0x29, 0x14, 0x2a, 0x15, 0x2b, 0x0a, 0x2c, 0x16, 0x2d, 0x16, 0x2e, 0x17, 0x2f, 0x02,
 0x30, 0x18, 0x31, 0x18, 0x32, 0x19, 0x33, 0x0c, 0x34, 0x1a, 0x35, 0x1a, 0x36, 0x1b, 0x37, 0x06,
 0x38, 0x1c, 0x39, 0x1c, 0x3a, 0x1d, 0x3b, 0x0e, 0x3c, 0x1e, 0x3d, 0x1e, 0x3e, 0x1f, 0x00, 0x00,
 0x40, 0x20, 0x41, 0x20, 0x42, 0x21, 0x43, 0x10, 0x44, 0x22, 0x45, 0x22, 0x46, 0x23, 0x47, 0x08,
 0x48, 0x24, 0x49, 0x24, 0x4a, 0x25, 0x4b, 0x12, 0x4c, 0x26, 0x4d, 0x26, 0x4e, 0x27, 0x4f, 0x04,
 0x50, 0x28, 0x51, 0x28, 0x52, 0x29, 0x53, 0x14, 0x54, 0x2a, 0x55, 0x2a, 0x56, 0x2b, 0x57, 0x0a,
 0x58, 0x2c, 0x59, 0x2c, 0x5a, 0x2d, 0x5b, 0x16, 0x5c, 0x2e, 0x5d, 0x2e, 0x5e, 0x2f, 0x3f, 0x02,
 0x60, 0x30, 0x61, 0x30, 0x62, 0x31, 0x63, 0x18, 0x64, 0x32, 0x65, 0x32, 0x66, 0x33, 0x67, 0x0c,
 0x68, 0x34, 0x69, 0x34, 0x6a, 0x35, 0x6b, 0x1a, 0x6c, 0x36, 0x6d, 0x36, 0x6e, 0x37, 0x6f, 0x06,
 0x70, 0x38, 0x71, 0x38, 0x72, 0x39, 0x73, 0x1c, 0x74, 0x3a, 0x75, 0x3a, 0x76, 0x3b, 0x77, 0x0e,
 0x78, 0x3c, 0x79, 0x3c, 0x7a, 0x3d, 0x7b, 0x1e, 0x7c, 0x3e, 0x7d, 0x3e, 0x7e, 0x3f, 0x7f, 0x00 },
// Input Len = 6
{0x00, 0x00, 0x01, 0x00, 0x02, 0x02, 0x03, 0x00, 0x04, 0x04, 0x05, 0x02, 0x06, 0x06, 0x07, 0x00,
 0x08, 0x08, 0x09, 0x04, 0x0a, 0x0a, 0x0b, 0x02, 0x0c, 0x0c, 0x0d, 0x06, 0x0e, 0x0e, 0x0f, 0x00,
 0x10, 0x10, 0x11, 0x08, 0x12, 0x12, 0x13, 0x04, 0x14, 0x14, 0x15, 0x0a, 0x16, 0x16, 0x17, 0x02,
 0x18, 0x18, 0x19, 0x0c, 0x1a, 0x1a, 0x1b, 0x06, 0x1c, 0x1c, 0x1d, 0x0e, 0x1e, 0x1e, 0x1f, 0x00,
 0x20, 0x20, 0x21, 0x10, 0x22, 0x22, 0x23, 0x08, 0x24, 0x24, 0x25, 0x12, 0x26, 0x26, 0x27, 0x04,
 0x28, 0x28, 0x29, 0x14, 0x2a, 0x2a, 0x2b, 0x0a, 0x2c, 0x2c, 0x2d, 0x16, 0x2e, 0x2e, 0x2f, 0x02,
 0x30, 0x30, 0x31, 0x18, 0x32, 0x32, 0x33, 0x0c, 0x34, 0x34, 0x35, 0x1a, 0x36, 0x36, 0x37, 0x06,
 0x38, 0x38, 0x39, 0x1c, 0x3a, 0x3a, 0x3b, 0x0e, 0x3c, 0x3c, 0x3d, 0x1e, 0x3e, 0x3e, 0x00, 0x00,
 0x40, 0x40, 0x41, 0x20, 0x42, 0x42, 0x43, 0x10, 0x44, 0x44, 0x45, 0x22, 0x46, 0x46, 0x47, 0x08,
 0x48, 0x48, 0x49, 0x24, 0x4a, 0x4a, 0x4b, 0x12, 0x4c, 0x4c, 0x4d, 0x26, 0x4e, 0x4e, 0x4f, 0x04,
 0x50, 0x50, 0x51, 0x28, 0x52, 0x52, 0x53, 0x14, 0x54, 0x54, 0x55, 0x2a, 0x56, 0x56, 0x57, 0x0a,
 0x58, 0x58, 0x59, 0x2c, 0x5a, 0x5a, 0x5b, 0x16, 0x5c, 0x5c, 0x5d, 0x2e, 0x5e, 0x5e, 0x3f, 0x02,
 0x60, 0x60, 0x61, 0x30, 0x62, 0x62, 0x63, 0x18, 0x64, 0x64, 0x65, 0x32, 0x66, 0x66, 0x67, 0x0c,
 0x68, 0x68, 0x69, 0x34, 0x6a, 0x6a, 0x6b, 0x1a, 0x6c, 0x6c, 0x6d, 0x36, 0x6e, 0x6e, 0x6f, 0x06,
 0x70, 0x70, 0x71, 0x38, 0x72, 0x72, 0x73, 0x1c, 0x74, 0x74, 0x75, 0x3a, 0x76, 0x76, 0x77, 0x0e,
 0x78, 0x78, 0x79, 0x3c, 0x7a, 0x7a, 0x7b, 0x1e, 0x7c, 0x7c, 0x7d, 0x3e, 0x7e, 0x7e, 0x7f, 0x00 },
// Input Len = 7
{0x00, 0x00, 0x02, 0x00, 0x04, 0x02, 0x06, 0x00, 0x08, 0x04, 0x0a, 0x02, 0x0c, 0x06, 0x0e, 0x00,
 0x10, 0x08, 0x12, 0x04, 0x14, 0x0a, 0x16, 0x02, 0x18, 0x0c, 0x1a, 0x06, 0x1c, 0x0e, 0x1e, 0x00,
 0x20, 0x10, 0x22, 0x08, 0x24, 0x12, 0x26, 0x04, 0x28, 0x14, 0x2a, 0x0a, 0x2c, 0x16, 0x2e, 0x02,
 0x30, 0x18, 0x32, 0x0c, 0x34, 0x1a, 0x36, 0x06, 0x38, 0x1c, 0x3a, 0x0e, 0x3c, 0x1e, 0x3e, 0x00,
 0x40, 0x20, 0x42, 0x10, 0x44, 0x22, 0x46, 0x08, 0x48, 0x24, 0x4a, 0x12, 0x4c, 0x26, 0x4e, 0x04,
 0x50, 0x28, 0x52, 0x14, 0x54, 0x2a, 0x56, 0x0a, 0x58, 0x2c, 0x5a, 0x16, 0x5c, 0x2e, 0x5e, 0x02,
 0x60, 0x30, 0x62, 0x18, 0x64, 0x32, 0x66, 0x0c, 0x68, 0x34, 0x6a, 0x1a, 0x6c, 0x36, 0x6e, 0x06,
 0x70, 0x38, 0x72, 0x1c, 0x74, 0x3a, 0x76, 0x0e, 0x78, 0x3c, 0x7a, 0x1e, 0x7c, 0x3e, 0x00, 0x00,
 0x80, 0x40, 0x82, 0x20, 0x84, 0x42, 0x86, 0x10, 0x88, 0x44, 0x8a, 0x22, 0x8c, 0x46, 0x8e, 0x08,
 0x90, 0x48, 0x92, 0x24, 0x94, 0x4a, 0x96, 0x12, 0x98, 0x4c, 0x9a, 0x26, 0x9c, 0x4e, 0x9e, 0x04,
 0xa0, 0x50, 0xa2, 0x28, 0xa4, 0x52, 0xa6, 0x14, 0xa8, 0x54, 0xaa, 0x2a, 0xac, 0x56, 0xae, 0x0a,
 0xb0, 0x58, 0xb2, 0x2c, 0xb4, 0x5a, 0xb6, 0x16, 0xb8, 0x5c, 0xba, 0x2e, 0xbc, 0x5e, 0x7e, 0x02,
 0xc0, 0x60, 0xc2, 0x30, 0xc4, 0x62, 0xc6, 0x18, 0xc8, 0x64, 0xca, 0x32, 0xcc, 0x66, 0xce, 0x0c,
 0xd0, 0x68, 0xd2, 0x34, 0xd4, 0x6a, 0xd6, 0x1a, 0xd8, 0x6c, 0xda, 0x36, 0xdc, 0x6e, 0xde, 0x06,
 0xe0, 0x70, 0xe2, 0x38, 0xe4, 0x72, 0xe6, 0x1c, 0xe8, 0x74, 0xea, 0x3a, 0xec, 0x76, 0xee, 0x0e,
 0xf0, 0x78, 0xf2, 0x3c, 0xf4, 0x7a, 0xf6, 0x1e, 0xf8, 0x7c, 0xfa, 0x3e, 0xfc, 0x7e, 0xfe, 0x00 }
}; // End of Squeeze


BYTE CODEBASED DecWidth[8][256] = {
// Input Len = 0
{8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 1
{8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 2
{8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 7, 7, 0, 1,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 7, 2,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3,
 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 0 },
// Input Len = 3
{8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 7, 2,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 7, 7, 0, 1,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 7, 2,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 3,
 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 4, 8, 8, 8, 7, 8, 8, 8, 0 },
// Input Len = 4
{8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 7, 2,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 7, 6, 0, 1,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 7, 2,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 3,
 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 4, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7, 8, 0 },
// Input Len = 5
{7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 6, 2,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 6, 5, 0, 1,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 6, 2,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 3,
 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 4, 7, 6, 7, 6, 7, 6, 7, 5, 7, 6, 7, 6, 7, 6, 7, 0 },
// Input Len = 6
{7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 6, 2,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 6, 6, 0, 1,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 6, 2,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 3,
 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 4, 7, 7, 7, 6, 7, 7, 7, 5, 7, 7, 7, 6, 7, 7, 7, 0 },
// Input Len = 7
{8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 7, 2,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 7, 6, 0, 1,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 7, 2,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 3,
 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 4, 8, 7, 8, 6, 8, 7, 8, 5, 8, 7, 8, 6, 8, 7, 8, 0 }
}; // width
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\encoder.c ===
/***************************************************************************
 Name     :     ENCODER.C
 Comment  :     HDLC encoding routines
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1


#include "prep.h"

#include "encoder.h"
#include "debug.h"


#include "glbproto.h"

#define FILEID                  FILEID_ENCODER

extern  BYTE CODEBASED EncLen[5][256], CODEBASED EncWidth[5][256];
extern  WORD CODEBASED EncOut[5][256];

USHORT SWECMEXP HDLC_Encode(PThrdGlbl pTG, LPBYTE lpbSrc, USHORT cbSrc, LPBYTE lpbDst, LPENCODESTATE lpState)
{
        // Processes all cbSrc input bytes
        // Returns number of bytes written to lpbDst

    USHORT  cbDst;

    BYTE StateLen = lpState->len;
    BYTE StateCarry = lpState->carry;
    BYTE StateWidth = lpState->enc_width;
    USHORT SrcSize;
    BYTE InByte;
    LPBYTE CurrentSrc = lpbSrc;
    LPBYTE CurrentDst = lpbDst;
    ULONG EncodeWord;                //must be ULONG because value can be up to 17 bits


   for (SrcSize = cbSrc; SrcSize > 0; SrcSize--) 
   {
      InByte = *CurrentSrc++;
      EncodeWord = (((ULONG)EncOut[StateLen][InByte]) << StateWidth) | StateCarry;
      *CurrentDst++ = LOBYTE(EncodeWord);
      EncodeWord >>= 8;
      StateWidth += EncWidth[StateLen][InByte];
      StateLen = EncLen[StateLen][InByte];
      if (StateWidth < 8) 
      {
         StateCarry = LOBYTE(EncodeWord);
      }
      else 
      {
         *CurrentDst++ = LOBYTE(EncodeWord);
         StateCarry = HIBYTE(EncodeWord);
         StateWidth -= 8;
      }
   }

   lpState->carry = StateCarry;
   lpState->enc_width = StateWidth;
   lpState->len = StateLen;
   cbDst = (USHORT)(CurrentDst - lpbDst);





    return cbDst;
}


BYTE RotFlag[8] = { 0x7e, 0xfc, 0xf9, 0xf3, 0xe7, 0xcf, 0x9f, 0x3f };
BYTE LowBits[8] = { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f };


USHORT SWECMEXP HDLC_AddFlags(PThrdGlbl pTG, LPBYTE lpbDst, USHORT cbFlags, LPENCODESTATE lpState)
{
    USHORT i;

    BG_CHK(lpState->enc_width < 8);

    *lpbDst         =  lpState->carry;
    *lpbDst++       |= (0x7E << lpState->enc_width);

    lpState->len = 0;
    lpState->carry = RotFlag[lpState->enc_width];
    // lpState->enc_width   is unchanged

    for(i=0; i<cbFlags-1; i++)
    {
        *lpbDst++ = lpState->carry;
    }
    // zap out high (8-width) bits of carry
    lpState->carry &= LowBits[lpState->enc_width];

    return cbFlags;
}

BYTE CODEBASED EncLen[5][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 3 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 4 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 0 },
// Input Len = 3
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 1 },
// Input Len = 4
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 1, 1, 2, 2 }

}; // Len


BYTE CODEBASED EncWidth[5][256] = {
// Input Len = 0
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 },
// Input Len = 1
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 },
// Input Len = 2
{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2 },
// Input Len = 3
{0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 2,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 2 },
// Input Len = 4
{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 2, 1, 2, 1, 2 }

}; // W2

WORD CODEBASED EncOut[5][256] = {
// Input Len = 0
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x01f,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x02f,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x037,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x05f,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x047,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x04f,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x057,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x09f,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x067,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x06f,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x077,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0df,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x087,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x08f,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x097,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x11f,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x0a7,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x0af,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x0b7,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x15f,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x0c7,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x0cf,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x0d7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x19f,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x0e7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x0ef,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x0f7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1df },
// Input Len = 1
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x02f,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x04f,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x037,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x06f,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x047,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x08f,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x057,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x0af,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x067,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x0cf,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x077,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0ef,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x087,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x10f,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x097,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x12f,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x0a7,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x14f,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x0b7,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x16f,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x0c7,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x18f,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x0d7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x1af,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x0e7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x1cf,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x0f7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1ef },
// Input Len = 2
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,
 0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x017,
 0x010, 0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x027,
 0x018, 0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x037,
 0x020, 0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x047,
 0x028, 0x029, 0x02a, 0x02b, 0x02c, 0x02d, 0x02e, 0x057,
 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x067,
 0x038, 0x039, 0x03a, 0x03b, 0x03c, 0x03d, 0x03e, 0x077,
 0x040, 0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x087,
 0x048, 0x049, 0x04a, 0x04b, 0x04c, 0x04d, 0x04e, 0x097,
 0x050, 0x051, 0x052, 0x053, 0x054, 0x055, 0x056, 0x0a7,
 0x058, 0x059, 0x05a, 0x05b, 0x05c, 0x05d, 0x05e, 0x0b7,
 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066, 0x0c7,
 0x068, 0x069, 0x06a, 0x06b, 0x06c, 0x06d, 0x06e, 0x0d7,
 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x0e7,
 0x078, 0x079, 0x07a, 0x07b, 0x07c, 0x07d, 0x0be, 0x0f7,
 0x080, 0x081, 0x082, 0x083, 0x084, 0x085, 0x086, 0x107,
 0x088, 0x089, 0x08a, 0x08b, 0x08c, 0x08d, 0x08e, 0x117,
 0x090, 0x091, 0x092, 0x093, 0x094, 0x095, 0x096, 0x127,
 0x098, 0x099, 0x09a, 0x09b, 0x09c, 0x09d, 0x09e, 0x137,
 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x147,
 0x0a8, 0x0a9, 0x0aa, 0x0ab, 0x0ac, 0x0ad, 0x0ae, 0x157,
 0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x167,
 0x0b8, 0x0b9, 0x0ba, 0x0bb, 0x0bc, 0x0bd, 0x13e, 0x177,
 0x0c0, 0x0c1, 0x0c2, 0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x187,
 0x0c8, 0x0c9, 0x0ca, 0x0cb, 0x0cc, 0x0cd, 0x0ce, 0x197,
 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5, 0x0d6, 0x1a7,
 0x0d8, 0x0d9, 0x0da, 0x0db, 0x0dc, 0x0dd, 0x0de, 0x1b7,
 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x1c7,
 0x0e8, 0x0e9, 0x0ea, 0x0eb, 0x0ec, 0x0ed, 0x0ee, 0x1d7,
 0x0f0, 0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x1e7,
 0x0f8, 0x0f9, 0x0fa, 0x0fb, 0x17c, 0x17d, 0x1be, 0x1f7 },
// Input Len = 3
{0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x00b,
 0x008, 0x009, 0x00a, 0x013, 0x00c, 0x00d, 0x00e, 0x01b,
 0x010, 0x011, 0x012, 0x023, 0x014, 0x015, 0x016, 0x02b,
 0x018, 0x019, 0x01a, 0x033, 0x01c, 0x01d, 0x01e, 0x03b,
 0x020, 0x021, 0x022, 0x043, 0x024, 0x025, 0x026, 0x04b,
 0x028, 0x029, 0x02a, 0x053, 0x02c, 0x02d, 0x02e, 0x05b,
 0x030, 0x031, 0x032, 0x063, 0x034, 0x035, 0x036, 0x06b,
 0x038, 0x039, 0x03a, 0x073, 0x03c, 0x03d, 0x03e, 0x07b,
 0x040, 0x041, 0x042, 0x083, 0x044, 0x045, 0x046, 0x08b,
 0x048, 0x049, 0x04a, 0x093, 0x04c, 0x04d, 0x04e, 0x09b,
 0x050, 0x051, 0x052, 0x0a3, 0x054, 0x055, 0x056, 0x0ab,
 0x058, 0x059, 0x05a, 0x0b3, 0x05c, 0x05d, 0x05e, 0x0bb,
 0x060, 0x061, 0x062, 0x0c3, 0x064, 0x065, 0x066, 0x0cb,
 0x068, 0x069, 0x06a, 0x0d3, 0x06c, 0x06d, 0x06e, 0x0db,
 0x070, 0x071, 0x072, 0x0e3, 0x074, 0x075, 0x076, 0x0eb,
 0x078, 0x079, 0x07a, 0x0f3, 0x07c, 0x07d, 0x0be, 0x0fb,
 0x080, 0x081, 0x082, 0x103, 0x084, 0x085, 0x086, 0x10b,
 0x088, 0x089, 0x08a, 0x113, 0x08c, 0x08d, 0x08e, 0x11b,
 0x090, 0x091, 0x092, 0x123, 0x094, 0x095, 0x096, 0x12b,
 0x098, 0x099, 0x09a, 0x133, 0x09c, 0x09d, 0x09e, 0x13b,
 0x0a0, 0x0a1, 0x0a2, 0x143, 0x0a4, 0x0a5, 0x0a6, 0x14b,
 0x0a8, 0x0a9, 0x0aa, 0x153, 0x0ac, 0x0ad, 0x0ae, 0x15b,
 0x0b0, 0x0b1, 0x0b2, 0x163, 0x0b4, 0x0b5, 0x0b6, 0x16b,
 0x0b8, 0x0b9, 0x0ba, 0x173, 0x0bc, 0x0bd, 0x13e, 0x17b,
 0x0c0, 0x0c1, 0x0c2, 0x183, 0x0c4, 0x0c5, 0x0c6, 0x18b,
 0x0c8, 0x0c9, 0x0ca, 0x193, 0x0cc, 0x0cd, 0x0ce, 0x19b,
 0x0d0, 0x0d1, 0x0d2, 0x1a3, 0x0d4, 0x0d5, 0x0d6, 0x1ab,
 0x0d8, 0x0d9, 0x0da, 0x1b3, 0x0dc, 0x0dd, 0x0de, 0x1bb,
 0x0e0, 0x0e1, 0x0e2, 0x1c3, 0x0e4, 0x0e5, 0x0e6, 0x1cb,
 0x0e8, 0x0e9, 0x0ea, 0x1d3, 0x0ec, 0x0ed, 0x0ee, 0x1db,
 0x0f0, 0x0f1, 0x0f2, 0x1e3, 0x0f4, 0x0f5, 0x0f6, 0x1eb,
 0x0f8, 0x0f9, 0x0fa, 0x1f3, 0x17c, 0x17d, 0x1be, 0x2fb },
// Input Len = 4
{0x000, 0x001, 0x002, 0x005, 0x004, 0x009, 0x006, 0x00d,
 0x008, 0x011, 0x00a, 0x015, 0x00c, 0x019, 0x00e, 0x01d,
 0x010, 0x021, 0x012, 0x025, 0x014, 0x029, 0x016, 0x02d,
 0x018, 0x031, 0x01a, 0x035, 0x01c, 0x039, 0x01e, 0x03d,
 0x020, 0x041, 0x022, 0x045, 0x024, 0x049, 0x026, 0x04d,
 0x028, 0x051, 0x02a, 0x055, 0x02c, 0x059, 0x02e, 0x05d,
 0x030, 0x061, 0x032, 0x065, 0x034, 0x069, 0x036, 0x06d,
 0x038, 0x071, 0x03a, 0x075, 0x03c, 0x079, 0x03e, 0x07d,
 0x040, 0x081, 0x042, 0x085, 0x044, 0x089, 0x046, 0x08d,
 0x048, 0x091, 0x04a, 0x095, 0x04c, 0x099, 0x04e, 0x09d,
 0x050, 0x0a1, 0x052, 0x0a5, 0x054, 0x0a9, 0x056, 0x0ad,
 0x058, 0x0b1, 0x05a, 0x0b5, 0x05c, 0x0b9, 0x05e, 0x0bd,
 0x060, 0x0c1, 0x062, 0x0c5, 0x064, 0x0c9, 0x066, 0x0cd,
 0x068, 0x0d1, 0x06a, 0x0d5, 0x06c, 0x0d9, 0x06e, 0x0dd,
 0x070, 0x0e1, 0x072, 0x0e5, 0x074, 0x0e9, 0x076, 0x0ed,
 0x078, 0x0f1, 0x07a, 0x0f5, 0x07c, 0x0f9, 0x0be, 0x17d,
 0x080, 0x101, 0x082, 0x105, 0x084, 0x109, 0x086, 0x10d,
 0x088, 0x111, 0x08a, 0x115, 0x08c, 0x119, 0x08e, 0x11d,
 0x090, 0x121, 0x092, 0x125, 0x094, 0x129, 0x096, 0x12d,
 0x098, 0x131, 0x09a, 0x135, 0x09c, 0x139, 0x09e, 0x13d,
 0x0a0, 0x141, 0x0a2, 0x145, 0x0a4, 0x149, 0x0a6, 0x14d,
 0x0a8, 0x151, 0x0aa, 0x155, 0x0ac, 0x159, 0x0ae, 0x15d,
 0x0b0, 0x161, 0x0b2, 0x165, 0x0b4, 0x169, 0x0b6, 0x16d,
 0x0b8, 0x171, 0x0ba, 0x175, 0x0bc, 0x179, 0x13e, 0x27d,
 0x0c0, 0x181, 0x0c2, 0x185, 0x0c4, 0x189, 0x0c6, 0x18d,
 0x0c8, 0x191, 0x0ca, 0x195, 0x0cc, 0x199, 0x0ce, 0x19d,
 0x0d0, 0x1a1, 0x0d2, 0x1a5, 0x0d4, 0x1a9, 0x0d6, 0x1ad,
 0x0d8, 0x1b1, 0x0da, 0x1b5, 0x0dc, 0x1b9, 0x0de, 0x1bd,
 0x0e0, 0x1c1, 0x0e2, 0x1c5, 0x0e4, 0x1c9, 0x0e6, 0x1cd,
 0x0e8, 0x1d1, 0x0ea, 0x1d5, 0x0ec, 0x1d9, 0x0ee, 0x1dd,
 0x0f0, 0x1e1, 0x0f2, 0x1e5, 0x0f4, 0x1e9, 0x0f6, 0x1ed,
 0x0f8, 0x1f1, 0x0fa, 0x1f5, 0x17c, 0x2f9, 0x1be, 0x37d }

}; // Out
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\makefile.inc ===
obj\$(TARGET_DIRECTORY)\awmodem.h: awmodem.inf
        bin2c -a awmodem.inf obj\$(TARGET_DIRECTORY)\awmodem.h szAwmodemInf

obj\$(TARGET_DIRECTORY)\adaptive.h: adaptive.inf
        bin2c -a adaptive.inf obj\$(TARGET_DIRECTORY)\adaptive.h szAdaptiveInf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\fdebug.c ===
/***************************************************************************
        Name      :     fdebug.C
        Comment   :     Factored out debug code
        Functions :     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"

#include <comdevi.h>

#include "filet30.h"  //RSL just need t30fail.h
#include "efaxcb.h"
#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


#include "glbproto.h"


#define FILEID                  FILEID_FDEBUG

#ifdef DEBUG
#       define ST_DB(x)         if(ZONE_DB) { x; }
#       define ST_DB3(x)        if(ZONE_DB3) { x; }
#else
#       define ST_DB(x)         { }
#       define ST_DB3(x)        { }
#endif

#define FLUSHBUFSIZE 256

void InitCommErrCount(PThrdGlbl pTG)
{
    T30FAILURECODE err;

    err = 0;
    if(pTG->Comm.uOtherErrorCount >= 20)
            err = T30FAIL_OTHERCOMM2;
    else if(pTG->Comm.uOtherErrorCount >= 10)
            err = T30FAIL_OTHERCOMM1;
    else if(pTG->Comm.uOtherErrorCount >= 5)
            err = T30FAIL_OTHERCOMM;
    if(err)
            ICommFailureCode(pTG, err);

    err = 0;
    if(pTG->Comm.uFramingBreakErrorCount >= 20)
            err = T30FAIL_FRAMING2;
    else if(pTG->Comm.uFramingBreakErrorCount >= 10)
            err = T30FAIL_FRAMING1;
    else if(pTG->Comm.uFramingBreakErrorCount >= 5)
            err = T30FAIL_FRAMING;
    if(err)
            ICommFailureCode(pTG, err);

    err = 0;
    if(pTG->Comm.uBufferOverflowCount >= 20)
            err = T30FAIL_BUFOVER2;
    else if(pTG->Comm.uBufferOverflowCount >= 10)
            err = T30FAIL_BUFOVER1;
    else if(pTG->Comm.uBufferOverflowCount >= 5)
            err = T30FAIL_BUFOVER;
    if(err)
            ICommFailureCode(pTG, err);

    err = 0;
    if(pTG->Comm.uInterruptOverunCount >= 20)
            err = T30FAIL_OVER2;
    else if(pTG->Comm.uInterruptOverunCount >= 10)
            err = T30FAIL_OVER1;
    else if(pTG->Comm.uInterruptOverunCount >= 5)
            err = T30FAIL_OVER;
    if(err)
            ICommFailureCode(pTG, err);

    pTG->Comm.uInterruptOverunCount      = 0;
    pTG->Comm.uBufferOverflowCount       = 0;
    pTG->Comm.uFramingBreakErrorCount= 0;
    pTG->Comm.uOtherErrorCount           = 0;
}

void far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs)
{
    // int nCommEvt;           // MUST be 16bit in WIN16 and 32bit in WIN32

    if(err & CE_OVERRUN)
            pTG->Comm.uInterruptOverunCount++;
    if(err & CE_RXOVER)
            pTG->Comm.uBufferOverflowCount++;
    if(err & (CE_BREAK | CE_FRAME))
            pTG->Comm.uFramingBreakErrorCount++;
    if(err & (~(CE_OVERRUN | CE_RXOVER | CE_BREAK | CE_FRAME)))
            pTG->Comm.uOtherErrorCount++;

#ifdef DEBUG
        BG_CHK(err);
        D_PrintCE(err);

        D_PrintCOMSTAT(pTG, lpcs);

#endif // DEBUG
}

void far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid)
{
#ifdef DEBUG
        // int     nCommEvt;       // MUST be 16bit in WIN16 and 32bit in WIN32
        COMSTAT comstat;
        int             err;    // _must_ be 32bits in Win32

        GetCommErrorNT( pTG, (HANDLE) nCid, &err, &comstat);
        D_PrintCE(err);
        D_PrintCOMSTAT(pTG, &comstat);
        // .... won't work in Win32.....
        // MyGetCommEvent(nCid, &nCommEvt);
        // D_PrintEvent(nCommEvt);
#endif
}

#undef USE_DEBUG_CONTEXT
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

void far D_HexPrint(LPB b1, UWORD incnt)
{
#ifdef DEBUG
        BYTE    b2[FLUSHBUFSIZE];
        UWORD   i, j;

        DEBUG_FUNCTION_NAME(("D_HexPrint"));

        DebugPrintEx(   DEBUG_MSG,
                        "b1=0x%08lx incnt=%d",
                        (LPSTR)b1, 
                        incnt);

        for(i=0; i<incnt;)
        {
            for(j=0; i<incnt && j<FLUSHBUFSIZE-6;)
            {
                j += (UWORD)wsprintf(b2+j, "%02x ", (UWORD)(b1[i]));
                i++;
            }
            b2[j] = 0;
            DebugPrintEx(DEBUG_MSG,"(%s)",(LPSTR)b2);
        }
#endif
}

#undef USE_DEBUG_CONTEXT
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#ifdef DEBUG

void D_PrintIE(int err)
{
    DEBUG_FUNCTION_NAME(_T("D_PrintIE"));
    switch(err)
    {
    case IE_BADID:      DebugPrintEx(DEBUG_ERR,"IE(%02x) Some Bad Com identifier", err); 
                        break;
    case IE_BAUDRATE:   DebugPrintEx(DEBUG_ERR,"IE(%02x) Bad Baud Rate", err); 
                        break;
    case IE_BYTESIZE:   DebugPrintEx(DEBUG_ERR,"IE(%02x) Invalid Byte Size", err); 
                        break;
    case IE_DEFAULT:    DebugPrintEx(DEBUG_ERR,"IE(%02x) Error in default params", err); 
                        break;
    case IE_HARDWARE:   DebugPrintEx(DEBUG_ERR,"IE(%02x) Missing Hardware", err); 
                        break;
    case IE_MEMORY:     DebugPrintEx(DEBUG_ERR,"IE(%02x) Can't get memory", err); 
                        break;
    case IE_NOPEN:      DebugPrintEx(DEBUG_ERR,"IE(%02x) Device not open", err); 
                        break;
    case IE_OPEN:       DebugPrintEx(DEBUG_ERR,"IE(%02x) Device already open", err); 
                        break;
    default:            DebugPrintEx(DEBUG_ERR,"IE(%02x) No Comm Error!!!!", err); 
                        break;
    }
}


void D_PrintCE(int err)
{
    DEBUG_FUNCTION_NAME(("D_PrintCE"));
    if(err & CE_MODE)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) CE Mode -- or nCid is illegal", err);
        return;
    }
    if(err & CE_RXOVER)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Buffer Overflow", err);
    }
    if(err & CE_OVERRUN)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Overrun (not an error during startup)", err);
    }
    if(err & CE_RXPARITY)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Parity error", err);
    }
    if(err & CE_FRAME)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Framing error (not an error during call startup or shutdown)", err);
    }
    if(err & CE_BREAK)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Break condition (not an error during call startup or shutdown)", err);
    }
    if(err & CE_TXFULL)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Transmit Buffer full", err);
    }
    if(err & (CE_PTO | CE_IOE | CE_DNS | CE_OOP))
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Parallel Printer Errors!!!", err);
    }
}

void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs)
{

    DEBUG_FUNCTION_NAME(_T("D_PrintCOMSTAT"));

    if( (lpcs->cbInQue != pTG->PrevcbInQue)             || 
        (lpcs->cbOutQue != pTG->PrevcbOutQue)           ||
        (lpcs->fXoffHold != (DWORD)pTG->PrevfXoffHold)  ||
        (lpcs->fXoffSent != (DWORD)pTG->PrevfXoffSent)  )
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "STAT::: InQ=%d PutQ=%d XoffHold=%d XoffSent=%d",
                        lpcs->cbInQue, 
                        lpcs->cbOutQue,
                        lpcs->fXoffHold, 
                        lpcs->fXoffSent);
    }

    if( lpcs->fCtsHold  || 
        lpcs->fDsrHold  || 
        lpcs->fRlsdHold || 
        lpcs->fEof      || 
        lpcs->fTxim     )
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "???::: CTShold=%d DSRhold=%d RLShold=%d FOF=%d TXim=%d",
                        lpcs->fCtsHold, 
                        lpcs->fDsrHold, 
                        lpcs->fRlsdHold, 
                        lpcs->fEof, 
                        lpcs->fTxim);
    }

    pTG->PrevfXoffHold = lpcs->fXoffHold;
    pTG->PrevfXoffSent = lpcs->fXoffSent;

    BG_CHK(lpcs->cbInQue < 0xffff);
    BG_CHK(lpcs->cbOutQue < 0xffff);

    pTG->PrevcbInQue = (USHORT) lpcs->cbInQue;
    pTG->PrevcbOutQue = (USHORT) lpcs->cbOutQue;
}

void D_PrintEvent(UWORD uwEvent)
{
    char sz[256];
    LPSTR szCurr;

    DEBUG_FUNCTION_NAME(("D_PrintEvent"));
    szCurr = sz;
    if(uwEvent & EV_RXCHAR)
        szCurr += wsprintf(szCurr, "1-RXCHAR ");

    if(uwEvent & EV_RXFLAG)
        szCurr += wsprintf(szCurr, "2-RXFLAG ");

    if(uwEvent & EV_TXEMPTY)
        szCurr += wsprintf(szCurr, "4-TXEMPTY ");

    if(uwEvent & EV_CTS)
        szCurr += wsprintf(szCurr, "8-CTSchange ");

    if(uwEvent & EV_DSR)
        szCurr += wsprintf(szCurr, "16-DSRchange ");

    if(uwEvent & EV_RLSD)
        szCurr += wsprintf(szCurr, "32-CDchange ");

    if(uwEvent & EV_BREAK)
        szCurr += wsprintf(szCurr, "64-BREAK ");

    if(uwEvent & EV_ERR)
        szCurr += wsprintf(szCurr, "128-LSRerror ");

    if(uwEvent & EV_RING)
        szCurr += wsprintf(szCurr, "256-RING ");

    if(uwEvent & EV_PERR)
        szCurr += wsprintf(szCurr, "512-LPTerror ");

    *szCurr = 0;

    if(szCurr > sz)
    {
        DebugPrintEx(DEBUG_MSG,"EVENT:::{%04x} %s", uwEvent, (LPSTR)sz);
    }
}

void D_FComCheck(PThrdGlbl pTG, LONG_PTR nCid)
{
    COMSTAT         comstat;
    int             err;    // _must_ be 32bits in Win32

    GetCommErrorNT( pTG, (HANDLE) nCid, &err, &comstat);
    if(err != 0)
    {
        D_PrintCE(err);
        if(ZONE_DB)
        {
            D_PrintCOMSTAT(pTG, &comstat);
        }
    }
}

#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

void D_SafePrint(PThrdGlbl pTG, LPB b1, UWORD incnt)
{
    BYTE    b2[FLUSHBUFSIZE];
    UWORD   i, j;

    DEBUG_FUNCTION_NAME(("D_SafePrint"));

    DebugPrintEx(DEBUG_MSG,"b1=0x%08lx incnt=%d", (LPSTR)b1, incnt);

    for(i=0, j=0; i<incnt && j<FLUSHBUFSIZE-6; i++)
    {
        if(b1[i] < 32 || b1[i] >= 128)
        {
            j += (UWORD)wsprintf(b2+j, "{0x%02x}", (UWORD)(b1[i]));
        }
        else
        {
            b2[j++] = b1[i];
        }
    }
    b2[j] = 0;
    DebugPrintEx(DEBUG_MSG,"%s", (LPSTR)b2);
}

#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#endif //DEBUG


#ifdef MON3
// COMM MONITOR CODE
// 2/11/95      JosephJ Created
//
//      The functions MonInit, MonDeInit, MonPut and MonDump may be used
//  to  timestamp and log all reads from/writes using the comm apis.
//  MonDump creates two files, one a byte buffer, and the 2nd
//  an array of MONREC structures, each structure containing a timestamp
//  and an offset into the first file pointing to the actual comm data.

BOOL iMonWriteFrames(PThrdGlbl pTG, HFILE hfile, ULONG_PTR dwMROffset, DWORD dwcmr);
HFILE iMonOpenAndWriteHeader(PThrdGlbl pTG);


BOOL MonInit(PThrdGlbl pTG, LPMONOPTIONS lpmo)
{
        BOOL fRet=FALSE;
        DWORD dwPrefMRBufSize = lpmo->dwMRBufSize;
        DWORD dwPrefDataBufSize = lpmo->dwDataBufSize;

        if (pTG->gMonInfo.fInited) {BG_CHK(FALSE); goto end;}

        _fmemset(&pTG->gMonInfo, 0, sizeof(pTG->gMonInfo));
        GetLocalTime(&pTG->gMonInfo.stStart);
        pTG->gMonInfo.mo = *lpmo; //structure copy.


        // Try to allocate...

#define TRYALLOC(buffer, size, minsize, maxsize, ptrtype)\
                if ((size)<(minsize)) size=(minsize);\
                if ((size)>(maxsize)) size=(maxsize);\
                buffer = (ptrtype) MemAlloc((size));\
                if (!buffer)\
                {\
                        size = (minsize);\
                        buffer = (ptrtype) MemAlloc((size));\
                        if (!(buffer))\
                        {\
                                buffer=0;\
                                size=0;\
                        }\
                }

        BG_CHK(MIN_MRBUFSIZE>=sizeof(MONREC));
        BG_CHK(MIN_DATABUFSIZE>=sizeof(BYTE));
        TRYALLOC(pTG->gMonInfo.lpmrBuf, dwPrefMRBufSize,MIN_MRBUFSIZE,MAX_MRBUFSIZE,
                                                                                                                        LPMONREC);
        if (pTG->gMonInfo.lpmrBuf)
        {
        TRYALLOC(pTG->gMonInfo.lpbBuf,dwPrefDataBufSize,MIN_DATABUFSIZE,MAX_DATABUFSIZE,
                                                                                                                        LPBYTE);
                if (!pTG->gMonInfo.lpbBuf)
                {
                        MemFree(pTG->gMonInfo.lpmrBuf);
                        pTG->gMonInfo.lpmrBuf=0;
                        dwPrefMRBufSize=0;
                }
        }

        if (pTG->gMonInfo.lpmrBuf)
        {
                BG_CHK(dwPrefMRBufSize>=MIN_MRBUFSIZE);
                BG_CHK(pTG->gMonInfo.lpbBuf);
                BG_CHK(dwPrefDataBufSize>=MIN_DATABUFSIZE);

                pTG->gMonInfo.lpmrNext=pTG->gMonInfo.lpmrBuf;
                pTG->gMonInfo.dwcmrBuf= dwPrefMRBufSize/sizeof(MONREC);

                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf;
                pTG->gMonInfo.dwcbBuf = dwPrefDataBufSize;

                pTG->gMonInfo.fFreeOnExit=TRUE;
        }
        else
        {
                BG_CHK(!dwPrefMRBufSize);
                BG_CHK(!pTG->gMonInfo.lpbBuf);
                BG_CHK(!dwPrefDataBufSize);

                pTG->gMonInfo.lpmrNext=pTG->gMonInfo.lpmrBuf=NULL;
                pTG->gMonInfo.dwcmrBuf= 0;

                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf=NULL;
                pTG->gMonInfo.dwcbBuf = 0;

                pTG->gMonInfo.fFreeOnExit=FALSE;
                fRet=FALSE;
                goto end;
        }


        pTG->gMonInfo.fInited=TRUE;
        fRet=TRUE;

end:
        return fRet;
}

void MonDeInit(PThrdGlbl pTG)
{
        if (!pTG->gMonInfo.fInited) { BG_CHK(FALSE); return; }

        // Free monbuf and mr array, if allocated.
        if (pTG->gMonInfo.fFreeOnExit)
        {
                MemFree(pTG->gMonInfo.lpbBuf);
                MemFree(pTG->gMonInfo.lpmrBuf);
        }

        _fmemset(&pTG->gMonInfo, 0, sizeof(pTG->gMonInfo));
}


BOOL MonPutComm(PThrdGlbl pTG, WORD wFlags, LPBYTE lpb, WORD wcb)
// NOTE: special wFlags value (WORD)-1 indicates that
// lpb is actually an entire MONFRAME_EVENT structure
{
        DWORD    cb0 = (DWORD)(pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf -
                               pTG->gMonInfo.lpbNext);
        LPMONREC lpmrNext = pTG->gMonInfo.lpmrNext;

        if ((DWORD)wcb > pTG->gMonInfo.dwcbBuf) {BG_CHK(FALSE); return FALSE;}

        // +++Collapse into one bgchk after initial test.
        BG_CHK(pTG->gMonInfo.fInited);
        BG_CHK((pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf)>pTG->gMonInfo.lpbNext);
        BG_CHK(cb0<=pTG->gMonInfo.dwcbBuf);

        lpmrNext->dwTickCount=GetTickCount();
        lpmrNext->wFlags=wFlags;
        lpmrNext->wcb=wcb;
        // even on if !wcb we still keep the offset, for consistancy.
        lpmrNext->dwOffset=(DWORD)(pTG->gMonInfo.lpbNext-pTG->gMonInfo.lpbBuf);

        pTG->gMonInfo.dwNumBytes+=wcb;
        pTG->gMonInfo.dwNumPuts++;

        pTG->gMonInfo.lpmrNext++;
        if (pTG->gMonInfo.lpmrNext>=(pTG->gMonInfo.lpmrBuf+pTG->gMonInfo.dwcmrBuf))
                pTG->gMonInfo.lpmrNext = pTG->gMonInfo.lpmrBuf;
        if (wcb>cb0)
        {
                _fmemcpy(pTG->gMonInfo.lpbNext, lpb, cb0);
                pTG->gMonInfo.lpbNext=pTG->gMonInfo.lpbBuf;
                wcb-=(WORD)cb0;
                lpb+=cb0;
        }


        _fmemcpy(pTG->gMonInfo.lpbNext, lpb, wcb);
        pTG->gMonInfo.lpbNext+=wcb;
        if (pTG->gMonInfo.lpbNext >= (pTG->gMonInfo.lpbBuf+pTG->gMonInfo.dwcbBuf))
                pTG->gMonInfo.lpbNext = pTG->gMonInfo.lpbBuf;

        return TRUE;
}

BOOL MonPutEvent(PThrdGlbl pTG, WORD wFlags, WORD wID, WORD wSubID,
                                        DWORD dwData0, DWORD dwData1, LPSTR lpszTxtMsg)
{
        // We actually call MonPutComm, with a "special" wFlag value of
        // (WORD) -1. MonDump looks for this special value and treates it
        // differently when writing out the record.


        char rgchBuf[sizeof(MONFRAME_EVENT)+MAX_TXTMSG_SIZE];
        LPMONFRAME_EVENT lpmfe=(LPMONFRAME_EVENT) rgchBuf;
        BOOL fRet=FALSE;

        lpmfe->wTxtMsgOff=
        lpmfe->wTotalSize=lpmfe->wHeaderSize=sizeof(MONFRAME_EVENT);
        lpmfe->wcbTxtMsg = (lpszTxtMsg) ? (WORD)lstrlen(lpszTxtMsg)+1:0;
        lpmfe->wTotalSize += lpmfe->wcbTxtMsg;
        if (lpmfe->wTotalSize>sizeof(rgchBuf)) goto end;
        lpmfe->wType = MFR_EVENT;
        lpmfe->wFlags = wFlags;
        lpmfe->dwTickCount = GetTickCount();
        lpmfe->wID=wID;
        lpmfe->wSubID=wSubID;
        lpmfe->dwInstanceID=pTG->gMonInfo.dwEventInstanceID++;
        lpmfe->dwData0=dwData0;
        lpmfe->dwData1=dwData1;
        GetLocalTime(&(lpmfe->st));
        if (lpmfe->wcbTxtMsg) _fmemcpy(((LPBYTE)lpmfe)+lpmfe->wTxtMsgOff,lpszTxtMsg, lpmfe->wcbTxtMsg);
        fRet = MonPutComm(pTG, (WORD)-1, (LPBYTE)lpmfe, lpmfe->wTotalSize);

end:
        return fRet;
}

void MonDump(PThrdGlbl pTG)
{
        HFILE hfile=HFILE_ERROR;
        LPMONREC lpmrFirst;
        DWORD dwcbBytesLeft;
        DWORD dwNumGoodMRs;

        if (!pTG->gMonInfo.fInited) {BG_CHK(FALSE); goto end;}

        GetLocalTime(&pTG->gMonInfo.stDump);

        hfile = iMonOpenAndWriteHeader(pTG);

        if (hfile==HFILE_ERROR) goto end;

        // Fixup offsets in MONREC structures to reflect the fact that
        // we're going to write starting from the oldest record onwards..
        //
        // This is a bit tricky because some of the MONREC structures may
        // not have associated data (the data could have been written over).
        // There may alternatively be data for which there are no MONREC structures
        // but that's OK.
        //
        // We start from the newest monrec structure and work our way backwards,
        // checking that the data is still valid and fixing up the offsets.

        if (pTG->gMonInfo.dwNumPuts<=pTG->gMonInfo.dwcmrBuf)
                lpmrFirst = pTG->gMonInfo.lpmrBuf;
       else
                lpmrFirst = pTG->gMonInfo.lpmrNext; // MONREC buffer rollover

        dwcbBytesLeft = pTG->gMonInfo.dwcbBuf; // we don't care if it's > than actually
                                                                          // in buffer.
        dwNumGoodMRs=0;
        if (pTG->gMonInfo.dwNumPuts && pTG->gMonInfo.dwNumBytes)
        {
                LPMONREC lpmr = pTG->gMonInfo.lpmrNext;

                // Starting with last monrec, work our way backwards...
                do
                {
                        if (lpmr>pTG->gMonInfo.lpmrBuf)
                                {lpmr--;}
                        else
                                {lpmr=pTG->gMonInfo.lpmrBuf+pTG->gMonInfo.dwcmrBuf-1;}

                        if (lpmr->wcb <= dwcbBytesLeft)
                        {
                                dwcbBytesLeft-=lpmr->wcb;
                        }
                        else
                        {
                                // we've nuked one-or-more of the earlier structures because
                                // their byte-data was overwritten.
                                // So we reset lpmrFirst to the next MR structure.
                                lpmrFirst=pTG->gMonInfo.lpmrBuf+
                                                                ((lpmr+1-pTG->gMonInfo.lpmrBuf)%pTG->gMonInfo.dwcmrBuf);
                                break;
                        }

                        dwNumGoodMRs++;

                } while (lpmr!=lpmrFirst);

        }

        iMonWriteFrames(pTG, hfile, (lpmrFirst-pTG->gMonInfo.lpmrBuf), dwNumGoodMRs);
        DosClose(hfile);


        pTG->gMonInfo.uRefCount++;
        pTG->gMonInfo.uRefCount&=0xf; // Limit number to 16

end:
        return;
}


void imon_write(HFILE hfile, LPBYTE lpb, DWORD dwcb)
{
        // Write out mon file, in chunks of 32K
        // -- because old mon code did that, perhaps a Win16 consideration.
#define WRITESIZE (0x1L<<15)

        while(dwcb>=WRITESIZE)
        {
                DosWrite(hfile, lpb, WRITESIZE);
                lpb+=WRITESIZE;
                dwcb-=WRITESIZE;
        }
        if (dwcb)
        {
                DosWrite(hfile, lpb, dwcb);
        }
}


// Create a single file which contains the combined info in the
// MONREC buffer and the byte buffer, in the form of MONFRAME
// structures.
// NOTE: special wFlags value (WORD)-1 indicates that
// lpb is actually an entire MONFRAME_EVENT structure
BOOL iMonWriteFrames(PThrdGlbl pTG, HFILE hfile, ULONG_PTR dwMROffset, DWORD dwcmr)
{

        //BG_CHK((!dwMROffset && !dwcmr) || dwcmr<dwMROffset);

        // Simple version: don't bother caching
        {
                BYTE bBuf[sizeof(MONFRAME_COMM)];
                LPMONFRAME_COMM lpmfc = (LPMONFRAME_COMM) bBuf;
                LPMONREC lpmr = pTG->gMonInfo.lpmrBuf+dwMROffset;
                BG_CHK(dwMROffset<pTG->gMonInfo.dwcmrBuf);
                BG_CHK(dwcmr<=pTG->gMonInfo.dwcmrBuf);
                BG_CHK(dwcmr<=pTG->gMonInfo.dwNumPuts);

                while(dwcmr--)
                {
                        DWORD dwcb0;
                        BG_CHK((lpmr->wcb+sizeof(MONFRAME_COMM))<(1L<<(8*sizeof(WORD))));
                        BG_CHK(lpmr->wcb<=pTG->gMonInfo.dwcbBuf);
                        BG_CHK(lpmr->dwOffset<=pTG->gMonInfo.dwcbBuf);
                        if (lpmr->wFlags != (WORD)-1) // See comment at head of function
                        {
                                lpmfc->wHeaderSize = sizeof(MONFRAME_COMM);
                                lpmfc->wTotalSize = sizeof(MONFRAME_COMM)+lpmr->wcb;
                                lpmfc->wType = MFR_COMMDATA;
                                lpmfc->wFlags = lpmr->wFlags;
                                lpmfc->dwTickCount = lpmr->dwTickCount;
                                lpmfc->wcb = lpmr->wcb;
                                imon_write(hfile, (LPBYTE)lpmfc, lpmfc->wHeaderSize);
                        }
                        dwcb0=pTG->gMonInfo.dwcbBuf-lpmr->dwOffset;
                        if (lpmr->wcb<=dwcb0)
                        {
                                imon_write(hfile, pTG->gMonInfo.lpbBuf+lpmr->dwOffset, lpmr->wcb);
                        }
                        else
                        {
                                imon_write(hfile, pTG->gMonInfo.lpbBuf+lpmr->dwOffset, dwcb0);
                                imon_write(hfile, pTG->gMonInfo.lpbBuf, lpmr->wcb-dwcb0);
                        }
                        if ( (lpmr+1-pTG->gMonInfo.lpmrBuf) < (long)pTG->gMonInfo.dwcmrBuf)
                                lpmr++;
                        else
                                lpmr=pTG->gMonInfo.lpmrBuf;
                }

        }

        return TRUE;
}


HFILE iMonOpenAndWriteHeader(PThrdGlbl pTG)
// Open file, if it's too big, rename old file and create file again.
// If file empty, put signature
// Put introductory timestamp text event.
{
        UINT uHeaderSize=0;
        LPSTR lpszPathPrefix=pTG->gMonInfo.mo.rgchDir;
        char rgchPath[64];
        HFILE hfile = HFILE_ERROR;
        LONG l=0;

        if (!*lpszPathPrefix || (_fstrlen(lpszPathPrefix)+8) > sizeof (rgchPath))
        {
                lpszPathPrefix= "c:\\";
        }
#define szMONFILESTUB "fax0"
#define szRENAMED_MONFILESTUB "old"
        wsprintf(rgchPath, "%s%s", (LPSTR) lpszPathPrefix,
                                        (LPSTR) szMONFILESTUB "." szMON_EXT);

        // Try to open existing file.
        hfile = DosOpen(rgchPath, OF_READWRITE|OF_SHARE_DENY_WRITE);

        // Check if size is too big -- if so rename.
        if (hfile!=HFILE_ERROR)
        {
                l = DosSeek(hfile, 0, FILE_END);
                if (l==HFILE_ERROR) {DosClose(hfile); hfile=HFILE_ERROR; goto end;}
                if ((DWORD)l>pTG->gMonInfo.mo.dwMaxExistingSize)
                {
                        char rgchRenamed[64];
                        DosClose(hfile); hfile=HFILE_ERROR;
                        wsprintf(rgchRenamed, "%s%s", (LPSTR) lpszPathPrefix,
                                                (LPSTR) szRENAMED_MONFILESTUB "." szMON_EXT);
                        DeleteFile(rgchRenamed);
                        MoveFile(rgchPath, rgchRenamed);
                }
        }

        if (hfile== HFILE_ERROR)
        {
                hfile = DosCreate(rgchPath, 0);
                if (hfile==HFILE_ERROR) goto end;
                l=0;
        }

        // Write header
        if (!l) {
                imon_write(hfile, szMONFRM_VER001 szMONFRM_DESC001,
                                                                        sizeof(szMONFRM_VER001 szMONFRM_DESC001));
        }

        // Create and write Text-frame with TIMESTAMP.
        {
                char rgchBuf[sizeof(MONFRAME_EVENT)+MAX_TXTMSG_SIZE];
                LPMONFRAME_EVENT lpmfe=(LPMONFRAME_EVENT) rgchBuf;
                UINT uTxtLen=0;

                lpmfe->wTxtMsgOff=
                lpmfe->wTotalSize=lpmfe->wHeaderSize=sizeof(MONFRAME_EVENT);
                lpmfe->wType = MFR_EVENT;
                lpmfe->wFlags = fEVENT_TRACELEVEL_0;
                lpmfe->dwTickCount = GetTickCount();
                lpmfe->wID= EVENT_ID_MON;
                lpmfe->wSubID= EVENT_SubID_MON_DUMP;
                lpmfe->dwInstanceID=pTG->gMonInfo.dwEventInstanceID++;
                lpmfe->dwData0=0;
                lpmfe->dwData1=0;
                GetLocalTime(&(lpmfe->st));

                uTxtLen = wsprintf(((LPBYTE)lpmfe)+lpmfe->wTxtMsgOff,
                                          "\tStarted: %02u/%02u/%04u %02u:%02u:%02u\r\n"
                                          "\t   Puts: %lu/%lu\r\n"
                                          "\t  Bytes: %lu/%lu\r\n",
                                        (unsigned) pTG->gMonInfo.stStart.wMonth&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wDay&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wYear&0xffff,
                                        (unsigned) pTG->gMonInfo.stStart.wHour&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wMinute&0xff,
                                        (unsigned) pTG->gMonInfo.stStart.wSecond&0xff,
                                        (unsigned) ((pTG->gMonInfo.dwcmrBuf>pTG->gMonInfo.dwNumPuts)
                                                          ? pTG->gMonInfo.dwNumPuts: pTG->gMonInfo.dwcmrBuf),
                                        (unsigned) pTG->gMonInfo.dwNumPuts,
                                        (unsigned) ((pTG->gMonInfo.dwcbBuf>pTG->gMonInfo.dwNumBytes)
                                                          ? pTG->gMonInfo.dwNumBytes: pTG->gMonInfo.dwcbBuf),
                                        (unsigned) pTG->gMonInfo.dwNumBytes);
                lpmfe->wcbTxtMsg = uTxtLen+1; // incuding zero.
                lpmfe->wTotalSize += lpmfe->wcbTxtMsg;
                BG_CHK(lpmfe->wTotalSize<=sizeof(rgchBuf));
                imon_write(hfile, (LPBYTE)lpmfe, lpmfe->wTotalSize);
        }

end:
        return  hfile;
}
#endif // MON3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\class1\framing.c ===
/***************************************************************************
 Name     :     FRAMING.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"

#include "encoder.h"
#include "decoder.h"

#include "class1.h"
#include "debug.h"


#include "glbproto.h"


#define         FILEID                  FILEID_FRAMING


#ifdef DEBUG
#       define  ST_SWFRAME2(x)                  if(ZONE_SWFRAME2) { x; }
#else
#       define  ST_SWFRAME2(x)                  { }
#endif



BOOL FramingBufSetup(PThrdGlbl pTG, BOOL fOn);

BOOL SWFramingSendSetup(PThrdGlbl pTG, BOOL fOn)
{
    DEBUG_FUNCTION_NAME(_T("SWFramingSendSetup"));
    // If fOn=TRUE, Check that Recv framing is not ON.
    // Can't use Recv and Send framing simultaneously
    BG_CHK(!(fOn && pTG->Class1Modem.fRecvSWFraming));

    if(fOn)
    {
        BG_CHK(!pTG->Class1Modem.fSendSWFraming);
    }
    else if(!pTG->Class1Modem.fSendSWFraming)
    {
        DebugPrintEx(DEBUG_WRN,"(FALSE) called when not inited. Ignoring");
        return TRUE;
    }

    if(!FramingBufSetup(pTG, fOn))
        return FALSE;

    pTG->Class1Modem.fSendSWFraming = fOn;
    InitEncoder(pTG, pTG->Framing.EncodeState);
    return TRUE;
}

BOOL SWFramingRecvSetup(PThrdGlbl pTG, BOOL fOn)
{
    DEBUG_FUNCTION_NAME(_T("SWFramingRecvSetup"));
    // if fOn=TRUE Check that Send framing is not ON.
    // Can't use Recv and Send framing simultaneously
    BG_CHK(!(fOn && pTG->Class1Modem.fSendSWFraming));

    if(fOn)
    {
        BG_CHK(!pTG->Class1Modem.fRecvSWFraming);
    }
    else if(!pTG->Class1Modem.fRecvSWFraming)
    {
        DebugPrintEx(DEBUG_WRN,"(FALSE) called when not inited. Ignoring");
        return TRUE;
    }

    if(!FramingBufSetup(pTG, fOn))
        return FALSE;

    pTG->Class1Modem.fRecvSWFraming = fOn;
    InitDecoder(pTG, pTG->Framing.DecodeState);
    return TRUE;
}

BOOL FramingBufSetup(PThrdGlbl pTG, BOOL fOn)
{
    // UWORD uwJunk;

    DEBUG_FUNCTION_NAME(("FramingBufSetup"));
    if(fOn)
    {
        pTG->Framing.lpbBuf = pTG->bStaticFramingBuf;
        pTG->Framing.cbBufSize = FRAMEBUFINITIALSIZE;
    }
    else
    {
        BG_CHK(fOn == FALSE);
        pTG->Framing.lpbBuf = 0;
        pTG->Framing.cbBufSize = 0;
    }
    pTG->Framing.cbBufCount = 0;
    pTG->Framing.lpbBufSrc = pTG->Framing.lpbBuf;
    pTG->Framing.swEOF = 0;
    return TRUE;
}

/* SWFramingSendFrame:
 * Send buffer to comm port. 
 * lpb - start of the buffer
 * uCount - size of the buffer
 * uFlags - SEND_ENDFRAME must _always_ be TRUE in HDLC mode (partial frames are no longer supported)
 *        - SEND_FINAL
 *
 */

BOOL SWFramingSendFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount, USHORT uFlags)
{
    WORD    wCRC;
    USHORT  cbDst;

    DEBUG_FUNCTION_NAME(("SWFramingSendFrame"));

    DebugPrintEx(   DEBUG_MSG, 
                    "iSW: lpb=%08lx c=%d f=%02x ",
                    lpb, 
                    uCount, 
                    uFlags, 
                    lpb[0]);

    // always DLE-stuff here. Never zero-stuff
    BG_CHK(uFlags & SEND_ENDFRAME);
    BG_CHK(lpb && uCount);

    BG_CHK(uCount <= 260);  // can add stuff to realloc the Dst buffer
                                                            // to a bigger one as needed here
    wCRC = CalcCRC(pTG, lpb, uCount);
    DebugPrintEx(DEBUG_MSG, "CRC=%04x", wCRC);

    cbDst = HDLC_Encode(pTG, lpb, uCount, pTG->Framing.lpbBuf, &pTG->Framing.EncodeState);
    DebugPrintEx(DEBUG_MSG, "D1=%d", cbDst);

    cbDst += HDLC_Encode(pTG, (LPB)(&wCRC), 2, pTG->Framing.lpbBuf+cbDst, &pTG->Framing.EncodeState);
    DebugPrintEx(DEBUG_MSG, "D2=%d", cbDst);

    BG_CHK(cbDst + pTG->ModemParams.InterframeFlags <= pTG->Framing.cbBufSize);
    cbDst += HDLC_AddFlags(pTG, pTG->Framing.lpbBuf+cbDst, pTG->ModemParams.InterframeFlags, &pTG->Framing.EncodeState);
    DebugPrintEx(   DEBUG_MSG, 
                    "D3=%d f=%02x l=%02x", 
                    cbDst, 
                    pTG->Framing.lpbBuf[0], 
                    pTG->Framing.lpbBuf[cbDst-1]);

    // always DLE-stuff here. Never zero-stuff
    if(!FComFilterAsyncWrite(pTG, pTG->Framing.lpbBuf, cbDst, FILTER_DLEONLY))
    {
        DebugPrintEx(DEBUG_ERR, "Class1: DataWrite Timeout");    
        goto error;
    }

    if(uFlags & SEND_FINAL)
    {
        if(!SWFramingSendPostamble(pTG, pTG->Class1Modem.CurMod))
        {
            DebugPrintEx(DEBUG_ERR, "Class1: SWFramingSendPostamble");    
            goto error;
        }

        {
            // if(!FComDirectAsyncWrite(bDLEETXCR, 3))
            if(!FComDirectAsyncWrite(pTG, bDLEETX, 2)) 
            {
                DebugPrintEx(DEBUG_ERR, "Class1: FComDirectAsyncWrite");    
                goto error;
            }
        }

        if(!iModemDrain(pTG))
        {
            DebugPrintEx(DEBUG_ERR, "Class1: iModemDrain");    
            goto error;
        }

        SWFramingSendSetup(pTG, FALSE);
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        FComXon(pTG, FALSE);         // critical. End of PhaseC
        EndMode(pTG);
    }
    DebugPrintEx(DEBUG_MSG,"Success, Returning true");
    return TRUE;

error:
    SWFramingSendSetup(pTG, FALSE);
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    FComXon(pTG, FALSE);                 // critical. End of PhaseC (err)
    EndMode(pTG);
    DebugPrintEx(DEBUG_ERR, "Returning false");
    return FALSE;
}

BOOL SWFramingSendFlags(PThrdGlbl pTG, USHORT uHowMany)
{
    int cb, i;      // must be signed

    DEBUG_FUNCTION_NAME(("SWFramingSendFlags"));

    DebugPrintEx(DEBUG_MSG,"SENDING ECM Flags (%d).....", uHowMany);

    for(i=0, cb = uHowMany; cb>0; i++, cb -= pTG->Framing.cbBufSize)
    {
        if(i<=1)
        {
            HDLC_AddFlags(  pTG, 
                            pTG->Framing.lpbBuf, 
                            pTG->Framing.cbBufSize, 
                            &pTG->Framing.EncodeState);
        }

        // always DLE-stuff here. Never zero-stuff
        if(!FComFilterAsyncWrite(   pTG, 
                                    pTG->Framing.lpbBuf,
                                    (USHORT) min((USHORT)pTG->Framing.cbBufSize, (USHORT)cb), 
                                    FILTER_DLEONLY))
        {
            DebugPrintEx(DEBUG_ERR,"PreFlagDataWrite Timeout");
            return FALSE;
        }
    }
    return TRUE;
}

USHORT SWFramingRecvFrame(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
    USHORT  cbDst, cbProduce, cbConsume, uRet;
    LPB             lpbDst;

    DEBUG_FUNCTION_NAME(_T("SWFramingRecvFrame"));

    DebugPrintEx(   DEBUG_MSG,  
                    "iSW: Buf=%08lx Src=%08lx cbSrc=%d cbMax=%d", 
                    pTG->Framing.lpbBuf, 
                    pTG->Framing.lpbBufSrc, 
                    pTG->Framing.cbBufCount, 
                    cbMax);
/**/
    BG_CHK(pTG->Class1Modem.ModemMode == FRM);
    BG_CHK(pTG->Class1Modem.fRecvSWFraming);
    startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
/**/
    BG_CHK(lpb && cbMax && lpcbRecv);

    *lpcbRecv = 0;

    for(lpbDst=lpb, cbDst=cbMax ;; )
    {
        if(pTG->Framing.cbBufCount == 0)
        {
            if(pTG->Framing.swEOF == 0)
            {
                pTG->Framing.lpbBufSrc = pTG->Framing.lpbBuf;
                // 4th arg must be FALSE for Class1
                pTG->Framing.cbBufCount = FComFilterReadBuf(pTG, pTG->Framing.lpbBufSrc, pTG->Framing.cbBufSize, &(pTG->Class1Modem.toRecv), FALSE, &pTG->Framing.swEOF);
                DebugPrintEx(   DEBUG_MSG,
                                "f=%02x l=%02x", 
                                pTG->Framing.lpbBufSrc[0], 
                                pTG->Framing.lpbBufSrc[pTG->Framing.cbBufCount-1]);
                if(pTG->Framing.swEOF == -1)
                {
                    {
                        // See LONG comment under DDI.C ModemRecvData()
                        // option (a)
                        // ERRMSG((SZMOD "<<WARNING>> Got arbitrary DLE-ETX. Assuming END OF PAGE!!!\r\n"));
                        // pTG->Framing.swEOF = 1;

                        // option (b)
                        DebugPrintEx(DEBUG_WRN,"Got arbitrary DLE-ETX. Ignoring");
                        pTG->Framing.swEOF = 0;
                    }
                }
                BG_CHK(pTG->Framing.swEOF == 0 || pTG->Framing.swEOF == 1 ||
                                 pTG->Framing.swEOF == -2 || pTG->Framing.swEOF == -3);

                // check for progress
                BG_CHK(pTG->Framing.cbBufCount!=0 || pTG->Framing.swEOF!=0);
            }
            else
            {
                // pTG->Framing.swEOF != 0

                BG_CHK(pTG->Framing.swEOF == 1 || pTG->Framing.swEOF == -2 || pTG->Framing.swEOF == -3);

                if(cbDst != cbMax)
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "Got EOF with partial frame %d bytes", 
                                    cbMax-cbDst);
                    ST_SWFRAME2(D_HexPrint(lpb, (USHORT)(cbMax-cbDst)));
                    uRet = RECV_BADFRAME;
                    goto done;
                }

                if(pTG->Framing.swEOF == 1)  // class1 eof
                {
                    SWFramingRecvSetup(pTG, FALSE);
                    EndMode(pTG);
                    uRet = RECV_EOF;
                    goto done;
                }
                else if(pTG->Framing.swEOF < 0)      // error or timeout
                {
                    SWFramingRecvSetup(pTG, FALSE);
                    EndMode(pTG);
                    uRet = ((pTG->Framing.swEOF == -2) ? RECV_ERROR : RECV_TIMEOUT);
                    goto done;
                }
            }
        }

        // cbDst=space left in destination                      lpbDst=start of space
        // pTG->Framing.cbBufCount=bytes left in source      pTG->Framing.lpbBufSrc=start of bytes

        cbConsume = HDLC_Decode(pTG, pTG->Framing.lpbBufSrc,(USHORT) min(pTG->Framing.cbBufCount, cbDst), lpbDst, &cbProduce, &pTG->Framing.DecodeState);
        BG_CHK(cbConsume <= pTG->Framing.cbBufCount && pTG->Framing.lpbBufSrc+cbConsume<=pTG->Framing.lpbBuf+pTG->Framing.cbBufSize);
        BG_CHK(cbProduce <= cbDst && lpbDst+cbProduce <= lpb+cbMax);

        DebugPrintEx(   DEBUG_MSG,
                        "iSW: C=%d P=%d fa=%d", 
                        cbConsume, 
                        cbProduce, 
                        pTG->Framing.DecodeState.flagabort);

        pTG->Framing.cbBufCount      -= cbConsume;
        pTG->Framing.lpbBufSrc       += cbConsume;
        cbDst   -= cbProduce;
        lpbDst  += cbProduce;

        // check for progress.
        BG_CHK(pTG->Framing.DecodeState.flagabort==FLAG ||           // exits below
                                cbProduce || cbConsume ||                       // exits eventually
                                pTG->Framing.cbBufCount==0);         // exits or continues above

        if(pTG->Framing.DecodeState.flagabort == FLAG)
        {
            if((cbMax-cbDst)>=2 && (CalcCRC(pTG, lpb, (USHORT)(cbMax-cbDst)) == ((WORD)(~0xF0B8))) )
            {
                cbDst += 2;
                if(cbMax <= cbDst)
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "GOOD Frame BAD Length!! cbMax=%d cbDst=%d, "
                                    "lpb[0]=%02x lpb[1]=%02x, CRC=%04x",
                                    cbMax, 
                                    cbDst, 
                                    lpb[0], 
                                    lpb[1], 
                                    CalcCRC(pTG, lpb, (USHORT)(cbMax+2-cbDst)));
                    BG_CHK(FALSE);  // can't get good frame of 0 length!
                    // must return RECV_BADFRAME here otherwise we break.
                    // In HDLC.C the (RECV_OK swRead==0) pair gets converted
                    // to RECV_ERROR and we quit receiving. On some modems
                    // this can happen often. See BUG#1684
                    uRet = RECV_BADFRAME;
                }
                else
                {
                    uRet = RECV_OK;
                }
            }
            else
            {
                BG_CHK(cbMax >= cbDst);
#ifdef DEBUG
                if (cbMax-cbDst)
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "BADFR: SWFrRecvFr: CbMax-cbDst = %d bytes", 
                                    cbMax-cbDst);
                }
#endif
                ST_SWFRAME2(D_HexPrint(lpb, (USHORT)(cbMax-cbDst)));
                uRet = RECV_BADFRAME;
            }
            goto done;
        }
        else if(pTG->Framing.DecodeState.flagabort == ABORT)
        {
            lpbDst=lpb;     cbDst=cbMax;
        }
        else if(cbDst == 0)
        {
            // bad frames can be very long
            DebugPrintEx(DEBUG_WRN,"Overflow. Got %d chars -- no flag", cbMax);
            uRet = RECV_BADFRAME;
            goto done;
        }
    }

done:
    *lpcbRecv = cbMax-cbDst;
    DebugPrintEx(DEBUG_MSG,"xSW: uR=%d *lpcbR=%d",uRet,*lpcbRecv);
    return uRet;
}

/*********************

        ECM Preamble and PostAmble: In T.4 appendix A it says
        that the Preamble must be 200ms +/1 100ms of flags,
        and the postamble must be 50ms max.

        However we also have recving modems that don't know they
        are getting ECM and need the 6eols to tell them when to
        stop recving. Also some of them lose large chunks of data
        at the end of PhaseC due to "carrier squelch", i.e. whne
        they lose carrier, they throw away the contents of their
        recv buffer.

        To get 240ms of flags, just multiply CurMod by 3
        // #define SWFramingSendPreamble(b)     \
        //      (FComDirectAsyncWrite(b00EOL, 2), SWFramingSendFlags(b + b + b))

        Postamble must have *max* 50ms of flags, so let's say 30ms, which is
        9 flags at 2400 and 54 at 14400. Just multiply CurMod by (3/8)
        to get correct number of flags
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags((b+b+b) >> 3)
        but with carrier squelch and all that, so few may not be safe.
        Murata sends out 44 flags at 2400 baud on closing. So lets
        just send out 80ms (just CurMod flags)

        This is the 80ms postamble
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags(b)

        // Fix for DSI bug -- drops last 500 bytes or so ////
        // #define SWFramingSendPostamble(b)    SWFramingSendFlags(600)

*********************/


BYTE                            b00EOL[3] = { 0x00, 0x80, 0 };
BYTE b6EOLs[10] = { 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00 };

BOOL SWFramingSendPreamble(PThrdGlbl pTG, USHORT uCurMod)
{
    BOOL fRet = TRUE;

    {
        // fix bug#1762. DataRace modem misses leading EOL unless
        // preceded by some zeros, and it then chews up all data
        // until an EOL, thereby eating up part of the first frame
        SendZeros1(pTG, 100);
        fRet = fRet && FComDirectAsyncWrite(pTG, b00EOL, 2);
    }
    fRet = fRet && SWFramingSendFlags(pTG, (USHORT)(uCurMod + uCurMod + uCurMod));

    return fRet;
}


BOOL SWFramingSendPostamble(PThrdGlbl pTG, USHORT uCurMod)
{
    BYTE bZero[50];
    USHORT i;
    BOOL fRet = TRUE;

    // send 80ms of flags
    fRet &= SWFramingSendFlags(pTG, uCurMod);

    {
        // then send 6EOLs
        fRet &= FComDirectAsyncWrite(pTG, b6EOLs, 9);

        // then send 250 or so 00s
        _fmemset(bZero, 0, 50);

        for (i=0; i<5; i++)
                fRet &= FComDirectAsyncWrite(pTG, bZero, 50);

    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\fcom.c ===
/***************************************************************************
        Name      :     FCOM.C
        Comment   :     Functions for dealing with Windows Comm driver

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"


#include <comdevi.h>
#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


#ifdef MDRV                             // to check for conflicts
#include "..\class1\class1.h"
#endif
#include <filet30.h>    // for registry info.

///RSL
#include "t30gl.h"
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_FCOM
// Enable LOWLOG if you want to see *Everything* going to/from the COM port
// #define LOWLOG                  


#ifdef ADAPTIVE_ANSWER
#       pragma message("Compiling with ADAPTIVE_ANSWER")
#endif

// in ms
#define  TIME_CONTROL     50



#ifdef DEBUG
#       define ST_FC(x)         if(ZONE_FC) { x; }
#else
#       define ST_FC(x)         { }
#endif


/***------------- Local Vars and defines ------------------***/



#define LONG_DEADCOMMTIMEOUT                 60000L
#define SHORT_DEADCOMMTIMEOUT                10000L

#define WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT   120000
#define WAIT_FCOM_FILTER_READBUF_TIMEOUT     120000


// don't want DEADCOMMTIMEOUT to be greater than 32767, so make sure
// buf sizes are always 9000 or less. maybe OK.

#ifdef WIN32
// Our COMM timeout settings, used in call to SetCommTimeouts. These
// values (expect read_interval_timeout) are the default values for
// Daytona NT Beta 2, and seem to work fine..
#define READ_INTERVAL_TIMEOUT                           100
#define READ_TOTAL_TIMEOUT_MULTIPLIER           0
#define READ_TOTAL_TIMEOUT_CONSTANT                     0
#define WRITE_TOTAL_TIMEOUT_MULTIPLIER          0
#define WRITE_TOTAL_TIMEOUT_CONSTANT            LONG_DEADCOMMTIMEOUT
#endif

#define         CTRL_P          0x10
#define         CTRL_Q          0x11
#define         CTRL_S          0x13



#define MYGETCOMMERROR_FAILED 117437834L



// Forward declarations
static BOOL FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead);
static BOOL CancellPendingIO(PThrdGlbl pTG, HANDLE hComm, LPOVERLAPPED lpOverlapped, LPDWORD lpCounter);




BOOL FComDTR(PThrdGlbl pTG, BOOL fEnable)
{
    DEBUG_FUNCTION_NAME(_T("FComDTR"));

    DebugPrintEx(DEBUG_MSG,"FComDTR = %d", fEnable);

    if(MyGetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG, "Before: %02x", pTG->Comm.dcb.fDtrControl);

    pTG->Comm.dcb.fDtrControl = (fEnable ? DTR_CONTROL_ENABLE : DTR_CONTROL_DISABLE);

    if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"After: %02x", pTG->Comm.dcb.fDtrControl);

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR, "Can't Set/Get DCB");
    FComGetError(pTG);
    return FALSE;
}

BOOL FComClose(PThrdGlbl pTG)
{
    // Note: even if FComClose fails, pTG->Comm.nCid, pTG->Comm.fCommOpen,
    //                                      and pTG->Comm.fExternalHandle are all reset.
    int nRet;       // MUST be 16bit in WIN16 and 32bit in WIN32
    BOOL fRet = TRUE;

    DEBUG_FUNCTION_NAME(_T("FComClose"));

    DebugPrintEx(   DEBUG_MSG, 
                    "Closing Comm pTG->Comm.nCid=%d", 
                    pTG->Comm.nCid);
    //
    // handoff
    //
    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        My2ndCloseComm(pTG->Comm.nCid, &nRet);
        goto lEnd;
    }

    ST_FC(D_FComCheck(pTG, pTG->Comm.nCid));

#if 1
    // We flush our internal buffer here...
    if (pTG->Comm.lpovrCur)
    {
        int nNumWrote; // Must be 32bits in WIN32
        if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
        {
            // error...
            DebugPrintEx(DEBUG_ERR, "1st ov_write failed");
        }
        BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                  || pTG->Comm.lpovrCur->eState==eIO_PENDING);
        pTG->Comm.lpovrCur=NULL;
        DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
    }
    
    ov_drain(pTG, FALSE);
#endif


#ifdef METAPORT
    if (1) // RSL pTG->Comm.fExternalHandle)
    {
        // Here we will restore settings to what it was when we
        // took over the port. Currently (9/23/94) we (a) restore the
        // DCB to pTG->Comm.dcbOrig and (b) If DTR was originally ON,
        // try to sync the modem to
        // the original speed by issueing "AT" -- because unimodem does
        // only a half-hearted attempt at synching before giving up.

#ifdef ADAPTIVE_ANSWER
        if(pTG->Comm.fStateChanged && (!pTG->Comm.fEnableHandoff || !pTG->Comm.fDataCall))
#else // !ADAPTIVE_ANSWER
        if(pTG->Comm.fStateChanged)
#endif // !ADAPTIVE_ANSWER
        {
            if (MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcbOrig)))
            {
                DebugPrintEx(   DEBUG_WRN,
                                "Couldn't restore state.  Err=0x%lx",
                                (unsigned long) GetLastError());
            }

            DebugPrintEx(   DEBUG_MSG, 
                            "restored DCB to Baud=%d, fOutxCtsFlow=%d, "
                            " fDtrControl=%d, fOutX=%d",
                            pTG->Comm.dcbOrig.BaudRate,
                            pTG->Comm.dcbOrig.fOutxCtsFlow,
                            pTG->Comm.dcbOrig.fDtrControl,
                            pTG->Comm.dcbOrig.fOutX);

            pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcbOrig.BaudRate;

            if (pTG->Comm.dcbOrig.fDtrControl==DTR_CONTROL_ENABLE)
            {
                // Try to pre-sync modem at new speed before we hand
                // it back to TAPI. Can't call iiSyncModemDialog here because
                // it's defined at a higher level. We don't really care
                // to determine if we get an OK response anyway...

#define AT              "AT"
#define cr              "\r"

#define  iSyncModemDialog2(pTG, s, l, w1, w2)\
iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

                if (!iSyncModemDialog2(pTG, AT cr,sizeof(AT cr)-1,"OK", "0")) 
                {
                    DebugPrintEx(DEBUG_ERR,"couldn't sync AT command");
                }
                else 
                {
                    DebugPrintEx(DEBUG_MSG,"Sync AT command OK");
                   // We flush our internal buffer here...
                   if (pTG->Comm.lpovrCur)
                   {
                       int nNumWrote; // Must be 32bits in WIN32
                       if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
                       {
                            // error...
                            DebugPrintEx(DEBUG_ERR, "2nd ov_write failed");
                       }
                       BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                                 || pTG->Comm.lpovrCur->eState==eIO_PENDING);
                       pTG->Comm.lpovrCur=NULL;
                       DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
                   }
                   ov_drain(pTG, FALSE);
                }
            }
        }
        pTG->Comm.fStateChanged=FALSE;
#ifdef ADAPTIVE_ANSWER
        pTG->Comm.fDataCall=FALSE;
#endif // ADAPTIVE_ANSWER

    }
    // RSL else
#endif // METAPORT
    {
        DebugPrintEx(DEBUG_MSG,"Closing Comm pTG->Comm.nCid=%d.", pTG->Comm.nCid);
        // FComDTR(pTG, FALSE);         // drop DTR before closing port

        My2ndCloseComm(pTG->Comm.nCid, &nRet);
        if(nRet)
        {
#ifdef DEBUG
            D_PrintIE(nRet);
#endif
            FComGetError(pTG);
            fRet=FALSE;
        }
    }


#ifndef MON3 //!MON3
#ifdef MON
    PutMonBufs(pTG);
#endif
#endif //!MON3


lEnd:

#ifdef WIN32
    if (pTG->Comm.ovAux.hEvent) CloseHandle(pTG->Comm.ovAux.hEvent);
    _fmemset(&pTG->Comm.ovAux, 0, sizeof(pTG->Comm.ovAux));
    ov_deinit(pTG);
#endif

    pTG->Comm.nCid = (-1);
    pTG->Comm.fCommOpen = FALSE;

#ifdef METAPORT
    pTG->Comm.fExternalHandle=FALSE;
#endif

#ifdef WIN32
    pTG->Comm.fDoOverlapped=FALSE;
#endif

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////////////////////
BOOL
T30ComInit  
(
    PThrdGlbl pTG,
    HANDLE   hComm
)
{

    DEBUG_FUNCTION_NAME(("T30ComInit"));

    if (pTG->fCommInitialized) 
    {
        goto lSecondInit;
    }


    pTG->Comm.fDataCall=FALSE;

#ifdef METAPORT
    BG_CHK(!pTG->Comm.fCommOpen && !pTG->Comm.fExternalHandle && !pTG->Comm.fStateChanged);
#endif
    BG_CHK(!pTG->Comm.ovAux.hEvent);

    DebugPrintEx(DEBUG_MSG,"Opening Comm Port=%x", hComm);

    pTG->CommCache.dwMaxSize = 4096;

    ClearCommCache(pTG);
    pTG->CommCache.fReuse = 0;

    DebugPrintEx(   DEBUG_MSG,
                    "OPENCOMM: bufs in=%d out=%d", 
                    COM_INBUFSIZE, 
                    COM_OUTBUFSIZE);

    pTG->Comm.nCid = (LONG_PTR) hComm;

    if(pTG->Comm.nCid < 0)
    {
        DebugPrintEx(DEBUG_ERR,"OPENCOMM failed. nRet=%d", pTG->Comm.nCid);
        //DEBUGSTMT(D_PrintIE(pTG->Comm.nCid));
        goto error;
    }

    DebugPrintEx(DEBUG_MSG,"OPENCOMM succeeded nCid=%d", pTG->Comm.nCid);
    pTG->Comm.fCommOpen = TRUE;
    pTG->Comm.cbInSize = COM_INBUFSIZE;
    pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

    // Reset Comm timeouts...
    {
        COMMTIMEOUTS cto;
        _fmemset(&cto, 0, sizeof(cto));

        // Out of curiosity, see what they are set at currently...
        if (!GetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto))
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "GetCommTimeouts fails for handle=0x%lx",
                            (unsigned long) pTG->Comm.nCid);
        }
        else
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "GetCommTimeouts: cto={%lu, %lu, %lu, %lu, %lu}",
                            (unsigned long) cto.ReadIntervalTimeout,
                            (unsigned long) cto.ReadTotalTimeoutMultiplier,
                            (unsigned long) cto.ReadTotalTimeoutConstant,
                            (unsigned long) cto.WriteTotalTimeoutMultiplier,
                            (unsigned long) cto.WriteTotalTimeoutConstant);
        }

        cto.ReadIntervalTimeout =  READ_INTERVAL_TIMEOUT;
        cto.ReadTotalTimeoutMultiplier =  READ_TOTAL_TIMEOUT_MULTIPLIER;
        cto.ReadTotalTimeoutConstant =  READ_TOTAL_TIMEOUT_CONSTANT;
        cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
        cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
        if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto))
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "SetCommTimeouts fails for handle=0x%lx",
                            (unsigned long) pTG->Comm.nCid);
        }
    }

    pTG->Comm.fCommOpen = TRUE;

    pTG->Comm.cbInSize = COM_INBUFSIZE;
    pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

    _fmemset(&(pTG->Comm.comstat), 0, sizeof(COMSTAT));

    if(MyGetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
            goto error2;

#ifdef METAPORT
    pTG->Comm.dcbOrig = pTG->Comm.dcb; // structure copy.
    pTG->Comm.fStateChanged=TRUE;
#endif



lSecondInit:


    // Use of 2400/ 8N1 and 19200 8N1 is not actually specified
    // in Class1, but seems to be adhered to be universal convention
    // watch out for modems that break this!

    if (pTG->SerialSpeedInit) 
    {
       pTG->Comm.dcb.BaudRate = pTG->SerialSpeedInit;
    }
    else 
    {
       pTG->Comm.dcb.BaudRate = 57600;     // default              
    }

    pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcb.BaudRate;

    pTG->Comm.dcb.ByteSize       = 8;
    pTG->Comm.dcb.Parity         = NOPARITY;
    pTG->Comm.dcb.StopBits       = ONESTOPBIT;

    pTG->Comm.dcb.fBinary        = 1;
    pTG->Comm.dcb.fParity        = 0;

    /************************************
            Pins assignments, & Usage

            Protective Gnd                                  --              1
            Transmit TxD (DTE to DCE)               3               2
            Recv     RxD (DCE to DTE)               2               3
            RTS (Recv Ready--DTE to DCE)    7               4
            CTS (TransReady--DCE to DTE)    8               5
            DSR                      (DCE to DTE)           6               6
            signal ground                                   5               7
            CD                       (DCE to DTR)           1               8
            DTR                      (DTE to DCE)           4               20
            RI                       (DCE to DTE)           9               22

            Many 9-pin adaptors & cables use only 6 pins, 2,3,4,5, and 7.
            We need to worry about this because some modems actively
                    use CTS, ie. pin 8.
            We don't care about RI and CD (Unless a really weird modem
            uses CD for flow control). We ignore DSR, but some (not so
            weird, but not so common either) modems use DSR for flow
            control.

            Thought :: Doesn't generate DSR. Seems to tie CD and CTS together
            DOVE    :: Generates only CTS. But the Appletalk-9pin cable
                               only passes 1-5 and pin 8.
            GVC             :: CTS, DSR and CD
    ************************************/

            // CTS -- dunno. There is some evidence that the
            // modem actually uses it for flow control
    
    
    if (pTG->fEnableHardwareFlowControl) 
    {
       pTG->Comm.dcb.fOutxCtsFlow = 1;      // Using it hangs the output sometimes...
    }
    else 
    {
       pTG->Comm.dcb.fOutxCtsFlow = 0;
    }
                                                                            // Try ignoring it and see if it works?
    pTG->Comm.dcb.fOutxDsrFlow = 0;      // Never use this??

    pTG->Comm.dcb.fRtsControl    = RTS_CONTROL_ENABLE;   // Current code seems to leave this ON
    pTG->Comm.dcb.fDtrControl    =  (pTG->Comm.fExternalHandle)
                                      ?     pTG->Comm.dcbOrig.fDtrControl
                                      :     DTR_CONTROL_DISABLE;
                                                      // If external handle, we preserve the
                                                      // previous state, else we
                                                      // keep it off until we need it.

    pTG->Comm.dcb.fErrorChar             = 0;
    pTG->Comm.dcb.ErrorChar              = 0;
    // Can't change this cause SetCommState() resets hardware.
    pTG->Comm.dcb.EvtChar                = ETX;          // set this when we set an EventWait

    pTG->Comm.dcb.fOutX          = 0;    // Has to be OFF during HDLC recv phase
    pTG->Comm.dcb.fInX           = 0;    // Will this do any good??
                                                            // Using flow-control on input is only a good
                                                            // idea if the modem has a largish buffer
    pTG->Comm.dcb.fNull          = 0;


    pTG->Comm.dcb.XonChar        = CTRL_Q;
    pTG->Comm.dcb.XoffChar       = CTRL_S;
    pTG->Comm.dcb.XonLim         = 100;                  // Need to set this when BufSize is set
    pTG->Comm.dcb.XoffLim        = 50;                   // Set this when BufSize is set
            // actually we *never* use XON/XOFF in recv, so don't worry about this
            // right now. (Later, when we have smart modems with large buffers, &
            // we are worried about our ISR buffer filling up before our windows
            // process gets run, we can use this). Some tuning will be reqd.
    pTG->Comm.dcb.EofChar                = 0;

    pTG->Comm.dcb.fAbortOnError  = 0;   // RSL don't fail if minor problems

    if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error2;

    if (pTG->fCommInitialized) 
    {
       return TRUE;
    }

#ifdef METAPORT
    pTG->Comm.fStateChanged=TRUE;
#endif

    MySetCommMask(pTG->Comm.nCid, 0);                            // all events off

    BG_CHK(!pTG->Comm.lpovrCur);
    pTG->Comm.lpovrCur=NULL;

    _fmemset(&pTG->Comm.ovAux,0, sizeof(pTG->Comm.ovAux));
    pTG->Comm.ovAux.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (pTG->Comm.ovAux.hEvent==NULL)
    {
        DebugPrintEx(DEBUG_ERR, "FComOpen: couldn't create event");
        goto error2;
    }
    if (!ov_init(pTG))
    {
        CloseHandle(pTG->Comm.ovAux.hEvent);
        pTG->Comm.ovAux.hEvent=0;
        goto error2;
    }

    return TRUE;

error:
    //DEBUGSTMT(D_PrintIE(pTG->Comm.nCid));        
error2:

    DebugPrintEx(DEBUG_ERR, "FComOpen failed");
    FComGetError(pTG);
    if (pTG->Comm.fCommOpen)
    {
        FComClose(pTG);
        BG_CHK(!pTG->Comm.fCommOpen);
#ifdef METAPORT
        BG_CHK(!pTG->Comm.fExternalHandle && !pTG->Comm.fStateChanged);
#endif
    }
    return FALSE;
}

BOOL FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate)
{
    DEBUG_FUNCTION_NAME(("FComSetBaudRate"));

    DebugPrintEx(DEBUG_MSG,"Setting BAUDRATE=%d",uwBaudRate);

    if(MyGetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    pTG->Comm.dcb.BaudRate  = uwBaudRate;
    pTG->CurrentSerialSpeed = uwBaudRate;

    if(MySetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR, "Set Baud Rate --- Can't Get/Set DCB");
    FComGetError(pTG);
    return FALSE;
}

BOOL FComInXOFFHold(PThrdGlbl pTG)
{
    int     err;    // _must_ be 32bits in Win32 

    DEBUG_FUNCTION_NAME(_T("FComInXOFFHold"));
    GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
#ifdef DEBUG
    if(err)
        D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
#endif

#ifndef WIN32
    BG_CHK(!(pTG->Comm.comstat.status &
                            (CSTF_CTSHOLD|CSTF_DSRHOLD|CSTF_RLSDHOLD)));
    if((pTG->Comm.comstat.status & CSTF_XOFFHOLD) != 0)
#else //!WIN32
    BG_CHK(!(pTG->Comm.comstat.fCtsHold || pTG->Comm.comstat.fDsrHold || pTG->Comm.comstat.fRlsdHold));
    if(pTG->Comm.comstat.fXoffHold)
#endif //!WIN32
    {
        DebugPrintEx(DEBUG_MSG,"In XOFF hold");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL FComXon(PThrdGlbl pTG, BOOL fEnable)
{

    DEBUG_FUNCTION_NAME(_T("FComXon"));

     if (pTG->fEnableHardwareFlowControl) 
     {
        DebugPrintEx(   DEBUG_MSG, 
                        "FComXon = %d IGNORED : h/w flow control", 
                        fEnable);
        return TRUE;
     }

    DebugPrintEx(DEBUG_MSG,"FComXon = %d",fEnable);

    // enables/disables flow control
    // returns TRUE on success, false on failure

    if(MyGetCommState( pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"FaxXon Before: %02x", pTG->Comm.dcb.fOutX);

    pTG->Comm.dcb.fOutX  = fEnable;

    if(MySetCommState(pTG->Comm.nCid, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"After: %02x",pTG->Comm.dcb.fOutX);
    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR,"Can't Set/Get DCB");
    FComGetError(pTG);
    return FALSE;
}

// queue=0 --> receiving queue
// queue=1 --> transmitting queue
void FComFlushQueue(PThrdGlbl pTG, int queue)
{
    int     nRet;
    DWORD   lRet;

    DEBUG_FUNCTION_NAME(_T("FComFlushQueue"));

    DebugPrintEx(DEBUG_MSG, "FlushQueue = %d", queue);
    ST_FC(D_FComCheck(pTG, pTG->Comm.nCid));
//RSL        ST_FC(D_FComDumpFlush(pTG, pTG->Comm.nCid, queue));
    BG_CHK(queue == 0 || queue == 1);

    if (queue == 1) 
    {
        DebugPrintEx(DEBUG_MSG,"ClearCommCache");
        ClearCommCache(pTG);
    }

    if(nRet = MyFlushComm(pTG->Comm.nCid, queue))
    {
#ifdef DEBUG
        D_PrintIE(nRet);
#endif
        DebugPrintEx(DEBUG_ERR,"FlushComm failed nRet=%d", nRet);
        FComGetError(pTG);
        // Throwing away errors that happen here.
        // No good reason for it!
    }
    if(queue == 1)
    {
        FComInFilterInit(pTG);
    }
    else // (queue == 0)
    {
        // Let's dump any stuff we may have in *our* buffer.
        if (pTG->Comm.lpovrCur && pTG->Comm.lpovrCur->dwcb)
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "Clearing NonNULL pTG->Comm.lpovrCur->dwcb=%lx",
                            (unsigned long) pTG->Comm.lpovrCur->dwcb);
            pTG->Comm.lpovrCur->dwcb=0;
            ov_unget(pTG, pTG->Comm.lpovrCur);
            pTG->Comm.lpovrCur=NULL;
        }

        // Lets "drain" -- should always return immediately, because
        // we have just purged the output comm buffers.
        if (pTG->Comm.fovInited) 
        {
            DebugPrintEx(DEBUG_MSG," before ov_drain");
            ov_drain(pTG, FALSE);
            DebugPrintEx(DEBUG_MSG," after ov_drain");
        }

        // just incase it got stuck due to a mistaken XOFF
        if(lRet = MySetXON(pTG->Comm.nCid))
        {
            // Returns the comm error value CE!!
            // DEBUGSTMT(D_PrintIE(nRet));
            DebugPrintEx(DEBUG_MSG,"EscapeCommFunc(SETXON) returned %d", lRet);
            FComGetError(pTG);
        }
    }
}


#ifdef NTF

#define EV_ALL (EV_BREAK|EV_CTS|EV_CTSS|EV_DSR|EV_ERR|EV_PERR|EV_RING|EV_RLSD \
                                |EV_DSRS|EV_RLSDS|EV_RXCHAR|EV_RXFLAG|EV_TXEMPTY|EV_RINGTE)


#define         ALWAYSEVENTS    (EV_BREAK | EV_ERR)

        // errors + TXEMPTY. Ignore incoming chars
#define         DRAINEVENTS             (ALWAYSEVENTS | EV_TXEMPTY)
        // errors and TXEMPTY (also an error!)
#define         WRITEEVENTS             (ALWAYSEVENTS | EV_TXEMPTY)
        // errors and RXCHAR
#define         READLINEEVENTS  (ALWAYSEVENTS | EV_RXCHAR)
        // errors and RXFLAG (EvtChar already set to ETX)
#define         READBUFEVENTS   (ALWAYSEVENTS | EV_RXFLAG)


BOOL FComEnableNotify(PThrdGlbl pTG, UWORD uwInTrig, UWORD uwOutTrig, UWORD events)
{
    HANDLE  h;

    DEBUG_FUNCTION_NAME(_T("FComEnableNotify"));

    // Used incrementally, so don't clear events!
    DebugPrintEx(   DEBUG_MSG,
                    "EnableCommNotif(hwnd=%d uwIn=%d uwOUt=%d events=%d)", 
                    pTG->FComModem.hwndNotify, 
                    uwInTrig, 
                    uwOutTrig, 
                    events);

    h = pTG->FComModem.hwndNotify;

    if (!h)
    {
        DebugPrintEx(DEBUG_ERR, "Can't set Notif -- hwnd=%d", h);
        return TRUE;    // Continue anyway
    }

    if((pTG->Comm.lpEventWord = SetCommEventMask(pTG, pTG->Comm.nCid, events)) &&
            EnableCommNotification(pTG, pTG->Comm.nCid, h, uwInTrig, uwOutTrig))
    {
        // Both return non-zero on success
        DebugPrintEx(   DEBUG_MSG,
                        "ECN succ: %d %d %d %d", 
                        pTG->Comm.nCid, 
                        h, 
                        uwInTrig, 
                        uwOutTrig);
        return TRUE;
    }
    else
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "ECN fail: %d %d %d %d", 
                        pTG->Comm.nCid, 
                        h, 
                        uwInTrig, 
                        uwOutTrig);
        FComGetError(pTG);
        return FALSE;
    }
}
#endif  // NTF

/***************************************************************************
        Name      :     FComDrain(BOOL fLongTO, BOOL fDrainComm)
        Purpose   :     Drain internal buffers. If fDrainComm, wait for Comm
                                ISR Output buffer to drain.
                                Returns when buffer is drained or if no progress is made
                                for DRAINTIMEOUT millisecs. (What about XOFFed sections?
                                Need to set     Drain timeout high enough)
        Parameters:
        Returns   :     TRUE on success (buffer drained)
                                FALSE on failure (error or timeout)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it in a new incarnation
***************************************************************************/

// This timeout has to be low at time and high at others. We want it low
// so we don't spend too much time trying to talk to a non-existent modem
// during Init/Setup. However in PhaseC, when the timer expires all we
// do is abort and kill everything. So it serves no purpose to make it
// too low. With the Hayes ESP FIFO card long stretches can elapse without
// any visible "progress", so we fail with that card because we think
// "no progress" is being made


//    So....make it short for init/install
// but not too short. Some cmds (e.g. AT&F take a long time)
// Used to be 800ms & seemed to work then, so leave it at that
#define SHORT_DRAINTIMEOUT      800

//    So....make it long for PhaseC
// 4secs should be about long enough
#define LONG_DRAINTIMEOUT       4000

BOOL FComDrain(PThrdGlbl pTG, BOOL fLongTO, BOOL fDrainComm)
{
    WORD    wTimer = 0;
    UWORD   cbPrevOut = 0xFFFF;
    BOOL    fStuckOnce=FALSE;
    BOOL    fRet=FALSE;

    DEBUG_FUNCTION_NAME(_T("FComDrain"));

    ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));
    /** BG_CHK(uwCurrMsg == 0); **/

    // We flush our internal buffer here...
    if (pTG->Comm.lpovrCur)
    {
        int nNumWrote; // Must be 32bits in WIN32
        if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
            goto done;

        BG_CHK  (pTG->Comm.lpovrCur->eState==eFREE
                  || pTG->Comm.lpovrCur->eState==eIO_PENDING);
        pTG->Comm.lpovrCur=NULL;
        DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
    }

    if (!fDrainComm)
    {
        fRet=TRUE; 
        goto done;
    }

    // +++ Here we drain all our overlapped events..
    // If we setup the system comm timeouts properly, we
    // don't need to do anything else, except for the XOFF/XON
    // stuff...
    fRet =  ov_drain(pTG, fLongTO);
    goto done;

done:

    return fRet;  //+++ was (cbOut == 0);
}

/***************************************************************************
        Name      :     FComDirectWrite(, lpb, cb)
        Purpose   :     Write cb bytes starting from lpb to pTG->Comm. If Comm buffer
                                is full, set up notifications and timers and wait until space
                                is available. Returns when all bytes have been written to
                                the Comm buffer or if no progress is made
                                for WRITETIMEOUT millisecs. (What about XOFFed sections?
                                Need to set     timeout high enough)
        Parameters:     , lpb, cb
        Returns   :     Number of bytes written, i.e. cb on success and <cb on timeout,
                                or error.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// This is WRONG -- see below!!
// totally arbitrary should be no more than the time as it would
// take to write WRITEQUANTUM out at the fastest speed
// (say 14400 approx 2 bytes/ms)
// #define      WRITETIMEOUT    min((WRITEQUANTUM / 2), 200)

// This timeout was too low. We wanted it low so we don't spend too much
// time trying to talk to a non-existent modem during Init/Setup. But in
// those cases we _never_ reach full buffer, so we don't wait here
// we wait in FComDrain(). Here we wait _only_ in PhaseC, so when the
// timer expires all we do is abort and kill everything. So it serves
// no purpose to make it too low. With the Hayes ESP FIFO card long
// stretches can elapse without any visible "progress", so we fail with
// that card because we think "no progress" is being made
//    So....make it long
// 2secs should be about long enough
#define         WRITETIMEOUT    2000


UWORD FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb)
{
    DWORD   cbLeft = cb;

    DEBUG_FUNCTION_NAME(_T("FComDirectWrite"));

//    D_SafePrint(pTG, lpb, cb);
#ifdef LOWLOG
    if (cb<50 && cb>1)
    {
        PSSLogEntry(PSS_MSG, 3, "%4d \"%s\"", cb, lpb);
    }
    else if (cb>1)
    {
        PSSLogEntry(PSS_MSG, 3, "%4d <data omitted>", cb);
    }
#endif // LOWLOG

    ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));

    while(cbLeft)
    {
        DWORD dwcbCopy;
        DWORD dwcbWrote;
        int err;

        if (!pTG->Comm.lpovrCur)
        {
            pTG->Comm.lpovrCur = ov_get(pTG);
            if (!pTG->Comm.lpovrCur) goto error;
            BG_CHK(!pTG->Comm.lpovrCur->dwcb);
        }
        BG_CHK(pTG->Comm.lpovrCur->eState==eALLOC);
        BG_CHK(OVBUFSIZE>=pTG->Comm.lpovrCur->dwcb);

        dwcbCopy = OVBUFSIZE-pTG->Comm.lpovrCur->dwcb;

        if (dwcbCopy>cbLeft) dwcbCopy = cbLeft;

        // Copy as much as we can to the overlapped buffer...
        _fmemcpy(pTG->Comm.lpovrCur->rgby+pTG->Comm.lpovrCur->dwcb, lpb, dwcbCopy);
        cbLeft-=dwcbCopy; pTG->Comm.lpovrCur->dwcb+=dwcbCopy; lpb+=dwcbCopy;

        // Let's always update comstat here...
        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
#ifdef DEBUG
        if(err)
            D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
#endif

        DebugPrintEx(   DEBUG_MSG,
                        "OutQ has %d fDoOverlapped=%d",
                        pTG->Comm.comstat.cbOutQue, 
                        pTG->Comm.fDoOverlapped);

        // We write to comm if our buffer is full or the comm buffer is
        // empty or if we're not in overlapped mode...
        if (!pTG->Comm.fDoOverlapped ||
                pTG->Comm.lpovrCur->dwcb>=OVBUFSIZE || !pTG->Comm.comstat.cbOutQue)
        {
            BOOL fRet = ov_write(pTG, pTG->Comm.lpovrCur, &dwcbWrote);
            BG_CHK(    pTG->Comm.lpovrCur->eState==eIO_PENDING
                            || pTG->Comm.lpovrCur->eState==eFREE);
            pTG->Comm.lpovrCur=NULL;
            if (!fRet) 
                goto error;
        }

    } // while (cbLeft)

    return cb;

error:
    return 0;

}

/***************************************************************************
        Name      :     FComFilterReadLine(, lpb, cbSize, pto)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                                lpb. If Comm buffer is empty, set up notifications and timers
                                and wait until characters are available.

                                Filters out DLE characters. i.e DLE-DLE is reduced to
                                a single DLE, DLE ETX is left intact and DLE-X is deleted.

                                Returns success (+ve bytes count) when CR-LF has been
                                encountered, and returns failure (-ve bytes count).
                                when either (a) cbSize bytes have been read (i.e. buffer is
                                full) or (b) PTO times out or an error is encountered.

                                It is critical that this function never returns a
                                timeout, as long as data
                                is still pouring/trickling in. This implies two things
                                (a) FIRST get all that is in the InQue (not more than a
                                line, though), THEN check the timeout.
                                (b) Ensure that at least 1 char-arrival-time at the
                                slowest Comm speed passes between the function entry
                                point and the last time we check for a byte, or between
                                two consecutive checks for a byte, before we return a timeout.

                                Therefor conditions to return a timeout are Macro timeout
                                over and inter-char timeout over.

                                In theory the slowest speed we need to worry about is 2400,
                                because that's the slowest we run the Comm at, but be paranoid
                                and assume the modem sends the chars at the same speed that
                                they come in the wire, so slowest is now 300. 1 char-arrival-time
                                is now 1000 / (300/8) == 26.67ms.

                                If pto expires, returns error, i.e. -ve of the number of
                                bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                                of bytes read on timeout. 0 is a timeout error with no bytes
                                read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// totally arbitrary
#define         READLINETIMEOUT         50

#define         ONECHARTIME                     (30 * 2)                // see above *2 to be safe

// void WINAPI OutputDebugStr(LPSTR);
// char szJunk[200];




// Read a line of size no more than cbSize to lpb
// 
#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

SWORD FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead)
{
    WORD           wTimer = 0;
    UWORD          cbIn = 0, cbGot = 0;
    LPB            lpbNext;
    BOOL           fPrevDLE = 0;
    SWORD          i, beg;
    TO to;

    DEBUG_FUNCTION_NAME(_T("FComFilterReadLine"));

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cb=%d timeout=%lu", 
                    lpb, 
                    cbSize, 
                    lptoRead->ulTimeout);
    BG_CHK(cbSize>2);
    ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));

    cbSize--;               // make room for terminal NULL
    lpbNext = lpb;  // we write the NULL to *lpbNext, so init this NOW!
    cbGot = 0;              // return value (even err return) is cbGot. Init NOW!!
    fPrevDLE=0;

    pTG->fLineTooLongWasIgnored = FALSE;
    //
    // check the cache first.
    // Maybe the cache contains data

    if ( ! pTG->CommCache.dwCurrentSize) 
    {
        DebugPrintEx(DEBUG_MSG,"Cache is empty. Resetting comm cache.");
        ClearCommCache(pTG);
        // Try to fill the cache
        if (!FComFilterFillCache(pTG, cbSize, lptoRead)) 
        {
            DebugPrintEx(DEBUG_ERR,"FillCache failed");
            goto error;
        }
    }

    while (1) 
    {
        if ( ! pTG->CommCache.dwCurrentSize) 
        {
            DebugPrintEx(DEBUG_ERR, "Cache is empty after FillCache");
            goto error;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "Cache: size=%d, offset=%d", 
                        pTG->CommCache.dwCurrentSize, 
                        pTG->CommCache.dwOffset);

        lpbNext = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset;

        if (pTG->CommCache.dwCurrentSize >= 3) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "1=%x 2=%x 3=%x 4=%x 5=%x 6=%x 7=%x 8=%x 9=%x /"
                            " %d=%x, %d=%x, %d=%x",
                            *lpbNext, 
                            *(lpbNext+1), 
                            *(lpbNext+2), 
                            *(lpbNext+3), 
                            *(lpbNext+4), 
                            *(lpbNext+5), 
                            *(lpbNext+6), 
                            *(lpbNext+7), 
                            *(lpbNext+8),
                            pTG->CommCache.dwCurrentSize-3, 
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-3),
                            pTG->CommCache.dwCurrentSize-2, 
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-2),
                            pTG->CommCache.dwCurrentSize-1,
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-1) );
        }
        else 
        {
            DebugPrintEx(DEBUG_MSG,"1=%x 2=%x", *lpbNext, *(lpbNext+1) );
        }

        for (i=0, beg=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) 
        {
            if (i > 0 ) 
            { // check from the second char in the buffer for CR + LF.
               if ( ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i - 1) == CR ) &&
                    ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i)     == LF ) )  
               {
                  if ( i - beg >= cbSize)  
                  {
                     // line too long.  try next one.
                     DebugPrintEx(  DEBUG_ERR, 
                                    "Line len=%d is longer than bufsize=%d "
                                    " Found in cache pos=%d, CacheSize=%d, Offset=%d",
                                    i-beg, 
                                    cbSize, 
                                    i+1, 
                                    pTG->CommCache.dwCurrentSize, 
                                    pTG->CommCache.dwOffset);
                     beg = i + 1;
                     pTG->fLineTooLongWasIgnored = TRUE;
                     continue;
                  }

                  // found the line.
                  CopyMemory (lpb, (pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + beg), (i - beg + 1) );

                  pTG->CommCache.dwOffset += (i+1);
                  pTG->CommCache.dwCurrentSize -= (i+1);
                  *(lpb+i-beg+1) = '\0'; // Make sure that the line is null terminated

                  DebugPrintEx( DEBUG_MSG, 
                                "Found in cache pos=%d, CacheSize=%d, Offset=%d",
                                i+1, 
                                pTG->CommCache.dwCurrentSize, 
                                pTG->CommCache.dwOffset);

#ifdef LOWLOG
                  if (i-beg+1 > 2)
                  {
                      PSSLogEntry(PSS_MSG, 3, "%4d                 \"%s\"", i-beg+1, lpb);
                  }
#endif // LOWLOG

                  // return how much bytes in the line
                  return ( i-beg+1 );
               }
           }
        }

        // we get here if we didn't find CrLf in Cache
        DebugPrintEx(DEBUG_MSG,"Cache wasn't empty but we didn't find CrLf");

        // if cache too big (and we have not found anything anyway) --> clean it

        if (pTG->CommCache.dwCurrentSize >= cbSize) 
        {
           DebugPrintEx(DEBUG_MSG, "ClearCommCache");
           ClearCommCache(pTG);
        }
        else if ( ! pTG->CommCache.dwCurrentSize) 
        {
           DebugPrintEx(DEBUG_MSG,"Cache is empty. Resetting comm cache.");
           ClearCommCache(pTG);
        }

        to.ulStart = 0;
        to.ulTimeout = 0;
        to.ulEnd = 500;
        if ( ! FComFilterFillCache(pTG, cbSize, &to/*lptoRead*/) ) 
        {
            DebugPrintEx(DEBUG_ERR, "FillCache failed");
            goto error;
        }
    }

error:
    ClearCommCache(pTG);
    return (0);

}


// Read from the comm port.
// The input is written to 'the end' of pTG->CommCache.lpBuffer buffer.
// returns TRUE on success, FALSE - otherwise.
BOOL  FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead)
{
    WORD             wTimer = 0;
    UWORD            cbGot = 0, cbAvail = 0;
    DWORD            cbRequested = 0;
    char             lpBuffer[4096]; // ATTENTION: We do overlapped read into the stack!!
    LPB              lpbNext;
    int              nNumRead;       // _must_ be 32 bits in Win32!!
    LPOVERLAPPED     lpOverlapped;
    COMMTIMEOUTS     cto;
    DWORD            dwLastErr;
    DWORD            dwTimeoutRead;
    char             *pSrc;
    char             *pDest;
    DWORD            i, j;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;

    DEBUG_FUNCTION_NAME(_T("FComFilterFillCache"));

    HandlesArray[1] = pTG->AbortReqEvent;

    dwTimeoutRead = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);

    lpbNext = lpBuffer;
    
    DebugPrintEx(   DEBUG_MSG, 
                    "cb=%d to=%d",
                    cbSize, 
                    dwTimeoutRead);

    // we want to request the read such that we will be back
    // no much later than dwTimeOut either with the requested
     // amount of data or without it.

    cbRequested = cbSize;

    // use COMMTIMEOUTS to detect there are no more data

    cto.ReadIntervalTimeout =  50;   // 30 ms is during negotiation frames; del(ff, 2ndchar> = 54 ms with USR 28.8
    cto.ReadTotalTimeoutMultiplier =  0;
    cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY*/
    cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
    cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
    if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto)) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetCommTimeouts fails for handle %lx , le=%x",
                        (unsigned long) pTG->Comm.nCid, 
                        GetLastError());
    }

    lpOverlapped =  &pTG->Comm.ovAux;

    (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                        (lpOverlapped)->OffsetHigh = 0;

    if ((lpOverlapped)->hEvent)
    {
        if (!ResetEvent((lpOverlapped)->hEvent))
        {
            BG_CHK(FALSE);
        }
    }
    
    nNumRead = 0;
    DebugPrintEx(   DEBUG_MSG,
                    "Before ReadFile Req=%d", 
                    cbRequested);

    if (! ReadFile( (HANDLE) pTG->Comm.nCid, lpbNext, cbRequested, &nNumRead, lpOverlapped) ) 
    {
        if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
        {
            //
            // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
            //
            if (pTG->fAbortRequested) 
            {
                if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                {
                    DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                    pTG->fAbortReqEventWasReset = TRUE;
                    if (!ResetEvent(pTG->AbortReqEvent))
                    {
                        BG_CHK(FALSE);
                    }
                }
                pTG->fUnblockIO = TRUE;
            }

            HandlesArray[0] = pTG->Comm.ovAux.hEvent;
            // Remeber that: HandlesArray[1] = pTG->AbortReqEvent;
            if (pTG->fUnblockIO) 
            {
                NumHandles = 1; // We don't want to be disturb by an abort
            }
            else 
            {
                NumHandles = 2;
            }

            if (pTG->fStallAbortRequest)
            {
                // this is used to complete a whole IO operation (presumably a short one)
                // when this flag is set, the IO won't be disturbed by the abort event
                // this flag should NOT be set for long periods of time since abort
                // is disabled while it is set.
                DebugPrintEx(DEBUG_MSG,"StallAbortRequest, do not abort here...");
                NumHandles = 1; // We don't want to be disturb by an abort
                pTG->fStallAbortRequest = FALSE;
            }

            DebugPrintEx(DEBUG_MSG,"Waiting for %d Event(s)",NumHandles);
            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT);
            DebugPrintEx(DEBUG_MSG,"WaitForMultipleObjects returned %d",WaitResult);

            if (WaitResult == WAIT_TIMEOUT) 
            {
                DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                goto error;
            }

            if (WaitResult == WAIT_FAILED) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "WaitForMultipleObjects FAILED le=%lx NumHandles=%d",
                                GetLastError(), 
                                NumHandles);
                goto error;
            }

            if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
            {
                // There was an abort by the user and that there are still pending reads
                // Lets cancell the pending I/O operations, and then wait for the overlapped results  
                pTG->fUnblockIO = TRUE;
                DebugPrintEx(DEBUG_MSG,"ABORTed");
                goto error;
            }

            // The IO operation was complete. Lets try to get the overlapped result.
            if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, lpOverlapped, &nNumRead, TRUE) ) 
            {
                DebugPrintEx(DEBUG_ERR, "GetOverlappedResult le=%x", GetLastError());
                if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) 
                {
                    DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x", GetLastError());
                }
                else 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d "
                                    " Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d "
                                    " In=%d Out=%d",
                                    dwErr, 
                                    ErrStat.fCtsHold, 
                                    ErrStat.fDsrHold, 
                                    ErrStat.fRlsdHold, 
                                    ErrStat.fXoffHold, 
                                    ErrStat.fXoffSent, 
                                    ErrStat.fEof,
                                    ErrStat.fTxim, 
                                    ErrStat.cbInQue, 
                                    ErrStat.cbOutQue);
                }
                goto errorWithoutCancel;
            }
        }
        else 
        {
            DebugPrintEx(DEBUG_ERR, "ReadFile");
            // We will do cancell pending IO, should we?
            goto errorWithoutCancel;
        }
    }
    else 
    {
        DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
    }

    DebugPrintEx(   DEBUG_MSG,
                    "After ReadFile Req=%d Ret=%d",
                    cbRequested, 
                    nNumRead);

    // How much bytes we actually have read
    cbAvail = (UWORD)nNumRead;

    if (!cbAvail) 
    {
        DebugPrintEx(DEBUG_ERR, "0 read");
        goto errorWithoutCancel;
    }

    // filter DLE stuff 

    pSrc  = lpbNext;
    pDest = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+ pTG->CommCache.dwCurrentSize;

    for (i=0, j=0; i<cbAvail; ) 
    {
        if ( *(pSrc+i) == DLE)  
        {
            if ( *(pSrc+i+1) == DLE ) 
            {
                *(pDest+j) =    DLE;
                j += 1;
                i += 2;
            }
            else if ( *(pSrc+i+1) == ETX ) 
            {
                *(pDest+j) = DLE;
                *(pDest+j+1) = ETX;
                j += 2;
                i += 2;
            }
            else 
            {
                i += 2;
            }
        }
        else
        {
            *(pDest+j) = *(pSrc+i);
            i++;
            j++;
        }
    }

    pTG->CommCache.dwCurrentSize += j;
    return TRUE;

error:
    
    if (!CancellPendingIO(pTG , (HANDLE) pTG->Comm.nCid , lpOverlapped , (LPDWORD) &nNumRead))
    {
        DebugPrintEx(DEBUG_ERR, "failed when call to CancellPendingIO");
    }

errorWithoutCancel:
    
    return FALSE;
}

/***************************************************************************
        Name      :     FComDirectReadBuf(, lpb, cbSize, lpto, pfEOF)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                                lpb. If Comm buffer is empty, set up notifications and timers
                                and wait until characters are available.

                                Returns when success (+ve byte count) either (a) cbSize
                                bytes have been read or (b) DLE-ETX has been encountered
                                (in which case *pfEOF is set to TRUE).

                                Does no filtering. Reads the Comm buffer in large quanta.

                                If lpto expires, returns error, i.e. -ve of the number of
                                bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                                of bytes read on timeout. 0 is a timeout error with no bytes
                                read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// +++ #define          READBUFQUANTUM          (pTG->Comm.cbInSize / 8)
// totally arbitrary
// +++ #define  READBUFTIMEOUT                  200

// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout

UWORD FComFilterReadBuf
(
    PThrdGlbl pTG, 
    LPB lpb, 
    UWORD cbSize, 
    LPTO lptoRead, 
    BOOL fClass2, 
    LPSWORD lpswEOF
)
{
    WORD             wTimer = 0;
    UWORD            cbGot = 0, cbAvail = 0;
    DWORD            cbRequested = 0;
    LPB              lpbNext;
    int              nNumRead = 0;       // _must_ be 32 bits in Win32!!
    LPOVERLAPPED     lpOverlapped;
    COMMTIMEOUTS     cto;
    DWORD            dwLastErr;
    DWORD            dwTimeoutRead;
    DWORD            cbFromCache = 0;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;

    DEBUG_FUNCTION_NAME(_T("FComFilterReadBuf"));
    HandlesArray[1] = pTG->AbortReqEvent;


    dwTimeoutRead = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cbSize=%d to=%d",
                    lpb, 
                    cbSize, 
                    dwTimeoutRead);

    BG_CHK((BOOL)pTG->Comm.dcb.fOutX == FALSE);
    // Dont want to take ^Q/^S from modem to
    // be XON/XOFF in the receive data phase!!

    // BG_CHK(lpb && cbSize>2 && lptoRead && lpswEOF && *lpswEOF == 0);
    BG_CHK(lpb && cbSize>3 && lptoRead && lpswEOF);

    *lpswEOF=0;

    ST_FC(D_FComPrint(pTG, pTG->Comm.nCid));
    // BG_CHK(Filter.fStripDLE);    // Always on
    /** BG_CHK(uwCurrMsg == 0); **/

    // Leave TWO spaces at start to make sure Out pointer will
    // never get ahead of the In pointer in StripBuf, even
    // if the last byte of prev block was DLE & first byte
    // of this one is SUB (i.e need to insert two DLEs in
    // output).
    // Save a byte at end for the NULL terminator (Why? Dunno...)

    lpb += 2;
    cbSize -= 3;

    cbRequested = cbSize;

    for(lpbNext=lpb;;) 
    {
        DebugPrintEx(   DEBUG_MSG,
                        "cbSize=%d cbGot=%d cbAvail=%d",
                        cbSize, 
                        cbGot, 
                        cbAvail);

        if((cbSize - cbGot) < cbAvail) 
        {
             cbAvail = cbSize - cbGot;
        }

        if( (!cbGot) && !checkTimeOut(pTG, lptoRead) ) 
        {
            // No chars available *and* lptoRead expired
            DebugPrintEx(   DEBUG_ERR, 
                            "ReadLn:Timeout %ld-toRd=%ld start=%ld",
                            GetTickCount(), 
                            lptoRead->ulTimeout, 
                            lptoRead->ulStart);
            goto failure;
        }

        // check Comm cache first (AT+FRH leftovers)
        if ( pTG->CommCache.fReuse && pTG->CommCache.dwCurrentSize ) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "CommCache will REUSE %d offset=%d 0=%x 1=%x",
                            pTG->CommCache.dwCurrentSize, 
                            pTG->CommCache.dwOffset,
                            *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset),
                            *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+1) );

            if ( pTG->CommCache.dwCurrentSize >= cbRequested)  
            {
                CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbRequested);

                pTG->CommCache.dwOffset +=  cbRequested;
                pTG->CommCache.dwCurrentSize -=  cbRequested;

                cbAvail =  (UWORD) cbRequested;
                cbRequested = 0;

                DebugPrintEx(DEBUG_MSG,"CommCache still left; no need to read");
                goto l_merge;
            }
            else 
            {
                cbFromCache =  pTG->CommCache.dwCurrentSize;
                CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbFromCache);
                ClearCommCache(pTG);
                cbRequested -= cbFromCache;
                DebugPrintEx(DEBUG_MSG,"CommCache used all %d",cbFromCache);
            }
        }

        // use COMMTIMEOUTS to detect there are no more data

        cto.ReadIntervalTimeout =  20;  // 0  RSL make 15 later
        cto.ReadTotalTimeoutMultiplier =  0;
        cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY
        cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
        cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
        if (!SetCommTimeouts((HANDLE) pTG->Comm.nCid, &cto)) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "SetCommTimeouts fails for handle %lx , le=%x",
                            (unsigned long) pTG->Comm.nCid, 
                            GetLastError());
        }

        lpOverlapped =  &pTG->Comm.ovAux;

        (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                            (lpOverlapped)->OffsetHigh = 0;

        if ((lpOverlapped)->hEvent)
        {
            if(!ResetEvent((lpOverlapped)->hEvent))
            {
                BG_CHK(FALSE);
            }
        }

        nNumRead = 0;
        
        DebugPrintEx(DEBUG_MSG,"Before ReadFile Req=%d",cbRequested);

        if (! ReadFile( (HANDLE) pTG->Comm.nCid, lpbNext+cbFromCache, cbRequested, &nNumRead, &pTG->Comm.ovAux) ) 
        {
            if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
            {
                // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
                //
                if (pTG->fAbortRequested) 
                {
                    if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                    {
                        DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                        pTG->fAbortReqEventWasReset = TRUE;
                        if (!ResetEvent(pTG->AbortReqEvent))
                        {
                            BG_CHK(FALSE);
                        }
                    }

                    pTG->fUnblockIO = TRUE;
                    *lpswEOF = -2;
                    return cbGot;
                }

                HandlesArray[0] = pTG->Comm.ovAux.hEvent;
                HandlesArray[1] = pTG->AbortReqEvent;

                if (pTG->fUnblockIO) 
                {
                    NumHandles = 1;
                }
                else 
                {
                    NumHandles = 2;
                }

                WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);

                if (WaitResult == WAIT_TIMEOUT) 
                {
                    DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                    ClearCommCache(pTG);
                    goto failure;
                }

                if (WaitResult == WAIT_FAILED) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "WaitForMultipleObjects FAILED le=%lx",
                                    GetLastError());

                    ClearCommCache(pTG);
                    goto failure;
                }

                if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
                {
                    // We have an abort and also there is pending IO ReadFile.
                    pTG->fUnblockIO = TRUE;
                    DebugPrintEx(DEBUG_MSG,"ABORTed");
                    ClearCommCache(pTG);
                    *lpswEOF = -2;
                    return cbGot;
                }

                if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, &pTG->Comm.ovAux, &nNumRead, TRUE) ) 
                {
                    DebugPrintEx(DEBUG_ERR, "GetOverlappedResult le=%x", GetLastError());
                    if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) 
                    {
                        DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x", GetLastError());
                    }
                    else 
                    {
                        DebugPrintEx(   DEBUG_WRN, 
                                        "ClearCommError dwErr=%x ErrSTAT: Cts=%d "
                                        "Dsr=%d Rls=%d XoffHold=%d XoffSent=%d "
                                        "fEof=%d Txim=%d In=%d Out=%d",
                                        dwErr, 
                                        ErrStat.fCtsHold, 
                                        ErrStat.fDsrHold, 
                                        ErrStat.fRlsdHold, 
                                        ErrStat.fXoffHold, 
                                        ErrStat.fXoffSent, 
                                        ErrStat.fEof,
                                        ErrStat.fTxim, 
                                        ErrStat.cbInQue, 
                                        ErrStat.cbOutQue);
                    }
                    goto failure;
                }
            }
            else 
            {
                DebugPrintEx(DEBUG_ERR, "ReadFile le=%x", dwLastErr);
                goto failure;
            }
        }
        else 
        {
            DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
        }

        DebugPrintEx(   DEBUG_MSG,
                        "After ReadFile Req=%d Ret=%d", 
                        cbRequested, 
                        nNumRead);

        cbAvail = (UWORD) (nNumRead + cbFromCache);

l_merge:
        // RSL PUTBACK INMON(pTG, lpbNext, cbAvail);

        if (!cbAvail) 
        {
            DebugPrintEx(DEBUG_MSG,"cbAvail = %d --> continue", cbAvail);
            continue;
        }
        // else we just drop through

        // try to catch COMM read problems

        DebugPrintEx(   DEBUG_MSG, 
                        "Just read %d bytes, from cache =%d, "
                        "log [%x .. %x], 1st=%x last=%x",
                        nNumRead, 
                        cbFromCache, 
                        pTG->CommLogOffset, 
                        (pTG->CommLogOffset+cbAvail),
                        *lpbNext, 
                        *(lpbNext+cbAvail-1) );

        // RSL TEMP. Check T4 problems.

        if (gT30.T4LogLevel) 
        {
            _lwrite(ghComLogFile, lpbNext, cbAvail);
        }

        pTG->CommLogOffset += cbAvail;

        // Strip the redunant chars. The return value is the number of chars we got.
        cbAvail = FComStripBuf(pTG, lpbNext-2, lpbNext, cbAvail, fClass2, lpswEOF);

        if (fClass2)
        {
            // for class 2 FComFilterReadBuf should keep cache for FComFilterReadLine
            if ((*lpswEOF)==-1)
            {
                // We got EOF, we should keep the extra data we got for FComFilterReadLine
                INT iExtraChars = nNumRead - cbAvail;
                // lpbNext points before the DLE-ETX in the end of the buffer.
                // any data should be after those two chars
                if (iExtraChars>2)
                {
                    iExtraChars -= 2;   // skipping the DLE - ETX in the buffer
                    DebugPrintEx(DEBUG_MSG,"There are %ld chars after EOF",iExtraChars);
                    CopyMemory (pTG->CommCache.lpBuffer,lpbNext+cbAvail+2, iExtraChars);
                    pTG->CommCache.dwOffset = 0;
                    pTG->CommCache.dwCurrentSize = iExtraChars;
                }
                else
                {
                    DebugPrintEx(DEBUG_MSG,"No extra data after EOF");
                }
            }
        }

        BG_CHK(*lpswEOF == 0 || *lpswEOF == -1 || *lpswEOF == 1);

        DebugPrintEx(DEBUG_MSG,"After FComStripBuf cbAvail=%ld",cbAvail);

        cbGot += cbAvail;
        lpbNext += cbAvail;

        // RSL 970123. Dont wanna loop if got anything.

        if ( (*lpswEOF != 0) || (cbGot > 0) )    
        {   // some eof or full buf
                goto done;
        }

    }
    BG_CHK(FALSE);

    *lpswEOF = -2;
    goto done;


failure:
    ;

//timeout:
    *lpswEOF = -3;
    // fall through to done

done:

//    DebugPrintEx(DEBUG_MSG,"exit: cbGot=%d swEOF=%d", cbGot, *lpswEOF);
#ifdef LOWLOG
    PSSLogEntry(PSS_MSG, 3, "%4d                 <data omitted>", cbGot);
#endif // LOWLOG
    return cbGot;
}

#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM


void FComCritical(PThrdGlbl pTG, BOOL x)
{
    DEBUG_FUNCTION_NAME(_T("FComCritical"));
    if (x)
    {
        pTG->Comm.bDontYield++;
    }
    else if (pTG->Comm.bDontYield)
    {
        pTG->Comm.bDontYield--;
    }
    else
    {
        BG_CHK(FALSE);
    }

#ifdef DEBUG
    if (pTG->Comm.bDontYield) 
    {
        DebugPrintEx(DEBUG_MSG,"Exiting NESTED");
    }
#endif
}

#if !defined(WFW) && !defined(WFWBG)

BOOL FComCheckRing(PThrdGlbl pTG)
{
    int     err;    // must be 32 bits in WIN32
    BOOL    fRet=0;
    COMSTAT comstatCheckActivity;

    DEBUG_FUNCTION_NAME(("FComCheckRing"));

    BG_CHK(pTG->Comm.nCid >= 0);
    GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &comstatCheckActivity);

    if(err)
    {
        DebugPrintEx(DEBUG_ERR, "NCUCheckRing: Got Comm Error %04x", err);
        D_GotError(pTG, pTG->Comm.nCid, err, &comstatCheckActivity);
    }

    fRet = (comstatCheckActivity.cbInQue > 0);

    // get rid of RING sitting in buffer,
    // or well wait until kingdom come with it
    // in some situations, like someone refuses to
    // answer or we have a full recv-filename-cache

    MyFlushComm(pTG->Comm.nCid, 0);
    MyFlushComm(pTG->Comm.nCid, 1);

    DebugPrintEx(DEBUG_MSG,"fRet=%d Q=%d", fRet, comstatCheckActivity.cbInQue);
    return fRet;
}

#endif //!WFWBG

BOOL
FComGetOneChar
(
   PThrdGlbl pTG,
   UWORD ch
)
{
    BYTE             rgbRead[10];    // must be 3 or more. 10 for safety
    // ATTENTION: We do overlapped read into the stack!!
    TO               toCtrlQ;
    int              nNumRead;               // _must_ be 32 bits in WIN32
    LPOVERLAPPED     lpOverlapped;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;
    DWORD            dwLastErr;
    SWORD            i;

    DEBUG_FUNCTION_NAME(("FComGetOneChar"));

    HandlesArray[1] = pTG->AbortReqEvent;

    //
    // check the cache first.
    //
    if ( ! pTG->CommCache.dwCurrentSize) 
    {
        DebugPrintEx(DEBUG_MSG, "Cache is empty. Resetting comm cache.");
        ClearCommCache(pTG);
    }
    else 
    {
       // The cache is not empty, lets look for ch in the cache
       for (i=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) 
       {
          if ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i) == ch) 
          {
             // found in cache
             DebugPrintEx(  DEBUG_MSG,
                            "Found XON in cache pos=%d total=%d",
                            i, 
                            pTG->CommCache.dwCurrentSize);
             
             pTG->CommCache.dwOffset += (i+1);
             pTG->CommCache.dwCurrentSize -= (i+1);

             goto GotCtrlQ;
          }
       }

       DebugPrintEx(    DEBUG_MSG, 
                        "Cache wasn't empty. Didn't find XON. Resetting comm cache.");

       ClearCommCache(pTG);
    }

    // Send nothing - look for cntl-Q (XON) after connect
    BG_CHK(ch == 0x11);             // so far looking for just ctrlQ
    startTimeOut(pTG, &toCtrlQ, 1000);
    do
    {
        ////MyReadComm(Comm.nCid, rgbRead, 1, &nNumRead);
        lpOverlapped =  &pTG->Comm.ovAux;

        (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                            (lpOverlapped)->OffsetHigh = 0;

        if ((lpOverlapped)->hEvent)
        {
            if (!ResetEvent((lpOverlapped)->hEvent))
            {
                BG_CHK(FALSE);
            }
        }

        nNumRead = 0;

        DebugPrintEx(DEBUG_MSG, "Before ReadFile Req=1");

        if (! ReadFile( (HANDLE) pTG->Comm.nCid, rgbRead, 1, &nNumRead, lpOverlapped) ) 
        {
           if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
           {
               // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
               //
               if (pTG->fAbortRequested) 
               {
                   if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                   {
                       DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                       pTG->fAbortReqEventWasReset = TRUE;
                       if (!ResetEvent(pTG->AbortReqEvent))
                       {
                            BG_CHK(FALSE);                        
                       }
                   }

                   pTG->fUnblockIO = TRUE;
                   goto error;
               }

               HandlesArray[0] = pTG->Comm.ovAux.hEvent;
               HandlesArray[1] = pTG->AbortReqEvent;

               if (pTG->fUnblockIO) 
               {
                   NumHandles = 1;
               }
               else 
               {
                   NumHandles = 2;
               }

               WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);

               if (WaitResult == WAIT_TIMEOUT) 
               {
                   DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                      
                   goto error;
               }

               if (WaitResult == WAIT_FAILED) 
               {
                   DebugPrintEx(    DEBUG_ERR,
                                    "WaitForMultipleObjects FAILED le=%lx",
                                    GetLastError());
                   goto error;
               }

               if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
               {
                   pTG->fUnblockIO = TRUE;
                   DebugPrintEx(DEBUG_MSG,"ABORTed");
                   goto error;
               }

                // The IO operation was complete. Lets try to get the overlapped result.
               if ( ! GetOverlappedResult ( (HANDLE) pTG->Comm.nCid, lpOverlapped, &nNumRead, TRUE) ) 
               {
                   DebugPrintEx(DEBUG_ERR,"GetOverlappedResult le=%x",GetLastError());
                   if (! ClearCommError( (HANDLE) pTG->Comm.nCid, &dwErr, &ErrStat) ) 
                   {
                       DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x",GetLastError());
                   }
                   else 
                   {
                       DebugPrintEx(    DEBUG_ERR, 
                                        "ClearCommError dwErr=%x ErrSTAT: Cts=%d "
                                        "Dsr=%d Rls=%d XoffHold=%d XoffSent=%d "
                                        "fEof=%d Txim=%d In=%d Out=%d",
                                        dwErr, 
                                        ErrStat.fCtsHold, 
                                        ErrStat.fDsrHold, 
                                        ErrStat.fRlsdHold, 
                                        ErrStat.fXoffHold, 
                                        ErrStat.fXoffSent, 
                                        ErrStat.fEof,
                                        ErrStat.fTxim, 
                                        ErrStat.cbInQue, 
                                        ErrStat.cbOutQue);
                   }
                   goto errorWithoutCancel;
               }
           }
           else 
           { // error in ReadFile (not ERROR_IO_PENDING), so there is no Pending IO operations
               DebugPrintEx(DEBUG_ERR, "ReadFile le=%x at",dwLastErr);
               goto errorWithoutCancel;
           }
        }
        else 
        {
           DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
        }

        DebugPrintEx(DEBUG_MSG,"After ReadFile Req=1 Ret=%d",nNumRead);

        switch(nNumRead)
        {
        case 0:         break;          // loop until we get something
        case 1:         // INMON(rgbRead, 1);
                        if(rgbRead[0] == ch)
                        {
                            goto GotCtrlQ;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"GetCntlQ: Found non ^Q char");
                            goto errorWithoutCancel;
                        }
        default:        BG_CHK(FALSE);
                        goto errorWithoutCancel;
        }
    }
    while(checkTimeOut(pTG, &toCtrlQ));
    ////ERRMSG(("<<ERROR>> GetCntlQ: Timed out\n\r"));
    goto errorWithoutCancel;

GotCtrlQ:
#ifdef LOWLOG
    PSSLogEntry(PSS_MSG, 3, "   1                 0x%02x", ch);
#endif // LOWLOG
    ////TRACE(("GetCntlQ: YES!!! Found cntl q\n\r"));
    return TRUE;

error:

    if (!CancellPendingIO(pTG , (HANDLE) pTG->Comm.nCid , lpOverlapped , (LPDWORD) &nNumRead))
    {
        DebugPrintEx(DEBUG_ERR, "failed when call to CancellPendingIO");
    }

errorWithoutCancel:

return FALSE;
}


/*****
#ifdef USE_HWND
#       define MyGetMessage(x)                                                                                  \
          ( GetMessage(&x, NULL, 0, 0),                                                                 \
            (x.hwnd ? (DispatchMessage(&x), x.message=WM_NULL) : 0),    \
            (x.message != WM_QUIT) )

#       define MyPeekMessage(x)                                                                                         \
          ( (x.message=WM_NULL),                                                                                        \
                ( PeekMessage(&x, NULL, 0, 0, PM_RNOY) ?                                                \
                        (x.hwnd ? (DispatchMessage(&x), x.message=WM_NULL) : TRUE)      \
                          : FALSE ) )
#else

#       define MyGetMessage(x)   (      GetMessage(&x, NULL, 0, 0),                     \
                                                                BG_CHK(x.hwnd==0),                                      \
                                                                (x.message != IF_QUIT) )

#       define MyPeekMessage(x)  (      (x.message = WM_NULL),                                  \
                                                                PeekMessage(&x, NULL, 0, 0, PM_RNOY),   \
                                                                BG_CHK(x.hwnd==0),                                      \
                                                                (x.message != WM_NULL) )
#endif
*****/

#ifdef MDRV
extern void iModemParamsReset(PThrdGlbl pTG);
extern void iModemInitGlobals(PThrdGlbl pTG);
#endif

#define szMODULENAME    "awfxio32"


OVREC *ov_get(PThrdGlbl pTG)
{
    OVREC   *lpovr=NULL;

    DEBUG_FUNCTION_NAME(_T("ov_get"));

    if (!pTG->Comm.covAlloced)
    {
        // There are no OVREC in use now.
        BG_CHK(!pTG->Comm.uovLast && !pTG->Comm.uovFirst);
        lpovr = &(pTG->Comm.rgovr[0]);
        BG_CHK(lpovr->eState==eFREE);
        BG_CHK(!(lpovr->dwcb));
    }
    else
    {
        UINT uNewLast = (pTG->Comm.uovLast+1) % NUM_OVS;

        DebugPrintEx(   DEBUG_MSG, 
                        "iov_flush: 1st=%d, last=%d", 
                        pTG->Comm.uovFirst, 
                        pTG->Comm.uovLast);

        lpovr = pTG->Comm.rgovr+uNewLast;
        if (uNewLast != pTG->Comm.uovFirst)
        {
            BG_CHK(lpovr->eState==eFREE);
        }
        else
        {
            BG_CHK(lpovr->eState==eIO_PENDING);
            if (!iov_flush(pTG, lpovr, TRUE))
            {
                BG_CHK(lpovr->eState==eALLOC);
                ov_unget(pTG, lpovr);
                lpovr=NULL; // We fail if a flush operation failed...
            }
            else
            {
                BG_CHK(lpovr->eState==eALLOC);
                pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
            }
        }
        if (lpovr)
            pTG->Comm.uovLast = uNewLast;
    }
    if (lpovr && lpovr->eState!=eALLOC)
    {
        BG_CHK(lpovr->eState==eFREE && !lpovr->dwcb);
        BG_CHK(pTG->Comm.covAlloced < NUM_OVS);
        pTG->Comm.covAlloced++;
        lpovr->eState=eALLOC;
    }
    return lpovr;
}

// We have array of overllaped structures (size: NUM_OVS)
// This function release given OVREC

BOOL ov_unget(PThrdGlbl pTG, OVREC *lpovr)
{
    BOOL fRet = FALSE;

    DEBUG_FUNCTION_NAME(("ov_unget"));

    DebugPrintEx(DEBUG_MSG,"lpovr=%lx",lpovr);

    if (    lpovr->eState!=eALLOC ||
            !pTG->Comm.covAlloced || 
            lpovr!=(pTG->Comm.rgovr+pTG->Comm.uovLast))
    {
        DebugPrintEx(DEBUG_ERR, "invalid lpovr.");
        BG_CHK(FALSE);
        goto end;
    }

    BG_CHK(!lpovr->dwcb);

    if (pTG->Comm.covAlloced==1)
    {
        BG_CHK(pTG->Comm.uovLast == pTG->Comm.uovFirst);
        pTG->Comm.uovLast = pTG->Comm.uovFirst = 0;
    }
    else
    {
        pTG->Comm.uovLast = (pTG->Comm.uovLast)?  (pTG->Comm.uovLast-1) : (NUM_OVS-1);
    }
    pTG->Comm.covAlloced--;
    lpovr->eState=eFREE;
    fRet = TRUE;

end:
    return fRet;
}

// function: ov_write
// This function writes the buffer from lpovr to the comm. In case of error or return w/o waiting, the function free
// the ovrec. In case of IO_PENDING we write to *lpdwcbWrote the size of the buffer to write and return without waiting
// for operation to complete
// 

BOOL ov_write(PThrdGlbl pTG, OVREC *lpovr, LPDWORD lpdwcbWrote)
{
    DEBUG_FUNCTION_NAME(_T("ov_write"));
    // Write out the buffer associated with lpovr.
    BG_CHK(lpovr->eState==eALLOC);
    if (!lpovr->dwcb) // Nothing in the buffer
    {
        // Just free the overlapped structure
        ov_unget(pTG, lpovr);
        lpovr=NULL;
    }
    else
    {
        BOOL fRet;
        DWORD dw;
        int err;
        OVERLAPPED *lpov = &(lpovr->ov);

        DWORD cbQueue;

        BG_CHK(lpovr->dwcb<=OVBUFSIZE);
        pTG->Comm.comstat.cbOutQue += lpovr->dwcb;

        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));

        if(err)  
        {
            DebugPrintEx(DEBUG_ERR, "GetCommError failed");
            D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
        }

        cbQueue = pTG->Comm.comstat.cbOutQue;

        OUTMON(pTG, lpovr->rgby, (USHORT)lpovr->dwcb);

        {
            DebugPrintEx(   DEBUG_MSG, 
                            "Before WriteFile lpb=%x, cb=%d lpovr=%lx",
                            lpovr->rgby,
                            lpovr->dwcb, 
                            lpovr);

            if (!(fRet = WriteFile( (HANDLE)pTG->Comm.nCid, 
                                    lpovr->rgby, 
                                    lpovr->dwcb,
                                    lpdwcbWrote, 
                                    lpov)))
            {
                dw=GetLastError();
            }
            DebugPrintEx(DEBUG_MSG,"After, wrote %ld",*lpdwcbWrote);

            GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));

            if (err) 
            {
                DebugPrintEx(DEBUG_ERR, "GetCommError failed");
                D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
            }

            DebugPrintEx(   DEBUG_MSG, 
                            "Queue before=%lu; after = %lu. n= %lu, *pn=%lu",
                            (unsigned long) cbQueue,
                            (unsigned long) (pTG->Comm.comstat.cbOutQue),
                            (unsigned long) lpovr->dwcb,
                            (unsigned long) *lpdwcbWrote);
        }
        if (fRet)
        {
            // Write operation completed
            DebugPrintEx(DEBUG_WRN, "WriteFile returned w/o wait");
            OVL_CLEAR( lpov);
            lpovr->dwcb=0;
            ov_unget(pTG, lpovr);
            lpovr=NULL;
        }
        else
        {
            if (dw==ERROR_IO_PENDING)
            {
                DebugPrintEx(DEBUG_MSG,"WriteFile returned PENDING");
                *lpdwcbWrote = lpovr->dwcb; // We set *pn to n on success else 0.
                lpovr->eState=eIO_PENDING;
            }
            else
            {
                DebugPrintEx(   DEBUG_ERR,
                                "WriteFile returns error 0x%lx",
                                (unsigned long)dw);
                OVL_CLEAR(lpov);
                lpovr->dwcb=0;
                ov_unget(pTG, lpovr);
                lpovr=NULL;
                goto error;
            }
        }
    }

    BG_CHK(!lpovr || lpovr->eState==eIO_PENDING);
    return TRUE;

error:

    BG_CHK(!lpovr);
    return FALSE;
}

// This function do "iov_flush" on all the allocated OVREC, and free the OVREC for future use.

BOOL ov_drain(PThrdGlbl pTG, BOOL fLongTO)
{
    BOOL fRet = TRUE;

    // We want to iterate on all the OVREC that are in use.
    UINT u = pTG->Comm.covAlloced;

    DEBUG_FUNCTION_NAME(_T("ov_drain"));

    while(u--)
    {
        OVREC *lpovr = pTG->Comm.rgovr+pTG->Comm.uovFirst;
        OVERLAPPED *lpov = &(lpovr->ov);

        if (lpovr->eState==eIO_PENDING)
        {
            if (!iov_flush(pTG, lpovr, fLongTO))
                fRet=FALSE;

            BG_CHK(lpovr->eState==eALLOC);
            lpovr->eState=eFREE;
            BG_CHK(pTG->Comm.covAlloced);
            pTG->Comm.covAlloced--;
            pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
        }
        else
        {
            // Only the newest (last) structure can be still in the
            // allocated state.
            BG_CHK(lpovr->eState==eALLOC && !u);
            BG_CHK(pTG->Comm.lpovrCur == lpovr); // Ugly check
            DebugPrintEx(DEBUG_WRN,"called when alloc'd structure pending");
        }
    }

    if (!pTG->Comm.covAlloced)
    {
        pTG->Comm.uovFirst=pTG->Comm.uovLast=0;
    }
    else
    {
        BG_CHK(     pTG->Comm.covAlloced==1
                    && pTG->Comm.uovFirst==pTG->Comm.uovLast
                    && pTG->Comm.uovFirst<NUM_OVS
                    && pTG->Comm.rgovr[pTG->Comm.uovFirst].eState==eALLOC);
    }

    return fRet;
}


BOOL ov_init(PThrdGlbl pTG)
{
    UINT u;
    OVREC *lpovr = pTG->Comm.rgovr;

    DEBUG_FUNCTION_NAME(_T("ov_init"));
    // init overlapped structures, including creating events...
    if (pTG->Comm.fovInited)
    {
        DebugPrintEx(DEBUG_ERR, "we're *already* inited.");
        BG_CHK(FALSE);
        ov_deinit(pTG);
    }

    BG_CHK(!pTG->Comm.fovInited && !pTG->Comm.covAlloced);

    for (u=0;u<NUM_OVS;u++,lpovr++) 
    {
        OVERLAPPED *lpov = &(lpovr->ov);
        BG_CHK(lpovr->eState==eDEINIT);
        BG_CHK(!(lpovr->dwcb));
        _fmemset(lpov, 0, sizeof(OVERLAPPED));
        lpov->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (lpov->hEvent==NULL)
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "couldn't create event #%lu",
                            (unsigned long)u);
            goto failure;
        }
        lpovr->eState=eFREE;
        lpovr->dwcb=0;
    }

    pTG->Comm.fovInited=TRUE;

    return TRUE;

failure:
    BG_CHK(!pTG->Comm.fovInited);
    while (u--)
    {   
        --lpovr; 
        CloseHandle(lpovr->ov.hEvent); 
        lpovr->eState=eDEINIT;
    }
    return FALSE;

}

BOOL ov_deinit(PThrdGlbl pTG)
{
    UINT u=NUM_OVS;
    OVREC *lpovr = pTG->Comm.rgovr;

    DEBUG_FUNCTION_NAME(("ov_deinit"));

    if (!pTG->Comm.fovInited)
    {
        DebugPrintEx(DEBUG_WRN,"Already deinited.");
        goto end;
    }

    //
    // if handoff ==> dont flush
    //
    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        goto lNext;
    }

    // deinit overlapped structures, including freeing events...
    if (pTG->Comm.covAlloced)
    {
        DWORD dw;
        DebugPrintEx(   DEBUG_WRN,
                        "%lu IO's pending.",
                        (unsigned long) pTG->Comm.covAlloced);
        if (pTG->Comm.lpovrCur)
        {
            ov_write(pTG, pTG->Comm.lpovrCur,&dw); 
            pTG->Comm.lpovrCur=NULL;
        }
        ov_drain(pTG, FALSE);
    }
    BG_CHK(!pTG->Comm.covAlloced);

lNext:

    while (u--)
    {
        BG_CHK(!(lpovr->dwcb));
        BG_CHK(lpovr->eState==eFREE);
        lpovr->eState=eDEINIT;
        if (lpovr->ov.hEvent) 
            CloseHandle(lpovr->ov.hEvent);

        _fmemset(&(lpovr->ov), 0, sizeof(lpovr->ov));
        lpovr++;
    }

    pTG->Comm.fovInited=FALSE;

end:
    return TRUE;
}


BOOL iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO)
// On return, state of lpovr is *always* eALLOC, but
// it returns FALSE if there was a comm error while trying
// to flush (i.e. drain) the buffer.
// If we timeout with the I/O operation still pending, we purge
// the output buffer and abort all pending write operations.
{
    DWORD dwcbPrev;
    DWORD dwStart = GetTickCount();
    BOOL  fRet=FALSE;
    DWORD dwWaitRes;
    DWORD dw;
    int err;

    DEBUG_FUNCTION_NAME(_T("iov_flush"));

    DebugPrintEx(DEBUG_MSG,"fLongTo=%d lpovr=%lx",fLongTO,lpovr);

    BG_CHK(lpovr->eState==eIO_PENDING);

    if (pTG->Comm.nCid<0)
    {
        lpovr->eState=eALLOC; 
        goto end;
    }

    // We call
    // WaitForSingleObject multiple times ... basically
    // the same logic as the code in the old FComDirectWrite...
    // fLongTO is TRUE except when initing
    // the modem (see comments for FComDrain).

    BG_CHK(lpovr->ov.hEvent);
    GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
#ifdef DEBUG
    if(err)
        D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
#endif
    // We want to check for progress, so we check the amount of bytes in the output buffer.
    dwcbPrev = pTG->Comm.comstat.cbOutQue;

    while( (dwWaitRes=WaitForSingleObject(  lpovr->ov.hEvent,
                                            fLongTO ? 
                                            LONG_DRAINTIMEOUT : 
                                            SHORT_DRAINTIMEOUT))==WAIT_TIMEOUT)
    {
        BOOL fStuckOnce=FALSE;

        DebugPrintEx(DEBUG_MSG,"After WaitForSingleObject TIMEOUT");

        GetCommErrorNT( pTG, (HANDLE) pTG->Comm.nCid, &err, &(pTG->Comm.comstat));
#ifdef DEBUG
        if(err)
            D_GotError(pTG, pTG->Comm.nCid, err, &(pTG->Comm.comstat));
#endif
        // Timed out -- check if any progress
        if (dwcbPrev == pTG->Comm.comstat.cbOutQue)
        {
            //  No pregess, the size of the output buffer is without any change.
            DebugPrintEx(DEBUG_WRN,"No progress %d",dwcbPrev);

            // No progress... If not in XOFFHold, we break....
            if(!FComInXOFFHold(pTG))
            {
                if(fStuckOnce)
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "No Progress -- OutQ still %d", 
                                    (int)pTG->Comm.comstat.cbOutQue);
                    iModemSetError(pTG, MODEMERR_TIMEOUT, 0, MODEMERRFLAGS_TRANSIENT);
                    goto done;
                }
                else
                {
                    fStuckOnce=TRUE;
                }
            }
        }
        else
        {
                // Some progress...
                dwcbPrev= pTG->Comm.comstat.cbOutQue;
                fStuckOnce=FALSE;
        }

        // Independant deadcom timeout... I don't want
        // to use TO because of the 16bit limitation.
        {
            DWORD dwNow = GetTickCount();
            DWORD dwDelta = (dwNow>dwStart)
                            ?  (dwNow-dwStart)
                               :  (0xFFFFFFFFL-dwStart) + dwNow;
            if (dwDelta > (unsigned long)
                                    ((fLongTO)?LONG_DEADCOMMTIMEOUT:SHORT_DEADCOMMTIMEOUT))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "Drain:: Deadman Timer -- OutQ still %d", 
                                (int) pTG->Comm.comstat.cbOutQue);
                goto end;
            }
        }
    }

    if (dwWaitRes==WAIT_FAILED)
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "WaitForSingleObject failed (ec=%d)", 
                        GetLastError());
        goto end;
    }
done:

    DebugPrintEx(DEBUG_MSG,"Before GetOverlappedResult");

    if (GetOverlappedResult((HANDLE)pTG->Comm.nCid, &(lpovr->ov), &dw, FALSE))
    {
        fRet=TRUE;
    }
    else
    {
        dw = GetLastError();
        DebugPrintEx(   DEBUG_ERR,
                        "GetOverlappedResult returns error 0x%lx",
                        (unsigned long)dw);
        if (dw==ERROR_IO_INCOMPLETE)
        {
            // IO operation still pending, but we *have* to
            // reuse this buffer -- what should we do?!-
            // purge the output buffer and abort all pending
            // write operations on it..

            DebugPrintEx(DEBUG_ERR, "Incomplete");
            PurgeComm((HANDLE)pTG->Comm.nCid, PURGE_TXABORT);
        }
        fRet=FALSE;
    }
    OVL_CLEAR( &(lpovr->ov));
    lpovr->eState=eALLOC;
    lpovr->dwcb=0;

end:
    return fRet;
}

void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fBegin)
{
    DEBUG_FUNCTION_NAME(_T("FComOverlappedIO"));

    DebugPrintEx(DEBUG_MSG,"Turning %s OVERLAPPED IO", (fBegin) ? "ON" : "OFF");
    pTG->Comm.fDoOverlapped=fBegin;
}


BOOL
CancellPendingIO
(
    PThrdGlbl pTG , 
    HANDLE hComm , 
    LPOVERLAPPED lpOverlapped , 
    LPDWORD lpCounter)
{ 
    BOOL retValue = TRUE;
    /*
    The CancelIo function cancels all pending input and output (I/O) operations 
    that were issued by the calling thread for the specified file handle. The 
    function does not cancel I/O operations issued for the file handle by other threads.
    */

    DEBUG_FUNCTION_NAME(_T("CancellPendingIO"));
    BG_CHK(pTG != NULL);
    BG_CHK(hComm != NULL);
    BG_CHK(lpCounter);
    BG_CHK(lpOverlapped != NULL);
    BG_CHK(lpOverlapped->hEvent != NULL);

    if (!CancelIo(hComm))
    {
        retValue = FALSE;
        BG_CHK(FALSE);
        DebugPrintEx(DEBUG_ERR, "CancelIO failed, ec=%x",GetLastError());
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"CancelIO succeeded.");
    }

    (*lpCounter) = 0;
    if (!GetOverlappedResult (hComm , lpOverlapped, lpCounter , TRUE))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "GetOverlappedResult failed because we cancel the "
                        "IO operation, ec=%x", 
                        GetLastError());
    }
    else
    {
        // If the function was successful then something fishy with the CancellIo(hComm)
        // The operation succeeded cause the pending IO was finished before the 'CancelIo'
        DebugPrintEx(   DEBUG_MSG,
                        "GetOverlappedResult succeeded. Number of bytes read %d", 
                        *lpCounter);
    }
    ClearCommCache(pTG);
    return retValue;
}



void
GetCommErrorNT
(
    PThrdGlbl       pTG,
    HANDLE          h,
    int *           pn,
    LPCOMSTAT       pstat
)
{
    DEBUG_FUNCTION_NAME(_T("GetCommErrorNT"));
    if (!ClearCommError( h, pn, pstat) ) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "(0x%lx) FAILS. Returns 0x%lu",
                        h,  
                        GetLastError());
        *(pn) =  MYGETCOMMERROR_FAILED;
    }
}


void
ClearCommCache
(
    PThrdGlbl   pTG
)
{
    pTG->CommCache.dwCurrentSize = 0;
    pTG->CommCache.dwOffset      = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\awg3file.h ===
#ifndef _AWG3FILE_
#define _AWG3FILE_

/********************************************************************

    @doc    EXTERNAL SRVRDLL LINEARIZER

    @type   VOID | AWG3 File Format |
            
            An AWG3 file can be used to describe any
            multi page image encoded using a CCITT G3 standard like
            MH, MR, or MMR.

            The file format is a special case of the Microsoft Fax Linearized
			format. It consists of a LINHEADER structure, followed by
			an extended linearized header, followed by the image data.
			The image data is specified as one or more headers, each followed
            by a page of encoded image data. Each header starts a
            new page. The file is terminated with a header containing
            a special end-of-file signature marker.

			Linearizer helper function CreateSimpleHeader  should be used to
			write the LINHEADER and extended linearized header when creating
			an AWG3 file.

			Linearizer helper function DiscardLinHeader  should be used to
			skip past the LINHEADER and extended linearized header when
			reading the AWG3 file.

            The page header format is defined by the structure <t AWG3HEADER>.
            The data for each page consists of one or more frames.
			A frame consists of  a DWORD indicating the length of data in
			the frame followed by that many bytes of data. The last
			frame of each page must be of zero length and indicates
			the end of the page data.
			The data consists of raw MH, MR, or MMR, encoded so that the
			least significant bit of each byte should be sent first over
			the wire.

    @xref   <t AWG3HEADER>

********************************************************************/

/********
    @doc    EXTERNAL SRVRDLL LINEARIZER

    @types  AWG3HEADER | Describes the Header Structure for an AWG3 File.

    @field  WORD    | wSig  | Must be SIG_G3 for the page headers, and
            SIG_ENDFILE for the end of file header.

    @field  WORD    | wHeaderSize | Must be set to the size of the header
            structure. Used for version control.

    @field  WORD    | wTotalHeaders | If non-zero, this indicates the total
            number of and headers (including the end-of-file header)
			in this file. This need only be set in the first header.
			If zero, the total number of headers is not specified directly and
			can be obtained by traversing the headers in the file (until
			the end-of-file header).

    @field  WORD    | wHeaderNum | Gives the ordinal number for this 
            header. Must be set for all headers. Numbering starts at 1.

    @field  DWORD   | lDataOffset   | Gives the offset from the beginning
            of the current header to the start of the first frame
			of the data for this page. 
            Must always be set. 

    @field  DWORD   | lNextHeaderOffset | Gives the offset from the start of the
            current header to where the header for the next page can be found. If this
            is set to 0, the next header starts at the end of the
            last frame (which will be a null frame) for this page. 

    @field  DWORD | AwRes | One of the standard resolution defines 
            specified in <t STD_RESOLUTIONS>.

    @field  DWORD | Encoding | One of the G3 Fax types from the
            standard types defined in <t STD_DATA_TYPES>. Basically one
            of MH_DATA, MR_DATA, or MMR_DATA.

    @field  DWORD | PageWidth | One of the standard page widths as defined in
            <t STD_PAGE_WIDTHS>.

    @field  DWORD | PageLength | One of the standard page lengths as defined in
            <t STD_PAGE_LENGTHS>.

    @xref   <t AWG3 File Format>
********/    

#define	SIG_G3		0x3347
#define SIG_ENDFILE 0x4067

#ifndef WIN16		// remove WIN16 irritation
#pragma pack(push)
#endif

#pragma pack(1)
typedef struct {
	WORD	wSig;		  	// always set to one of the above SIG_ #defines
	WORD	wHeaderSize;  	// always set
  WORD    wTotalHeaders;	// can be 0
	WORD	wHeaderNum;		// starts from 1
    // 8 bytes

								// all offsets from start of _this_header_
	DWORD	lDataOffset;		// always set. points to the first frame-size DWORD
	DWORD	lNextHeaderOffset;	// may be NULL--then next header follows end of data 
    // 16 bytes

	DWORD   AwRes;			// as per AWRES_ defines below. DIFFERENT from Snowball
	DWORD   Encoding;		// as per _DATA defines below. Same as Snowball
	DWORD   PageWidth;		// as per WIDTH_ defines below. Same as Snowball
	DWORD   PageLength;		// as per LENGTH_ defines below. Same as SNowball
    // 32 bytes

	BYTE	Reserved1[32];	// pad out to 64 bytes for future expansion
} AWG3HEADER, far* LPAWG3HEADER;

#ifdef WIN16		// remove WIN16 irritation
#pragma pack()
#else
#pragma pack(pop)
#endif



// Standard Bit Valued MetaData values
#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L


// Standard Resolutions
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_75_75             0x00000800L
#define AWRES_100_100           0x00001000L

/********
    @doc    EXTERNAL  DATATYPES  SRVRDLL

    @type   WORD | STD_PAGE_LENGTHS | Standard Page Lengths

    @emem   LENGTH_A4 | Std A4 paper length, Value: 0
    @emem   LENGTH_B4 | Std B4 paper length, Value: 1
    @emem   LENGTH_UNLIMITED | Unknown length, Value: 2

    @comm   These lengths are compatible with those defined
            by the CCITT for G3 machines. They are used
            in fax format headers, and in structures dealing
            with fax machine capabilities.
********/   

// Length defines
#define LENGTH_A4			0	
#define LENGTH_B4			1	
#define LENGTH_UNLIMITED	2


/********
    @doc    EXTERNAL  DATATYPES  SRVRDLL

    @type   WORD | STD_PAGE_WIDTHS | Standard Page Widths

    @emem   WIDTH_A4 |1728 pixels, Value: 0
    @emem   WIDTH_B4 |2048 pixels, Value: 1
    @emem   WIDTH_A3 |2432 pixels, Value: 2
    @emem   WIDTH_A5 |1216 pixels, Value: 16
    @emem   WIDTH_A6 |864 pixels, Value: 32

    @comm   These widths are compatible with those defined
            by the CCITT for G3 machines. They are used
            in fax format headers, and in structures dealing
            with fax machine capabilities.
********/   

//Width defines
#define WIDTH_A4	0	/* 1728 pixels */
#define WIDTH_B4	1	/* 2048 pixels */
#define WIDTH_A3	2	/* 2432 pixels */
#define WIDTH_MAX	WIDTH_A3

#define WIDTH_A5		16 	/* 1216 pixels */
#define WIDTH_A6		32	/* 864 pixels  */
#define WIDTH_A5_1728	64 	/* 1216 pixels */
#define WIDTH_A6_1728	128	/* 864 pixels  */

#endif // _AWG3FILE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\mdmcmds.h ===
#ifdef DEFINE_MDMCMDS

CBSZ cbszAT             = "AT\r";
CBSZ cbszHANGUP         = "ATH0\r";
CBSZ cbszANSWER         = "ATA\r";
CBSZ cbszDIAL           = "ATD%c %s\r";
CBSZ cbszDIAL_EXT       = "ATX%cD%c %s%s\r";

CBSZ cbszS8             = "S8=%d";
CBSZ cbszXn             = "X%d";
CBSZ cbszLn             = "L%d";
CBSZ cbszMn             = "M%d";
CBSZ cbszJustAT         = "AT";

CBSZ cbszOK             = "OK";
CBSZ cbszCONNECT        = "CONNECT";
CBSZ cbszRING           = "RING";
CBSZ cbszNOCARRIER      = "NO CARRIER";
CBSZ cbszERROR          = "ERROR";
CBSZ cbszBLACKLISTED    = "BLACKLISTED";
CBSZ cbszDELAYED        = "DELAYED";
CBSZ cbszNODIALTONE     = "NO DIAL"; // Was NO DIALTONE. Changed to fix
                                     // Elliot Bug#2009: USR28 and USR14
                                     // modems return NO DIAL TONE instead
                                     // of NO DIALTONE.
CBSZ cbszBUSY           = "BUSY";
CBSZ cbszNOANSWER       = "NO ANSWER";
CBSZ cbszFCERROR        = "+FCERROR";


CBSZ cbszGO_CLASS0      = "AT+FCLASS=0\r";
CBSZ cbszGO_CLASS1      = "AT+FCLASS=1\r";
CBSZ cbszGO_CLASS2      = "AT+FCLASS=2\r";
CBSZ cbszGO_CLASS2_0    = "AT+FCLASS=2.0\r";
CBSZ cbszGET_CLASS      = "AT+FCLASS?\r";

CBPSTR rgcbpstrGO_CLASS[] =
{       cbszGO_CLASS0,
        cbszGO_CLASS1,
        cbszGO_CLASS2,
        cbszGO_CLASS2_0
};

USHORT uLenGO_CLASS[] =
{
        sizeof(cbszGO_CLASS0)-1,
        sizeof(cbszGO_CLASS1)-1,
        sizeof(cbszGO_CLASS2)-1,
        sizeof(cbszGO_CLASS2_0)-1,
};

CBSZ cbszQUERY_CLASS    = "AT+FCLASS=?\r";
CBSZ cbszQUERY_FTH              = "AT+FTH=?\r";
CBSZ cbszQUERY_FTM              = "AT+FTM=?\r";
CBSZ cbszQUERY_FRH              = "AT+FRH=?\r";
CBSZ cbszQUERY_FRM              = "AT+FRM=?\r";
CBSZ cbszQUERY_S1               = "ATS1?\r";

#else

extern  CBSZ cbszAT;
extern  CBSZ cbszHANGUP;
extern  CBSZ cbszANSWER;
extern  CBSZ cbszDIAL;
extern  CBSZ cbszDIAL_EXT;

extern  CBSZ cbszS8;
extern  CBSZ cbszXn;
extern  CBSZ cbszLn;
extern  CBSZ cbszMn;
extern  CBSZ cbszJustAT;

extern  CBSZ cbszOK;
extern  CBSZ cbszCONNECT;
extern  CBSZ cbszRING;
extern  CBSZ cbszNOCARRIER;
extern  CBSZ cbszERROR;
extern  CBSZ cbszNODIALTONE;



extern  CBSZ cbszBUSY;
extern  CBSZ cbszNOANSWER;
extern  CBSZ cbszFCERROR;


extern  CBSZ cbszGO_CLASS0;
extern  CBSZ cbszGO_CLASS1;
extern  CBSZ cbszGO_CLASS2;
extern  CBSZ cbszGO_CLASS2_0;
extern  CBSZ cbszGET_CLASS;

extern  CBPSTR rgcbpstrGO_CLASS[];

extern  USHORT uLenGO_CLASS[];

extern  CBSZ cbszQUERY_CLASS;
extern  CBSZ cbszQUERY_FTH;
extern  CBSZ cbszQUERY_FTM;
extern  CBSZ cbszQUERY_FRH;
extern  CBSZ cbszQUERY_FRM;
extern  CBSZ cbszQUERY_S1;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\modem.c ===
/***************************************************************************
        Name      :     MODEM.C
        Comment   :     Various modem dialog & support functions, specific
                                to COM connected modems. For a modem on the bus
                                everything below & including this file is replaced
                                by the modem driver.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/04/92        arulm   Modif to SUPPORT to provide a replaceable interface
                                                        and to use new FCom functions.
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"

#include "mmsystem.h"
#include "modemint.h"
#include "fcomint.h"
#include "fdebug.h"

#include "efaxcb.h"

#define DEFINE_MDMCMDS
#include "mdmcmds.h"

///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_MODEM

// 12/18/94 JosephJ: CHECKGOCLASS code issues a +FCLASS? after
//                      each +FCLASS=x to verify that the modem has gone to CLASS x.
//                      We have disabled it because we've not been able to repro
//                      a potential bug of the modem not going to CLASS1 when we expect it -
//                      we currently issue AT+FCLASS=x, wait 500ms, and then issue
//                      an AT to resync, but don't check that the class is currect.
//                      The CHECGOCLASS code has been TESTED on a couple of modems, but
//                      I haven't been able to actually kick in -- i.e., catch the modem
//                      in the wrong mode and retry the +FCLASS=x command, so we've
//                      commented out all the code until we can repro the problem.
// #define CHECKGOCLASS

// no need for this--LPZ is now compulsory, PCMODEMS is optional in this
//    module, and we will use inifiles here whether INIFILE is defd or not
//    (INIFILE is not defined for IFAX so that the other (non-test) modules
//    don't use INI files). In IFAX this module is just for test-purposes.
// #if !defined(INIFILE) || !defined(PCMODEMS) || !defined(LPZ)
// #error "INIFILE and LPZ and PCMODEMS _must_ be defined"
// #endif


#define faxT2log(m)                     DEBUGMSG(ZONE_DIA, m)
#define FILEID                          FILEID_MODEM

#ifdef DEBUG
#       define  ST_DIA(x)                       if(ZONE_DIA) { x; }
#       define  ST_MOD(x)                       if(ZONE_MD) { x; }
#else
#       define  ST_DIA(x)                       { }
#       define  ST_MOD(x)                       { }
#endif

#ifdef MON3

// Enhanced comm monitor logging...

#define wEVFLAGS_DIAL   fEVENT_TRACELEVEL_1
#define wEVFLAGS_ANSWER fEVENT_TRACELEVEL_1
#define wEVFLAGS_INIT   fEVENT_TRACELEVEL_1
#define wEVFLAGS_DEINIT fEVENT_TRACELEVEL_1
#define wEVFLAGS_HANGUP fEVENT_TRACELEVEL_1

void    InitMonitorLogging(PThrdGlbl pTG);

#else // !MON3
#define InitMonitorLogging(PThrdGlbl pTG) 0
#endif // !MON3


#       pragma message("Compiling with ADAPTIVE_ANSWER")
USHORT iModemGetAdaptiveResp(PThrdGlbl pTG);
#define uMULTILINE_SAVEENTIRE   0x1234 // +++ HACK passed in as fMultiLine
                                                   //  in iiModemDialog to get it so save
                                                   //  entire buffer in FComModem.bEntireReply.

// Need to have these in descending order so that we'll
// Sync at teh highest common speed with auto-bauding modems!
static UWORD rguwSpeeds[] = {57600,19200, 19200, 9600, 2400, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {19200, 2400, 9600, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {2400, 19200, 9600, 1200, 300, 0};











SWORD HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, CBPSTR cbszCommand, UWORD uwLen)
{
    /* Internal routine to synchronize with the modem's speed.  Tries to
       get a response from the modem by trying the speeds in rglSpeeds
       in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
       a response before trying to reset the speeds.

       Returns the speed it found, 0 if they're in sync upon entry (only
       checked if fTryCurrent!=0), or -1 if it couldn't sync.
    */
    // short i;
    short ilWhich = -1;

    DEBUG_FUNCTION_NAME(("HayesSyncSpeed"));
    rguwSpeeds[0] = pTG->CurrentSerialSpeed;

    if ( rguwSpeeds[0] == rguwSpeeds[1]) 
    {
        ilWhich++;
    }

    BG_CHK(cbszCommand && uwLen);

    BG_CHK(fTryCurrent);
    // has to be TRUE, or we won't work with autobauding modems

    if (!fTryCurrent)
    {
        if(!FComSetBaudRate(pTG, rguwSpeeds[++ilWhich]))
        {
            return -1;
        }
    }

    for(;;)
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Trying: ilWhich=%d  speed=%d", 
                        ilWhich,
                        rguwSpeeds[ilWhich]);

        if(iSyncModemDialog(pTG, (LPSTR)cbszCommand, uwLen, cbszOK))
        {
            DebugPrintEx(   DEBUG_MSG,
                            "Succeeded in Syncing at Speed = %d (il=%d)",
                            rguwSpeeds[ilWhich], 
                            ilWhich);

            return (ilWhich>=0 ? rguwSpeeds[ilWhich] : 0);
        }

        /* failed.  try next speed. */
        if (rguwSpeeds[++ilWhich]==0)
        {
            // Tried all speeds. No response
            DebugPrintEx(   DEBUG_ERR,
                            "Cannot Sync with Modem on Command %s", 
                            (LPSTR)cbszCommand);
            iModemSetError(pTG, MODEMERR_HARDWARE, ERR_MODEM_NORESPONSE, MODEMERRFLAGS_FATAL);
            return -1;
        }
        if(!FComSetBaudRate(pTG, rguwSpeeds[ilWhich]))
            return -1;
    }
}

SWORD iModemSync(PThrdGlbl pTG)
{
    // The command used here must be guaranteed to be harmless,
    // side-effect free & non-dstructive. i.e. we can issue it
    // at any point in command mode without chnageing the state
    // of teh modem or disrupting anything.
    // ATZ does not qualify. AT does, I think.....

    return HayesSyncSpeed(pTG, TRUE, cbszAT, sizeof(cbszAT)-1);
}


SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd)
{
    SWORD swRet;

    if (szCmd == NULL) 
    {
        return -1;
    }

    if((swRet = HayesSyncSpeed(pTG, TRUE, szCmd, (UWORD) _fstrlen(szCmd))) < 0)
    {
        return swRet;
    }
    else
    {
        // ATZ may result in a change in the state/baud rate of the modem
        // (eg. Thought board drops to 2400), therefore we must Sync up
        // again because this function is really a Reset&Sync function.

        // instead of syncing up on AT and then doing ATE0, just
        // sync up on ATE0 directly

        if(iModemSync(pTG) < 0)
                return -1;

        /////////////////////
        // the above idea does not work with Sharad's PP9600FXMT
        // somehow I end up sending it ATATE0 and it answers the phone
        // In other cases, the ATE0 simply has no effect (because the AT&F
        // thing above got confused and teh ATE0 ended up just aborting
        // some previous command) and on ATA I get the ATA echoed,
        // get confused (because multi-line is FALSE) & send ATA again
        // which aborts the whole thing....
        //
        // return HayesSyncSpeed(TRUE, cbszATE0, sizeof(cbszATE0)-1);
        //

        return 0;
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define ATV1                "ATV1"
#define AT                  "AT"
#define cr                  "\r"
#define cbszZero            "0"

USHORT
T30ModemInit
(
    PThrdGlbl pTG,
    HANDLE  hComm,
    DWORD   dwLineID,
    DWORD   dwLineIDType,
    DWORD   dwProfileID,
    LPSTR   lpszKey,
    int     iInstall
)
{
    USHORT uLen, uRet;

    /*** Inits (or re-inits) the COM port, Syncs up with Modem (at whatever,
             speed), gets modem capabilities, puts it into CLASS0, syncs again,
              flushes buffers and returns TRUE on success FALSE on failure
    ***/

    DEBUG_FUNCTION_NAME(("T30ModemInit"));

    PSSLogEntry(PSS_MSG, 0, "Modem initialization");

    // Save the profile ID and key string.
    pTG->FComModem.dwProfileID = dwProfileID;

    uLen = min(_fstrlen(lpszKey), sizeof(pTG->FComModem.rgchKey)-1);
    _fmemcpy(pTG->FComModem.rgchKey, lpszKey, uLen);
    pTG->FComModem.rgchKey[uLen] = 0;

    if (!uLen)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Bad param: ProfileID=0x%lx; Key=%s",
                        (unsigned long) pTG->FComModem.dwProfileID,
                        (LPSTR) pTG->FComModem.rgchKey);
        return INIT_INTERNAL_ERROR;
    }

    InitMonitorLogging(pTG);

    //
    // Get the modem info before talking to h/w.
    //

    if(uRet = iModemGetCmdTab(  pTG, 
                                dwLineID, 
                                dwLineIDType,
                                &pTG->FComModem.CurrCmdTab, 
                                &pTG->FComModem.CurrMdmCaps,
                                &pTG->FComModem.CurrMdmExtCaps, 
                                iInstall))
    {
        goto error;
    }


    if (dwLineIDType==LINEID_COMM_HANDLE)
    {
        // Let's try to sync up with a simple AT command here...
        // Sometimes the modem could be busy sending RINGS at the wrong
        // speed and it seems to return OK to the reset string but
        // not interpret it?????
        // ALSO: (this is a general problem, in faxt) the modem could be
        // in NUMERIC mode, in which case it will return "0", not "OK"!
        // So we  check for 0 as well...
        if (!iSyncModemDialog2(pTG, AT cr,sizeof(AT cr)-1,cbszOK,cbszZero))
        {
            DebugPrintEx(DEBUG_ERR,"couldn't sync up to modem on takeover");
        }
    }

    // use MultiLine because we may get asynchronous RING responses
    // at arbitrary times when on-hook

    if(pTG->FComModem.CurrCmdTab.szSetup && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szSetup)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szSetup, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in SETUP string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szSetup);
            // SETUP is usually the defaults?? So do nothing if this fails
            // uRet = INIT_MODEMERROR;
            // goto error;
        }
    }

    switch (pTG->dwSpeakerMode) 
    {
        case MDMSPKR_OFF:
            pTG->NCUParams.SpeakerControl = 0;
            break;

        case MDMSPKR_DIAL:
            pTG->NCUParams.SpeakerControl = 1;
            break;

        case MDMSPKR_ON:
            pTG->NCUParams.SpeakerControl = 2;
            break;

        default:
            pTG->NCUParams.SpeakerControl = 0;
            break;
    }

    switch (pTG->dwSpeakerVolume) 
    {
        case MDMVOL_LOW:
            pTG->NCUParams.SpeakerVolume = 0;
            break;

        case MDMVOL_MEDIUM:
            pTG->NCUParams.SpeakerVolume = 2;
            break;

        case MDMVOL_HIGH:
            pTG->NCUParams.SpeakerVolume = 3;
            break;

        default:
            pTG->NCUParams.SpeakerVolume = 0;
            break;
    }


    pTG->NCUParams.DialBlind      = 4;  //X4

    // need to do this every time after a Reset/AT&F
    if(! iModemSetNCUParams(    pTG, 
                                (iInstall==fMDMINIT_ANSWER)?(-1): pTG->NCUParams.DialPauseTime,
                                pTG->NCUParams.SpeakerControl,
                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                pTG->NCUParams.SpeakerRing))
    {
        DebugPrintEx(DEBUG_WRN,"Can't Set NCU params - Ignoring that");
    }

    pTG->fNCUParamsChanged=FALSE;

    InitCommErrCount(pTG);

    // Why is this here??
    FComFlush(pTG);

    pTG->FComStatus.fModemInit = TRUE;
    // pTG->fNCUAbort = 0;
    uRet = INIT_OK;
    goto end;

error:
    FComClose(pTG);
    pTG->FComStatus.fModemInit = FALSE;
    // fall through...
end:
    PUTEVENT(pTG, wEVFLAGS_INIT, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_INIT_END,
                            uRet, 0, NULL);
    return uRet;
}


LPCMDTAB iModemGetCmdTabPtr(PThrdGlbl pTG)
{
    BG_CHK(pTG->FComStatus.fModemInit);
    BG_CHK(pTG->FComModem.CurrCmdTab.szReset);

    return (pTG->FComStatus.fModemInit) ? &pTG->FComModem.CurrCmdTab: NULL;
}


#define PARAMSBUFSIZE   60
#define fDETECT_DIALTONE 1
#define fDETECT_BUSYTONE 2

BOOL iModemSetNCUParams
(
    PThrdGlbl pTG, 
    int comma, 
    int speaker,
    int volume, 
    int fBlind, 
    int fRingAloud
)
{

    char bBuf[PARAMSBUFSIZE];
    USHORT uLen;

    DEBUG_FUNCTION_NAME(("iModemSetNCUParams"));

    _fstrcpy(bBuf, cbszJustAT);
    uLen = sizeof(cbszJustAT)-1;

    // +++ If we want to split this into dial-tone & busy-tone we
    //         Do it here...
    if ( (fBlind >= 0) && (pTG->ModemKeyCreationId == MODEMKEY_FROM_NOTHING) )
    {
        UINT u=0;
        switch(fBlind)
        {
        case 0:
                break;
        case fDETECT_DIALTONE:
                u=2;
                break;
        case fDETECT_BUSYTONE:
                u=3;
                break;
        default:
                u=4;
                break;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszXn, u);
    }

    if(comma >= 0)
    {
        if(comma > 255)
        {
            BG_CHK(FALSE);
            comma = 255;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszS8, comma);
    }
    if(speaker >= 0)
    {
        if(speaker > 2)
        {
            BG_CHK(FALSE);
            speaker = 2;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszMn, speaker);
    }
    if(volume >= 0)
    {
        if(volume > 3)
        {
            BG_CHK(FALSE);
            volume = 3;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszLn, volume);
    }

    // do something with RingAloud

    bBuf[uLen++] = '\r';
    bBuf[uLen] = 0;

    // use MultiLine because we may get asynchronous RING responses
    // at arbitrary times when on-hook
    if(OfflineDialog2(pTG, (LPSTR)bBuf, uLen, cbszOK, cbszERROR) != 1)
    {
        BG_CHK(FALSE);
        DebugPrintEx(DEBUG_ERR,"Can't Set NCU params");
        return FALSE;
    }
    return TRUE;
}

UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
    UWORD uRet1=0, uRet2=0, uRet3=0;

    DEBUG_FUNCTION_NAME(("GetCap"));
    // We call GetCapAux twice and if they don't match we
    // call it a 3rd time and arbitrate. Provided it doesn't
    // fail the first time.
    if (!(uRet1=GetCapAux(pTG, cbpstrSend, uwLen))) 
        goto end;

    uRet2=GetCapAux(pTG, cbpstrSend, uwLen);
    if (uRet1!=uRet2)
    {
        DebugPrintEx(   DEBUG_WRN,
                        "2nd getcaps return differs 1=%u,2=%u",
                        (unsigned)uRet1,
                        (unsigned)uRet2);

        uRet3=GetCapAux(pTG, cbpstrSend, uwLen);
        if (uRet1==uRet2 || uRet1==uRet3) 
        {
            goto end;
        }
        else if (uRet2==uRet3)
        {
            uRet1=uRet2; 
            goto end;
        }
        else
        {
            DebugPrintEx(   DEBUG_ERR,
                            "all 2 getcaps differ! 1=%u,2=%u, 3=%u",
                            (unsigned) uRet1, (unsigned) uRet2,
                            (unsigned) uRet3);
        }
    }

end: 
    return uRet1;

}

UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
    NPSTR sz;
    BYTE  speed, high;
    UWORD i, code;
    USHORT  retry;
    USHORT  uRet;

    DEBUG_FUNCTION_NAME(("GetCapAux"));
    retry = 0;
restart:
    retry++;
    if(retry > 2)
            return 0;

    DebugPrintEx(DEBUG_MSG,"Want Caps for (%s)", (LPSTR)cbpstrSend);

    pTG->fMegaHertzHack = TRUE;
    uRet = OfflineDialog2(pTG, (LPSTR)cbpstrSend, uwLen, cbszOK, cbszERROR);
    pTG->fMegaHertzHack=FALSE;

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(DEBUG_MSG,"LastLine = (%s)",(LPSTR)(&(pTG->FComModem.bLastReply)));

    if(uRet == 2)
            goto restart;

    if(_fstrlen((LPSTR)pTG->FComModem.bLastReply) == 0)
            goto restart;

    speed = 0;
    high = 0;
    for(i=0, sz=pTG->FComModem.bLastReply, code=0; i<REPLYBUFSIZE && sz[i]; i++)
    {
            if(sz[i] >= '0' &&  sz[i] <= '9')
            {
                    code = code*10 + (sz[i] - '0');
                    continue;
            }
            // reached a non-numeric char
            // if its teh first after a code, need to process the code.

            switch(code)
            {
            case 0:  continue;      // not the first char after a code
            case 3:  break;
            case 24: break;
            case 48: speed |= V27; break;
            case 72:
            case 96: speed |= V29; break;
            case 73:
            case 97:
            case 121:
            case 145: speed |= V33; break;  // long-train codes
            case 74:
            case 98:
            case 122:
            case 146: speed |= V17; break;  // short-train codes

            //case 92:
            //case 93:      break;
            // case 120: // not legal
            // case 144: // not legal
            default:
                            DebugPrintEx(   DEBUG_WRN,
                                            "Ignoring unknown Modulation code = %d",
                                            code);
                            // +++ goto restart;
                            code=0;
                            break;
                            // BG_CHK(FALSE);
                            // return 0;
            }
            if(code > high)
                    high=(BYTE)code;

            // reset code counter after processing the baud rate code
            code = 0;
    }

    if(speed == 0)
    {
        // got garbage in response to query
        DebugPrintEx(   DEBUG_MSG,
                        "Can't get Caps for (%s) = 0x%04x  Highest=%d", 
                        (LPSTR)cbpstrSend, 
                        speed, 
                        high);
        return 0;
    }

    if(speed == 0x0F) 
        speed = V27_V29_V33_V17;

/// RICOH's broken 1st prototype ////////////
///     speed = V27_SLOW;
///     high = 24;
/// RICOH's broken 1st prototype ////////////

    DebugPrintEx(   DEBUG_MSG,
                    "Got Caps for (%s) = 0x%04x  Highest=%d", 
                    (LPSTR)cbpstrSend, 
                    speed, 
                    high);

    return MAKEWORD(speed, high);   // speed==low byte
}

BOOL iModemGetCaps
(
    PThrdGlbl pTG, 
    LPMODEMCAPS lpMdmCaps, 
    DWORD dwSpeed, 
    LPSTR lpszReset,
    LPDWORD lpdwGot
)
{
    /** Modem must be synced up and in normal (non-fax) mode.
            Queries available classes,
            HDLC & Data receive and transmit speeds. Returns
            TRUE if Modem is Class1 or Class2, FALSE if not fax modem
            or other error. Sets the fields in the ET30INST struct **/
    // lpszReset, if nonempty, will be used to reset the modem after
    // the FCLASS=? command see comment about US Robotics Sportster below...

    UWORD   i, uwRet;
    BYTE    speed;
    BOOL    err;
    NPSTR   sz;
    USHORT  retry, uResp;

    DEBUG_FUNCTION_NAME(("iModemGetCaps"));
    if (!*lpdwGot) 
    {
        _fmemset(lpMdmCaps, 0, sizeof(MODEMCAPS));
    }

    if (*lpdwGot & fGOTCAP_CLASSES) 
        goto GotClasses;

    for(retry=0; retry<2; retry++)
    {
        pTG->fMegaHertzHack = TRUE;
        uResp = OfflineDialog2(pTG, (LPSTR)cbszQUERY_CLASS, sizeof(cbszQUERY_CLASS)-1, cbszOK, cbszERROR);
        pTG->fMegaHertzHack=FALSE;
        if(uResp != 2)
                break;
    }

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(   DEBUG_MSG, 
                    "LastLine = (%s)", 
                    (LPSTR)(&(pTG->FComModem.bLastReply)));


    lpMdmCaps->uClasses = 0;
    for(i=0, sz=pTG->FComModem.bLastReply; i<REPLYBUFSIZE && sz[i]; i++)
    {
        UINT uDig=0, uDec=(UINT)-1;

        // This code will accept 1.x as class1, 2 as class2 and 2.x as class2.0
        // Also, it will not detect class 1 in 2.1 or class2 in 1.2 etc.
        // (JDecuir newest class2.0 is labeled class2.1, and he talks
        //  of class 1.0...)
        if(sz[i] >= '0' && sz[i] <= '9')
        {
            uDig = sz[i]- '0';
            if (sz[i+1]=='.')
            {
                i++;
                if(sz[i+1] >= '0' && sz[i+1] <= '9')
                {
                    uDec = sz[i] - '0';
                    i++;
                }
            }
        }
        if(uDig==1) 
        {
            lpMdmCaps->uClasses |= FAXCLASS1;
        }
        if(uDig==2) 
        {
            if (uDec==((UINT)-1)) 
            {
                lpMdmCaps->uClasses |= FAXCLASS2;
            }
            else
            {
                lpMdmCaps->uClasses |= FAXCLASS2_0;
            }
        }
    }
    *lpdwGot |= fGOTCAP_CLASSES;

GotClasses:

    BG_CHK(*lpdwGot & fGOTCAP_CLASSES);
    BG_CHK(lpMdmCaps->uClasses & (FAXCLASS1|FAXCLASS2|FAXCLASS2_0));

    if(lpMdmCaps->uClasses & FAXCLASS2_0)
    {
            // Test Class2.0 ability
#ifndef CL2_0
        DebugPrintEx(DEBUG_ERR,"Class2.0 modem -- IS NOT supported");
        lpMdmCaps->uClasses &= (~FAXCLASS2_0);
#endif //CL2_0
    }

    if(lpMdmCaps->uClasses & FAXCLASS2)
    {
            // Test Class2 ability
#ifndef CL2
        DebugPrintEx(DEBUG_ERR,"Class2 modem -- IS NOT supported");
        lpMdmCaps->uClasses &= (~FAXCLASS2);
#endif //CL2
    }

    if(!lpMdmCaps->uClasses)
    {
        DebugPrintEx(DEBUG_ERR,"Not a fax modem or unsupported fax class");
        iModemSetError(pTG, MODEMERR_HARDWARE, ERR_NOTFAX, MODEMERRFLAGS_FATAL);
        *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
        return FALSE;
    }

    if(!(lpMdmCaps->uClasses & FAXCLASS1)) 
        return TRUE;

///////////////// rest is for Class1 only //////////////////////////

    //////////
    // MERGED from SNOWBALL.RC, but can't really do this in new scheme!!
    // The US Robotics Sportster Swedish resets itself after AT+FCLASS=?
    // So we need to issue a ATE0 here before trying to get caps
    // This is timing independent.
    // if(OfflineDialog2((LPSTR)cbszATE0, sizeof(cbszATE0)-1, cbszOK, cbszERROR) != 1)
    // {
    //      (MyDebugPrint(pTG, LOG_ERR,"<<WARNING>> Error on ATE0 in GetCaps %s\r\n", (LPSTR)cbszATE0));
    // }
    //////////
    //              +++ why is this done only for Class1?
    // What we do instead is send the Reset command
    if(lpszReset && *lpszReset && iModemReset(pTG, lpszReset) < 0) 
        return FALSE;
    //////////

    if(!iiModemGoClass(pTG, 1, dwSpeed)) 
        goto NotClass1;

    err = FALSE;
    if (!(*lpdwGot & fGOTCAP_SENDSPEEDS))
    {
        uwRet = GetCap( pTG, cbszQUERY_FTM, sizeof(cbszQUERY_FTM)-1);
        err = (err || uwRet==0);
        speed = LOBYTE(uwRet);
        BG_CHK((speed & ~0x0F)==0);
        lpMdmCaps->uSendSpeeds = speed;
        *lpdwGot |= fGOTCAP_SENDSPEEDS;
    }
    if (!(*lpdwGot & fGOTCAP_RECVSPEEDS))
    {
        uwRet = GetCap(pTG, cbszQUERY_FRM, sizeof(cbszQUERY_FRM)-1);
        err = (err || uwRet==0);
        speed = LOBYTE(uwRet);
        BG_CHK((speed & ~0x0F)==0);
        lpMdmCaps->uRecvSpeeds = speed;
        *lpdwGot |= fGOTCAP_RECVSPEEDS;
    }

    if(!iiModemGoClass(pTG, 0, dwSpeed))
        err = TRUE;

    if(err)
    {
        DebugPrintEx(DEBUG_ERR,"Cannot get capabilities");
        iModemSetError(pTG, MODEMERR_HARDWARE, ERR_NOCAPS, MODEMERRFLAGS_FATAL);
        goto NotClass1;
    }

    DebugPrintEx(DEBUG_MSG,"Got Caps");
    return TRUE;

NotClass1:
    // Reported Class1 but failed AT+FCLASS=1 or one of the Cap queries
    // GVC9624Vbis does this. See bug#1016
    // FIX: Just zap out the Class1 bit. If any other class supported
    // then return TRUE, else FALSE

    lpMdmCaps->uClasses &= (~FAXCLASS1);    // make the Class1 bit==0
    if(lpMdmCaps->uClasses)
    {
        return TRUE;
    }
    else
    {
        *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
        return FALSE;
    }
}

void TwiddleThumbs1( ULONG ulTime)
{
    DEBUG_FUNCTION_NAME(("TwiddleThumbs1"));

    // doesnt make sense to sleep for less
    // when talking to stupid modems
    // BG_CHK(ulTime >= 40);

    MY_TWIDDLETHUMBS(ulTime);

    DebugPrintEx(DEBUG_MSG,"Exit");
}

BOOL iModemGoClass(PThrdGlbl pTG, USHORT uClass)
{
    return iiModemGoClass(pTG, uClass, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
}


BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed)
{
    int i;
    USHORT uBaud;
    
    DEBUG_FUNCTION_NAME(("iiModemGoClass"));

    BG_CHK(!(dwSpeed & 0xFFFF0000L));

    for(i=0; i<3; i++)
    {
        // UDS V.3257 modem needs this time, because if we send it a
        // command too quickly after the previous response, it ignores
        // it or gets garbage
        TwiddleThumbs1(100);
        FComFlush(pTG);
        PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", rgcbpstrGO_CLASS[uClass]);
        if(!FComDirectSyncWriteFast(pTG, (LPB)rgcbpstrGO_CLASS[uClass], uLenGO_CLASS[uClass]))
            goto error;
        // wait 500ms. Give modem enough time to get into Class1 mode
        // otherwise the AT we send may abort the transition
// #ifdef CHECKGOCLASS
//              TwiddleThumbs1(uPause);
//#else // !CHECKGOCLASS
        TwiddleThumbs1(500);
//#endif // !CHECKGOCLASS

        if(dwSpeed)
        {
            USHORT usSpeed  = (USHORT) dwSpeed;
            BG_CHK((usSpeed >= 4800) &&
                     ((usSpeed % 2400) == 0) &&
                     ((1152 % (usSpeed/100)) == 0));

            uBaud = usSpeed;
        }
        else if (pTG->SerialSpeedInit) 
        {
           uBaud = pTG->SerialSpeedInit;
        }
        else 
        {
           uBaud = 57600;
        }

        // RSL don't do hard-coded 2400 for class0.

        FComSetBaudRate(pTG, uBaud);

        FComFlush(pTG);
        if(iModemSync(pTG) >= 0)
        {
            InitCommErrCount(pTG);
            return TRUE;
        }
    }
error:
    // no point -- and we'll smash our settings
    // iModemReset();
    // error is already set to ERR_NO_RESPONSE inside HayesSync()
    DebugPrintEx(DEBUG_ERR,"Cant go to Class %d", uClass);
    return FALSE;
}

BOOL iModemClose(PThrdGlbl pTG)
{
    USHORT uLen;
    BOOL fRet=FALSE;

    DEBUG_FUNCTION_NAME(("iModemClose"));

    if(!pTG->FComStatus.fModemInit)
        return TRUE;


    PUTEVENT(pTG, wEVFLAGS_DEINIT, EVENT_ID_MODEM_STATE,
                            EVENT_SubID_MODEM_DEINIT_START, 0, 0, NULL);
    /** Hangs up the phone if it is off hook, closes the COM port
            and returns. If hangup fails then port is also left open. **/


    if(!iModemHangup(pTG))
        goto lNext;


    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        goto lNext;
    }

    if(pTG->FComModem.CurrCmdTab.szExit && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szExit)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szExit, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in EXIT string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szExit);
        }
    }

lNext:
    if(FComClose(pTG))
    {
        pTG->FComStatus.fModemInit = FALSE;
        fRet=TRUE;
    }

    PUTEVENT(pTG, wEVFLAGS_DEINIT, EVENT_ID_MODEM_STATE,
                            EVENT_SubID_MODEM_DEINIT_END, fRet, 0, NULL);
#ifdef MON3
    if (pTG->gMonInfo.fInited)
    {
        MonDump(pTG);
        MonDeInit(pTG);
    }
#endif // MON3
    return fRet;
}

BOOL iModemHangup(PThrdGlbl pTG)
{
    BOOL fRet=FALSE;

    DEBUG_FUNCTION_NAME(("iModemHangup"));

    if(!pTG->FComStatus.fOffHook) 
    {
        DebugPrintEx(   DEBUG_WRN,
                        "The modem is already on-hook!!!! return without doing nothing");
        return TRUE;
    }

    // Note: iModemHangup is called by NCULink in ddi.c.
    // Rather than do adaptive-answer-specific code in ddi.c as well,
    // we simply ignore the hangup command in the following case...

// RSL  if (pTG->Comm.fEnableHandoff && pTG->Comm.fExternalHandle && pTG->Comm.fDataCall)
    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall)
    {
        DebugPrintEx(DEBUG_WRN,"IGNORING Hangup of datamodem call");
            return TRUE;
    }

    PSSLogEntry(PSS_MSG, 1, "Hanging up");

    PUTEVENT(pTG, wEVFLAGS_HANGUP, EVENT_ID_MODEM_STATE,
                    EVENT_SubID_MODEM_HANGUP_START, 0, 0, NULL);
    // ST_MOD(D_FComPrint(pTG->FComStatus.uComPort-1));
    // FComDTR(FALSE);              // Lower DTR to hangup in ModemHangup
                                            // Need to have &D2 in init string for this.

    // Do this twice. There is a bizarre case where you drop DTR,
    // then go into Dialog, flush, send ATH0, then the modem gives
    // you an OK for the DTR, and you take it as one for the ATH0
    // maybe that's ok....if this gets too slow, skip this.
    HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1);

    if(HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
    {
        FComDTR(pTG, FALSE);         // Lower DTR on stubborn hangups in ModemHangup
        TwiddleThumbs1(1000);    // pause 1 second
        FComDTR(pTG, TRUE);          // raise it again. Some modems return to cmd state
                                                // only when this is raised again

        if(iModemReset(pTG, pTG->FComModem.CurrCmdTab.szReset) < 0)
            goto error;
        if(HayesSyncSpeed(pTG, TRUE, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
            goto error;
    }
    pTG->FComStatus.fOffHook = FALSE;

    if(!iiModemGoClass(pTG, 0, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
        goto end;
            // Can also ignore this return value. Just for tidier cleanup

    // Avoid! we'll smash our settings
    // iModemReset();
    fRet=TRUE;
    goto end;

error:
    FComDTR(pTG, TRUE);          // raise it again
    BG_CHK(!fRet);
    // fall through...

end:
    PUTEVENT(pTG, wEVFLAGS_HANGUP, EVENT_ID_MODEM_STATE,
                    EVENT_SubID_MODEM_HANGUP_END, fRet, 0, NULL);
    return fRet;
}

#define DIAL_TIMEOUT    70000L

#define TIME_DELTA(prev, now)\
    (((prev)<=(now)) ?((now)-(prev)) : (now) + (0xffffffffL-(prev)))

USHORT iModemDial(PThrdGlbl pTG, LPSTR lpszDial, USHORT uClass)
{
    ULONG   ulTimeout;
    USHORT  uRet, uLen, uDialStringLen;
    BYTE    bBuf[DIALBUFSIZE];
    CBPSTR  cbpstr;
    char    chMod = pTG->NCUParams.chDialModifier;
    DWORD   dw=0;
    char    KeyName[200];
    HKEY    hKey;
    char    BlindDialString[200];
    char    RegBlindDialString[200];
    long    lRet;
    DWORD   dwSize;
    DWORD   dwType;

    DEBUG_FUNCTION_NAME(("iModemDial"));
    
    BG_CHK(lpszDial);

    pTG->FComStatus.fOffHook = TRUE;     // Has to be here. Can get an error return
                                                           // below even after connecting
                                                            // and we want to hangup after that!!
    BG_CHK(pTG->Comm.fDataCall==FALSE);
    pTG->Comm.fDataCall=FALSE;

    BG_CHK(uClass==FAXCLASS0 || uClass==FAXCLASS1);

    //
    // check "Modems->Properties->Connection->Wait for dial tone" setting before dialing
    // to correctly set ATX to possibly blind dial
    //
    if (pTG->fBlindDial) 
    {
       // create default string
       sprintf(BlindDialString, "ATX3\r");
       
       // need to check Unimodem Settings\Blind_On key. 
       sprintf(KeyName, "%s\\Settings", pTG->lpszUnimodemKey);

       lRet = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KeyName,
                       0,
                       KEY_READ,
                       &hKey);
   
       if (lRet != ERROR_SUCCESS) 
       {
          DebugPrintEx(DEBUG_ERR, "Can't read Unimodem Settings key %s", KeyName);
       }
       else 
       {
          dwSize = sizeof(RegBlindDialString); 

          lRet = RegQueryValueEx(
                     hKey,
                     "Blind_On",
                     0,
                     &dwType,
                     RegBlindDialString,
                     &dwSize);

          RegCloseKey(hKey);

          if (lRet != ERROR_SUCCESS) 
          {
              DebugPrintEx( DEBUG_ERR, 
                            "Can't read Unimodem key\\Settings\\Blind_On value");
          }
          else if (RegBlindDialString) 
          {
             sprintf(BlindDialString, "AT%s\r", RegBlindDialString);
          }
       }
    }


    // Let's update the modem settings here, if required.
    if (pTG->fNCUParamsChanged)
    {
        if (!iModemSetNCUParams(    pTG, 
                                    pTG->NCUParams.DialPauseTime,
                                    pTG->NCUParams.SpeakerControl,
                                    pTG->NCUParams.SpeakerVolume, 
                                    pTG->NCUParams.DialBlind,
                                    pTG->NCUParams.SpeakerRing))
        {
            DebugPrintEx(DEBUG_WRN,"iModemSetNCUParams FAILED");
        }
        pTG->fNCUParamsChanged=FALSE;
    }

    if(uClass==FAXCLASS1)
    {
        if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
        {
            uRet = CONNECT_ERROR;
            goto error;
        }
    }

    //
    // blind dial set here if requested by user
    //
    if (pTG->fBlindDial && BlindDialString) 
    {
       uLen = (USHORT)strlen(BlindDialString);
       if(OfflineDialog2(pTG, BlindDialString, uLen, cbszOK, cbszERROR) != 1)
       {
           DebugPrintEx(    DEBUG_ERR,
                            "Error in BLIND DIAL string: %s", 
                            BlindDialString);
       }
    }

    if(pTG->FComModem.CurrCmdTab.szPreDial && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreDial)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in PREDIAL string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial);
        }
    }

    cbpstr = cbszDIAL;

    // If the dial string already has a T or P prefix, we use that
    // instead.
    {
        char c=0;
        while((c=*lpszDial) && c==' ')
            *lpszDial++;

        if (c=='t'|| c=='T' || c=='p'|| c=='P')
        {
            chMod = c;
            lpszDial++;
            while((c=*lpszDial) && c==' ')
                *lpszDial++;
        }
    }

    BG_CHK(chMod=='P' || chMod=='T' || chMod=='p' || chMod=='t');

    // in mdmcmds.h you can find this line: cbszDIAL = "ATD%c %s\r"
    uLen = (USHORT)wsprintf(bBuf, cbpstr, chMod, (LPSTR)lpszDial);

    // Need to set an approriate timeout here. A minimum of 15secs is too short
    // (experiment calling machines within a PABX), plus one has to give extra
    // time for machines that pick up after 2 or 4 rings and also for long distance
    // calls. I take a minumum of 30secs and add 3secs for each digits over 7
    // (unless it's pulse dial in which case I add 8secs/digit).
    // (I'm assuming that a long-distance call will take a minimum of 8 digits
    // anywhere in ths world!). Fax machines I've tested wait about 30secs
    // independent of everything.

    uDialStringLen = (USHORT)_fstrlen(lpszDial);

    ulTimeout=0;
    if(uDialStringLen > 7)
    {
            ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000)
                                     * (uDialStringLen - 7);
    }

    if(pTG->NCUParams.AnswerTimeout != -1 &&
            (((ULONG)pTG->NCUParams.AnswerTimeout * 1000L) > ulTimeout))
    {
        ulTimeout = 1000L * (ULONG)pTG->NCUParams.AnswerTimeout;
        if (ulTimeout<20000L) ulTimeout=20000L;
    }
    else
    {
        ulTimeout += DIAL_TIMEOUT;
    }

    if(pTG->fNCUAbort)
    {
        DebugPrintEx(DEBUG_ERR,"aborting");
        pTG->fNCUAbort = 0;
        uRet = CONNECT_ERROR;
        goto error;
    }
    ICommStatus(pTG, T30STATS_DIALING, 0, 0, 0);
    pTG->FComStatus.fInDial = TRUE;
    // look for MultiLine, just in case we get echo or garbage.
    // Nothing lost, since on failure of this we can't do anything

    // uRet = iiModemDialog((LPB)bBuf, uLen, ulTimeout, TRUE, 1, TRUE,
    //                                       cbszCONNECT, cbszBUSY, cbszNOANSWER,
    //                                       cbszNODIALTONE, cbszERROR, (CBPSTR)NULL);
    // Send seperately & use iiModemDialog only for the response

    // all this just to send the ATDT
    FComFlushOutput(pTG);
    TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
    FComFlushInput(pTG);

    PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", bBuf);
    
    FComDirectAsyncWrite(pTG, bBuf, uLen);
    // now try to get a response
    dw = GetTickCount();
    uRet = iiModemDialog(   pTG, 
                            0, 
                            0, 
                            ulTimeout, 
                            TRUE, 
                            1, 
                            TRUE,
                            cbszCONNECT, 
                            cbszBUSY, 
                            cbszNOANSWER,
                            cbszNODIALTONE, 
                            cbszERROR, 
                            cbszBLACKLISTED,
                            cbszDELAYED,
                            cbszNOCARRIER, 
                            (CBPSTR)NULL);

    pTG->FComStatus.fInDial = FALSE;
    DebugPrintEx(DEBUG_MSG,"ModemDial -- got %d response from Dialog", uRet);


#if !((CONNECT_TIMEOUT==0) && (CONNECT_OK==1) && (CONNECT_BUSY==2) && (CONNECT_NOANSWER == 3) && (CONNECT_NODIALTONE==4) && (CONNECT_ERROR==5) && (CONNECT_BLACKLISTED==6) && (CONNECT_DELAYED==7))
#error CONNECT defines not correct ERROR, OK, BUSY, NOANSWER, NODIALTONE == CONNECT_ERROR, CONNECT_OK, CONNECT_BUSY, CONNECT_NOANSWER, CONNECT_NODIALTONE
#else
#pragma message("verified CONNECT defines")
#endif


    switch(uRet)
    {
    case CONNECT_TIMEOUT:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - timeout");
        break;

    case CONNECT_OK:
        PSSLogEntry(PSS_MSG, 1, "Response - CONNECT");
        break;

    case CONNECT_BUSY:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_BUSY);
        PSSLogEntry(PSS_ERR, 1, "Response - BUSY");
        break;

    case CONNECT_NOANSWER:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - NO ANSWER");
        break;

    case CONNECT_NODIALTONE:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_DIAL_TONE);
        PSSLogEntry(PSS_ERR, 1, "Response - NO DIALTONE");
        break;

    case CONNECT_ERROR:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - ERROR");
        break;

    case CONNECT_BLACKLISTED:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_CALL_BLACKLISTED);
        PSSLogEntry(PSS_ERR, 1, "Response - BLACKLISTED");
        break;

    case CONNECT_DELAYED:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_CALL_DELAYED);
        PSSLogEntry(PSS_ERR, 1, "Response - DELAYED");
        break;

    case 8: {
                DWORD dwNow=GetTickCount();
                DWORD dwDelta = TIME_DELTA(dw, dwNow);
                PSSLogEntry(PSS_ERR, 1, "Response - NO CARRIER");
                if (dwDelta < 5000L)
                {
                    DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's BUSY");
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_BUSY);
                    uRet = CONNECT_BUSY;
                }
                else
                {
                    DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's TIMEOUT");
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_NO_ANSWER);
                    uRet = CONNECT_TIMEOUT;
                }
            }
            break;

    default:
         BG_CHK(FALSE);

    }

    if(uRet == CONNECT_OK)
    {
            goto done;
    }
    else
    {
            if(uRet == CONNECT_TIMEOUT)     
            {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_NO_ANSWER);

                uRet = CONNECT_NOANSWER;
                    // call it a no answer
            }

            goto error;
    }

    // no fallthru here
    BG_CHK(FALSE);

error:
    if(!iModemHangup(pTG))
    {
        // BG_CHK(FALSE);
        // at this point in teh production version we
        // need to call some OS reboot function!!
        DebugPrintEx(DEBUG_ERR,"Can't Hangup after DIALFAIL");
        uRet = CONNECT_ERROR;
    }
    // fall through
    ICommFailureCode(pTG, T30FAILS_NCUDIAL_ERROR + uRet);
done:
    PUTEVENT(pTG, wEVFLAGS_DIAL, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_DIAL_END,
                            uRet, 0, NULL);
    return uRet;
}


// fImmediate==FALSE -- wait for NCUParams.NumRings else answer right away
USHORT   iModemAnswer(PThrdGlbl pTG, BOOL fImmediate, USHORT uClass)
{
    CBPSTR  cbpstr;
    USHORT  uLen, uRet;
    char    Command[400];
    int     i;

    DEBUG_FUNCTION_NAME(("iModemAnswer"));

    pTG->FComStatus.fOffHook=TRUE;       // Has to be here. Can screwup after answering
                                                            // but before CONNECT and we want to hangup
                                                            // after that!!
    BG_CHK(pTG->Comm.fDataCall==FALSE);
    pTG->Comm.fDataCall=FALSE;

/**** Not looking for RING should speed things up *********************
    (MyDebugPrint(pTG, "Looking for RING\r\n"));
    // However with an external modem this can cause problems
    // because we may go into a 14second wait for answer, with phone
    // off hook. Better to read S1 here. If 0 return error. If non-zero
    // loop until reaches X or timeout (in case other guy hangs up before
    // X rings).

    // Don't resync here. We'll flush the RING from the buffer!!
    // if EfaxCheckForRing() fails, the callers will resync
    // through FaxSync()

#define RING_TIMEOUT 15000                              // Random Timeout
// Need to wait reasonably long, so that we don't give up too easily

    if(!iModemResp1(RING_TIMEOUT, cbszRING))
            {uRet=CONNECT_NORING_ERROR; goto done;}

**********************************************************************/

    BG_CHK(uClass==FAXCLASS0 || uClass==FAXCLASS1);

    if (pTG->fNCUParamsChanged)
    {
        if (!iModemSetNCUParams(    pTG,  
                                    pTG->NCUParams.DialPauseTime,
                                    pTG->NCUParams.SpeakerControl,
                                    pTG->NCUParams.SpeakerVolume, 
                                    pTG->NCUParams.DialBlind,
                                    pTG->NCUParams.SpeakerRing))
        {
            DebugPrintEx(DEBUG_WRN,"iModemSetNCUParams FAILED");
        }
        pTG->fNCUParamsChanged=FALSE;
    }

    //
    // below is Adaptive Answer handling. 
    // It is separate because all the commands are defined via INF
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       for (i=0; i< (int) pTG->AnswerCommandNum; i++) 
       {
          sprintf (Command, "%s",  pTG->AnswerCommand[i] );

          if (i == (int) pTG->AnswerCommandNum - 1) 
          {
             // last command-answer
             FComFlushOutput(pTG);
             TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
             FComFlushInput(pTG);

             PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", Command);
             FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );

             pTG->FComStatus.fInAnswer = TRUE;
             
             break;

          }


          if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
          {
              DebugPrintEx(DEBUG_ERR, "Answer %d=%s FAILED", i, Command);
          }
          else 
          {
              DebugPrintEx(DEBUG_MSG, "Answer %d=%s rets OK", i, Command);
          }
       }

       uRet=iModemGetAdaptiveResp(pTG);
       pTG->FComStatus.fInAnswer=FALSE;
       if (uRet==CONNECT_OK) 
           goto done;
       else          
           goto error;
    }

    //
    // assuming FAX call since can't determine that anyway...
    //
    else if(uClass==FAXCLASS1)
    {
            // 5/95 JosephJ:Elliot Bug#3421 -- we issue the AT+FCLASS=1 command
            //      twice so that if one gets zapped by a RING the other will
            //          be OK.
            if (pTG->FComModem.CurrCmdTab.dwFlags&fMDMSP_ANS_GOCLASS_TWICE)
                    iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
            if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
            {
                    uRet = CONNECT_ERROR;
                    goto error;
            }
    }

    if(pTG->FComModem.CurrCmdTab.szPreAnswer && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreAnswer)))
    {
            if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer, uLen, cbszOK, cbszERROR) != 1)
            {
                    DebugPrintEx(   DEBUG_WRN,
                                    "Error on PREANSWER string: %s", 
                                    (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer);
            }
    }



#define ANSWER_TIMEOUT 40000                            // Random Timeout
// Need to wait reasonably long, so that we don't give up too easily

    cbpstr = cbszANSWER;
    uLen = sizeof(cbszANSWER)-1;

    if(pTG->fNCUAbort)
    {
        DebugPrintEx(DEBUG_ERR,"aborting");
        pTG->fNCUAbort = 0;
        uRet = CONNECT_ERROR;
        goto error;
    }

    ICommStatus(pTG, T30STATR_ANSWERING, 0, 0, 0);
    pTG->FComStatus.fInAnswer = TRUE;

    // if(!iModemDialog((LPSTR)cbpstr, uLen, ANSWER_TIMEOUT, cbszCONNECT))
    // look for MultiLine, just in case we get echo or garbage.
    // Nothing lost, since on failure of this we can't do anything

    // if(!iiModemDialog((LPB)cbpstr, uLen, ANSWER_TIMEOUT, TRUE, 1, TRUE,
    //                                       cbszCONNECT, (CBPSTR)NULL))
    // Send seperately & use iiModemDialog only for the response

    // all this just to send the ATA


    FComFlushOutput(pTG);
    TwiddleThumbs1(200);     // 100 is not too long for this IMPORTANT one!
    FComFlushInput(pTG);
    PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", cbpstr);
    FComDirectAsyncWrite(pTG, cbpstr, uLen);

    // this is used to complete a whole IO operation (presumably a short one)
    // when this flag is set, the IO won't be disturbed by the abort event
    // this flag should NOT be set for long periods of time since abort
    // is disabled while it is set.
    pTG->fStallAbortRequest = TRUE;
    // now try to get a response
    
    if(!iiModemDialog(pTG, 0, 0, ANSWER_TIMEOUT, TRUE, 1, TRUE, cbszCONNECT, (CBPSTR)NULL))
    {
        pTG->FComStatus.fInAnswer = FALSE;
        PSSLogEntry(PSS_ERR, 1, "Response - ERROR");

        // try to hangup and sync with modem. This should work
        // even if phone is not really off hook
        uRet = CONNECT_ERROR;
        goto error;
    }
    else
    {
        pTG->FComStatus.fInAnswer = FALSE;
        PSSLogEntry(PSS_MSG, 1, "Response - CONNECT");

        uRet = CONNECT_OK;
        goto done;
    }

    // no fallthru here
    BG_CHK(FALSE);

error:

    if (pTG->Comm.fEnableHandoff && uRet==CONNECT_WRONGMODE_DATAMODEM)
    {
        // We won't hangup.
        ICommFailureCode(pTG, T30FAILR_NCUANSWER_ERROR); // ++ Change
        // We deliberately leave pTG->FComStatus.fOffHook to TRUE, because
        // it is off hook.
        goto done;
    }

    if(!iModemHangup(pTG))
    {
        // BG_CHK(FALSE);
        // at this point in teh production version we need to
        // call some OS reboot function!!
        // In WFW this can occur if an external modem has been
        // powered down. so just drop thru & return ERROR
        DebugPrintEx(DEBUG_ERR,"Can't Hangup after ANSWERFAIL");
        uRet = CONNECT_ERROR;
    }
    ICommFailureCode(pTG, T30FAILR_NCUANSWER_ERROR);
    // fall through

done:
    PUTEVENT(pTG, wEVFLAGS_DIAL, EVENT_ID_MODEM_STATE, EVENT_SubID_MODEM_ANSWER_END,
                            uRet, 0, NULL);
    return uRet;

}


LPSTR my_fstrstr( LPSTR sz1, LPSTR sz2)
{
        int i, len1, len2;

        if ( (sz1 == NULL) || (sz2 == NULL) ) {
            return NULL;
        }

        len1 = _fstrlen(sz1);
        len2 = _fstrlen(sz2);

        for(i=0; i<=(len1-len2); i++)
        {
                if(_fmemcmp(sz1+i, sz2, len2) == 0)
                        return sz1+i;
        }
        return NULL;
}






int my_strcmp(LPSTR sz1, LPSTR sz2)
{

   if ( (sz1 == NULL) || (sz2 == NULL) ) 
   {
       return FALSE;
   }

   if ( strcmp(sz1, sz2) == 0 ) 
   {
      return TRUE;
   }

   return FALSE;

}


BOOL fHasNumerals(PThrdGlbl pTG, LPSTR sz)
{
        int i;

        if (sz == NULL) 
        {
            return FALSE;
        }

        for(i=0; sz[i]; i++)
        {
                if(sz[i] >= '0' && sz[i] <= '9')
                        return TRUE;
        }
        return FALSE;
}


#define DIALOGRETRYMIN  600
#define SECONDLINE_TIMEOUT      500
#define ABORT_TIMEOUT    250
#ifdef DEBUG
#       define DEFMONVAL 1
#else   //!DEBUG
#       define DEFMONVAL 0
#endif  //!DEBUG
#define szMONITOREXISTINGFILESIZE "MonitorMaxOldSizeKB"
#define szMONITORDIR                      "MonitorDir"


UWORD far iiModemDialog
(   PThrdGlbl pTG, 
    LPSTR szSend, 
    UWORD uwLen, 
    ULONG ulTimeout,
    BOOL fMultiLine, 
    UWORD uwRepeatCount, 
    BOOL fPause,
    CBPSTR cbpstrWant1, 
    CBPSTR cbpstrWant2,
    ...
)
{
        /** Takes a command string, and it's lengt writes it out to the modem
            and tries to get one of the allowed responses. It writes the command
                out, waits ulTimeOut millisecs for a response. If it gets one of the
                expected responses it returns immediately.

                If it gets an unexpected/illegal response it tries (without any
                waiting) for subsequent lines to the same response.     When all the
                lines (if > 1) of the response lines are exhausted, if none is among the
                expected responses, it writes the command again and tries again,
                until ulTimeout has expired. Note that if no response is received,
                the command will be written just once.

                The whole above thing will be repeated upto uwRepeatCount times
                if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

                It returns when (a) one of the specified responses is received or
                (b) uwRepeatCount tries have failed (each having returned an
                illegal response or having returned no response in ulTimeout
                millsecs) or (c) the command write failed, in which
                case it returns immediately.

                It flushes the modem inque before each Command Write.

                Returns 0 on failure and the 1 based index of the successful
                response on     success.

                This can be used in the following way:-

                for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
                value, of the order of the transmission time of the longest
                possible (erroneous or correct) line of response plus the size
                of the command. eg. at 1200baud we have about 120cps = about
                10ms/char. Therefore a timeout of about 500ms is more than
                adequate, except for really long command lines.

                for Local Sync dialogs, used to sync up with the modem which may
                be in an unsure state, use the same timeout, but also a repeat
                count of 2 or 3.

                for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
                after the flags have been received, and which may incur a delay
                before a response (ATDT is teh same. CONNECT is issued after a
                long delay & anything the DTE sends will abort the process).
                For these cases the caller should supply a long timeout and
                probably a repeatcount of 1, so that the
                routine will timeout after one try but go on issuing teh command
                as long as an error repsonse is received.

                For +FRH etc, the long timeout should be T1 or T2 in teh case of
                CommandRecv and ResponseRecv respectively.

        **/


    BYTE bReply[REPLYBUFSIZE];
    UWORD   i, j, uwRet, uwWantCount;
    SWORD   swNumRead;
    CBPSTR  rgcbszWant[10];
    va_list ap;
    LPTO    lpto, lptoRead, lpto0;
    BOOL    fGotFirstLine, fFirstSend;
    ULONG   ulLeft;
    UINT    uPos=0;

    DEBUG_FUNCTION_NAME(("iiModemDialog"));
    pTG->FComModem.bEntireReply[0]=0;

    // ensure that we'll abort in FComm only on fresh calls to NCUAbort
    // protecting ourselves against this var being randomly left set.
    // Note we check this variable _just_ before calling ModemDialog
    // in NCUDial and NCUAnswer & assuming atomicity between then and here
    // we'll never miss an abort in a Dial/Answer

    BG_CHK(uwRepeatCount>0);
    // extract the (variable length) list of acceptable responses.
    // each is a CBSZ, code based 2 byte ptr

    // first response always present
    rgcbszWant[1] = cbpstrWant1;

    if((rgcbszWant[2] = cbpstrWant2) != NULL)
    {
        // if more than one response
        va_start(ap, cbpstrWant2);
        for(j=3; j<10; j++)
        {
                if((rgcbszWant[j] = va_arg(ap, CBPSTR)) == NULL)
                        break;
        }
        uwWantCount = j-1;
        va_end(ap);
    }
    else
    {
        uwWantCount = 1;
    }

    BG_CHK(uwWantCount>0);

    if(szSend)
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "Dialog: Send (%s) len=%d WantCount=%d time=%ld rep=%d", 
                        (LPSTR)szSend,
                        uwLen, 
                        uwWantCount, 
                        ulTimeout, 
                        uwRepeatCount);
    }
    else
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "Response: WantCount=%d time=%ld rep=%d",
                        uwWantCount, 
                        ulTimeout, 
                        uwRepeatCount);
    }
    for(j=1; j<=uwWantCount; j++)
    {
        DebugPrintEx(DEBUG_MSG,"Want %s",(LPSTR)(rgcbszWant[j]));
    }

    lpto = &(pTG->FComModem.toDialog);
    lpto0 = &(pTG->FComModem.toZero);
    pTG->FComStatus.fInDialog = TRUE;

    // Try the dialog upto uwRepeatCount times
    for(uwRet=0, i=0; i<uwRepeatCount; i++)
    {
        startTimeOut(pTG, lpto, ulTimeout);
        fFirstSend = TRUE;
        do
        {
            if(szSend)
            {
                if(!fFirstSend)
                {
                    ulLeft = leftTimeOut(pTG, lpto);
                    if(ulLeft <= DIALOGRETRYMIN)
                    {
                        DebugPrintEx(DEBUG_MSG,"ulLeft=%ul too low",ulLeft);
                        break;
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_MSG,"ulLeft=%ul OK",ulLeft);
                    }
                }
                fFirstSend = FALSE;

                // If a command is supplied, write it out, flushing input
                // first to get rid of spurious input.

        /*** SyncWrite calls Drain here which we should not need **
         *** as we are immediately waiting for a response *********
         **********************************************************
                if(!FComDirectSyncWrite(szSend, uwLen))
         **********************************************************/

                if(fPause)
                        TwiddleThumbs1(40);      // 100 is too long

                // FComFlushInput();
                FComFlush(pTG);            // Need to flush output too? Maybe...
                // there's nowhere else to flush/loosen up teh output

                // The flush has to be as late in the game as possible,
                // because if teh previous command got confused & accepted
                // a response to an earlier command or something, then
                // it's response may still be in transit (this happened
                // on Sharad's PP9600FXMT), so the later we do this the
                // better. So we send the entire command w/o teh \r,
                // wait for it to drain, then Flush again (input only
                // this time) then send the CR

///////// Potential Major source of failures ////////
// DirectSyncWrite calls Drain which calls DllSleep if everything
// is not drained, so we could end up waiting for 1 time slice
// which is at least 50ms and looks like it can be much higher on
// some machines. This was screwing up our AT+FTM=96 is some cases
// FIX: Enter Crit section here exit after this is done
//////////////////////////////////////////////////////

                FComCritical(pTG, TRUE);     // make sure to exit on all paths out of here

                BG_CHK(szSend[uwLen-1] == '\r');

                PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", szSend);
                
                if(!FComDirectSyncWriteFast(pTG, szSend, (UWORD)(uwLen-1)))
                {

                    FComCritical(pTG, FALSE);

                    // Need to check that we are sending only ASCII or pre-stuffed data here
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Sync Write timed Out");
                    uwRet = 0;
                    goto error;
                    // If Write fails, fail & return immediately.
                    // SetMyError() will already have been called.
                }
                // output has drained. Now flush input
                FComFlushInput(pTG);
                // and then send the CR
                if(!FComDirectAsyncWrite(pTG, "\r", 1))
                {

                    FComCritical(pTG, FALSE);
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Write timed Out on CR");
                    uwRet = 0;
                    goto error;
                }

                FComCritical(pTG, FALSE);

            }

            // Try to get a response until timeout or bad response
            pTG->FComModem.bLastReply[0] = 0;
            fGotFirstLine=FALSE;

            for(lptoRead=lpto;;startTimeOut(pTG, lpto0, SECONDLINE_TIMEOUT), lptoRead=lpto0)
            {
                    // get a CR-LF terminated line
                    // for the first line use macro timeout, for multi-line
                    // responses use 0 timeout.
retry:
                    swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);
                    DebugPrintEx(DEBUG_MSG,"FComFilterReadLine returns %d",swNumRead);
                    if(swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                            goto retry;             // blank line -- throw away & get another

                    // Fix Bug#1226. Elsa Microlink returns this garbage line in
                    // response to AT+FCLASS=?, followed by the real reply. Since
                    // we only look at the first line, we see only this garbage line
                    // and we never see the real reply (0, 1, 2, 2.0)
                    if(swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                            goto retry;

                    // Fix Elliot bug#3619 -- German modem TE3801 sends us
                    // \r\r\nOK\r\n -- so we treat \r\r\n as blank line.
                    if(swNumRead==3 && bReply[0]=='\r' && bReply[1]=='\r' && bReply[2]=='\n')
                            goto retry;

                    if(swNumRead == 0)      // timeout
                    {
                        if(fGotFirstLine)
                        {
                            // for MegaHertz, which returns no OK after
                            // capabilities queries
                            if(pTG->fMegaHertzHack)
                            {
                                if(fHasNumerals(pTG, pTG->FComModem.bLastReply))
                                {
                                    uwRet = 1;
                                    goto end;
                                }
                            }
                            break;
                        }
                        else
                        {
                            goto timeout;
                        }
                    }
                    if(swNumRead < 0)       // error-but lets see what we got anyway
                            swNumRead = (-swNumRead);

                    fGotFirstLine=TRUE;


                    //
                    // +++ HACK:
                    // We add everything upto the first NULL of each
                    // line of reply to bEntireReply, for the specific
                    // case of fMultiLine==uMULTILINE_SAVEENTIRE
                    // This is so we save things like:
                    // \r\nDATA\r\n\r\nCONNECT 12000\r\n
                    //
                    if(pTG->Comm.fEnableHandoff && fMultiLine==uMULTILINE_SAVEENTIRE
                            && uPos<sizeof(pTG->FComModem.bEntireReply))
                    {
                        UINT cb;
                        bReply[REPLYBUFSIZE-1]=0;
                        cb = _fstrlen(bReply);
                        if ((cb+1)> (sizeof(pTG->FComModem.bEntireReply)-uPos))
                        {
                            DebugPrintEx(DEBUG_WRN, "bEntireReply: out of space");
                            BG_CHK(FALSE);
                            cb=sizeof(pTG->FComModem.bEntireReply)-uPos;
                            if (cb) cb--;
                        }
                        _fmemcpy((LPB)pTG->FComModem.bEntireReply+uPos, (LPB)bReply, cb);
                        uPos+=cb;
                        pTG->FComModem.bEntireReply[uPos]=0;
                    }

                    PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);

                    for(bReply[REPLYBUFSIZE-1]=0, j=1; j<=uwWantCount; j++)
                    {
                        if(my_fstrstr(bReply, rgcbszWant[j]) != NULL)
                        {
                            uwRet = j;
                            goto end;
                        }
                    }


                    if(!fMultiLine)
                            break;
                    // Got something unknown
                    // Retry command and response until timeout

                    // We reach here it IFF we got a non blank reply, but it wasn't what
                    // we wanted. Squirrel teh first line away somewhere so that we can
                    // retrieve is later. We use this hack to get multi-line informational
                    // responses to things like +FTH=? Very important to ensure that
                    // blank-line replies don't get recorded here. (They may override
                    // the preceding line that we need!).

                    if( (pTG->FComModem.bLastReply[0] == 0) ||
                        ( ! _fstrcmp(pTG->FComModem.bLastReply, cbszRING) ) ) 
                    {
                                // copy only if _first_ response line
                            _fmemcpy((LPB)pTG->FComModem.bLastReply, (LPB)bReply, REPLYBUFSIZE);
                    }
                    // copies whole of bReply which includes zero-termination put
                    // there by FComFilterReadLine
                    DebugPrintEx(   DEBUG_MSG,
                                    "Saved line (%s)", 
                                    (LPSTR)(&(pTG->FComModem.bLastReply)));
            }
            // we come here only on unknown reply.
            BG_CHK(swNumRead > 0 || fGotFirstLine);
        }
        while(checkTimeOut(pTG, lpto));

        if(fGotFirstLine)
                continue;

        DebugPrintEx(DEBUG_WRN,"Weird!! got timeout in iiModemDialog loop");
timeout:
        // Need to send anychar to abort the previous command.
        // use random 120ms timeout -- too short. upped to 250
        BG_CHK(swNumRead == 0);
        // send \rAT\r
        // no need for pause--we just timed out!!
        // TwiddleThumbs1(40);

        FComFlush(pTG); // flush first--don't wnat some old garbage result
        FComDirectSyncWriteFast(pTG, "\rAT", 3);
        FComFlushInput(pTG); // flush input again
        FComDirectAsyncWrite(pTG, "\r", 1);
        startTimeOut(pTG, lpto0, ABORT_TIMEOUT);
        do
        {
            // don't abort inside ReadLine for this (abort dialog)
            if(pTG->fNCUAbort >= 2) 
                pTG->fNCUAbort = 1;

            swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
        }
        while(swNumRead==2 && bReply[0]=='\r'&& bReply[1]=='\n');
        // While we get a blank line. Get another.
        bReply[REPLYBUFSIZE-1] = 0;

        if(bReply[0] && my_fstrstr(bReply, cbszOK)==NULL)
            DebugPrintEx(   DEBUG_ERR,
                            "Anykey abort reply not OK. Got <<%s>>", 
                            (LPSTR)bReply);

        // Need Flush here, because \rAT\r will often get us
        // a cr-lf-OK-cr-lf-cr-lfOK-cr-lf response. If we send
        // just a \r, sometimes we may get nothing

        // FComFlushInput();
        FComFlush(pTG);

        if(pTG->fNCUAbort)
        {
            DebugPrintEx(DEBUG_ERR,"aborting");
            pTG->fNCUAbort = 0;
            break;  // drop out of loop to error
        }
    }

error:
    BG_CHK(uwRet == 0);
    DebugPrintEx(   DEBUG_WRN,
                    "(%s) --> (%d)(%s, etc) Failed", 
                    (LPSTR)(szSend?szSend:"null"), 
                    uwWantCount, 
                    (LPSTR)rgcbszWant[1]);

    iModemSetError(pTG, MODEMERR_HARDWARE, ERR_COMMAND_FAILED, MODEMERRFLAGS_TRANSIENT);
    pTG->FComStatus.fInDialog = 0;
    return 0;

end:
    BG_CHK(uwRet != 0);

    DebugPrintEx(DEBUG_MSG,"GOT IT %d (%s)", uwRet, (LPSTR)(rgcbszWant[uwRet]));
    pTG->FComStatus.fInDialog = 0;
    return uwRet;
}


#ifdef MON3
void InitMonitorLogging(PThrdGlbl pTG)
{
    DWORD_PTR dwKey;

    DEBUG_FUNCTION_NAME(("InitMonitorLogging"));
    pTG->Comm.fEnableHandoff=1;
    if (pTG->Comm.fEnableHandoff)
    {
        DebugPrintEx(DEBUG_WRN,"ADAPTIVE ANSWER ENABLED");
    }

    if ( 0 )  // RSL !fBeenHere
    {
        dwKey = ProfileOpen(DEF_BASEKEY, szGENERAL, fREG_READ);
        if (dwKey)
        {
            MONOPTIONS mo;
            BOOL fDoMonitor =(BOOL)(ProfileGetInt(dwKey, szMONITORCOMM, DEFMONVAL, NULL));
            _fmemset(&mo, 0, sizeof(mo));
            if (fDoMonitor)
            {
                UINT uPrefDataBufSizeKB=0;
                UINT uMaxExistingSizeKB=0;
                uPrefDataBufSizeKB=ProfileGetInt(dwKey, szMONITORBUFSIZEKB, (0x1<<6), NULL);
                uMaxExistingSizeKB=ProfileGetInt(dwKey, szMONITOREXISTINGFILESIZE, 64, NULL);
                mo.dwMRBufSize = ((DWORD)uPrefDataBufSizeKB)<<(10-2);
                mo.dwDataBufSize = ((DWORD)uPrefDataBufSizeKB)<<10;
                mo.dwMaxExistingSize = ((DWORD)uMaxExistingSizeKB)<<10;
                ProfileGetString(dwKey, szMONITORDIR, "c:\\",mo.rgchDir, sizeof(mo.rgchDir)-1);
            }
            ProfileClose(dwKey); 
            dwKey=0;

            if (fDoMonitor)
            {
                INT i = _fstrlen(mo.rgchDir);
                BG_CHK((i+1)<sizeof(mo.rgchDir));
                if (i && mo.rgchDir[i-1]!='\\')
                        {mo.rgchDir[i]='\\';mo.rgchDir[i+1]=0;}
                MonInit(pTG, &mo);
                DebugPrintEx(   DEBUG_MSG, 
                                "MONITOR OPTIONS: dwMR=%lu; dwDB=%lu; dwMES=%lu; "
                                " szDir=%s %s",
                                (unsigned long) mo.dwMRBufSize,
                                (unsigned long) mo.dwDataBufSize,
                                (unsigned long) mo.dwMaxExistingSize,
                                (LPSTR) mo.rgchDir,
                                (LPSTR) ((pTG->gMonInfo.fInited)? "ON" : "OFF"));
            }
        }
    }
}
#endif // MON3

// RSL was 60 000
#define AA_ANSWER_TIMEOUT       40000

USHORT iModemGetAdaptiveResp(PThrdGlbl pTG)
{
    USHORT                uRet=CONNECT_ERROR;
    BOOL                  fGotOK=FALSE;
    BOOL                  fGotData=FALSE;
    BOOL                  fGotFax=FALSE;
    LONG                  lRet;
    char                  Command[400];


    DEBUG_FUNCTION_NAME(("iModemGetAdaptiveResp"));

    pTG->Comm.fDataCall = FALSE;
    //
    // handle Adaptive Answer
    // should get FAX/DATA response
    //
    switch( iiModemDialog(  pTG, 
                            0, 
                            0, 
                            AA_ANSWER_TIMEOUT, 
                            uMULTILINE_SAVEENTIRE,
                            1, 
                            TRUE,
                            pTG->ModemResponseFaxDetect,
                            pTG->ModemResponseDataDetect,
                            cbszCONNECT,
                            cbszOK,
                            (CBPSTR)NULL)) 
    {

         case 1:
              fGotFax = 1;
              DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: got FAX response");
              break;

         case 2:
             fGotData = 1;
             DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: got DATA response");
             break;

         case 3:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get CONNECT before FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         case 4:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get OK before FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         default:
         case 0:   
            DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get default before FAX/DATA");
            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
    }

    // here we may have to change the serial speed and send some cmds (such as ATO-go online)

    if (fGotFax) 
    {
       if (pTG->SerialSpeedFaxDetect) 
       {
          FComSetBaudRate(pTG, pTG->SerialSpeedFaxDetect);
       }

       if (pTG->HostCommandFaxDetect)  
       {
          sprintf (Command, "%s",  pTG->HostCommandFaxDetect );

          FComFlushOutput(pTG);
          FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
       }

    }
    else if (fGotData) 
    {
       if (pTG->SerialSpeedDataDetect) 
       {
          FComSetBaudRate(pTG, pTG->SerialSpeedDataDetect);
       }

       if (pTG->HostCommandDataDetect)    
       {
          sprintf (Command, "%s",  pTG->HostCommandDataDetect );

          FComFlushOutput(pTG);
          FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
       }
    }
    else 
    {
       DebugPrintEx(DEBUG_ERR,"AnswerPhone: LOGICAL PGM ERROR");
       pTG->Comm.fDataCall = FALSE;
       uRet = CONNECT_ERROR;
       goto end;
    }


    // wait for connect now.

    switch( iiModemDialog(  pTG, 
                            0, 
                            0, 
                            AA_ANSWER_TIMEOUT, 
                            uMULTILINE_SAVEENTIRE,
                            1, 
                            TRUE,
                            (fGotFax) ? pTG->ModemResponseFaxConnect : pTG->ModemResponseDataConnect,
                            cbszCONNECT,
                            cbszOK,
                            (CBPSTR)NULL)) 
    {

         case 1:
              if (fGotFax) 
              {
                 uRet=CONNECT_OK;
                 goto end;
              }
              else 
              {
                 goto lDetectDataCall;
              }

         case 2:
            if (fGotFax) 
            {
               uRet=CONNECT_OK;
               goto end;
            }
            else 
            {
               goto lDetectDataCall;
            }

         case 3:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get OK after FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         default:
         case 0:
            DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get default after FAX/DATA");
            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
    }



lDetectDataCall:
    // Now we've got to fake out modem and fcom into thinking that
    // the phone is off hook when in fact it isn't.
    pTG->Comm.fDataCall = TRUE;
    uRet = CONNECT_WRONGMODE_DATAMODEM;
    //
    // New TAPI: Have to switch out of passtrough before handing off the call
    //

    DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: lineSetCallParams called");

    if (!itapi_async_setup(pTG)) 
    {
        DebugPrintEx(DEBUG_ERR,"AdaptiveAnswer: itapi_async_setup failed");

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }

    lRet = lineSetCallParams(pTG->CallHandle,
                             LINEBEARERMODE_VOICE,
                             0,
                             0xffffffff,
                             NULL);

    if (lRet < 0) 
    {
        DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer: lineSetCallParams failed");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }
    else 
    {
         DebugPrintEx(  DEBUG_MSG,
                        "AdaptiveAnswer: lineSetCallParams returns ID %ld", 
                        (long) lRet);
    }

    if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) 
    {
        DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer: itapi_async_wait failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }

    pTG->fFatalErrorWasSignaled = 1;
    SignalStatusChange(pTG, FS_NOT_FAX_CALL);

end:
    return uRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\identify.c ===
/***************************************************************************
        Name      :     IDENTIFY.C
        Comment   :     Identifying modems

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1


#include "prep.h"


#include "modemint.h"
//#include "fcomint.h"
#include "fdebug.h"

#include "awmodem.h"
#include "adaptive.h"


///RSL
#include "glbproto.h"

#define BIGTEMPSIZE             250

#define FILEID           FILEID_IDENTIFY

#include "inifile.h"

char szModemFaxClasses[] = "ModemFaxClasses";
char szModemSendSpeeds[] = "ModemSendSpeeds";
char szModemRecvSpeeds[] = "ModemRecvSpeeds";
char szModemId[]         = "ModemId";
char szModemIdCmd[]      = "ModemIdCmd";
char szClass0ModemId[]   = "Class0ModemId";
char szClass2ModemId[]   = "Class2ModemId";
char szClass20ModemId[]  = "Class2.0ModemId";

char szResetCommand[]    = "ResetCommand";
char szSetupCommand[]    = "SetupCommand";
char szExitCommand[]     = "ExitCommand";
char szPreDialCommand[]  = "PreDialCommand";
char szPreAnswerCommand[]= "PreAnswerCommand";

// RSL new UNIMODEM INF settings (FAX GENERIC)

char szHardwareFlowControl[]  = "HardwareFlowControl";
char szSerialSpeedInit[]      = "SerialSpeedInit";
char szSerialSpeedConnect[]   = "SerialSpeedConnect";
char szAdaptiveAnswerEnable[] = "AdaptiveAnswerEnable"; 

// new ADAPTIVE INF file (FAX ADAPTIVE)
char      szResponsesKeyName[]  =    "ResponsesKeyName=";
char      szResponsesKeyName2[]  =   "ResponsesKeyName";

char szAdaptiveRecordUnique[] =      "AdaptiveRecordUnique";
char szAdaptiveCodeId[] =            "AdaptiveCodeId";  
char szFaxClass[] =                  "FaxClass";
char szAnswerCommand[] =             "AnswerCommand";
char szModemResponseFaxDetect[] =    "ModemResponseFaxDetect";
char szModemResponseDataDetect[] =   "ModemResponseDataDetect";
char szSerialSpeedFaxDetect[] =      "SerialSpeedFaxDetect";
char szSerialSpeedDataDetect[] =     "SerialSpeedDataDetect";
char szHostCommandFaxDetect[] =      "HostCommandFaxDetect";
char szHostCommandDataDetect[] =     "HostCommandDataDetect";
char szModemResponseFaxConnect[] =   "ModemResponseFaxConnect";
char szModemResponseDataConnect[] =  "ModemResponseDataConnect";

// how was the Modem Key created
char szModemKeyCreationId[] =        "ModemKeyCreationId";


#define NUM_CL0IDCMDS           7
#define NUM_CL2IDCMDS           3
#define NUM_CL20IDCMDS          3

#define LEN_CL0IDCMDS           5
#define LEN_CL2IDCMDS           9
#define LEN_CL20IDCMDS          8


USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG);
BOOL iModemCopyOEMInfo(PThrdGlbl pTG);
void SmashCapsAccordingToSettings(PThrdGlbl pTG);


NPSTR szClass0IdCmds[NUM_CL0IDCMDS] =
{
        "ATI0\r",
        "ATI1\r",
        "ATI2\r",
        "ATI3\r",
        "ATI4\r",
        "ATI5\r",
        "ATI6\r"
};

NPSTR szClass2IdCmds[NUM_CL2IDCMDS] =
{
        "AT+FMFR?\r",
        "AT+FMDL?\r",
        "AT+FREV?\r"
};

NPSTR szClass20IdCmds[NUM_CL20IDCMDS] =
{
        "AT+FMI?\r",
        "AT+FMM?\r",
        "AT+FMR?\r"
};


typedef struct {
        USHORT  uGoClass,   //@ The fax class the modem need to be put on before using the id commands.
                uNum,       //@ The number of strings (commands) in the command table.
                uLen;       //@ The maximum length (required buffer size) in the command table.
                            //@ (including space for a terminating NULL char).
        NPSTR   *CmdTable;  //@ An array of strings each containing a modem id command.
        NPSTR   szIniEntry; //@ The name of the registry value in which the resulting
                            //@ is should be saved ("Class0ModemId", "Class2ModemId", "Class2.0ModemId")

} GETIDSTRUCT, near* NPGETIDSTRUCT;

GETIDSTRUCT GetIdTable[3] =
{
        { 0, NUM_CL0IDCMDS, LEN_CL0IDCMDS, szClass0IdCmds, szClass0ModemId },
        { 2, NUM_CL2IDCMDS, LEN_CL2IDCMDS, szClass2IdCmds, szClass2ModemId },
        { GOCLASS2_0, NUM_CL20IDCMDS, LEN_CL20IDCMDS, szClass20IdCmds, szClass20ModemId }
};

#define MAXCMDSIZE              128
#define MAXIDSIZE               128
#define RESPONSEBUFSIZE 256
#define SMALLTEMPSIZE   80
#define TMPSTRINGBUFSIZE (6*MAXCMDSIZE+MAXIDSIZE+RESPONSEBUFSIZE+2*SMALLTEMPSIZE+10)
                                // Enough space for all the lpszs below.




BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG);
void imodem_free_tmp_strings(PThrdGlbl pTG);
void imodem_clear_tmp_settings(PThrdGlbl pTG);

                    
BOOL 
imodem_list_get_str(
    PThrdGlbl pTG,
    ULONG_PTR KeyList[10],
    LPSTR lpszName,
    LPSTR lpszCmdBuf,
    UINT  cbMax,
    BOOL  fCmd);

BOOL imodem_get_str(PThrdGlbl pTG, ULONG_PTR dwKey, LPSTR lpszName, LPSTR lpszCmdBuf, UINT cbMax,
                                        BOOL fCmd);

BOOL SearchInfFile(PThrdGlbl pTG, LPSTR lpstrFile, LPSTR lpstr1, LPSTR lpstr2, LPSTR lpstr3, DWORD_PTR dwLocalKey);
void CheckAwmodemInf(PThrdGlbl pTG);
void ToCaps(LPBYTE lpb);

BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG);

BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG);

#ifndef USE_REGISTRY
BOOL iModemExpandKey(PThrdGlbl pTG, DWORD dwKey, LPSTR FAR *lplpszKey, LPSTR FAR *lplpszProfileName);
#endif






USHORT EndWithCR( LPSTR sz, USHORT uLen)
{
    if(uLen)
    {
        // Check if the string is terminated with a \r
        if(sz[uLen-1] != '\r')
        {
            // add a \r
            sz[uLen++] = '\r';
            sz[uLen] = 0;
        }
    }
    return uLen;
}



BOOL RemoveCR( LPSTR  sz )
{
   DWORD  len;

    if (!sz) 
    {
       return FALSE;
    }

    len = strlen(sz);
    if (len == 0) 
    {
       return FALSE;
    }

    if (sz[len-1] == '\r') 
    {
       sz[len-1] = 0;
    }

    return TRUE;
}


//@
//@ Sends an Id command to the modem and returns the resulting id string.
//@ 
USHORT GetIdResp(PThrdGlbl pTG, LPSTR szSend, USHORT uSendLen, LPBYTE lpbRespOut, USHORT cbMaxOut)
{
    USHORT uRespLen;

    DEBUG_FUNCTION_NAME(("GetIdResp"));

    DebugPrintEx(DEBUG_MSG,"Want Id for (%s)", (LPSTR)szSend);

    pTG->fMegaHertzHack = TRUE;
    //@
    //@ Send the id command to the modem and wait for a response followed by OK or ERROR.
    //@ On return pTG->bLastReply contains the last modem response before the OK or ERROR.
    //@
    OfflineDialog2(pTG, (LPSTR)szSend, uSendLen, cbszOK, cbszERROR);
    pTG->fMegaHertzHack=FALSE;

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(DEBUG_MSG, "LastLine = (%s)",(LPSTR)(&(pTG->FComModem.bLastReply)));
    uRespLen = min(cbMaxOut, _fstrlen(pTG->FComModem.bLastReply));

    _fmemcpy(lpbRespOut, pTG->FComModem.bLastReply, uRespLen);
    lpbRespOut[uRespLen] = 0; // zero terminate the string

    return uRespLen;
}




USHORT GetIdForClass
(
    PThrdGlbl pTG, 
    NPGETIDSTRUCT npgids, 
    LPBYTE lpbOut, 
    USHORT cbMaxOut,
    LPBYTE lpbLongestId, 
    USHORT cbMaxLongestId, 
    LPBYTE lpbLongestCmd
)
/*++

Routine Description:

    The functions returns a id string for the modem. 
    The string is class dependent (as indicated in npgids,uGoClass).
    The string will be in the format id1;id2;..idn where id<i> is the response of the 
    modem to command i in the input GETIDSTRUCT::CmdTable array.
    It optionally returns the longest id ( form the result of the first 3 commands) and 
    the command that generatedthis longest id.


Arguments:

    pTG [IN/OU]
        A pointer to the infamous ThrdGlbl.

    npgids [IN]
        Pointer to GETIDSTRUCT that specifies the commands to send to get the id

    lpbOut [OUT]
        A buffer where the generated id string will be placed.
        The string will be in the format id1;id2;..idn where id<i> is the response of the 
        modem to command i in the input GETIDSTRUCT::CmdTable array.

    cbMaxOut [IN]
        The maximum size of the above buffer

    lpbLongestId [OUT] OPTIONAL
        A buffer where longest id string will be placed.
        Can be NULL in which case it will not be used.

    cbMaxLongestId [IN] OPTIONAL
        The size of the longest id buffer
        
    lpbLongestCmd
        A pointer to the command string (in the provided npgids::CmdTable) that generated
        the longer id as described above.

Return Value:


--*/
{
        USHORT  i, j, k, uRet, uLen, uLenLong, iLong;
        LPBYTE  lpbLong;
        
        DEBUG_FUNCTION_NAME(TEXT("GetIdForClass"));

        BG_CHK(lpbOut && cbMaxOut>2);
        cbMaxOut -= 2; // make space for trailing ; and \0
        if(lpbLongestId)
                cbMaxLongestId -= 1; // make space for trailing \0
        uLen=0;

        if(npgids->uGoClass)
        {
                //@
                //@ Put the mode into the class required to use the id commands
                //@
                DebugPrintEx(DEBUG_MSG,
                             TEXT("Putting the modem into class %ld"),
                             npgids->uGoClass);

                if(!iiModemGoClass(pTG, npgids->uGoClass, 0))
                {
                        DebugPrintEx(   DEBUG_ERR,
                                        "GoClass %d failed",
                                        npgids->uGoClass);
                        goto done;
                }
        }

        for(lpbLong=NULL, uLenLong=0, i=0; i<npgids->uNum; i++)
        {
            //@ 
            //@ Sent the command at index I in the command table to the modem
            //@ and get the response in (*lpbOut+uLen). This effectively
            //@ concatenates all the responses (seperated with ";")
            //@
                uRet = GetIdResp(
                            pTG, 
                            npgids->CmdTable[i], 
                            npgids->uLen, 
                            lpbOut+uLen, 
                            (USHORT)(cbMaxOut-uLen)
                            );
                // find longest ID among ATI0 thru 3 only!
                if(i<=3 && uLenLong < cbMaxLongestId && uRet > uLenLong)
                {
                        //@
                        //@ Update the length of the longest id (but not above the
                        //@ max size the caller specified).
                        //@
                        uLenLong = min(uRet, cbMaxLongestId);
                        //@
                        //@ lpbLong points to the longets id
                        //@
                        lpbLong = lpbOut + uLen;
                        //@
                        //@ iLong id holds the index (0,1,2) of the longer id
                        //@
                        iLong = i;
                }
                uLen += uRet;
                //@
                //@ Seperate the ids by a ";"
                //@
                lpbOut[uLen++] = ';';
        }
        lpbOut[uLen] = 0;

        if(lpbLongestId && lpbLongestCmd && cbMaxLongestId && lpbLong && uLenLong)
        {
                //@ 
                //@ Copy the longest id (0,1 or 2) to the caller's buffer
                //@
                _fmemcpy(lpbLongestId, lpbLong, uLenLong);
                lpbLongestId[uLenLong] = 0;
                //@
                //@ Copy the command that generated the longest id to the caller's buffer
                //@
                _fmemcpy(lpbLongestCmd, npgids->CmdTable[iLong], npgids->uLen);
                lpbLongestCmd[npgids->uLen] = 0;
                DebugPrintEx(   DEBUG_MSG,
                                "LongestId (%s)-->(%s)", 
                                (LPSTR)lpbLongestCmd, 
                                (LPSTR)lpbLongestId);
        }
        // strip non-prinatbles. *AFTER* extracting the ModemId string!!
        for(j=0, k=0; j<uLen; j++)
        {
            if(lpbOut[j] >= 32 && lpbOut[j] <= 127)
                    lpbOut[k++] = lpbOut[j];
        }
        uLen = k;
        lpbOut[uLen] = 0;
        DebugPrintEx(   DEBUG_MSG,
                        "Class%dId (%s)", 
                        npgids->uGoClass, 
                        (LPSTR)lpbOut);

done:
        if(npgids->uGoClass)
        {
            //@
            //@ Go back to class 0 if we changes classes
            //@
                iiModemGoClass(pTG, 0, 0);
        }
        return uLen;
}


void iModemGetWriteIds(PThrdGlbl pTG, BOOL fGotOEMInfo)
{
        // As with iModemFigureOutCmds and iModemGetCaps, we selectively
        // detect ID's taking into account OEM info that's already read in...
        USHORT     uLen1, uLen2, uLen3;
        DWORD_PTR  dwKey=0;
        LPSTR      lpstr1 = 0, lpstr2 = 0, lpstr3 = 0;
        USHORT     uClasses = pTG->TmpSettings.lpMdmCaps->uClasses;

        DEBUG_FUNCTION_NAME(("iModemGetWriteIds"));

        uLen1 = uLen2 = uLen3 = 0;

        //@ Open the device key 
        if (!(dwKey=ProfileOpen(    pTG->FComModem.dwProfileID, 
                                    pTG->FComModem.rgchKey,
                                    fREG_CREATE | fREG_READ | fREG_WRITE)))

        {
                DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
                BG_CHK(FALSE);
                goto end;
        }
        
        if (pTG->TmpSettings.dwGot & fGOTPARM_IDCMD)
        {
            //@
            //@ We already have the id command (we read it from the registry during iModemGetCurrentModemInfo)
            //@

                int i=0;

                if (!pTG->TmpSettings.szIDCmd[0])
                {
                    //@
                    //@ We have a null ID command so we can't really do anything 
                    //@ just save and exit.
                        BG_CHK(!pTG->TmpSettings.szID[0]);
                        goto SaveIDandCMD;
                }
                //@
                //@ We have a non empty id command and can try to use it to detect the id.
                //@
                while(i++<2)
                {
                        pTG->TmpSettings.szID[0]=0;
                        pTG->TmpSettings.szResponseBuf[0]=0;
                        //@ Send the id command to the modem. The id string is returned
                        //@ in pTG->TmpSettigns.szID
                        GetIdResp(  pTG, 
                                    pTG->TmpSettings.szIDCmd,
                                    (USHORT) _fstrlen(pTG->TmpSettings.szIDCmd),
                                    pTG->TmpSettings.szID, 
                                    MAXIDSIZE);
                        //@
                        //@ Send the id command again this time putting the result
                        //@ in pTG->TmpSettings.szResponseBuf.
                        //@
                        GetIdResp(  pTG,
                                    pTG->TmpSettings.szIDCmd,
                                    (USHORT)_fstrlen(pTG->TmpSettings.szIDCmd),
                                    pTG->TmpSettings.szResponseBuf, 
                                    MAXIDSIZE);
                        //@
                        //@ Compate the two results. If they are the same then break.
                        //@ Otherwise try again.
                        //@ (Why do we need to do this comparision ????)
                        //@
                        if (!_fstrcmp(pTG->TmpSettings.szID, pTG->TmpSettings.szResponseBuf)) 
                        {
                            break;
                        }
                }
                if (i>=3 || !pTG->TmpSettings.szID[0])
                {
                    //@
                    //@ We failed to the the id response.
                    //@

                    DebugPrintEx(   DEBUG_ERR,
                                    "Can't get matching ID for supplied IDCMD: %s",
                                    (LPSTR) pTG->TmpSettings.szIDCmd);
                    //@
                    //@ Nullify the command id and id held in TmpSettings.
                    //@
                        pTG->TmpSettings.szIDCmd[0]=pTG->TmpSettings.szID[0]=0;
                }
                else
                {
                    //@
                    //@ The id command worked and we have a matching id.
                    //@
                        DebugPrintEx(   DEBUG_MSG,
                                        "OEM IDCmd=%s --> %s",
                                        (LPSTR) pTG->TmpSettings.szIDCmd,
                                        (LPSTR) pTG->TmpSettings.szID);
                }
                //@
                //@ In any case we indicate that we have an id command and matchind id.
                //@ (Why do we do that in the case we did not find a matching id ?)
                //@ And save the results to the registry.
                pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD | fGOTPARM_ID);
                goto SaveIDandCMD;

        }

        //@
        //@ This is the case where we do not have a command id that we previously found.
        //@

        // write ModemId first, then ModemIdCmd

        // the lpszOemIDCmd and lpszOemID above).
        pTG->TmpSettings.szID[0]=0;
        lpstr1 = pTG->TmpSettings.szResponseBuf;

        //@
        //@ Get the class 0 full id string into lpstr1.
        //@ Get the longest id (1st three commands) into pTG->TmpSettings.szID
        //@ Get the command that generated the longest id into pTG->TmpSettings.szIDCmd
        //@
        uLen1 = GetIdForClass(pTG, &GetIdTable[0], lpstr1,
                        RESPONSEBUFSIZE, pTG->TmpSettings.szID, MAXIDSIZE,
                        pTG->TmpSettings.szIDCmd);
        lpstr1[uLen1] = 0;
        if (pTG->TmpSettings.szID[0])
        {   
            pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD|fGOTPARM_ID);
        }
        
        //@
        //@ Write the full id string for class 0 into the registry (Class0ModemId)
        //@
        ProfileWriteString(dwKey, GetIdTable[0].szIniEntry, lpstr1, FALSE);

       

        if(uClasses & FAXCLASS2) //@ if the modem supports class 2
        {
                //@
                //@ Get the class 2 full id string into lpstr2.
                //@ Dont ask for longest id (not relevant for class 2).
                //@ Note that lptstr2 is placed just after lpstr1 in pTG->TmpSettings.szResponseBuf
                //@
                BG_CHK(pTG->TmpSettings.szResponseBuf[uLen1] == 0);
                lpstr2 = pTG->TmpSettings.szResponseBuf + uLen1 + 1;
                BG_CHK(uLen1 + 1 < RESPONSEBUFSIZE);
                uLen2 = GetIdForClass(pTG, &GetIdTable[1], lpstr2,
                                        (USHORT)(RESPONSEBUFSIZE-uLen1-1), 0, 0, 0);
                lpstr2[uLen2] = 0;
                ProfileWriteString(dwKey, GetIdTable[1].szIniEntry, lpstr2, FALSE);
        }
        if(uClasses & FAXCLASS2_0) //@ if the modem supports class 2.0
        {
                BG_CHK(pTG->TmpSettings.szResponseBuf[uLen1] == 0);
                BG_CHK(uLen2==0 || pTG->TmpSettings.szResponseBuf[uLen1+uLen2+1] == 0);
                BG_CHK(uLen1 + uLen2 + 2 < RESPONSEBUFSIZE);
                lpstr3 = pTG->TmpSettings.szResponseBuf + uLen1 + uLen2 + 2;
                //@
                //@ Get the class 2.0 full id string into lpstr3.
                //@ Dont ask for longest id (not relevant for class 2).
                //@ Note that lptstr3 is placed just after lpstr2 in pTG->TmpSettings.szResponseBuf
                //@
                uLen3 = GetIdForClass(pTG, &GetIdTable[2], lpstr3, (USHORT)((RESPONSEBUFSIZE)-uLen1-uLen2-2), 0, 0, 0);
                lpstr3[uLen3] = 0;
                ProfileWriteString(dwKey, GetIdTable[2].szIniEntry, lpstr3, FALSE);
        }

        //@
        //@ Note: At this point we changed the value of pTG->TmpSettings.szId and szIdCmd.
        //@ and placed there the class 0 id and command respectively.
        //@
        ToCaps(lpstr1);
        ToCaps(lpstr2);
        ToCaps(lpstr3);

        DebugPrintEx(   DEBUG_MSG,
                        "Got Ids (%s)\r\n(%s)\r\n(%s)",
                        ((LPSTR)(lpstr1 ? lpstr1 : "null")),
                        ((LPSTR)(lpstr2 ? lpstr2 : "null")),
                        ((LPSTR)(lpstr3 ? lpstr3 : "null")));

        // If we've read any commands or caps from the OEM location we
        // skip this...

        //@
        //@ This means that if we read the information from Unimodem key
        //@ or find it in the adaptive answering file we will never search
        //@ AWMODEM.INF or AWOEM.INF
        //@
        if (fGotOEMInfo || ( pTG->ModemKeyCreationId != MODEMKEY_FROM_NOTHING) )
        {
            DebugPrintEx(DEBUG_WRN,"Got OEM info: Skipping AWMODEM.INF file search!");
        }
        else
        {
            if (!SearchInfFile(pTG, "AWOEM.INF", lpstr1, lpstr2, lpstr3, dwKey))
            {
                 SearchInfFile(pTG, "AWMODEM.INF", lpstr1, lpstr2, lpstr3, dwKey);
            }
        }

SaveIDandCMD:

        BG_CHK(pTG->TmpSettings.dwGot & fGOTPARM_IDCMD);
        ProfileWriteString(dwKey, szModemId, pTG->TmpSettings.szID, FALSE);
        ProfileWriteString(dwKey, szModemIdCmd, pTG->TmpSettings.szIDCmd, TRUE);

end:
        if (dwKey) ProfileClose(dwKey);
        return;
}

// state: 0=ineol  1=insectionhdr  2=in midline  3=got] 4=got\r\n
// inputs: \r\n==0 space/tab=1 2=[ 3=] 4=pritables 5=others
USHORT uNext[5][6] =
{
  // crlf sp [  ] asc oth
        { 0, 0, 1, 2, 2, 2 },   //in eol
        { 0, 1, 2, 3, 1, 2 },   //in sectionhdr
        { 0, 2, 2, 2, 2, 2 },   //in ordinary line
        { 4, 3, 2, 2, 2, 2 },   //found ]
        { 4, 4, 4, 4, 4, 4 }    //found closing \r\n
};

#define START           0
#define INHEADER1       1
#define INHEADER2       3
#define FOUND           4



void ToCaps(LPBYTE lpb)
{
        // capitalize string
        USHORT i;

        for(i=0; lpb && lpb[i]; i++)
        {
                if(lpb[i] >= 'a' && lpb[i] <= 'z')
                        lpb[i] -= 32;
        }
}



BOOL SearchInfFile
(
    PThrdGlbl pTG, 
    LPSTR lpstrFile, 
    LPSTR lpstr1, 
    LPSTR lpstr2, 
    LPSTR lpstr3, 
    DWORD_PTR dwLocalKey
)
{
#if defined(DOSIO) || defined(KFIL)
        char    bTemp[BIGTEMPSIZE];
        char    szHeader[SMALLTEMPSIZE+SMALLTEMPSIZE];
        char    bTemp2[SMALLTEMPSIZE+SMALLTEMPSIZE];
        UINT    uLen, state=0, input=0, uHdrLen;
        HFILE   hfile;
        LPBYTE  lpb, lpbCurr;

        DEBUG_FUNCTION_NAME(("SearchInfFile"));

        uLen = GetWindowsDirectory(bTemp, BIGTEMPSIZE-15);
        if(!uLen)
        {
            BG_CHK(FALSE);
            return FALSE;
        }
        // if last char is not a \ then append a '\'
        if(bTemp[uLen-1] != '\\')
        {
            bTemp[uLen++] = '\\';
            bTemp[uLen] = 0;                // add new 0 terminator
        }
        _fstrcpy(bTemp+uLen, lpstrFile);
        if((hfile = DosOpen(bTemp, 0)) == HFILE_ERROR)
        {
            DebugPrintEx(DEBUG_WRN,"%s: No such file", (LPSTR)bTemp);
            return FALSE;
        }

        uLen = 0;
        lpbCurr = bTemp;

nextround:
        DebugPrintEx(DEBUG_MSG,"Nextround");
        state = START;
        uHdrLen = 0;
        for(;;)
        {
                if(!uLen)
                {
                        uLen = DosRead( hfile, bTemp, sizeof(bTemp));
                        if(!uLen || uLen == ((UINT) -1))
                                goto done;
                        lpbCurr = bTemp;
                }

                BG_CHK(state != FOUND);
                switch(*lpbCurr)
                {
                case '\r':
                case '\n':      input = 0; break;
                case ' ':
                case '\t':      input = 1; break;
                case '[':       input = 2; break;
                case ']':       input = 3; break;
                default:        if(*lpbCurr >= 32 && *lpbCurr < 128)
                                {
                                    input = 4;
                                }
                                else
                                {
                                    input = 5;
                                }
                                break;
                }
                state = uNext[state][input];

                if(state == FOUND)
                {
                    if(uHdrLen > 2)
                    {
                        break;
                    }
                    else
                    {
                        goto nextround;
                    }
                }

                if(state == INHEADER1)
                {
                        if(*lpbCurr != '[' && uHdrLen < sizeof(szHeader)-1)
                                szHeader[uHdrLen++] = *lpbCurr;
                }
                else if(state != INHEADER2)
                        uHdrLen=0;

                lpbCurr++;
                uLen--;

                // szHeader[uHdrLen] = 0;
        }
        DebugPrintEx(DEBUG_MSG,"Found[%s]", (LPSTR)szHeader);
        BG_CHK(uHdrLen > 2);
        // uHdrLen--; // get rid of trailing ]
        szHeader[uHdrLen] = 0;

        // capitalize search string
        ToCaps(szHeader);

        DebugPrintEx(DEBUG_MSG,"Found[%s]", (LPSTR)szHeader);

        if(     (lpstr1 ? my_fstrstr(lpstr1, szHeader) : FALSE) ||
                (lpstr2 ? my_fstrstr(lpstr2, szHeader) : FALSE) ||
                (lpstr3 ? my_fstrstr(lpstr3, szHeader) : FALSE) )
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Copying INI file section [%s] from %s to %s",
                            (LPSTR)szHeader, 
                            (LPSTR)lpstrFile, 
                            (LPSTR)szIniFile);

            DosClose( hfile);
            // read the whole section as profile string
            if(GetPrivateProfileString(szHeader, NULL, "", bTemp, sizeof(bTemp), lpstrFile) == 0)
            {
                DebugPrintEx(DEBUG_ERR,"Can't read INF file section");
                return FALSE;
            }
            // copy it to our IniFile
            for(lpb=bTemp; *lpb; lpb += _fstrlen(lpb)+1)
            {
                // lpb is a key in the [szHeader] section of the INF file
                if(GetPrivateProfileString(szHeader, lpb, "", bTemp2, sizeof(bTemp2), lpstrFile) == 0)
                {
                    DebugPrintEx(DEBUG_ERR,"Can't read INF file entry");
                }
                else
                {
                    // copy it to our IniFile
                    ProfileWriteString(dwLocalKey, lpb, bTemp2, FALSE);
                    DebugPrintEx(   DEBUG_MSG, 
                                    "Wrote %s=%s", 
                                    (LPSTR)lpb, 
                                    (LPSTR)bTemp2);
                }
            }
            // found what we wanted. Outta here
                return TRUE;
        }

        // couldnt match, try again
        DebugPrintEx(DEBUG_MSG,"No match");
        goto nextround;

done:
        DebugPrintEx(DEBUG_MSG,"End of INF file %s",(LPSTR)lpstrFile);
        // end of inf file--close it
        DosClose(hfile);
#endif  // DOSIO || KFIL
        return FALSE;
}

void CheckAwmodemInf(PThrdGlbl pTG)
{
#if defined(DOSIO) || defined(KFIL)
    USHORT uLen;
    char bTemp[BIGTEMPSIZE];
    HFILE hfile;

    DEBUG_FUNCTION_NAME(_T("CheckAwmodemInf"));

    uLen = (USHORT)GetWindowsDirectory(bTemp, sizeof(bTemp)-15);
    if(!uLen)
    {
        BG_CHK(FALSE);
        return;
    }
    // if last char is not a \ then append a '\'
    if(bTemp[uLen-1] != '\\')
    {
        bTemp[uLen++] = '\\';
        bTemp[uLen] = 0;                // add new 0 terminator
    }
    _fstrcpy(bTemp+uLen, "AWMODEM.INF");
    if((hfile = DosCreate(bTemp, 0)) == HFILE_ERROR)
    {
        DebugPrintEx(DEBUG_ERR,"Could not create %s",(LPSTR)bTemp);
    }
    else
    {
        DosWrite( hfile, (LPSTR)szAwmodemInf, sizeof(szAwmodemInf)-1);
        DosClose( hfile);
        DebugPrintEx(DEBUG_WRN,"Created %s",(LPSTR)bTemp);
    }
    return;
#endif  //DOSIO || KFIL
}

#define ADDSTRING(STRING) \
        BG_CHK(pTG->TmpSettings.STRING); \
        u = _fstrlen(pTG->TmpSettings.STRING)+1; \
        _fmemcpy(pb, pTG->TmpSettings.STRING,u); \
        lpCmdTab->STRING=pb;\
        pb+=u; \
        BG_CHK(pb<=(pTG->bModemCmds+sizeof(pTG->bModemCmds)));

USHORT iModemGetCmdTab
(
    PThrdGlbl pTG, 
    DWORD dwLineID, 
    DWORD dwLineIDType,
    LPCMDTAB lpCmdTab, 
    LPMODEMCAPS lpMdmCaps, 
    LPMODEMEXTCAPS lpMdmExtCaps,
    BOOL fInstall
)
{
    USHORT uLen1, uLen2, uRet = INIT_INTERNAL_ERROR;
    USHORT uPassCount = 0;
    USHORT uInstall=0;
    BOOL    fDontPurge=FALSE; //If true, we won't delete section in install.
    int i;

    DEBUG_FUNCTION_NAME(("iModemGetCmdTab"));
#ifndef METAPORT
    BG_CHK(dwLineIDType == LINEID_COMM_PORTNUM);
#else
    BG_CHK(  dwLineIDType == LINEID_COMM_PORTNUM
              || dwLineIDType == LINEID_COMM_HANDLE);
#endif

    if (!imodem_alloc_tmp_strings(pTG)) 
        goto done;

    pTG->TmpSettings.lpMdmCaps = lpMdmCaps;
    pTG->TmpSettings.lpMdmExtCaps = lpMdmExtCaps;

    if(fInstall==fMDMINIT_INSTALL) 
        goto DoInstall;

ReadConfig:

    // check for ModemIdCmd, ModemId, ModemFaxClasses,
    //       ResetCommand, SetupCommand, PreDialCommand, PreAnswerCommand,
    //       ExitCommand, FaxSerialSpeed vars
    //       and (if Class1) ModemSendCaps, ModemRecvCaps
    // if all present [some exceptions--see below], then verify that
    //       ModemId is still correct (send ModemIdCmd, get ModemId)
    // if correct then copy all INI values into lpMdmCaps and lpCmdTab
    // else do full install

// get ModemCaps from current settings

    imodem_clear_tmp_settings(pTG);

    if (!iModemGetCurrentModemInfo(pTG))
    {
        goto DoInstall;
    }

    SmashCapsAccordingToSettings(pTG);

    if (! pTG->fCommInitialized) 
    {
       if( ! T30ComInit(pTG, pTG->hComm) ) 
       {
          DebugPrintEx(DEBUG_MSG,"T30ComInit failed");
           goto done;
       }

       FComDTR(pTG, TRUE); // Raise DTR in ModemInit
       FComFlush(pTG);

       pTG->fCommInitialized = 1;
    }


    // do modem reset, or ID check won't work (because of echo)
    BG_CHK(pTG->TmpSettings.dwGot&fGOTCMD_Reset);
    if (!pTG->TmpSettings.szReset[0])
    {
        DebugPrintEx(DEBUG_WRN,"NULL reset command specified!");
    }
    else
    {
        if(iModemReset(pTG, pTG->TmpSettings.szReset) < 0)
        {
            fDontPurge=TRUE; // we specifically don't purge in this case.
            goto DoInstall;
        }
    }
// check ID

    // a way around this Id check. If IdCmd has been manually deleted, skip chk
    BG_CHK(pTG->TmpSettings.szIDCmd && pTG->TmpSettings.szID);
    uLen1 = (USHORT)_fstrlen(pTG->TmpSettings.szIDCmd);
    if (fInstall==fMDMINIT_ANSWER || !uLen1) 
    {
        uRet = 0; 
        goto done;
    }
    uLen2 = (USHORT)_fstrlen(pTG->TmpSettings.szID);
    BG_CHK(uLen2);

    for(i=0; i<3; i++)
    {
        GetIdResp(  pTG, 
                    pTG->TmpSettings.szIDCmd, 
                    uLen1, 
                    pTG->TmpSettings.szResponseBuf,
                    RESPONSEBUFSIZE);
        if(my_fstrstr(pTG->TmpSettings.szResponseBuf, pTG->TmpSettings.szID))
        {
            DebugPrintEx(   DEBUG_WRN,  
                            "Modem IDs (%s): (%s\r\n)-->(%s) confirmed",
                            (LPSTR)pTG->TmpSettings.szID, 
                            (LPSTR)pTG->TmpSettings.szIDCmd,
                            (LPSTR)pTG->TmpSettings.szResponseBuf);
            uRet = 0;
            goto done;
        }
    }

    // Failed ID check
    // Fall thru to DoInstall;

DoInstall:
    if(uPassCount > 0)
    {
        DebugPrintEx(DEBUG_ERR,"Install looping!!");
        BG_CHK(FALSE);
        uRet =  INIT_INTERNAL_ERROR;
        goto done;
    }
    uPassCount++;

    // +++ currently we always do a "clean" install -- dwGot=0
    // EXCEPT that we use fDontPurge do determine whether we
    // delete the profile section or not.
    fDontPurge=fDontPurge|| (pTG->TmpSettings.uDontPurge!=0);
    imodem_clear_tmp_settings(pTG);
    BG_CHK(!pTG->TmpSettings.dwGot);

    if(uRet = iModemInstall(pTG, dwLineID, dwLineIDType, fDontPurge))
    {
        goto done;      // failed
    }
    else
    {
        goto ReadConfig;        // success
    }

    // on success we want to go back and start over because (a) we want to check
    // that everything is indeed OK and (b) UI etc may have modfied some of the
    // settings so we need to go back and read them in again.

done:
    if (!uRet)
    {
        char *pb = pTG->bModemCmds;
        UINT u;

        // Initialize all command strings in lpCmdTab to static buffer,
        // copying from the corresponding strings in the TmpSettings structure.
        // the latter strings point into
        // the temporarily allocated buffer allocated in
        // imodem_alloc_tmp_strings and will be freed on exit.

        _fmemset(lpCmdTab, 0, sizeof(CMDTAB));


        ADDSTRING(szReset);
        ADDSTRING(szSetup);
        ADDSTRING(szExit);
        ADDSTRING(szPreDial);
        ADDSTRING(szPreAnswer);
    }

    lpCmdTab->dwSerialSpeed = pTG->SerialSpeedInit;
    lpCmdTab->dwFlags = pTG->TmpSettings.dwFlags;
    imodem_free_tmp_strings(pTG);
    return uRet;
}

USHORT iModemInstall
(
    PThrdGlbl pTG,
    DWORD dwLineID, 
    DWORD dwLineIDType, 
    BOOL fDontPurge
)
{
    USHORT   uRet = 0;
    BOOL     fGotOEMInfo = FALSE;
    DWORD_PTR hkFr;
    DWORD    localModemKeyCreationId;

    DEBUG_FUNCTION_NAME(("iModemInstall"));

    CheckAwmodemInf(pTG);              // check that AWMODEM.INf exist, otherwise create it

    if (!pTG->TmpSettings.dwGot) 
    {
        /////// clear settings in input //////

        // Clear out persistant (registry) info...
        if (!fDontPurge && !ProfileDeleteSection(DEF_BASEKEY,pTG->FComModem.rgchKey))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "ClearCurrentModemInfo:Can't delete section %s",
                            (LPSTR) pTG->FComModem.rgchKey);
        }

        // Since  the above deletes the entire section, we have to write
        // back things that are important to us, which currently
        // is the OEM key...
        {
            DWORD_PTR dwKey;

            //@
            //@ Open a key to Fax\Devices\<Modem Id>\Modem.
            //@ Write the valud of pTG->FComModem.rgchOEMKey to the value OEMKey under it.
            //@ This value is not refered to anywhere else we can remove it !!! 
            //@

            if (!(dwKey = ProfileOpen(  pTG->FComModem.dwProfileID,
                                        pTG->FComModem.rgchKey, 
                                        fREG_CREATE |fREG_READ|fREG_WRITE))
                || !ProfileWriteString( dwKey, 
                                        szOEMKEY,
                                        pTG->FComModem.rgchOEMKey, 
                                        FALSE))
            {
                DebugPrintEx(   DEBUG_WRN,
                                "Couldn't write OEM Key after clearing section");
            }
            // may be save other things here, like modem params???

            if (dwKey)
            {
                ProfileClose(dwKey);
                dwKey=0;
            }
        }

        //@
        //@ First lets see if the modem has a Unimodem FAX key.
        //@ If it does then we will use the Unimodem FAX key settings
        //@ and will not attempt to search ADAPTIVE.INF AWMODEM.INF or AWOEM.INF
        //@ Note: This is different from thw W2K implementation. W2K provider
        //@       looked first in ADAPTIVE.INF and if it found a match it DID NOT
        //@       look for a Unimodem FAX key.
        //@

        pTG->ModemKeyCreationId = MODEMKEY_FROM_NOTHING;
        pTG->fUnimodemFaxDefined = 0;


        hkFr = ProfileOpen( OEM_BASEKEY, pTG->lpszUnimodemFaxKey, fREG_READ);
        if ( hkFr  ) 
        {
              pTG->fUnimodemFaxDefined = 1;
              pTG->ModemKeyCreationId = MODEMKEY_FROM_UNIMODEM;
              ProfileClose( hkFr);
              //@
              //@ This copies all the information from the unimodem FAX key to 
              //@ our registry.
              //@
              iModemCopyOEMInfo(pTG);
        }
        else
        {
            //@
            //@ Check to see if this modem is defined in Adaptive.Inf
            //@ Since the last parameret is FALSE we will not read in the record content
            //@ if it contains an "AdaptiveCodeId" field (which indiciates we need to 
            //@ make sure what is the modem revision first). If it does not contain
            //@ this field we will read the content into the pTG.
            //@
            SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, FALSE);

            if (pTG->fAdaptiveRecordFound) 
            {
               if (! pTG->fAdaptiveRecordUnique) 
               {
                  //@
                  //@ The section indicates that a modem id identification is required.
                  //@ The next oddly named function will set pTG->fAdaptiveRecordUnique to 1
                  //@ if it identified the modem revision as a one for which 
                  //@ adaptive answering is working.
                  //@
                  TalkToModem (pTG, FALSE); //@ void function
                  if (pTG->fAdaptiveRecordUnique) 
                  {
                    //@
                    //@ Now we are we are sure the the adaptive record matches the modem.
                    //@ We search the INF again but this time allways read the record 
                    //@ content into the pTG (last parameter is TRUE).
                    //@
                     SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, TRUE);
                  }
                  else 
                  {
                      //@
                      //@ The modem does not match the revision for which adaptive
                      //@ answering is enabled.
                      //@
                     pTG->fAdaptiveRecordFound = 0;
                     pTG->ModemClass = 0;
                  }
               }
            }

            if (pTG->fAdaptiveRecordFound) 
            {
                //@
                //@ If we succeeded to find an adaptive record then we need
                //@ to save the information we read from it into the pTG to the
                //@ registry.
                //@
               pTG->ModemKeyCreationId = MODEMKEY_FROM_ADAPTIVE; //@ so we will know the information source
               SaveInf2Registry(pTG);
            }

        }

       
        localModemKeyCreationId = pTG->ModemKeyCreationId;
        pTG->AdaptiveAnswerEnable = 0; //@ we are going to read it back from the registry in a second
        
        //
        // At this point we have all the info from Adaptive.inf or Unimodem Reg.
        // into Modem Reg.
        // We have nothing in memory.
        //

        if (! pTG->ModemClass) 
        {
           ReadModemClassFromRegistry(pTG);
        }

        if (! pTG->ModemClass) 
        {
           TalkToModem(pTG, TRUE);
           SaveModemClass2Registry(pTG);
        }


        //@
        //@ Read the modem data back from the registry. (We have just written it
        //@ to the registry in the preceeding functions and we want it back into
        //@ memory).
        //@ Note that this sets pTG->TmpSettings.dwGot with the fGOTCAPS_X, fGOTPARM_X, etc. flags
        //@ Also note that this will turn off or on the adaptive answering flag
        //@ (pTG->AdaptiveAnswerEnable) based on the extension configuration of the T30 FSP.
        //@
        iModemGetCurrentModemInfo(pTG);
        pTG->ModemKeyCreationId = localModemKeyCreationId;

    }

    //
    // We are ready now to initialize the hardware.
    // Can be second init (first one is in TalkToModem
    //

    if(! T30ComInit(pTG, pTG->hComm) )
    {
        DebugPrintEx(DEBUG_ERR,"Cannot Init COM port");
        // error already set to ERR_COMM_FAILED
        uRet = INIT_PORTBUSY;
        goto done;
    }

    FComDTR(pTG, TRUE); // Raise DTR in ModemInit
    FComFlush(pTG);

    pTG->fCommInitialized = 1;

    // we use this to decide if we must read our OEM inf files or not....
    //@ Make sure we have all what we need to operate. If we miss any of these
    //@ we will attempt to find it in AWMODEM.INF and AWOEM.INF.
    //@ 
    //@ CMDS: 
    //@     fGOTCMD_Reset \
    //@     fGOTCMD_Setup \
    //@     fGOTCMD_PreAnswer \
    //@     fGOTCMD_PreDial \
    //@     fGOTCMD_PreExit
    //@ CAPS:
    //@     fGOTCAP_CLASSES 
    //@     fGOTCAP_SENDSPEEDS 
    //@     fGOTCAP_RECVSPEEDS
    //@ PARAMS:
    //@     fGOTPARM_PORTSPEED
    //@     fGOTPARM_IDCMD
    //@     fGOTPARM_ID
    //@
    fGotOEMInfo = (pTG->TmpSettings.dwGot & (fGOTCMDS|fGOTCAPS|fGOTPARMS));

    // At this point, we have possibly an incompletely and/or
    // incorrectly filled out set of commands and capabilities.

    // must be first, or modem is in a totally unknown state
    //@
    //@ If the setup and reset command were not read or are not good
    //@ iModemFigureOutCmdsExt attempts to find them and place them in
    //@ pTG->TmpSettings.szReset and pTG->TmpSettings.szSetup
    //@
    if(uRet = iModemFigureOutCmdsExt(pTG))
        goto done;

    // iModemFigureOut leaves modem is a good (synced up) state
    // this needs to be _after_ lpCmdTab is filled out
    if(!iModemGetCaps(  pTG, 
                        pTG->TmpSettings.lpMdmCaps,
                        pTG->TmpSettings.dwSerialSpeed,
                        pTG->TmpSettings.szReset,
                        &pTG->TmpSettings.dwGot))
    {
        uRet = INIT_GETCAPS_FAIL;
        goto done;
    }

    // we always save settings here because iModemGetWriteIds below
    // will need to possibly override our settings so far...
    iModemSaveCurrentModemInfo(pTG);

    // must be last since it also does the AWMODEM.INF search
    //@
    //@ Note that iModemGetWriteIds will not do the INF search (and copy)
    //@ if fGotOEMInfo is TRUE or if pTG->ModemKeyCreationId != MODEMKEY_FROM_NOTHING.
    //@ This means that if we read the information from Unimodem the AWMODEM.INF and
    //@ AWOEM.INF will be ignored. This is what we want !
    //@
    iModemGetWriteIds(pTG, fGotOEMInfo);

    CleanModemInfStrings(pTG);
    imodem_clear_tmp_settings(pTG);

    // Now we've done all we can. We've got all the settings, written them to
    // the INI file. Call back the UI function here. This will read the
    // current settings from INI file, may modify them and returns OK, Cancel
    // and Detect. On OK & Cancel, just exit. On Detect loop back to start
    // of this function, but this time _skip_ UNIMODEM & do detection ourself

    uRet = 0;

done:

    return uRet;
}


/***-------------------- FLOW CONTROL ----------------------**********

        Each modem seems to have it's own stupid way of setting
        flow control. Here's a survey

Manuf           which modem?            Flow    Sideeffects
-----           ------------            ----    -----------
Rockwell        RC2324AC                        &K4             &H unused.  \Q unused.
US Robotics Sportster14400              &H2             &K0-3 used, &K4 unused. \cmds unused
                        Courier(HST,V32bis)
PracPeriph      PP14400FXMT/SA          &K4             &H unsued. \cmds unused.
                    PP2400EFXSA
Zoom            9600 V.32 VFX           &K4             &H unused. \Q unused
UDSMotorola Fastalk                             \Q1             &H unused &K unused
HayesOptima Optima24/144                &K4             &H unused \cmds unused
MegaHertz       P2144                    \Q1 \Q4        &H unused &K unused
TwinCom         144/DF                          &K4             &H unused \Q unused
PCLogic         ???                                     ???             ????
????            ???                                     \Q1             &H unused &K unused
ATI                     2400 etc                        &K4             &H unused \cmds unused
MultiTech       MultiModemMT1432MU      &E5             &H unused &K unused \Q unused
                        MultiModemII MT932
                        MultiModemII MT224
Viva            14.4i/Fax and 9624i &K4         &H unused \Q unused &E unused
GVC                     "9600bps Fax Modem" \Q1         &H unused &K unused &E unused
SmartOne        1442F/1442FX            &K4             &H unused \Q unused &E unused
DSI                     ScoutPlus                       *F2             &H &E &K \Q1 unused


        We had &K4 and \Q1 commands being sent (until 7/10/93).
        This is a potential problem for US Robotics, MultiTech
        and DSI modems.

        US Robotics defaults to ALL flow control disabled
        DSI ScoutPlus defaults to CTS/RTS flow control
        MultiTech defaults to CTS/RTS flow control
        MultiTech is Class2-only, so we may not have trouble there

7/10/93
        Added &H2 command to iModemReInit -- doesn't affect anyone else I think
later
        Removed &H2 -- some modems use that as  'help' cmd & display a page
        of help info that they refuse to exit except on pressing N or some such!
        So we think the modem's hung!
later
        Removed *F2 -- Starts a Flassh ROM download on Rockwell!!

****-------------------- FLOW CONTROL -------------------------*******/



/*************************************************************************
        According to "Data and Fax Communications" by Hummel,flow control
        settings are as follows

xon     both
&H2     &H3     -- US Robotics (though this fatally invokes Help on some modems)
&K4     -- Dallas, Hayes, Practical, Prometheus, Rockwell, Sierra, Telebit
                        Twincom, Zoom
\Q1     -- AT&T, Dallas, Microcom, Practical, Prometheus, Sierra
*F2             -- Prometheus (though it fatally invokes Flash ROM download on Rockwell)
#K4             -- Sierra-based fax modems
S68=3   -- Telebit

**************************************************************************/


#define AT      "AT"
#define ampF    "&F"
#define S0_0    "S0=0"
#define E0      "E0"
#define V1      "V1"
#define Q0      "Q0"
#define S7_60  "S7=60"
#define ampD2   "&D2"
#define ampD3   "&D3"
#define bsQ1    "\\Q1"
#define bsJ0    "\\J0"
#define ampK4   "&K4"
#define ampH2   "&H2"
#define ampI2   "&I2"
#define ampE5   "&E5"
#define cr      "\r"
//#define       ampC1   "&C1"


USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG)

/*++

Routine Description:

    Tries to figure out the reset and setup command for the modem if the were
    not read from the registry or what was read does not work.
    If a reset command works the fGOTCMD_Reset is set in pTG->TmpSettings.dwGot and it is saved in pTG->TmpSettings.szReset.
    If a setup command works the fGOTCMD_Setup is set in pTG->TmpSettings.dwGot and it is saved in pTG->TmpSettings.szReset.
    if pTG->TmpSettings.dwSerialSpeed is not set (0) then we set it to pTG->SerialSpeedInit and turn on 
    the fGOTPARM_PORTSPEED flag.

Return Value:
    0 if succeeded.
    INIT_MODEMDEAD if the modem does not respond.


--*/
{
    USHORT uLen1 = 0, uLen2 = 0;
    BOOL fGotFlo;

    // At this point, we have possibly an incompletely and/or
    // incorrectly filled out set of commands and capabilities.

    // Our job here is to use a combination of detection and
    // pre-filled commands to come up with a working set of
    // commands..

    DEBUG_FUNCTION_NAME(_T("iModemFigureOutCmdsExt"));

    if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
    {
        //@
        //@ If we read a reset command from the registry we
        //@ don't attempt to find it if it is NULL or empty.
        if (!(pTG->TmpSettings.szReset)
           || !*(pTG->TmpSettings.szReset)
           || iModemReset(pTG, pTG->TmpSettings.szReset) >= 0)
        {
            //@ If we dont have a pre read reset command
            //@ or the reset command is empty
            //@ or we succeeded in getting a response from the specified reset command
            //@ then we don't attemp to figure this out.
                goto SkipReset;
        }
        else
        {
            DebugPrintEx(   DEBUG_WRN,
                            "BOGUS supplied reset cmd: \"%s\"",
                            (LPSTR) pTG->TmpSettings.szReset);
        }
    }

    //@
    //@ We wither did not read a reset command from the registr or read
    //@ a non empty one and it did not work.
    //@
    //@ We now try to figure out the right reset command by just trying
    //@ the most common strings...
    //@

    // Quick test to see if we have a modem at all...
    // +++ REMOVE!
    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT E0 V1 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) < 0)
    {
        DebugPrintEx(DEBUG_ERR,"can't set ATE0V1");
        goto modem_dead;
    }

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 Q0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    // too many variants, too slow, V1Q0 are default anyway
    //_fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 cr);
    //if(iModemReset(pTG->TmpSettings.szSmallTemp1) >= 0)
    //      goto GotReset;

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF E0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    DebugPrintEx(DEBUG_ERR,"can't set AT&FE0");

    // Purge comm here, because there may be stuff left in the output
    // buffer that FComClose will try to complete, and if the modem
    // is dead, that  will take a while...
modem_dead:
    FComFlush(pTG);

    return INIT_MODEMDEAD;

GotReset:
    //@
    //@ We succeeded in figuring out a reset command. Turn on the fGOTCMD_Reset flag
    //@ and save it in pTG->TmpSettings.szReset.
    //@
    pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
    _fstrcpy(pTG->TmpSettings.szReset, pTG->TmpSettings.szSmallTemp1);

SkipReset:
    // now try setup cmd
    if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
    {
        if (!(pTG->TmpSettings.szSetup)
           || !*(pTG->TmpSettings.szSetup)
           || OfflineDialog2(pTG, pTG->TmpSettings.szSetup,
                                        (USHORT)_fstrlen(pTG->TmpSettings.szSetup), cbszOK,
                                                cbszERROR)==1)
        {
            goto SkipSetup;
        }
        else
        {
            DebugPrintEx(   DEBUG_WRN,
                            "BOGUS supplied setup cmd: \"%s\"\r\n",
                            (LPSTR) pTG->TmpSettings.szSetup);
        }
    }
    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT);
    uLen2 = sizeof(AT)-1;

    if(OfflineDialog2(pTG, (LPSTR)(AT S7_60 cr), sizeof(AT S7_60 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, S7_60);
        uLen2 += sizeof(S7_60)-1;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"can't set S7=255");
    }

    if(OfflineDialog2(pTG, (LPSTR)(AT ampD3 cr), sizeof(AT ampD3 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD3);
        uLen2 += sizeof(ampD3)-1;
    }
    else if(OfflineDialog2(pTG, (LPSTR)(AT ampD2 cr), sizeof(AT ampD2 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD2);
        uLen2 += sizeof(ampD2)-1;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"can't set &D3 or &D2");
    }

    fGotFlo=FALSE;
    if(OfflineDialog2(pTG, (LPSTR)(AT ampK4 cr), sizeof(AT ampK4 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampK4);
        uLen2 += sizeof(ampK4)-1;
        fGotFlo=TRUE;
    }

    // JosephJ 3/10/95: We try \Q1\J0 even if &K4 passed,
    // because many japanese modems return OK to &K4 but in fact
    // use \J0 for xon xoff flow control
    if(OfflineDialog2(pTG, (LPSTR)(AT bsQ1 cr), sizeof(AT bsQ1 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsQ1);
        uLen2 += sizeof(bsQ1)-1;

        if(OfflineDialog2(pTG, (LPSTR)(AT bsJ0 cr), sizeof(AT bsJ0 cr)-1, cbszOK, cbszERROR) == 1)
        {
            _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsJ0);
            uLen2 += sizeof(bsJ0)-1;
        }
        fGotFlo=TRUE;
    }

    if (!fGotFlo)
    {
        DebugPrintEx(DEBUG_WRN,"can't set &K4 or \\Q1, trying &K5");
        if(OfflineDialog2(pTG, (LPSTR)(AT ampE5 cr), sizeof(AT ampE5 cr)-1, cbszOK, cbszERROR) == 1)
        {
            _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampE5);
            uLen2 += sizeof(ampE5)-1;
            fGotFlo=TRUE;
        }
    }

    _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, cr);
    uLen2 += sizeof(cr)-1;

    _fstrcpy(pTG->TmpSettings.szSetup, pTG->TmpSettings.szSmallTemp1);
    pTG->TmpSettings.dwGot |=fGOTCMD_Setup;

SkipSetup:

    if (!pTG->TmpSettings.dwSerialSpeed)
    {
        pTG->TmpSettings.dwSerialSpeed = pTG->SerialSpeedInit;
        pTG->TmpSettings.dwGot |=fGOTPARM_PORTSPEED;
    }

    return 0;
}

void 
TalkToModem 
(
    PThrdGlbl pTG,
    BOOL fGetClass
)
{

   char    Command [400];
   char    Response[1000];
   DWORD   RespLen;
   USHORT  uRet;
   char    *lpBeg;
   char    *lpCur;

#define uMULTILINE_SAVEENTIRE   0x1234

   //
   // This function implements special case modems firmware identification
   // as well as modem class identification.
   //

   DEBUG_FUNCTION_NAME(("TalkToModem"));

   if ( (! fGetClass) && (pTG->AdaptiveCodeId != 1) ) 
   {
      return;
   }

   //
   // Initialize modem
   //

   if(! T30ComInit(pTG, pTG->hComm) ) 
   {
      DebugPrintEx(DEBUG_ERR,"cannot init COM port");
      return;
   }

   FComDTR(pTG, TRUE); // Raise DTR in ModemInit
   FComFlush(pTG);

   pTG->fCommInitialized = 1;
   
   sprintf (Command, "AT E0 Q0 V1\r" );

   if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
   {
       DebugPrintEx(DEBUG_ERR, "1 %s FAILED",  Command);
       return;
   }
   
   DebugPrintEx(DEBUG_MSG,"TalkToModem 1 %s rets OK",  Command);


   if (fGetClass) 
   {
      //
      // Get modem class
      //

      pTG->ModemClass=MODEM_CLASS1;  // default
     
      sprintf (Command, "AT+FCLASS=?\r" );
     
      if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
      {
          DebugPrintEx(DEBUG_ERR, "TalkToModem 1 %s FAILED",  Command);
          return;
      }
     
      DebugPrintEx( DEBUG_MSG, 
                    "TalkToModem 1 %s returned %s",  
                    Command, 
                    pTG->FComModem.bLastReply);
     
      if (strchr(pTG->FComModem.bLastReply, '1') ) 
      {
         DebugPrintEx(DEBUG_MSG, "Default to Class1");
      }
      else if ( lpBeg = strchr (pTG->FComModem.bLastReply, '2') )  
      {
         lpBeg++;
         if ( *lpBeg != '.' ) 
         {
            DebugPrintEx(DEBUG_MSG, "Default to Class2");
            pTG->ModemClass=MODEM_CLASS2;
         }
         else if ( strchr (lpBeg, '2') ) 
         {
             DebugPrintEx(DEBUG_MSG, "Default to Class2");
             pTG->ModemClass=MODEM_CLASS2;
         }
         else 
         {
            DebugPrintEx(DEBUG_MSG, "Default to Class2.0");
            pTG->ModemClass=MODEM_CLASS2_0;
         }
      }
      else 
      {
         DebugPrintEx(DEBUG_ERR, "Could not get valid Class answer. Default to Class1");
      }
   }

   //
   // If needed, get firmware identification.
   //

   switch (pTG->AdaptiveCodeId) 
   {
   case 1:
      // Sportster 28800-33600 internal/external

      sprintf (Command, "ATI7\r" );

      FComFlushOutput(pTG);
      FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );

      if ( ( uRet = iiModemDialog( pTG, 0, 0, 5000, uMULTILINE_SAVEENTIRE,1, TRUE,
                               cbszOK,
                               cbszERROR,
                               (CBPSTR)NULL) ) != 1 )  
      {
          DebugPrintEx(DEBUG_ERR, "TalkToModem 2 %s FAILED",  Command);
          return;
      }

      DebugPrintEx(DEBUG_MSG,"TalkToModem 2 %s rets OK",  Command);

      RespLen = min(sizeof(Response) - 1,  strlen(pTG->FComModem.bEntireReply) );
      memcpy(Response, pTG->FComModem.bEntireReply, RespLen);
      Response[RespLen] = 0;

      ToCaps(Response);

      //
      // if "EPROM DATE" is "10/18/95" then the adaptive answer is broken (Hugh Riley, USR 03/25/97).
      // otherwise enable adaptive answer.  
      // If we enabled adaptive answer and firmware is broken then the customer needs to upgrade f/w.
      //

      if ( ! strstr(Response, "10/18/95") ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      // 
      // found "10/18/95".  Lets check if this is an EPROM DATE.
      //
      if ( ! (lpBeg = strstr(Response, "EPROM DATE") ) ) 
      {
         return;
      }

      if ( ! (lpCur = strstr(lpBeg, "10/18/95") ) ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      if ( ! strstr(lpCur, "DSP DATE") ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }
      
      return;

   default:
      return;

   }
   return;
}


BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG)
                // Reads as much as it can from the current profile. Returns TRUE
                // IFF it has read enough for a proper init.
                // On failure, zero's out everything.
                // All info is maintained in global TmpSettings;
{
    USHORT          uLen1=0, uLen2=0;
    ULONG_PTR        dwKey=0;
    ULONG_PTR        dwKeyAdaptiveAnswer=0;
    ULONG_PTR        dwKeyAnswer=0;
    BOOL            fRet=FALSE;
    LPMODEMCAPS     lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
    LPMODEMEXTCAPS  lpMdmExtCaps = pTG->TmpSettings.lpMdmExtCaps;
    UINT            uTmp;
    ULONG_PTR        KeyList[10] = {0};
    char            KeyName[200];
    DWORD           i;
    char            lpTemp[MAXCMDSIZE];
    char            szClass[10];

    DEBUG_FUNCTION_NAME(("iModemGetCurrentModemInfo"));

    imodem_clear_tmp_settings(pTG);

    for (i=0; i< 20; i++) 
    {
        BG_CHK(pTG->AnswerCommand[i] == NULL);
    }

    // We want to be sure that there isn't any memory leak here
    BG_CHK(!pTG->ModemResponseFaxDetect &&
           !pTG->ModemResponseDataDetect &&
           !pTG->HostCommandFaxDetect &&
           !pTG->HostCommandDataDetect &&
           !pTG->ModemResponseFaxConnect &&
           !pTG->ModemResponseDataConnect);

    //
    // get T.30 modem Fax key
    //

    if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) 
    {
        goto end;
    }

    //
    // Lets see what modem Class we will use
    //
    uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
    
    if (uTmp == 1) 
    {
       pTG->ModemClass = MODEM_CLASS1;
    }
    else if (uTmp == 2) 
    {
       pTG->ModemClass = MODEM_CLASS2;
    }
    else if (uTmp == 20) 
    {
       pTG->ModemClass = MODEM_CLASS2_0;
    }

    if (! pTG->ModemClass) 
    {
       DebugPrintEx(DEBUG_ERR, "MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       sprintf(szClass, "Class1");
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       break;

    default:
       sprintf(szClass, "Class1");
    }


    //
    // depending on a requested operation, find the appropriate settings 
    //

    if (pTG->Operation == T30_RX) 
    {
       KeyList[0] = dwKey;

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
       KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);
       KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       if (KeyList[2] == 0) 
       {
           pTG->AdaptiveAnswerEnable = 0;

           sprintf(KeyName, "%s\\%s\\Receive", pTG->FComModem.rgchKey, szClass);
           KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
       }
       else 
       {
           dwKeyAdaptiveAnswer = KeyList[2];
           pTG->AdaptiveAnswerEnable = 1;
       }

       KeyList[3] = 0;
       //
       // Turn off adaptive answering if the admin disabled it via the UI
       //
       pTG->AdaptiveAnswerEnable = pTG->AdaptiveAnswerEnable && pTG->ExtData.bAdaptiveAnsweringEnabled;       

    }
    else if (pTG->Operation == T30_TX) 
    {
       KeyList[0] = dwKey;

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
       KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       sprintf(KeyName, "%s\\%s\\Send", pTG->FComModem.rgchKey, szClass);
       KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
       
       KeyList[3] = 0;
    }
    else 
    {
       DebugPrintEx(DEBUG_ERR, "INVALID pTG->Operation=%d",(int)pTG->Operation );
       goto end;
    }

    if (lpMdmCaps->uClasses = (USHORT)ProfileListGetInt(KeyList, szModemFaxClasses, 0))
    {
        pTG->TmpSettings.dwGot |= fGOTCAP_CLASSES;
    }

    if(lpMdmCaps->uClasses & FAXCLASS1)
    {
        if (lpMdmCaps->uSendSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemSendSpeeds, 0))
        {
            pTG->TmpSettings.dwGot |= fGOTCAP_SENDSPEEDS;
        }
        if (lpMdmCaps->uRecvSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemRecvSpeeds, 0))
        {
            pTG->TmpSettings.dwGot |= fGOTCAP_RECVSPEEDS;
        }
    }

    pTG->ModemKeyCreationId = ProfileGetInt(dwKey, szModemKeyCreationId, 0, FALSE);

    //RSL 10/10/96

    pTG->Inst.ProtParams.fEnableV17Send   = ProfileListGetInt(KeyList, szEnableV17Send, 1);
    pTG->Inst.ProtParams.fEnableV17Recv   = ProfileListGetInt(KeyList, szEnableV17Recv, 1);

    uTmp = ProfileListGetInt(KeyList, szHighestSendSpeed, 0);
    if (uTmp) 
    {
        pTG->Inst.ProtParams.HighestSendSpeed = (SHORT)uTmp;
    }

    uTmp = ProfileListGetInt(KeyList, szLowestSendSpeed, 0);
    if (uTmp) 
    {
        pTG->Inst.ProtParams.LowestSendSpeed = (SHORT)uTmp;
    }

    // new settings 

    uTmp = ProfileListGetInt(KeyList, szSerialSpeedInit, 0);
    if (uTmp) 
    {
        pTG->SerialSpeedInit = (UWORD)uTmp;
        pTG->SerialSpeedInitSet = 1;
        pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
    }

    uTmp = ProfileListGetInt(KeyList, szSerialSpeedConnect, 0);
    if (uTmp) 
    {
        pTG->SerialSpeedConnect = (UWORD)uTmp;
        pTG->SerialSpeedConnectSet = 1;
        pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
    }

    uTmp = ProfileListGetInt(KeyList, szHardwareFlowControl, 0);
    if (uTmp) 
    {
        pTG->fEnableHardwareFlowControl = 1;
    }


    DebugPrintEx(   DEBUG_MSG, 
                    "fEnableV17Send=%d, fEnableV17Recv=%d, "
                    "HighestSendSpeed=%d, Low=%d EnableAdaptAnswer=%d",
                     pTG->Inst.ProtParams.fEnableV17Send,
                     pTG->Inst.ProtParams.fEnableV17Recv,
                     pTG->Inst.ProtParams.HighestSendSpeed,
                     pTG->Inst.ProtParams.LowestSendSpeed,
                     pTG->AdaptiveAnswerEnable);
    
    DebugPrintEx(   DEBUG_MSG, 
                    "HardwareFlowControl=%d, SerialSpeedInit=%d, SerialSpeedConnect=%d",
                    pTG->fEnableHardwareFlowControl,
                    pTG->SerialSpeedInit,
                    pTG->SerialSpeedConnect);

    // get CmdTab. We distinguish been a command being not-specified and null.
    //

    if (imodem_list_get_str(pTG, KeyList, szResetCommand,
                                    pTG->TmpSettings.szReset, MAXCMDSIZE, TRUE))
            pTG->TmpSettings.dwGot |= fGOTCMD_Reset;

    if (imodem_list_get_str(pTG, KeyList, szSetupCommand,
                                    pTG->TmpSettings.szSetup, MAXCMDSIZE, TRUE))
            pTG->TmpSettings.dwGot |= fGOTCMD_Setup;

    if (imodem_list_get_str(pTG, KeyList, szPreDialCommand,
                                    pTG->TmpSettings.szPreDial, MAXCMDSIZE, TRUE))
            pTG->TmpSettings.dwGot |= fGOTCMD_PreDial;

    if (imodem_list_get_str(pTG, KeyList, szPreAnswerCommand,
                                    pTG->TmpSettings.szPreAnswer, MAXCMDSIZE, TRUE))
            pTG->TmpSettings.dwGot |= fGOTCMD_PreAnswer;

    if (imodem_list_get_str(pTG, KeyList, szExitCommand,
                                    pTG->TmpSettings.szExit, MAXCMDSIZE, TRUE))
            pTG->TmpSettings.dwGot |= fGOTCMD_PreExit;


    //
    // Adaptive Answer strings ONLY.
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       pTG->AnswerCommandNum = 0;

       // get Answer commands key
       sprintf(KeyName, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       if (dwKeyAnswer == 0) 
       {
          DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer\\AnswerCommand does not exist");
          goto lPostAdaptiveAnswer;
       }

       for (i=1; i<=20; i++) 
       {
          sprintf (KeyName, "%d", i);
          if ( ! imodem_get_str(pTG, dwKeyAnswer, KeyName, lpTemp, MAXCMDSIZE, TRUE) ) 
          {
             break;
          }

          if (NULL != (pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpTemp) + 1))) 
          {
			 sprintf ( pTG->AnswerCommand[pTG->AnswerCommandNum], "%s", lpTemp);
          }
		  else 
          {
			 goto end;
          }

          pTG->AnswerCommandNum++;
       }

       ProfileClose(dwKeyAnswer);

       if (pTG->AnswerCommandNum == 0) 
       {
          DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer\\AnswerCommand Zero values.");
          goto lPostAdaptiveAnswer;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpTemp) + 1)))
			 sprintf ( pTG->ModemResponseFaxDetect, "%s", lpTemp);
		  else
			 goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
	   {
          if (NULL != (pTG->ModemResponseDataDetect = MemAlloc( strlen(lpTemp) + 1)))
			 sprintf ( pTG->ModemResponseDataDetect, "%s", lpTemp);
		  else
			 goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          pTG->SerialSpeedFaxDetect = (UWORD)atoi (lpTemp);
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          pTG->SerialSpeedDataDetect = (UWORD)atoi (lpTemp);
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandFaxDetect, lpTemp, MAXCMDSIZE, TRUE) ) 
       {
          if (NULL != (pTG->HostCommandFaxDetect = MemAlloc( strlen(lpTemp) + 1)))
			 sprintf ( pTG->HostCommandFaxDetect, "%s", lpTemp);
		  else
			 goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandDataDetect, lpTemp, MAXCMDSIZE, TRUE) ) 
       {
          if (NULL != (pTG->HostCommandDataDetect = MemAlloc( strlen(lpTemp) + 1)))
			 sprintf ( pTG->HostCommandDataDetect, "%s", lpTemp);
		  else
			  goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxConnect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpTemp) + 1)))
             sprintf ( pTG->ModemResponseFaxConnect, "%s", lpTemp);
		  else
			  goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataConnect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseDataConnect = MemAlloc( strlen(lpTemp) + 1)))
             sprintf ( pTG->ModemResponseDataConnect, "%s", lpTemp);
		  else
			 goto end;
       }


    }




lPostAdaptiveAnswer:

    pTG->FixSerialSpeed = (UWORD)ProfileListGetInt(KeyList, szFixSerialSpeed, 0);
    if (pTG->FixSerialSpeed) 
    {
         pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
         pTG->FixSerialSpeedSet = 1;
    }


    //
    // Merge 3 optional different settings for Serial Speed here
    //

    // FixSerialSpeed overrides the others (init/connect)

    if (pTG->FixSerialSpeedSet) 
    {
        pTG->SerialSpeedInit = pTG->FixSerialSpeed;
        pTG->SerialSpeedConnect = pTG->FixSerialSpeed;
        pTG->SerialSpeedInitSet = 1;
        pTG->SerialSpeedConnectSet = 1;
    }

    // if only one of init/connect then the other is same

    if ( pTG->SerialSpeedInitSet && (!pTG->SerialSpeedConnectSet) ) 
    {
       pTG->SerialSpeedConnect = pTG->SerialSpeedInit;
       pTG->SerialSpeedConnectSet = 1;
    }
    else if ( (!pTG->SerialSpeedInitSet) && pTG->SerialSpeedConnectSet ) 
    {
       pTG->SerialSpeedInit = pTG->SerialSpeedConnect;
       pTG->SerialSpeedInitSet = 1;
    }

    // values init/connect are always initialized. 
    // Use (init/connect)Set flags to determine whether there were originally set.
    
    if (! pTG->SerialSpeedInit) 
    {
        pTG->SerialSpeedInit    = 57600;
        pTG->SerialSpeedConnect = 57600;
    }

    // +++ Expand as necessary:
    if (ProfileListGetInt(KeyList, szCL1_NO_SYNC_IF_CMD, 1))
    {
        pTG->TmpSettings.dwFlags |= fMDMSP_C1_NO_SYNC_IF_CMD;
    }
    if (ProfileListGetInt(KeyList, szANS_GOCLASS_TWICE, 1))
    {
        pTG->TmpSettings.dwFlags |= fMDMSP_ANS_GOCLASS_TWICE; // DEFAULT
    }
#define szMDMSP_C1_FCS  "Cl1FCS" // 0==dunno 1=NO 2=yes-bad
    // specifies whether the modem reports the 2-byteFCS with
    // received HDLC data. (Elliot bugs# 3641, 3668, 3086 report
    // cases of modems sending incorrect FCS bytes).
    // 9/7/95 JosephJ -- changed default from 0 to 2 because Class1 spec
    // says we should NOT rely on the FCS bytes being computed correctly.
    switch(ProfileListGetInt(KeyList, szMDMSP_C1_FCS, 2))
    {
    case 1: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_NO;
            break;
    case 2: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_YES_BAD;
            break;
    }
    pTG->TmpSettings.dwGot |= fGOTFLAGS;


    lpMdmExtCaps->dwDialCaps = ProfileListGetInt(KeyList, szDIALCAPS, 0);

    // Retrieve ID command.
    // a way around this Id check. If IdCmd has been manually deleted, skip chk
    if (imodem_list_get_str(pTG, KeyList, szModemIdCmd,
                                    pTG->TmpSettings.szIDCmd, MAXCMDSIZE, TRUE))
    {
            pTG->TmpSettings.dwGot |= fGOTPARM_IDCMD;
            if (imodem_list_get_str(pTG, KeyList, szModemId,
                                    pTG->TmpSettings.szID, MAXIDSIZE, FALSE))
                    pTG->TmpSettings.dwGot |= fGOTPARM_ID;
    }

    pTG->TmpSettings.uDontPurge= (USHORT)ProfileListGetInt(KeyList, szDONT_PURGE, 0xff);


    //
    // Classes 2 and 2.0
    //

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        uTmp = ProfileListGetInt(KeyList,szRECV_BOR,0xff);
        pTG->CurrentMFRSpec.iReceiveBOR = (USHORT) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szSEND_BOR, 0xff);
        pTG->CurrentMFRSpec.iSendBOR = (USHORT) uTmp;
                  
        uTmp = ProfileListGetInt(KeyList, szSW_BOR, 0xff);
        pTG->CurrentMFRSpec.fSWFBOR = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szDC2CHAR, 0x0);
        pTG->CurrentMFRSpec.szDC2[0] = (CHAR) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szIS_SIERRA, 0xff);
        pTG->CurrentMFRSpec.bIsSierra = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szIS_EXAR, 0xff);
        pTG->CurrentMFRSpec.bIsExar = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szSKIP_CTRL_Q, 0xff);
        pTG->CurrentMFRSpec.fSkipCtrlQ = (BOOL) uTmp;
    }

    if (dwKey)
        ProfileClose(dwKey);

#define fMANDATORY (fGOTCMD_Reset|fGOTCMD_Setup|fGOTCAP_CLASSES)
#define fCLASS1MANDATORY (fMANDATORY | fGOTCAP_SENDSPEEDS | fGOTCAP_RECVSPEEDS)
    fRet = (lpMdmCaps->uClasses & FAXCLASS1)
              ?     ((pTG->TmpSettings.dwGot & fCLASS1MANDATORY) == fCLASS1MANDATORY)
              :     ((pTG->TmpSettings.dwGot & fMANDATORY) == fMANDATORY);

end:
    	
   for (i=1; i<10; i++) 
   {
      if (KeyList[i] != 0) 
      {
         ProfileClose (KeyList[i]);
      }
   }

   if (!fRet) 
   { // Lets free all memory that was allocated here
       CleanModemInfStrings (pTG);
   }

   return fRet;
}

BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG)
{
    DWORD_PTR      dwKey=0;
    LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
    char           KeyName[200];
    DWORD_PTR      dwKeyAdaptiveAnswer=0;
    DWORD_PTR      dwKeyAnswer=0;
    DWORD          i;
    char           szClass[10];


    DEBUG_FUNCTION_NAME(("iModemSaveCurrentModemInfo"));
    //
    // Right now we save all major caps at the root level.
    //
      
    if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                    fREG_CREATE | fREG_READ | fREG_WRITE)))
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
        goto failure;
    }

    if (! pTG->ModemClass) 
    {
       pTG->ModemClass = MODEM_CLASS1;  
       DebugPrintEx(DEBUG_ERR, "MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
       sprintf(szClass, "Class1");
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
       break;

    default:
       sprintf(szClass, "Class1");
    }

    wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->ModemKeyCreationId );
    ProfileWriteString(dwKey, szModemKeyCreationId,   pTG->TmpSettings.szSmallTemp1, FALSE);
    
    ////// Modem Commands
    ProfileWriteString(dwKey, szResetCommand,     pTG->TmpSettings.szReset, TRUE);
    ProfileWriteString(dwKey, szSetupCommand,     pTG->TmpSettings.szSetup, TRUE);
    ProfileWriteString(dwKey, szExitCommand ,     pTG->TmpSettings.szExit, TRUE);
    ProfileWriteString(dwKey, szPreDialCommand  , pTG->TmpSettings.szPreDial, TRUE);
    ProfileWriteString(dwKey, szPreAnswerCommand, pTG->TmpSettings.szPreAnswer, TRUE);


    //
    // Adaptive Answer
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       // create Class key if it doesn't exist

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open Class1.");
            goto failure;
       }

       ProfileClose(dwKeyAdaptiveAnswer);

       // create Class1\AdaptiveAnswer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer.");
            goto failure;
       }

       // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey, szClass);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer\\AnswerCommand .");
            goto failure;
       }

       for (i=0; i<pTG->AnswerCommandNum; i++) 
       {
          sprintf (KeyName, "%d", i+1);
          ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
       }

       ProfileClose(dwKeyAnswer);

       // store the rest of the AdaptiveAnswer values

       if (pTG->ModemResponseFaxDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);

       if (pTG->ModemResponseDataDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);

       if (pTG->SerialSpeedFaxDetect) 
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
       }

       if (pTG->SerialSpeedDataDetect)   
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
       }

       if (pTG->HostCommandFaxDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);

       if (pTG->HostCommandDataDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect, TRUE);


       if (pTG->ModemResponseFaxConnect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);

       if (pTG->ModemResponseDataConnect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);


       ProfileClose(dwKeyAdaptiveAnswer);

    }

    if (pTG->fEnableHardwareFlowControl) 
    {
       ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
    }


    //
    // Serial Speed
    //

    if (!pTG->SerialSpeedInitSet) 
    {
         wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->TmpSettings.dwSerialSpeed);
         ProfileWriteString(dwKey, szFixSerialSpeed,   pTG->TmpSettings.szSmallTemp1, FALSE);
    }
    else 
    {
       wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
       ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
    }

    if (pTG->TmpSettings.dwGot & fGOTFLAGS)
    {
        if (pTG->TmpSettings.dwFlags & fMDMSP_C1_NO_SYNC_IF_CMD)
        {
            ProfileWriteString(dwKey, szCL1_NO_SYNC_IF_CMD, "1", FALSE);
        }

        if (!(pTG->TmpSettings.dwFlags & fMDMSP_ANS_GOCLASS_TWICE))
        {
            ProfileWriteString(dwKey, szANS_GOCLASS_TWICE, "0", FALSE);
        }
    }

    // uDontPurge==1 => save 1
    // otherwise     => save 0
    wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) (pTG->TmpSettings.uDontPurge==1)?1:0);
    ProfileWriteString(dwKey, szDONT_PURGE, pTG->TmpSettings.szSmallTemp1, FALSE);

    ///////// Modem Caps...
    // write out Classes, then Speeds
    wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uClasses);
    ProfileWriteString(dwKey, szModemFaxClasses,   pTG->TmpSettings.szSmallTemp1, FALSE);


    //
    // Classes 2 and 2.0 
    // 

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iReceiveBOR);
        ProfileWriteString(dwKey, szRECV_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iSendBOR);
        ProfileWriteString(dwKey, szSEND_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSWFBOR);
        ProfileWriteString(dwKey, szSW_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        ProfileWriteString(dwKey, szDC2CHAR, pTG->CurrentMFRSpec.szDC2, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsSierra);
        ProfileWriteString(dwKey, szIS_SIERRA, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsExar);
        ProfileWriteString(dwKey, szIS_EXAR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSkipCtrlQ);
        ProfileWriteString(dwKey, szSKIP_CTRL_Q, pTG->TmpSettings.szSmallTemp1, FALSE);
    }

    if(lpMdmCaps->uClasses & FAXCLASS1)
    {
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uSendSpeeds);
        ProfileWriteString(dwKey, szModemSendSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uRecvSpeeds);
        ProfileWriteString(dwKey, szModemRecvSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);
    }
    if (dwKey)
            ProfileClose(dwKey);

    return TRUE;

failure:
    if (dwKey)
            ProfileClose(dwKey);

    return FALSE;
}

BOOL ReadModemClassFromRegistry  (PThrdGlbl pTG)
{

   UINT            uTmp;
   DWORD_PTR       dwKey;


   if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) 
   {
       return FALSE;
   }

   //
   // Lets see what modem Class we will use
   //
   uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
   
   if (uTmp == 1) 
   {
      pTG->ModemClass = MODEM_CLASS1;
   }
   else if (uTmp == 2) 
   {
      pTG->ModemClass = MODEM_CLASS2;
   }
   else if (uTmp == 20) 
   {
      pTG->ModemClass = MODEM_CLASS2_0;
   }

   if (dwKey) 
      ProfileClose(dwKey);

   return TRUE;
}

BOOL SaveModemClass2Registry(PThrdGlbl pTG)
{
   DWORD_PTR      dwKey=0;

   DEBUG_FUNCTION_NAME(("SaveModemClass2Registry"));

   if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                   fREG_CREATE | fREG_READ | fREG_WRITE)))
   {
       DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
       goto failure;
   }


   switch (pTG->ModemClass) 
   {
   case MODEM_CLASS1 :
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
      break;

   case MODEM_CLASS2 :
      ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
      break;

   case MODEM_CLASS2_0 :
      ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
      break;

   default:
      DebugPrintEx(DEBUG_ERR,"pTG->ModemClass=%d", pTG->ModemClass);
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
   }

   if (dwKey)
           ProfileClose(dwKey);

   return TRUE;


failure:
   return FALSE;


}


BOOL SaveInf2Registry  (PThrdGlbl pTG)
{
    DWORD_PTR      dwKey=0;
    LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
    char           KeyName[200];
    DWORD_PTR      dwKeyAdaptiveAnswer=0;
    DWORD_PTR      dwKeyAnswer=0;
    DWORD          i;
    char           szClass[10];

    DEBUG_FUNCTION_NAME(("SaveInf2Registry"));

    if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                    fREG_CREATE | fREG_READ | fREG_WRITE)))
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
        goto failure;
    }

    if (! pTG->ModemClass) 
    {
       DebugPrintEx(DEBUG_ERR,"MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       sprintf(szClass, "Class1");
       ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
       break;

    default:
       sprintf(szClass, "Class1");
    }

    ////// Modem Commands
    if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
       ProfileWriteString(dwKey, szResetCommand,     pTG->TmpSettings.szReset, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
       ProfileWriteString(dwKey, szSetupCommand,     pTG->TmpSettings.szSetup, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_PreExit)
       ProfileWriteString(dwKey, szExitCommand ,     pTG->TmpSettings.szExit, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_PreDial)
       ProfileWriteString(dwKey, szPreDialCommand  , pTG->TmpSettings.szPreDial, TRUE);
    
    if (pTG->TmpSettings.dwGot & fGOTCMD_PreAnswer)
       ProfileWriteString(dwKey, szPreAnswerCommand, pTG->TmpSettings.szPreAnswer, TRUE);


    //
    // Adaptive Answer
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       // create szClass key if it doesn't exist

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open szClass.");
            goto failure;
       }

       ProfileClose(dwKeyAdaptiveAnswer);

       // create Class\AdaptiveAnswer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer.");
            goto failure;
       }

       // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey ,szClass);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer\\AnswerCommand .");
            goto failure;
       }

       for (i=0; i<pTG->AnswerCommandNum; i++) 
       {
          sprintf (KeyName, "%d", i+1);
          ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
          MemFree( pTG->AnswerCommand[i]);
          pTG->AnswerCommand[i] = NULL;
       }
       pTG->AnswerCommandNum = 0;
       ProfileClose(dwKeyAnswer);

       // store the rest of the AdaptiveAnswer values

       if (pTG->ModemResponseFaxDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);
          MemFree( pTG->ModemResponseFaxDetect );
          pTG->ModemResponseFaxDetect = NULL;
       }

       if (pTG->ModemResponseDataDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);
          MemFree (pTG->ModemResponseDataDetect);
          pTG->ModemResponseDataDetect = NULL;
       }

       if (pTG->SerialSpeedFaxDetect) 
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
       }

       if (pTG->SerialSpeedDataDetect)   
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
       }

       if (pTG->HostCommandFaxDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);
          MemFree( pTG->HostCommandFaxDetect);
          pTG->HostCommandFaxDetect = NULL;
       }

       if (pTG->HostCommandDataDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect,TRUE);
          MemFree( pTG->HostCommandDataDetect);
          pTG->HostCommandDataDetect = NULL;
       }

       if (pTG->ModemResponseFaxConnect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);
          MemFree( pTG->ModemResponseFaxConnect);
          pTG->ModemResponseFaxConnect = NULL;
       }

       if (pTG->ModemResponseDataConnect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);
          MemFree(pTG->ModemResponseDataConnect);
          pTG->ModemResponseDataConnect = NULL;
       }


       ProfileClose(dwKeyAdaptiveAnswer);

    }


    if (pTG->fEnableHardwareFlowControl) 
    {
       ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
    }


    //
    // Serial Speed
    //

    if (pTG->SerialSpeedInitSet) 
    {
       wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
       ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
    }

    //
    // Classes 2 and 2.0
    //

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iReceiveBOR);
        ProfileWriteString(dwKey, szRECV_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iSendBOR);
        ProfileWriteString(dwKey, szSEND_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSWFBOR);
        ProfileWriteString(dwKey, szSW_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);

        ProfileWriteString(dwKey, szDC2CHAR, pTG->CurrentMFRSpec.szDC2, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsSierra);
        ProfileWriteString(dwKey, szIS_SIERRA, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsExar);
        ProfileWriteString(dwKey, szIS_EXAR, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSkipCtrlQ);
        ProfileWriteString(dwKey, szSKIP_CTRL_Q, pTG->TmpSettings.szSmallTemp1, FALSE);

    }

    if (dwKey)
            ProfileClose(dwKey);
    return TRUE;



failure:
    if (dwKey)
            ProfileClose(dwKey);
    return FALSE;
}










BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG)
{
    WORD w;
    LPSTR lpstr;
    LPVOID lpv;

    DEBUG_FUNCTION_NAME(("imodem_alloc_tmp_strings"));

    BG_CHK(    !pTG->TmpSettings.hglb
                    && !pTG->TmpSettings.szReset
                    && !pTG->TmpSettings.szSetup
                    && !pTG->TmpSettings.szExit
                    && !pTG->TmpSettings.szPreDial
                    && !pTG->TmpSettings.szPreAnswer
                    && !pTG->TmpSettings.szID
                    && !pTG->TmpSettings.szIDCmd
                    && !pTG->TmpSettings.szSmallTemp1
                    && !pTG->TmpSettings.szSmallTemp2
                    && !pTG->TmpSettings.szResponseBuf);

    w = TMPSTRINGBUFSIZE;
    pTG->TmpSettings.hglb  = (ULONG_PTR) MemAlloc(TMPSTRINGBUFSIZE);

    if (!pTG->TmpSettings.hglb) 
        goto failure;

    lpv = (LPVOID) (pTG->TmpSettings.hglb);
    lpstr=(LPSTR)lpv;
    if (!lpstr) 
    {
        MemFree( (PVOID) pTG->TmpSettings.hglb); 
        pTG->TmpSettings.hglb=0; 
        goto failure;
    }
    pTG->TmpSettings.lpbBuf = (LPBYTE)lpstr;

    _fmemset(lpstr, 0, TMPSTRINGBUFSIZE);

    pTG->TmpSettings.szReset             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szSetup             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szExit              = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szPreDial           = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szPreAnswer         = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szIDCmd             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szID                = lpstr; lpstr+=MAXIDSIZE;
    pTG->TmpSettings.szResponseBuf       = lpstr; lpstr+=RESPONSEBUFSIZE;
    pTG->TmpSettings.szSmallTemp1        = lpstr; lpstr+=SMALLTEMPSIZE;
    pTG->TmpSettings.szSmallTemp2        = lpstr; lpstr+=SMALLTEMPSIZE;

    pTG->TmpSettings.dwGot=0;

    if ( ((LPSTR)lpv+TMPSTRINGBUFSIZE) < lpstr)
    {
        BG_CHK(FALSE); goto failure;
    }

    return TRUE;

failure:

    DebugPrintEx(DEBUG_ERR,"MyAlloc/MyLock failed!");
    BG_CHK(FALSE);
    return FALSE;
}

void imodem_free_tmp_strings(PThrdGlbl pTG)
{
    if (pTG->TmpSettings.hglb)
    {
        MemFree( (PVOID) pTG->TmpSettings.hglb);
    }
    _fmemset(&pTG->TmpSettings, 0, sizeof(pTG->TmpSettings));
}

void imodem_clear_tmp_settings(PThrdGlbl pTG)
{
    BG_CHK(pTG->TmpSettings.lpMdmCaps);
    _fmemset(pTG->TmpSettings.lpMdmCaps, 0, sizeof(MODEMCAPS));
    _fmemset(pTG->TmpSettings.lpMdmExtCaps, 0, sizeof(MODEMEXTCAPS));
    pTG->TmpSettings.dwGot=0;
    pTG->TmpSettings.uDontPurge=0;
    pTG->TmpSettings.dwSerialSpeed=0;
    pTG->TmpSettings.dwFlags=0;
    _fmemset(pTG->TmpSettings.lpbBuf, 0, TMPSTRINGBUFSIZE);
}

BOOL 
imodem_list_get_str
(
    PThrdGlbl pTG,
    ULONG_PTR  KeyList[10],
    LPSTR     lpszName,
    LPSTR     lpszCmdBuf,
    UINT      cbMax,
    BOOL      fCmd
)
{
    int       i;
    int       Num=0;
    BOOL      bRet=0;


    for (i=0; i<10; i++) 
    {
        if (KeyList[i] == 0) 
        {
            Num = i-1;
            break;
        }
    }

    for (i=Num; i>=0; i--)  
    {
        if ( bRet = imodem_get_str(pTG, KeyList[i], lpszName,  lpszCmdBuf, cbMax,  fCmd) ) 
        {
            return bRet;
        }
    }
   
    return bRet;
}

BOOL imodem_get_str
(
    PThrdGlbl pTG, 
    ULONG_PTR dwKey, 
    LPSTR lpszName, 
    LPSTR lpszCmdBuf, 
    UINT cbMax,
    BOOL fCmd
)
{
    UINT uLen2;
    char *pc = "bogus";

    BG_CHK(cbMax>1);

    *lpszCmdBuf=0;

    uLen2 = ProfileGetString(dwKey, lpszName,pc, lpszCmdBuf, cbMax-1);
    if (uLen2)
    {
        if (!_fstrcmp(lpszCmdBuf, pc))
        {
            *lpszCmdBuf=0; return FALSE;
        }
        if (fCmd)
            EndWithCR(lpszCmdBuf, (USHORT)uLen2);
    }
    return TRUE;
}

BOOL iModemCopyOEMInfo(PThrdGlbl pTG)
{

   return ProfileCopyTree(  DEF_BASEKEY, 
                            pTG->FComModem.rgchKey, 
                            OEM_BASEKEY,
                            pTG->lpszUnimodemFaxKey);

}



#define MASKOFFV17              0x03

void SmashCapsAccordingToSettings(PThrdGlbl pTG)
{
    // INI file has already been read.

    DEBUG_FUNCTION_NAME(("SmashCapsAccordingToSettings"));
    // If !fV17Enable then smash the V17 bits of the Capabilities
    if(!pTG->Inst.ProtParams.fEnableV17Send) 
    {
        DebugPrintEx(DEBUG_WRN,"Masking off V.17 send capabilities");
        pTG->FComModem.CurrMdmCaps.uSendSpeeds &= MASKOFFV17;
    }

    if(!pTG->Inst.ProtParams.fEnableV17Recv) 
    {
        DebugPrintEx(DEBUG_WRN,"Masking off V.17 receive capabilities");
        pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= MASKOFFV17;
    }

    //
    // commented out RSL. We run at 19200. Nowhere in awmodem.inf have I seen FixSerialSpeed clause.
    //

    DebugPrintEx(   DEBUG_MSG, 
                    "uSendSpeeds=%x uRecvSpeeds=%x",
                    pTG->FComModem.CurrMdmCaps.uSendSpeeds,  
                    pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

}

int
SearchNewInfFile
(
   PThrdGlbl     pTG,
   char         *Key1,
   char         *Key2,
   BOOL          fRead
)
{

   char      szInfSection[] = "SecondKey=";
   DWORD     lenNewInf;
   int       RetCode = FALSE;
   char      Buffer[400];     // to hold lpToken=lpValue string
   char     *lpCurrent;
   char     *lpStartSection;
   char     *lpTmp;
   char     *lpToken;
   char     *lpValue;


   ToCaps(Key1);

   if (Key2) 
   {
      ToCaps(Key2);
   }

   pTG->AnswerCommandNum = 0;

   if ( ( lenNewInf = strlen(szAdaptiveInf) ) == 0 )  
   {
      return FALSE;
   }
   

   //
   // Loop thru all segments.
   // Each segment starts with InfPath=
   //

   lpCurrent = szAdaptiveInf;

   do 
   {
      // find InfPath
      lpStartSection = strstr (lpCurrent, szResponsesKeyName);
      if (! lpStartSection) 
      {
         goto exit;
      }

      lpTmp = strchr (lpStartSection, '\r' );
      if (!lpTmp) 
      {
         goto exit;
      }

      // compare Key1
      if ( strlen(Key1) != (lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) 
      {
          lpCurrent = lpTmp;
          continue;
      }

      if ( memcmp (lpStartSection+strlen(szResponsesKeyName),
                   Key1,
                   (ULONG)(lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) != 0 ) 
      {
         lpCurrent = lpTmp;
         continue;
      }

      // find InfSection

      lpCurrent = lpTmp;

      if (Key2) 
      {
           lpStartSection = strstr (lpCurrent, szInfSection);
           if (! lpStartSection) 
           {
              goto exit;
           }
         
           lpTmp = strchr (lpStartSection, '\r' );
           if (!lpTmp) 
           {
              goto exit;
           }

          // compare Key2

          if ( strlen(Key2) != (lpTmp - lpStartSection - strlen(szInfSection) ) ) 
          {
              lpCurrent = lpTmp;
              continue;
          }
       
          if ( memcmp (lpStartSection+strlen(szInfSection),
                       Key2,
                       (ULONG)(lpTmp - lpStartSection - strlen(szInfSection)) ) != 0 ) 
          {
             lpCurrent = lpTmp;
             continue;
          }

      lpCurrent = lpTmp;

      }

      //
      // both keys matched. Go get settings and return
      //
      
      do 
      {
         lpCurrent = strchr (lpCurrent, '\r' );
         if (!lpCurrent) 
         {
            goto exit;
         }

         lpCurrent += 2;


         // find next setting inside the matching section
         lpToken = lpCurrent;

         lpCurrent = strchr (lpCurrent, '=' );
         if (!lpCurrent) 
         {
            goto exit;
         }

         lpTmp = strchr (lpToken, '\r' );
         if (!lpTmp) 
         {
            goto exit;
         }

         if (lpCurrent > lpTmp) 
         {
            // empty string
            lpCurrent = lpTmp;
            continue;
         }


         lpValue = ++lpCurrent;

         lpTmp = strchr (lpValue, '\r' );
         if (!lpTmp) 
         {
            goto exit;
         }

         // we parsed the string. Now get it to the Buffer

         if (lpTmp - lpToken > sizeof (Buffer) ) 
         {
            goto exit;
         }

         memcpy(Buffer, lpToken, (ULONG)(lpTmp - lpToken));

         Buffer[lpValue -lpToken - 1] = 0;
         Buffer[lpTmp - lpToken] = 0;
         
         lpValue = &Buffer[lpValue - lpToken];
         lpToken = Buffer;

         pTG->fAdaptiveRecordFound = 1;


         if ( my_strcmp(lpToken, szAdaptiveAnswerEnable) ) 
         {
            pTG->AdaptiveAnswerEnable = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szAdaptiveRecordUnique) ) 
         {
            pTG->fAdaptiveRecordUnique = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szAdaptiveCodeId) ) 
         {
            pTG->AdaptiveCodeId = atoi (lpValue);
            if ( ! fRead ) 
            {
               goto exit;
            }
         }
         else if ( my_strcmp(lpToken, szFaxClass) ) 
         {
            ;
         }
         else if ( my_strcmp(lpToken, szHardwareFlowControl) ) 
         {
            pTG->fEnableHardwareFlowControl = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szSerialSpeedInit) ) 
         {
            pTG->SerialSpeedInit = (USHORT)atoi (lpValue);
            pTG->SerialSpeedInitSet = 1;
         }
         else if ( my_strcmp(lpToken, szResetCommand) ) 
         {
            sprintf ( pTG->TmpSettings.szReset, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
         }
         else if ( my_strcmp(lpToken, szSetupCommand) ) 
         {
            sprintf ( pTG->TmpSettings.szSetup, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Setup;
         }
         else if ( my_strcmp(lpToken, szAnswerCommand) ) 
         {
            if (pTG->AnswerCommandNum >= MAX_ANSWER_COMMANDS) 
            {
               goto exit;
            }
    
            if (NULL != (pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpValue) + 1))) 
            {
                sprintf ( pTG->AnswerCommand[pTG->AnswerCommandNum], "%s", lpValue);
                pTG->AnswerCommandNum++;
            }
            else 
            {
                goto bad_exit;
            }            
         }    
         else if ( my_strcmp(lpToken, szModemResponseFaxDetect) ) 
         {
            if (NULL != (pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->ModemResponseFaxDetect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseDataDetect) ) 
         {
            if (NULL != (pTG->ModemResponseDataDetect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->ModemResponseDataDetect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szSerialSpeedFaxDetect) ) 
         {
            pTG->SerialSpeedFaxDetect = (USHORT)atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szSerialSpeedDataDetect) ) 
         {
            pTG->SerialSpeedDataDetect = (USHORT)atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szHostCommandFaxDetect) ) 
         {
            if (NULL != (pTG->HostCommandFaxDetect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->HostCommandFaxDetect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szHostCommandDataDetect) ) 
         {
            if (NULL != (pTG->HostCommandDataDetect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->HostCommandDataDetect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseFaxConnect) ) 
         {
            if (NULL != (pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->ModemResponseFaxConnect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseDataConnect) ) 
         {
            if (NULL != (pTG->ModemResponseDataConnect = MemAlloc( strlen(lpValue) + 1)))
                sprintf ( pTG->ModemResponseDataConnect, "%s", lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szResponsesKeyName2) ) 
         {
            RetCode = TRUE;
            goto exit;
         }

      } 
      while ( 1 );    // section loop
   } 
   while ( 1 );       // file loop
   return (FALSE);

bad_exit:
   CleanModemInfStrings (pTG);
exit:
   return (RetCode);

}


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       )

{
   DWORD    i;

   for (i=0; i<pTG->AnswerCommandNum; i++) {
      if (pTG->AnswerCommand[i]) {
         MemFree( pTG->AnswerCommand[i]);
         pTG->AnswerCommand[i] = NULL;
      }
   }

   pTG->AnswerCommandNum = 0;

   if (pTG->ModemResponseFaxDetect) {
      MemFree( pTG->ModemResponseFaxDetect );
      pTG->ModemResponseFaxDetect = NULL;
   }

   if (pTG->ModemResponseDataDetect) {
      MemFree (pTG->ModemResponseDataDetect);
      pTG->ModemResponseDataDetect = NULL;
   }


   if (pTG->HostCommandFaxDetect) {
      MemFree( pTG->HostCommandFaxDetect);
      pTG->HostCommandFaxDetect = NULL;
   }

   if (pTG->HostCommandDataDetect) {
      MemFree( pTG->HostCommandDataDetect);
      pTG->HostCommandDataDetect = NULL;
   }


   if (pTG->ModemResponseFaxConnect) {
      MemFree( pTG->ModemResponseFaxConnect);
      pTG->ModemResponseFaxConnect = NULL;
   }

   if (pTG->ModemResponseDataConnect) {
      MemFree(pTG->ModemResponseDataConnect);
      pTG->ModemResponseDataConnect = NULL;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\filter.c ===
/**************************************************************************
 Name     :     FILTER.C
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"


#include "fdebug.h"
#include "fcomapi.h"
#include "fcomint.h"



#include "glbproto.h"


#define         FILEID                  FILEID_FILTER

#ifdef DEBUG
#       define ST_FIL(x)                if(ZONE_FIL) { x; }
#else
#       define ST_FIL(x)                { }
#endif


UWORD StuffZeroDLE(PThrdGlbl pTG, LPBYTE lpbIn, UWORD cbIn, LPBYTE lpbOut, UWORD cbOutSize, LPUWORD lpcbDone);

/**--------------------------Locals-----------------------------------**/




#define FILTERBUFSIZE  (WRITEQUANTUM * 2)



void  FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin)
{
        pTG->Filter.cbLineMin = cbLineMin;
        pTG->Filter.cbLineCount = 0;
}


void  FComOutFilterInit(PThrdGlbl pTG)
{
        // UWORD uwJunk;

        BG_CHK(pTG->Filter.lpbFilterBuf==0);

        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;
        pTG->Filter.bLastOutByte = 0xFF;

        pTG->Filter.lpbFilterBuf = pTG->bStaticFilterBuf;
}

void  FComOutFilterClose(PThrdGlbl pTG)
{
        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;

        if(!pTG->Filter.lpbFilterBuf)
        {
            DEBUG_FUNCTION_NAME(("FComOutFilterClose"));
            DebugPrintEx(DEBUG_WRN,"called when not open");
            return;
        }

        pTG->Filter.lpbFilterBuf = 0;
}

void  FComInFilterInit(PThrdGlbl pTG)
{
        pTG->Filter.bPrevIn = 0;
        pTG->Filter.fGotDLEETX = 0;
        pTG->Filter.cbPost = 0;
}




/***************************************************************************
        Name      :     UWORD FComFilterWrite(LPB lpb, UWORD cb)
        Purpose   :     Filters bytes for DLE and ZERO stuffing and writes them out.
                                Returns when bytes are in the Comm ISR buffer.
                                DLE stuffing is always on. ZERO stuffing is usually on.
        Parameters:     lpb == data
                                cb == size of pb[]
        Returns   :     cb on success, 0 on failure

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

UWORD  FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags)
{
    UWORD   cbIn, cbOut, cbDone;
    LPB             lpbIn;

    DEBUG_FUNCTION_NAME(("FComFilterWrite"));

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cb=%d lpbFilterBuf=0x%08lx",
                    lpb, 
                    cb, 
                    pTG->Filter.lpbFilterBuf);
    ST_FIL(D_FComPrint(pTG, pTG->Comm.nCid));
    BG_CHK(pTG->Filter.lpbFilterBuf);

    BG_CHK(flags==FILTER_DLEONLY || flags==FILTER_DLEZERO);
    BG_CHK(!(flags==FILTER_DLEONLY && pTG->Filter.cbLineMin));

    for(lpbIn=lpb, cbIn=cb; cbIn>0; lpbIn += cbDone, cbIn -= cbDone)
    {
        BG_CHK(cbIn);

        cbOut = StuffZeroDLE(pTG, lpbIn, cbIn, pTG->Filter.lpbFilterBuf,
                                  (UWORD)FILTERBUFSIZE, (LPUWORD)&cbDone);
        BG_CHK(cbDone && cbOut);        // need to make progress
        if(FComDirectWrite(pTG, pTG->Filter.lpbFilterBuf, cbOut) != cbOut)
        {
            DebugPrintEx(DEBUG_ERR,"exit Timeout");
            return 0;
        }
    }

    // Done....
    DebugPrintEx(DEBUG_MSG,"Exit");
    return cb;
}


/***************************************************************************
 Purpose  :     Copy Input buffer to output, stuffing DLEs and Zeros
                        as specified by fStuffZERO, and cbLineMin. (DLE stuffing
                        is always on).
 Comment  :      This is both debugged and fast. Don't mess around!

;;              Registers are used here as follows
;;
;;      DF = cleared (forward)
;;      AH = previous byte
;;      AL = current byte
;;      CX = byte count of current image line -- initially Filter.cbLineCount
;;      DX = bytes left in input  -- initially [cbIn]
;;      BX = Space left in output -- initially [cbOut]
;;      ES:DI = destination             -- initially [lpbOut]
;;      DS:SI = source                  -- initially [lpbIn]
;;
;;              Since ES & DS are both used, we use the stack frame too
;;              We need to restore the DF flag and the seg regs. can trash
;;              any others.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#define         DLE             0x10
#define         SUB             0x1a
#define         EOL             0x80
#define         EffEff          0xFF
#define         ELEVEN_ZEROS    0xF07F

UWORD StuffZeroDLE
(
    PThrdGlbl pTG, 
    LPBYTE lpbIn, 
    UWORD cbIn, 
    LPBYTE lpbOut,
    UWORD cbOutSize, 
    LPUWORD lpcbDone
)
{
    UWORD   LineMin;        // copy of Filter.cbLineMin. Need it on stack
    UWORD   cbOutLeft;

   BYTE CurByte;
   BYTE PrevByte = pTG->Filter.bLastOutByte;
   UWORD CurLineCount = pTG->Filter.cbLineCount;
   LPBYTE SrcEnd = lpbIn + cbIn;
   LPBYTE DstEnd = lpbOut + cbOutSize - 1;   //Subtract 1 in case write 2 bytes at once
   LPBYTE CurrentSrc = lpbIn;
   LPBYTE CurrentDst = lpbOut;
   UWORD NumZeros;

    DEBUG_FUNCTION_NAME(_T("StuffZeroDLE"));

    DebugPrintEx(   DEBUG_MSG,
                    "lpbIn=0x%08lx cbIn=%d lpbOut=0x%08lx cbOutSize=%d",
                    lpbIn, 
                    cbIn, 
                    lpbOut, 
                    cbOutSize);

    DebugPrintEx(   DEBUG_MSG,
                    "lpcbDone=0x%08lx cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x",
                    lpcbDone, 
                    pTG->Filter.cbLineMin, 
                    pTG->Filter.cbLineCount, 
                    pTG->Filter.bLastOutByte);

    // OK. Setup stack frame
    LineMin = pTG->Filter.cbLineMin;

    while ((CurrentSrc < SrcEnd) && (CurrentDst < DstEnd)) 
    {
       CurByte = *CurrentSrc++;
       if (CurByte == DLE) 
       {
          *CurrentDst++ = CurByte;
          CurLineCount++;
       }
       if ((CurByte == EOL) && ((PrevByte & 0xF0) == 0)) 
       {
          if ((CurLineCount+1) < LineMin) 
          {
             NumZeros = (LineMin - CurLineCount) - 1;
             if (NumZeros <= (DstEnd - CurrentDst))        // DstEnd-CurrentDst is 1 less than bytes left, leave 1 byte for end of line, hence <=
             {
                for (;NumZeros > 0;NumZeros--)
                   *CurrentDst++ = 0;
             }
             else 
             {
                CurrentSrc--;       //Unget the end of line for count or bytes written
                break;
             }
          }
          CurLineCount = (WORD)-1;
       }
       *CurrentDst++ = CurByte;
       PrevByte = CurByte;
       CurLineCount++;
    }



   pTG->Filter.cbLineCount = CurLineCount;
   pTG->Filter.bLastOutByte = PrevByte;
   *lpcbDone = (UWORD)(cbIn - (SrcEnd - CurrentSrc));
   cbOutLeft = (UWORD)((DstEnd - CurrentDst) + 1);

    DebugPrintEx(   DEBUG_MSG, 
                    "exit: *lpcbDone=%d cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x",
                    *lpcbDone, 
                    pTG->Filter.cbLineMin, 
                    pTG->Filter.cbLineCount, 
                    pTG->Filter.bLastOutByte);

    DebugPrintEx(   DEBUG_MSG,
                    "exit: cbOutSize=%d cbOutLeft=%d uwRet=%d",
                    cbOutSize, 
                    cbOutLeft, 
                    (cbOutSize-cbOutLeft));

    return (cbOutSize - cbOutLeft);
}

// Used to use NOCARRIER_CRLF. However Elliot bug#3619: Ger TE3801 cannot
// receive in Class1 mode -- this
// modem sends us NO CARRIER\n (missing \r), so we look for
// NO CARRIER[\r\n]*..
// CBSZ cbszNOCARRIER_CRLF      = "NO CARRIER\r\n";
extern CBSZ cbszNOCARRIER;
CBSZ cbszOK_CRLF                = "OK\r\n";
#define NCsize          (sizeof("NO CARRIER")-1)
#define OKsize          (sizeof(cbszOK_CRLF)-1)

#define cbPost          pTG->Filter.cbPost
#define rgbPost         pTG->Filter.rgbPost
#define fGotDLEETX      pTG->Filter.fGotDLEETX
#define bPrevIn         pTG->Filter.bPrevIn

// void WINAPI OutputDebugStr(LPSTR);

#define PortcbSkip   cbSkip
#define PortbPrevIn  bPrevIn

UWORD FComStripBuf
(
    PThrdGlbl pTG, 
    LPB lpbOut, 
    LPB lpbIn, 
    UWORD cb, 
    BOOL fClass2, 
    LPSWORD lpswEOF
)
{
    LPB     lpbOutStart, lpbLim;
    UWORD   cbLeft;
    UWORD   cbSkip;
    UWORD   i;
    LPBYTE CurrentSrc;

    DEBUG_FUNCTION_NAME(_T("FComStripBuf"));

    cbLeft = cb;
    lpbOutStart = lpbOut;
    lpbLim = lpbIn + cb;

    if(fGotDLEETX)
    {
        goto MatchPost;
    }

    for( ;lpbIn<lpbLim; )
    {
        if(bPrevIn == DLE)
        {
            BG_CHK(lpbOut < lpbIn);         // at least 1 behind at this point
            switch(*lpbIn++)
            {
                case DLE:       *lpbOut++ = DLE;
                                break;                          // insert single DLE
                case SUB:       *lpbOut++ = DLE;
                                *lpbOut++ = DLE;
                                break;                          // insert _two_ DLEs!
                case EffEff: // treat DLE-0xFF same as DLE-ETX. Intel gives us this
                case ETX:       goto gotDLEETX;
                // default:     break;                          // delete two
            }
            bPrevIn = 0;
        }
        else
        {
            BG_CHK(lpbLim-lpbIn >= 1);

            for (CurrentSrc = lpbIn;  (CurrentSrc < lpbLim) && (*CurrentSrc != DLE); CurrentSrc++);

            if (CurrentSrc != lpbLim) 
            {
               PortbPrevIn = DLE;
            }
            PortcbSkip = (UWORD)(CurrentSrc - lpbIn);

            _fmemcpy(lpbOut, lpbIn, cbSkip);
            lpbOut += cbSkip;
            lpbIn += cbSkip+1;
        }
    }
    return (UWORD)(lpbOut-lpbOutStart);

gotDLEETX:
    // lpbIn now points to character *after* ETX
    // neither DLE nor ETX have been copied to output

    // return everything upto the last char before DLE
    // and *lpswEOF == TRUE iff the entirety of what follows
    // the DLE-ETX consists of (CR|LF)*("NO CARRIER")(CR|LF)*
    // *or* (CR|LF)*("OK")(CR|LF)*
    // else return error

    if(fClass2)
    {
        *lpswEOF = -1;  // -1==Class2 eof
        goto done;
    }

    fGotDLEETX = TRUE;
    cbPost = 0;

MatchPost:
    cbLeft = min((USHORT)(lpbLim-lpbIn), (USHORT)(POSTBUFSIZE-cbPost));
    _fmemcpy(rgbPost+cbPost, lpbIn, cbLeft);
    cbPost += cbLeft;

    DebugPrintEx(DEBUG_MSG,"GotDLEETX: cbPost=%d cbLeft=%d",cbPost,cbLeft);
    // // TRACE(("<<%s>>\r\n", (LPSTR)(lpbIn)));
    // D_HexPrint(lpbIn, cbLeft);

    // skip CR LFs. Remember to restart from beginning of the post buffer
    for(i=0; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++);

    if(i >= cbPost)
        goto done;

    if(rgbPost[i] == 'N')
    {
        if(cbPost-i < NCsize)
        {
            goto done;
        }
        else if(_fmemcmp(rgbPost+i, cbszNOCARRIER, NCsize)==0)
        {
            i += NCsize;
            goto eof;
        }
        else
        {
            goto error;
        }
    }
    else if(rgbPost[i] == 'O')
    {
        if(cbPost-i < OKsize)
        {
            goto done;
        }
        else if(_fmemcmp(rgbPost+i, cbszOK_CRLF, OKsize)==0)
        {
            i += OKsize;
            goto eof;
        }
        else
        {
            goto error;
        }
    }
    else
    {
        goto error;
    }

    BG_CHK(FALSE);
eof:
    // skip any trailing CR/LFs
    for( ; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++)
            ;
    if(i == cbPost)
    {
        *lpswEOF = 1;
        goto done;
    }
    // else drop thru to error

error:
    *lpswEOF = -1;
    // goto done;
    fGotDLEETX = 0;         // reset this or we get 'stuck' in this state!

done:
    DebugPrintEx(   DEBUG_MSG,
                    "GotDLEETX exit: swEOF=%d uRet=%d", 
                    *lpswEOF, 
                    lpbOut-lpbOutStart);

    return (UWORD)(lpbOut-lpbOutStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\ncuparms.c ===
/***************************************************************************
 Name     :     NCUPARMS.C
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM


#include "prep.h"

#include "modemint.h"
#include "fcomint.h"
#include "fdebug.h"


///RSL
#include "glbproto.h"


#define FILEID                          FILEID_NCUPARMS



void iNCUParamsReset(PThrdGlbl pTG)
{
        _fmemset(&(pTG->NCUParams), 0, sizeof(NCUPARAMS));

        pTG->NCUParams.uSize = sizeof(pTG->NCUParams);

        // These are used to set S regs etc.
        // -1 means leave modem at default
        pTG->NCUParams.DialtoneTimeout = -1;
        pTG->NCUParams.DialPauseTime   = pTG->NCUParams.FlashTime         = -1;
        pTG->NCUParams.DialBlind     = -1;
        pTG->NCUParams.SpeakerVolume   = pTG->NCUParams.SpeakerControl= -1;
        pTG->NCUParams.SpeakerRing     = -1;

        // should be used in answer
        pTG->NCUParams.RingsBeforeAnswer = 0;
        // should be used in Dial
        pTG->NCUParams.AnswerTimeout = 60;
        // used in Dial
        pTG->NCUParams.chDialModifier  = 'T';
        pTG->fNCUParamsChanged =FALSE; // to indicate the we need to reset params
}





void FComInitGlobals(PThrdGlbl pTG)
{
        _fmemset(&pTG->FComStatus, 0, sizeof(FCOM_STATUS));
        _fmemset(&pTG->FComModem, 0, sizeof(FCOM_MODEM));
        pTG->fNCUAbort = 0;
        _fmemset(&pTG->Comm, 0, sizeof(pTG->Comm));
        // +++ fComInit = 0;
}












BOOL   NCUSetParams(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams)
{
        BG_CHK(lpNCUParams);
        // BG_CHK(DDI.fLineInUse == 1);
        // (MyDebugPrint(pTG, "In NCUSetParams fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        // BG_CHK(FComStatus.fModemInit);

        // Copy params into our local NCUparams struct
        pTG->NCUParams = *lpNCUParams;

/*** all will be set on next ReInit. Since all have to *****************
         do with dial that's soon enough ***********************************
        return
        iModemSetNCUParams( pTG->NCUParams.DialPauseTime, pTG->NCUParams.SpeakerControl,
                                                pTG->NCUParams.SpeakerVolume, pTG->NCUParams.DialBlind,
                                                pTG->NCUParams.SpeakerRing);
************************************************************************/

        // ignoring DialtoneTimeout and AnswerTimeout because we have
        //              problems with S7 and answering correctly (no answer vs voice etc)
        // also Pulse/Tone I think is being used correctly in Dial (C2 & C1)

        pTG->fNCUParamsChanged =TRUE; // to indicate the we need to reset params
                                                         // next time we call/answer...
// To-do
        // Use RingsBeforeAnswer in Class2Answer and Modem answer
        // and we have to set RingAloud--how?

        return TRUE;
}













BOOL   ModemGetCaps(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpMdmCaps)
{
        BG_CHK(lpMdmCaps);
        // BG_CHK(DDI.fModemOpen == 1);
        // (MyDebugPrint(pTG, "In ModemGetCaps fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        BG_CHK(pTG->FComStatus.fModemInit);

        *lpMdmCaps = pTG->FComModem.CurrMdmCaps;
        return TRUE;
}













void   NCUAbort(PThrdGlbl pTG, USHORT uLine, BOOL fEnable)
{
        // BG_CHK(DDI.fLineInUse == 1);
        // (MyDebugPrint(pTG, "In NCUAbort fModemInit=%d fModemOpen=%d fLineInUse=%d\r\n", FComStatus.fModemInit, DDI.fModemOpen, DDI.fLineInUse));
        BG_CHK(pTG->FComStatus.fModemInit || !fEnable);

        if(!fEnable)
                pTG->fNCUAbort = 0;
        else if(pTG->FComStatus.fInAnswer || pTG->FComStatus.fInDial)
                pTG->fNCUAbort = 2;
        else
                pTG->fNCUAbort = 1;
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\modemint.h ===
/***************************************************************************
 Name     :     MODEMINT.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 512 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 512+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/

#define MAXPHONESIZE    512
#define DIALBUFSIZE     MAXPHONESIZE + 10


/**---------------------- #define of other things ---------------------

        FAX_CLASSn      is used in Modem.FaxClass.

        CHECK_PATTERN is used in the Guard elements.
        ECM_FRAMESIZE in T30.C

---------------------- #define of other things ---------------------**/

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

// The following bunch of defines allow us to combine detection
// with pre-read settings (from unimodem, say).

#define fGOTCMD_Reset           (0x1)
#define fGOTCMD_Setup           (0x1<<1)
#define fGOTCMD_PreAnswer       (0x1<<2)
#define fGOTCMD_PreDial         (0x1<<3)
#define fGOTCMD_PreExit         (0x1<<4)

#define fGOTCMDS \
          fGOTCMD_Reset \
        | fGOTCMD_Setup \
        | fGOTCMD_PreAnswer \
        | fGOTCMD_PreDial \
        | fGOTCMD_PreExit

#define fGOTCAP_CLASSES         (0x1<<10)
#define fGOTCAP_SENDSPEEDS      (0x1<<11)
#define fGOTCAP_RECVSPEEDS      (0x1<<12)

#define fGOTCAPS \
          fGOTCAP_CLASSES \
        | fGOTCAP_SENDSPEEDS \
        | fGOTCAP_RECVSPEEDS

#define fGOTPARM_PORTSPEED      (0x1<<20)
#define fGOTPARM_IDCMD          (0x1<<21)
#define fGOTPARM_ID                     (0x1<<22)

#define fGOTPARMS \
          fGOTPARM_PORTSPEED \
        | fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTIDS \
          fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTFLAGS (0x1<<23)


// Following structure has stuff which should ideally go into
// MODEMCAPS, but we can't change that at this state (11/94).

extern BOOL                             fMegaHertzHack;



// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
// Looks like even 330 is too short for some modems..
// 550 is too short for Sharad's PP9600FXMT & things
// can get really screwed up if this times out, so use
// a nice large value
#define  iSyncModemDialog(pTG, s, l, w)                                                      \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w, (CBPSTR)(NULL))

// This version for dealing with possible NON-numeric responses as well...
#define  iSyncModemDialog2(pTG, s, l, w1, w2)                                                        \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

// mostly use MultiLine instead because we may get asynchronous
// RING responses at arbitrary times when on-hook
// Non-sync related local stuff. SIngle line, single try
// #define  iLocalModemDialog(s, l, w)  iiModemDialog(s, l, 950, FALSE, 1,      (CBPSTR)w, (CBPSTR)(NULL))

// Use these 3 *only* for GetCaps and ATI etc where we are initing
// (*not* re-initing, which can happen while RING is coming in & so need
// more than 1 try.

// temporarily chnage this to 2 tries & see if it slows things down
// too much.

/****************************

// used to get multi-line responses--single try
#define  iMultiLineModemDialog(s, l, w)                                                 \
                iiModemDialog(s, l, 900, TRUE, 2, (CBPSTR)w, (CBPSTR)(NULL))
// used to get multi-line responses--single try
#define  iMultiLineModemDialog2(s, l, w1, w2)                                                   \
                iiModemDialog(s, l, 900, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
// used for optional settings/commands. Single line, single try
#define  iOptionalModemDialog2(s, l, w1, w2)                                                    \
                iiModemDialog(s, l, 850, FALSE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

// used to get multi-line responses--2 tries. Used when RING noises
// can be coming in, and everywhere else off hook.
#define  i2xMultiLineModemDialog(s, l, w)                                                       \
                iiModemDialog(s, l, 950, TRUE, 2, (CBPSTR)w, (CBPSTR)(NULL))

// used to get multi-line responses
#define  i2xMultiLineModemDialog2(s, l, w1, w2)                                                 \
                iiModemDialog(s, l, 950, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

#define  i2xMultiLineModemDialog2Long(s, l, w1, w2)                                                     \
                iiModemDialog(s, l, 1900, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

************************************/

// These are used for offline things, so we make them all (a) multiline
// (b) long timeout (c) 2 tries and (d) make sure they all look for ERROR
// as a response, to speed things up

#define OfflineDialog2(pTG, s,l,w1,w2)        iiModemDialog(pTG, s, l, 5000, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define OfflineDialog3(pTG, s,l,w1,w2,w3) iiModemDialog(pTG, s, l, 5000, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))

// extern void TwiddleThumbs(ULONG ulTime);
// #define OfflineDialog2(s,l,w1,w2)     (TwiddleThumbs(100), iiModemDialog(s, l, 2000, TRUE, 2, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL)))


#define GOCLASS2_0      3
extern CBSZ cbszOK, cbszERROR;




/****************** begin prototypes from modem.c *****************/
SWORD iModemSync(PThrdGlbl pTG);
SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd);
UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
BOOL iModemGetCaps(PThrdGlbl pTG, LPMODEMCAPS lpMdmCaps,
                                        DWORD dwSpeed, LPSTR lpszReset, LPDWORD lpdwGot);
void TwiddleThumbs(ULONG ulTime);
BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed);
LPSTR my_fstrstr( LPSTR sz1, LPSTR sz2);
/***************** end of prototypes from modem.c *****************/


/****************** begin prototypes from identify.c *****************/
USHORT iModemGetCmdTab(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
        LPCMDTAB lpCmdTab, LPMODEMCAPS lpMdmCaps,  LPMODEMEXTCAPS lpMdmExtCaps,
        BOOL fInstall);
USHORT iModemInstall(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType, BOOL fDontPurge);
USHORT iModemFigureOutCmds(PThrdGlbl pTG, LPCMDTAB lpCmdTab);
USHORT iModemGetWriteCaps(PThrdGlbl pTG);
/***************** end of prototypes from identify.c *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\timeouts.c ===
/***************************************************************************
        Name      :     TIMEOUTS.C
        Comment   :     Various support functions

        Revision Log

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        001 12/18/91    arulm   Commenting it for the first time. This is the
                                                        "stable" DOS version from which the Windows code
                                                        will be derived. This file should not change
                                                        for Windows
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"

#include "fcomint.h"
#include "fdebug.h"

///RSL
#include "glbproto.h"


#define         faxT2log(m)             DEBUGMSG(ZONE_TIMEOUT, m)
#define         FILEID                  FILEID_TIMEOUTS

/***************************************************************************
        Name      :     Timers Class
        Purpose   :     Provide for Timeouts
                                        TO                 -- Timeout struct
                                        startTimeout -- creates a new timeout
***************************************************************************/








void   startTimeOut(PThrdGlbl pTG, LPTO lpto, ULONG ulTimeout)
{

        /////////////  ulTimeout <<= 1;         // give us a little more time during debugging

        BG_CHK(lpto);

        lpto->ulStart = GetTickCount();
        lpto->ulTimeout = ulTimeout;
        lpto->ulEnd = lpto->ulStart + ulTimeout;        // will wrap around as system
                                                                                                // time nears 4Gig ms

        return;
}






BOOL   checkTimeOut(PThrdGlbl pTG, LPTO lpto)
{
        // if it returns FALSE, caller must return FALSE immediately
        // (after cleaning up, as appropriate).

        // SWORD swRet;
        ULONG ulTime;

        BG_CHK(lpto);

        ulTime = GetTickCount();

        //// if(fVerbose3)
        ////    (MyDebugPrint(pTG, "CheckTO: 0x%08lx --> to=0x%08lx start=0x%08lx  end=0x%08lx CURR=0x%08lx\r\n",
        ////            lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));

        if(lpto->ulTimeout == 0)
        {
                goto out;
        }
        else if(lpto->ulEnd >= lpto->ulStart)
        {
                if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
                        return TRUE;
                else
                        goto out;
        }
        else    // ulEnd wrapped around!!
        {
                ERRMSG(("<<ERROR>> CheckTO WRAPPED!!: 0x%04x --> to=0x%08lx start=0x%08lx  end=0x%08lx time=0x%08lx\r\n",
                        lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));

                if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
                        return TRUE;
                else
                        goto out;
        }

out:
        faxT2log(("CheckTO--TIMEOUT!: 0x%04x --> to=0x%08lx start=0x%08lx  end=0x%08lx CURR=0x%08lx\r\n",
                        lpto, lpto->ulTimeout, lpto->ulStart, lpto->ulEnd, ulTime));
        return FALSE;
}










// this will return garbage values if
ULONG   leftTimeOut(PThrdGlbl pTG, LPTO lpto)
{
        ULONG ulTime;

        BG_CHK(lpto);
        ulTime = GetTickCount();

        if(lpto->ulTimeout == 0)
                return 0;
        else if(lpto->ulEnd >= lpto->ulStart)
        {
                if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
                        return (lpto->ulEnd - ulTime);
                else
                        return 0;
        }
        else
        {
                if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
                        return (lpto->ulEnd - ulTime);  // in unsigned arithmetic this
                                                                                        // works correctly even if End<Time
                else
                        return 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\awnsfapi.h ===
/***************************************************************************
 Name     :     AWNSFAPI.H
 Comment  :     Definitions of the AtWork AWBC (Basicaps) structure which is the
            decrypted/decooded/reformatted form of the At Work NSF and NSC
            Also the decrypted form of the At Work NSS
            Also defines the APIs for encoding/decoding AtWork NSF/NSC/NSS

     Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Created
***************************************************************************/

#ifndef _AWNSFAPI_H
#define _AWNSFAPI_H


/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#ifdef PORTABLE    /** -DPORTABLE on machines with flat 32-bit model **/
#ifdef STDCALL
#   define WINAPI       __stdcall
#   define EXPORTAWBC   __stdcall
#else
#       define WINAPI
#       define EXPORTAWBC
#endif
#       define FAR
#       define NEAR
#       define PASCAL
#   define CALLBACK
#       define __export
#       define _export
#       define max(a, b)        (((a) > (b)) ? (a) : (b))
        typedef short    BOOL;
#elif defined(WIN32) /** WIN32 **/
#       define __export  __declspec( dllexport )
#       define _export  __declspec( dllexport )
#       define EXPORTAWBC        WINAPI
#else /** 16bit Windows */
#       define FAR       _far
#       define NEAR              _near
#       define PASCAL    _pascal
#       define WINAPI    _far _pascal
#   define CALLBACK  _far _pascal
#       define EXPORTAWBC       _export WINAPI
        typedef int      BOOL;
#endif /** Portable, WIN32 or WIN16 **/

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;
typedef unsigned short  USHORT;
typedef BYTE FAR*               LPBYTE;
typedef WORD FAR*               LPWORD;


#include <fr.h>

#pragma pack(2)    /** ensure packing is portable, i.e. 2 or more **/





typedef enum {
        BC_NONE = 0,
    SEND_CAPS,      /** Used to derive an NSF to send **/
    RECV_CAPS,      /** Derived from a received NSF   **/
    SEND_PARAMS,    /** Used to derive an NSS to send **/
    RECV_PARAMS,    /** Derived from a received NSS   **/
    SEND_POLLREQ,   /** Used to derive a NSC to send  **/
    RECV_POLLREQ,    /** Derived from a receive NSC    **/

        SEND_ACK,
        RECV_ACK,
        SEND_DISCONNECT,
        RECV_DISCONNECT

} BCTYPE;

#define BCTYPE_FIRST    RECV_CAPS
#define BCTYPE_LAST     RECV_POLLREQ





#define MAXTOTALIDLEN           61
#define MAXNSCPOLLREQ           5

#ifndef NOCHALL
#       define POLL_CHALLENGE_LEN       10
#       define POLL_PASSWORD_LEN        20
#endif

#define MAXNSFFRAMESIZE         256     /* MAW NSx frames must be 255 bytes or less */
#define MAXFIRSTNSFSIZE         38  /* The first transmitted MAW NSx frame must
                                                                        be 38 bytes or less */
#define MAXNEXTNSFSIZE          70  /* subsequent transmitted MAW NSx frame must
                                                                        be 72 bytes or less */
#define MAXNSFFRAMES            (MAXNSCPOLLREQ+5)


typedef struct
{
        WORD PollType;          /* one of the POLLTYPE_ defines below */
        WORD fReturnControl;    /* T or F */
        WORD PassType;
        WORD wNameLen;
        BYTE bName[MAXTOTALIDLEN+3];    /* align on even boundary */

#ifdef NOCHALL
        WORD wPassLen;
        BYTE bPass[MAXTOTALIDLEN+3];    /* align on even boundary */
#else
        WORD wChallRespLen;
        BYTE bChallResp[max(POLL_PASSWORD_LEN, POLL_CHALLENGE_LEN)+2];
#endif
}
AWBCPOLLREQ, FAR* LPAWBCPOLLREQ;

typedef struct
{
  BCTYPE bctype;    /* must always be set. One of the enum values above    */
  WORD   wAWBCSize; /* size of this (fixed size) AWBC struct, must be set  */
  WORD   wAWBCVer;  /* if using this header file, set it to VER_AWFXPROT100*/
  WORD   wAWBCSig;  /* Clients must set to SIG_AWFXPROT in struct passed in
                        to the NSF encoding/decoding routines. In Structs
                        returned from these routines this will be 0         */

  BYTE  vMsgProtocol;  /* 00==Doesn't accept linearized msgs. vMSG_SNOW==
                           Current (WFW) version of linearizer. For NSS, ver
                           of linearized msg, if any, following the NSS-DCS */
  BYTE  fInwardRouting;/* 00==no inward routing                            */
  BYTE  fBinaryData;   /* accept binary files inside linearized msgs       */
  BYTE  vMsgCompress;  /* 00==none                                              */
  BYTE  fDontCache;    /* 1=NSF/DIS caps of this machine should _not_ be cached (see long note above)*/

  BYTE  DataLink;      /* Data-link protocols. 000==none                   */
  BYTE  DataSpeed;     /* Data modem modulations/speeds. 00000==none       */
  BYTE  vShortFlags;   /* 00==not supported                                */

  BYTE  OperatingSys;  /* OS_WIN16==16bit Windows(Win3.1, WFW etc)         */
                       /* OS_ARADOR==AtWork based OSs (IFAX etc)           */
                       /* OS_WIN32== WIN32 OSs (NT, WIN95)                      */
  BYTE  vSecurity;     /* 00==none vSECURE_SNOW==snowball security         */
  BYTE  vInteractive;  /* 00==No interactive protocol support              */

  BYTE  TextEncoding;  /* Text code. TEXTCODE_ASCII==ascii    */
  BYTE  TextIdLen;     /* Text ID length                                        */
  BYTE  Reserved1;         /* Pad to even boundary before array */

  BYTE  bTextId[MAXTOTALIDLEN+3];   /* zero-terminated                     */
  BYTE  bMachineId[MAXTOTALIDLEN+3];/* machine ID                          */

  BYTE  MachineIdLen;               /* length of machine id                */

  BYTE  vRamboVer;     /* Rambo: 00==not supported                         */
  BYTE  vAddrAttach;   /* 00==cannot accept address bk attachmnts          */
  BYTE  fAnyWidth;     /* page pixel widths don't have to be exactly T.4   */
  BYTE  HiEncoding;    /* one or more of the HENCODE_ #defines below       */
  BYTE  HiResolution;  /* one or more of the HRES_ #defines below          */
  BYTE  CutSheetSizes; /* one or more of the PSIZE_ #defines below         */
  BYTE  fOddCutSheet;  /* Cut-sheet sizes other than ones listed below     */
  BYTE  vMetaFile;     /* 00==metafiles not accepted                       */
  BYTE  vCoverAttach;  /* 00==no digital cover page renderer               */

  BYTE  fLowSpeedPoll;  /* SEP/PWD/NSC poll reqs accepted                  */
  BYTE  fHighSpeedPoll; /* PhaseC pollreqs accepted                        */
                        /* if both the above 00, poll reqs not accepted    */
  BYTE  fFilePolling;   /* Supports polling for arbitrary files            */
  BYTE  fPollByRecipAvail; /* Poll-by-Recipient msgs available             */
  BYTE  fPollByNameAvail;  /* Poll-by-MessageName msgs available           */

  BYTE  fExtCapsAvail;  /* Extended capabiities available                  */
  BYTE  fNoShortTurn;   /* NOT OK recving NSC-DTC immediately after EOM-MCF*/
  BYTE  vMsgRelay;      /* Msg relay ver. 0==no support                    */

  WORD  ExtCapsCRC;     /* CRC of machine's extended capabilities          */

  struct {
    BYTE    vMsgProtocol;  /* non-zero: linearized msg follows           */
                           /* vMSG_SNOW current linearized format        */
    BYTE    vInteractive;  /* non-zero: Interactive prot being invoked   */
  }
  NSS;

  WORD wNumPollReq;                                     /* number of poll reqs */
  AWBCPOLLREQ rgPollReq[MAXNSCPOLLREQ]; /* array of AWBCPOLLREQ structures */
}
AWBC, FAR* LPAWBC, NEAR* NPAWBC;


/** Appropriate values for some of the above fields **/

#define vMSG_SNOW       1       /* Snowball Linearizer version */
#define vMSG_IFAX100    2       /* IFAX linearizer version */
#define vSECURE_SNOW    1       /* vSecurity for Snowball (v1.00 of MAW)         */
#define OS_WIN16        0       /* OperatingSys for Win3.0, 3.1, WFW3.1, 3.11*/
#define OS_ARADOR       1       /* OperatingSys for Arador-based systems         */
#define OS_WIN32                2       /* OperatingsSys for WIN32 (NT, WIN95)       */
#define TEXTCODE_ASCII  0       /* TextEncoding for 7-bit ASCII                          */


#define SIG_AWFXPROT    0xYYYY
#define VER_AWFXPROT100 0x100



extern BOOL WINAPI IsAtWorkNSx(LPBYTE lpb, WORD wSize);



extern WORD _export WINAPI AWBCtoNSx(IFR ifr, LPAWBC lpawbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);



extern WORD _export WINAPI NSxtoAWBC(IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                                        LPAWBC lpawbcOut, WORD wAWBCSize);


extern void _export WINAPI MaskAWBC(LPAWBC lpawbc, WORD wSize);



#define AWERROR_OK                0
#define AWERROR_BCTYPE            1
#define AWERROR_SIG               2
#define AWERROR_NOSPACE           3
#define AWERROR_NOTAWFRAME        4
#define AWERROR_NULLFRAME         5
#define AWERROR_VERSION           6
#define AWERROR_INVALIDBC         7

#pragma pack()

#endif /** _AWNSFAPI_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\bgt30.h ===
/***************************************************************************
 Name     :	BGT30.C
 Comment  :	Implements the IFAX Comm API

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


/****************************************************
	// wParam==Comport
#	define IF_T30_INIT		(IF_USER + 0x301)

	// wParam==TRUE/FALSE	lParam==hProt
#	define IF_T30_ANSWER	(IF_USER + 0x302)

	// wParam==aPhone		lParam==hProt
#	define IF_T30_CALL		(IF_USER + 0x303)

	// wParam==On/off
#	define IF_T30_LISTEN	(IF_USER + 0x304)

	// wParam, lParam unused
	// #	define IF_T30_ABORT	(IF_USER + 0x305)
	// #define IF_T30_DATA		(IF_USER + 0x306)
******************************************************/

#ifdef TSK
#	define BGT30EXPORT	__export WINAPI
#	define BGT30WINAPI	WINAPI
#else
#	define BGT30EXPORT	
#	define BGT30WINAPI	
#endif
	
		void BGT30EXPORT T30Init(USHORT uComPort, USHORT uModemClass);
typedef void (BGT30WINAPI  *LPFN_T30INIT)(USHORT uComPort, USHORT uModemClass);
		void BGT30EXPORT T30DeInit(void);
typedef	void (BGT30WINAPI  *LPFN_T30DEINIT)(void);
		USHORT BGT30EXPORT T30Answer(BOOL fImmediate, USHORT uLine, USHORT uModem);
typedef USHORT (BGT30WINAPI  *LPFN_T30ANSWER)(BOOL fImmediate, USHORT uLine, USHORT uModem);
		UWORD BGT30EXPORT T30Call(ATOM aPhone, USHORT uLine, USHORT uModem);
typedef	UWORD (BGT30WINAPI  *LPFN_T30CALL)(ATOM aPhone, USHORT uLine, USHORT uModem);
		USHORT BGT30EXPORT T30Listen(USHORT uLevel, USHORT uLine);
typedef	USHORT (BGT30WINAPI  *LPFN_T30LISTEN)(USHORT uLevel, USHORT uLine);

#ifdef TSK
void BGT30EXPORT SetT30Callbacks(HWND, LPFN_T30INIT, LPFN_T30DEINIT,
						   LPFN_T30CALL, LPFN_T30ANSWER, LPFN_T30LISTEN);
#endif

#ifdef THREAD
void BGT30EXPORT T30WaitUntilBGExit(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\awnsfcor.h ===
/***************************************************************************
 Name     :	AWNSFCOR.H
 Comment  :	NSF related definitions that _must_ be kept the same.
			EVERYTHING in this file affects what is sent across the
			wire. For full compatibility with all versions of Microsoft
			At Work NSFs, _nothing_ in here should be changed.

			The NSF protocol can be extended by adding new groups
			and by appending fields at the end of existing groups.

			Interfaces, structures and constants that only affect one
			machine (i.e. not what is on the wire) should not be in
			this file


	Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 12/31/93 arulm Created this. Verified in matches Snowball.rc
***************************************************************************/

#ifndef _AWNSFCOR_H
#define _AWNSFCOR_H

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


/** Microsoft At Work NSF signature **/

#define SIG_USA            0xB5		/** defiend by CCITT 		**/
#define SIG_ATWORK1        0x00		/** 00--first (low) byte	**/
#define SIG_ATWORK2        0x76		/** 76--second (high) byte	**/


#define MAXNSCPOLLREQ			5

#ifndef NOCHALL
#	define POLL_CHALLENGE_LEN	10
#endif 


/** NSF Group Numbers. Cant have duplicates. Max 5 bits. **/

#define GROUPNUM_FIRST		1
#define GROUPNUM_STD		1
#define GROUPNUM_POLLCAPS	2
#define GROUPNUM_POLLREQ	3
#define GROUPNUM_IMAGE 		4
#define GROUPNUM_TEXTID		5
#define GROUPNUM_MACHINEID	6
#define GROUPNUM_NSS		7
#define GROUPNUM_LAST		7



#ifndef PORTABLE /* Microsoft C only */

#pragma pack(1)    /** MUST ensure packed structures here **/

// Note that all these structures have a fixed size (as defined here)
// in memory, but a variable size when encoded in the NSF on the wire
// During transmission, only the smallest non-zero prefix of each 
// capability group is sent. For example if the STD group is
// zero from the 7th byte onward, only 6 bytes are sent.
//
// Similarly strings that are variable length on the wire are fixed 
// length in the in-memory structures, for ease of manipulation

typedef struct
{
	WORD	GroupLength	:6;
	WORD	GroupNum	:5;
	WORD	Reserved	:5;
}
BCHDR, near* NPBCHDR, far* LPBCHDR;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCSTD | Standard Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCSTD).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_STD.

	@field BITFIELD | vMsgProtocol | Linearizer version. Set to 0 if linearized
			messages are not accepted. Set to vMSG_SNOW if using
			Snowball/WFW3.11 linearizer/delinearizer. Set to vMSG_IFAX if
			using IFAX release 1.00 linearizer/delinearizer.

	@field BITFIELD | fBinaryData | Set to 1 if binary files are accepted
			inside linearized messages. Otherwise set to 0. (Currently
			must set to 1 if vMsgProtocol is non-zero).

	@field BITFIELD | fInwardRouting | Currently set to 0
	@field BITFIELD | vSecurity		 | Set to vSECURE_SNOW if using Snowball/WFW3.11
			version of linearized message security

	@field BITFIELD | vMsgCompress	 | Currently set to 0
	@field BITFIELD | fDontCache	 | If this is set, the DIS & NSF capabilities
		   should not be cached, because they are not constant. This will
		   be set, for example, in machines that are part of a "hunt group"
		   i.e. a poll of fax possibly heterogenous machines connected to
		   multiple lines on a single inward-dial number. When a call comes
		   in any random available machine is assigned the call. If the
		   machines are heterogenous, then callers that cache capabilities
		   will run into trouble on subsequent calls to the same number.
		   The same might be the case for numbers shared by a (say) PC with a
		   modem running the At Work protocol and a ordinary G3 fax. When the
		   PC is powered up & running, At Work features are available. When the
		   PC is shutdown the G3 fax acts as a "backup". Etc..

	@field BITFIELD | OperatingSys	 | Set to OS_WIN16 if based on 16bit Windows
			(Win3.1 or earlier, WFW3.1, WFW3.11 etc).  OS_WIN32 if based on
			WIN32 API (NT and WIN95). OS_ARADOR if based on the AT Work
			device OSs. Values for non-Microsoft OSs TBD.
			Please contact Microsoft if you need this.

	@field BITFIELD | vShortFlags	 | Currently set to 0	
	@field BITFIELD | vInteractive	 | Currently set to 0
	@field BITFIELD | DataSpeed		 | Currently set to 0
	@field BITFIELD | DataLink		 | Currently set to 0

	@xref <t BC> 
********/

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_STD
	WORD	vMsgProtocol	:3;	// 00==Doesnt accept linearized msgs
								// vMSG_SNOW==Current (WFW) version of linearizer
	WORD	fBinaryData		:1;	// accept binary files inside linearized msgs
	WORD	fInwardRouting	:1;	// 00==no inward routing
//2bytes
	BYTE	vSecurity		:3;	// 00==none vSECURE_SNOW==snowball security
	BYTE	vMsgCompress	:2;	// 00==none
	BYTE	fDontCache		:1;	// 1=DIS/NSF caps should not be cached!!
	BYTE	Reserved		:2;
//3bytes
	BYTE	OperatingSys	:3;	// OS_WIN16==16bit Windows(Win3.1, WFW etc)
								// OS_ARADOR==AtWork based OSs (IFAX etc)
								// OS_WIN32== WIN32 OSs (NT, WIN95)
	BYTE	vShortFlags		:2;	// 00==not supported
	BYTE	vInteractive	:3;	// 00==No interactive protocol support
//4bytes
	BYTE	DataSpeed		:5;	//Data modem modulations/speeds. 00000==none
	BYTE	DataLink 		:3;	//Data-link protocols. 000==none
//5bytes
}
BCSTD, near* NPBCSTD, far* LPBCSTD;

typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// must be GROUPNUM_TEXTID
	WORD	TextEncoding:5;	// Text code. TEXTCODE_ASCII==ascii
//2bytes
	BYTE	bTextId[MAXTOTALIDLEN+2];	// zero-terminated
}
BCTEXTID, near* NPBCTEXTID, far* LPBCTEXTID;


typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// must be GROUPNUM_MACHINEID
	WORD	Reserved	:5;	
//2bytes
	BYTE	bMachineId[MAXTOTALIDLEN+2];	// machine ID
}
BCMACHINEID, near* NPBCMACHINEID, far* LPBCMACHINEID;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCIMAGE | Image Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCIMAGE).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_IMAGE.

	@field BITFIELD | fAnyWidth	| Currently set to 0.
	@field BITFIELD | vRamboVer	| At Work Resource-based rendering technology
			(a.k.a. Rambo) version number. Set to 0 if Rambo format is not
			supported. Set to vRAMBO_VER1 if using IFAX release 1.00 Rambo
			rasterizer.

	@field BITFIELD | vCoverAttach | Currently set to 0.
	@field BITFIELD | vAddrAttach  | Currently set to 0.
	@field BITFIELD | vMetaFile	   | Currently set to 0.
	@field BITFIELD | HiResolution | Currently set to 0.
	@field BITFIELD | HiEncoding   | Currently set to 0.	 
	@field BITFIELD | CutSheetSizes| Currently set to 0.
	@field BITFIELD | fOddCutSheet | Currently set to 0.

	@xref <t BC> 
********/

typedef struct
{
	WORD	GroupLength	:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum	:5;	// group number--must be GROUPNUM_IMAGE
	WORD	fAnyWidth	:1;	// page pixel widths dont have to be exactly T.4
	WORD	vRamboVer	:4;	// Rambo: 00==not supported
//2bytes

	BYTE	vCoverAttach:3;	// 00==no digital cover page renderer
	BYTE	vAddrAttach	:2;	// 00==cannot accept address bk attachmnts
	BYTE	vMetaFile	:2;	// 00==metafiles not accepted
	BYTE	Reserved1	:1;
//3bytes

	BYTE	HiResolution :4; // one or more of the HRES_ #defines below
	BYTE	HiEncoding	 :4; // one or more of the HENCODE_ #defines below
//4bytes

	BYTE	CutSheetSizes;	// one or more of the PSIZE_ #defines below
//5bytes

	BYTE	fOddCutSheet:1;	// Cut-sheet sizes other than ones listed below
							// are available. (To get list req. ext caps)
	BYTE	Reserved2	:7;
//6bytes
}
BCIMAGE, far* LPBCIMAGE, near* NPBCIMAGE;

/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCPOLLCAPS | Polling Capabilities Group

	@field BITFIELD | GroupLength | Must be set to sizeof(BCPOLLCAPS).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_POLLCAPS.

	@field BITFIELD | fLowSpeedPoll	 | Set to 1 if NSC poll requests are accepted,
			and there are poll-stored messages/files available for polling.

	@field BITFIELD | fHighSpeedPoll | Set to 1 if Phase-C poll requests are
			accepted, and there are poll-stored messages/files available
			for polling.

	@field BITFIELD | fPollByNameAvail  | Set to 1 if polling for documents by
			title and optional password is supported and there are some
			such poll-stored documents available.

	@field BITFIELD | fPollByRecipAvail	| Set to 1 if polling for contents of
			a registered user's Message folder is supported and active.

	@field BITFIELD | fFilePolling 	| Set to 1 if polling for arbitrary disk
			files by path name is supported.

	@field BITFIELD | fExtCapsAvail	| Set to 1 if extended capabalities are
			supported and there are some registered extended capabilities
			available for polling. If this is non-zero, the ExtCapsCRC field
			must also be set.

	@field BITFIELD | fNoShortTurn	| Set to 1 if polling is supported, but the
			poller is required to wait for the T2 (6 sec) timeout followed
			by NSF-DIS before sending NSC-DTC. If this is 0, Pollers are
			free to send an NSC-DTC immediately after EOM-MCF.

	@field BITFIELD | vMsgRelay	 | Currently set to 0.

	@field WORD | ExtCapsCRC | Set iff fExtCapsAvail is 1. This is a
			CCITT-CRC16 of the registered extended capabailities on the
			the machine.

	@xref <t BC> 
********/
					  
typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_POLLCAPS
	WORD	fLowSpeedPoll	:1;	// SEP/PWD/NSC poll reqs accepted
	WORD	fHighSpeedPoll	:1;	// PhaseC pollreqs accepted
								// if both the above 00, poll reqs not accepted
	WORD	fPollByNameAvail :1;// Poll-by-MessageName msgs available
	WORD	fPollByRecipAvail:1;// Poll-by-Recipient msgs available
	WORD	fFilePolling 	 :1;// Supports polling for arbitrary files
//2bytes

	BYTE	fExtCapsAvail	:1;	// Extended capabiities available
	BYTE	fNoShortTurn	:1;	// NOT OK recving NSC-DTC immediately after EOM-MCF
	BYTE	vMsgRelay		:3;	// Msg relay ver. 0==no support
	BYTE	Reserved		:3;
//3bytes

	WORD	ExtCapsCRC;			// CRC of machines extended capabilities
//5bytes
}
BCPOLLCAPS, far *LPBCPOLLCAPS, near* NPBCPOLLCAPS;


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCPOLLREQ | Poll Request stucture

	@field BITFIELD | GroupLength | Must be set to sizeof(BCPOLLREQ).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_POLLREQ.

	@field BITFIELD | fReturnControl | 1=return control when done 0=hangup when done
	@field BITFIELD | PollType		 | Poll type. See <t POLLTYPE> for details.
	@field BYTE		| b[]			 | Variable length name and (optionally) password.
			The exact contents and layout depends on the POLLTYPE as follows

		@flag POLLTYPE_NAMED_DOC | b[] contains a Poll Document Name. If there
			is no password, the Document Name is not null-terminated. If there
			is a password, the document name is null-terminated and followed
			by the "Poll Challenge Response" generated using the algorithm
			below.

		@flag POLLTYPE_BYRECIPNAME | b[] contains a Recipient Mailbox Address.
			If there is no password, the Mailbox Address is not null-terminated.
			If there is a password, the mailbox address is null-terminated and
			followed by the "Poll Challenge Response".

		@flag POLLTYPE_BYPATHNAME | b[] contains a file pathname. If there
			is no password, the pathname is not null-terminated. If there
			is a password, the pathname is null-terminated and followed
			by the "Poll Challenge Response".

		@flag POLLTYPE_EXTCAPS | If no password is supplied b[] is 0 length,
			otherwise b[0] is 0, and is followed by the "Poll Challenge
			Response".

		@flag POLLTYPE_DONE | b[0] is the poll error code. A code of 0 means
				success. If b[] is zero length, that is equivalent to success.

		@flag POLLTYPE_WAIT   | b[] must be 0 length
		@flag POLLTYPE_PHASEC | b[] must be 0 length

	@comm

	At Work Fax uses a Challenge-Response protocol for password
	verification during polling. The scheme used is as follows.

	On the POLLER'S side, bytes 3 to 3 + POLL_CHALLENGE_LEN of the actual
	encrypted bytes of the FIF of the last MS NSF received prior to polling is
	used as a challenge string. (This corresponds to the first
	POLL_CHALLENGE_LEN bytes of the FIF after skipping the USA & MS codes).
	If the received NSFs FIF had fewer than 3+POLL_CHALLENGE_LEN bytes then
	as many bytes as were received are used. These bytes are the "Challenge".
	
	This challenge string is encrypted using the actual Poll-Password as the
	key. The enctypted result is the "Challenge Response". This is what is
	actually sent on the wire. The actual poll password is not sent.
	
	On the POLLEE'S side password verification is done as follows. The
	relevant bytes of the last NSF sent are always saved as teh "Challenge".
	On receiving a poll-req, the requested poll document name is used to look
	up the expected password. Encrypt the saved "Challenge" the expected
	password to get the "Expected Challenge Response". Compare the "Expected
	Challenge Response" with the actual received "Challenge Response". Allow
	the poll request to proceed only if they are identical (and identical is
	length).
	
	Note: The Challenge, and the challenge-response may both contain embedded
	nuls. However the Poll Document-Name cannot contain embedded nuls.

	@xref <t BC> 
********/

#pragma warning (disable: 4200)

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_POLLREQ
	WORD	fReturnControl	:1;	// 1=return control when done 0=hangup when done
	WORD	PollType		:4;	// one of the POLLTYPE_ defines below
//2bytes
	BYTE	b[];		// var length name and (optionally) password
}
BCPOLLREQ, far *LPBCPOLLREQ, near* NPBCPOLLREQ;

#pragma warning (default: 4200)


/********
    @doc   EXTERNAL DATATYPES OEMNSF

	@types BCNSS | BC NSS struct

	@field BITFIELD | GroupLength | Must be set to sizeof(BCNSS).
	@field BITFIELD | GroupNum 	  | Must be set to GROUPNUM_NSS.

	@field BITFIELD | vMsgProtocol | Version of linearizer used to
			encode the version of the message that immediately follows.

	@field BITFIELD | vInteractive | Command to switch to the Microsoft
			At Work Interactive Protocol. Version of that protocol to use.

	@xref <t BC> 
********/			  

typedef struct
{
	WORD	GroupLength		:6;	// length of this group in bytes 00=grp invalid
	WORD	GroupNum		:5;	// must be GROUPNUM_NSS
	WORD	vMsgProtocol	:3;	// non-zero: linearized msg follows
								// vMSG_SNOW current linearized format
	WORD	Reserved1		:2;
// 2 bytes
	BYTE	vInteractive	:3;	// non-zero: Interactive prot being invoked
	BYTE	Reserved2		:5;
// 3 bytes
} 
BCNSS, far *LPBCNSS, near* NPBCNSS;

#pragma pack()    /** MUST ensure packed structures here **/

#endif /* !PORTABLE */



#define vMSG_SNOW       1	/* Snowball Linearizer version */
#define vMSG_IFAX100	2	/* IFAX linearizer version */
#define vSECURE_SNOW    1	/* vSecurity for Snowball (v1.00 of MAW)	 */
#define vRAMBO_VER1		1	/* Rambo ver on IFS66 */
#define OS_WIN16        0	/* OperatingSys for Win3.0, 3.1, WFW3.1, 3.11*/
#define OS_ARADOR       1	/* OperatingSys for Arador-based systems 	 */
#define	OS_WIN32		2	/* OperatingsSys for WIN32 (NT, WIN95)       */	
#define TEXTCODE_ASCII  0	/* TextEncoding for 7-bit ASCII				 */
#define vADDRBK_VER1    1   /* Address book attachments ver 1.00         */

/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI

    @type   VOID | POLLTYPE | PollType values

    @emem	POLLTYPE_WAIT		| Poll request being processed--wait 
	@emem	POLLTYPE_PHASEC		| Poll request was already sent in PhaseC 
	@emem	POLLTYPE_EXTCAPS	| Extended capabilities poll request
	@emem	POLLTYPE_NAMED_DOC	| Named document poll request
	@emem	POLLTYPE_BYRECIPNAME| Poll-by-Recip Mailbox Address
	@emem	POLLTYPE_BYPATHNAME	| Poll-by-File Pathname
	@emem	POLLTYPE_DONE		| poll request done or failed. Control being returned
********/

#define POLLTYPE_WAIT			0	
#define POLLTYPE_PHASEC			1	
#define POLLTYPE_EXTCAPS		2	
#define POLLTYPE_NAMED_DOC		3	
#define POLLTYPE_BYRECIPNAME	4	
#define POLLTYPE_BYPATHNAME		5	
#define POLLTYPE_DONE			8	
#define POLLTYPE_LAST				/* last valie POLLTYPE_ value */


#ifdef PORTABLE		/** ANSI C version **/

#define GroupLength(lp)		  ((((LPBYTE)(lp))[0]) & 0x3F)
#define GroupNum(lp)		  ((((((LPBYTE)(lp))[0]) >> 6) & 0x03) | (((((LPBYTE)(lp))[1]) & 0x07) << 2))
#define SetGroupLength(lp, n) ((((LPBYTE)(lp))[0]) = (((((LPBYTE)(lp))[0]) & 0xC0) | ((n) & 0x3F)))
#define SetupTextIdHdr(lp, l, n, t)										\
    (((LPBYTE)(lp))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));   \
    (((LPBYTE)(lp))[1]) = ((((n) & 0x1C) >> 2) | (((t) & 0x1F) << 3));

#else 				/** Microsoft C version **/

#define GroupLength(lp)		  (((LPBCHDR)(lp))->GroupLength)
#define GroupNum(lp)		  (((LPBCHDR)(lp))->GroupNum)
#define SetGroupLength(lp, n) (((LPBCHDR)(lp))->GroupLength = (n))
#define SetupTextIdHdr(lp, l, n, t)				\
	(((LPBCTEXTID)(lp))->GroupNum = (n)); 		\
	(((LPBCTEXTID)(lp))->GroupLength = (l));	\
	(((LPBCTEXTID)(lp))->TextEncoding = (t));

#endif /* PORTABLE */


#define AWRES_ALLT30 (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_mm080_154 | AWRES_mm160_154 | AWRES_200_200 | AWRES_300_300 | AWRES_400_400)


/********
    @doc    EXTERNAL OEMNSF DATATYPES

    @type   VOID | FAX_PAGE_WIDTHS | Fax Page Width values

    @emem	WIDTH_A4 | A4 width, 1728 pixels at 8 lines/mm horizontal resolution.
	@emem	WIDTH_B4 | B4 width, 2048 pixels at 8 lines/mm horizontal resolution.
	@emem	WIDTH_A3 | A3 width, 2432 pixels at 8 lines/mm horizontal resolution.

	@comm
	
	Widths in pixels must be exactly correct for MH/MR/MMR decoding to work.
	The width above are for NORMAL, FINE, 200dpi and SUPER resolutions.
	At 400dpi or SUPER_SUPER exactly twice as many pixels must be supplied
	and at 300dpi exactly 1.5 times.

	@flag Number of Pixels/Bytes per line at each page width and resolution |

		.			A4				B4				A3

		200		1728/216		2048/256		2432/304

		300		2592/324		3072/384		3648/456

		400		3456/432		4096/512		4864/608

	@xref <t BCFAX>

********/

#define WIDTH_A4	0	
#define WIDTH_B4	1	
#define WIDTH_A3	2	
#define WIDTH_MAX	WIDTH_A3

#define WIDTH_A5		16 	/* 1216 pixels */
#define WIDTH_A6		32	/* 864 pixels  */
#define WIDTH_A5_1728	64 	/* 1216 pixels */
#define WIDTH_A6_1728	128	/* 864 pixels  */



/********
    @doc    EXTERNAL OEMNSF DATATYPES

    @type   VOID | FAX_PAGE_LENGTHS | Fax Page Width values

    @emem	LENGTH_A4		| A4 length.
	@emem	LENGTH_B4		| B4 length.
	@emem	LENGTH_UNLIMITED| Unknown/Unlimited length.

	@xref <t BCFAX> 
********/

#define LENGTH_A4			0	
#define LENGTH_B4			1	
#define LENGTH_UNLIMITED	2


#endif /* _AWNSFCOR_H */

/****************************************************************************

 Note, line is kept open during poll requests as follows:-

(1) Successful poll request

 Caller   Callee        Notes
 ....
 <SendPhaseC>
 EOM
          MCF      previous operation is now done
 NSC/DTC           TurnReason=TURN_POLL (may be accompanied by SEP etc)
                    (should contain all NSF caps etc)
          NSC/DTC  TurnReason=TURN_WAIT (response is not yet ready)
                    (minimal NSC, only beginning of POLLREQ grp, no other grps)
 NSC/DTC           TurnReason=TURN_POLL (dont resend SEP etc)
                    (minimal NSC, only beginning of POLLREQ grp, no other grps)
          NSC/DTC  TurnReason=TURN_WAIT 
 NSC/DTC           TurnReason=TURN_POLL 
          NSS/DCS        
 <TCF, CFR, Phase C etc>
          EOM 
 MCF
          NSC/DTC  TurnReason=TURN_DONE (req done. Return control if req)
                    (if control is not requested back, send DCN here)
 .....


(2) Unsuccessful poll request

 Caller   Callee     Notes
 ....
 <SendPhaseC>
 EOM 
          MCF       previous operation is now done
 NSC/DTC            TurnReason=TURN_POLL (may be accompanied by SEP etc)
                     (should contain all NSF caps etc)
          NSC/DTC   TurnReason=TURN_WAIT (response is not yet ready)
                     (minimal NSC, only beginning of POLLREQ grp, no other grps)
 NSC/DTC            TurnReason=TURN_POLL (dont resend SEP etc)
                     (minimal NSC, only beginning of POLLREQ grp, no other grps)
          NSC/DTC   TurnReason=TURN_WAIT (response is not yet ready)
 NSC/DTC            TurnReason=TURN_POLL (dont resend SEP etc)
          NSC/DTC   TurnReason=TURN_FAIL (response is not available)
 DCN                 (or continue with other operations)
                         
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\buffers.h ===
/*==============================================================================
This file includes the BUFFER typedef and standard meta-data values.

23-Feb-93    RajeevD    Moved from ifaxos.h
17-Jul-93    KGallo     Added STORED_BUF_DATA metadata type for buffers containing 
                        the stored info for another buffer.
28-Sep-93    ArulM      Added RES_ ENCODE_ WIDTH_ and LENGTH_ typedefs
==============================================================================*/
#ifndef _INC_BUFFERS
#define _INC_BUFFERS

//----------------------------- BUFFERS -------------------------
/****
	@doc    EXTERNAL        IFAXOS    DATATYPES

	@types  BUFFER  |   The Buffer structure defines the buffer header
			structures which processes manipulate.

	@field  WORD	|   fReadOnly   | Specifies whether the buffer
			is readonly or not. It is the applications responsibility to
			check this flag and not violate it. <f IFBufMakeWritable> should
			be used if a process needs to write on a buffer which is
			marked readonly. This field should not be modified by the
			process itself.

	@field  LPBYTE  |   lpbBegBuf   | A far ptr pointing to the physical
			start of the buffer. This ptr has meaning only in the calling
			process's address space and should not be stored for any
			reason. It should not be modified either.

	@field  WORD    |   wLengthBuf  | Physical length of the buffer. Should
			not be modified by the process. Should be used in conjunction
			with <e BUFFER.lpbBegBuf> to know the physical boundaries of the buffer.

	@field  DWORD    |   dwMetaData   | Indicates the kind of data stored in
			the buffer. See <t STD_DATA_TYPES> for all the possible values
	    of this field.

	@field  LPBYTE  |   lpbBegData  | Far ptr to the start of valid data in the
			buffer. The process is responsible for maintaining the integrity
			of this as it consumes or produces data in the buffer. The ptr should
			not be passed to any other process as it will not be valid. At buffer
			allocation time this field is initialized to point to the physical
			beginning of the buffer.

	@field  LPBYTE  |   lpbCurPtr   | One of the fields of a union containing
	    lpbfNext and dwTemp as its other members.
	    A general purpose far ptr which can be
			used to mark an interesting place in the buffer. Should be used as
			a temporary variable while processing the buffer. Should not be directly
	    passed to any other process. Initialized
			to point to the beginning of the buffer at allocation time.
	    Remember that this is a UNION !!

	@field  LPBUFFER  |   lpbfNext | One of the fields of a union containing
	    lpbCurPtr and dwTemp as its other members. This should be used
	    when a module wants to internally link a list of buffers together.
	    Remember that this is a UNION !!

	@field  DWORD |   dwTemp | One of the fields of a union containing
	    lpbfNext and lpbCurPtr as its other members. This should be used when
	    the module wants to store some random information in the header.
	    Remember that this is a UNION !!

	@field  WORD    |   wLengthData | Gives the length of valid contiguous data
			present in the buffer starting at <e BUFFER.lpbBegData>. The process is
			responsible for maintaining the integrity of this. Initialized to
			zero at allocation time.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname _BUFFER

****/

typedef struct _BUFFER
{       
	// Private portion
	struct _BUFFERDATA  FAR *lpbdBufData;
	struct _BUFFER FAR *lpbfNextBuf;
    WORD    wResFlags;

	// Read Only portion
	WORD	fReadOnly;      // Is the buffer readonly ??
	LPBYTE  lpbBegBuf;      // Physical start of buffer
	WORD    wLengthBuf;     // Length of buffer

	// Read write public portion
	WORD    wLengthData;    // length of valid data
	DWORD   dwMetaData;      // Used to store metadata information
	LPBYTE  lpbBegData;     // Ptr to start of data
	union
	{
		struct _BUFFER FAR*     lpbfNext;       // for linking buffers
		LPBYTE  lpbCurPtr;      // for local current position use
		DWORD   dwTemp;    // for general use
	};

#ifdef VALIDATE
	// Dont touch this !!
	WORD    sentinel;       // debug sentinel
#endif

// C++ Extensions
#ifdef __cplusplus

	LPBYTE EndBuf  (void) FAR {return lpbBegBuf  + wLengthBuf; }
	LPBYTE EndData (void) FAR {return lpbBegData + wLengthData;}
	void   Reset   (void) FAR {lpbBegData = lpbBegBuf; wLengthData = 0;}
  
#endif // __cplusplus

} BUFFER, FAR *LPBUFFER , FAR * FAR * LPLPBUFFER ;

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_DATA_TYPES | Standard data types used for
	    specifying the format of data in the system.

    @emem   MH_DATA     | Modified Huffman (T.4 1-dimensional).
    @emem   MR_DATA     | Modified READ (T.4 2-dimensional).
    @emem   MMR_DATA| Modified Modified READ (T.6).
    @emem   LRAW_DATA | Raw bitmap data, Least Significant Bit to the left.
    @emem   HRAW_DATA | Raw Bitmap data, Most Significant Bit to the left.
    @emem   DCX_DATA | Industry standard DCX specification (collection of PCX pages).
    @emem   ENCRYPTED_DATA | Data encrypted - original format unspecified.
    @emem   SIGNED_DATA | Data along with a digital signature. 
    @emem   BINFILE_DATA | Arbitrary binary data.
    @emem   STORED_BUF_DATA | Contains a BUFFER header & data.
    @emem   DCP_TEMPLATE_DATA | Digital Cover Page template data.
    @emem   DCP_DATA | Digital Cover Page processed template data.
    @emem   SPOOL_DATA | Spool data type - same as MMR for now.
    @emem   PRINTMODE_DATA | Printer Mode structure.
    @emem   ASCII_DATA | Ascii text.
    @emem   OLE_DATA   | Ole object.
    @emem   OLE_PICTURE | Ole Rendering Data.
    @emem   END_OF_PAGE | End of page marker.
    @emem   END_OF_JOB  | End of job marker.
    @emem   CUSTOM_METADATA_TYPE  | Beyond this value custom data types can be
	    defined.

    @comm   This should be used to specify data type of any data stream in the
	    system - from BUFFERS to Linearized Messages.  All data types which 
	    need to be used in bit fields (i.e. the Format Resolution) must have
	    a value which is a power of 2.  Other data types which do not need to used
	    in a bit field context may be assigned the other values.
********/

#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L
#define LRAW_DATA         0x00000008L
#define HRAW_DATA         0x00000010L
#define DCX_DATA          0x00000020L
#define ENCRYPTED_DATA    0x00000040L
#define BINFILE_DATA      0x00000080L
#define DCP_TEMPLATE_DATA 0x00000100L
#define ASCII_DATA        0x00000200L
#define RAMBO_DATA        0x00000400L
#define LINEARIZED_DATA   0x00000800L
#define DCP_DATA          0x00001000L
#define PCL_DATA          0x00002000L
#define ADDR_BOOK_DATA    0x00004000L
#define OLE_BIT_DATA      0x00008000L    // So we can use fmtres on OLE_DATA
#define OLE_BIT_PICTURE   0x00010000L    // So we can use fntres on OLE_BIT_PICTURE

// Make spool data be MMR
#define SPOOL_DATA        MMR_DATA

// Standard Non-Bit Valued MetaData values
#define NULL_DATA         0x00000000L
#define SIGNED_DATA       0x00000003L
#define STORED_BUF_DATA   0x00000005L
#define PRINTMODE_DATA    0x00000006L
#define OLE_DATA          0x0000001EL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define OLE_PICTURE       0x0000001FL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define END_OF_PAGE       0x00000021L
#define END_OF_JOB        0x00000022L
#define PARADEV_DATA      0x00000031L    // parallel device data
#define PARADEV_EOF       0x00000032L    // parallel device end of file


#define ISVIEWATT(e)  (((e) == MMR_DATA) || ((e) == RAMBO_DATA))
#define ISOLEATT(e)   (((e) == OLE_DATA) || ((e) == OLE_PICTURE))
#define ISPAGEDATT(e) (((e)==MMR_DATA) || ((e)==MR_DATA) || \
                        ((e)==MH_DATA)|| ((e)==LRAW_DATA)|| ((e)==HRAW_DATA))


// Allow for 24 standard bit valued MetaData values
#define CUSTOM_METADATA_TYPE  0x00800001L

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_RESOLUTIONS | Standard Page Resolutions

    @emem   AWRES_UNUSED      | Resolution is unused or irrelevant
    @emem   AWRES_UNKNOWN     | Resolution is unknown
    @emem   AWRES_CUSTOM      | Custom resolution
    @emem   AWRES_mm080_038   | 8 lines/mm x 3.85 lines/mm
    @emem   AWRES_mm080_077   | 8 lines/mm x 7.7 lines/mm
    @emem   AWRES_mm080_154   | 8 lines/mm x 15.4 lines/mm
    @emem   AWRES_mm160_154   | 16 lines/mm x 15.4 lines/mm
    @emem   AWRES_200_100     | 200 dpi x 100 dpi
    @emem   AWRES_200_200     | 200 dpi x 200 dpi
    @emem   AWRES_200_400     | 200 dpi x 400 dpi
    @emem   AWRES_300_300     | 300 dpi x 300 dpi
    @emem   AWRES_400_400     | 400 dpi x 400 dpi
********/   

#define AWRES_UNUSED            0xFFFFFFFFL
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_600_300           0x00000800L

// Keep old names for a while
#define AWRES_NORMAL            AWRES_mm080_038
#define AWRES_FINE              AWRES_mm080_077
#define AWRES_SUPER             AWRES_mm080_154
#define AWRES_SUPER_SUPER       AWRES_mm160_154
#define AWRES_SUPER_FINE        AWRES_SUPER_SUPER

/********
    @doc    EXTERNAL    IFAXOS  DATATYPES  SRVRDLL

    @type   DWORD |  STD_PAGE_LENLIMITS | Standard Page Length Limits

    @emem   AWLENLIMIT_UNUSED    | Page Length Limit unused
    @emem   AWLENLIMIT_STD       | Page Length Limit defined by Standard Paper Size
    @emem   AWLENLIMIT_UNLIMITED | unlimited page length
********/

#define AWLENLIMIT_UNUSED    0xFFFFFFFFL
#define AWLENLIMIT_STD       0x00000001L
#define AWLENLIMIT_UNLIMITED 0x00000002L


/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL 

    @typee  STD_PAGE_SIZES | Standard Page Sizes

    @emem   AWPAPER_UNUSED         |  Paper size is unused
    @emem   AWPAPER_UNKNOWN         |  Unknown size
    @emem   AWPAPER_CUSTOM          |  Custom Paper size
    @emem   AWPAPER_A3_PORTRAIT     |  A3 Portrait
    @emem   AWPAPER_A3_LANDSCAPE    | A3 landscape
    @emem	AWPAPER_B4_PORTRAIT     | B4 portrait
	@emem	AWPAPER_B4_LANDSCAPE    | B4 landscape
	@emem	AWPAPER_A4_PORTRAIT     | A4 portrait
	@emem	AWPAPER_A4_LANDSCAPE    | A4 landscape
	@emem	AWPAPER_B5_PORTRAIT     | B5 portrait
	@emem	AWPAPER_B5_LANDSCAPE    | B5 landscape
	@emem	AWPAPER_A5_PORTRAIT     | A5 portrait
	@emem	AWPAPER_A5_LANDSCAPE    | A5 landscape
	@emem	AWPAPER_A6_PORTRAIT     | A6 portrait
	@emem	AWPAPER_A6_LANDSCAPE    | A6 landscape
	@emem	AWPAPER_LETTER_PORTRAIT | Letter portrait
	@emem	AWPAPER_LETTER_LANDSCAPE | Letter landscape
	@emem	AWPAPER_LEGAL_PORTRAIT   | Legal portrait
	@emem	AWPAPER_LEGAL_LANDSCAPE  | Legal landscape
	@emem	AWPAPER_WIN31_DEFAULT   | ????


	@comm   Page width in pixels must be exactly correct for MH/MR/MMR
			decoding and to interoperate with Group-3 fax machines.
			The table in the example below gives the bits/bytes required at each width
			and resolution combination

    @ex     Table for Page Width vs Resolution  |

                         A4        B4        A3        A5        A6
    200dpi / 8li/mm   1728/216  2048/256  2432/304  1216/152   864/108
    300               2592/324  3072/384  3648/456  1824/228  1296/162
    400dpi / 16li/mm  3456/432  4096/512  4864/608  2432/304  1728/216

********/

#define         AWPAPER_UNUSED                  0xFFFFFFFFL
#define         AWPAPER_UNKNOWN                 0x00000000L
#define         AWPAPER_CUSTOM                  0x00000001L
#define         AWPAPER_A3_PORTRAIT             0x00000002L
#define         AWPAPER_A3_LANDSCAPE            0x00000004L
#define         AWPAPER_B4_PORTRAIT             0x00000008L
#define         AWPAPER_B4_LANDSCAPE            0x00000010L
#define         AWPAPER_A4_PORTRAIT             0x00000020L
#define         AWPAPER_A4_LANDSCAPE            0x00000040L
#define         AWPAPER_B5_PORTRAIT             0x00000080L
#define         AWPAPER_B5_LANDSCAPE            0x00000100L
#define         AWPAPER_A5_PORTRAIT             0x00000200L
#define         AWPAPER_A5_LANDSCAPE            0x00000400L
#define         AWPAPER_A6_PORTRAIT             0x00000800L
#define         AWPAPER_A6_LANDSCAPE            0x00001000L
#define         AWPAPER_LETTER_PORTRAIT         0x00002000L
#define         AWPAPER_LETTER_LANDSCAPE        0x00004000L
#define         AWPAPER_LEGAL_PORTRAIT          0x00008000L
#define         AWPAPER_LEGAL_LANDSCAPE         0x00010000L
#define         AWPAPER_WIN31_DEFAULT           0x00020000L





#endif // _INC_BUFFERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\class2.h ===
#define         IDSIZE                  20
#define         MFR_SIZE                80
#define         RESPONSE_BUF_SIZE       300

typedef enum {  
  PCB_SEND_CAPS,
  PCB_SEND_PARAMS,
  PCB_RECV_PARAMS
}  PCBTYPE;


typedef struct {
        USHORT  uPCBSize;               // must set this
        BOOL    fEFAX;                  // accepts EFAX linearized file format

        BYTE    Resolution;             // one or more of the RES_ #defines below
        BYTE    Encoding;               // one or more of the ENCODE_ #defines below
        BYTE    PageWidth;                      // one of the WIDTH_ #defines below
        BYTE    PageLength;                     // one of the LENGTH_ #defines below
        BYTE    MinScan;                // one of the MINSCAN_ #defines below
                                                        // used only in RecvCaps
        PCBTYPE pcbtype;
        // BOOL fG3image;                       
        BOOL    fG3Poll;                // has G3 file available for polling
        BOOL    fNewT30;                // handles PWD/SEP/SUB
        CHAR    szID[IDSIZE+2]; // Must use '0' to '9' or ' '(space) only

        BOOL    fBinary;                // accepts binary files inside linearized EFAX messages
        BOOL    fRambo;                 // accepts Rambo inside linearized EFAX messages
        BOOL    fExtCapsSupport;// supports extended caps
        BOOL    fExtCapsAvail;  // has extended caps available for polling
                                                        // add more as they become clear

        BYTE    Baud;
} PCB, far* LPPCB, near* NPPCB;


//  Array to hold parsed class2 command strings.
#define MAX_CLASS2_COMMANDS     10
#define MAX_PARAM_LENGTH        50

typedef struct cl2_command {
    USHORT    comm_count;
    BYTE    command[MAX_CLASS2_COMMANDS];
    BYTE    parameters[MAX_CLASS2_COMMANDS][MAX_PARAM_LENGTH];
} CL2_COMM_ARRAY;


// structure for modem specific hacks
typedef struct {
        // Fields for manufacturer, model, and revision number
        CHAR    szATI[MFR_SIZE];
        CHAR    szMFR[MFR_SIZE];
        CHAR    szMDL[MFR_SIZE];
        CHAR    szREV[MFR_SIZE];
        //Fields for specific actions to take
        //BOR values to use
        USHORT    iReceiveBOR;
        USHORT    iSendBOR;
        //Value to enable data to be recieved after FDR
        CHAR    szDC2[2];
        BOOL    bIsSierra;
        BOOL    bIsExar;
        BOOL    fSkipCtrlQ;     // DONT wait for CtrlQ after FDT
        BOOL    fSWFBOR;        // Implement AT+FBOR=1 in software (i.e., bitreverse)
                                                // Only invoked on send(recv) if iSendBOR(iRecvBOR)
                                                // is 1 (in which it will send AT+FBOR=0).
} MFRSPEC, far *LPMFRSPEC;



/**-------------------- from MODEM.H -----------------------------**/

typedef char  C2SZ;
typedef char  *C2PSTR;




/**-------------------- from COMMODEM.H -----------------------------**/

#define MAXPHONESIZE    512
#define DIALBUFSIZE     MAXPHONESIZE + 10






/**-------------------- modelled after MODEMINT.H -----------------------------**/
// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
                // Looks like even 330 is too short for some modems..

#define Class2SyncModemDialog(pTG, s, l, w)                                  \
    Class2iModemDialog(pTG, (s), (l), 550, TRUE, 2, (C2PSTR)(w), (C2PSTR)(NULL))



// has to be >1 try & multi-line because we can have RING noises
// coming in at anytime while on-hook
/**
#define  Class2LocalModemDialog(s, l, w)                        \
        Class2iModemDialog((s), (l), 1500, TRUE, 2, (C2PSTR)(w), (C2PSTR)(NULL))
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\dosio.h ===
#ifdef KFIL		// use win kernel file handling

#define DosInit() 				(TRUE)
#define DosDeInit()
#define DosOpen(f, m)			_lopen(f, m)
#define DosClose(h)				_lclose(h)
#define DosCreate(f, m)			_lcreat(f, m)
#define DosSeek(h, off, pos)	((DWORD)_llseek(h, off, pos))
#define DosRead(h, lpb, cb)		_lread(h, lpb, cb)	
#define DosWrite(h, lpb, cb)	_lwrite(h, lpb, cb)
#define DosCommit(h)		

#endif // KFIL

#ifdef DOSIO

#define	MAKEWORD(l,h)	((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))

BOOL WINAPI DosInit(void);
void WINAPI DosDeInit(void);
DWORD WINAPI DosCall (WORD DosAX, WORD DosBX, WORD DosCX, DWORD DosDSDX);

#define DosDelete(sz)		((WORD)DosCall(0x4100, 0, 0, (DWORD)((LPSTR)(sz))))
#define DosCreate(sz,a)		((WORD)DosCall(0x3C00, 0, a, (DWORD)((LPSTR)(sz))))
#define DosClose(h)			((WORD)DosCall(0x3E00, h, 0, 0))
#define DosCommit(h)		((WORD)DosCall(0x6800, h, 0, 0))
#define DosOpen(sz, m)		((WORD)DosCall(MAKEWORD(m, 0x3D), 0, 0, (DWORD)((LPSTR)(sz))))
#define DosRead(h, lpb, cb)	((WORD)DosCall(0x3F00, h, cb, (DWORD)((LPBYTE)(lpb))))
#define DosWrite(h,lpb,cb)	((WORD)DosCall(0x4000, h, cb, (DWORD)((LPBYTE)(lpb))))
#define DosSeek(h,off,p)	DosCall(MAKEWORD(p,0x42), h, HIWORD((DWORD)(off)), MAKELONG(LOWORD((DWORD)(off)), 0))

// #ifdef VPMTD_FINDFIRST
//	// these two return -1 on failure and unknown (probably 0x4E00 etc) on success
//	// the structure containing the found data is in the DTA (part of PSP)
// #	define DosFindFirst(sz, a)	((WORD)DosCall(0x4E00, 0, a, (DWORD)((LPSTR)(sz))))
// #	define DosFindNext()		((WORD)DosCall(0x4F00, 0, 0, 0))
// #endif //VPMTD_FINDFIRST

#endif //DOSIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\cas.h ===
/***************************************************************************
 Name     :	CAS.C
 Comment  :	

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#ifdef CAS

// Copy of the DCX and PCX header from dcx.h in \wfw\efaxpump

#define MAX_DCX_PAGES       1023 

typedef struct DCXHDR_s
{
    DWORD   id;                     // 4 byte integer =987654321
    DWORD   Offset[MAX_DCX_PAGES+1];// array of 4 byte integers showing page offsets

}   DCXHDR;

typedef struct PCXHDR_s
{
	char    id;             // always = 0Ah
	char    version;        // value of 2 is suggested, higher allowed
	char    encode_method;  // always = 1
	char    bitsperpixel;   // =1 for fax mode transfer
	short   xtopleft;
	short   ytopleft;
	short   width;
	short   height;
	short   hDPI; 
	short   vDPI; 
	char    pal[48];
	char    reserv;
	char    colorplanes;    // must be 1 for fax mode
	short   horiz;
    	short   nPaletteInfo;   // palette info. must be 1
	char    filler[58];
}   PCXHDR;


/***------------------ Interface to CAS.C ------------------***/

		BOOL __export WINAPI CASModemFind(void);
typedef BOOL (WINAPI  *LPFN_CASMODEMFIND)(void);
	// returns TRUE if CAS is installed, FALSE if not

		VOID __export WINAPI CASInit(void);
typedef BOOL (WINAPI  *LPFN_CASINIT)(void);
	// init stuff, if any

		VOID __export WINAPI CASDeInit(void);
typedef VOID (WINAPI  *LPFN_CASDEINIT)(void);
	// if you want to down any shutdown-cleanup
	// (e.g. if there are pending receives, does CAS 
	// save them for you across a reboot?)

		BOOL __export WINAPI CASSendFile(ATOM aPhone, ATOM aFileMG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX);
typedef BOOL (WINAPI  *LPFN_CASSENDFILE)(ATOM aPhone, ATOM aFileMG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX);
	// Send. Returns immediately with TRUE unless
	// some internal DEBUGCHK-like error or multiple
	// sends. Handles only one at a time & saves CAS handle
	// internally

		WORD __export WINAPI CASCheckSent(void);
typedef WORD (WINAPI  *LPFN_CASCHECKSENT)(void);
	// Checks if pending send (only one at any time), was sent. 
	// Returns 0 if still pending, non-zero if done, with success/error. 
	// The return value should be in LOBYTE=result HIBYTE=extended-error 
	// form. See FILET30.H, line 29-38 for valid values/combinations.

		USHORT __export WINAPI CASGetNumReceived(void);
typedef USHORT (WINAPI  *LPFN_CASGETNUMRECEIVED)(void);
	// Get *number* of pending receives	(successful or failure) only. 
	// Don't actually dequeue any.

		DWORD __export WINAPI CASGetNextRecv(LPSTR szPath, LPSTR szFile);
typedef DWORD (WINAPI  *LPFN_CASGETNEXTRECV)(LPSTR szPath, LPSTR szFile);
	// gives the spool dir (recvd file in all forms _must_ be put 
	// there for pump to get it) and a suggested filename (8.3 format) 
	// which has been checked to be "safe" to create in that directory. 
	// File name/extension can be changed as neccesary.
	// Return value must be a DWORD with the return filename atom
	// in LOWORD and result/extendederr in HIWORD (i.e result
	// is LOBYTE(HIWORD()) and exterr is HIBYTE(HIWORD()).
	// See lines 54--66 of FILET30.H for valid return values

		VOID __export WINAPI CASAbort(void);
typedef VOID (WINAPI  *LPFN_CASABORT)(void);
	// Abort current Send/Recv if possible.
	// Return when abort is **complete**. Can stub it out currently

		BOOL __export WINAPI CASSetAutoAnswer(BOOL fOn, USHORT uNumRings);
typedef BOOL (WINAPI  *LPFN_CASSETAUTOANSWER)(BOOL fOn, USHORT uNumRings);
	// fOn==TRUE--answer On, FALSE--answer Off
	// uNumRings == after X rings. (0 or more)


		BOOL __export WINAPI CASSetBC(LPBC lpbc, BCTYPE bctype);
typedef	BOOL (WINAPI  *LPFN_CASSETBC)(LPBC lpbc, BCTYPE bctype);

// Finally, we should also see if we can implement any of Mike 
// Ginsberg's INI settings on a CAS board. 

#endif // CAS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\awnsfint.h ===
/***************************************************************************
 Name     :     AWNSFINT.H
 Comment  :     INTERNAL-ONLY Definitions of BC and NSF related structs

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Modifying aftering adding encryption
***************************************************************************/


#ifndef _AWNSFINT_H
#define _AWNSFINT_H

#include <awnsfcor.h>
#include <fr.h>

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#pragma pack(2)         /* ensure portable packing (i.e. 2 or more) */

/* these sizes should remain constant across all platforms */

#define GRPSIZE_STD                     5
#define GRPSIZE_IMAGE           6
#define GRPSIZE_POLLCAPS        5
#define GRPSIZE_NSS                     3
#define GRPSIZE_FAX                     12

#define BCEXTRA_TEXTID  64      /** space for one 60-byte Text ID **/
#define BCEXTRA_POLL    128     /** space for reasonable poll requests **/
#define BCEXTRA_HUGE    640     /** space for everything, probably.... **/

#define MAXNSCPOLLREQ                   5

#ifndef NOCHALL
#       define POLL_CHALLENGE_LEN       10
#endif



#ifdef PORTABLE         /* ANSI C */

typedef struct { BYTE b[GRPSIZE_STD];           } BCSTD;
typedef struct { BYTE b[GRPSIZE_IMAGE];         } BCIMAGE;
typedef struct { BYTE b[GRPSIZE_POLLCAPS];      } BCPOLLCAPS;
typedef struct { BYTE b[GRPSIZE_NSS];           } BCNSS;
typedef struct { BYTE b[GRPSIZE_FAX];           } BCFAX;

typedef struct
{
        BCTYPE  bctype;
        WORD    wBCSize;
        WORD    wBCVer;
        WORD    wBCSig;
        WORD    wTotalSize; /** total size of header + associated var len strings **/

        BCSTD           Std;
        BCIMAGE         Image;
        BCPOLLCAPS      PollCaps;
        BCNSS           NSS;
        BCFAX           Fax;

        WORD    wTextEncoding;  /** char set code see above  **/
        WORD    wTextIdLen;             /** length of text id **/
        WORD    wszTextId;              /** offset from start of struct to zero-term szTextId **/
        WORD    wMachineIdLen;  /** size of Machine Id (not zero-terminated) **/
        WORD    wrgbMachineId;  /** offset from start of struct to zero-term szNumId **/
        /* WORD wszNumId; */    /** offset from start of struct to zero-term szNumId **/

        WORD    wszRecipSubAddr;  /* offset from start of struct to zero-term SUB frame */
        WORD    wRecipSubAddrLen; /* length of SUB frame */

        WORD    wNumPollReq;    /** number of SEPPWDOFF structs i.e. size of following array **/
        WORD    rgwPollReq[MAXNSCPOLLREQ];      /** array of offsets to POLLREQ structures **/

#ifndef NOCHALL
        WORD    wChallengeLen;  /** length of challenge string **/
        WORD    wChallenge;             /** offset to challenge string **/
#endif

        BYTE    b[BCEXTRA_HUGE];
        DWORD   Guard;
}
BCwithHUGE, FAR* LPBC, NEAR* NPBC;

#define BC_SIZE (sizeof(BCwithHUGE)-BCEXTRA_HUGE-sizeof(DWORD))


#else /* Microsoft C only */



/********
    @doc   EXTERNAL DATATYPES OEMNSF

        @types BCFAX | Fax Capabilities Group

        @field BOOL      | fPublicPoll | Blind/Public poll availability/request
        @field DWORD | AwRes       | Resolution Capabilities or Mode. See <t STD_RESOLUTIONS> for values.
        @field WORD  | Encoding    | Encoding Capabilities or Mode. See <t STD_DATA_TYPES>
        @field WORD  | PageWidth   | Page Width Capabilities or Mode. See <t FAX_PAGE_WIDTHS>
        @field WORD  | PageLength  | Page Length Capabilities or Mode. See <t FAX_PAGE_LENGTHS>
********/

typedef struct
{
        ///////// This structure is not transmitted /////////

        WORD    fPublicPoll;
//2bytes

        DWORD   AwRes;          /* One or more of the AWRES_ #defines           */
        WORD    Encoding;       /* One or more of MH_DATA/MR_DATA/MMR_DATA      */
        WORD    PageWidth;      /* One of the WIDTH_ #defines (these are not bitflags!) */
        WORD    PageLength;     /* One of the LENGTH_ #defines (these are not bitflags!) */
//12 bytes
}
BCFAX, far* LPBCFAX, near* NPBCFAX;


/********
    @doc    EXTERNAL DATATYPES OEMNSF

        @types  BC | Basic Capabilities structure corresponding
                                 to sent or received NSF, NSS or NSC frames.

        @field BCTYPE | bctype | Type of BC structure. Must always be set. See <t BCTYPE> for values.
        @field WORD   | wBCSize| Size of this (fixed size) AWBC struct. Must always be set.
        @field WORD   | wBCVer | Version. Currently set it to VER_AWFXPROT100.
        @field WORD   | wBCSig | Set to VER_AWFXPROT100.

        @field BCSTD      | Std      | Standard Capability group. See <t BCSTD> for details.
        @field BCIMAGE    |     Image    | Image Capability group. See <t BCIMAGE> for details.
        @field BCPOLLCAPS |     PollCaps | PollCaps Capability group. See <t BCPOLLCAPS> for details.
        @field BCNSS      | NSS          | NSS Capability group. See <t BCNSS> for details.
        @field BCFAX      | Fax          | Fax Capability group. See <t BCFAX> for details.

        @field WORD     | wTextEncoding | Character-Set code used in TextId
        @field WORD     | wTextIdLen    | Length of TextId in bytes
        @field WORD     | wszTextId             | Offset from start of struct to zero-term szTextId
        @field WORD     | wMachineIdLen | Length of MachineId in bytes (not zero-terminated)
        @field WORD     | wrgbMachineId | Offset from start of struct to MachineId.

        @field WORD     | wszRecipSubAddr  | Offset from start of struct to zero-term SubAddress.
        @field WORD     | wRecipSubAddrLen | Length of SubAddress.
                                |
        @field WORD     | wNumPollReq  | Number of valid PollReqs in the following array. Cannot exceed MAXNSCPOLLREQ.
        @field WORD     | rgwPollReq[] | Array of offsets (from start of struct) to POLLREQ structures.
                                |
        @field WORD     | wChallengeLen | Length of the Password-Challenge string
        @field WORD     | wChallenge    | Offset (from start of struct) to Challenge string

        @xref   <t BCTYPE>
********/


typedef struct
{
        BCTYPE  bctype;  // must always be set. One of the enum values above
        WORD    wBCSize; // size of this (fixed size) BC struct, must be set
        WORD    wBCVer; // if using this header file, set it to VER_AWFXPROT100
        WORD    wBCSig; // if using this header file, set it to VER_AWFXPROT100
        WORD    wTotalSize; // total size of header + associated var len strings

        BCSTD                   Std;
        BCIMAGE                 Image;
        BCPOLLCAPS              PollCaps;
        BCNSS                   NSS;
        BCFAX                   Fax;            // for internal use _only_

        WORD    wTextEncoding;  // char set code
        WORD    wTextIdLen;             // length of text id
        WORD    wszTextId;              // offset from start of struct to zero-term szTextId
        WORD    wMachineIdLen;  // size of Machine Id (not zero-terminated)
        WORD    wrgbMachineId;  // offset from start of struct to zero-term szNumId
        // WORD wszNumId;               // offset from start of struct to zero-term szNumId

        WORD    wszRecipSubAddr;        // offset from start of struct to zero-term SUB frame
        WORD    wRecipSubAddrLen;       // length of SUB frame

        WORD    wNumPollReq;            // size of following array
        WORD    rgwPollReq[MAXNSCPOLLREQ];      // array of offsets to POLLREQ structures

#ifndef NOCHALL
        WORD    wChallengeLen;  // length of challenge string
        WORD    wChallenge;             // offset to challenge string
#endif //!NOCHALL
}
BC, far* LPBC, near* NPBC;

#define BC_SIZE sizeof(BC)

//#ifndef __cplusplus

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_TEXTID];
        DWORD   Guard;
}
BCwithTEXT;

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_POLL];
        DWORD   Guard;
}
BCwithPOLL;

typedef struct
{
   #ifndef __cplusplus
           BC;
   #else
      BC bc;
   #endif //!__cplusplus

        BYTE b[BCEXTRA_HUGE];
        DWORD   Guard;
}
BCwithHUGE;

//#endif //!__cplusplus


/**------------------- ACK struct ----------------**/

typedef struct
{
        BCTYPE  bctype;  // must always be set. One of SEND_ACK or SEND_DISCONNECT
        WORD    wACKSize; // size of this (fixed size) ACK struct, must be set
        WORD    wACKVer; // if using this header file, set it to VER_AWFXPROT100
        WORD    wACKSig; // if using this header file, set it to VER_AWFXPROT100

        BOOL    fAck;
}
ACK, far* LPACK;


#endif /** PORTABLE **/



#define AppendToBCLen(lpbc, uMax, lpb, uLen, wOff, wLen)                \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo = ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                          \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wOff = (lpbc)->wTotalSize;                                            \
          (lpbc)->wLen = uCopy;                                                                         \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}


#define AppendToBCOff(lpbc, uMax, lpb, uLen, wOff)                              \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo = ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                          \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wOff = (lpbc)->wTotalSize;                                            \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}

#define AppendToBC(lpbc, uMax, lpb, uLen)                                               \
{       USHORT uCopy;                                                                                           \
        LPBYTE lpbTo;                                                                                           \
        BG_CHK((lpbc) && (uMax) && (lpb) && (uLen));                            \
        BG_CHK((lpbc)->wTotalSize >= sizeof(BC));                                       \
        if((lpbc)->wTotalSize+1 < (uMax))                                                       \
        {                                                                                                                       \
          uCopy = min((uLen), (uMax)-1-(lpbc)->wTotalSize);                     \
          BG_CHK(uCopy == (uLen));                                                                      \
          lpbTo =  ((LPBYTE)(lpbc))+(lpbc)->wTotalSize;                         \
          _fmemcpy(lpbTo, (lpb), uCopy);                                                        \
          lpbTo[uCopy] = 0;                                                                                     \
          (lpbc)->wTotalSize += uCopy+1;                                                        \
        }                                                                                                                       \
        BG_CHK((lpbc)->wTotalSize <= uMax);                                                     \
}


#define InitBC(lpbc, uSize, t)                                                          \
{                                                                                                                       \
        _fmemset((lpbc), 0, (uSize));                                                   \
        (lpbc)->bctype  = (t);                                                                  \
        (lpbc)->wBCSize = sizeof(BC);                                                   \
        (lpbc)->wBCVer  = VER_AWFXPROT100;                                              \
        (lpbc)->wBCSig  = VER_AWFXPROT100;                                              \
        (lpbc)->wTotalSize = sizeof(BC);                                                \
}


#define GetTextId(lpbc, lpbOut, uMax)                                                                           \
        BG_CHK((lpbOut) && (lpbc) && (uMax));                                                                   \
        ((LPBYTE)(lpbOut))[0] = 0;                                                                                              \
        if( (lpbc)->wTextIdLen && (lpbc)->wszTextId &&                                                  \
                (lpbc)->wszTextId < (lpbc)->wTotalSize &&                                                       \
                (lpbc)->wszTextId+(lpbc)->wTextIdLen <= (lpbc)->wTotalSize)                     \
        {                                                                                                                                               \
                USHORT uLen;                                                                                                            \
                uLen = min(((uMax)-1), (lpbc)->wTextIdLen);                                                     \
                _fmemcpy((lpbOut), (((LPBYTE)(lpbc)) + (lpbc)->wszTextId), uLen);       \
                ((LPBYTE)(lpbOut))[uLen] = 0;                                                                           \
        }

#define PutTextId(lpbc, uMax, lpbIn, uLen, enc)                                                          \
        if(uLen) { AppendToBCLen(lpbc, uMax, lpbIn, uLen, wszTextId, wTextIdLen);\
                (lpbc)->wTextEncoding = (enc); }

#define HasTextId(lpbc)         ((lpbc)->wTextIdLen && (lpbc)->wszTextId)



#define PutRecipSubAddr(lpbc, uMax, lpbIn, uLen)                                                         \
        if(uLen) { AppendToBCLen(lpbc, uMax, lpbIn, uLen, wszRecipSubAddr, wRecipSubAddrLen); }

#define GetRecipSubAddr(lpbc, lpbOut, uMax)                                                                             \
        BG_CHK((lpbOut) && (lpbc) && (uMax));                                                                   \
        ((LPBYTE)(lpbOut))[0] = 0;                                                                                              \
        if( (lpbc)->wRecipSubAddrLen && (lpbc)->wszRecipSubAddr &&                                                      \
                (lpbc)->wszRecipSubAddr < (lpbc)->wTotalSize &&                                                 \
                (lpbc)->wszRecipSubAddr+(lpbc)->wRecipSubAddrLen <= (lpbc)->wTotalSize)                 \
        {                                                                                                                                               \
                USHORT uLen;                                                                                                            \
                uLen = min(((uMax)-1), (lpbc)->wRecipSubAddrLen);                                                       \
                _fmemcpy((lpbOut), (((LPBYTE)(lpbc)) + (lpbc)->wszRecipSubAddr), uLen); \
                ((LPBYTE)(lpbOut))[uLen] = 0;                                                                           \
        }

#define HasRecipSubAddr(lpbc)   ((lpbc)->wRecipSubAddrLen && (lpbc)->wszRecipSubAddr)


/* returns FALSE (and doesnt caopy anything) if destination is too small */
#define CopyBC(lpbcOut, wMaxOut, lpbcIn)                \
        ( (wMaxOut < lpbcIn->wTotalSize) ? FALSE :      \
                        (_fmemcpy(lpbcOut, lpbcIn, lpbcIn->wTotalSize), TRUE) )

/** not for general use **/
/** #define DeleteTextId(lpbc)  ((lpbc)->wszTextId=(lpbc)->wTextIdLen=(lpbc)->wTextEncoding=0) **/




#define OffToNP(npbc, off) (((npbc)->off) ? (((NPBYTE)(npbc)) + ((npbc)->off)) : NULL)
#define OffToLP(lpbc, off) (((lpbc)->off) ? (((LPBYTE)(lpbc)) + ((lpbc)->off)) : NULL)

#define OFF_CHK(lpbc, off)      BG_CHK((lpbc)->off >= sizeof(BC) && (lpbc)->off <= (lpbc)->wTotalSize)


#if defined(IFBGPROC) || defined(IFFGPROC)
#       define EXPORTBC         _export WINAPI
#else
#       define EXPORTBC
#endif


/***************************************************************************
    @doc    INTERNAL

        @api    WORD | NSxtoBC | Called to parse received Microsoft At Work NSx
                                        frames and fill in a BC structure.

        @parm   IFR | ifr | This must be set to ifrNSF for parsing Capabilities
                        (NSF/DIS) and to ifrNSS for parsing Mode/Parameters (NSS/DCS)

        @parm   LPFR[] | rglpfr | [in] Pointer to array of LPFR pointers which
                        point to FR structures that contain the received frame(s).

        @parm   WORD | wNumFrame | [in] Number of received frames i.e. length of
                        the above array of pointers

        @parm   LPBC | lpbcOut | [out] Pointer to output BC struct

        @parm   WORD | wBCSize | [in] size of the above AWBC struct.

        @rdesc  Returns AWERROR_OK on success, otherwise one of the other
                        AWERROR_ values.

        @xref   <t IFR> <t FR> <t BC>
***************************************************************************/



/***************************************************************************
    @doc    INTERNAL

        @api    WORD | BCtoNSx | Called to create Microsoft At Work NSx frames
                                                         from a BC struct

        @parm   IFR | ifr | This must be set to ifrNSF for creating Capabilities
                        (NSF/DIS) and to ifrNSS for creating Mode/Parameters (NSS/DCS)

        @parm   LPBC | lpbcIn | [in] Pointer to input BC struct.

        @parm   LPBYTE | lpbOut | [out] Pointer to space where the NSx frames
                        will be created. On successful return this will point to an array
                        of *lpwNumFrame pointers to FR structures, (i.e. on return the
                        start of this buffer contains an LPFR[] array that is *lpwNumFrame
                        items long). The pointers point to the actual (variable-length)
                        FR stuctures which are placed in the buffer following this
                        array of pointers.

        @parm   WORD | wMaxOut | [in] Length of the above buffer. It is
                        reccomended that this be at least 256 bytes long

        @parm   LPWORD | lpwNumFrame | [out] Number of NSx frames created. Also
                        length of the LPFR[] array created in the supplied buffer.

        @rdesc  Returns AWERROR_OK on success, otherwise one of the other
                        AWERROR_ values.

        @xref   <t IFR> <t FR> <t BC>
***************************************************************************/




#if defined(IFBGPROC) || defined(IFFGPROC)

// internal APIs only!

/***************************************************************************
    @doc    INTERNAL

        @api    WORD    | DIStoBCFAX | Parses a DIS into a BCFAX
        @parm   LPBYTE  | lpbDIS         | [in] Pointer to DIS (FIF part only)
        @parm   WORD    | wLenDIS        | [in] length of DIS
        @parm   LPBCFAX | lpbcfax        | [out] Pointer to BCFAX struct to be filled in
        @parm   WORD    | wLenBCFAX      | [in] length of BCFAX struct

        @rdesc  Returns length of BCFAX filled in on success. 0 on failure

        @comm   **NOTE**: Be sure to call this function _after_ calling NSxtoBC,
                        because NSxtoBC zeros out the entire BC struct, _including_ the
                        BCFAX part, so if the order were reversed, the data parsed from
                        the DIS would be lost.

        @xref   <t IFR> <t BCFAX>
***************************************************************************/

WORD EXPORTBC DIStoBCFAX(IFR ifr, LPBYTE lpbDIS, WORD wLenDIS, LPBCFAX lpbcfax, WORD wLenBCFAX);

/***************************************************************************
    @doc    INTERNAL

        @api    WORD    | BCFAXtoDIS | Creates a DIS from a BCFAX
        @parm   LPBCFAX | lpbcfax        | [in] Pointer to BCFAX struct
        @parm   WORD    | wLenBCFAX      | [in] length of BCFAX struct
        @parm   LPBYTE  | lpbDIS         | [out] Pointer to space for DIS (FIF part only).
                                                                        Note: This API does _not_ create an FR struct!!
        @parm   WORD    | wLenDIS        | [in] length of buffer provided for DIS

        @rdesc  Returns length of DIS created on success. 0 on failure
        @xref   <t IFR> <t BCFAX>
***************************************************************************/

WORD EXPORTBC BCFAXtoDIS(IFR ifr, LPBCFAX lpbcfax, WORD wLenBCFAX, LPBYTE lpbDIS, WORD wLenDIS);

#endif /* IFBGPROC || IFFGPROC */

#pragma pack()

#endif /** _AWNSFINT_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\comdevi.h ===
/***************************************************************************
 Name     :     COMDEVI.H
 Comment  :     Controls Comm interface used by Fax Modem Driver. There are
                        4 choices.
                        (a) If UCOM is defined, it uses the WIN16 Comm API as exported
                                by USER.EXE (though eventually it gets to COMM.DRV)
                        (b) If UCOM is not defined and VC is defined, it uses the
                                COMM.DRV-like interface exported by DLLSCHED.DLL (which
                                merely serves as a front for VCOMM.386)
                        (c) If neither UCOM nor VC are defined, it uses Win3.1 COMM.DRV
                                export directly.
                        (d) If WIN32 is defined (neither UCOM or VC should be defined at
                                the same time), it uses the WIN32 Comm API

 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



#pragma optimize("e", off)              // "e" is buggy

// must be 8K or less, dues to DEADCOMMTIMEOUT. See fcom.c!!
// maybe not...

// #define      COM_INBUFSIZE           16384
// #define      COM_OUTBUFSIZE          16384
#define COM_INBUFSIZE           4096
#define COM_OUTBUFSIZE          4096
// #define COM_INBUFSIZE                256
// #define COM_OUTBUFSIZE               256
// #define COM_INBUFSIZE                1024
// #define COM_OUTBUFSIZE               1024

#define BETWEENCALL_THRESH 50

#ifdef DEBUG
#       define CALLTHRESH_CONST         50
#       define CALLTHRESH_PERBYTE       1
#       define BEFORECALL               static DWORD t1, t2; t1=GetTickCount();
#   define INTERCALL(sz)
/*
#   define INTERCALL(sz)                if((t1-t2) > BETWEENCALL_THRESH)\
                 ERRMSG(("!!!Inter API %s delay %ld!!!\r\n", (LPSTR)(sz), (t1-t2)));
*/
#       define AFTERCALL(sz,n)  \
                t2=GetTickCount();\
                if((t2-t1) > (CALLTHRESH_CONST+((DWORD)n)*CALLTHRESH_PERBYTE))                  \
                        ERRMSG(("!!!API %s took %ld!!!\r\n", (LPSTR)(sz), (t2-t1)));
#else
#       define BEFORECALL
#       define AFTERCALL
#   define INTERCALL
#endif

#define My2ndOpenComm(sz, ph)                                                                                           \
        { BEFORECALL;                                                                                                                   \
          if((*((LPHANDLE)(ph)) = CreateFile((LPCTSTR)(sz), GENERIC_READ|GENERIC_WRITE, \
                        0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) != INVALID_HANDLE_VALUE)           \
          {                                                                                                                                             \
                if(!SetupComm(*((LPHANDLE)(ph)), COM_INBUFSIZE, COM_OUTBUFSIZE))        \
                {                                                                                                                                       \
                        CloseHandle(*((LPHANDLE)(ph)));                                                                 \
                        *((LPHANDLE)(ph)) = INVALID_HANDLE_VALUE;                                               \
                }                                                                                                                                       \
          }                                                                                                                                             \
          AFTERCALL("Open", 0);                                                                                                 \
        }                                                                                                                                               \


#define My2ndCloseComm(h, pn)   { BEFORECALL; *(pn) = (!CloseHandle((HANDLE)h)); AFTERCALL("Close",0); }
#define MySetCommState(h,pdcb)  (!SetCommState((HANDLE)(h), (pdcb)))
#define MyGetCommState(h,pdcb)  (!GetCommState((HANDLE)(h), (pdcb)))

#define OVL_CLEAR(lpovl) \
                                 { \
                                        if (lpovl) \
                                        { \
                                                (lpovl)->Internal = (lpovl)->InternalHigh=\
                                                (lpovl)->Offset = (lpovl)->OffsetHigh=0; \
                                                if ((lpovl)->hEvent) ResetEvent((lpovl)->hEvent); \
                                        } \
                                 }


#define MySetCommMask(h,mask)   (!SetCommMask((HANDLE)(h), (mask)))
#define MyFlushComm(h,q)                (!PurgeComm((HANDLE)h, ((q)==0 ? PURGE_TXCLEAR : PURGE_RXCLEAR)))
#define MySetXON(h)                             (!EscapeCommFunction((HANDLE)(h), SETXON))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\faxsrc.inc ===
!if !$(FREEBUILD)				
C_DEFINES = $(C_DEFINES) -DDEBUG		
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\fcomapi.h ===
/***************************************************************************
        Name      :     FCOMAPI.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.
        Functions :     (see Prototypes just below)
        Revision Log

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "timeouts.h"

#define FILTER_DLEONLY  1
#define FILTER_DLEZERO  0



// following currently defined in FileT30.h
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)










/***************************************************************************
                                        Common Modem Operations
***************************************************************************/

#ifdef CBZ
        typedef char __based(__segname("_CODE")) CBSZ[];
        typedef char __based(__segname("_CODE")) *CBPSTR;
#else
#       ifdef LPZ
                typedef char far CBSZ[];
                typedef char far *CBPSTR;
#       else
                typedef char near CBSZ[];
                typedef char near *CBPSTR;
#       endif
#endif

// iModemInit takes following SPECIAL values for fInstall:
#define fMDMINIT_NORMAL 0       // Normal Init -- includes ID Check.
#define fMDMINIT_INSTALL 1      // Full install
#define fMDMINIT_ANSWER 10      // Quick init before answering -- Skips ID check.

// +++ Old code sometimes calls with fINSTALL=TRUE
#if     (fMDMINIT_INSTALL!=TRUE) || (fMDMINIT_ANSWER==TRUE) || (fMDMINIT_NORMAL!=0) || !fMDMINIT_ANSWER
#       error "fMDMINIT_* ERROR"
#endif

// iModemInit returns these
#define INIT_OK                         0
#define INIT_INTERNAL_ERROR     13
#define INIT_MODEMERROR         15
#define INIT_PORTBUSY           16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\efaxcb.h ===
/***************************************************************************
 Name     :     EFAXCB.H
 Comment  :

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "protparm.h"

#ifdef TSK
#       define TSKEXPORT        _export WINAPI
#else
#       define TSKEXPORT
#endif

/****************** begin prototypes from icomfile.c *****************/
void   ICommGotAnswer(PThrdGlbl pTG);
void   ICommSetSendMode(PThrdGlbl pTG, BOOL fECM, LONG sBufSize, USHORT uDataSize, BOOL fPad);
BOOL   ICommRecvCaps(PThrdGlbl pTG, LPBC lpBC);
BOOL   ICommRecvParams(PThrdGlbl pTG, LPBC lpBC);
BOOL   ICommRecvPollReq(PThrdGlbl pTG, LPBC lpBC);
USHORT   ICommNextSend(PThrdGlbl pTG);
BOOL   ICommSendPageAck(PThrdGlbl pTG, BOOL fAck);
void   ICommFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail);
SWORD   ICommGetSendBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, SLONG slOffset);
BOOL   ICommPutRecvBuf(PThrdGlbl pTG, LPBUFFER lpbf, SLONG slOffset);
USHORT   ICommGetRecvPageAck(PThrdGlbl pTG, BOOL fSleep);
LPBC   ICommGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep);

#ifdef RICOHAI
        LPBYTE   ICommGetOEMCaps(LPWORD);
        void   ICommSetOEMCaps(LPBYTE lpb, WORD wLen);
#endif

#ifdef STATUS
        void   ICommStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3);
#else
#       define  ICommStatus(pTG, stat, uN1, uN2, uN3)
#endif

#ifdef FILET30
        void TSKEXPORT  NotifyRing(PThrdGlbl pTG, BOOL fStart);        // TRUE==start FALSE==stop
        void TSKEXPORT  EndOfCall(PThrdGlbl pTG, UWORD uErr);
        ULONG TSKEXPORT StartAnswer(PThrdGlbl pTG, BOOL fBG, BOOL fImmediate);

        void    ICommRawCaps(PThrdGlbl pTG, LPBYTE lpbCSI, LPBYTE lpbDIS, USHORT cbDIS,
                        LPFR FAR * rglpfrNSF, USHORT wNumFrames);

#       define ICommRecvBufIsEmpty(pTG)    (TRUE)

#else

        void   NotifyHandset(PThrdGlbl pTG, USHORT uOld, USHORT uNew);
        void       NotifyRing(PThrdGlbl pTG, BOOL fStart);
        void       EndOfCall(PThrdGlbl pTG, UWORD uErr);
        ULONG   StartAnswer(PThrdGlbl pTG, BOOL fBG, BOOL fImmediate);
        BOOL   ICommRecvBufIsEmpty(PThrdGlbl pTG);

#endif //FILET30
/***************** end of prototypes from icomfile.c *****************/


// flags for PutRecvBuf
#define RECV_STARTBLOCK         -1
#define RECV_STARTPAGE          -2
#define RECV_ENDPAGE            -3
#define RECV_ENDDOC             -4
#define RECV_SEQ                -5
#define RECV_SEQBAD             -6
#define RECV_FLUSH              -7
#define RECV_ENDDOC_FORCESAVE   -8

// flags for GetSendBuf
#define SEND_STARTBLOCK         -1
#define SEND_STARTPAGE          -2
#define SEND_QUERYENDPAGE       -3
#define SEND_SEQ                -4

#define SEND_ERROR              -1
#define SEND_EOF                 1
#define SEND_OK                  0


#ifdef PSI
        void   D_PSIFAXCheckMask(PThrdGlbl pTG, LPBYTE);
#else
#       define  D_PSIFAXCheckMask(pTG, arg)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\faxcodec.h ===
// Copyright (c) Microsoft Corp. 1992-94
/*==============================================================================
The prototypes in this header file define an API for the Fax Codec DLL.

DATE				NAME			COMMENTS
25-Nov-92		RajeevD   Created.
13-Apr-93		RajeevD		Changed to Bring Your Own Memory (BYOM :=) API.
01-Nov-93   RajeevD   Defined structure for initialization parameters.
21-Jan-94   RajeevD   Split FaxCodecRevBuf into BitReverseBuf and InvertBuf.
19-Jul-94   RajeevD   Added nTypeOut=NULL_DATA and FaxCodecCount.
==============================================================================*/
#ifndef _FAXCODEC_
#define _FAXCODEC_

#include <windows.h>
#include <buffers.h>

/*==============================================================================
The FC_PARAM structure specifies the conversion to be initialized.
This matrix indicates the valid combinations of nTypeIn and nTypeOut.

                             nTypeOut
                             
                 MH     MR     MMR    LRAW    NULL
                 
        MH               *      *       *      *

        MR       *              *       *      *
nTypeIn
        MMR      *       *              *

        LRAW     *       *      * 
        
==============================================================================*/
#ifdef WIN32
#pragma pack (push)
#pragma pack(1)
#endif

typedef struct
#ifdef __cplusplus
  FAR FC_PARAM
#endif
{
	DWORD nTypeIn;      // input data type:  {MH|MR|MMR|LRAW}_DATA
	DWORD nTypeOut;     // output type type: {MH|MR|MMR|LRAW|NULL}_DATA
	UINT  cbLine;       // scan line byte width (must be multiple of 4)
	UINT  nKFactor;     // K factor (significant for nTypeOut==MR_DATA)
}
	FC_PARAM, FAR *LPFC_PARAM;

#ifdef WIN32
#pragma pack(pop)
#endif

#ifdef __cplusplus
extern "C" {
#endif
/*==============================================================================
FaxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // size of context (0 on failure)
WINAPI FaxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

typedef UINT (WINAPI *LPFN_FAXCODECINIT)
	(LPVOID, LPFC_PARAM);

// Return codes for FaxCodecConvert
typedef UINT FC_STATUS;
#define FC_INPUT_EMPTY 0
#define FC_OUTPUT_FULL 1
#define FC_DECODE_ERR  4 // only for nTypeIn==MMR_DATA

/*==============================================================================
FaxCodecConvert() executes the conversion specified in FaxCodecInit().

In the input buffer, lpbBegData is advanced and wLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.  If the input type is LRAW_DATA, wLengthData must be a
multiple of 4.

In the output buffer, wLengthData is incremented as data is appended.  If the
output type is LRAW_DATA, an whole number of scan lines are produced.

To flush any output data at the end of a page, pass a NULL input buffer or a
zero length buffer with dwMetaData set to END_OF_PAGE.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // status
WINAPI FaxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);

typedef UINT (WINAPI *LPFN_FAXCODECCONVERT)
	(LPVOID, LPBUFFER, LPBUFFER);

/*==============================================================================
The FC_COUNT structure accumulates various counters during FaxCodecConvert.
==============================================================================*/
typedef struct
{
	DWORD cTotalGood;    // total good scan lines
	DWORD cTotalBad;     // total bad scan lines
	DWORD cMaxRunBad;    // maximum consecutive bad
}
	FC_COUNT, FAR *LPFC_COUNT;

/*==============================================================================
FaxCodecCount() reports and resets the internal counters.
==============================================================================*/
void WINAPI FaxCodecCount
(
	LPVOID     lpContext,
	LPFC_COUNT lpCount
);

typedef void (WINAPI *LPFN_FAXCODECCOUNT)
	(LPVOID, LPFC_COUNT);

/*==============================================================================
BitReverseBuf() performs a bit reversal of buffer data.  The dwMetaData field is
toggled between LRAW_DATA and HRAW_DATA.  As with all scan lines, the length 
of data (wLengthData) must be a 32-bit multiple.  For best performance the start
of the data (lpbBegData) should be 32-bit aligned and the data predominantly 0.
==============================================================================*/
void WINAPI BitReverseBuf (LPBUFFER lpbuf);

/*==============================================================================
InvertBuf() inverts buffer data.  As with all scan lines, the length of data 
(wLengthData) must be a 32-bit multiple.  For best performance, the start of 
data (lpbBegData) should be 32-bit aligned.
==============================================================================*/
void WINAPI InvertBuf (LPBUFFER lpbuf);

/*==============================================================================
FaxCodecChange() produces a change vector for an LRAW scan line.
==============================================================================*/
typedef short FAR* LPSHORT;

// Slack Parameters.
#define RAWBUF_SLACK 2
#define CHANGE_SLACK 12
#define OUTBUF_SLACK 16

extern void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,  // LRAW scan line
	UINT    cbLine,   // scan line width
  LPSHORT lpsChange // change vector
);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // _FAXCODEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\et30type.h ===
/**************************************************************************
    Name      : ET30TYPE.H
    Comment   : Types used in several et30 modules

    Copyright (c) Microsoft Corp. 1991, 1992, 1993

    Revision Log
    Num   Date      Name     Description
    --- -------- ---------- -----------------------------------------------
***************************************************************************/


#include <fr.h>

/****

typedef     BYTE far*       LPB;
typedef     LPB  far*       LPLPB;
typedef     WORD far*       LPWORD;
typedef     void far*       LPVOID;
typedef     signed short    SWORD;
typedef     signed long     SLONG;

typedef     LPBUFFER far*   LPLPBUFFER;

****/




/**** ERR values returned by GetLastError() ***
// used in T30
#define ERR_T1_TIMEOUT_SEND     41
#define ERR_T1_TIMEOUT_RECV     42
#define ERR_3TCFS_NOREPLY       43
#define ERR_3TCFS_DISDTC        44
#define ERR_TCF_BADREPLY        45 
#define ERR_3POSTPAGES_NOREPLY  46
#define ERR_T2_TIMEOUT          47

****/




typedef enum 
{                       
    actionNULL = 0,
    actionFALSE,        
    actionTRUE,
    actionERROR,
    actionHANGUP,
    actionDCN,
    actionGONODE_T,
    actionGONODE_R1,
    actionGONODE_R2,
    actionGONODE_A,     
    actionGONODE_D,     
    actionGONODE_E,
    actionGONODE_F,
    actionGONODE_I,     
    actionGONODE_II,    
    actionGONODE_III,
    actionGONODE_IV,    
    actionGONODE_V,     
    actionGONODE_VII,
    actionGONODE_RECVCMD,
    actionGONODE_ECMRETRANSMIT,
    actionGONODE_RECVPHASEC,
    actionGONODE_RECVECMRETRANSMIT,
    actionSEND_DIS,     
    actionSEND_DTC,     
    actionSEND_DCS,
    actionSENDMPS,      
    actionSENDEOM,      
    actionSENDEOP,
    actionSENDMCF,      
    actionSENDRTP,      
    actionSENDRTN,
    actionSENDFTT,      
    actionSENDCFR,      
    actionSENDEOR_EOP,
    actionGETTCF,       
    actionSKIPTCF,    
    actionSENDDCSTCF,   
    actionDCN_SUCCESS,  
    actionNODEF_SUCCESS,
    actionHANGUP_SUCCESS,
#ifdef PRI
    actionGONODE_RECVPRIQ,
    actionGOVOICE,
    actionSENDPIP,
    actionSENDPIN,
#endif
#ifdef IFP
    actionGONODE_IFP_SEND,  
    actionGONODE_IFP_RECV,
#endif
    actionNUM_ACTIONS,

} ET30ACTION;

LPCTSTR action_GetActionDescription(ET30ACTION);

typedef enum 
{
    eventNULL = 0,
    eventGOTFRAMES,
    eventNODE_A,
    eventSENDDCS,
    eventGOTFTT,
    eventGOTCFR,
    eventSTARTSEND,
    eventPOSTPAGE,
    eventGOTPOSTPAGERESP,
    eventGOT_ECM_PPS_RESP,
    eventSENDDIS,
    eventSENDDTC,
    eventRECVCMD,
    eventGOTTCF,
    eventSTARTRECV,
    eventRECVPOSTPAGECMD,
    eventECM_POSTPAGE,
    event4THPPR,
    eventNODE_T,
    eventNODE_R,
#ifdef PRI
    eventGOTPINPIP,
    eventVOICELINE,
    eventQUERYLOCALINT,
#endif
    eventNUM_EVENTS,

} ET30EVENT;

LPCTSTR event_GetEventDescription(ET30EVENT);

/** ifr indexes. These numbers must match the ones in hdlc.c.
 ** They must be consecutive, and start from 1
 **/

#define     ifrNULL     0
#define     ifrDIS      1
#define     ifrCSI      2
#define     ifrNSF      3
#define     ifrDTC      4
#define     ifrCIG      5
#define     ifrNSC      6
#define     ifrDCS      7
#define     ifrTSI      8
#define     ifrNSS      9
#define     ifrCFR      10
#define     ifrFTT      11
#define     ifrMPS      12
#define     ifrEOM      13
#define     ifrEOP      14
#define     ifrPWD      15
#define     ifrSEP      16
#define     ifrSUB      17
#define     ifrMCF      18
#define     ifrRTP      19
#define     ifrRTN      20
#define     ifrPIP      21
#define     ifrPIN      22
#define     ifrDCN      23
#define     ifrCRP      24 

#define     ifrPRI_MPS      25
#define     ifrPRI_EOM      26
#define     ifrPRI_EOP      27

#define     ifrPRI_FIRST    ifrPRI_MPS
#define     ifrPRI_LAST     ifrPRI_EOP

    /********* ECM stuff starts here. T.30 section A.4 ******/

#define     ifrCTC      28
#define     ifrCTR      29
#define     ifrRR       30
#define     ifrPPR      31
#define     ifrRNR      32
#define     ifrERR      33

#define     ifrPPS_NULL     34
#define     ifrPPS_MPS      35
#define     ifrPPS_EOM      36
#define     ifrPPS_EOP      37
#define     ifrPPS_PRI_MPS  38
#define     ifrPPS_PRI_EOM  39
#define     ifrPPS_PRI_EOP  40

#define     ifrPPS_FIRST        ifrPPS_NULL
#define     ifrPPS_LAST         ifrPPS_PRI_EOP
#define     ifrPPS_PRI_FIRST    ifrPPS_PRI_MPS
#define     ifrPPS_PRI_LAST     ifrPPS_PRI_EOP

#define     ifrEOR_NULL     41
#define     ifrEOR_MPS      42
#define     ifrEOR_EOM      43
#define     ifrEOR_EOP      44
#define     ifrEOR_PRI_MPS  45
#define     ifrEOR_PRI_EOM  46
#define     ifrEOR_PRI_EOP  47

#define     ifrEOR_FIRST        ifrEOR_NULL
#define     ifrEOR_LAST         ifrEOR_PRI_EOP
#define     ifrEOR_PRI_FIRST    ifrEOR_PRI_MPS
#define     ifrEOR_PRI_LAST     ifrEOR_PRI_EOP

#define     ifrECM_FIRST    ifrCTC
#define     ifrECM_LAST     ifrEOR_PRI_EOP

#define     ifrMAX      48      // Max legal values (not incl this one)
#define     ifrBAD      49
#define     ifrTIMEOUT  50
// #define      ifrERROR    51

LPCTSTR ifr_GetIfrDescription(BYTE);


/**** Global buffer mgmnt ****/


#define MAXFRAMESIZE    132

// #define ECM_FRAME_SIZE   256
// #define ECM_EXTRA        9   // 4 for prefix, 2 for suffix, 3 for slack in recv


#ifdef IFK
    // use same for 64 bytes frames also
#   define MY_ECMBUF_SIZE           BYTE_265_SIZE
#   define MY_ECMBUF_ACTUALSIZE     BYTE_265_ACTUALSIZE
#   define MY_BIGBUF_SIZE           BYTE_265_SIZE
#   define MY_BIGBUF_ACTUALSIZE     BYTE_265_ACTUALSIZE
#else //IFK
    // use same for 64 bytes frames also
#   define MY_ECMBUF_SIZE           (256 + 9)   
#   define MY_ECMBUF_ACTUALSIZE     (256 + 9)
#   define MY_BIGBUF_SIZE           (MY_ECMBUF_SIZE * 4)
#   define MY_BIGBUF_ACTUALSIZE     (MY_ECMBUF_SIZE * 4)
#endif //IFK


// too long
// #define PAGE_PREAMBLE    1700
// too long
// #define PAGE_PREAMBLE    400
// MUST BE LESS THAN 375 (TCF length at 2400bps)
// too short for slow 386/20 with Twincom at 9600
// #define PAGE_PREAMBLE   100

// too long
// #define PAGE_POSTAMBLE  500
// #define PAGE_POSTAMBLE  250

// Can all teh above. WE're going to make it a factor of the TCF len
// #define  PAGE_PREAMBLE_DIV   3   // 500ms preamble at all speeds
// let's be nice & safe & use 750ms (see bug#1196)
#define PAGE_PREAMBLE_DIV   2   // 750ms preamble at all speeds

// Postamble is not that important so use a smaller time
#define PAGE_POSTAMBLE_DIV  3   // 500ms preamble at all speeds
// #define  PAGE_POSTAMBLE_DIV  2   // 750ms preamble at all speeds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\debug.h ===
/*
 -  DEBUG.H
 -
 *      Debug-related definitions
 *
 *		Yoram Yaacovi, 11/93
 *		Taken from MAPI 1.0 sources
 *
 */

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It 
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define SzDecodeScode(_sc)	SzDecodeScodeFn(_sc)
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#define SzDecodeScode(_sc)	(0)
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#if defined (DEBUG)
#define	DEBUG_TRACE	DebugTraceFn
#define	EXTENDED_DEBUG_TRACE ExtendedDebugTraceFn
#else
#define DEBUG_TRACE
#define EXTENDED_DEBUG_TRACE
#endif

// Prototypes for debug functions in debug.c
#if !defined (__MAPIDBG_H_)
void			DebugTrap(void);
int __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int __cdecl		DebugTraceFn(char *pszFormat, ...);
int __cdecl		ExtendedDebugTraceFn(char *pszFormat, ...);
char * __cdecl	SzDecodeScodeFn(SCODE sc);
#endif
BOOL ExtendedDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\defs.h ===
/***************************************************************************
 Name     :	DEFS.H
 Comment  :	

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#pragma warning(disable:4001)   /** nonstd extensions **/
#pragma warning(error:4002)		// too many actual params for macro
#pragma warning(error:4003)     // too few actual params for macro
#pragma warning(error:4005)     // macro redefined
#pragma warning(error:4020)     // too many actual params for function
#pragma warning(error:4021)     // too few actual params for function


#pragma warning(disable:4050)	// different code attributes on fn ptr
#pragma warning(disable:4057)   // indirection to slightly different types
#pragma warning(disable:4101)   // unreferenced local variable
//// ignoring this warning resulted in bug when 'case' keyword was omitted!!//
// #pragma warning(disable:4102)   // unreferenced label
#pragma warning(disable:4135)   // conv between integral types
#pragma warning(disable:4200)   // nonstd ext: zero sized array in struct
#pragma warning(disable:4201)   // nonstd ext: nameless struct/union
#pragma warning(disable:4206)	// nonstd ext: trans unit is empty (whole file ifdefd out)
#pragma warning(disable:4209)	// nonstd ext: benign typedef redefinition
#pragma warning(disable:4214)   // nonstd ext: non-int bitfield
#pragma warning(disable:4704)   // inline asm precludes global optimization
#pragma warning(disable:4705)   // statement has no effect
#pragma warning(disable:4706)   // Assignment within conditional expression
#pragma warning(disable:4791)   // Loss of debugging info


#define UECM	// REQD!! DON'T DELETE EVER!! (This is incorrect-->use ECM for NON-EFAX G3 machines. (Ortho))
				// This directly controls the ECM bit in the DIS
#define PDUMP	// Protocol dump. Uses 500bytes extra. Ortho to all else


#if defined(WFW) || defined(WFWBG)
#   pragma  message ("Compiling for WFW")
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)
#endif //DEBUG
#	define FASTLOG	// recv file list/log is FASTER (REQD--old one doesn't work)
#	define VS		// Vertical Scaling in Send. (Ortho)
#	define NOPRE	// no pre-emption. Reqd for WFW. Useless for IF (Ortho)
#   define DYNL    	// Dynamic loading of DLLs. (WFW and !MDRV)
#   define VC       // uses VCOMM Comm driver thru DLLSCHED (WFW)
#   define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#   define CAS      // CAS support (Ortho)
#   define CL2      // Class2 support (Ortho)
#   define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
#   define CHK      // check recvd data using old or new FAXCODEC (req !REC)
#	define FILET30	// all file io & filet30 api
#	define FAXWATCH	// write out a FAXWATCH.LOG
#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#	define NEGOT	// do negotiation
#	define DOSIO	// use DOSIO calls thru DLLSCHED
#	define DISCARDFIX	// Declare discardable & fix in LibMain
//#	define  SEC         // recode send data to MR/MMR with new FAXCODEC. Doesn't work yet
//#	define  REC         // recode recv data with new FAXCODEC (!CHK and RECODE_TO). Doesn't work yet
//#	define  RECODE_TO	MH_DATA         // for old Pumps
//#	define  RECODE_TO	MMR_DATA        // for compactness
#endif //WFW || WFWBG


#if defined(IFAX) && !defined(WINPAD)
#  pragma message ("Compiling for IFAX")
#ifdef DEBUG
//#	define MON	// monitor bytes (Ortho)	// can't use it without KFIL or DOSIO
#endif //DEBUG
// #  define IFP


//  Receive spool options to control anti-RNR
#define RXSPOOLFIFO	// initiate receive spool FIFO if printer cannot keep up
#define END_PSIFAX_WHENFLUSHING		// early cleanup of PSIFAX when receive is
									// complete and FIFO is being flushed

#  define CHKDATA  // check recvd data in MSGSVR
#  define RECOVER // save recvd data in MSGSVR for later recovery
#  define RECOVER2 // continue recving after jobproc has croaked
#  define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#  define OEMNSF	// support fro OEMNSF DLLs
#  define RICOHAI 	// support fro Ricoh AI protocol (requires OEMNSF also)
#  define PSI	// PSI version--reqd to compile anything in PSIFAX dir
#  define TSK	// BGT30 is a Process. No DLLSCHED. REQD for some vague stuff in FCOM
#  define IFK	// Use IFKERNEL services (Alloc/Free etc)
#  define BOSS	// Make WEP FIXED etc...
//#define COMMCRIT	// put CritSection() around access to COMM.DRV
//#define CL2	// Use CL2 or 2.0 driver, not T30+ET30PROT+Class1/OEM driver
//#  define PCR	// PageCrit. Reqd for safe recv with Class1. (need !MDDI). BREAKS! with OEM modem drivers

//	The Cactus is a MDDI based on our Class1 driver. So we need PCR!
#if defined(CACTUS)
#	define PCR
#	pragma message("Enabling PCR for CACTUS")
#endif // CACTUS

#  define MDRV	// monolith drv. REQD for OEM driver (need !WFW & !DYNL). Incompatible with CL2. Optional for Class1.
#  define STATUS  // support for sending STATUS msgs. Optional.
#  define NVLOG	// log errors to NVRAM
// these two must be OFF for IFAX, ON for Winpad
// (if left on in IFAX UI & Transport use different option struct sizes)
//# define INIFILE // read INI file settings. Optional. (advisable for Cl1 & Cl2)
//# define PCMODEMS// read AT cmd INI file settings. Reqd for Class1 & CL2. (i.e. if not OEM driver or !MDDI) (need INIFILE also).
#endif  //IFAX && !WINPAD



#if defined(WINPAD)
#  pragma message ("Compiling for WINPAD")
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)	// can't use it without KFIL or DOSIO
#endif //DEBUG
#  define TSK	// BGT30 is a Process. No DLLSCHED. REQD for some vague stuff in FCOM
//#  define MDRV	// monolith drv. REQD for OEM driver (need !WFW & !DYNL). Incompatible with CL2. Optional for Class1.
#  define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#  define CL2      // Class2 support (Ortho)
//#  define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
//#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#  	define PSI	// PSI version--reqd to compile anything in PSIFAX dir
#  	define IFK	// Use IFKERNEL services (Alloc/Free etc)
#	define KFIL // use kernel file APIs
#	define COMMCRIT	// put CritSection() around access to COMM.DRV
#endif  //WINPAD



#if defined(WIN32)
#   pragma  message ("Compiling for WIN32")
#define AWG3	// Use AWG3 instead of MG3
#ifdef DEBUG
#	define MON	// monitor bytes (Ortho)
// Can't monitor bytes in WIN 32 -- why not?
#endif //DEBUG
#	define POLLREQ	// send poll req. (ortho)
#	define FASTLOG	// recv file list/log is FASTER (REQD--old one doesn't work)
#	define VS		// Vertical Scaling in Send. (Ortho)
//#	define NOPRE	// no pre-emption. Reqd for WFW. Useless for all others?
//#	define TSK		// BGT30 is a Process. No DLLSCHED. doesn't work in WIN32
#	define THREAD	// BGT30 becomes a WIN32 thread inside EFAXRUN
#   define DYNL    	// Dynamic loading of DLLs. (WFW and !MDRV)
//#   define VC       // uses VCOMM Comm driver thru DLLSCHED (WFW)
#   define LPZ      // CBSZ ptrs are far ptrs. Reqd for split driver/WFW
#   define CAS      // CAS support (Ortho)
#   define CL2      // Class2 support (Ortho)
#   define CL2_0   	// Class2.0 support (Ortho)
#   define PCR      // Page Critical. Reqd for safe recv. (!MDDI)
#   define CHK      // check recvd data using old or new FAXCODEC (req !REC)
#	define FILET30	// all file io & filet30 api
#	define FAXWATCH	// write out a FAXWATCH.LOG
#	define STATUS	// send out STATUS messages
#	define INIFILE	// read INI file settings
#	define PCMODEMS	// AT-cmd, serial modems
#	define NEGOT	// do negotiation
#	define KFIL	// use Kernel File Calls
#	define  SEC     // recode send MMR data to MR/MH with AWCODC32. Works now.
//#	define  REC         // recode recv data with new FAXCODEC (req NFC and !CHK and RECODE_TO). Doesn't work yet
//#	define  RECODE_TO	MH_DATA         // for old Pumps
//#	define  RECODE_TO	MMR_DATA        // for compactness
#	define IFDbgPrintf MyIFDbgPrintf	// +++ Redirect dbg msgs to efaxrun for now..
#	define METAPORT		// FCom can deal with port handles as well as port number.
#	define UNIMEXT		// Unimodem MCX aware
#	define TAPI			// TAPI aware
#	define COMPRESS		// Linearized messages are RejeevD-compressed.
#	define ADAPTIVE_ANSWER	// Ataptive-answer handoff to another TAPI app..
#	define USECAPI		// Capabilities saved via registry, not via
						// Post-message, textcaps, etc.
#	define MON3			// Extended COMM monitoring features (retail AND debug)
#	ifndef DEBUG
#	define SHIP_BUILD
#	endif // !DEBUG
#	ifdef DEBUG
#		define NSF_TEST_HOOKS	// hooks for testing NSF compatibility.
#	endif // DEBUG
# define PORTABLE_CODE
#endif // WIN32






//////// JUNE Demo IFAX /////////////////////////////////////////
//	#if defined(IFFGPROC) || defined(IFBGPROC)
//	#       pragma  message ("Compiling for IFAX")
//	#       define  MDRV    // monolithic driver. reqd for IF (!WFW & !DYNL)
//	#       define  TSK             // it's a Process--Can use win msging. No DLLSCHED
//	#       define  IFK             // Use IFKERNEL services (Alloc/Free etc)
//	#       define  KFIL    // Use Win Kernel FILEIO services
//	//#		define  PCR             // Page Critical. Reqd for safe recv. (!MDDI)
//	#       define  MDDI    // exact ModemDDI (rev 0.90)    (MDRV && T3TO && !DYNL)
//	#       define  T3TO    // use local timeouts (not from fcom) in T30 (MDDI)
//	#		define JUNE             // june 6th demo
//	#       define  FASTLOG 		// take this out along with JUNE
//	// #	ifdef DEBUG
//	// #       	define  MON             // monitor bytes (Ortho)
//	// #	endif //DEBUG
//	#endif  //IFFGPROC
/////////////////////////////////////////////////////////////////////						
// +++ josephj Ifaxos was changed so that DEBUGCHK calls DBGCHK,
//		which is not so harmful
//#ifdef DEBUG
//	// not safe to call in BG (snowball==>GPF, IFAX==>timing problems)
//#	define DEBUGCHK_UNSAFE_IN_WFWBG
//#	define DEBUGCHK		UNSAFE_IN_WFWBG
//#endif //DEBUG

#if (defined(CHK) && defined(REC))
#       error REC and CHK combination invalid
#endif
#if defined(MDDI) && !defined(MDRV)
#       error MDDI requires MDRV
#endif
#if defined(DYNL) && defined(MDRV)
#       error DYNL requires !MDRV
#endif
#if !defined(MDRV) && !defined(LPZ)
#       error !MDRV requires LPZ
#endif
#if !defined(LPZ)
#       error New modem-init scheme requires LPZ in _all_ builds
#endif

#if !defined(FILET30) && (defined(FASTLOG) || defined(FAXWATCH))
#       error NOFILE--cant have FASTLOG or FAXWATCH
#endif

#ifdef WIN32
#	ifdef IFK
#		error "IFK option illegal under WIN32"
#	endif
//#	ifndef TSK
//#		error "must use TSK in WIN32. Dllsched option NYI"
//#	endif
#	ifdef NOPRE
#		error NOPRE not supported in WIN32 (cant lockup machine)
#	endif
#endif

#ifdef TMR
#	error "TMR option no longer supported"
#endif



	
#ifdef DISCARDFIX
#	define	CODEFIXED	DISCARDABLE
#	define	DATAFIXED	FIXED
#else //DISCARDFIX
#	define	CODEFIXED	FIXED
#	define	DATAFIXED	FIXED
#endif // DISCARDFIX


#ifdef COMMENTS_NEED_TO_BE_REMOVED

/////////////////////////////////////// Tasking/Sleep/Timing options ///////
//
// There are 4 options available
// (1) Tasking/Sleeping thru DLLSCHED: #defs reqd are !TSK !TMR and !IFK
// (2) Tasking/Sleeping thru an IFKERNEL BGproc: #defs reqd TSK IFK and !TMR
// (3) Tasking thru WIN32: #defs reqd WIN32 TSK !IFK !TMR
// (4) Use WM_TIMERs to sleep: #defs reqd TSK TMR  -- NOT SUPPORTED anymore
//
/////////////////////////////////////// Tasking/Sleep/Timing options ///////


//######## GENERAL ##############################
//
// anything labelled (Ortho) is orthogonal to everything else and can be
//      added or removed independently. All others have conditions marked
//      or described below.
//
//
// WFW--requires VC and SMM and !IFK and !KFIL. Can use DYNL or not.
//              If DYNL used then LPZ is reqd & MDRV excluded
// IFF--requires MDRV and TSK and IFK and !DYNL. Can use TMR and/or NTF
//              but currently thats broken. Requires KFIL if any file calls are
//              made.
//
//
// TMR--use Timers & messaging (requires TSK)
// NTF--use WM_NOTIFY msgs also (requires TSK and TMR)
// DYNL & split drivers don't work with IF.
// DYNL and MDRV are mutually exclusive (though both can be absent)
//
//
// Modem Strings. Can use -D LPZ(far) CBZ(code-based) or nothing (near)
// for CBSZ ptrs, but the latter 2 work only with FCOM & CLASS1
// as one piece (i.e. with MDRV defined).
// For WFW--MUST be LPZ. For IF--can be nothing or LPZ. near is better
// CBZ doesn't work yet
//
//######## Debug ##############################
//
// MON-- monitor bytes to port, can be set orthogonal to DEBUG
// DEFS= $(DEFS) -DNOVCOM       ## don't use VCOMM (use with dummy DDRV)
//
//######## WFW specific ##############################
//
// WFW--assumes disk available for r/w during ECM
// only reasonable combos are (T30PROC and not WFW) and (not T30PROC and WFW)
// STATICM--never dynamically allocs. Must be set for WFW
// UCOM--call comm driver thru USER (not directly). Must *not* be set
//              for WFW. Probably don't use for IFF or IFB
//
//######## OBSOLETE BUT USABLE ##############################
//
// SLOW--double all timeouts,
// TO_REALLY_VERBOSE--trace every TO check
//
//######## TOTALLY OBSOLETE -- DO NOT USE ###############
//
// T3TO -- T30 timeouts are local (NPTOs) instead of from FCOM (now foled into MDDI)
//
//######## NOT TESTED IN A WHILE -- DO NOT USE ###############
//
// NCR--don't preempt during negotiation
// DYNMON -- monitor bufs are dynamically alloced. Must be off for WFW
// OLDECM -- old (non-seeking/non-buffered) ver of ECM
//
//######## BROKEN -- DO NOT USE ##############################
//
// Hack for RC224ATF
// DEFS= $(DEFS) -DS7H          ## don't turn this ON. It's broken & not reqd
//
//######## NOT YET IMPLEM ##########################
//
// RECVOEMNSF--not yet implem. Only for IFAX
// PRI--not yet implem, may never be
// USECRP--not tested, may never be
// MMR_AVAIL -- runtime rendering not yet implem. will be soon
//
//##################################################

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\errormod.h ===
#ifndef _ERRORMOD_H
#define _ERRORMOD_H


// IFKERNEL API's
#define API_IFK_ALLOCBUF	         0x0040
#define API_IFK_FREEBUF	            0x0080
#define API_IFK_MAKEBUFWRITABLE	   0x00c0
#define API_IFK_SHAREBUF	         0x0100
#define API_IFK_SPLITBUF	         0x0140

#define API_IFK_IFGLOBALALLOC       0x1000
#define API_IFK_IFGLOBALFREE        0x1040

#define API_IFK_CREATEIFPIPE	      0x2000
#define API_IFK_DELETEIFPIPE	      0x2040
#define API_IFK_OPENIFPIPE	         0x2080
#define API_IFK_CLOSEIFPIPE	      0x20c0
#define API_IFK_REQREADFROMIFPIPE	0x2100
#define API_IFK_REQWRITETOIFPIPE	   0x2140

#define API_IFK_NEWMEMUNIT	         0x3040

#define API_IFK_POSTMESSAGE	      0x4000
#define API_IFK_GETMESSAGE		      0x4040
#define API_IFK_PEEKMESSAGE	      0x4080
#define API_IFK_BROADCASTMESSAGE	   0x40c0

#define API_IFK_CREATEPROCESS       0x5000
#define API_IFK_TERMINATEAPP            0x5040
#define API_IFK_GETIFPROCWINDOW         0x5080
#define API_IFK_SETIFPROCPRIORITY       0x50C0
#define API_IFK_GETIFPROCPRIORITY       0x5100

#define API_IFK_CREATEMUTEX	            0x6000
#define API_IFK_RELEASEMUTEX	        0x6040
#define API_IFK_CREATEEVENT	            0x6080
#define API_IFK_SETEVENT		        0x60c0   
#define API_IFK_WAITFORSINGLEOBJECT	    0x6100
#define API_IFK_FREESYNCOBJECT	        0x6140
#define API_IFK_GETSETEVENTPARAM        0x6180

#define API_IFK_IFSETTIMER             0x7000


//IFSCAN APIs (High level scanner driver: error codes in prnscn.h)
#define	API_OPENSCANNER				0x0040
#define	API_CLOSESCANNER			0x0080
#define	API_STARTSCANJOB			0x00c0
#define	API_ENDSCANJOB				0x0100
#define	API_CONTINUESCANJOB			0x0200
#define	API_ABORTSCANJOB			0x0300
#define	API_GETSCANNERSTATUS		0x0400
#define API_GETSCANNERPAPERINFO	  	0x0500
#define	API_GETSCANIMAGEINFO		0x0600
#define	API_GETSCANNERCAPS			0x0700
#define	API_GETSCANNERCUSTOMCAPS	0x0800
#define	API_COMPLETESCANPAGE		0x0900
#define	API_GETSCANDEVICEINFO		0x0a00
#define	API_SELECTSCANDEVICE		0x0b00
#define	API_SCANDEVICEMODE			0x0c00
#define	API_INITIFSCAN				0x0d00
#define	API_SCANDIAGNOSTICJOB		0x0e00
#define	API_GETDEVINFOFROMID		0x0f00
#define	API_GETDEVINFOFROMSTR		0x1000
#define	API_GETDEVDEFAULTMODE		0x1100
#define API_SCANNERPREFEED			0x1200
#define API_STARTCOPYJOB			0x1300
#define API_ENDCOPYJOB				0x1400

//IFPRINT (high level printer drivers api: error codes in prnscn.h)
#define	API_SELECTPRINTDEVICE		0x0a00
#define	API_GETPRINTDEVICEINFO		0x0900
#define	API_PRINTDEVICEMODE			0x0b00
#define	API_PRINTDIAGNOSTICJOB		0x0c00
#define API_CHECKPRINTERSTATUS		0x0d00

//Awreport(the report engine)
#define	API_AWREPORTMESSAGE			0x0a00


//Remote Access APIs (Remote Access Apis)
//IPX
#define	API_PSINIT				0x0040
#define	API_INITIATEBIND		0x0080

//MAC
#define	API_MACINIT				0x0040


//Renderer APIs

#define	API_RENDEROPEN				0x0040
#define	API_RENDEREXECUTE			0x0080
#define	API_RENDERCLOSE				0x00c0


//  Message pump events disguised as APIs

                                       // APICODE BITS | ERRCODE BITS
#define API_JOBMESSAGE        0x0040   // 0000 0000 01 | 00 0000
#define API_JOBCOMPLETE       0x0080   // 0000 0000 10 | 00 0000
#define API_JOBERRCOMPLETE    0x00C0   // 0000 0000 11 | 00 0000

#define API_MPJOBCANCEL       0x0100   
#define API_MPREJECTMSG       0x0140   
#define API_MPANSWER          0x0180   
#define API_MPTRANSPORT       0x01C0   
#define API_MPPOLLRETRIEVE    0x0200   
#define API_MPDEST            0x0240   




// WINDOWS MODULE API's 
#define WERR_OK  0x0
#define WERR_GETVERSION 0x40
#define WERR_GETFREESPACE 0x80
#define WERR_GETCURRENTPDB 0xC0
#define WERR_GETWINDOWSDIRECTORY 0x100
#define WERR_GETSYSTEMDIRECTORY 0x140
#define WERR_GETFREESYSTEMRESOURCES 0x180
#define WERR_GETWINFLAGS 0x1C0
#define WERR_GETDOSENVIRONMENT 0x200
#define WERR_GETCURRENTTIME 0x240
#define WERR_GETTICKCOUNT 0x280
#define WERR_GETTIMERRESOLUTION 0x2C0
#define WERR_LOGERROR 0x300
#define WERR_LOGPARAMERROR 0x340
#define WERR_GETWINDEBUGINFO 0x380
#define WERR_SETWINDEBUGINFO 0x3C0
#define WERR_FATALEXIT 0x400
#define WERR_FATALAPPEXIT 0x440
#define WERR_EXITWINDOWS 0x480
#define WERR_EXITWINDOWSEXEC 0x4C0
#define WERR_DEBUGBREAK 0x500
#define WERR_OUTPUTDEBUGSTRING 0x540
#define WERR_SETERRORMODE 0x580
#define WERR_ISBADREADPTR 0x5C0
#define WERR_ISBADWRITEPTR 0x600
#define WERR_ISBADHUGEREADPTR 0x640
#define WERR_ISBADHUGEWRITEPTR 0x680
#define WERR_ISBADCODEPTR 0x6C0
#define WERR_ISBADSTRINGPTR 0x700
#define WERR_PROFINSCHK 0x740
#define WERR_PROFSETUP 0x780
#define WERR_PROFSAMPRATE 0x7C0
#define WERR_PROFSTART 0x800
#define WERR_PROFSTOP 0x840
#define WERR_PROFCLEAR 0x880
#define WERR_PROFFLUSH 0x8C0
#define WERR_PROFFINISH 0x900
#define WERR_CATCH 0x940
#define WERR_THROW 0x980
#define WERR_SWITCHSTACKBACK 0x9C0
#define WERR_SWITCHSTACKTO 0xA00
#define WERR_LOADMODULE 0xA40
#define WERR_FREEMODULE 0xA80
#define WERR_LOADLIBRARY 0xAC0
#define WERR_FREELIBRARY 0xB00
#define WERR_WINEXEC 0xB40
#define WERR_GETMODULEHANDLE 0xB80
#define WERR_GETMODULEUSAGE 0xBC0
#define WERR_GETMODULEFILENAME 0xC00
#define WERR_GETPROCADDRESS 0xC40
#define WERR_GETINSTANCEDATA 0xC80
#define WERR_GETCODEHANDLE 0xCC0
#define WERR_GETCODEINFO 0xD00
#define WERR_MAKEPROCINSTANCE 0xD40
#define WERR_FREEPROCINSTANCE 0xD80
#define WERR_SETSWAPAREASIZE 0xDC0
#define WERR_SWAPRECORDING 0xE00
#define WERR_VALIDATECODESEGMENTS 0xE40
#define WERR_GETNUMTASKS 0xE80
#define WERR_ISTASK 0xEC0
#define WERR_GETCURRENTTASK 0xF00
#define WERR_YIELD 0xF40
#define WERR_DIRECTEDYIELD 0xF80
#define WERR_GLOBALALLOC 0xFC0
#define WERR_GLOBALREALLOC 0x1000
#define WERR_GLOBALFREE 0x1040
#define WERR_GLOBALDOSALLOC 0x1080
#define WERR_GLOBALDOSFREE 0x10C0
#define WERR_GLOBALLOCK 0x1100
//#define WERR_GLOBALLOCK 0x1140
#define WERR_GLOBALUNLOCK 0x1180
#define WERR_GLOBALSIZE 0x11C0
#define WERR_GLOBALHANDLE 0x1200
#define WERR_GLOBALFLAGS 0x1240
#define WERR_GLOBALWIRE 0x1280
//#define WERR_GLOBALWIRE 0x12C0
#define WERR_GLOBALUNWIRE 0x1300
#define WERR_GLOBALPAGELOCK 0x1340
#define WERR_GLOBALPAGEUNLOCK 0x1380
#define WERR_GLOBALFIX 0x13C0
#define WERR_GLOBALUNFIX 0x1400
#define WERR_GLOBALLRUNEWEST 0x1440
#define WERR_GLOBALLRUOLDEST 0x1480
#define WERR_GLOBALCOMPACT 0x14C0
#define WERR_GLOBALNOTIFY 0x1500
#define WERR_LOCKSEGMENT 0x1540
#define WERR_UNLOCKSEGMENT 0x1580
#define WERR_ALLOCSELECTOR 0x15C0
#define WERR_FREESELECTOR 0x1600
#define WERR_ALLOCDSTOCSALIAS 0x1640
#define WERR_PRESTOCHANGOSELECTOR 0x1680
#define WERR_GETSELECTORBASE 0x16C0
#define WERR_SETSELECTORBASE 0x1700
#define WERR_GETSELECTORLIMIT 0x1740
#define WERR_SETSELECTORLIMIT 0x1780
#define WERR_LIMITEMSPAGES 0x17C0
#define WERR_VALIDATEFREESPACES 0x1800
#define WERR_LOCALALLOC 0x1840
#define WERR_LOCALREALLOC 0x1880
#define WERR_LOCALFREE 0x18C0
#define WERR_LOCALLOCK 0x1900
//#define WERR_LOCALLOCK 0x1940
#define WERR_LOCALUNLOCK 0x1980
#define WERR_LOCALSIZE 0x19C0
#define WERR_LOCALHANDLE 0x1A00
//#define WERR_LOCALHANDLE 0x1A40
#define WERR_LOCALFLAGS 0x1A80
#define WERR_LOCALINIT 0x1AC0
#define WERR_LOCALCOMPACT 0x1B00
#define WERR_LOCALSHRINK 0x1B40
#define WERR_OPENFILE 0x1B80
#define WERR__LOPEN 0x1BC0
#define WERR__LCREAT 0x1C00
#define WERR__LCLOSE 0x1C40
#define WERR__LLSEEK 0x1C80
#define WERR__LREAD 0x1CC0
#define WERR__LWRITE 0x1D00
#define WERR__HREAD 0x1D40
#define WERR__HWRITE 0x1D80
#define WERR_GETTEMPFILENAME 0x1DC0
#define WERR_GETTEMPDRIVE 0x1E00
#define WERR_GETDRIVETYPE 0x1E40
#define WERR_SETHANDLECOUNT 0x1E80
#define WERR_WNETADDCONNECTION 0x1EC0
#define WERR_WNETGETCONNECTION 0x1F00
#define WERR_WNETCANCELCONNECTION 0x1F40
#define WERR_FINDRESOURCE 0x1F80
#define WERR_LOADRESOURCE 0x1FC0
#define WERR_FREERESOURCE 0x2000
#define WERR_LOCKRESOURCE 0x2040
//#define WERR_LOCKRESOURCE 0x2080
#define WERR_SIZEOFRESOURCE 0x20C0
#define WERR_ACCESSRESOURCE 0x2100
#define WERR_ALLOCRESOURCE 0x2140
#define WERR_SETRESOURCEHANDLER 0x2180
#define WERR_INITATOMTABLE 0x21C0
#define WERR_ADDATOM 0x2200
#define WERR_DELETEATOM 0x2240
#define WERR_FINDATOM 0x2280
#define WERR_GETATOMNAME 0x22C0
#define WERR_GLOBALADDATOM 0x2300
#define WERR_GLOBALDELETEATOM 0x2340
#define WERR_GLOBALFINDATOM 0x2380
#define WERR_GLOBALGETATOMNAME 0x23C0
#define WERR_GETATOMHANDLE 0x2400
#define WERR_GETPROFILEINT 0x2440
#define WERR_GETPROFILESTRING 0x2480
#define WERR_WRITEPROFILESTRING 0x24C0
#define WERR_GETPRIVATEPROFILEINT 0x2500
#define WERR_GETPRIVATEPROFILESTRING 0x2540
#define WERR_WRITEPRIVATEPROFILESTRING 0x2580
#define WERR_ANSITOOEM 0x25C0
#define WERR_OEMTOANSI 0x2600
#define WERR_ANSITOOEMBUFF 0x2640
#define WERR_OEMTOANSIBUFF 0x2680
#define WERR_ANSINEXT 0x26C0
#define WERR_ANSIPREV 0x2700
#define WERR_ANSIUPPER 0x2740
#define WERR_ANSILOWER 0x2780
#define WERR_ANSIUPPERBUFF 0x27C0
#define WERR_ANSILOWERBUFF 0x2800
#define WERR_ISCHARALPHA 0x2840
#define WERR_ISCHARALPHANUMERIC 0x2880
#define WERR_ISCHARUPPER 0x28C0
#define WERR_ISCHARLOWER 0x2900
#define WERR_LSTRCMP 0x2940
#define WERR_LSTRCMPI 0x2980
#define WERR_LSTRCPY 0x29C0
#define WERR_LSTRCAT 0x2A00
#define WERR_LSTRLEN 0x2A40
#define WERR_LSTRCPYN 0x2A80
#define WERR_HMEMCPY 0x2AC0
#define WERR_ISDBCSLEADBYTE 0x2B00
#define WERR_LOADSTRING 0x2B40
#define WERR_OEMKEYSCAN 0x2B80
#define WERR_VKKEYSCAN 0x2BC0
#define WERR_GETKEYBOARDTYPE 0x2C00
#define WERR_MAPVIRTUALKEY 0x2C40
#define WERR_GETKBCODEPAGE 0x2C80
#define WERR_GETKEYNAMETEXT 0x2CC0
#define WERR_TOASCII 0x2D00
#define WERR_CREATEDC 0x2D40
#define WERR_CREATEIC 0x2D80
#define WERR_CREATECOMPATIBLEDC 0x2DC0
#define WERR_DELETEDC 0x2E00
#define WERR_GETDCORG 0x2E40
#define WERR_SAVEDC 0x2E80
#define WERR_RESTOREDC 0x2EC0
#define WERR_SETENVIRONMENT 0x2F00
#define WERR_GETENVIRONMENT 0x2F40
#define WERR_MULDIV 0x2F80
#define WERR_SETBOUNDSRECT 0x2FC0
#define WERR_GETBOUNDSRECT 0x3000
#define WERR_GETDEVICECAPS 0x3040
#define WERR_SETMAPMODE 0x3080
#define WERR_GETMAPMODE 0x30C0
#define WERR_SETWINDOWORG 0x3100
#define WERR_GETWINDOWORG 0x3140
#define WERR_SETWINDOWEXT 0x3180
#define WERR_GETWINDOWEXT 0x31C0
#define WERR_OFFSETWINDOWORG 0x3200
#define WERR_SCALEWINDOWEXT 0x3240
#define WERR_SETVIEWPORTORG 0x3280
#define WERR_GETVIEWPORTORG 0x32C0
#define WERR_SETVIEWPORTEXT 0x3300
#define WERR_GETVIEWPORTEXT 0x3340
#define WERR_OFFSETVIEWPORTORG 0x3380
#define WERR_SCALEVIEWPORTEXT 0x33C0
#define WERR_SETWINDOWORGEX 0x3400
#define WERR_GETWINDOWORGEX 0x3440
#define WERR_SETWINDOWEXTEX 0x3480
#define WERR_GETWINDOWEXTEX 0x34C0
#define WERR_OFFSETWINDOWORGEX 0x3500
#define WERR_SCALEWINDOWEXTEX 0x3540
#define WERR_SETVIEWPORTEXTEX 0x3580
#define WERR_GETVIEWPORTEXTEX 0x35C0
#define WERR_SETVIEWPORTORGEX 0x3600
#define WERR_GETVIEWPORTORGEX 0x3640
#define WERR_OFFSETVIEWPORTORGEX 0x3680
#define WERR_SCALEVIEWPORTEXTEX 0x36C0
#define WERR_DPTOLP 0x3700
#define WERR_LPTODP 0x3740
#define WERR_GETNEARESTCOLOR 0x3780
#define WERR_GETSYSCOLOR 0x37C0
#define WERR_SETSYSCOLORS 0x3800
#define WERR_GETSTOCKOBJECT 0x3840
#define WERR_ISGDIOBJECT 0x3880
#define WERR_DELETEOBJECT 0x38C0
#define WERR_SELECTOBJECT 0x3900
#define WERR_GETOBJECT 0x3940
#define WERR_UNREALIZEOBJECT 0x3980
#define WERR_ENUMOBJECTS 0x39C0
//#define WERR_ENUMOBJECTS 0x3A00
#define WERR_CREATEPEN 0x3A40
#define WERR_CREATEPENINDIRECT 0x3A80
#define WERR_CREATESOLIDBRUSH 0x3AC0
#define WERR_CREATEHATCHBRUSH 0x3B00
#define WERR_CREATEPATTERNBRUSH 0x3B40
#define WERR_CREATEDIBPATTERNBRUSH 0x3B80
#define WERR_CREATEBRUSHINDIRECT 0x3BC0
#define WERR_SETBRUSHORG 0x3C00
#define WERR_GETBRUSHORG 0x3C40
#define WERR_GETBRUSHORGEX 0x3C80
#define WERR_CREATERECTRGN 0x3CC0
#define WERR_CREATERECTRGNINDIRECT 0x3D00
#define WERR_CREATEELLIPTICRGNINDIRECT 0x3D40
#define WERR_CREATEELLIPTICRGN 0x3D80
#define WERR_CREATEPOLYGONRGN 0x3DC0
#define WERR_CREATEPOLYPOLYGONRGN 0x3E00
#define WERR_CREATEROUNDRECTRGN 0x3E40
#define WERR_SETRECTRGN 0x3E80
#define WERR_COMBINERGN 0x3EC0
#define WERR_EQUALRGN 0x3F00
#define WERR_OFFSETRGN 0x3F40
#define WERR_GETRGNBOX 0x3F80
#define WERR_RECTINREGION 0x3FC0
#define WERR_PTINREGION 0x4000
#define WERR_CREATEPALETTE 0x4040
#define WERR_SELECTPALETTE 0x4080
#define WERR_REALIZEPALETTE 0x40C0
#define WERR_UPDATECOLORS 0x4100
#define WERR_ANIMATEPALETTE 0x4140
#define WERR_SETPALETTEENTRIES 0x4180
#define WERR_GETPALETTEENTRIES 0x41C0
#define WERR_GETNEARESTPALETTEINDEX 0x4200
#define WERR_RESIZEPALETTE 0x4240
#define WERR_GETSYSTEMPALETTEENTRIES 0x4280
#define WERR_GETSYSTEMPALETTEUSE 0x42C0
#define WERR_SETSYSTEMPALETTEUSE 0x4300
#define WERR_SELECTCLIPRGN 0x4340
#define WERR_GETCLIPBOX 0x4380
#define WERR_INTERSECTCLIPRECT 0x43C0
#define WERR_OFFSETCLIPRGN 0x4400
#define WERR_EXCLUDECLIPRECT 0x4440
#define WERR_PTVISIBLE 0x4480
#define WERR_RECTVISIBLE 0x44C0
#define WERR_MOVETO 0x4500
#define WERR_GETCURRENTPOSITION 0x4540
#define WERR_MOVETOEX 0x4580
#define WERR_GETCURRENTPOSITIONEX 0x45C0
#define WERR_LINETO 0x4600
#define WERR_POLYLINE 0x4640
#define WERR_LINEDDA 0x4680
#define WERR_RECTANGLE 0x46C0
#define WERR_ROUNDRECT 0x4700
#define WERR_ELLIPSE 0x4740
#define WERR_ARC 0x4780
#define WERR_CHORD 0x47C0
#define WERR_PIE 0x4800
#define WERR_POLYGON 0x4840
#define WERR_POLYPOLYGON 0x4880
#define WERR_SETPOLYFILLMODE 0x48C0
#define WERR_GETPOLYFILLMODE 0x4900
#define WERR_FLOODFILL 0x4940
#define WERR_EXTFLOODFILL 0x4980
#define WERR_FILLRGN 0x49C0
#define WERR_FRAMERGN 0x4A00
#define WERR_INVERTRGN 0x4A40
#define WERR_PAINTRGN 0x4A80
#define WERR_FILLRECT 0x4AC0
#define WERR_FRAMERECT 0x4B00
#define WERR_INVERTRECT 0x4B40
#define WERR_DRAWFOCUSRECT 0x4B80
#define WERR_TEXTOUT 0x4BC0
#define WERR_TABBEDTEXTOUT 0x4C00
#define WERR_EXTTEXTOUT 0x4C40
#define WERR_GETTEXTEXTENT 0x4C80
#define WERR_GETTABBEDTEXTEXTENT 0x4CC0
#define WERR_GETTEXTEXTENTPOINT 0x4D00
#define WERR_DRAWTEXT 0x4D40
#define WERR_GRAYSTRING 0x4D80
#define WERR_GETCHARWIDTH 0x4DC0
#define WERR_SETTEXTCOLOR 0x4E00
#define WERR_GETTEXTCOLOR 0x4E40
#define WERR_SETBKCOLOR 0x4E80
#define WERR_GETBKCOLOR 0x4EC0
#define WERR_SETBKMODE 0x4F00
#define WERR_GETBKMODE 0x4F40
#define WERR_SETTEXTALIGN 0x4F80
#define WERR_GETTEXTALIGN 0x4FC0
#define WERR_SETTEXTCHARACTEREXTRA 0x5000
#define WERR_GETTEXTCHARACTEREXTRA 0x5040
#define WERR_SETTEXTJUSTIFICATION 0x5080
#define WERR_CREATEFONT 0x50C0
#define WERR_CREATEFONTINDIRECT 0x5100
#define WERR_SETMAPPERFLAGS 0x5140
#define WERR_ADDFONTRESOURCE 0x5180
#define WERR_REMOVEFONTRESOURCE 0x51C0
#define WERR_GETTEXTFACE 0x5200
#define WERR_GETASPECTRATIOFILTER 0x5240
#define WERR_GETASPECTRATIOFILTEREX 0x5280
#define WERR_GETTEXTMETRICS 0x52C0
#define WERR_GETOUTLINETEXTMETRICS 0x5300
#define WERR_ENUMFONTFAMILIES 0x5340
#define WERR_ENUMFONTS 0x5380
//#define WERR_ENUMFONTS 0x53C0
//#define WERR_ENUMFONTFAMILIES 0x5400
#define WERR_GETFONTDATA 0x5440
#define WERR_CREATESCALABLEFONTRESOURCE 0x5480
#define WERR_GETGLYPHOUTLINE 0x54C0
#define WERR_GETCHARABCWIDTHS 0x5500
#define WERR_GETKERNINGPAIRS 0x5540
#define WERR_GETRASTERIZERCAPS 0x5580
#define WERR_CREATEBITMAP 0x55C0
#define WERR_CREATEBITMAPINDIRECT 0x5600
#define WERR_CREATECOMPATIBLEBITMAP 0x5640
#define WERR_CREATEDISCARDABLEBITMAP 0x5680
#define WERR_CREATEDIBITMAP 0x56C0
#define WERR_LOADBITMAP 0x5700
#define WERR_BITBLT 0x5740
#define WERR_PATBLT 0x5780
#define WERR_STRETCHBLT 0x57C0
#define WERR_STRETCHDIBITS 0x5800
#define WERR_SETPIXEL 0x5840
#define WERR_GETPIXEL 0x5880
#define WERR_SETSTRETCHBLTMODE 0x58C0
#define WERR_GETSTRETCHBLTMODE 0x5900
#define WERR_SETBITMAPDIMENSION 0x5940
#define WERR_GETBITMAPDIMENSION 0x5980
#define WERR_SETBITMAPDIMENSIONEX 0x59C0
#define WERR_GETBITMAPDIMENSIONEX 0x5A00
#define WERR_SETROP2 0x5A40
#define WERR_GETROP2 0x5A80
#define WERR_SETBITMAPBITS 0x5AC0
#define WERR_GETBITMAPBITS 0x5B00
#define WERR_SETDIBITS 0x5B40
#define WERR_GETDIBITS 0x5B80
#define WERR_SETDIBITSTODEVICE 0x5BC0
#define WERR_CREATEMETAFILE 0x5C00
#define WERR_CLOSEMETAFILE 0x5C40
#define WERR_GETMETAFILE 0x5C80
#define WERR_DELETEMETAFILE 0x5CC0
#define WERR_COPYMETAFILE 0x5D00
#define WERR_PLAYMETAFILE 0x5D40
#define WERR_GETMETAFILEBITS 0x5D80
#define WERR_SETMETAFILEBITS 0x5DC0
#define WERR_SETMETAFILEBITSBETTER 0x5E00
#define WERR_PLAYMETAFILERECORD 0x5E40
#define WERR_ENUMMETAFILE 0x5E80
#define WERR_STARTDOC 0x5EC0
#define WERR_STARTPAGE 0x5F00
#define WERR_ENDPAGE 0x5F40
#define WERR_ENDDOC 0x5F80
#define WERR_ABORTDOC 0x5FC0
#define WERR_SETABORTPROC 0x6000
#define WERR_SPOOLFILE 0x6040
#define WERR_QUERYABORT 0x6080
#define WERR_ESCAPE 0x60C0
#define WERR_GETSYSTEMMETRICS 0x6100
#define WERR_GETDOUBLECLICKTIME 0x6140
#define WERR_SETDOUBLECLICKTIME 0x6180
#define WERR_SYSTEMPARAMETERSINFO 0x61C0
#define WERR_SETRECT 0x6200
#define WERR_SETRECTEMPTY 0x6240
#define WERR_COPYRECT 0x6280
#define WERR_ISRECTEMPTY 0x62C0
#define WERR_EQUALRECT 0x6300
#define WERR_INTERSECTRECT 0x6340
#define WERR_UNIONRECT 0x6380
#define WERR_SUBTRACTRECT 0x63C0
#define WERR_OFFSETRECT 0x6400
#define WERR_INFLATERECT 0x6440
#define WERR_PTINRECT 0x6480
#define WERR_REGISTERWINDOWMESSAGE 0x64C0
#define WERR_GETMESSAGE 0x6500
#define WERR_PEEKMESSAGE 0x6540
#define WERR_WAITMESSAGE 0x6580
#define WERR_GETMESSAGEPOS 0x65C0
#define WERR_GETMESSAGETIME 0x6600
#define WERR_GETMESSAGEEXTRAINFO 0x6640
#define WERR_TRANSLATEMESSAGE 0x6680
#define WERR_DISPATCHMESSAGE 0x66C0
#define WERR_SETMESSAGEQUEUE 0x6700
#define WERR_GETINPUTSTATE 0x6740
#define WERR_GETQUEUESTATUS 0x6780
#define WERR_POSTMESSAGE 0x67C0
#define WERR_SENDMESSAGE 0x6800
#define WERR_POSTAPPMESSAGE 0x6840
#define WERR_REPLYMESSAGE 0x6880
#define WERR_INSENDMESSAGE 0x68C0
#define WERR_CALLMSGFILTER 0x6900
#define WERR_POSTQUITMESSAGE 0x6940
#define WERR_REGISTERCLASS 0x6980
#define WERR_UNREGISTERCLASS 0x69C0
#define WERR_GETCLASSINFO 0x6A00
#define WERR_GETCLASSNAME 0x6A40
#define WERR_GETCLASSWORD 0x6A80
#define WERR_SETCLASSWORD 0x6AC0
#define WERR_GETCLASSLONG 0x6B00
#define WERR_SETCLASSLONG 0x6B40
#define WERR_ISWINDOW 0x6B80
#define WERR_CREATEWINDOWEX 0x6BC0
#define WERR_CREATEWINDOW 0x6C00
#define WERR_DESTROYWINDOW 0x6C40
#define WERR_GETWINDOWTASK 0x6C80
#define WERR_ISCHILD 0x6CC0
#define WERR_GETPARENT 0x6D00
#define WERR_SETPARENT 0x6D40
#define WERR_ISWINDOWVISIBLE 0x6D80
#define WERR_SHOWWINDOW 0x6DC0
#define WERR_ENABLEWINDOW 0x6E00
#define WERR_ISWINDOWENABLED 0x6E40
#define WERR_SETWINDOWTEXT 0x6E80
#define WERR_GETWINDOWTEXT 0x6EC0
#define WERR_GETWINDOWTEXTLENGTH 0x6F00
#define WERR_GETWINDOWWORD 0x6F40
#define WERR_SETWINDOWWORD 0x6F80
#define WERR_GETWINDOWLONG 0x6FC0
#define WERR_SETWINDOWLONG 0x7000
#define WERR_GETCLIENTRECT 0x7040
#define WERR_GETWINDOWRECT 0x7080
#define WERR_GETWINDOWPLACEMENT 0x70C0
#define WERR_SETWINDOWPLACEMENT 0x7100
#define WERR_SETWINDOWPOS 0x7140
#define WERR_BEGINDEFERWINDOWPOS 0x7180
#define WERR_DEFERWINDOWPOS 0x71C0
#define WERR_ENDDEFERWINDOWPOS 0x7200
#define WERR_MOVEWINDOW 0x7240
#define WERR_BRINGWINDOWTOTOP 0x7280
#define WERR_DEFWINDOWPROC 0x72C0
#define WERR_CALLWINDOWPROC 0x7300
//#define WERR_CALLWINDOWPROC 0x7340
#define WERR_ADJUSTWINDOWRECT 0x7380
#define WERR_ADJUSTWINDOWRECTEX 0x73C0
#define WERR_FLASHWINDOW 0x7400
#define WERR_SHOWOWNEDPOPUPS 0x7440
#define WERR_OPENICON 0x7480
#define WERR_CLOSEWINDOW 0x74C0
#define WERR_ANYPOPUP 0x7500
#define WERR_ISICONIC 0x7540
#define WERR_ISZOOMED 0x7580
#define WERR_CLIENTTOSCREEN 0x75C0
#define WERR_SCREENTOCLIENT 0x7600
#define WERR_MAPWINDOWPOINTS 0x7640
#define WERR_WINDOWFROMPOINT 0x7680
#define WERR_CHILDWINDOWFROMPOINT 0x76C0
#define WERR_GETDESKTOPWINDOW 0x7700
#define WERR_FINDWINDOW 0x7740
#define WERR_ENUMWINDOWS 0x7780
#define WERR_ENUMCHILDWINDOWS 0x77C0
#define WERR_ENUMTASKWINDOWS 0x7800
#define WERR_GETTOPWINDOW 0x7840
#define WERR_GETWINDOW 0x7880
#define WERR_GETNEXTWINDOW 0x78C0
#define WERR_SETPROP 0x7900
#define WERR_GETPROP 0x7940
#define WERR_REMOVEPROP 0x7980
#define WERR_ENUMPROPS 0x79C0
#define WERR_GETDC 0x7A00
#define WERR_RELEASEDC 0x7A40
#define WERR_GETWINDOWDC 0x7A80
#define WERR_GETDCEX 0x7AC0
#define WERR_BEGINPAINT 0x7B00
#define WERR_ENDPAINT 0x7B40
#define WERR_UPDATEWINDOW 0x7B80
#define WERR_EXCLUDEUPDATERGN 0x7BC0
#define WERR_LOCKWINDOWUPDATE 0x7C00
#define WERR_GETUPDATERECT 0x7C40
#define WERR_GETUPDATERGN 0x7C80
#define WERR_INVALIDATERECT 0x7CC0
#define WERR_VALIDATERECT 0x7D00
#define WERR_INVALIDATERGN 0x7D40
#define WERR_VALIDATERGN 0x7D80
#define WERR_REDRAWWINDOW 0x7DC0
#define WERR_SCROLLWINDOW 0x7E00
#define WERR_SCROLLDC 0x7E40
#define WERR_SCROLLWINDOWEX 0x7E80
#define WERR_SETACTIVEWINDOW 0x7EC0
#define WERR_GETACTIVEWINDOW 0x7F00
#define WERR_GETLASTACTIVEPOPUP 0x7F40
#define WERR_SETFOCUS 0x7F80
#define WERR_GETFOCUS 0x7FC0
#define WERR_GETKEYSTATE 0x8000
#define WERR_GETASYNCKEYSTATE 0x8040
#define WERR_GETKEYBOARDSTATE 0x8080
#define WERR_SETKEYBOARDSTATE 0x80C0
#define WERR_SETCAPTURE 0x8100
#define WERR_RELEASECAPTURE 0x8140
#define WERR_GETCAPTURE 0x8180
#define WERR_SWAPMOUSEBUTTON 0x81C0
#define WERR_GETSYSMODALWINDOW 0x8200
#define WERR_SETSYSMODALWINDOW 0x8240
#define WERR_SETTIMER 0x8280
#define WERR_KILLTIMER 0x82C0
#define WERR_LOADACCELERATORS 0x8300
#define WERR_TRANSLATEACCELERATOR 0x8340
#define WERR_ISMENU 0x8380
#define WERR_CREATEMENU 0x83C0
#define WERR_CREATEPOPUPMENU 0x8400
#define WERR_LOADMENU 0x8440
#define WERR_LOADMENUINDIRECT 0x8480
#define WERR_DESTROYMENU 0x84C0
#define WERR_GETMENU 0x8500
#define WERR_SETMENU 0x8540
#define WERR_GETSYSTEMMENU 0x8580
#define WERR_DRAWMENUBAR 0x85C0
#define WERR_HILITEMENUITEM 0x8600
#define WERR_INSERTMENU 0x8640
#define WERR_APPENDMENU 0x8680
#define WERR_MODIFYMENU 0x86C0
#define WERR_REMOVEMENU 0x8700
#define WERR_DELETEMENU 0x8740
#define WERR_CHANGEMENU 0x8780
#define WERR_ENABLEMENUITEM 0x87C0
#define WERR_CHECKMENUITEM 0x8800
#define WERR_GETSUBMENU 0x8840
#define WERR_GETMENUITEMCOUNT 0x8880
#define WERR_GETMENUITEMID 0x88C0
#define WERR_GETMENUSTRING 0x8900
#define WERR_GETMENUSTATE 0x8940
#define WERR_SETMENUITEMBITMAPS 0x8980
#define WERR_GETMENUCHECKMARKDIMENSIONS 0x89C0
#define WERR_TRACKPOPUPMENU 0x8A00
#define WERR_SETSCROLLPOS 0x8A40
#define WERR_GETSCROLLPOS 0x8A80
#define WERR_SETSCROLLRANGE 0x8AC0
#define WERR_GETSCROLLRANGE 0x8B00
#define WERR_SHOWSCROLLBAR 0x8B40
#define WERR_ENABLESCROLLBAR 0x8B80
#define WERR_OPENCLIPBOARD 0x8BC0
#define WERR_CLOSECLIPBOARD 0x8C00
#define WERR_EMPTYCLIPBOARD 0x8C40
#define WERR_GETOPENCLIPBOARDWINDOW 0x8C80
#define WERR_GETCLIPBOARDOWNER 0x8CC0
#define WERR_SETCLIPBOARDVIEWER 0x8D00
#define WERR_GETCLIPBOARDVIEWER 0x8D40
#define WERR_SETCLIPBOARDDATA 0x8D80
#define WERR_GETCLIPBOARDDATA 0x8DC0
#define WERR_ISCLIPBOARDFORMATAVAILABLE 0x8E00
#define WERR_GETPRIORITYCLIPBOARDFORMAT 0x8E40
#define WERR_REGISTERCLIPBOARDFORMAT 0x8E80
#define WERR_COUNTCLIPBOARDFORMATS 0x8EC0
#define WERR_ENUMCLIPBOARDFORMATS 0x8F00
#define WERR_GETCLIPBOARDFORMATNAME 0x8F40
#define WERR_CHANGECLIPBOARDCHAIN 0x8F80
#define WERR_LOADCURSOR 0x8FC0
#define WERR_CREATECURSOR 0x9000
#define WERR_DESTROYCURSOR 0x9040
#define WERR_COPYCURSOR 0x9080
#define WERR_SHOWCURSOR 0x90C0
#define WERR_SETCURSORPOS 0x9100
#define WERR_GETCURSORPOS 0x9140
#define WERR_SETCURSOR 0x9180
#define WERR_GETCURSOR 0x91C0
#define WERR_CLIPCURSOR 0x9200
#define WERR_GETCLIPCURSOR 0x9240
#define WERR_LOADICON 0x9280
#define WERR_CREATEICON 0x92C0
#define WERR_DESTROYICON 0x9300
#define WERR_COPYICON 0x9340
#define WERR_DRAWICON 0x9380
#define WERR_MESSAGEBOX 0x93C0
#define WERR_MESSAGEBEEP 0x9400
#define WERR_CREATECARET 0x9440
#define WERR_DESTROYCARET 0x9480
#define WERR_SETCARETPOS 0x94C0
#define WERR_GETCARETPOS 0x9500
#define WERR_HIDECARET 0x9540
#define WERR_SHOWCARET 0x9580
#define WERR_GETCARETBLINKTIME 0x95C0
#define WERR_SETCARETBLINKTIME 0x9600
#define WERR_DEFFRAMEPROC 0x9640
#define WERR_DEFMDICHILDPROC 0x9680
#define WERR_TRANSLATEMDISYSACCEL 0x96C0
#define WERR_ARRANGEICONICWINDOWS 0x9700
#define WERR_ISDIALOGMESSAGE 0x9740
#define WERR_DEFDLGPROC 0x9780
#define WERR_CREATEDIALOG 0x97C0
#define WERR_CREATEDIALOGINDIRECT 0x9800
#define WERR_CREATEDIALOGPARAM 0x9840
#define WERR_CREATEDIALOGINDIRECTPARAM 0x9880
#define WERR_DIALOGBOX 0x98C0
#define WERR_DIALOGBOXINDIRECT 0x9900
#define WERR_DIALOGBOXPARAM 0x9940
#define WERR_DIALOGBOXINDIRECTPARAM 0x9980
#define WERR_ENDDIALOG 0x99C0
#define WERR_GETDLGCTRLID 0x9A00
#define WERR_GETDLGITEM 0x9A40
#define WERR_SENDDLGITEMMESSAGE 0x9A80
#define WERR_SETDLGITEMINT 0x9AC0
#define WERR_GETDLGITEMINT 0x9B00
#define WERR_SETDLGITEMTEXT 0x9B40
#define WERR_GETDLGITEMTEXT 0x9B80
#define WERR_CHECKDLGBUTTON 0x9BC0
#define WERR_CHECKRADIOBUTTON 0x9C00
#define WERR_ISDLGBUTTONCHECKED 0x9C40
#define WERR_GETNEXTDLGGROUPITEM 0x9C80
#define WERR_GETNEXTDLGTABITEM 0x9CC0
#define WERR_MAPDIALOGRECT 0x9D00
#define WERR_GETDIALOGBASEUNITS 0x9D40
#define WERR_DLGDIRLIST 0x9D80
#define WERR_DLGDIRSELECT 0x9DC0
#define WERR_DLGDIRLISTCOMBOBOX 0x9E00
#define WERR_DLGDIRSELECTCOMBOBOX 0x9E40
#define WERR_DLGDIRSELECTEX 0x9E80
#define WERR_DLGDIRSELECTCOMBOBOXEX 0x9EC0
#define WERR_SETWINDOWSHOOK 0x9F00
#define WERR_DEFHOOKPROC 0x9F40
//#define WERR_SETWINDOWSHOOK 0x9F80
//#define WERR_DEFHOOKPROC 0x9FC0
#define WERR_UNHOOKWINDOWSHOOK 0xA000
#define WERR_SETWINDOWSHOOKEX 0xA040
#define WERR_UNHOOKWINDOWSHOOKEX 0xA080
#define WERR_CALLNEXTHOOKEX 0xA0C0
#define WERR_ENABLEHARDWAREINPUT 0xA100
#define WERR_QUERYSENDMESSAGE 0xA140
#define WERR_LOCKINPUT 0xA180
#define WERR_GETSYSTEMDEBUGSTATE 0xA1C0
#define WERR_WINHELP 0xA200
#define WERR_OPENSOUND 0xA240
#define WERR_CLOSESOUND 0xA280
#define WERR_STARTSOUND 0xA2C0
#define WERR_STOPSOUND 0xA300
#define WERR_SETVOICEQUEUESIZE 0xA340
#define WERR_SETVOICENOTE 0xA380
#define WERR_SETVOICEACCENT 0xA3C0
#define WERR_SETVOICEENVELOPE 0xA400
#define WERR_SETVOICESOUND 0xA440
#define WERR_SETVOICETHRESHOLD 0xA480
#define WERR_GETTHRESHOLDEVENT 0xA4C0
#define WERR_GETTHRESHOLDSTATUS 0xA500
#define WERR_SETSOUNDNOISE 0xA540
#define WERR_WAITSOUNDSTATE 0xA580
#define WERR_SYNCALLVOICES 0xA5C0
#define WERR_COUNTVOICENOTES 0xA600
#define WERR_BUILDCOMMDCB 0xA640
#define WERR_OPENCOMM 0xA680
#define WERR_CLOSECOMM 0xA6C0
#define WERR_READCOMM 0xA700
#define WERR_WRITECOMM 0xA740
#define WERR_UNGETCOMMCHAR 0xA780
#define WERR_FLUSHCOMM 0xA7C0
#define WERR_TRANSMITCOMMCHAR 0xA800
#define WERR_SETCOMMSTATE 0xA840
#define WERR_GETCOMMSTATE 0xA880
#define WERR_GETCOMMERROR 0xA8C0
#define WERR_SETCOMMBREAK 0xA900
#define WERR_CLEARCOMMBREAK 0xA940
#define WERR_SETCOMMEVENTMASK 0xA980
#define WERR_GETCOMMEVENTMASK 0xA9C0
#define WERR_ESCAPECOMMFUNCTION 0xAA00
#define WERR_ENABLECOMMNOTIFICATION 0xAA40
#define WERR_WVSPRINTF 0xAA80
#define WERR_DEFDRIVERPROC 0xAAC0
#define WERR_OPENDRIVER 0xAB00
#define WERR_CLOSEDRIVER 0xAB40
#define WERR_SENDDRIVERMESSAGE 0xAB80
#define WERR_GETDRIVERMODULEHANDLE 0xABC0
#define WERR_GETNEXTDRIVER 0xAC00
#define WERR_GETDRIVERINFO 0xAC40

#endif // _ERRORMOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\fr.h ===
#ifndef _FR_H
#define _FR_H

#pragma pack(1)    /** ensure packed structures **/

/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI SRVRDLL

    @type   BYTE | IFR | .
				
	@flag Frame identifier values used in the FR struct and various APIs |

			ifrDIS 	= DIS frame

			ifrCSI 	= CSI frame

			ifrNSF	= NSF frame

			ifrDTC	= DTC frame

			ifrCIG	= CIG frame

			ifrNSC	= NSC frame

    		ifrDCS	= DCS frame

    		ifrTSI 	= TSI frame

    		ifrNSS	= NSS frame

    @xref   <t FR>
********/

#define 	ifrNULL		0
#define 	ifrDIS		1
#define 	ifrCSI		2
#define 	ifrNSF		3
#define		ifrDTC		4
#define		ifrCIG		5
#define		ifrNSC		6
#define		ifrDCS		7
#define		ifrTSI		8
#define		ifrNSS		9

typedef BYTE 		IFR;
typedef IFR FAR*	LPIFR;


/********
    @doc    EXTERNAL OEMNSF DATATYPES AWNSFAPI SRVRDLL

	@types  FR | Structure containing received or sent frames

	@field  IFR		| ifr	| Frame identifier
	@field  BYTE	| cb	| Length of the FIF part of the frame
	@field  BYTE[]	| fif	| Variable length FIF part

	@tagname _FR
	@xref   <t IFR>
********/


typedef struct 
{
	IFR		ifr;
	BYTE	cb;

} FRBASE;

#if defined(PORTABLE) || defined(__cplusplus)	/* strictly ANSI C */

typedef struct 
{
	IFR		ifr;
	BYTE	cb;
	BYTE	fif[1];		/* start of var length array */
}
FR, FAR* LPFR, NEAR* NPFR;

#else 				/* Microsoft C */

typedef struct 
{
	FRBASE;			/* anonymous */
	BYTE	fif[1];	/* variable length fif field */
	    
} FR, FAR* LPFR, NEAR* NPFR;

#endif

typedef LPFR FAR* LPLPFR;
typedef LPLPFR FAR* LPLPLPFR;


/********
    @doc    EXTERNAL OEMNSF DATATYPES

	@types  LLPARAMS | Structure containing low-level T.30 capabilities or
						parameters.

	@field  BYTE 	| Baud    | Baud Rate Capability or Mode.
	
		@flag Baud Rate Mode Codes |

			V27_2400	= 0

			V27_4800	= 2

			V29_7200	= 3

			V29_9600	= 1

			V33_12000	= 6

			V33_14400	= 4

			V17_7200	= 11

			V17_9600	= 9

			V17_12000	= 10

			V17_14400	= 8

		@flag V27_SLOW | Baud Rate Capability: V.27 at 2400bps only.
		@flag V27_ONLY | Baud Rate Capability: V.27 only, at 2400bps and 4800bps.
		@flag V29_ONLY | Baud Rate Capability: V.29 only, at 7200bps and 9600bps.
		@flag V27_V29  | Baud Rate Capability: V.27 and V.29 at the above speeds.
		@flag V27_V29_V33 | Baud Rate Capability: V.27 and V.29 at the above speeds plus
							V.33 at 12000bps and 14400bps.
		@flag V27_V29_V33_V17 | Baud Rate Capability: V.27, V.29, V.33 at the above
							speeds plus V.17 at 12000bps and 14400bps.

	@field  BYTE	| MinScan | Minimum Scan-line time Requirement or Mode.

		@flag Minscan Mode Codes |

			MINSCAN_40	= 4

			MINSCAN_20	= 0

			MINSCAN_10	= 2

			MINSCAN_5	= 1

			MINSCAN_0	= 7

		@flag MINSCAN_0_0_0    | MinScan Reqmnt: 0ms at all vertical resolutions
		@flag MINSCAN_5_5_5    | MinScan Reqmnt: 5ms at all vertical resolutions
		@flag MINSCAN_10_10_10 | MinScan Reqmnt: 10ms at all vertical resolutions
		@flag MINSCAN_20_20_20 | MinScan Reqmnt: 20ms at all vertical resolutions
		@flag MINSCAN_40_40_40 | MinScan Reqmnt: 40ms at all vertical resolutions
		@flag MINSCAN_40_20_20 | MinScan Reqmnt: 40ms at 100dpi, 20ms at all other resolutions
		@flag MINSCAN_20_10_10 | MinScan Reqmnt: 20ms at 100dpi, 10ms at all other resolutions
		@flag MINSCAN_10_5_5   | MinScan Reqmnt: 10ms at 100dpi, 5ms at all other resolutions
		@flag MINSCAN_40_40_20 | MinScan Reqmnt: 40ms at 100dpi and 200dpi, 20ms at 400dpi
		@flag MINSCAN_20_20_10 | MinScan Reqmnt: 20ms at 100dpi and 200dpi, 10ms at 400dpi
		@flag MINSCAN_10_10_5  | MinScan Reqmnt: 10ms at 100dpi and 200dpi, 5ms at 400dpi
		@flag MINSCAN_40_20_10 | MinScan Reqmnt: 40ms at 100dpi, 20ms at 200dpi, 10ms at 400dpi
		@flag MINSCAN_20_10_5  | MinScan Reqmnt: 20ms at 100dpi, 10ms at 200dpi, 5ms at 400dpi

	@field  BYTE	| fECM	  | ECM Capability or Mode (boolean).
	@field  BYTE	| fECM64  | Small-Frame (64 byte frame) ECM Capability or Mode (boolean).

	@tagname _LLPARAMS
	@xref   <f OEM_NSxToBC>, <f OEM_CreateFrame>
********/


typedef struct
{

    BYTE    Baud;
    BYTE    MinScan;

    BYTE    fECM;
    BYTE    fECM64;
/**
    BYTE    fNonEfaxBFT     :1;
    BYTE    fNonEfaxSUB     :1;
    BYTE    fNonEfaxSEP     :1;
    BYTE    fNonEfaxPWD     :1;
    BYTE    fNonEfaxCharMode:1;
    BYTE    fNonEfaxDTM     :1;
    BYTE    fNonEfaxBTM     :1;
    BYTE    fNonEfaxEDI     :1;
**/
}
LLPARAMS, FAR* LPLLPARAMS, NEAR* NPLLPARAMS;

/** Baud rate capability codes **/
// Bit order is from 14 to 11: 14 13 12 11
#define V27_SLOW			0   // 0000
#define V27_ONLY			2   // 0010 
#define V29_ONLY			1   // 0001
#define V33_ONLY			4   // 0100
#define V17_ONLY			8   // 1000
#define V27_V29				3   // 0011
#define V27_V29_V33			7   // 0111
#define V27_V29_V33_V17		11  // 1011
#define V_ALL				15  // 1111


/** Baud rate mode codes **/
#define V27_2400     0          // 0000  
#define V29_9600     1          // 0001
#define V27_4800     2          // 0010  
#define V29_7200     3          // 0011 
#define V33_14400    4          // 0100 
#define V33_12000    6          // 0110
#define V17_14400    8          // 1000
#define V17_9600     9          // 1001
#define V17_12000    10         // 1010
#define V17_7200     11         // 1011    


/** Minscan capability codes **/
#define MINSCAN_0_0_0		7
#define MINSCAN_5_5_5		1
#define MINSCAN_10_10_10	2
#define MINSCAN_20_20_20	0
#define MINSCAN_40_40_40	4
#define MINSCAN_40_20_20	5
#define MINSCAN_20_10_10	3
#define MINSCAN_10_5_5		6
#define MINSCAN_10_10_5	   	10
#define MINSCAN_20_20_10   	8
#define MINSCAN_40_40_20   	12
#define MINSCAN_40_20_10   	13
#define MINSCAN_20_10_5	   	11


typedef enum
{
	WHICHDCS_FIRST = 0,
	WHICHDCS_NOREPLY = 1,
	WHICHDCS_FTT = 2,
	WHICHDCS_DIS = 3
}
WHICHDCS;



#pragma pack()    

#endif /* _FR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\inifile.h ===
#ifndef INIFILE_H
#define INIFILE_H

// Defines data so can be included only once in each DLL!!

char szIniFile[]		= szINIFILE;

char szDialtoneTimeout[]= szDIALTONETIMEOUT;
char szAnswerTimeout[]	= szANSWERTIMEOUT;
char szDialPauseTime[]	= szDIALPAUSETIME;
char szPulseDial[]		= szPULSEDIAL;
char szDialBlind[]		= szDIALBLIND;
char szSpeakerControl[]	= szSPEAKERCONTROL;
char szSpeakerVolume[]	= szSPEAKERVOLUME;
char szSpeakerRing[]	= szSPEAKERRING;
char szRingsBeforeAnswer[]	= szRINGSBEFOREANSWER;
char szHighestSendSpeed[]	= szHIGHESTSENDSPEED;
char szLowestSendSpeed[]	= szLOWESTSENDSPEED;
char szEnableV17Send[]		= szENABLEV17SEND;
char szEnableV17Recv[]		= szENABLEV17RECV;
char szDisableECM[]			= szDISABLEECM;
char sz64ByteECM[]			= sz64BYTEECM;
char szCopyQualityCheckLevel[]	= szCOPYQUALITYCHECKLEVEL;

#ifdef PCMODEMS
char szFixModemClass[] 		= szFIXMODEMCLASS;
char szFixSerialSpeed[]     = szFIXSERIALSPEED;
#endif //PCMODEMS


char szDefRecipName[]		= szDEFRECIPNAME;
char szDefRecipAddr[]		= szDEFRECIPADDR;
char szSpoolDir[]			= szSPOOLDIR;
char szLocalID[]			= szLOCALID;
char szOEMKey[]				= szOEMKEY;

#endif INIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\filet30.h ===
/***************************************************************************
 Name     :
 Comment  :

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
  ???     arulm created
 3/17/94  josephj Modified to handle AWG3 format, tapi and other device ids.
                  Specifically, changed prototypes for FileT30Init,
                  and FileT30ModemClasses, and added #defines for LINEID_*
***************************************************************************/
#ifndef _FILET30_
#define _FILET30_

#include <ifaxos.h>
#include <t30fail.h>

#ifdef __cplusplus
extern "C" {
#endif

//      Types of LineId's
#define LINEID_NONE             (0x0)
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)
#define LINEID_NETFAX_DEVICE    (0x10)


USHORT  FileT30Init(
                                DWORD dwLineID, USHORT usLineIDType,
                                DWORD dwProfileID, LPSTR lpszSection,
                                USHORT uClass,
                                // LPSTR szSpoolDir, LPSTR szId,
                                // LPSTR szDefRecipAddress, LPSTR szDefRecipName,

                                USHORT uAutoAnswer, HWND hwndListen
                         );

        // dwLineID, usLineIDType:
        //   If usLineIDType==LINEID_COMM_PORTNUM:
        //      dwLineID = COMM port# -- 1 to 4 for COM ports, 0 for CAS
        //   If usLineIDType==LINEID_COMM_HANDLE:
        //      dwLineID = Handle to open comm port.
        //   If usLineIDType==LINEID_TAPI_DEVICEID:
        //      dwLineID = TAPI DeviceID
        //   If usLineIDType==LINEID_TAPI_PERMANENT_DEVICEID:
        //      dwLineID = TAPI Permanent DeviceID.
        //
        // uClass: exactly one of the FAXCLASS??? #defines from below
        //
        //  dwProfileID and lpszSection point to the registry/inifile that
        //      contain configuration information for the particular line.
        //
        //      WIN16: dwProfileID is ignored (should be 0), and we look in efaxpump.ini
        //                 lpszSection should point to the section where per-line
        //                 configuration information is stored. The following entries
        //                 are mandatory:
        //                 - SpoolDir --> path to spool directory for recvd files
        //                       acquires modem etc. Returns one of values below
        //                 - LocalId:   ID to be used in DIS/CIG
        //                 - DefRecipAddr: Recip address to be used for
        //                       incoming G3 faxes
        //                 - DefRecipName:    Recip name to be used for incoming G3 faxes.
        // WIN32: dwProfileID should point to a system registry key handle (such as
        //                              HKEY_CURRENT_USER)
        //                lpszSection should be a key relative to the above handle that
        //                points to a location where configuration information for this
        //                line is to be stored. The mandatory entries are those mentioned
        //                above for WIN16 -- they are all null-terminated strings.

        // uAutoAnswer, hwndListen: same as for FileT30Listen below..
        //
        // Returns OK, NOMODEM (port number is wrong) or PORTBUSY
        // (somebody else is using the port) or WRONGTYPE (wrong modem type)
        // BETTERTYPE (chosen type is supported, but a "better" type is also
        // supported). In the last 2 cases suberr is 1,2, or 3 giving the
        // correct/better type and Init is *successful*. In the BETTERTYPE
        // case, the chosen type is used, *not* the "better" type.
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem


USHORT  FileT30Listen(USHORT uLevel, HWND hwndResult);
        // uLevel: 0==off 1==notif posted if hwndResult is non-NULL 2==auto
        // returns one of values below
        // Usually OK or PORTBUSY
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem

        // In manual answer mode (Mode 1), once a RING is detected,
        // it _must_ be cleared before anything else can be done.
        // It can be cleared by a call to FileT30Answer(T/F)

void  FileT30Send(ATOM aPhone, ATOM aCapsPhone, ATOM aFileAWG3, ATOM aFileIFX, ATOM aFileEFX, ATOM aFileDCX, HWND hwndResult);
        // return value via IF_FILET30_DONE message below.
        // Result values can be
        //      BUSY or PORTBUSY
        //      CALLDONE+SENTALL                                -- all Aok
        //      CALLFAIL+SENTSOME or SENTNONE   -- actually called & failed
        //      BADPARAM                                                -- bad file name, phone number too long
        //      BUG                                                             -- some debugchk failed
        //  DIALFAIL+NCUDIAL_xxx                        -- failure during dial
        //  DIALFAIL+NCUANSWER_xxx                      -- failure during answer
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        //      That's it
        // aCapsPhone, is nonzero, is to be used to as  the key for saving
        // capabilities entries (it  will be in canonical form, typically).
        // All the caller is responsible for freeing all atoms, on receiving
        // FILET30_DONE message, which is guaranteed to be sent.

ULONG  FileT30Answer(BOOL fAccept, BOOL fImmediate, HWND hwndResult);
        // fAccept is FALSE to reject a call
        // if fAccept and fImmediate are TRUE call is answered even
        //              if no RING detected if transport is IDLE
        // if fAccept==TRUE and fImmediate==FALSE call is answered
        //              iff it is ringing. We also wait for the configured
        //              number of Rings rather than answer immediately.

        // failure return value (loword==err hiword==FailureCode)
        // Result values can be
        // BUSY or PORTBUSY
        // FILE_ERROR
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        // Nothing else


void  FileT30Abort();
        // Synchronous abort of current send/recv. Busy-waits until done.
        // Transport returns to IDLE state. If aim is to shut down all
        // activity, then call FileT30Listen(0,0) first, then FileT30Abort()
        // and then FileT30Deinit(TRUE)

DWORD  FileT30ReportRecv(LPDWORD lpdwPollContext, BOOL fGetIt);
        // returns file names of received faxes one by one.
        // *lpdwPollContext, if non-null, will be set to 0 if this is a normal
        // receive or the supplied context dword if this is a response to a poll
        // request (see FileT30PollRequest).
        //
        // returns 0 if no more received faxes
        // LOWORD is global atom for file name
        // HIWORD is final result (i.e. lowbyte=one of the values below,
        //                                                              hibyte=Failure Code // T30FAIL_xxx values)
        //
        // The only return values returned are:-
        // ANSWERFAIL (ext err is NCUANSWER_ERROR or NCUANSWER_NORING)
        //              (former likely on voice calls, latter on manual answers)
        // CALLFAIL, CALLDONE, ABORT or FILE_ERROR (ext err == 0)
        // file atom can be present anyway from any of these. If
        // result value is not CALLDONE then this is only a partially
        // received transmission.


BOOL  FileT30AckRecv(ATOM aRecv);
        // acknowledges successful receipt. The Recv log is deleted
        // aRecv must be non-NULL and a valid recv file name
        // returns FALSE on errors

        // ***NOTE*** Until AckRecv is called multiple calls to ReportRecv
        //                        will return the same value


USHORT  FileT30Status(void);
        // returns one of
#       define  T30STATE_IDLE           0
#       define  T30STATE_SENDING        1
#       define  T30STATE_RECEIVING      2
#       define  T30STATE_ABORTING       3       // stuck inside abort loop
                                                                // this is a bad error...!!


void  FileT30SetStatusWindow(HWND hwndStatus);
        // all subsequent status messages get posted to this
        // window. If hwndStatus==0, recv status is not posted

BOOL  FileT30ReadIniFile(void);
        // forces transport to re-read INI file
        // returns FALSE if busy


USHORT  FileT30DeInit(BOOL fForce);
        // Frees modem etc.
        // returns T30_OK if ok
        // Returns T30_BUSY if call in progress
        // If call not in progress, but recv files left,
        // returns T30_RECVLEFT. If fForce is TRUE then
        // it saves recv file list to disk and returns
        // and T30_OK. Reloads recv list next time


DWORD  FileT30ModemClasses(
        DWORD dwLineID, USHORT usLineIDType,
        DWORD dwProfileID, LPSTR lpszSection
        );
        // dwLineID, usLineIDType: same as in FileT30Init.
        // dwProfileID, lpszSection: same as in FileT30Init.
        //----------MUST BE CALLED ONLY WHEN TRANSPORT IS **NOT** INITED--------//
        // returns ((DWORD)(-1)) on error (e.g. if called when transport is inited)
        // return 0 if no modem detected (e.g. CAS is supported but no CAS detected
        //                                                              or can't get ComPort or can't talk to modem)
        // LOWORD(return value)==uClasses is one or more of the below
        // CAS is checked IFF uPort is 0

#ifdef WIN32
BOOL  FileT30UpdateHandle(HANDLE hComm);
        // Once the transport has been inited with an external handle,
        // and answer mode is off, and no activity is ongoing, this api
        // can be called to to specify a new comm handle. If hComm ==
        // NULL, this will disable further sends or attempts to change answer
        // mode to on until a subsequent FileT30UpdateHandle call is made with a
        // valid hComm. The comm port and modem will be in an unknown state
        // when this is made, so the transport should properly setup the
        // port and reset the modem to a known state the next time it want's
        // to talk to the modem.
#endif

#       define          FAXCLASS0               0x01
#       define          FAXCLASS1               0x02
#       define          FAXCLASS2               0x04
#       define          FAXCLASS2_0             0x08    // Class4==0x10
#       define          FAXCLASSMOUSE   0x40    // used if mouse found
#       define          FAXCLASSCAS             0x80

void  FileT30PollReq(ATOM aPhone, ATOM aCapsPhone, USHORT PollType,
                   ATOM aDocName, ATOM aPassWord, DWORD dwPollContext, HWND hwndResult);

        // Poll type is one of the POLLTYPE_ values below
#define POLLTYPE_G3                      0 // G3(blind) poll req: DocName/Pass=null
#define POLLTYPE_EXTCAPS         2 // ext-caps poll request: DocName/Pass=null
#define POLLTYPE_NAMED_DOC       3 // named-doc poll req: DocName=reqd. Pwd=optional
#define POLLTYPE_BYRECIPNAME 4 // poll-by-recip-name: DocName=recip email-name. Pwd=reqd
#define POLLTYPE_BYPATHNAME      5 // poll-by-filename: DocName=file-path. Pwd=reqd

        // dwPollContext is a dword of context which will associated with all
        // receives associated with this poll request. See FileT30ReportReceives.

        // return value via IF_FILET30_DONE message below.
        // Poll Response shows up as a regular recvd message
        // Result values can be
        //      BUSY or PORTBUSY
        //      CALLDONE                                -- all Aok
        //      CALLFAIL                                -- actually called & failed
        //      BADPARAM                                -- bad file name, phone number too long
        //      BUG                                             -- some debugchk failed
        //  DIALFAIL+NCUDIAL_xxx        -- failure during dial
        // Can return any of these on modem errors:-
        // T30_MODEMERROR -- usually non-fixable. Got some weird response from modem
        // T30_PORTBUSY   -- someone else owns teh Com Port
        // T30_MODEMDEAD  -- could not talk to modem at all. Modem may be off,
        //                                       on a different port or the guy has cabling problems
        //                                       this is sometimes fixable by power-cycling the modem
        // aCapsPhone -- see FileT30Send.

// also returns
        // T30_NOSUPPORT  -- returns this if this API is called with a Class2
        //              or CAS modem (polling not supported), or a non-G3 pollreq is
        //              sent to a non-AWFAX entity (this error returned after calling)




/**------------------ Messages returned *from* t30.exe --------------------**/

#define IF_FILET30_STATUS       (IF_USER + 0x702)
        // wParam==aPhone (used as handle)
        // LOBYTE(LOWORD(lParam))==one of T30STATUS_ defines below
        // HIBYTE(LOWORD(lParam))==N1 (as defined below)
        // LOBYTE(HIWORD(lParam))==N2 (as defined below)
        // HIBYTE(HIWORD(lParam))==N3 (as defined below)
        // +++ WARNING: these constants are duplicated in psifxapi.h

  typedef enum
  {
        T30STAT_INITING,        // all N==0
  // sender
        T30STATS_DIALING,       // all N==0
        T30STATS_TRAIN,         // N1==BaudRateCode N2==how many times N3==0
                                                // Baud rate remains same for the page that follows
        T30STATS_SEND,          // N1==Page number N2==%age done N3==0
        T30STATS_CONFIRM,       // N1==Page number N2==0 N3==0
        T30STATS_REJECT,        // N1==Page number N2==0 N3==0
        T30STATS_RESEND_ECM,// N1==Page number N2==0 N3==Block number
        T30STATS_SUCCESS,       // all N==0
        T30STATS_FAIL,          // all N==0
  // recvr
        T30STATR_ANSWERING,     // all N==0
        T30STATR_TRAIN,         // N1==0 N2==how many times(NYI) N3==0
                                                // Baud rate remains same for the page that follows
        T30STATR_RECV,          // N1==Page number
                                                // MAKEWORD(N2,N3)==KBytes recvd in this page
        T30STATR_CONFIRM,       // N1==Page number **rest NYI** N2==Num bad lines N3==0
        T30STATR_REJECT,        // N1==Page number **rest NYI** N2==Num bad lines N3==0
        T30STATR_RERECV_ECM,// **all Ns NYI**  N1==Page number N2==BlockNum N3==how many times
        T30STATR_SUCCESS,       // all N==0
        T30STATR_FAIL,          // all N==0
  // both
        T30STAT_ERROR,          // all N==0
  // autoanswer
        T30STAT_NOANSWER,               // all N==0
        T30STAT_MANUALANSWER,   // all N==0
        T30STAT_AUTOANSWER,             // all N==0

        T30STATS_SEND_DATA,             // N1==Page number N2=KB sent in curr page N3==MsgNum or AttachNum
        T30STATR_RECV_DATA,             // N1==Page number N2=KB recvd in curr page N3==MsgNum or AttachNum
        T30STATS_CONFIRM_ECM    // Sent in ADDITION to T30STATS_CONFIRM
                                                // N1==Page number.
                                                // MAKEWORD(N2,N3)==K Bytes confirmed.
  }
  T30STATUS;

        // Baud rate codes
        /* V27_2400     0  (display as V.27 2400bps) */
        /* V29_9600     1 */
        /* V27_4800     2 */
        /* V29_7200     3 */
        /* V33_14400    4 */
        /* V33_12000    6 */
        /* V17_14400    8 */
        /* V17_9600     9 */
        /* V17_12000    10 */
        /* V17_7200     11 */


// Not used any more
// #define      IF_FILET30_RING         (IF_USER + 0x704)
        // wParam, lParam not used
        // sent iff listen level is set to 1
        // This is sent in manual answer mode. You *must* call FileT30Answer
        // with TRUE or FALSE after this, otherwise no further calls will
        // be answered or notified.

#define IF_FILET30_DESTTYPERES          (IF_USER + 0x705)
        // wParam==aPhone. LOBYTE(LOWORD(lParam))=one of the DEST_ defines below
        //                      HIBYTE(LOWORD(lParam))=Res--one or more of the RES_ defines
        //                      LOBYTE(HIWORD(lParam))=Enc--one or more of the ENCODE_ defines
        //                      HIBYTE(HIWORD(lParam))=vSecurity--security version number
        //                                                                      00==none 01==snowball
        // (see protapi.h for format)

        // Destination types
#       define DEST_UNKNOWN     0
#       define DEST_G3                  1
#       define DEST_IFAX                2
#       define DEST_EFAX                3
#       define NUM_DESTTYPE     4


#define IF_FILET30_TEXTCAPS     (IF_USER + 0x706)
        // wParam==aPhone. lParam==long pointer to ASCIIZ rep. of recvd NSF/CSI/DIS
        // length of the textcaps will never exceed
        #define TEXTCAPSSIZE    300

#define IF_FILET30_START        (IF_USER + 0x702)
#define IF_FILET30_END          (IF_USER + 0x706)

#define IF_FILET30_DONE         (IF_USER + 0x703)
        // sent after a Send is done
        // wParam==aPhone (used as handle)
        // LOBYTE(LOWORD(lParam))==result value
        // HIBYTE(LOWORD(lParam))==ext err
        // LOBYTE(HIWORD(lParam))==FailureCode  // one of the T30FAIL_xxx defines
        // never returns OK. Only CALLDONE, DIALFAIL, BUSY, PORTBUSY, BADPARAM, BADFILE
        // **new** and FILE_ERROR (only on disk-errors on manual answer; on same
        // errors in auto-answer, it just doesn't answer). Currently this happens
        // if (a) spool dir is so full it can't find a unique file name or
        // (b) it can't create a spool file for the received fax.

/**----- result values --------**/
#define T30_OK                          0
#define T30_CALLDONE            1
#define T30_CALLFAIL            2
#define T30_BUSY                        3
#define T30_DIALFAIL            4
#define T30_ANSWERFAIL          5
#define T30_BADPARAM            6
#define T30_WRONGTYPE           7
#define T30_BETTERTYPE          8
#define T30_NOMODEM                     9
#define T30_MISSING_DLLS        10
#define T30_FILE_ERROR          11
#define T30_RECVLEFT            12
#define T30_INTERNAL_ERROR      13
#define T30_ABORT                       14
#define T30_MODEMERROR          15
#define T30_PORTBUSY            16
#define T30_MODEMDEAD           17
#define T30_GETCAPS_FAIL        18
#define T30_NOSUPPORT           19
/**----- ICommEnd values **/


/**----- If err=T30_DIALFAIL, exterr is one of -----**/
#       define          NCUDIAL_ERROR                   0
// #define              NCUDIAL_OK                              1
#       define          NCUDIAL_BUSY                    2
#       define          NCUDIAL_NOANSWER                3
#       define          NCUDIAL_NODIALTONE              4
#       define          NCUDIAL_MODEMERROR              5


/**----- If err=T30_ANSWERFAIL, exterr is one of -----**/
#       define          NCUANSWER_ERROR                 0
// #define              NCUANSWER_OK                    1
#       define          NCUANSWER_NORING                8
#       define          NCUANSWER_MODEMERROR    5
#       define          NCUANSWER_DATAMODEM     10

/**----- If err=T30_MODEMBUSY, exterr is one of -----**/
        // 0==we are using it 1==someone else is using the modem/com port

/**-- On Send: if err=T30_CALLDONE or T30_CALLFAIL, exterr is one of --**/
#       define          T30_SENTALL             1
#       define          T30_SENTNONE    2
#       define          T30_SENTSOME    3

/***
        if err=T30_CALLDONE and exterr=T30_SENTALL
                a call is considered completed successfully
        if err=T30_CALLFAIL and exterr=T30_SENTALL                      ***REPORT A BUG***
                something weird has heppened,
                but all pages _may_ have reached.
                to be safe call it an error
        if err=T30_CALLDONE and exterr!=T30_SENTALL                     ***REPORT A BUG***
                something _really_ weird has happened,
                most probably all pages did not reach OK.
                To be safe call it an error
        if err=T30_CALLFAIL and exterr!=T30_SENTALL
                A definite error
**/

/**-- On Send and Recv: if err=T30_CALLDONE or T30_CALLFAIL, FailureCode is one of
          the failure codes described in T30FAIL.H
**/



/************************************************************************
*************************************************************************
*************************************************************************
*************************************************************************
*************************************************************************/



/**-- disk file format (MG3, EFX, IFX and CFX files)
          File consists on N pages, each with a header of
          the following structure, followed by data.

          However, all parameters in the headers on non-first
          pages are ignored, except the size field, i.e. you can't
          mix MG3/IFX/EFX in a single file, and all pages better
          use the same res/width/length/encoding.

          Sigs are:- "G3", "EB", "EI" (EFAX binary, image) and "EF"
                                 (File/ASCII)
--**/

#define SIG_G3          0x3347
#define SIG_EB          0x4245
#define SIG_EI          0x4945
#define SIG_FA          0x4146

typedef struct {
        WORD    wSig;                   // must always be set and must be the same for all headers in a file.
        WORD    wHeaderSize;    // size of this header in bytes. Must always be set
        WORD    wTotalHeaders;  // significant *only* in *first* page header. Can be zero otherwise.
        WORD    wHeaderNum;             // from 1 to wNumPages. Must always be set.
        DWORD   lDataOffset;// offset to this page's data from start of file. Must always be set.
        DWORD   lDataSize;      // num bytes of data following. Must always be set.

// 16 bytes
        DWORD   lNextHeaderOffset;      // offset to next header, from start of file. Must always be set.

        // the next 5 are significant *only* in *first* page header. Can be zero otherwise.
        BYTE    Resolution;             // one or more of the RES_ #defines below
        BYTE    Encoding;               // one or more of the ENCODE_ #defines below
        BYTE    PageWidth;                      // one of the WIDTH_ #defines below
        BYTE    PageLength;                     // one of the LENGTH_ #defines below
        WORD    wMinBytesPerLine;       // set to 0 if no guarantees
                                                                // this may not be used
        WORD    Text;                   // Text Encoding, can use TEXT_ASCII from below
        BYTE    RecvStatus;             // Received OK/not OK (0=unknown/unused 1=OK 2=error)
        BYTE    SendStatus;             // Sent OK/not OK (0=unknown/unused 1=OK 2=error)
        WORD    vSecurity;              // Pad to 32 bytes

// 32 bytes
#define MAXFHBIDLEN     20
        BYTE    szID[MAXFHBIDLEN+1];            // caller id (used in send _and_ recv). Null terminated.
        BYTE    Reserved2[11];  // Pad to 32 bytes

// 64 bytes

        BYTE    szFileTitle[13];// Null-term 8.3 user-visible file name,
        BYTE    szFileName[13]; // Null-term 8.3 file name, assumed to be in _same_
                                                        // directory as the spool file containing this struct
        BYTE    Reserved3[6];   // Pad to 32 bytes

// 96 bytes

        BYTE    Reserved4[160]; // pad out to 256 bytes for future expansion

// 256 bytes

} FHB, far* LPFHB;

#define vSECURE_SNOW    1

/**---------------------------------------------------------------------

MG3
        A G3 file consists of one or more such headers each followed by
        Group-3 fax data, in compressed form. Each header starts a new
        page. The number of pages, res, encoding, width & len of each
        page is set in the first header.

EFX
IFX
        An EB file consists of one or more such headers each followed by
        Linearized data. Each header starts a new Message. The number of
        messages in a file is determined by the 'wTotalPages' field of
        the first header. An EI file differs only in that the contents
        of the linearized message are claimed to be purely imageable.

CFX
        An FA file consists of one or more such headers. Each header
        either represents ASCII note-text or a file attachment.
        If the Text field of the header is set to TEXT_ASCII,
        then the header is followed by lPageDataSize bytes of ASCII
        data, and the szFileName field is not used.

        Otherwise the Text field must be 0 and the szFileName
        field must be meaningful, and must contain the user-visible
        filename of an attachment. The file must be in the same
        directory, and the filename is in zero-terminated 8.3 format.
        Resolution, Width, Length, wMinBytesPerLine unused. The
        And the lPageDatSize field of this structure must be zero.


NOTES:-
        In all cases, wSig, wHeaderSize, lPageDataSize, lPagePadSize
        must be set correctly (0 when applicable).
        Each FHB in the file corresponds to a logical "page", so
        wPageNum must always be set accordingly (first page is 1) and
        in the FIRST FHB in a file wTotalPages must be set to the total
        number of FHB structures in the file. In all other FHBs in the file
        it must be 0.

        Resolution, Encoding, Width, Length and wMinBytesPerLine
        are not always used. In all cases, all unused fields, reserved and
        pad fields must be set to 00.

--------------------------------------------------------------------**/


//--------------------- Transport API's ---------------

BOOL FAR PASCAL ProcessAnswerModeReturn(USHORT uRetVal);
    // Return TRUE if the answer mode shoudl be retried
    // FALSE if not. Displays an error message box if
    // necessary.

//--------------------- PROFILE ACCESS API's ---------------
//
//      Following APIs provide access the fax-related information
//      stored in the the registry/ini-file.
//
//      These API's should be used, rather than GetPrivateProfileString, etc...
//  On WIN32, these API's use the registry.
//

#ifdef WIN32
#define USE_REGISTRY
#endif

#ifdef USE_REGISTRY
#       define  DEF_BASEKEY 1
#       define  OEM_BASEKEY 2
#else
#       define  DEF_BASEKEY 0
#       define  OEM_BASEKEY 0
#endif

#define szINIFILE                       "EFAXPUMP.INI"

#define szDIALTONETIMEOUT       "DialToneWait"
#define szANSWERTIMEOUT         "HangupDelay"
#define szDIALPAUSETIME         "CommaDelay"
#define szPULSEDIAL                     "PULSEDIAL"
#define szDIALBLIND                     "BlindDial"
#define szSPEAKERCONTROL        "SpeakerMode"
#define szSPEAKERVOLUME         "Volume"
#define szSPEAKERRING           "RingAloud"
#define szRINGSBEFOREANSWER     "NumRings"
#define szHIGHESTSENDSPEED      "HighestSendSpeed"
#define szLOWESTSENDSPEED       "LowestSendSpeed"
#define szENABLEV17SEND         "EnableV17Send"
#define szENABLEV17RECV         "EnableV17Recv"



#define szDISABLEECM            "DisableECM"
#define szDISABLEG3ECM          "DisableG3ECM"
#define sz64BYTEECM                     "SmallFrameECM"
#define szDISABLE_MR_SEND       "DisableMRSend"
#define szDISABLE_MR_RECV       "DisableMRRecv"
#define szCOPYQUALITYCHECKLEVEL "CopyQualityCheckLevel"

#define szOEMKEY                        "OEMKey"
#define szFAX                           "Fax"

#ifdef PCMODEMS
#define szFIXMODEMCLASS         "FixModemClass"
#define szFIXSERIALSPEED        "FixSerialSpeed"
#define szCL1_NO_SYNC_IF_CMD "Cl1DontSync"
#define szANSWERMODE            "AnswerMode"
#define szANS_GOCLASS_TWICE "AnsGoClassTwice"
#endif //PCMODEMS


#define szDEFRECIPNAME          "DefRecipName"
#define szDEFRECIPADDR          "DefRecipAddr"
#define szSPOOLDIR                      "SpoolDir"
#define szLOCALID                       "LocalID"

#define szGENERAL                       "General"
#define szRUNTIME                       "RunTime"
#define szACTIVEDEVICEID    "ActiveDeviceID"
#define szACTIVEDEVICEIDTYPE "ActiveDeviceIDType"
#define szACTIVEDEVICESECTION "ActiveDeviceSection"

// Following use to specify model-specific behavour of CLASS2 Modems.
// Used only in the class2 driver.
#define         szRECV_BOR              "Cl2RecvBOR"
#define         szSEND_BOR              "Cl2SendBOR"
#define         szDC2CHAR               "Cl2DC2Char"    // decimal ascii code.
#define         szIS_SIERRA             "Cl2IsSr"               //Sierra
#define         szIS_EXAR               "Cl2IsEx"               //Exar
#define         szSKIP_CTRL_Q   "Cl2SkipCtrlQ"  // Don't wait for ^Q to send
#define         szSW_BOR                "Cl2SWBOR"              // Implement +FBOR in software.

// Following to control disabling compression capabalities
// 0 => Enabled !0 => Disabled
#define         szDISABLE_CMPRS_SEND    "DisableCmprsSend"
#define         szDISABLE_CMPRS_RECV    "DisableCmprsRecv"

// Cotrols whether we delete the modem section on installing modem...
#define         szDONT_PURGE "DontPurge"
#define szDIALCAPS                      "DialCaps"
        // One of the LINEDEVCAPSFLAGS_* below.

// RAW Capabilities for the machine dialled last - a MACHINECAPS structure
// which consists of (see srvrdll documentation):
// DIS -- single FR structure.
// NSFs -- Multipe FR structures, terminated by an FR structure with 0
// type and size.
#define szRemoteMachineCaps             "RemoteMACHINECAPS"


// Following constants from TAPI.H
// Indicate which special dial chars the modem supports: '!' '@' 'W' resp.
#define LINEDEVCAPFLAGS_DIALBILLING  0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET        0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE 0x00000100

#ifdef NSF_TEST_HOOKS

// These are used only for nsf compatibility testing...

// Key where test NSx frames are stored
#define szNSFTEST "Runtime\\NSFTest"

// Under the above key, the values are as follows:
// If any of the following are defined, we will transmit
// the corresponding frames instead of the internally-generated ones:
//              Name                    Type    Description
//          SentNSFFrameCount   string  count of nsf frames
//              SentNSFFrames           binary  one or more FR structures
//              SentNSSFrameCount       string
//              SentNSSFrames           binary
//
//      After each call, the received frames will be written under the same
//      key (NSFTest):
//              RecvdNSFFrameCount  string  count of nsf frames
//              RecvdNSFFrames      binary  one or more FR structures
//              RecvdNSSFrameCount  string
//              RecvdNSSFrames          binary
//              RecvdNSCFrameCount      string
//              RecvdNSCFrames          binary

#endif // NSF_TEST_HOOKS

//===========   PROFILE ENTRIES: ENHANCED COMM MONITORING =============

#define szMONITORCOMM "MonitorComm"
                        // If 1, comm monitoring is enabled. On by default
                        //      for debug, off by default for retail.
                        // Used by awfxio32.dll

#define szMONITORBUFSIZEKB "MonitorBufSizeKB"
                        // Size of comm monitor buffer in KB. If not specified,
                        // internal default is used.
                        // Used by awfxio32.dll

//========== PROFILE ENTRIES: ADAPTIVE ANSWER =============

#define szADAPTIVEANSWER "AdaptiveAnswer"
                        // If 1, adaptive answer is enabled -- i.e., the ability
                        // to answer either a data or fax call.
                        // Used by awfxio32.dll and awfxex32.exe

//========== PROFILE ENTRIES: TAPI =============

#define szHIGHEST_PRIO_APP "HighestPrioApp"
                        // String value giving module name of app to be placed as
                        // highest priority to answer datamodem calls.
                        // Used by awfxex32.exe

//      Flags passed into ProfileOpen
enum {
fREG_READ               = 0x1,
fREG_WRITE              = 0x1<<1,
fREG_CREATE     = 0x1<<2,
fREG_VOLATILE   = 0x1<<3
};

//--------------------- END PROFILE ACCESS API's ---------------

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FILET30_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\ncuparm.h ===
#ifndef _NCUPARAMS_
#define _NCUPARAMS_



// initial defaults for all settings in braces at end

typedef struct {
  USHORT uSize;			// of this structure
  SHORT	DialtoneTimeout;// how long to wait for dial tone (secs)	[30]
  SHORT	AnswerTimeout;	// how long to wait for callee to pick up phone (secs) [60]
  SHORT	DialPauseTime;	// how long to pause for a pause/comma (secs) [2]
  SHORT	FlashTime;		// how long to go off hook for flash (secs) [1]
  SHORT	RingsBeforeAnswer; // 0 to N [0]
  char 	chDialModifier;	// 'T'==tone 'P'==pulse
  SHORT	DialBlind;		// T/F (dial w/o waiting for dialtone) [0]
  SHORT	SpeakerVolume;	// 0 to 3 [1]
  SHORT SpeakerControl;	// 0=off  1=on during dial  2=on always [1];
  SHORT SpeakerRing;	// T/F (generate audible ring on incoming calls NYI) [0]
  USHORT uOEMExtra;		// set to 0
}
NCUPARAMS, far* LPNCUPARAMS;


// MODEM SPECIFIC INFORMATION
// +++ NOTE: 4/9/95 JosephJ: The name CMDTAB is out-of-date -- it contains more
// than just command-strings. It includes such modem-specific info as port-
// speed, whether to the modem (if class1) sends no-FCS after a frame, etc.
// So think about changing this name to something like MDMSP_INFO.
 
enum
{
// GENERAL

	fMDMSP_ANS_GOCLASS_TWICE	= (0x1<<0), // Try AT+FCLASS=1/2 TWICE on
											// answer, to get around clash with
											// incoming RING.
											// If NOT set, just do this once,
											// as in WFW 3.11.


// CLASS1-SPECIFIC

	fMDMSP_C1_NO_SYNC_IF_CMD	= (0x1<<8), // Do not send sync-command (AT)
											// if modem is already in command
											// State (To fix AT14 bug (Elliot
											// bug#2907) -- which returns
											// ERROR to AT+FTH=3 after AT
	fMDMSP_C1_FCS_NO    		= (0x1<<9), // No FCS after frame.
	fMDMSP_C1_FCS_YES_BAD		= (0x1<<10)	// Bad FCS after frame.
											// If neither flag specified,
											// driver will try to determine
											// on-the-fly.
};

typedef struct
{
	LPSTR szReset;
	LPSTR szSetup;
	LPSTR szExit;
	LPSTR szPreDial;
	LPSTR szPreAnswer;
	DWORD dwSerialSpeed;

	DWORD dwFlags;			// One-or-more fMDMSP_* flags defined above.
}
CMDTAB, FAR* LPCMDTAB;


#endif //_NCUPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\oemint.h ===
#ifdef OEMNSF
#	include <oemnsf.h>

	extern LPFN_OEM_STARTCALL	lpfnOEMStartCall;
	extern LPFN_OEM_ENDCALL		lpfnOEMEndCall;
	extern LPFN_OEM_NSXTOBC		lpfnOEMNSxToBC;
	extern LPFN_OEM_CREATEFRAME	lpfnOEMCreateFrame;
	extern LPFN_OEM_NEXTACTION	lpfnOEMNextAction;
	extern LPFN_OEM_GETBAUDRATE lpfnOEMGetBaudRate;
	extern LPFN_OEM_INITNSF		lpfnOEMInitNSF;
	extern LPFN_OEM_DEINITNSF	lpfnOEMDeInitNSF;

	extern WORD					wOEMFlags;
	extern WORD					wLenOEMID;
	extern BYTE					rgbOEMID[];
	extern BOOL					fUsingOEMProt;

#	ifdef RICOHAI
#	include <ricohai.h>

		extern LPFN_RICOHAISTARTTX	lpfnRicohAIStartTx;
		extern LPFN_RICOHAIENDTX	lpfnRicohAIEndTx;
		extern LPFN_RICOHAISTARTRX	lpfnRicohAIStartRx;
		extern BOOL					fUsingRicohAI;
#	endif //RICOHAI
#endif //OEMNSF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\global.h ===
#include <t30ext.h>
//
// thread sync. timeouts
//

#define RX_WAIT_ACK_TERMINATE_TIMEOUT   60000
#define RX_ACK_THRD_TIMEOUT             3000

#define TX_WAIT_ACK_TERMINATE_TIMEOUT   60000

//
// TIFF encoder/decoder defs.
//

#define  LINE_LENGTH   1728

#define  FAX_SUCCESS   0
#define  FAX_FAILURE   1

#define  RET_FAIL     0
#define  RET_SUCCESS  1
#define  RET_TIMEOUT  2
#define  RET_CANCELED 3

#define  LOG_ALL      256
#define  LOG_ERR      1
#define  LOG_NOTHING  0

#define  T30_RX       1
#define  T30_TX       2



typedef struct {
    DWORD           tiffCompression;
    BOOL            HiRes;
    char            lpszLineID[16];  // to be used for a temp. TIFF page data file
}  TX_THRD_PARAMS;

#define   DECODE_BUFFER_SIZE    44000

#define   MODEMKEY_FROM_UNIMODEM   1
#define   MODEMKEY_FROM_ADAPTIVE   2
#define   MODEMKEY_FROM_NOTHING    3



//identify.c

typedef struct {

   DWORD_PTR hglb;                 // Tmp globall alloc "handle" for strings.
                                                        // type HGLOBAL for non-ifax and LPVOID
                                                        // for IFAX
   LPBYTE lpbBuf;
   LPSTR  szReset;                      // MAXCMDSIZE
   LPBYTE szSetup;                      // MAXCMDSIZE
   LPBYTE szExit;                       // MAXCMDSIZE
   LPBYTE szPreDial;            // MAXCMDSIZE
   LPBYTE szPreAnswer;          // MAXCMDSIZE
   LPBYTE szIDCmd;                      // MAXCMDSIZE
   LPBYTE szID;                         // MAXIDSIZE
   LPBYTE szResponseBuf;        // RESPONSEBUFSIZE
   LPBYTE szSmallTemp1;         // SMALLTEMPSIZE
   LPBYTE szSmallTemp2;         // SMALLTEMPSIZE

   LPMODEMCAPS lpMdmCaps;
   LPMODEMEXTCAPS lpMdmExtCaps;
   DWORD dwSerialSpeed;
   DWORD dwFlags;               // dwFlags, as defined in the CMDTAB structure.
   DWORD dwGot;
   USHORT uDontPurge;           // Profile entry says shouldn't delete the profile.
                                                        // NOTE: We will ignore this and not delete the
                                                        // profile if we don't get a response from the
                                                        // modem, to avoid unnecessarily deleting the
                                                        // profile simply because the modem is not
                                                        // responding/off/disconnected.
                                                        //
                                                        // 0 = purge
                                                        // 1 = don't purge
                                                        // anything else = uninitialized.

} S_TmpSettings;


typedef struct tagThreadGlobal {
        //  t30.c
    int                     RecoveryIndex;
    ET30PARAMS              Params;      // protocol\t30.h
    ET30T30                 T30;         // same
    ET30ECM                 ECM;         // same
    ET30ECHOPROTECT         EchoProtect; // same
        // protapi.c
    PROT                    ProtInst;    // protocol\protocol.h
    PROTPARAMS              ProtParams;  // headers\protparm.h
        // ddi.c
    MODEMPARAMS             ModemParams; // headers\modemddi.h
    CLASS1_MODEM            Class1Modem; // class1\class1.h
    CLASS1_STATUS           Class1Status;// same
        // ifddi.c
    CLASS1_DDI              DDI;         // same
        // 4. fcom.c
    FCOM_COMM               Comm;        // comm\fcomint.h
    BOOL                    fNCUAbort;// same,  0=None 2=abort FCOM 1=abort higher level only
        // identify.c
    S_TmpSettings           TmpSettings; // here
        // ncuparams.c
    NCUPARAMS               NCUParams;   // headers\ncuparm.h
    BOOL                    fNCUParamsChanged; //comm\modemint.h, to indicate the we need to reset params on next dial/answer...
        // modem.c
    FCOM_MODEM              FComModem;   // same
    FCOM_STATUS             FComStatus;  // same

    INSTDATA                Inst;        // fxrn\efaxrun.h

    HLINE                   LineHandle;
    HCALL                   CallHandle;
    DWORD                   DeviceId;
    HANDLE                  FaxHandle;
    HANDLE                  hComm;
        // memory management
    USHORT  uCount;
    USHORT  uUsed;
    BUFFER  bfStaticBuf[STATICBUFCOUNT];
    BYTE    bStaticBufData[STATICBUFSIZE];
        // additional mostly from gTAPI
    int                     fGotConnect;
    HANDLE                  hevAsync;
    int                     fWaitingForEvent;
    DWORD                   dwSignalledRID;
    DWORD                   dwSignalledParam2;
    DWORD_PTR               dwSignalledParam3;
    DWORD                   dwPermanentLineID;
    char                    lpszPermanentLineID[16];
    char                    lpszUnimodemFaxKey[200];
    char                    lpszUnimodemKey[200];
    TIFF_INFO               TiffInfo;
    LPBYTE                  TiffData;
    int                     TiffPageSizeAlloc;
    int                     TiffOffset;
    int                     fTiffOpenOrCreated;
    char                    lpszDialDestFax[MAXPHONESIZE];
    DWORD                   StatusId;
    DWORD                   StringId;
    DWORD                   PageCount;
    LPTSTR                  CSI;
    char                    CallerId[200];
    LPTSTR                  RoutingInfo;
    int                     fDeallocateCall;
    int                     CurrentCommSpeed;
    COMM_CACHE              CommCache;
    BOOL                    fMegaHertzHack;
    MONINFO                 gMonInfo;
    FCOM_FILTER             Filter;

#define MAXFILTERBUFSIZE 2048
    BYTE                    bStaticFilterBuf[MAXFILTERBUFSIZE];

#define CMDTABSIZE 100
    BYTE                    bModemCmds[CMDTABSIZE];    // store modem cmds read from INI/registry here

#define SMALLTEMPSIZE   80
    char                    szSmallTemp1[SMALLTEMPSIZE];
    char                    szSmallTemp2[SMALLTEMPSIZE];

    COMMODEM_FRAMING        Framing;

#define FRAMEBUFINITIALSIZE     ((USHORT)(((4 + 256 + 2) * 1.2) + 10)) // extra for flags
    BYTE                    bStaticFramingBuf[FRAMEBUFINITIALSIZE];


    BYTE                    bRem[MAXNSFFRAMESIZE];
    BYTE                    bOut[MAXNSFFRAMESIZE];

    PROTDUMP                fsDump;

#ifndef NOCHALL
    BYTE                    bSavedChallenge[POLL_CHALLENGE_LEN];
    USHORT                  uSavedChallengeLen;
#endif

#define TOTALRECVDFRAMESPACE    500
    BYTE                    bStaticRecvdFrameSpace[TOTALRECVDFRAMESPACE];

    DWORD                   lEarliestDialTime;

    RFS                     rfsSend;

    WORD                    PrevcbInQue;
    WORD                    PrevcbOutQue;
    BOOL                    PrevfXoffHold;
    BOOL                    PrevfXoffSent;


    LPWSTR                  lpwFileName;

    HANDLE                  CompletionPortHandle;
    ULONG_PTR                CompletionKey;

// helper thread interface
    BOOL                    fTiffThreadRunning;


    TX_THRD_PARAMS          TiffConvertThreadParams;
    BOOL                    fTiffThreadCreated;
    HANDLE                  hThread;

    HANDLE                  ThrdSignal;
    HANDLE                  FirstPageReadyTxSignal;

    DWORD                   CurrentOut;
    DWORD                   FirstOut;
    DWORD                   LastOut;
    DWORD                   CurrentIn;

    BOOL                    ThrdRuns;

    BOOL                    ReqTerminate;
    BOOL                    AckTerminate;
    BOOL                    ReqStartNewPage;
    BOOL                    AckStartNewPage;
    BOOL                    ThreadFatalError;

    char                    InFileName[_MAX_FNAME];
    HANDLE                  InFileHandle;
    BOOL                    InFileHandleNeedsBeClosed;
    BOOL                    fTxPageDone;
    BOOL                    fTiffPageDone;
    BOOL                    fTiffDocumentDone;

// helper RX interface


    BOOL                    fPageIsBad;      // Is the page bad (determined by rx_thrd)
    BOOL                    fPageIsBadOverride;  // Was fPageIsBad overridden in ICommPutRecvBuf
    BOOL                    fLastReadBlock;

    HANDLE                  ThrdDoneSignal;
    HANDLE                  ThrdAckTerminateSignal;

    DWORD                   ThrdDoneRetCode;

    DWORD                   BytesIn;
    DWORD                   BytesInNotFlushed;
    DWORD                   BytesOut;
    DWORD                   BytesOutWillBe;

    char                    OutFileName[_MAX_FNAME];
    HANDLE                  OutFileHandle;
    BOOL                    SrcHiRes;

// error reporting
    BOOL                    fFatalErrorWasSignaled;
    BOOL                    fLineTooLongWasIgnored;

// shutdown handling
    BOOL                    fShutdownInProgress;

// abort sync.

    HANDLE                  AbortReqEvent;
    HANDLE                  AbortAckEvent;
    
    // fUnblockIO:
    // Original documentation says: pending I/O should be aborted ONCE only
    //
    // This flag never initiated, but it's value is FALSE (0) at start. 
    // The flag get the value TRUE on two conditions:
    // 1) Before wait on overlapped IO event or tapi event we check if there was  an abort,
    //    if so we turn this flag to TRUE. 
    // 2) While waiting for multiple objects, the abort event has become signaled
    // 
    //  After this flag become TRUE, it stays so and never become FALSE again.
    BOOL                    fUnblockIO;        

    BOOL                    fOkToResetAbortReqEvent;
    BOOL                    fAbortReqEventWasReset;

    BOOL                    fAbortRequested;
    // this is used to complete a whole IO operation (presumably a short one)
    // when this flag is set, the IO won't be disturbed by the abort event
    // this flag should NOT be set for long periods of time since abort
    // is disabled while it is set.
    BOOL                    fStallAbortRequest;

// CSID, TSID local/remote

    char                    LocalID[MAXTOTALIDLEN + 2];
    LPWSTR                  RemoteID;
    BOOL                    fRemoteIdAvail;

// Adaptive Answer
    BOOL                    AdaptiveAnswerEnable;

// Unimodem setup
    DWORD                   dwSpeakerVolume;
    DWORD                   dwSpeakerMode;
    BOOL                    fBlindDial;

// INF settings
    BOOL                    fEnableHardwareFlowControl;

    UWORD                   SerialSpeedInit;
    BOOL                    SerialSpeedInitSet;
    UWORD                   SerialSpeedConnect;
    BOOL                    SerialSpeedConnectSet;
    UWORD                   FixSerialSpeed;
    BOOL                    FixSerialSpeedSet;

    BOOL                    fCommInitialized;

// derived from INF
    UWORD                   CurrentSerialSpeed;

// Unimodem key info
    char                    ResponsesKeyName[300];

// new ADAPTIVE.INF

    DWORD                   FaxClass;

    char                   *ResetCommand;
    char                   *SetupCommand;

    DWORD                   AnswerCommandNum;
#define MAX_ANSWER_COMMANDS 20
    char                   *AnswerCommand[MAX_ANSWER_COMMANDS];
    char                   *ModemResponseFaxDetect;
    char                   *ModemResponseDataDetect;
    UWORD                   SerialSpeedFaxDetect;
    UWORD                   SerialSpeedDataDetect;
    char                   *HostCommandFaxDetect;
    char                   *HostCommandDataDetect;
    char                   *ModemResponseFaxConnect;
    char                   *ModemResponseDataConnect;

    BOOL                    Operation;

// Flags to indicate the source of INF info

    BOOL                    fAdaptiveRecordFound;
    BOOL                    fAdaptiveRecordUnique;
    BOOL                    fUnimodemFaxDefined;
    DWORD                   AdaptiveCodeId;
    DWORD                   ModemKeyCreationId;


// Class2

    DWORD                   ModemClass;

    USHORT    cbResponseSize;
    BYTE    lpbResponseBuf[RESPONSE_BUF_SIZE];
    CL2_COMM_ARRAY  class2_commands;

    BYTE        FPTSreport;   // value from "+FPTS: X,..."  or "+FPS: X,..."

    NCUPARAMS   NCUParams2;
    LPCMDTAB        lpCmdTab;
    PROTPARAMS      ProtParams2;
    BYTE        bLastReply2[REPLYBUFSIZE+1];
    BYTE        bFoundReply[REPLYBUFSIZE+1];

    MFRSPEC                 CurrentMFRSpec;
    BYTE                    Class2bDLEETX[3];

    BYTE                    lpbResponseBuf2[RESPONSE_BUF_SIZE];

    BCwithTEXT      bcSendCaps; // Used to generate DIS
    BCwithTEXT      bcSendParams; // Used to generate DCS
    PCB DISPcb; // has default DIS values for this modem.

    BOOL        fAbort; // flag set when Class2Abort is called

    TO    toAnswer;
    TO    toRecv;
    TO    toDialog;
    TO    toZero;

#define C2SZMAXLEN 50

    C2SZ cbszFDT[C2SZMAXLEN];
    C2SZ cbszINITIAL_FDT[C2SZMAXLEN];
    C2SZ cbszFDR[C2SZMAXLEN];
    C2SZ cbszFPTS[C2SZMAXLEN];
    C2SZ cbszFCR[C2SZMAXLEN];
    C2SZ cbszFNR[C2SZMAXLEN];
    C2SZ cbszFCQ[C2SZMAXLEN];
    C2SZ cbszFLO[C2SZMAXLEN];

    C2SZ cbszFBUG[C2SZMAXLEN];
    C2SZ cbszSET_FBOR[C2SZMAXLEN];

    // DCC - set High Res, Huffman, no ECM/BFT, default all others.
    C2SZ cbszFDCC_ALL[C2SZMAXLEN];
    C2SZ cbszFDCC_RECV_ALL[C2SZMAXLEN];
    C2SZ cbszFDIS_RECV_ALL[C2SZMAXLEN];
    C2SZ cbszFDCC_RES[C2SZMAXLEN];
    C2SZ cbszFDCC_BAUD[C2SZMAXLEN];
    C2SZ cbszFDIS_BAUD[C2SZMAXLEN];
    C2SZ cbszFDIS_IS[C2SZMAXLEN];
    C2SZ cbszFDIS_NOQ_IS[C2SZMAXLEN];
    C2SZ cbszFDCC_IS[C2SZMAXLEN];
    C2SZ cbszFDIS_STRING[C2SZMAXLEN];
    C2SZ cbszFDIS[C2SZMAXLEN];
    C2SZ cbszZERO[C2SZMAXLEN];
    C2SZ cbszONE[C2SZMAXLEN];
    C2SZ cbszQUERY_S1[C2SZMAXLEN];
    C2SZ cbszRING[C2SZMAXLEN];


    C2SZ cbszCLASS2_ATI[C2SZMAXLEN];
    C2SZ cbszCLASS2_FMFR[C2SZMAXLEN];
    C2SZ cbszCLASS2_FMDL[C2SZMAXLEN];
    C2SZ cbszCLASS2_FREV[C2SZMAXLEN];

    C2SZ cbszFDT_CONNECT[C2SZMAXLEN];
    C2SZ cbszFDT_CNTL_Q[C2SZMAXLEN];
    C2SZ cbszFCON[C2SZMAXLEN];
    C2SZ cbszGO_CLASS2[C2SZMAXLEN];
    C2SZ cbszFLID[C2SZMAXLEN];
    C2SZ cbszENDPAGE[C2SZMAXLEN];
    C2SZ cbszENDMESSAGE[C2SZMAXLEN];
    C2SZ cbszCLASS2_QUERY_CLASS[C2SZMAXLEN];
    C2SZ cbszCLASS2_GO_CLASS0[C2SZMAXLEN];
    C2SZ cbszCLASS2_ATTEN[C2SZMAXLEN];
    C2SZ cbszATA[C2SZMAXLEN];
    // Bug1982: Racal modem, doesnt accept ATA. So we send it a PreAnswer
    // command of ATS0=1, i.r. turning ON autoanswer. And we ignore the
    // ERROR response it gives to the subsequent ATAs. It then answers
    // 'automatically' and gives us all the right responses. On hangup
    // however we need to send an ATS0=0 to turn auto-answer off. The
    // ExitCommand is not sent at all in Class2 and in Class1 it is only
    // sent on releasing the modem, not between calls. So just send an S0=0
    // after the ATH0. If the modem doesnt like it we ignore the response
    // anyway
    C2SZ cbszCLASS2_HANGUP[C2SZMAXLEN];
    C2SZ cbszCLASS2_CALLDONE[C2SZMAXLEN];
    C2SZ cbszCLASS2_ABORT[C2SZMAXLEN];
    C2SZ cbszCLASS2_DIAL[C2SZMAXLEN];
    C2SZ cbszCLASS2_NODIALTONE[C2SZMAXLEN];
    C2SZ cbszCLASS2_BUSY[C2SZMAXLEN];
    C2SZ cbszCLASS2_NOANSWER[C2SZMAXLEN];
    C2SZ cbszCLASS2_OK[C2SZMAXLEN];
    C2SZ cbszCLASS2_FHNG[C2SZMAXLEN];
    C2SZ cbszCLASS2_ERROR[C2SZMAXLEN];
    C2SZ cbszCLASS2_RESET[C2SZMAXLEN];
    C2SZ cbszCLASS2_ATE0[C2SZMAXLEN];

    BYTE    Resolution;
    BYTE    Encoding;


// Dbg
    DWORD                   CommLogOffset;
    DWORD                   dbg1;
    DWORD                   dbg2;
    DWORD                   dbg3;
    DWORD                   dbg4;
    DWORD                   dbg5;
//
//  Extension Data
//
    T30_EXTENSION_DATA      ExtData; 

    // NULL - PSS logging disabled
    // otherwise - file handle to log file
    HANDLE                  hPSSLogFile;
    
}   ThrdGlbl, *PThrdGlbl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\protapi.h ===
/***************************************************************************
 Name     :     PROTAPI.H
 Comment  : Interface to Protocol DLL

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "protparm.h"

// #define MAXNSFSIZE           40
// #define MAXSEPPWDSIZE        60





#define GET_SEND_MOD                    1
#define GET_RECV_MOD                    2
#define GET_ECM_FRAMESIZE               3
#define GET_PPR_FIF                             4
#define GET_WHATNEXT                    5
#define GET_MINBYTESPERLINE     6
#define RECEIVING_ECM                   7
#define GET_RECV_ECM_FRAMESIZE  8
#define GET_RECVECMFRAMECOUNT   10
#define RESET_RECVECMFRAMECOUNT 11
#define RESET_RECVPAGEACK               12
#define GET_PPS                                 15
#define GET_SEND_ENCODING               16
#define GET_RECV_ENCODING               17


// MUST match MSG_ flags in SOCKET.H
#       define NEXTSEND_MPS                     0x100
#       define NEXTSEND_EOM                     0x200
#       define NEXTSEND_EOP                     0x400
#       define NEXTSEND_ERROR           0x800




#define MINSCAN_0_0_0           7
#define MINSCAN_5_5_5           1
#define MINSCAN_10_10_10        2
#define MINSCAN_20_20_20        0
#define MINSCAN_40_40_40        4

#define MINSCAN_40_20_20        5
#define MINSCAN_20_10_10        3
#define MINSCAN_10_5_5          6

// #define MINSCAN_0_0_?                15              // illegal
// #define MINSCAN_5_5_?                9               // illegal
#define MINSCAN_10_10_5                 10
#define MINSCAN_20_20_10                8
#define MINSCAN_40_40_20                12

#define MINSCAN_40_20_10                13
#define MINSCAN_20_10_5                 11
// #define MINSCAN_10_5_?               14              // illegal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\glbproto.h ===
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\AWNSFINT.H


WORD EXPORTBC NSxtoBC(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                LPBC lpbcOut, WORD wBCSize);

WORD EXPORTBC BCtoNSx(PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from protocol\timeouts.h


#define TstartTimeOut(pTG, lpto, ulTime)             startTimeOut(pTG, lpto, ulTime)
#define TcheckTimeOut(pTG, lpto)                     checkTimeOut(pTG, lpto)



//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\timeouts.h

/****************** begin prototypes from timeouts.c *****************/
extern void    startTimeOut( PThrdGlbl pTG, TO *lpto, ULONG ulTimeOut);
extern BOOL    checkTimeOut( PThrdGlbl pTG, TO *lpto);
extern ULONG  leftTimeOut( PThrdGlbl pTG, TO *lpto);
/****************** begin prototypes from timeouts.c *****************/





//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\protapi.h



#define ProtGetSendMod(pTG)                  ((USHORT)ProtExtFunction(pTG, GET_SEND_MOD))
#define ProtGetRecvMod(pTG)                  ((USHORT)ProtExtFunction(pTG, GET_RECV_MOD))
#define ProtGetRetransmitMask(pTG)   ((LPBYTE)ProtExtFunction(pTG, GET_PPR_FIF))
#define ProtGetECMFrameSize(pTG)     ((USHORT)ProtExtFunction(pTG, GET_ECM_FRAMESIZE))
#define ProtGetRecvECMFrameSize(pTG) ((USHORT)ProtExtFunction(pTG, GET_RECV_ECM_FRAMESIZE))
#define ProtReceivingECM(pTG)                ((BOOL)ProtExtFunction(pTG, RECEIVING_ECM))
#define ProtGetWhatNext(pTG)                 ((LPWHATNEXTPROC)ProtExtFunction(pTG, GET_WHATNEXT))
#define ProtGetPPS(pTG)                      ((ULONG)ProtExtFunction(pTG, GET_PPS))

// have to use this in SendPhaseC
#define ProtGetMinBytesPerLine(pTG)         ((USHORT)ProtExtFunction(pTG, GET_MINBYTESPERLINE))
#define ProtGetRecvECMFrameCount(pTG)       ((USHORT)ProtExtFunction(pTG, GET_RECVECMFRAMECOUNT))
#define ProtResetRecvECMFrameCount(pTG) ((USHORT)ProtExtFunction(pTG, RESET_RECVECMFRAMECOUNT))
#define ProtResetRecvPageAck(pTG)           ((USHORT)ProtExtFunction(pTG, RESET_RECVPAGEACK))

#define ProtGetSendEncoding(pTG)            ((USHORT)ProtExtFunction(pTG, GET_SEND_ENCODING))
#define ProtGetRecvEncoding(pTG)            ((USHORT)ProtExtFunction(pTG, GET_RECV_ENCODING))



/****************** begin prototypes from protapi.c *****************/
BOOL    ProtGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep);
DWORD_PTR ProtExtFunction(PThrdGlbl pTG, USHORT uFunction);

                BOOL WINAPI ET30ProtSetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uRecvSpeeds, USHORT uSendSpeeds);
typedef BOOL (WINAPI *LPFN_ET30PROTSETPROTPARAMS)(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uRecvSpeeds, USHORT uSendSpeeds);
                BOOL WINAPI ET30ProtClose(PThrdGlbl pTG);
typedef BOOL (WINAPI *LPFN_ET30PROTCLOSE)(PThrdGlbl pTG);
                BOOL WINAPI iET30ProtSetBC(PThrdGlbl pTG, LPBC lpBC, BCTYPE bctype);
typedef BOOL (WINAPI *LPFN_IET30PROTSETBC)(PThrdGlbl pTG, LPBC lpBC, BCTYPE bctype);
                void WINAPI ET30ProtRecvPageAck(PThrdGlbl pTG, BOOL fAck);
typedef void (WINAPI *LPFN_ET30PROTRECVPAGEACK)(PThrdGlbl pTG, BOOL fAck);
                void WINAPI ET30ProtAbort(PThrdGlbl pTG, BOOL fEnable);
typedef void (WINAPI *LPFN_ET30PROTABORT)(PThrdGlbl pTG, BOOL fEnable);
                BOOL WINAPI ET30ProtOpen(PThrdGlbl pTG, BOOL fCaller);
typedef BOOL (WINAPI *LPFN_ET30PROTOPEN)(PThrdGlbl pTG, BOOL fCaller);

#ifdef OEMNSF
        // Ricoh IFS66 only
        void   LoadOEMNSFDll(PThrdGlbl pTG, HINSTANCE hinstModem);
        void   UnloadOEMNSFDll(PThrdGlbl pTG, BOOL fNormal);
#endif

#ifdef RICOHAI
        BOOL RicohAIInit(PThrdGlbl pTG);
        void RicohAIEnd(PThrdGlbl pTG);
        void RicohAIInitRecv(PThrdGlbl pTG);
#endif

/***************** end of prototypes from protapi.c *****************/


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\comapi.h

#define FComFilterAsyncWrite(pTG, lpb,cb,fl) (FComFilterWrite(pTG, lpb, cb, fl) == cb)
// #define FComFilterSyncWrite(lpb,cb)  ((FComFilterWrite(lpb, cb)==cb) && FComDrain(TRUE,TRUE))
#define FComDirectAsyncWrite(pTG, lpb,cb) (FComDirectWrite(pTG, lpb, cb) == cb)
#define FComDirectSyncWriteFast(pTG, lpb,cb)  ((FComDirectWrite(pTG, lpb, cb)==cb) && FComDrain(pTG, FALSE,TRUE))

#define FComFlush(pTG)                     { FComFlushQueue(pTG, 0); FComFlushQueue(pTG, 1); }
#define FComFlushInput(pTG)        { FComFlushQueue(pTG, 1); }
#define FComFlushOutput(pTG)       { FComFlushQueue(pTG, 0); }


extern BOOL    FComInit(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType);

extern BOOL    FComClose(PThrdGlbl pTG);
extern BOOL    FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate);
extern void    FComFlushQueue(PThrdGlbl pTG, int queue);
extern BOOL    FComXon(PThrdGlbl pTG, BOOL fEnable);
extern BOOL    FComDTR(PThrdGlbl pTG, BOOL fEnable);
extern UWORD   FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb);
extern UWORD   FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags);
extern BOOL    FComDrain(PThrdGlbl pTG, BOOL fLongTimeout, BOOL fDrainComm);
extern UWORD   FComFilterReadBuf(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lpto, BOOL fClass2, LPSWORD lpswEOF);
// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout
extern SWORD    FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead);

extern void    FComInFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterClose(PThrdGlbl pTG);

extern void    FComAbort(PThrdGlbl pTG, BOOL f);
extern void    FComCritical(PThrdGlbl pTG, BOOL);
extern void    FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin);

#if !defined(WFW) && !defined(WFWBG)
        extern BOOL   FComCheckRing(PThrdGlbl pTG);
        typedef BOOL (WINAPI *LPFN_FCOMCHECKRING)(PThrdGlbl pTG);
#endif
#ifndef MDRV
        BOOL FComGetOneChar(PThrdGlbl pTG, UWORD ch);
#endif //!MDRV


extern void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fStart);

/****************** begin DEBUG prototypes *****************/
extern void  far D_FComPrint(PThrdGlbl pTG, LONG_PTR nCid);
extern void  far D_HexPrint(LPB b1, UWORD incnt);

extern  void far D_GotError(PThrdGlbl pTG, LONG_PTR nCid, int err, COMSTAT far* lpcs);
typedef void (far  *LPFN_D_GOTERROR)(PThrdGlbl pTG, int nCid, int err, COMSTAT far* lpcs);

#ifdef WFWBG
        extern void  far FComSetBG(PThrdGlbl pTG, BOOL);
        typedef void (far  *LPFN_FCOMSETBG)(PThrdGlbl pTG, BOOL);
#endif
/***************** end of prototypes *****************/



/****************** begin prototypes from modem.c *****************/
extern USHORT  iModemInit(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
                                                                                        DWORD dwProfileID,
                                                                                        LPSTR lpszKey,
                                                                                        BOOL fInstall);
typedef USHORT (WINAPI  *LPFN_IMODEMINIT)(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType,
                                                                                        DWORD dwProfileID,
                                                                                        LPSTR lpszKey,
                                                                                        BOOL fInstall);
extern BOOL  iModemClose(PThrdGlbl pTG);
typedef BOOL (WINAPI  *LPFN_IMODEMCLOSE)(PThrdGlbl pTG);

extern BOOL     iModemSetNCUParams(PThrdGlbl pTG, int comma, int speaker, int volume, int fBlind, int fRingAloud);
extern BOOL     iModemHangup(PThrdGlbl pTG);
extern USHORT   iModemDial(PThrdGlbl pTG, LPSTR lpszDial, USHORT uClass);
extern USHORT   iModemAnswer(PThrdGlbl pTG, BOOL fImmediate, USHORT uClass);
extern LPCMDTAB   iModemGetCmdTabPtr(PThrdGlbl pTG);

// 6 fixed args, then variable number of CBPSTRs, but there
// must be at leat 2. One real one and one NULL terminator
extern UWORD  far iiModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                                        BOOL fMultiLine, UWORD uwRepeatCount, BOOL fPause,
                                        CBPSTR w1, CBPSTR w2, ...);
/***************** end of prototypes from modem.c *****************/






//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\filet30.h


ULONG_PTR   ProfileOpen(DWORD dwProfileID, LPSTR lpszSection, DWORD dwFlags);
                //                      dwProfileID should be one of DEF_BASEKEY or OEM_BASEKEY.
                //                      lpszSection should be (for example) "COM2" or "TAPI02345a04"
                //                      If dwProfileID == DEF_BASEKEY, the value is set to be a
                //                      sub key of:
                //                              HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\At Work Fax\
                //                              Local Modems\<lpszSection>.
                //                      Else if it is DEF_OEMKEY, it is assumed to be a fully-
                //                      qualified Key name, like "SOFTWARE\MICROSOFT.."
                //
                //                      Currently both are based of HKEY_LOCAL_MACHINE.
                //
                //      When you're finished with this key, call ProfileClose.
                //
                //  dwFlags is a combination of one of the fREG keys above..
                //
                //  WIN32 ONLY: if lpszSection is NULL, it will open the base key,
                //              and return its handle, which can be used in the Reg* functions.


// Following are emulations of Get/WritePrivateProfileInt/String...

BOOL   
ProfileWriteString(
    ULONG_PTR dwKey,
    LPSTR lpszValueName,
    LPSTR lpszBuf,
    BOOL  fRemoveCR 
    );


DWORD   ProfileGetString(ULONG_PTR dwKey, LPSTR lpszValueName, LPSTR lpszDefault, LPSTR lpszBuf , DWORD dwcbMax);
UINT   ProfileGetInt(ULONG_PTR dwKey, LPSTR szValueName, UINT uDefault, BOOL *fExist);


UINT   
ProfileListGetInt(
    ULONG_PTR  KeyList[10],
    LPSTR     lpszValueName,
    UINT      uDefault
);


// Following read/write binary data (type REG_BINARY). Available
// on Win32 only....

// Returns size of data read
DWORD   ProfileGetData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf , DWORD dwcbMax);
// Returns true on success. Deletes Value if lpbBuf is NULL.
BOOL    ProfileWriteData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf , DWORD dwcb);

void   ProfileClose(ULONG_PTR dwKey);
BOOL   ProfileDeleteSection(DWORD dwProfileID, LPSTR lpszSection);

BOOL   
ProfileCopySection(
      DWORD   dwProfileIDTo,
      LPSTR   lpszSectionTo,  
      DWORD   dwProfileIDFr,
      LPSTR   lpszSectionFr,
      BOOL    fCreateAlways
);

BOOL   ProfileCopyTree(DWORD dwProfileIDTo,
                        LPSTR lpszSectionTo, DWORD dwProfileIDFrom, LPSTR lpszSectionFrom);







//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



// from headers\modemddi.h


/****************** begin prototypes from ddi.c *****************/
                USHORT  NCUModemInit(PThrdGlbl pTG, DWORD lInitParam);
                void  NCUModemDeInit(PThrdGlbl pTG);
#ifdef UNUSED
                void  NCUGetConfig(PThrdGlbl pTG, LPNCUCONFIG lpNCUConfig);
#endif // UNUSED
                USHORT  NCUCheckRing(PThrdGlbl pTG, USHORT uLine);
                USHORT  NCUCheckHandset(PThrdGlbl pTG, USHORT uHandset);
                BOOL  NCUSetParams(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams);
typedef BOOL (WINAPI  *LPFN_NCUSETPARAMS)(PThrdGlbl pTG, USHORT uLine, LPNCUPARAMS lpNCUParams);
                HLINE  NCUGetLine(PThrdGlbl pTG, USHORT uLine);
                BOOL   NCUReleaseLine(PThrdGlbl pTG, HLINE hLine);
                USHORT   NCULink(PThrdGlbl pTG, HLINE hLine, HMODEM hModem, USHORT uHandset, USHORT uFlags);
                USHORT   NCUDial(PThrdGlbl pTG, HLINE hLine, LPSTR szPhoneNum);
                USHORT   NCUTxDigit(PThrdGlbl pTG, HLINE hLine, char chDigit);
                void   NCUAbort(PThrdGlbl pTG, USHORT uLine, BOOL fEnable);
typedef void (WINAPI   *LPFN_NCUABORT)(PThrdGlbl pTG, USHORT uLine, BOOL fEnable);
                HMODEM  ModemOpen(PThrdGlbl pTG, USHORT uModemType, USHORT uModem);
                BOOL    ModemClose(PThrdGlbl pTG, HMODEM hModem);
                BOOL    ModemGetCaps(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpModemCaps);
typedef BOOL (WINAPI    *LPFN_MODEMGETCAPS)(PThrdGlbl pTG, USHORT uModem, LPMODEMCAPS lpModemCaps);
                BOOL  ModemSync(PThrdGlbl pTG, HMODEM hModem, ULONG     ulTimeout);

                // 4/12/95 JosephJ. +++ Hack to prevent ModemSync from issuing AT
                // on sending DCN.
                BOOL  ModemSyncEx(PThrdGlbl pTG, HMODEM hModem, ULONG   ulTimeout, DWORD dwFlags);
                        // dwFlags -- one of...
#                       define fMDMSYNC_DCN 0x1L

                BOOL  ModemFlush(PThrdGlbl pTG, HMODEM);
                USHORT  ModemConnectTx(PThrdGlbl pTG, HMODEM, ULONG ulTimeout, WORD wFlags);
                USHORT  ModemConnectRx(PThrdGlbl pTG, HMODEM, WORD wFlags);
                BOOL  ModemSendMode(PThrdGlbl pTG, HMODEM, USHORT uMod, BOOL fHDLC, USHORT ifrHint);
#ifdef UNUSED
                BOOL  ModemSendTCF(PThrdGlbl pTG, HMODEM, USHORT uMod, ULONG ulDuration);
#endif // UNUSED
                BOOL  ModemSendMem(PThrdGlbl pTG, HMODEM, LPBYTE lpb, USHORT uCount, USHORT uParams);
                BOOL  ModemSendSilence(PThrdGlbl pTG, HMODEM, USHORT uMillisecs, ULONG ulTimeout);
                BOOL  ModemRecvSilence(PThrdGlbl pTG, HMODEM, USHORT uMillisecs, ULONG ulTimeout);
                USHORT  ModemRecvMode(PThrdGlbl pTG, HMODEM, USHORT uMod, BOOL fHDLC, ULONG ulTimeout, USHORT ifrHint);
                USHORT  ModemRecvMem(PThrdGlbl pTG, HMODEM, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
                BOOL  ModemSetParams(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParms);
typedef BOOL (WINAPI  *LPFN_MODEMSETPARAMS)(PThrdGlbl pTG, USHORT uModem, LPMODEMPARAMS lpParms);
                void  ModemEndRecv(PThrdGlbl pTG, HMODEM);
                BOOL  NCUModemUpdateConfig(PThrdGlbl pTG);
/***************** end of prototypes from ddi.c *****************/

// Modem Diagnostics API
DWORD  NCUModemDiagnostic(PThrdGlbl pTG, HLINE, HMODEM, WORD inparam);


//////////////// This is used for Modem Diagnostics //////////////

// Start a Modem diagnostic session
WORD WINAPI MdmStartDiagnostic(PThrdGlbl pTG);
// return a handle or 0 on failure (modem busy)

// Execute a modem diagnostic & return result
DWORD WINAPI MdmExecDiagnostic(PThrdGlbl pTG, WORD hndle, WORD inparam);
// calls Low-level modem driver disgnostic function
// NCUModemDiagnostic(HLINE, HMODEM, WORD inparam)
// and returned the DWORD result

// Start a Modem transport diagnostic session
WORD WINAPI MdmEndDiagnostic(PThrdGlbl pTG, WORD hndle);




//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//fxrn

void SetFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail);
void SetStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3);

LPBUFFER  MyAllocBuf(PThrdGlbl pTG, LONG sSize);
BOOL  MyFreeBuf(PThrdGlbl pTG, LPBUFFER);
void MyAllocInit(PThrdGlbl pTG);


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//negot.c

BOOL NegotiateCaps(PThrdGlbl pTG);




//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// my own stuff


typedef VOID (T30LINECALLBACK)(
    HLINE               hLine,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );


VOID
T30LineCallBackFunction(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );




VOID FaxDevInit(PThrdGlbl pTG, HLINE   hLine,HCALL   hCall);
BOOL    T30ComInit( PThrdGlbl pTG, HANDLE hComm);
PVOID T30AllocThreadGlobalData(VOID);
BOOL T30Cl1Rx (PThrdGlbl  pTG);
BOOL T30Cl1Tx (PThrdGlbl  pTG,LPSTR      szPhone);

HANDLE T30GetCommHandle(HLINE   hLine, HCALL   hCall);



USHORT
T30ModemInit(PThrdGlbl pTG,HANDLE  hComm,DWORD   dwLineID,DWORD   dwLineIDType,
             DWORD   dwProfileID, LPSTR   lpszKey, BOOL    fInstall);


BOOL itapi_async_setup(PThrdGlbl pTG);
BOOL itapi_async_wait(PThrdGlbl pTG,DWORD dwRequestID,PDWORD lpdwParam2,PDWORD_PTR lpdwParam3,DWORD dwTimeout);
BOOL itapi_async_signal(PThrdGlbl pTG, DWORD dwRequestID, DWORD dwParam2, DWORD_PTR dwParam3);

LPLINECALLPARAMS itapi_create_linecallparams(void);

void
GetCommErrorNT(
    PThrdGlbl       pTG,
    HANDLE          h,
    int*            pn,
    LPCOMSTAT       pstat);


int
ReadFileNT(
    PThrdGlbl       pTG,
    HANDLE          h,
    LPVOID          lpBuffer,
    DWORD           BytesToRead,
    LPDWORD         BytesHadRead,
    LPOVERLAPPED    lpOverlapped,
    DWORD           TimeOut,
    HANDLE          SecondEvent
    );


void
ClearCommCache(
    PThrdGlbl   pTG
    );

BOOL MonInit(PThrdGlbl pTG, LPMONOPTIONS lpmo);
                // dwPrefNumMRs - preferred number of MONREC structures in circ. buf
                // dwPrefBufSize - preferred size of byte circular buf
                // -- May globally alloc data of the appropriate size.
                // -- May use internal static data


void MonDeInit(PThrdGlbl pTG);
                // Inverse of MonInit.

BOOL MonPutComm(PThrdGlbl pTG, WORD wFlags, LPBYTE lpb, WORD wcb);
                // Adds comm info to monitor record.

BOOL MonPutEvent(PThrdGlbl pTG, WORD wFlags, WORD wID, WORD wSubID,
                                        DWORD dwData0, DWORD dwData1, LPSTR lpszTxtMsg);
                // Adds event info to monitor record.

void MonDump(PThrdGlbl pTG);
                // Dumps the .mon (byte buffer) and .mrc (MONREC buffer) to the
                // file constructed using lpszStubName, if non NULL.
                // EG: if lpszStubName == "d:\logs\awfax", the files
                // Created would be of the form "d:\logs\awfaxN.mon" and
                // "d:\logs\awfaxN.mrc", where N is a number starting with 0 and
                // incremented each time MonDump is called (it wraps around at 16
                // currently). N is reset to zero each time MonInit is called.
                // If lpszStubName is NULL, a default of "c:\fax" is used instead.

UWORD FComStripBuf(PThrdGlbl pTG, LPB lpbOut, LPB lpbIn, UWORD cb, BOOL fClass2, LPSWORD lpswEOF);

void InitCapsBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);

BOOL
SignalStatusChange(
    PThrdGlbl   pTG,
    DWORD       StatusId
    );

////////////////////////////////////////////////////////////////////
// Ansi prototypes
////////////////////////////////////////////////////////////////////

VOID  CALLBACK
T30LineCallBackFunctionA(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );

BOOL WINAPI
FaxDevInitializeA(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );


BOOL WINAPI
FaxDevStartJobA(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR       CompletionKey
    );

BOOL WINAPI
FaxDevEndJobA(
    HANDLE          FaxHandle
    );


BOOL WINAPI
FaxDevSendA(
    IN  HANDLE               FaxHandle,
    IN  PFAX_SEND_A          FaxSend,
    IN  PFAX_SEND_CALLBACK   FaxSendCallback
    );

BOOL WINAPI
FaxDevReceiveA(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE_A      FaxReceive
    );

BOOL WINAPI
FaxDevReportStatusA(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperationA(
    HANDLE              FaxHandle
    );


HRESULT WINAPI 
FaxDevShutdownA();



HANDLE
TiffCreateW(
    LPWSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    );




HANDLE
TiffOpenW(
    LPWSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly
    );



// fast tiff


DWORD
TiffConvertThreadSafe(
    PThrdGlbl   pTG
    );

DWORD
TiffConvertThread(
    PThrdGlbl   pTG
    );


DWORD
PageAckThreadSafe(
    PThrdGlbl   pTG
    );

DWORD
PageAckThread(
    PThrdGlbl   pTG
    );


VOID
SignalHelperError(
    PThrdGlbl   pTG
    );


DWORD
ComputeCheckSum(
    LPDWORD     BaseAddr,
    DWORD       NumDwords
    );

BOOL
SignalRecoveryStatusChange(
    T30_RECOVERY_GLOB   *Recovery
    );


int
SearchNewInfFile(
       PThrdGlbl     pTG,
       char         *Key1,
       char         *Key2,
       BOOL          fRead
       );


int 
my_strcmp(
       LPSTR sz1,
       LPSTR sz2
       );


void 
TalkToModem (
       PThrdGlbl pTG,
       BOOL      fGetClass
       );


BOOL
SaveInf2Registry (
       PThrdGlbl pTG
       );

BOOL
SaveModemClass2Registry  (
       PThrdGlbl pTG
       );


BOOL
ReadModemClassFromRegistry  (
       PThrdGlbl pTG
       );


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       );



BOOL
RemoveCR (
     LPSTR  sz
     );



/***  BEGIN PROTOTYPES FROM CLASS2.c ***/

BOOL
T30Cl2Rx(
   PThrdGlbl pTG
);


BOOL 
T30Cl2Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL  Class2Send(PThrdGlbl pTG);
BOOL  Class2Receive(PThrdGlbl pTG);
USHORT Class2Dial(PThrdGlbl pTG, LPSTR lpszDial);
USHORT Class2Answer(PThrdGlbl pTG, BOOL fImmediate);
SWORD Class2ModemSync(PThrdGlbl pTG);
UWORD   Class2iModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                  BOOL fMultiLine, UWORD uwRepeatCount, ...);
BOOL Class2ModemHangup(PThrdGlbl pTG);
BOOL Class2ModemAbort(PThrdGlbl pTG);
SWORD Class2HayesSyncSpeed(PThrdGlbl pTG, BOOL fTryCurrent, C2PSTR cbszCommand, UWORD uwLen);
USHORT Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout,
                        USHORT far* lpcbRecv);
BOOL  Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount);
DWORD Class2ModemDrain(PThrdGlbl pTG);
void Class2TwiddleThumbs(ULONG ulTime);
LPSTR Class2_fstrstr( LPSTR sz1, LPSTR sz2);
USHORT Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution);
BOOL Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb);
USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout);
USHORT Class2EndPageResponseAction(PThrdGlbl pTG);
BOOL Class2GetModemMaker(PThrdGlbl pTG);
void Class2SetMFRSpecific(PThrdGlbl pTG, LPSTR lpszSection);
BOOL    Class2Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
void    Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);
void    Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb);
void Class2SetDIS_DCSParams(PThrdGlbl pTG, BCTYPE bctype, LPUWORD Encoding, LPUWORD Resolution,
        LPUWORD PageWidth, LPUWORD PageLength, LPSTR szID);

void    Class2BCHack(PThrdGlbl pTG);
BOOL Class2GetBC(PThrdGlbl pTG, BCTYPE bctype);
void Class2ReadProfile(PThrdGlbl pTG, LPSTR lpszSection);
void    cl2_flip_bytes( LPB lpb, DWORD dw);


BOOL   iModemGoClass(PThrdGlbl pTG, USHORT uClass);

void Class2Abort(PThrdGlbl pTG, BOOL fEnable);
BOOL  Class2NCUSet(PThrdGlbl pTG, LPNCUPARAMS NCUParams2);

void
Class2Init(
     PThrdGlbl pTG
);


BOOL
Class2SetProtParams(
     PThrdGlbl pTG,
     LPPROTPARAMS lp
);

/***    BEGIN PROTOTYPES FROM CLASS2_0.c ***/

BOOL
T30Cl20Rx (
    PThrdGlbl pTG
);


BOOL
T30Cl20Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL  Class20Send(PThrdGlbl pTG);
BOOL  Class20Receive(PThrdGlbl pTG);

void
Class20Init(
     PThrdGlbl pTG
);

BOOL Class20GetModemMaker(PThrdGlbl pTG);
           
BOOL    Class20Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\protdump.h ===
//////////////////////// Protocol Dump APIs ////////////////////////////

#ifdef PDUMP    // Protocol Dump





//macros defined to access fields of the protocol dump
#define GETPROTDUMPFRAME(lpprotdump,i)  \
        ((LPFR)(((LPBYTE)(lpprotdump->b)) + lpprotdump->uFrameOff[i]))  \

#define ISSENDFRAME(lpfr)       \
                ((lpfr->ifr & 0x80))

#define GETFCF(lpfr,lpszBuf)    \
                (wsprintf(lpszBuf,              \
                (LPSTR)(rgszFrName[lpfr->ifr & 0x7F])))

#define GETFIF(lpfr,lpszBuf)    \
{       \
        int j;  \
        *lpszBuf = '\0';                \
        for(j=0;j<lpfr->cb;j++) \
                lpszBuf += wsprintf(lpszBuf,"%02x",(WORD)lpfr->fif[j]); \
}


///////// Sample Code for walking & printing Protocol Dump ////////
//
// void PrintDump(LPPROTDUMP lpprotdump)
// {
//      int i, j;
//
//      RETAILMSG((SZMOD "-*-*-*-*-*-*-*-* Print Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));
//
//      for(i=0; i<(int)lpprotdump->uNumFrames; i++)
//      {
//              LPFR lpfr = (LPFR) (((LPBYTE)(lpprotdump->b)) + lpprotdump->uFrameOff[i]);
//              IFR  ifr = (lpfr->ifr & 0x7F);
//              BOOL fSend = (lpfr->ifr & 0x80);
//
//              BG_CHK(ifr <= ifrMAX);
//              RETAILMSG((SZMOD "%s: %s [ ",
//                                      (LPSTR)(fSend ? "Sent" : "Recvd"),
//                                      (LPSTR)(rgszFrName[ifr]) ));
//
//              for(j=0; j<lpfr->cb; j++)
//                      RETAILMSG(("%02x ", (WORD)lpfr->fif[j]));
//
//              RETAILMSG(("]\r\n"));
//      }
//
//      RETAILMSG((SZMOD "-*-*-*-*-*-*-*-* End Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));
// }
//
///////////////////////////////////////////////////////////////////



#ifdef DEFINE_FRNAME_ARRAY

#define ifrMAX                  48

LPSTR rgszFrName[ifrMAX] = {
#define         ifrNULL         0
                                                        "???",
#define         ifrDIS          1
                                                        "DIS",
#define         ifrCSI          2
                                                        "CSI",
#define         ifrNSF          3
                                                        "NSF",
#define         ifrDTC          4
                                                        "DTC",
#define         ifrCIG          5
                                                        "CIG",
#define         ifrNSC          6
                                                        "NSC",
#define         ifrDCS          7
                                                        "DCS",
#define         ifrTSI          8
                                                        "TSI",
#define         ifrNSS          9
                                                        "NSS",
#define         ifrCFR          10
                                                        "CFR",
#define         ifrFTT          11
                                                        "FTT",
#define         ifrMPS          12
                                                        "MPS",
#define         ifrEOM          13
                                                        "EOM",
#define         ifrEOP          14
                                                        "EOP",
#define         ifrPWD          15
                                                        "PWD",
#define         ifrSEP          16
                                                        "SEP",
#define         ifrSUB          17
                                                        "SUB",
#define         ifrMCF          18
                                                        "MCF",
#define         ifrRTP          19
                                                        "RTP",
#define         ifrRTN          20
                                                        "RTN",
#define         ifrPIP          21
                                                        "PIP",
#define         ifrPIN          22
                                                        "PIN",
#define         ifrDCN          23
                                                        "DCN",
#define         ifrCRP          24
                                                        "CRP",
#define         ifrPRI_MPS      25
                                                        "PRI_MPS",
#define         ifrPRI_EOM      26
                                                        "PRI_EOM",
#define         ifrPRI_EOP      27
                                                        "PRI_EOP",
#define         ifrCTC          28
                                                        "CTC",
#define         ifrCTR          29
                                                        "CTR",
#define         ifrRR           30
                                                        "RR" ,
#define         ifrPPR          31
                                                        "PPR",
#define         ifrRNR          32
                                                        "RNR",
#define         ifrERR          33
                                                        "ERR",
#define ifrPPS_NULL     34
                                                         "PPS-NULL",
#define ifrPPS_MPS      35
                                                         "PPS-MPS",
#define ifrPPS_EOM      36
                                                         "PPS-EOM",
#define ifrPPS_EOP      37
                                                         "PPS-EOP",
#define ifrPPS_PRI_MPS  38
                                                         "PPS-PRI-MPS",
#define ifrPPS_PRI_EOM  39
                                                         "PPS-PRI-EOM",
#define ifrPPS_PRI_EOP  40
                                                         "PPS-PRI-EOP",
#define ifrEOR_NULL     41
                                                         "EOR-NULL",
#define ifrEOR_MPS      42
                                                         "EOR-MPS",
#define ifrEOR_EOM      43
                                                         "EOR-EOM",
#define ifrEOR_EOP      44
                                                         "EOR-EOP",
#define ifrEOR_PRI_MPS  45
                                                         "EOR-PRI-MPS",
#define ifrEOR_PRI_EOM  46
                                                         "EOR-PRI-EOM",
#define ifrEOR_PRI_EOP  47
                                                         "EOR-PRI-EOP"
#define ifrMAX                  48
};

#endif //DEFINE_FRNAME_ARRAY

#endif //PDUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\mysched.h ===
/***************************************************************************
 Name     :     MYSCHED.H
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

///////////////////// Tasking/Sleep/Timing options ///////////////////
//
// There are 4 options available
// (1) Tasking/Sleeping thru DLLSCHED: #defs reqd are !TSK !TMR and !IFK
// (2) Tasking/Sleeping thru an IFKERNEL BGproc: #defs reqd TSK IFK and !TMR
// (3) Tasking thru WIN32: #defs reqd WIN32 !IFK !TMR
//
//      In this file we define the macros for each of these options
/////////////////////////////////////// Tasking/Sleep/Timing options ///////

#define ACTIVESLICE             50


// MySetSlice(x) is defined seperately in BGT30.C and FCOM.C
// MySleep() is defined seperately in BGT30.C and FCOM.C

#       ifdef NCR
#               define FComCriticalNeg(pTG, x)       FComCritical(pTG, x)
#       else    // NCR
#               define FComCriticalNeg(pTG, x)
#       endif

#       ifdef PCR
#               define EnterPageCrit()  FComCritical(pTG, TRUE)
#               define ExitPageCrit()   FComCritical(pTG, FALSE)
#       else
#               define EnterPageCrit(pTG)
#               define ExitPageCrit(pTG)
#       endif

#       define EnterFileT30CritSection() // replaced by Mutex stuff in EFAXRUN.H
#       define ExitFileT30CritSection()  // replaced by Mutex stuff in EFAXRUN.H



#ifdef DEBUG
# ifndef WIN32
#       define SLIPMULT         2
#       define SLIPDIV          2
# else
#       define SLIPMULT         1
#       define SLIPDIV          4
# endif
#       define BEFORESLEEP       DWORD t1, t2; t1=GetTickCount();
#       define AFTERSLEEP(x) t2=GetTickCount();                         \
                if((t2-t1) > (((x)*SLIPMULT)+((x)/SLIPDIV)))    \
                        DEBUGMSG(1, ("!!!SLEPT %ld. Wanted only %d!!!\r\n", (t2-t1), (x)));
#else
#       define BEFORESLEEP
#       define AFTERSLEEP(x)
#endif



//  Note: timeBeginPeriod,timeEndPeriod require mmsystem.h
//                which is not included in windows.h if WIN32_LEAN_AND_MEAN is defined.
#       define MY_TWIDDLETHUMBS(ulTime) \
        { \
                BEFORESLEEP \
                Sleep(ulTime); \
                AFTERSLEEP(ulTime) \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\prep.h ===
#include "defs.h"

#include "resource.h"

#include <ifaxos.h>

#include <awnsfapi.h>
#include <awnsfint.h>

#include "stdio.h"
#include "stdlib.h"

#include <memory.h>

#include "tchar.h"


#include "mysched.h"

#include <filet30.h>
#include <dosio.h>


#include "tipes.h"
#include "et30type.h"
#include "tapi.h"

#include "modemddi.h"
#include "protapi.h"

#include <faxdev.h>
#include "faxutil.h"


#include "timeouts.h"
#include "mon.h"

#include "root.h"

#include "class2.h"

#include "..\..\..\tiff\inc\tifflib.h"
#include "global.h"

#include "fcomapi.h"

#include "rl_debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\modemddi.h ===
/***************************************************************************
 Name     :     MODEMDDI.H
 Comment  :     Interface for Modem/NCU DDI

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#ifndef _MODEMDDI_
#define _MODEMDDI_


#include <ncuparm.h>

typedef struct {
        USHORT  uSize;                  // of this structure
        USHORT  uNumLines, uNumFaxModems, uNumDataModems, uNumHandsets;
        BOOL    fToneDial, fPulseDial;
} NCUCONFIG, far* LPNCUCONFIG;


/******************** Not Used *************************

typedef struct {
        USHORT uErrorCode, uErrorFlags, uExtErrorCode, uWarning;
} MODEMSTATUS, far* LPMODEMSTATUS;

#define         MODEMERR_OK                     0
#define         MODEMERR_TIMEOUT        1
#define         MODEMERR_HARDWARE       2
#define         MODEMERR_OVERRUN        3
#define         MODEMERR_DEADMAN        4
#define         MODEMERR_COMPORT        5
#define         MODEMERR_BUG            6
#define         MODEMERR_RESOURCES      7
#define         MODEMERR_BADPARAM       8

#define         MODEMERR_UNDERRUN       11
#define         MODEMERR_BADCOMMAND     12
#define         MODEMERR_BADCRC         13

#define         MODEMERRFLAGS_FATAL                     2
#define         MODEMERRFLAGS_TRANSIENT         1

#define         MODEMWARNING_UNDERRUN           1

// Tone generation etc
#define         TONE_CED        1
#define         TONE_CNG        2

**************************************************************/

typedef struct {
        USHORT  uSize, uClasses, uSendSpeeds, uRecvSpeeds;
        USHORT  uHDLCSendSpeeds, uHDLCRecvSpeeds;
} MODEMCAPS, far* LPMODEMCAPS;

// uClasses is one or more of the below
#define         FAXCLASS0               0x01
#define         FAXCLASS1               0x02
#define         FAXCLASS2               0x04
#define         FAXCLASS2_0             0x08    // Class4==0x10

// uSendSpeeds, uRecvSpeeds, uHDLCSendSpeeds and uHDLCRecvSpeeds
// are one or more of the below. If V27 is provided
// at 2400bps *only*, then V27 is *not* set
// V27 2400 (nonHDLC) is always assumed

#define V27                                     2               // V27ter capability at 4800 bps
#define V29                                     1               // V29 at 7200 & 9600 bps
#define V33                                     4               // V33 at 12000 & 14400 bps
#define V17                                     8               // V17 at 7200 thru 14400 bps
#define V27_V29_V33_V17         11              // 15 --> 11 in T30speak

// used only in selecting modulation -- not in capability
// #define V21                                  7               // V21 ch2 at 300bps
// #define V27_FALLBACK         32              // V27ter capability at 2400 bps



// various calls return & use these
//typedef         HANDLE          HLINE;
//typedef         HANDLE          HCALL;
typedef         HANDLE          HMODEM;

// NCUModemInit returns these
#define INIT_OK                         0
#define INIT_INTERNAL_ERROR     13
#define INIT_MODEMERROR         15
#define INIT_PORTBUSY           16
#define INIT_MODEMDEAD          17
#define INIT_GETCAPS_FAIL       18
#define INIT_USERCANCEL         19

// NCUCheckRing and NCUCheckHandset returns one of these
#define NCUSTATUS_IDLE                  0
#define NCUSTATUS_RINGING               1
#define NCUSTATUS_BUSY                  2
#define NCUSTATUS_OFFHOOK               3
#define NCUSTATUS_NODIALTONE    4
#define NCUSTATUS_ERROR                 5

// NCULink takes one of these flags     (mutually exclusive)
#define NCULINK_HANGUP                  0
#define NCULINK_TX                              1
#define NCULINK_RX                              2
#define NCULINK_OFFHOOK                 3
#define NCULINK_MODEMASK                0x7
// and this flag may be added along with NCULINK_RX
#define NCULINK_IMMEDIATE       16      // don't wait for NCUParams.RingsBeforeAnswer


// NCUDial(and iModemDial), NCUTxDigit, ModemConnectTx and ModemConnectRx return one of
#define         CONNECT_TIMEOUT                 0
#define         CONNECT_OK                      1
#define         CONNECT_BUSY                    2
#define         CONNECT_NOANSWER                3
#define         CONNECT_NODIALTONE              4
#define         CONNECT_ERROR                   5
#define         CONNECT_BLACKLISTED             6
#define         CONNECT_DELAYED                 7
// NCULink (and iModemAnswer) returns one of the following (or OK or ERROR)
#define CONNECT_RING_ERROR              7       // was ringing when tried NCULINK_TX
#define CONNECT_NORING_ERROR    8       // was not ringing when tried NCULINK_RX
#define CONNECT_RINGEND_ERROR   9       // stopped ringing before
                                                                        // NCUParams.RingsBeforeAnswer count was
                                                                        // was reached when tried NCULINK_RX

/////// SUPPORT FOR ADAPTIVE ANSWER ////////
#define CONNECT_WRONGMODE_DATAMODEM     10      // We're connected as a datamodem.


///////////////////////// Ricoh Only /////////////////////////////////

// ModemConnectTx() and ModemConnectRx() can take this flag.
// ModemConnectTx: When this flag is set, if it detects CED, it begins
//              transmitting 800Hz tone and immediately returns (before
//              tone transmission completes) the return value CONNECT_ESCAPE
// ModemConnectRx: When this flag is set, it enables 800Hz tone detection
//              If the tone is detected, then the return value is CONNECT_ESCAPE

#define RICOHAI_MODE                    128

// ModemConnectRx() and ModemConnectTx() can also return the following
// when 800Hz tone is detected or transmitted

#define CONNECT_ESCAPE                  128

///////////////////////// Ricoh Only /////////////////////////////////




// ModemOpen and ModemGetCaps take one of these for uType
#define         MODEM_FAX                       1
#define         MODEM_DATA                      2

// SendMode and RecvMode take one of these for uModulation
#define V21_300         7               // used an arbitary vacant slot
#define V27_2400        0
#define V27_4800        2
#define V29_9600        1
#define V29_7200        3
#define V33_14400       4
#define V33_12000       6

#define V17_START       8       // every code above this is considered V17
#define V17_14400       8
#define V17_12000       10
#define V17_9600        9
#define V17_7200        11

#define ST_FLAG                 0x10
#define V17_14400_ST    (V17_14400 | ST_FLAG)
#define V17_12000_ST    (V17_12000 | ST_FLAG)
#define V17_9600_ST             (V17_9600 | ST_FLAG)
#define V17_7200_ST             (V17_7200 | ST_FLAG)


// SendMem take one one or more of these for uFlags
// SEND_ENDFRAME must _always_ be TRUE in HDLC mode
// (partial frames are no longer supported)
#define SEND_FINAL                      1
#define SEND_ENDFRAME           2
// #define SEND_STUFF                   4

// RecvMem and RecvMode return one these
#define RECV_OK                                 0
#define RECV_ERROR                              1
#define RECV_TIMEOUT                    2
#define RECV_WRONGMODE                  3       // only Recvmode returns this
#define RECV_OUTOFMEMORY                4
#define RECV_EOF                                8
#define RECV_BADFRAME                   16


// Min modem recv buffer size. Used for all recvs
// For IFAX30: *All* RecvMem calls will be called with exactly this size
#define MIN_RECVBUFSIZE                 265

// Max phone number size passed into NCUDial
#define MAX_PHONENUM_LEN        60




/**-- may be used in ModemSendMode ----**/
#define         ifrDIS          1
#define         ifrCSI          2
#define         ifrNSF          3
#define         ifrDTC          4
#define         ifrCIG          5
#define         ifrNSC          6
#define         ifrDCS          7
#define         ifrTSI          8
#define         ifrNSS          9
#define         ifrCFR          10
#define         ifrFTT          11
#define         ifrMPS          12
#define         ifrEOM          13
#define         ifrEOP          14
#define         ifrPWD          15
#define         ifrSEP          16
#define         ifrSUB          17
#define         ifrMCF          18
#define         ifrRTP          19
#define         ifrRTN          20
#define         ifrPIP          21
#define         ifrPIN          22
#define         ifrDCN          23
#define         ifrCRP          24
#define         ifrPRI_MPS      25
#define         ifrPRI_EOM      26
#define         ifrPRI_EOP      27
#define         ifrCTC          28
#define         ifrCTR          29
#define         ifrRR           30
#define         ifrPPR          31
#define         ifrRNR          32
#define         ifrERR          33
#define         ifrPPS_NULL             34
#define         ifrPPS_MPS              35
#define         ifrPPS_EOM              36
#define         ifrPPS_EOP              37
#define         ifrPPS_PRI_MPS  38
#define         ifrPPS_PRI_EOM  39
#define         ifrPPS_PRI_EOP  40
#define         ifrEOR_NULL             41
#define         ifrEOR_MPS              42
#define         ifrEOR_EOM              43
#define         ifrEOR_EOP              44
#define         ifrEOR_PRI_MPS  45
#define         ifrEOR_PRI_EOM  46
#define         ifrEOR_PRI_EOP  47

// don't use these values
// #define              ifrMAX          48
// #define              ifrBAD          49
// #define              ifrTIMEOUT      50
// #define              ifrERROR        51

/**-- may be used in ModemSendMode and ModemRecvMode ----**/
#define         ifrTCF                  55
// #define              ifrPIX          56      // not used anymore
#define         ifrECMPIX               57
#define         ifrPIX_MH               67
#define         ifrPIX_MR               68
#define         ifrPIX_SWECM    69

/**-- may be used in ModemRecvMode ----**/
// each value corresponds to one of the "Response Recvd" and
// "Command Recvd" boxes in the T30 flowchart.

#define         ifrPHASEBresponse       58              // receiver PhaseB
#define         ifrTCFresponse          59              // sender after sending TCF
#define         ifrPOSTPAGEresponse     60              // sender after sending MPS/EOM/EOP
#define         ifrPPSresponse          61              // sender after sending PPS-Q
#define         ifrCTCresponse          62              // sender after sending RR
#define         ifrRRresponse           63              // sender after sending RR

#define         ifrPHASEBcommand        64              // sender PhaseB
#define         ifrNODEFcommand         65              // receiver main loop (Node F)
#define         ifrRNRcommand           66              // receiver after sending RNR

#define         ifrEORresponse                  70
#define         ifrNODEFafterWRONGMODE  71      // hint for RecvMode after WRONGMODE
#define         ifrEOFfromRECVMODE              72      // GetCmdResp retval if RecvMode returns EOF
#define         ifrEND          73      // Max legal values (not incl this one)


// messages posted by NCUHandsetNotif and NCURingNotif

#define IF_MODEM_START  (IF_START+0x321)
#define IF_MODEM_END    (IF_START+0x325)

#define IF_NCU_RING             (IF_MODEM_START + 0x00)
#define IF_NCU_HANDSET  (IF_MODEM_START + 0x01)



#endif //_MODEMDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\mon.h ===
// COMM MONITOR CODE
// 2/11/95      JosephJ Created
//
//      The functions MonInit, MonDeInit, MonPut and MonDump may be used
//  to  timestamp and log all reads from/writes using the comm apis.
//  MonDump creates two files, one a byte buffer, and the 2nd
//  an array of MONREC structures, each structure containing a timestamp
//  and an offset into the first file that points to the actual comm data.




// Following two macros to be called before each write attempt
// and after each non-zero read.
#       define INMON(pTG, lpb, cb) \
        (pTG->gMonInfo.fInited && MonPutComm(pTG, fMON_COMM_IN, lpb,cb))
#       define OUTMON(pTG, lpb, cb) \
        (pTG->gMonInfo.fInited && MonPutComm(pTG, fMON_COMM_OUT, lpb,cb))
#       define  PUTEVENT(pTG, wFlags, ID, SubID, dw0, dw1, lpsz)\
        (pTG->gMonInfo.fInited && MonPutEvent(pTG, wFlags, ID, SubID, dw0, dw1, lpsz))

//File extensions for the mon-file
#define szMON_EXT "mon"


// Min and  Max sizes of internal buffers allocated for monitoring.
// MonInit will enforce that the sizes fall within this range.
#define MIN_MRBUFSIZE           (65536L>>2)
#define MIN_DATABUFSIZE         65536L

#define MAX_MRBUFSIZE           1000000L
#define MAX_DATABUFSIZE         1000000L

// Following structure records time of each call to read/write
// to comm. It also contains an offset into a circular buffer which
// contains all data writen to/read from comm port.
// wFlags is a word of information that was specified in the call to MonPut
// Currently it is a combination of the fMON_* flags above.
typedef struct
{
        WORD wFlags;            // One of fMON_* flags above. (A parameter to MonPut)
        WORD wcb;                       // Number of bytes of variable-lenghth data
        DWORD dwTickCount;      // GetTickCount at time of MonPut call
        DWORD dwOffset;         // Offset into circular byte-buffer where data is.
} MONREC, FAR *LPMONREC;


#define MFR_COMMDATA    1
#define MFR_EVENT               2

// Following flags are specified in the wFlags param of MonPut. They
// are  saved in the corresponding field of the MONREC structures.
#define fMON_COMM_RESERVED      (0x1<<15) // Should never be used.
#define fMON_COMM_IN            (0x1<<0) // Read operation
#define fMON_COMM_OUT           (0x1<<1) // Write operation
#define fMON_COMM_CMDRESP       (0x1<<3) // We believe modem is in command mode
#define fMON_COMM_DATA          (0x1<<4) // We believe modem is in data mode

#define EVENT_ID_TXTMSG         1               // Generic text message.
#define EVENT_ID_MON            10              // Related to the monitoring processitself.

#define EVENT_ID_T30_BASE       100             // T30-protocol-stack related.
#define EVENT_ID_T30_CALLSTATE  100     // T30-protocol: call state related.

#define EVENT_ID_MODEM_BASE     200             // Modem-related
#define EVENT_ID_MODEM_STATE    200     // Initialize modem

#define EVENT_SubID_NULL        0               // Nothing.

#define EVENT_SubID_MON_DUMP 1          // Dump (write to file) of in-memory record
                                                                        // TextID contains timestamp of start, as
                                                                        // well as number of puts, and bytes written
                                                                        // dwData0=dwData1=0
                                                                        // SubID=0

#define EVENT_SubID_T30_CS_SEND_START   1       // Initiate T.30 Send
                                                                        // Displayable phone number is embedded in
                                                                        // TxtMessage.
                                                                        // dwData0=dwData1=0;
#define EVENT_SubID_T30_CS_SEND_END     2       // End T.30 Send
                                                                        // dwData0=result code
#define EVENT_SubID_T30_CS_RECV_START   11      // Initiate T.30 Recv
                                                                        // dwData0=dwData1=0;
#define EVENT_SubID_T30_CS_RECV_END     12      // End T.30 Recv
                                                                        // dwData0=result code

#define EVENT_SubID_MODEM_INIT_START 1  // About to issue commands to Init modem
#define EVENT_SubID_MODEM_INIT_END 2    // Done initing.
                                                                        // dwData0=return code


#define EVENT_SubID_MODEM_DEINIT_START 11 // About to issue commands to deinit
#define EVENT_SubID_MODEM_DEINIT_END  12 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_SENDMODE_START 21 // About to issue commands to deinit
#define EVENT_SubID_MODEM_SENDMODE_END  22 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_RECVMODE_START 31 // About to issue commands to deinit
#define EVENT_SubID_MODEM_RECVMODE_END  32 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_DIAL_START 41 // About to issue commands to dial
                                                                                // szTxtMsg contains dial string
                                                                                // In retail, digits after first 4
                                                                                // are zapped.
#define EVENT_SubID_MODEM_DIAL_END  42 // Done dialing
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_ANSWER_START 51 // About to issue commands to answer
#define EVENT_SubID_MODEM_ANSWER_END  52 // Done with the answer command
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_HANGUP_START 61 // About to issue commands to answer
#define EVENT_SubID_MODEM_HANGUP_END  62 // Done with the answer command
                                                                        // dwData0=return code


#pragma pack(1)
typedef struct {
        WORD wTotalSize;
        WORD wHeaderSize;
        WORD wType;             // One of the MFR_* defines
        WORD wFlags;    // type dependant
        DWORD dwTickCount;      // GetTickCount() at time of call to MonPut.
} MONFRAME_BASE, FAR *LPMONFRAME_BASE;
#pragma pack()

// Following inserted in mon file to document data structure.
// Make sure it matches above structure.
#define szMONFRM_DESC001\
                "struct{WORD wcbTot; WORD wcbHdr; WORD wTyp; WORD wFlg; DWORD dwTick}"
// Update version when structure changes.
#define szMONFRM_VER001 "V.100"

#pragma pack(1)
typedef struct {
        WORD wTotalSize;
        WORD wHeaderSize;
        WORD wType;             // One of the MFR_* defines
        WORD wFlags;    // One of the fMON_COMM_* values.
        DWORD dwTickCount;      // GetTickCount() at time of call to MonPut.
        WORD wcb;          // Count of bytes following.
        BYTE rgb[];             // Actuall bytes of comm data.
} MONFRAME_COMM, FAR *LPMONFRAME_COMM;
#pragma pack()

#define fEVENT_ERROR_MASK        0x111
#define fEVENT_ERROR_NONE        0x000
#define fEVENT_ERROR_FATAL       0x001
#define fEVENT_ERROR_SERIOUS 0x010
#define fEVENT_ERROR_MSGFAIL 0x011
#define fEVENT_ERROR_OTHER       0x100
#define fEVENT_ERROR_WARNING 0x101

#define fEVENT_TRACELEVEL_MASK 0x11000
#define fEVENT_TRACELEVEL_0    0x00000  // Vital: MUST display
#define fEVENT_TRACELEVEL_1    0x01000  // Important
#define fEVENT_TRACELEVEL_2    0x10000  // Less important
#define fEVENT_TRACELEVEL_3    0x11000  // Least important

#define MAX_TXTMSG_SIZE 128                             // Max size of text msg in a MONFRAME_EVENT structure.

#pragma pack(1)
typedef struct {
        WORD    wTotalSize;
        WORD    wHeaderSize;
        WORD    wType;                  // Should be MFR_EVENT
        WORD    wFlags;                 // One of the fEVENT_* flags.
        DWORD   dwTickCount;    // GetTickCount() at time of call to MonPut.
        WORD    wID;                    // ID of event. One of the EVENT_ID_* defines
        WORD    wSubID;                 // Sub ID of event. One of the EVENT_SubID_* defines
        DWORD   dwInstanceID;   // Instance ID of event within this file.
        DWORD   dwData0;                // ID-specific data
        DWORD   dwData1;                // ID-specific data
        SYSTEMTIME st;  // SystemTime at time of call to MonPut
        WORD    wTxtMsgOff;// Offset to null-terminated text message, if any
        WORD    wcbTxtMsg; // Size of null-terminated text message, if any
} MONFRAME_EVENT, FAR *LPMONFRAME_EVENT;
#pragma pack()

//  Monitor Options -- passed into MonInit
typedef struct {

        // Buffer options
        DWORD dwMRBufSize;              // preferred size -- actual size may be different
        DWORD dwDataBufSize;    // preferred size -- actual size may be different

        // File options
        DWORD dwMaxExistingSize;// If the size of the existing file
                                                        // is > this, we will rename the existing file
                                                        // and create a new one.
        char rgchDir[64];       // Directory where fax0.mon is to be created.

} MONOPTIONS, FAR * LPMONOPTIONS;

// Global monitor state
typedef struct {

        SYSTEMTIME      stStart;        // Set by MonInit.
        SYSTEMTIME      stDump;         // Set by MonDump.
        BOOL    fFreeOnExit;    // TRUE iff buffers must be freed on exit.
        BOOL    fInited;                // Set in MonInit. Cleared in MonDeInit.

        DWORD   dwNumPuts;              // Number of calls to MonPut
        DWORD   dwNumBytes;             // Cumulative number of bytes specified to MonPut
        UINT    uRefCount;              // Incremented each time MonDump is called
                                                        // Used to new file for each MonDump
                                                        // Cleared in MonInit and MonDeInit
        DWORD   dwEventInstanceID; // ID which is supposed to uniquely identify
                                                        // each event within a file.

        LPMONREC lpmrBuf;               // Pointer to MONREC circular buffer
        DWORD   dwcmrBuf;                       // Size (in units of MONREC) if circular buffer
        LPMONREC lpmrNext;              // Pointer to next available MR

        LPBYTE  lpbBuf;         // Pointer to circular byte buffer.
        DWORD   dwcbBuf;                // Size (in bytes) of above buffer.
        LPBYTE  lpbNext;                // Pointer to next place to write bytes in this buf.

        MONOPTIONS mo;                  // Passed in to MonInit();

} MONINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\ifaxos.h ===
#ifndef _INC_IFAXOS
#define _INC_IFAXOS

#ifdef __cplusplus
extern "C" {
#endif

// add SHIP_BUILD from Win95fax retail builds
#ifndef DEBUG
#ifdef WIN32
#define SHIP_BUILD
#endif
#endif

// -------------------------- Include Files ------------------------------------

#ifdef IFBGPROC
// Remove appropriate parts of windows.h
// #define NOKERNEL
#ifndef WANTGDI
#define NOGDI
#endif
// #define  NOUSER
#define NOSOUND
// #define  NOCOMM
// #define  NODRIVERS
// #define  NOMINMAX
// #define  NOLOGERROR
// #define  NOPROFILER
// #define  NOMEMMGR
// #define  NOLFILEIO
// #define  NOOPENFILE
// #define  NORESOURCE
// #define  NOATOM
// #define  NOLANGUAGE
// #define  NOLSTRING
// #define  NODBCS
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#ifndef WANTGDI
#define NOGDIOBJ
#define NOBITMAP
#endif
#define NODRAWTEXT
#define NOTEXTMETRIC
#define NOSCALABLEFONT
#define NORASTEROPS
#define NOMETAFILE
#define NOSYSMETRICS
#define NOSYSTEMPARAMSINFO
// #define NOMSG
#define NOWINSTYLES
#define NOWINOFFSETS
// #define  NOSHOWWINDOW
#define NODEFERWINDOWPOS
#define NOVIRTUALKEYCODES
#define NOKEYSTATES
#define NOWH
#define NOMENUS
#define NOSCROLL
#define NOCLIPBOARD
#define NOICONS
#define NOMB
#define NOSYSCOMMANDS
#define NOMDI
#define NOCTLMGR
#define NOWINMESSAGES
#define NOHELP
#endif

// put strict type checking on ... and get rid of multiple define warnings
#ifndef STRICT
#define STRICT
#endif

#ifndef WINDRV
#   ifdef WIN32
#       define _INC_OLE
#   endif
#   include <windows.h>
#  ifdef   WIN32
#      include <windowsx.h>
#  endif
#endif

#ifdef WIN32
#define DECLSPEC_IMPORT __declspec(dllimport)
#endif

#ifndef WIN32
// Define WINBASE to avoid mapi including some duplicate definitions
#define _WINBASE_
#endif

//-------------------------- General Defines ---------------------

#ifndef WIN32
#define STATIC  static
#define CONST   const
#define CHAR    char
#define UCHAR   BYTE
#define INT     int

typedef short    SHORT;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef CHAR    *PCHAR;
typedef VOID    *PVOID;
#endif

typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;

#define CARRAIGE_RETURN 0x0D
#define LINEFEED 0x0A
#define BACKSPACE 0x08
#define CNULL   0x00

#ifndef WIN32
#ifndef MAKEWORD
#  define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif
#  define EXPORT_DLL
#  define IMPORT_DLL
#else
#  ifndef HTASK
#     define HTASK HANDLE
#  endif
#  define __export __declspec( dllexport )
#  define _export  __declspec( dllexport )
#  define IMPORT_DLL __declspec( dllimport )
#  define EXPORT_DLL __declspec( dllexport )
#endif

// --------------- RESOURCE management -------------------------------

// Always define this for now ...
#ifndef SHIP_BUILD
// #if defined(VALIDATE) || defined(DEBUGAPI) || defined(DEBUG)

/********
    @doc    EXTERNAL    RESOURCE IFAXOS

    @type   VOID |  RESOURCE_ALLOC_FLAGS | Lists the resource management options
            for OS resource accounting.

    @emem   RES_ALLOC_TASK  |  This flag indicates that the resource in question
            is being allocated on behalf of the current process. The resource
            should not be directly passed on to any other process context. It
            should be freed by this process before termination - else the kernel
            will free it when the process dies (if running in debug).
            Ownership automatically gets transferred between tasks when standard
            IPC methods like pipes are used to transfer resources like Buffers.

    @emem   RES_ALLOC_NONE  | This flag is used to allocate resources which should
            not be accounted to any system module. The calling party essentially
            undertakes full responsibility for freeing this object. This is mainly
            to be used for resource allocated on behalf of messages in the store
            since their ownership is transferred to the current process which has
            the message open.

    @emem   HINSTANCE_DLL   | If the allocated resource is to be assigned to the
            calling DLL, the hinstance of the DLL should be passed in as the value
            of the ResourceFlags Word. These resources will be freed (in the debug
            version) when the DLL terminates. They will not be assigned to any
            particular process context.

    @xref   <f IFMemAlloc> <f CreateMutex> <f CreateEvent>
            <f IFPipeCreate> <f IFProcSetResFlags>
********/

#define RES_ALLOC_TASK  0x0000
#define RES_ALLOC_NONE  0x0001
#define RES_ALLOC_INTERNAL  0x0002
#define RES_ALLOC_CRITSEC  0x0003

#if defined(WFW) || defined(WIN32)

#define IFProcSetResFlags(wResFlags)  (0)

#else

extern EXPORT_DLL VOID WINAPI IFProcSetResFlags(WORD wResFlags);

#endif

#else

#define IFProcSetResFlags(p1) (0)

#endif

// --------------- ERROR Handling ------------------------------------

#include <errormod.h>

/********
    @doc    EXTERNAL    ERROR   IFAXOS

    @api    DWORD    | IFErrAssemble   | Forms an IFAX Error dword out of its components.

    @parm   BYTE    | bProcessID    | Identifies the process in whose context the error
            occured. Must be one of the predefined system process ID's - see <t SYSTEM_PROCESSES>
            for the list. This field does not need to be filled in until an error is
            propagated across a process boundary. If not being set to a valid PROCID, this
            should be initilialized to one of the following values:
            @flag  PROCID_WIN32 | if <p bModuleID> is set to MODID_WIN32.
            @flag  PROCID_NONE | for all other cases.

    @parm   BYTE    | bModuleID | Identifies the module reporting the error. MUST be
            one of the predefined system module ID's - see <t SYSTEM_MODULES> for the
            list.

    @parm   WORD    | wApiCode  | Identifies the API code for the error in the module indicated
            by <p bModuleID>. All Api codes should be defined in the file errormod.h. Api codes should
            be defined so that the low 6 bits are zero. This allows both the <p wApiCode> and the
            <p wErrorCode> to be logical OR'ed together and stored as a single word.

    @parm   WORD    | wErrorCode    | Identifies the error code. The format
            of this is module dependent. For uniformity however, it is highly
            encouraged that all IFAX modules use a standard format for this error word.
            This standard format reserves the first 6 bits for an error code,
            and the high 10 bits for an API identifier.

            If the IFAX format is being used, the <p wApiCode>
            parameter should be used to pass in the high 10 bits, and the <p wErrorCode> (This
            parameter!) should be used to pass in the 6 bit error code. Values upto ERR_FUNCTION_START
            are reserved for standard system errors - see <t SYSTEM_ERROR_VALUES> for the list.
            Error values should be positive and less than 64.

            Other modules like the filesystem conform completely to the Win32 Error space. These
            should set <p wErrorCode> to standard Win32 errors (use all 16 bits) and leave
            the <p wApiCode> as API_WIN32.

            Still others need to use all 16 bits in a custom manner - like the Printer Drivers.
            These *must* set the <p bModuleID> correctly so that the error can be interpreted
            appropriately. Standard processes like the UI have to understand these error codes,
            so only inbuilt system modules which they have knowledge about can use custom codes.
            These should set the wApiCode to API_NONE.

    @rdesc  Returns the DWORD representation for this error. This allows this to be directly
            passed in as input to <f SetLastError>.

    @ex     Example usage |

            SetLastError(IFErrAssemble(PROCID_NONE,MODID_IFKERNEL,API_IFK_POSTMESSAGE,ERR_INVALID_PARAM));

    @xref   <f IFErrGetModule> <f IFErrGetProcess> <f GetIFErrorErrcode> <f SetLastError>
            <f GetIFErrorApicode> <t SYSTEM_MODULES> <t SYSTEM_PROCESSES> <t SYSTEM_ERROR_VALUES>
            <f GetLastError> <f IFNVRamSetError> <f GetIFErrorCustomErrcode>
********/

#define IFErrAssemble(process,module,call,error) \
    MAKELONG((WORD)call|(WORD)error, MAKEWORD((BYTE)module, (BYTE)process))

/*********
    @doc    EXTERNAL ERROR  IFAXOS

    @api    BYTE    | IFErrGetModule  | Retrieves the module ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the module ID. This will be from the list specified in <t SYSTEM_MODULES>.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrSetModule>

    @api    BYTE    | IFErrGetProcess  | Retrieves the process ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the process ID. This will be from the list specified in <t SYSTEM_PROCESSES>.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrSetProcess>

    @api    WORD    | GetIFErrorErrcode  | Retrieves the error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. If less than ERR_FUNCTION_START, this is from the list
            in <t SYSTEM_ERROR_VALUES>.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorCustomErrcode  | Retrieves a custom 16 bit error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. This might be a Win32 error code if the module ID was
            MODID_WIN32, or a custom error code.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorApicode  | Retrieves the API code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the API code. API codes for all the system modules are documented in
            the file errormod.h

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES>

    @api    DWORD    | IFErrSetModule  | Sets the module ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. It's value is not changed by the call.

    @parm   BYTE    | bModule   | The module ID to be set from the list in <t SYSTEM_MODULES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrGetModule>

    @api    DWORD    | IFErrSetProcess  | Sets the Process ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. Its value is not changed by the call.

    @parm   BYTE    | bProcess   | The Process ID to be set from the list in <t SYSTEM_PROCESSES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrGetProcess>

********/
#define IFErrSetModule(errvar,module)  \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD((BYTE)module, HIBYTE(HIWORD((DWORD)errvar))))
#define IFErrSetProcess(errvar,process)    \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD(LOBYTE(HIWORD((DWORD)errvar)), (BYTE)process))
#define IFErrGetModule(errvar)    LOBYTE(HIWORD((DWORD)errvar))
#define IFErrGetProcess(errvar)   HIBYTE(HIWORD((DWORD)errvar))
#define GetIFErrorErrcode(errvar)   (LOWORD((DWORD)errvar) & 0x003F)
#define GetIFErrorApicode(errvar)   (LOWORD((DWORD)errvar) & 0xFFC0)
#define GetIFErrorCustomErrcode(errvar) LOWORD((DWORD)errvar)

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULES  | Identifiers for all the standard system modules.

    @emem   MODID_NONE          | Use this if you are not setting the module ID. DONT USE ZERO !!
    @emem   MODID_WIN32         | Set for modules returning standard Win32 system error codes
    @emem   MODID_BOSS          | ID = 1    Error in BOSS
    @emem   MODID_WINMODULE     | ID = 2    All windows modules including UER/GDI/KERNEL
    @emem   MODID_IFKERNEL      | ID = 3
    @emem   MODID_IFFILESYS     | ID = 4
    @emem   MODID_MSGSTORE      | ID = 5
    @emem   MODID_LINEARIZER    | ID = 6
    @emem   MODID_SECURITY      | ID = 7
    @emem   MODID_IFPRINT       | ID = 8    High level Printer Driver
    @emem   MODID_IFSCAN        | ID = 9    High level Scanner Driver
    @emem   MODID_IFSIPX        | ID = 10   SPX/IPX Stack
    @emem   MODID_REND_SERVER   | ID = 11   Rendering Server
    @emem   MODID_FORMAT_RES    | ID = 12   Format Resolution
    @emem   MODID_IFFILE        | ID = 13   IFFiles
    @emem   MODID_TEXTRENDERER  | ID = 14   Ascii Renderer
    @emem   MODID_DIGCOVPAGE    | ID = 15   Digital Coverpage
    @emem   MODID_AWBRANDER     | ID = 16   Fax Brander
    @emem   MODID_MSGSVR        | ID = 17   Message Server
    @emem   MODID_MSGHNDLR      | ID = 18  Per-Connection message handler
    @emem   MODID_MODEMDRV      | ID = 19  Modem driver
    @emem   MODID_PSIFAX       | ID = 20   PSI Fax protocol
    @emem   MODID_AWT30            | ID = 21
    @emem   MODID_PSIFAXBG     | ID = 22
    @emem   MODID_AWNSF            | ID = 23
    @emem   MODID_FAXCODEC      | ID = 24
    @emem   MODID_MSGPUMP       | ID = 25
    @emem   MODID_AWREPORT      | ID = 26
    @emem   MODID_MSGSVRD               | ID = 27


    @emem   MODID_CUSTOM        | ID = 160  Beyond this are custom/installable modules

    @xref   <f IFErrAssemble> <f IFErrGetModule>
********/
// System Module IDs
#define MODID_WIN32         0
#define MODID_BOSS          1
#define MODID_WINMODULE     2
#define MODID_IFKERNEL      3
#define MODID_IFFILESYS     4
#define MODID_MSGSTORE      5
#define MODID_LINEARIZER    6
#define MODID_SECURITY      7
#define MODID_IFPRINT       8
#define MODID_IFSCAN        9
#define MODID_IFSIPX        10
#define MODID_REND_SERVER   11
#define MODID_FORMAT_RES    12
#define MODID_IFFILE        13
#define MODID_TEXTRENDERER  14
#define MODID_DIGCOVPAGE    15
#define MODID_AWBRANDER     16
#define MODID_MSGSVR        17
#define MODID_MSGHNDLR      18
#define MODID_MODEMDRV     19
#define MODID_PSIFAX       20
#define MODID_AWT30            21
#define MODID_PSIFAXBG     22
#define MODID_AWNSF            23
#define MODID_FAXCODEC      24
#define MODID_MSGPUMP       25
#define MODID_AWREPORT      26
#define MODID_MSGSVRD           27

#define MAXMODID              26

#define MODID_NONE          159

// Special module ID's
#define MODID_CUSTOM        160

// Strings used in debug version for friendly display
#define SYSMODULESTRINGS   \
    { "Win32", "Boss", "Windows", "IFKernel", "FileSystem", "Msg Store", "Linearizer",    \
      "Security", "HLPrintDriver", "HLScanDriver", "IPX/SPX", "RendServer", \
      "Format Res", "IFFile", "AsciiRenderer","DigCovPage","AWBrander", \
      "Msg Server", "Msg Handler", "Modem Driver", "PSIFAX", "AWT30",  \
     "PSIFAXBG", "AWNSF", "Fax Codec", "Msg Pump" , "Awreport" \
    }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_PROCESSES  | Identifiers for all the standard system processes.

    @emem   PROCID_WIN32        | Used to initialize for Win32 modules.
    @emem   PROCID_NONE         | Used when process context does not need to be set.
    @emem   PROCID_MSGSCHED     | ID = 0x21
    @emem   PROCID_JOBPROCESS   | ID = 0x22
    @emem   PROCID_UI           | ID = 0x23
    @emem   PROCID_PRINTER      | ID = 0x24
    @emem   PROCID_SCANNER      | ID = 0x25
    @emem   PROCID_MSGSVR       | ID = 0x26
    @emem   PROCID_GRRENDER     | ID = 0x27
    @emem   PROCID_MSGHNDLR     | ID = 0x28
    @emem   PROCID_PARADEV              | ID = 0x29
    @emem   PROCID_UIBGPROC     | ID = 0x30

    @comm   All Process ID's need to have the 6th bit set to be compatible with the
            standard Win32 error definitions.

    @xref   <f IFErrAssemble> <f IFErrGetProcess>
********/
// System Process IDs
#define PROCID_WIN32           0x00
#define PROCID_NONE            0x20
#define PROCID_MSGSCHED        0x21
#define PROCID_JOBPROCESS      0x22
#define PROCID_UI              0x23
#define PROCID_PRINTER         0x24
#define PROCID_SCANNER         0x25
#define PROCID_MSGSVR          0x26
#define PROCID_GRRENDER        0x27
#define PROCID_MSGHNDLR        0x28
#define PROCID_PARADEV         0x29
#define PROCID_UIBGPROC            0x30

// Strings used in debug version for friendly display
#define MAXPROCID  11
#define SYSPROCESSSTRINGS       \
    {"None", "Msg Scheduler", "Job Process", "UI Process", "Printer", "Scanner", \
     "Msg Transport", "GR Renderer", "Msg Handler", "Para Dev", "UIBGProc"  }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

   @type   VOID | SYSTEM_ERROR_VALUES | This defines all the standard
           system error values.

   @emem   ERR_NOT_ENOUGH_MEM | Value = 0x0001 : Indicates an out of memory
           condition.

   @emem   ERR_INVALID_PARAM | Value = 0x0002 : Indicates that any one of
           the parameters passed to the function was invalid.

   @emem   ERR_FUNCTION_START | Value = 0x0010 : Any error value above this
           had been custom defined by the called function. If you need
           a custom error value, you can define it starting from this
           value.

   @xref   <f IFErrAssemble>
********/

// System Error values
#define ERR_NOT_ENOUGH_MEM  0x0001
#define ERR_INVALID_PARAM   0x0002
#define ERR_FUNCTION_START  0x0010

// Strings used in debug version for friendly display
#define SYSERRORSTRINGS \
    {"None", "Out Of Memory", "Invalid Param", "Unused", "Unused", "Unused",  \
    "Unused", "Unused", "Unused", "Unused", "Unused", "Unused", \
    "Unused", "Unused", "Unused", "Unused" }

// Functions

#if !defined(SHIP_BUILD) && !defined(WIN32)
VOID WINAPI RestoreLastError (DWORD dwErrVal);
#else
#define RestoreLastError(dw) SetLastError(dw)
#endif

#ifndef WIN32
VOID WINAPI SetLastError (DWORD dwErrVal);
DWORD WINAPI GetLastError (VOID);
#endif


//----------------------------- MESSAGING -------------------------

// Message type definitions  - below 0x0400 is reserved by windows,
// between 0x0400 and 0x0800 is reserved by the IFAX OS

#define IF_START        WM_USER+0x0300

#define IF_TASK_START   IF_START+0x0001
#define IF_TASK_END     IF_START+0x0020
#define IF_DEBUG_START  IF_START+0x0021
#define IF_DEBUG_END    IF_START+0x0040
#define IF_PIPES_START  IF_START+0x0041
#define IF_PIPES_END    IF_START+0x0060
#define IF_TIMER_START  IF_START+0x0081
#define IF_TIMER_END    IF_START+0x0090
#define IF_USER         IF_START+0x0400
//messages for printer and scanner
#define IF_SCANNER_START IF_START+0x0200
#define IF_SCANNER_END   IF_START+0x0220
//messages for the graphics renderer
#define    IF_GRRENDER_START   IF_START+0x0221
#define    IF_GRRENDER_END     IF_START+0x0230
//messages for the faxcodec renderer
#define    IF_FAXREND_START    IF_START+0x0231
#define    IF_FAXREND_END      IF_START+0x0235
//messages for the message pump
#define IF_MSGPUMP_START (IF_START+0x0250)
#define IF_MSGPUMP_END   (IF_START+0x029F)
//messages for devices
#define IF_DEVICE_START (IF_START+0x02B0)
#define IF_DEVICE_END   (IF_START+0x02CF)
// Message for UI Init
#define IF_UI_START        (IF_START+0x2F0)
#define IF_UI_END      (IF_START+0x300)
// Status
#define IF_STATUS_START    (IF_START+0x301)
#define IF_STATUS_END   (IF_START+0x310)
// Config
#define IF_CONFIG_START    (IF_START+0x311)
#define IF_CONFIG_END   (IF_START+0x320)
// Modem
#define IF_MODEM_START (IF_START+0x321)
#define IF_MODEM_END   (IF_START+0x325)
// PSIBG
#define IF_PSIBG_START (IF_START+0x330)
#define IF_PSIBG_END   (IF_START+0x339)
// PSIFAX
#define IF_PSIFAX_START    (IF_START+0x340)
#define IF_PSIFAX_END      (IF_START+0x349)
// MSGSVR
#define IF_MSGSVR_START  (IF_START+0x350)
#define IF_MSGSVR_END    (IF_START+0x369)
// OEM
#define IF_OEM_START    (IF_START+0x370)
#define IF_OEM_END      (IF_START+0x379)
// SOS
#define IF_SOS_START    (IF_START+0x380)
#define IF_SOS_END      (IF_START+0x38F)
// uiutil
#define IF_UU_START     (IF_START+0x390)
#define IF_UU_END       (IF_START+0x39F)
// parallel device
#define IF_PD_START     (IF_START+0x3A0)
#define IF_PD_END       (IF_START+0x3BF)
// RPC layer
#define IF_RPC_START     (IF_START+0x3C0)
#define IF_RPC_END       (IF_START+0x3CF)
//UIBGProc
#define IF_UIBGPROC_START (IF_START+0x3D0)
#define IF_UIBGPROC_END   (IF_START+0x3DF)
// services
#define IF_SERVICE_START  (IF_START+0x3E0)
#define IF_SERVICE_END    (IF_START+0x3EF)


/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_INIT_STATUS |   This message should be posted by all devices
           after initialization is complete to indicate success/failure.
           Typically, the device process will send an IF_INIT_STATUS
          message for every device it initializes and one for its own
          initilization. This message should be posted to the UISHELL
          process. Use <f IFProcGetInfo> to obtain the appropriate window handle.

   @parm   WPARAM  | wParam    | 16 bit device error.
   @parm   LPARAM  | lParam    | Is formed as MAKELPARAM(MAKEWORD
       (ucInitStatus,ucMinorDevId),MAKEWORD(ucMajorDevId,ucProcId))
   @flag   INIT_NO_ERROR   |   There was no error.
   @flag   INIT_FATAL_ERROR|   There was a fatal error. System should reboot.
   @flag   INIT_WARNING_ERROR  | There were some errors, but the system doesnt need
           to reboot.

   @parm   LPARAM  | lParam    | Contains a standard IFAX Error code. See
           <f IFErrAssemble> for details.

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/
#define INIT_NO_ERROR      0x00
#define INIT_FATAL_ERROR   0x01
#define INIT_WARNING_ERROR 0x02

#define IF_INIT_STATUS     IF_UI_START
/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS
   @msg    IF_DEVREINIT |   This message will be posted by the uishell to
           device process that handle user errors if the initialization
           fails due to user errors.

   @parm   WPARAM  | wParam    | MAKEWORD(ucMinorDevId,ucMajorDevId)

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/

#define    IF_DEVREINIT    IF_UI_START+1

// Functions --------
BOOL WINAPI BroadcastMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI BroadcastMessageEx (UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dispatch message for BG Procs
/********
   @doc    EXTERNAL    MESSAGE     MACROS  IFAXOS

   @api    VOID    |   DispatchMessage | Dispatches a message to your
           windows procedure.

   @parm   LPMSG   | lpMsg |   Ptr to a message struct which is to be
           dispatched. This parameter *must* be &msg for all IFAX
           background processes - i.e you must have a declared variable
           called "msg" into which you have previsouly retrieved the
           message using <f GetMessage>.

   @comm   This function dispatches a message to your windows procedure.
           For foreground processes this works exactly the way the standard
           Windows DispatchMessage works. For background processes
           (which dont have any explicit windows) the message is sent to
           a procedure called BGWindowProc. You *must* have a callback
           defined as this - see BGWindowProc for details.

   @cb     LRESULT  BGCALLBACK |   BGWindowProc    | This is the window procedure
           for all IFAX background processes. The functions *must* be called
           by this exact name. This callback is not relevant for foreground
           processes.

   @parm   HWND    | hwnd  | contains the handle of the window to which the
           message is being dispatched. For Background processes this will always
           be the same as that returned from <f IFProcGetInfo>.

   @parm   UINT    | message | the message id

   @parm   WPARAM  | wParam | the first parameter associated with the message

   @parm   LPARAM  | lParam    | The second parameter associated with the message

   @rdesc  The return value depends on the message being processed.

   @comm   A protoype for this is already declared in ifaxos.h. You should
           process all your messages inside this window procedure. Your
           main application loop should thus look like

           while (GetMessage(&msg,NULL,0,0))
           {
               DispatchMessage(&msg);
           }
           return;

           You should *not* export this procedure in your .def file.

   @xref   <f GetMessage>
********/

#ifdef IFBGPROC
#define DispatchMessage(pmsg)   BGWindowProc((pmsg)->hwnd,(pmsg)->message,(pmsg)->wParam,(pmsg)->lParam)
#define BGCALLBACK PASCAL
LRESULT BGCALLBACK BGWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

//----------------------------- TASK MANAGEMENT--------------------
/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   ENTER_INT_CRIT_SECTION  | Macro to enter
           an interrupt critical section.

   @comm   This is an inline assembly macro which turns interrupts
           off. Needless to say, this must be used with extreme
           caution. There must be a matching call to
           <f EXIT_INT_CRIT_SECTION>. Nested pairs of calls
           to these are permitted as long as they are not within the
          same invocation of the function. The function relies on
          being able to save the previous state of the flags in a
          unique local variable called __wIntFlags.
           This might affect some optimization options in your
           function due to being inline assembly. You might want to
           declare a local function which calls this macro internally.
           This way you can get global optimzations in the calling
           functions.

   @xref   <f EXIT_INT_CRIT_SECTION>  <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/


// Macros --------
#define ENTER_INT_CRIT_SECTION  \
   {   \
   _asm pushf  \
   _asm cli    \
   _asm pop __wIntFlags    \
   }

/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   EXIT_INT_CRIT_SECTION   | Macro to exit
           an interrupt critical section.

   @comm   This is an inline assembly macro which sets the interrupt
           flag state back to its state before the last call to
           <f ENTER_INT_CRIT_SECTION>. This function relies    on the
          appropriate flags to have been saved in a local variable
          with the name __wIntFlags.

   @xref   <f ENTER_INT_CRIT_SECTION> <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/

// defined this way so that it works with windows enhanced mode
// refer guide to programming pg 14-15
#define EXIT_INT_CRIT_SECTION   \
   {   \
   _asm mov ax, __wIntFlags    \
   _asm test ah,2      \
   _asm jz $+3     \
   _asm sti            \
   _asm NOP            \
   }

/********
    @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | PRIORITY DEFINES  | System defined priority levels
    @emem   PROC_PRIORITY_CRITICALRT | This should be used very sparingly
            for tasks which have very critical real time constraints (less
            than 200ms). These processes should typically be very low bandwidth
            since they can easily starve other processes.
    @emem   PROC_PRIORITY_HIGHRT | Tasks with latency requirements of less than
            a second. Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_MEDRT | Tasks with latency requirements of 1-3 secs.
            Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_LOWRT | Tasks with latencies of 3-30secs. Should not
            be high bandwidth.
    @emem   PROC_PRIORITY_DEFAULT | The default priority tasks start out at. These
            processes have none or very low real time requirements. They should
            in general not have high bandwidth.
    @emem   PROC_PRIORITY_NONRT_USERVISIBLE | Non real time tasks which have visibility
            at the user level. Can be high bandwidth. An example on a fax machine is
            a copy job.
    @emem   PROC_PRIORITY_NONRT_USERHIDDEN | Non real time tasks which have very little
            visibility at the user level. Examples on a fax machine are local jobs
            not involving devices. Can be high bandwidth.
    @comm   Processes should be VERY careful in setting their priorities. The way the
            current scheduling works it is very easy to cause starvation of low
            priority processes. In particular, processes which are "high bandwidth" - ie
            those which can consume huge amounts of CPU time if given, should be very
            careful - and should in general be at a priority level lower than the default.
            Processes higher than the default should have some sontrols on how much cpu
            time they can use up. On the fax machine, such controls are mostly in the form
            of device througputs - like the phone line.
    @xref   <f IFProcSetPriority> <f IFProcGetPriority>
********/
#define PROC_PRIORITY_MIN               31
#define PROC_PRIORITY_MAX               1
#define PROC_PRIORITY_CRITICALRT        3
#define PROC_PRIORITY_HIGHRT            6
#define PROC_PRIORITY_MEDRT             9
#define PROC_PRIORITY_LOWRT             12
#define PROC_PRIORITY_DEFAULT           15
#define PROC_PRIORITY_NONRT_USERVISIBLE   18
#define PROC_PRIORITY_NONRT_USERHIDDEN    21

#define UAE_BOX                 0
#define NO_UAE_BOX              1

///// Specific priorities used by standard processes       ////
//
// We want the following relations to hold
//      PSIFAXBG > everything else, cause it's low-latency, low-bandwidth
//      ModemJob related (med bandwidth) > all other high/med bandwith jobs
//  DeviceJob related (high bandwidth, NO latency reqs) < all other jobs except Spool jobs
//  SpoolJobs (high bandwidth NO latency reqs, not user-visible) < everything
//  MSCHED is as high as ModemJob prio when it is on critical path, otherwise
//              it stays at default. Higher than Dev & Spool jobs, lower than all else
//  COMMSRV (pretty low latency reqs, high bandwidth) is slightly higher than
//              default (Higher than MSCHED & Dev/Spool jobs, lower than modem jobs)
//  RPCHNDLR (pretty lax latency reqs, high bandwidth) dynamic
//              Same prio as MSCHED while working, same as COMMSRV during accept
//  MSGSVR & RPCSRV (lowish latency reqs, very low bandwidth) roundrobin
//              with ModemJob, higher than all else
//  REPORT bg proc slightly lower than default.

// PSIFAXBG prio is highest
#define PRIO_PSIFAXBG_ACTIVE    PROC_PRIORITY_CRITICALRT
#define PRIO_PSIFAXBG_IDLE      PROC_PRIORITY_DEFAULT
// ModemJob is 2nd highest
#define PRIO_MODEMJOB           PROC_PRIORITY_MEDRT
// Spooljob is LOWEST, Device jobs are second lowest
#define PRIO_SPOOLJOB           PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_DEVICEJOB          PROC_PRIORITY_NONRT_USERVISIBLE
// PSINET jobs are same prio as SPOOL jobs
#define PRIO_PSINETJOB          PRIO_SPOOLJOB
// MSCHED's prio when it is NOT on a MODEMJOB critical path
#define PRIO_MSCHED             PROC_PRIORITY_DEFAULT
// COMMSRV is between MODEMJOB & MSCHED
#define PRIO_COMMSRV            PROC_PRIORITY_LOWRT
// RPCHNDLR is same as MSCHED while working
#define PRIO_RPCHNDLR_ACCEPT    PROC_PRIORITY_LOWRT
#define PRIO_RPCHNDLR_WORKING   PROC_PRIORITY_DEFAULT
// RPCSRV is same as MODEMJOB. It should NOT consume much CPU at this level!
#define PRIO_RPCSRV             PROC_PRIORITY_MEDRT
// MSGSVR is same as MODEMJOB, except when processing recovery msgs
#define PRIO_MSGSVR_WAITMSG     PROC_PRIORITY_MEDRT
#define PRIO_MSGSVR_RECOVERY    PROC_PRIORITY_NONRT_USERVISIBLE
// Report process is real low prio when doing background info assimilation
// slightly higher when doing work on user request.
#define PRIO_UIBGPROC                   PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_UIBGPROC_USERREQUEST PROC_PRIORITY_NONRT_USERVISIBLE

/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_QUIT |   This is the message which forces <f GetMessage>
           to return FALSE causing the process to exit its main message
           processing loop and terminate. Typically a process should
           post itself this message in response to a <m IF_EXIT> message.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_EXIT>

   @msg    IF_EXIT | This message is sent to a process to request it
           to terminate. An application should clean up any resources
           it has allocated and then post itself a <m IF_QUIT> message
           directly.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_QUIT>
********/

// Messages
#define IF_QUIT     IF_TASK_START
#define IF_EXIT     IF_TASK_START+1

// Functions -----------
#ifndef WIN32
HTASK   WINAPI GetWindowTask(HWND hwnd);
#ifndef SHIP_BUILD
DWORD   WINAPI IFProcProfile(HTASK hTask, BOOL fStart);
#else
#define IFProcProfile(HTASK,FSTART) (0)
#endif
#else
// Remove calls to Profile ..
#define IFProcProfile(x,y)    (DWORD)(0)
#endif

HTASK WINAPI IFProcCreate (LPSTR lpszAppName, UINT fuCmdShow);
VOID WINAPI IFProcTerminate (HTASK hTask, WORD wFlags);
VOID WINAPI IFProcEnterCritSec(VOID);
VOID WINAPI IFProcExitCritSec(VOID);
BOOL WINAPI IFProcChangeToFG(VOID);
BOOL WINAPI IFProcChangeToBG(VOID);
HWND    WINAPI IFProcGetInfo (HTASK FAR *lphTask, LPSTR lpszModule, HINSTANCE FAR *lphInst);
BOOL    WINAPI IFProcRegisterWindow (HWND hwnd);
WORD    WINAPI IFProcGetPriority (HTASK hTask);
BOOL    WINAPI IFProcSetPriority (HTASK hTask, WORD wPriority);

#ifndef NOBUFFERS
//----------------------------- BUFFERS -------------------------

// Moved BUFFER typedef and standard meta-data values to buffers.h! -RajeevD
#include <buffers.h>

#ifdef VALIDATE
#define BUF_SENTINELPOS 30
#endif

// Error values
#define ERR_DATA_SMALL      ERR_FUNCTION_START

// Functions
extern BOOL      IFBufFree (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufMakeWritable (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufShare (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufSplit (LPBUFFER lpbf, LPBYTE lpb);


//----------------------------- PIPES ----------------------------

#ifndef WIN32

// types
typedef  struct _PIPE NEAR *HPIPE;

// Parameter
#define IFPIPE_READ_MODE    0x0001
#define IFPIPE_WRITE_MODE   0x0002
#define REQREAD_REMOVE_DATA 0x0003
#define REQREAD_NOREMOVE_DATA   0x0004

// Error values
#define ERR_TOO_MANY_OPENS          ERR_FUNCTION_START
#define ERR_TOO_MANY_PENDING_WRITES ERR_FUNCTION_START+1
#define ERR_PIPE_STILL_OPEN         ERR_FUNCTION_START+2

/********
   @doc    EXTERNAL    MESSAGES    IFPIPES IFAXOS

   @msg    IF_PIPE_DATA_WRITTEN | This message is sent to notify a process
           that a previous write request using <f IFPipeReqWrite> has
           been successfully concluded. On reciept of this message the
           process can issue another write request on the same pipe.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <f IFPipeReqWrite>

   @msg    IF_PIPE_DATA_ARRIVED | This message is sent to a process which
           previsouly issued a read request to a pipe, intimating it that
           the buffer it requested is now available.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | Contains a far ptr to a <t BUFFER> structure
           which has the requested data. On receipt of this message the process
           can issue another read request on the same pipe.

   @rdesc  none

   @xref   <f IFPipeReqRead>
********/

// Messages
#define IF_PIPE_DATA_WRITTEN    IF_PIPES_START
#define IF_PIPE_DATA_ARRIVED    IF_PIPES_START+1

// Functions
HPIPE WINAPI IFPipeCreate (WORD wSize);
BOOL WINAPI IFPipeDelete (HPIPE hpipe);
BOOL WINAPI IFPipeOpen (HPIPE hPipe, HWND hwnd, WORD wMode, WPARAM wContext);
BOOL WINAPI IFPipeClose (HPIPE hPipe, WORD wMode);
BOOL WINAPI IFPipeReqRead (HPIPE hPipe, WORD fwRemove);
BOOL WINAPI IFPipeReqWrite (HPIPE hPipe, LPBUFFER lpbf);
BOOL WINAPI IFPipeGetInfo (HPIPE hPipe, LPWORD lpwSize, LPWORD lpwcBufs);

#else // !WIN32

DECLARE_HANDLE32(HPIPE);

#endif // !WIN32

#endif // NOBUFFERS

//----------------------------- DEBUG SERVICES -------------------------

// Debug typedefs. These dont do any harm to anyone. Define them if there is
// anyone who might need them.

#if defined(DEBUG) || defined(IFKINTERNAL)

/********
   @doc    EXTERNAL    DATATYPES   DEBUG   IFAXOS

   @types  DBGPARAM    |   Structure containing the debug
           settings for any module in the system.

   @field  CHAR[32]    |   lpszName    | Specifies the name of the module.
           This is how your module will appear in the IFAX controller. Must
           be less than 32 characters long, and NULL terminated.

   @field  HWND    |   hwnd    | Specifies the primary window handle associated with
           this module IF the module is a process. For DLL's this value should
           always be NULL. Background processes should set it to their own ID using
           <f IFProcGetInfo> and <f GetCurrentTask> at initialization time.
           Foreground processes should set it to the window handle of their client
           window.

   @field  CHAR[16][32]    | rglpszZones   |   Stores a list of 16 strings
           which describe the zones associated with the lower 16 bits of
           zone mask. The module must decide and define its own zones for these
           bits - any bits not used should be left as "Not Used". These strings
           will be displayed by the IFAX controller to assist users in choosing
           the zones to be set for your module. Each string should not be more
           than 32 characters long, and should be NULL terminated.

   @field  ULONG   |   ulZoneMask  |   This is the mask which stores the
           current zone settings for the module. The IFAX controller will
           set this field according to what the user specifies. This field
           should be initialized to something which makes sense for your module
           - as that will be the default till the user changes it.

   @comm   This structure should be passed to <f IFDbgSetParams> at
           intialization time to enable the user to control the trace options.

           **VERY IMPORTANT NOTE** This structure MUST be declared with a
           variable  name of dpCurSettings to allow the system zones to
           function correctly.

   @tagname _DBGPARAM

   @xref   <f IFDbgSetParams>

********/

typedef struct _DBGPARAM {
   CHAR    lpszName[32];           // name of module
   HWND    hwnd;                   // Primary window Handle if task, NULL otherwise
   CHAR    rglpszZones[16][32];    // names of zones for first 16 bits
   ULONG   ulZoneMask;             // Zone Mask
}   DBGPARAM, FAR *LPDBGPARAM;

// Debug functions
BOOL WINAPI IFDbgOut (LPSTR lpszStatus);
WORD WINAPI IFDbgIn (LPSTR lpszPrompt, LPSTR lpszReply, WORD wBufSize);
extern EXPORT_DLL VOID WINAPI IFDbgSetParams (LPDBGPARAM lpdpParam, BOOL fEntry);
extern VOID FAR  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

// Encourage people to use the correct variable
extern DBGPARAM dpCurSettings;


// Special UI communication stuff

// Functions
DWORD WINAPI DebugUIMessage (UINT wMsg, WPARAM wParam, DWORD lParam);

// Messages to the UI proc
#define IF_DISP_STRING  IF_DEBUG_START
#define IF_INP_REQUEST  IF_DEBUG_START+1
#define IF_NEW_SETTING  IF_DEBUG_START+2
#define IF_DEL_SETTING  IF_DEBUG_START+3
#define IF_NEW_TASK     IF_DEBUG_START+4
#define IF_DEL_TASK     IF_DEBUG_START+5
#define IF_FILELOG_POLL IF_DEBUG_START+6

// Messages from the UI proc
#define REGISTER_UI_TASK    1
#define SET_LOG_MODE       2
#define DEBUG_OUT_DONE      3
#define DEBUG_IN_DONE       4
#define DEREGISTER_UI_TASK  5


#endif

// Debug Macros. These should be defined only if the module is being compiled
// in debug

#ifdef DEBUG

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGMSG    |   Prints a trace message on the debug
           console depending on enable flags set by the user.

   @parm   <lt>c_expression<gt>    |   cond    |   Boolean condition which is
           evaluated to decide whether or not to print the message.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @rdesc  TRUE if the message is printed, and FALSE if it is not.

   @comm   The condition should consist of a boolean expression testing whether
           the relevant zones are on or off.  Each module has a current zone
           mask which identifies which of the possible 32 zones is currently on.
           The top 16 bits of these are reserved for use for system defined
           zones - like ZONE_FUNC_ENTRY which is defined as

           #define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)

            Modules should take care to see
           that they print out trace messages which are meaningful and conform
           to some pattern - remember that other people than you have to see
           and make sense of your messages. The general format I have been
           following is :

           <lt>Task ID<gt> :
           <lt>ModuleName<gt>:<lt>SubModule<gt>:<lt>Function<gt>:<lt>msg<gt>

           The task ID is useful to sort out the output of multiple tasks
           running in the system.  The example call above yields this kind of
           output.

           The various predefined system zones are:
               ZONE_FUNC_ENTRY : To be used for all function entry and exit
                   messages. By convention, the parameters should be printed
                   on entry, and the return value should be printed on exit.
                   Any values printed in hexadecimal should be preceded by a 0x
               ZONE_INT_FUNC : To be used for any other traces at interesting
                   points within a function.

           All trace messages are disabled in a non debug build.

   @ex     Example Definition & Use |

           #define ZONE_CUSTOM (0x00000001&dpCurSettings.ulZoneMask)

           DEBUGMSG (ZONE_FUNC_ENTRY && ZONE_CUSTOM,
                       ("0x%04X:IFK:Buffers:GenericFunction:Entry\r\n",
                       GetCurrentTask()));

           This will print a trace message only if the user has turned the
           function entry zone and the custom zone on.

   @xref   <f IFDbgPrintf>
********/

#if 0
#define DEBUGMSG(cond,printf_exp)   \
   ((cond)?(IFDbgPrintf printf_exp),1:0)
#endif


#define DEBUGMSG(cond, printf_exp)   \
   (IFDbgPrintf printf_exp)



// Standard Debug zones
#define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)
#define ZONE_INT_FUNC   (0x00020000&dpCurSettings.ulZoneMask)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   ERRORMSG    |   Prints an error message on the debug
           console.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display Error messages.

   @ex     Example Definition & Use |

           ERRORMSG (("0x%04X:JOB Failed !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           ERROR: Job Process: 0x2346: JOB Failed !!

   @xref   <f IFDbgPrintf>
********/
#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define ERRORMSG(printf_exp)   \
   (IFDbgPrintf("ERROR:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   RETAILMSG    |   Prints a message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           RETAILMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf>
********/
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   WARNINGMSG    |   Prints a warning message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           WARNINGMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           WARNING: 0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf> <f ERRORMSG>
********/
#ifndef WIN32
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define WARNINGMSG(printf_exp)   \
   (IFDbgPrintf("WARNING:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif


/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGCHK    |   Macro implementing an assert.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be checked.

   @rdesc  Returns TRUE if the expression was non zero, and FALSE if not.

   @comm   This is a macro which implements functionality similar to the assert
           statement in C.  The expression argument is evaluated, and no action
           is taken if it evaluates to true. If false, a debug message is
           printed out  giving the  File name and line number where the check
           failed, along with the module name which was registered
           in the <t DBGPARAM> structure. Because of this, you *must* register
           your debug settings using <f IFDbgSetParams> before you can use the
           DEBUGCHK macro.  After this the function <f IFDbgCheck> is called
           to generate an assert.

           This statement disappears when the DEBUG option is turned off.

    @xref   <f IFDbgCheck>
********/

#define BG_CHK(exp)    \
   ((exp)?1:(              \
       IFDbgPrintf ("DEBUGCHK failed in file %s at line %d \r\n",  \
                 (LPSTR) __FILE__ , __LINE__ ), 1  \
            ))


/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGSTMT   |   Evaluates the expression in debug mode.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be evaluated.

   @rdesc  Returns the value returned by the expression.

   @comm   This macro is provided for convenience and code readability purposes
           to replace a construct of the form

               #ifdef DEBUG
               exp;
               #endif

           It evaluates to zero in a non debug build.

********/

#define DEBUGSTMT(exp) exp

#else // NOT DEBUG

// Let debugmsg's through currently
#ifndef SHIP_BUILD
//#ifndef FOOBAR

// Non DEBUG MODE
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)
#else  //Win32 -- NO MESSAGES OF ANY SORT IN NON-DEBUG WIN32

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif


#else

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif

// These are to macro out all debug stuff in retail/ship builds
#define DEBUGMSG(cond,expr)  (0)
#define DBGCHK(module,exp) (0)
#define DEBUGCHK(exp) (0)
#define BG_CHK(exp) (0)
#define DEBUGSTMT(exp) (0)

// Macros for direct function calls made ..
#ifndef IFKINTERNAL
#define IFDbgOut(lpszStatus) (0)
#define IFDbgIn(lpszPrompt,lpszReply,wBufSize) (0)
#define IFDbgSetParams(lpdpParam,fEntry) (0)
#define DebugUIMessage(wMsg,wParam,lParam) (0)
#endif

#endif

/********
   @doc    EXTERNAL    IFAXOS    MACROS

   @api    BOOL    |   UIEVENT |   Prints a status string in the UI

   @parm   LPSTR | string |  String to be printed.

   @comm   This macro is provided in both the retail & debug builds to
            allow some limited set of status strings to be printed in
            the UI. You must format a string yourself - you can
            use wsprintf() to create a complex one if desired. The
            maximum string length allowed is 64 bytes.
********/
#define IF_SYS_EVENT     IF_UI_START+1
// UI Event messages
#define UIEVENT(string)   \
{       \
    CHAR    szUIShell[] = "UISHELL";  \
    DEBUGCHK(lstrlen(string) < 64); \
    PostMessage (IFProcGetInfo(NULL, szUIShell, NULL), IF_SYS_EVENT,   \
                 NULL, MAKELPARAM(GlobalAddAtom(string),0));    \
}

// --------------- Synchronization services --------------------------------------
// Dont provide any for win32.
#ifndef WIN32

typedef  struct _SYNC NEAR *HSYNC;

// Error returns
#define ERR_MUTEX_NOT_FREE  ERR_FUNCTION_START
#define ERR_EVENT_NOT_FREE  ERR_FUNCTION_START+1
#define ERR_TOO_MANY_EVENTWAITS ERR_FUNCTION_START+2

// generic functions
DWORD WINAPI WaitForSingleObject (HSYNC hsc, DWORD dwTime);

// Mutex functions
HSYNC WINAPI CreateMutex (LPVOID lpvAttribs, BOOL fInitial,LPSTR lpszName);
BOOL WINAPI ReleaseMutex (HSYNC hsc);

// Event Functions
HSYNC   WINAPI  CreateEvent (LPVOID lpvAttribs, BOOL bManualReset,
                            BOOL bInitialState, LPSTR lpszName);

BOOL    WINAPI  SetEvent (HSYNC hsc);
BOOL    WINAPI  ResetEvent (HSYNC hsc);
BOOL WINAPI FreeSyncObject (HSYNC hsc);
BOOL WINAPI  GetSetEventParam (HSYNC hsc, BOOL fSetParam, LPDWORD lpdwParam);

#else // !WIN32

DECLARE_HANDLE32(HSYNC);

#endif // !WIN32

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULE_NAMES  | Strings to be passed to IFProcGetInfo to get handles to standard IFAX modules

    @emem   MODNAME_UISHELL  | UI Shell
    @emem   MODNAME_MSCHED   | Message Scheduler
    @emem   MODNAME_MSGSVR   | Message Server a.k.a. Message Transport

    @xref   <f IFProcGetInfo>
********/

// IFAX Module names
#define MODNAME_UISHELL        "UISHELL"
#define MODNAME_MSCHED     "MSCHED"
#define MODNAME_MSGSVR     "MSGSVR"


// --------------- Timer Services -----------------------------------------

#ifndef WIN32

/********
   @doc    EXTERNAL    IFAXOS    MESSAGES    TIMER

   @msg    IF_TIMER | This message is sent to notify a process
           of the expiration of a timer set using <f IFTimerSet>.

   @parm   WPARAM  | wParam    | Contains the timer id set int he
           <f IFTimerSet> call.

   @parm   LPARAM  | lParam    | Contains the lParam passed into
           the IFTimerSet call.

   @rdesc  none

   @xref   <f IFTimerSet>
********/

// messages
#define IF_TIMER    IF_TIMER_START

// flags
#define TIME_ONESHOT    0
#define TIME_PERIODIC   1

// functions
VOID WINAPI IFProcSleep (WORD wSleepPeriod);
WORD WINAPI IFTimerSet (HWND hwnd, WORD idTimer, WORD wTimeout,
                         TIMERPROC tmprc, WORD wFlags, LPARAM lContext);
BOOL WINAPI    IFTimerKill (HWND hwnd, UINT idTimer);

#endif

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

//
#define RAW_DATA_SIZE       -3      // 8Kb

// Special size for modem ECM frame
#define BYTE_265_SIZE       -4      // 265 bytes
#define BYTE_265_ACTUALSIZE 265

// Number of sizes
#define MAX_POOL_INDEX  -4          // For parameter validation

// Not available yet!
#define BAND_BUFFER_SIZE    30720      // 64Kb

// Flag to force global alloc. Uses a windows flag which is ignored/defunct in
// the 3.1 kernel (and the boss kernel)
#define IFMEM_USEGLOBALALLOC GMEM_NOT_BANKED

// Functions
extern LPVOID IFMemAlloc (UINT fuAlloc, LONG lAllocSize,
                                  LPWORD lpwActualSize);
extern BOOL   IFMemFree (LPVOID lpvMem);


/********
    @doc    EXTERNAL   IFAXOS

    @api    HIPCMEM | IFMemGetIPCHandle | Returns an opaque 32 bit handle
            which is portable across process contexts.

    @parm   LPVOID  | lpvMem    | A ptr to global memory allocated using
            <f IFMemAlloc>.

    @rdesc  Opaque 32 bit none zero handle if succesfull. 0 if the memory
            ptr passed in is invalid.

    @comm   This function should be used by any DLL or process before trying
            to pass this memory to another process context. Only handles
            returned by this API should cross context boundaries, and the
            receiving context should call <f IFMemMapIPCHandle> to get back
            a valid memory ptr in its new context.

            This applies even for DLL's which might allocate a piece of
            global memory and access it in different process contexts. They
            should use these functions to map them so that they are portable.

            For Win16/IFAX implementations, this is essentially a NOP.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>

    @type   DWORD | HIPCMEM | Opaque 32 bit handle to global memory block.

    @xref   <f IFMemMapIPCHandle> <f IFMemGetIPCHandle>
*********/
typedef DWORD HIPCMEM;
#define IFMemGetIPCHandle(par1) ((HIPCMEM)par1)

/********
    @doc    EXTERNAL   IFAXOS

    @api    DWORD | IFMemMapIPCHandle | Maps a piece of memory into the
            current tasks address space.

    @parm   HIPCMEM | hMemHandle    | A memory handle returned from a call
            to <f IFMemGetIPCHandle> previously.

    @rdesc  Valid ptr to memory in the context of the calling process if
            succesful. NULL if it fails.

    @comm   See comments in <f IFMemMapIPCHandle>.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>
*********/
#define IFMemMapIPCHandle(par1) ((LPVOID)par1)


// --------------- Time API's ----------------------------------------------

/********
    @doc    EXTERNAL IFAXOS SRVRDLL

    @types  SYSTEMTIME  | Structure describing the time in terms of roman
            calendar.

    @field  WORD    | wYear | The year
    @field  WORD    | wMonth | The month from 1-12
    @field  WORD    | wDayOfWeek | Day of week with Sunday = 0
    @field  WORD    | wDay | The day of the month, from 1-31
    @field  WORD    | wHour | The hour from 0-23
    @field  WORD    | wMinute | Minutes from 0-59
    @field  WORD    | wSecond | Seconds from 0-50
    @field  WORD    | wMilliseconds | Milliseconds from 0-99

    @comm   This is the format used for dislaying time to the user etc.

    @xref   <f SystemTimeToFileTime> <t FILETIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32

typedef struct _SYSTEMTIME {
   WORD wYear;
   WORD wMonth;
   WORD wDayOfWeek;
   WORD wDay;
   WORD wHour;
   WORD wMinute;
   WORD wSecond;
   WORD wMilliseconds;
} SYSTEMTIME, FAR *LPSYSTEMTIME;

#endif

/********
    @doc    EXTERNAL  IFAXOS

    @types  FILETIME    | Structure used to store time internally and for
            mathematical operations.

    @field  DWORD   | dwLowDateTime | Low 32 bits of the time.

    @field  DWORD   | dwHighDateTime | High 32 bits of the time.

    @comm   Absolute time in IFAX is represented by a 64-bit large integer accurate
            to 100ns resolution.  The smallest time resolution used by this package
            is One millisecond.  The basis for this time is the start of 1601 which
            was chosen because it is the start of a new quadricentury.  Some facts
            to note are:

            o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

            o At 100ns resolution a large integer (i.e., 63 bits) is good for
            about 29,247 years, or around 10,682,247 days.

            o At 1 second resolution 31 bits is good for about 68 years

            o At 1 second resolution 32 bits is good for about 136 years

            o 100ns Time (ignoring time less than a millisecond) can be expressed
            as two values, Days and Milliseconds.  Where Days is the number of
            whole days and Milliseconds is the number of milliseconds for the
            partial day.  Both of these values are ULONG.

    @xref   <f SystemTimeToFileTime> <t SYSTEMTIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32
// If sos property.h has been included this will cause a redefinition
#ifndef PROPERTY_H

#ifndef _FILETIME_
#define _FILETIME_

typedef struct _FILETIME {
   DWORD dwLowDateTime;
   DWORD dwHighDateTime;
} FILETIME, FAR *LPFILETIME;

#endif // _FILETIME_

#endif // Property_H

BOOL WINAPI FileTimeToSystemTime(LPFILETIME lpTime,LPSYSTEMTIME lpTimeFields);

BOOL WINAPI SystemTimeToFileTime(LPSYSTEMTIME lpTimeFields,LPFILETIME lpTime);

BOOL WINAPI FileTimeToLocalFileTime(LPFILETIME lpft, LPFILETIME lpftLocal);

BOOL WINAPI LocalFileTimeToFileTime(LPFILETIME lpftLocal, LPFILETIME lpft);

BOOL WINAPI SetLocalTime(LPSYSTEMTIME lpstLocal);

VOID WINAPI GetLocalTime(LPSYSTEMTIME lpstLocal);
#endif // Win32

// --------------- NVRAM  API's ----------------------------------------------

typedef struct ERRORLOGPOINTER {
    WORD wNextEntryPtr ;
    WORD wNumEntries ;
} ERRORLOGPOINTER , FAR * LPERRORLOGPOINTER ;

#define MAX_ERRORLOG_ENTRIES       30
#define MAX_OEMERRBUF_SIZE         16

/********
    @doc    EXTERNAL  IFAXOS

    @types  ERRORLOGENTRY    | Used to store Log Entries.

    @field  DWORD   | dwErrorCode | This is the IFAX error code
           corresponding to the error being retrieved. See <f IFErrAssemble>
           for details of the format of this dword.

    @field  DWORD   | dwTimeStamp | The time at which this error was
           logged into NVRam. The various fields are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from COUNTER_YEAR_OFFSET (add COUNTER_YEAR_OFFSET to get actual year)

    @field CHAR    | oemErrBuf  | The buffer in which the application
           specific custom data/extended error corresponding to this
           error is retrieved.

    @comm   Used as a parameter to IFNvramGetError. This will typically be
           used for diagnostic functions.

    @xref   <f IFNvramGetError>
********/

#define COUNTER_YEAR_OFFSET  (1970)

typedef struct tagERRORLOGENTRY {
   DWORD dwErrorCode;
   DWORD dwTimeStamp;
   char oemErrBuf[MAX_OEMERRBUF_SIZE];
} ERRORLOGENTRY, FAR *LPERRORLOGENTRY;

typedef DWORD ERRORLOGSENTINEL , FAR * LPERRORLOGSENTINEL ;

// Set to the current version number (12.19)
#define SENTINEL_SET              0x00000C13UL

#define MAX_COUNTERS 30
#define OEM_NVRAM_COUNTER_START 12

// Special system counter which indicates the # of times the machine has rebooted
// It is a 4 byte counter with a timestamp
// If this value is 1 then this is the first time the machine has ever been rebooted.
// - This value cannot be set by any user application!

#define BOOT_COUNTER           0

// specific counter numbers assigned for various logical counters

#define TXCALL_COUNTER         1
#define RXCALL_COUNTER         2

// ****************************************************************************
//
// An HHSOS owned counter.
// This is the number of bad boots we have suffered (meaning the HHSOS could not
// successfully init).  When this number gets too big, we stop trying to init.
// This will cause AWCHKSOS to alert the user of the problem.
//

#define BAD_BOOTS_COUNTER      3

//
// ****************************************************************************


// These values for wFlags (in IFSetCounterValue) - some are mutually exclusive

// If CLEARSET is set the value is cleared before being added - otherwise it is just added
// Currently you cannot request a double long and a timestamp

// For now the interrupt has no context but in the future it might be useful

#define COUNTER_CLEARSET          0x0001
#define COUNTER_DOUBLE_LONG       0x0002
#define COUNTER_UPDATE_TIMESTAMP  0x0004
#define COUNTER_INTERRUPT_CONTEXT 0x1000

// Only here temporarily until everything gets moved to new values

#define COUNTER_VALUESET     (COUNTER_CLEARSET | COUNTER_UPDATE_TIMESTAMP)
#define COUNTER_ADDVALUE     0x0100
#define COUNTER_TIMESTAMP    0x0200
#define COUNTER_NOTIMESTAMP  COUNTER_DOUBLE_LONG
#define PROCESS_CONTEXT      0x0300
#define INTERRUPT_CONTEXT    COUNTER_INTERRUPT_CONTEXT

/********
    @doc    EXTERNAL  IFAXOS

    @types  COUNTERENTRY    | Used to store 4 and 8 byte Counters.

    @field  DWORD   | dwCounterVal1 | For a 4 byte counter, the value of the
           counter. For an 8 byte counter, the low order
           4 bytes of the value of the counter.

    @field  DWORD   | dwTimeStamp | For a 4 byte counter, the time at
           which the counter was last reset. The fields in the timestamp are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from 1980 (add 1980 to get actual year)

           For an 8 byte counter, dwTimeStamp is the high order 4 bytes of the
           counter value.

    @comm   Used by the IFNvramGetCounterValue function.

    @xref   <f IFNvramGetCounterValue>
********/
typedef struct tagCOUNTERENTRY {
   DWORD dwCounterVal1;
   DWORD dwTimeStamp;
} COUNTERENTRY, FAR *LPCOUNTERENTRY;

//-------------------------- Prototypes ----------------------------------

#if defined(WFW) || defined(WIN32)

#define IFNvramSetError(dw,lpb,w)              (0)
#define IFNvramSetErrorInterrupt(dw,lpb,w)         (0)
#define IFNvramGetError(lperrlog,lpwMaxEntries) (0)
#define IFNvramSetCounterValue(p1,p2,p3,p4)    (0)
#define IFNvramGetCounterValue(w1,lpentry)         (0)
#define IFNvramAllocScratchBuf(wSize)          (NULL)

#else

BOOL WINAPI     IFNvramSetError(DWORD, LPBYTE, WORD);
BOOL WINAPI     IFNvramSetErrorInterrupt(DWORD, LPBYTE, WORD);
BOOL FAR CDECL  IFNvramvSetError(DWORD dwError,WORD nErrs,...) ;
BOOL WINAPI     IFNvramGetError(LPERRORLOGENTRY lperrlog,LPWORD lpwMaxEntries) ;
BOOL WINAPI     IFNvramSetCounterValue(WORD, DWORD, DWORD, WORD);
BOOL WINAPI     IFNvramGetCounterValue(WORD, LPCOUNTERENTRY);
BOOL WINAPI     IFNvramFlushToFileLog(VOID) ;
BOOL WINAPI     IFNvramInitFileLog(VOID) ;
LPBYTE WINAPI   IFNvramAllocScratchBuf(WORD wSize);

#endif

/********
    @doc    EXTERNAL   IFAXOS

    @api    BOOL | _lflush | Flushes all pending writes to a file handle.

    @parm   HFILE  | hf    | A file handle obtained from _lopen or OpenFile

    @rdesc  Returns TRUE for success, FALSE for failure.

    @comm   This function will flush all pending writes to disk.

            For Win16 implementations, this currently always fails.
*********/

BOOL WINAPI _lflush(HFILE hf);


// the following is for service messages
#define IF_ST_END_SOSBK        (IF_SERVICE_START+0)
#define IF_ST_END_SOSRST       (IF_SERVICE_START+1)


#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // _INC_IFAXOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\nsfmacro.h ===
/***************************************************************************
 Name     :	NSFMACRO.H
 Comment  :	INTERNAL-ONLY Definitions of BC and NSF related structs

	Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#ifdef PORTABLE

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/

#define NSFvMsgProtocol(p)	(((((LPBYTE)(p))[1]) & 0x38) >> 3)
#define fBinaryData(p)		(((((LPBYTE)(p))[1]) & 0x40) >> 6)
#define fInwardRouting(p)	(((((LPBYTE)(p))[1]) & 0x80) >> 7)
#define vSecurity(p)		(((((LPBYTE)(p))[2]) & 0x07) >> 0)
#define vMsgCompress(p)		(((((LPBYTE)(p))[2]) & 0x18) >> 3)
#define fDontCache(p)		(((((LPBYTE)(p))[2]) & 0x20) >> 5)
#define OperatingSys(p)		(((((LPBYTE)(p))[3]) & 0x07) >> 0)
#define vShortFlags(p)		(((((LPBYTE)(p))[3]) & 0x18) >> 3)
#define NSFvInteractive(p)	(((((LPBYTE)(p))[3]) & 0xE0) >> 5)
#define DataSpeed(p)		(((((LPBYTE)(p))[4]) & 0x1F) >> 0)
#define DataLink(p)			(((((LPBYTE)(p))[4]) & 0xE0) >> 5)

#define SetBCSTD0(p, l, n, m, b, i)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((m) & 0x07) << 3) | \
				(((b) & 0x01) << 6) | (((i) & 0x01) << 7));

#define SetBCSTD2(p, s, c, d)									\
	(((LPBYTE)(p))[2]) = ((((s) & 0x07) << 0) | (((c) & 0x03) << 3) | (((d) & 0x01) << 5));	

#define SetBCSTD3(p, o, f, i)								\
	(((LPBYTE)(p))[3]) = ((((o) & 0x07) << 0) | (((f) & 0x03) << 3) | (((i) & 0x07) << 5));

#define SetBCSTD4(p, s, l)									\
	(((LPBYTE)(p))[4]) = ((((s) & 0x1F) << 0) | (((l) & 0x07) << 5));


#define TextEncoding(p)	(((((LPBYTE)(p))[1]) & 0xF8) >> 3)


#define fAnyWidth(p)	(((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define vRamboVer(p)	(((((LPBYTE)(p))[1]) & 0xF0) >> 4)
#define vCoverAttach(p)	(((((LPBYTE)(p))[2]) & 0x07) >> 0)
#define vAddrAttach(p)	(((((LPBYTE)(p))[2]) & 0x18) >> 3)
#define vMetaFile(p)	(((((LPBYTE)(p))[2]) & 0x60) >> 5)
#define HiResolution(p)	(((((LPBYTE)(p))[3]) & 0x0F) >> 0)
#define HiEncoding(p)	(((((LPBYTE)(p))[3]) & 0xF0) >> 4)
#define CutSheetSizes(p) (((LPBYTE)(p))[4])
#define fOddCutSheet(p)	(((((LPBYTE)(p))[5]) & 0x01) >> 0)

#define SetBCIMAGE0(p, l, n, a, r)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((a) & 0x01) << 3) | \
			(((r) & 0x0F) << 4));

#define SetBCIMAGE2(p, c, a, m)								\
	(((LPBYTE)(p))[2]) = ((((c) & 0x07) << 0) | (((a) & 0x03) << 3) | (((m) & 0x03) << 5));

#define SetBCIMAGE3(p, r, e)								\
	(((LPBYTE)(p))[3]) = ((((r) & 0x0F) << 0) | (((e) & 0x0F) << 4));

#define SetBCIMAGE4(p, c)	(((LPBYTE)(p))[4]) = (c);

#define SetBCIMAGE5(p, c)	(((LPBYTE)(p))[5]) = (((c) & 0x01) << 0);


#define fLowSpeedPoll(p)	 (((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define fHighSpeedPoll(p)	 (((((LPBYTE)(p))[1]) & 0x10) >> 4)
#define fPollByNameAvail(p)	 (((((LPBYTE)(p))[1]) & 0x20) >> 5)
#define fPollByRecipAvail(p) (((((LPBYTE)(p))[1]) & 0x40) >> 6)
#define fFilePolling(p)		 (((((LPBYTE)(p))[1]) & 0x80) >> 7)
#define fExtCapsAvail(p)	 (((((LPBYTE)(p))[2]) & 0x01) >> 0)
#define fNoShortTurn(p)	 	 (((((LPBYTE)(p))[2]) & 0x02) >> 1)
#define vMsgRelay(p)	 	 (((((LPBYTE)(p))[2]) & 0x1C) >> 2)


#define ExtCapsCRC(p)	 	 (((WORD)(((LPBYTE)(p))[3])) | (((WORD)(((LPBYTE)(p))[4])) << 8))
#define SetExtCapsCRC(p, w)  ((((LPBYTE)(p))[3] = (((WORD)(w)) & 0xFF)), (((LPBYTE)(p))[4] = ((((WORD)(w)) >> 8) & 0xFF)))

#define SetBCPOLLCAPS0(p, l, n, lp, hp, pn, pr, pf)			  \
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) |  (((n) & 0x03) << 6));  \
	(((LPBYTE)(p))[1]) =  ((((n) & 0x1C) >> 2) | (((lp) & 0x01) << 3) | \
				(((hp) & 0x01) << 4) | (((pn) & 0x01) << 5) | \
				(((pr) & 0x01) << 6) | (((pf) & 0x01) << 7));

#define SetBCPOLLCAPS2(p, e, n, m)							  \
	(((LPBYTE)(p))[2]) = ((((e) & 0x01) << 0) | (((n) & 0x01) << 1) | (((m) & 0x07) << 2));


#define NSSvMsgProtocol(p)		(((((LPBYTE)(p))[1]) & 0x38) >> 3)
#define NSSvInteractive(p)		(((((LPBYTE)(p))[2]) & 0x07) >> 0)

#define SetBCNSS0(p, l, n, m, i)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6)); \
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((m) & 0x07) << 3)); \
	(((LPBYTE)(p))[2]) = ((((i) & 0x07) << 0));


#define fReturnControl(p)	(((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define PollType(p)			(((((LPBYTE)(p))[1]) & 0xF0) >> 4)
#define NamePass(p)			(((LPBYTE)(p)) + 2) 

#define SetBCPOLLREQ0(p, l, n, f, t) 										\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((f) & 0x01) << 3) | 	\
			(((t) & 0x0F) << 4));



#else /** PORTABLE **/


#define NSFvMsgProtocol(p)	((p)->vMsgProtocol)
#define fBinaryData(p)		((p)->fBinaryData)
#define fInwardRouting(p)	((p)->fInwardRouting)
#define vSecurity(p)		((p)->vSecurity)	
#define vMsgCompress(p)		((p)->vMsgCompress)
#define fDontCache(p)		((p)->fDontCache)
#define OperatingSys(p)		((p)->OperatingSys)
#define vShortFlags(p)		((p)->vShortFlags)
#define NSFvInteractive(p)	((p)->vInteractive)
#define DataSpeed(p)		((p)->DataSpeed)	
#define DataLink(p)			((p)->DataLink)		

#define SetBCSTD0(p, l, n, m, b, i)			\
			(((p)->GroupLength)    = (l));	\
			(((p)->GroupNum)	   = (n));	\
			(((p)->vMsgProtocol)   = (m));	\
			(((p)->fBinaryData)	   = (b));	\
			(((p)->fInwardRouting) = (i));	

#define SetBCSTD2(p, s, c, d)				\
			(((p)->vSecurity)	 = (s));	\
			(((p)->vMsgCompress) = (c));	\
			(((p)->fDontCache)   = (d));

#define SetBCSTD3(p, o, f, i)				\
			(((p)->OperatingSys) = (o));	\
			(((p)->vShortFlags)	 = (f));	\
			(((p)->vInteractive) = (i));

#define SetBCSTD4(p, s, l)				\
			(((p)->DataSpeed)	= (s));	\
			(((p)->DataLink)	= (l));

#define TextEncoding(p)		(((LPBCTEXTID)(p))->TextEncoding)	

#define fAnyWidth(p)	 ((p)->fAnyWidth)
#define vRamboVer(p)	 ((p)->vRamboVer)	
#define vCoverAttach(p)	 ((p)->vCoverAttach)
#define vAddrAttach(p)	 ((p)->vAddrAttach)
#define vMetaFile(p)	 ((p)->vMetaFile)	
#define HiResolution(p)	 ((p)->HiResolution)
#define HiEncoding(p)	 ((p)->HiEncoding)		
#define CutSheetSizes(p) ((p)->CutSheetSizes)
#define fOddCutSheet(p)	 ((p)->fOddCutSheet)


#define SetBCIMAGE0(p, l, n, a, r)			\
			(((p)->GroupLength)    = (l));	\
			(((p)->GroupNum)	   = (n));	\
			(((p)->fAnyWidth)      = (a));	\
			(((p)->vRamboVer)	   = (r));

#define SetBCIMAGE2(p, c, a, m)				\
			(((p)->vCoverAttach)   = (c));	\
			(((p)->vAddrAttach)    = (a));	\
			(((p)->vMetaFile)	   = (m));

#define SetBCIMAGE3(p, r, e)   			\
			(((p)->HiResolution) = (r));	\
			(((p)->HiEncoding)   = (e));	\

#define SetBCIMAGE4(p, c)	(((p)->CutSheetSizes) = (c));

#define SetBCIMAGE5(p, c)	(((p)->fOddCutSheet) = (c));


#define fLowSpeedPoll(p)	 ((p)->fLowSpeedPoll)	
#define fHighSpeedPoll(p)	 ((p)->fHighSpeedPoll)
#define fPollByNameAvail(p)	 ((p)->fPollByNameAvail)
#define fPollByRecipAvail(p) ((p)->fPollByRecipAvail)
#define fFilePolling(p)		 ((p)->fFilePolling)		
#define fExtCapsAvail(p)	 ((p)->fExtCapsAvail)	
#define fNoShortTurn(p)	 	 ((p)->fNoShortTurn)
#define vMsgRelay(p)	 	 ((p)->vMsgRelay)
#define ExtCapsCRC(p)	 	 ((p)->ExtCapsCRC)


#define SetExtCapsCRC(p, w)	 (((p)->ExtCapsCRC) = (w))


#define SetBCPOLLCAPS0(p, l, n, lp, hp, pn, pr, pf)	\
			(((p)->GroupLength)    	 = (l));		\
			(((p)->GroupNum)	   	 = (n));		\
			(((p)->fLowSpeedPoll)    = (lp));		\
			(((p)->fHighSpeedPoll)	 = (hp));		\
			(((p)->fPollByNameAvail) = (pn));		\
			(((p)->fPollByRecipAvail)= (pr));		\
			(((p)->fFilePolling) 	 = (pf));

#define SetBCPOLLCAPS2(p, e, n, m)				\
			(((p)->fExtCapsAvail)	= (e));		\
			(((p)->fNoShortTurn)	= (n));		\
			(((p)->vMsgRelay) 		= (m));


#define NSSvMsgProtocol(p)		((p)->vMsgProtocol)
#define NSSvInteractive(p)		((p)->vInteractive)

#define SetBCNSS0(p, l, n, m, i)		 		\
			(((p)->GroupLength)    	 = (l));	\
			(((p)->GroupNum)	   	 = (n));	\
			(((p)->vMsgProtocol)   	 = (m));	\
			(((p)->vInteractive)	 = (i));	\


#define fReturnControl(p)	(((LPBCPOLLREQ)(p))->fReturnControl)
#define PollType(p)			(((LPBCPOLLREQ)(p))->PollType)
#define NamePass(p)			(((LPBCPOLLREQ)(p))->b)

#define SetBCPOLLREQ0(p, l, n, f, t) 			\
			((((LPBCPOLLREQ)(p))->GroupLength)    = (l));	\
			((((LPBCPOLLREQ)(p))->GroupNum)	      = (n));	\
			((((LPBCPOLLREQ)(p))->fReturnControl) = (f));	\
			((((LPBCPOLLREQ)(p))->PollType)       = (t));	\


#endif /** PORTABLE **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\rl_debug.h ===
////////////////////////
// debugging
///////////////////////
#ifdef DEFINE_T30_GLOBALS
    #define DEFINE_T30_EXTERNAL
#else
    #define DEFINE_T30_EXTERNAL   extern
#endif

DEFINE_T30_EXTERNAL  int     gfScrnPrint;
DEFINE_T30_EXTERNAL  int     gfFilePrint;
DEFINE_T30_EXTERNAL  HANDLE  ghLogFile;
DEFINE_T30_EXTERNAL  HFILE   ghComLogFile;

#define SIMULATE_ERROR_TX_IO      1
#define SIMULATE_ERROR_RX_IO      2
#define SIMULATE_ERROR_TX_TIFF    3
#define SIMULATE_ERROR_RX_TIFF    4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\pssframe.h ===
/*++

Module Name:
    pssframe.h
    
Abstract:
    This module logs the content of DISs and DCSs into PSS log file.
    
Author:
    Jonathan Barner (t-jonb)  Mar, 2001

Revision History:

--*/

#ifndef _PSSFRAME_H_
#define _PSSFRAME_H_


void LogClass1DISDetails(PThrdGlbl pTG, NPDIS npdis);
void LogClass1DCSDetails(PThrdGlbl pTG, NPDIS npdis);
void LogClass2DISDetails(PThrdGlbl pTG, LPPCB lpPcb);
void LogClass2DCSDetails(PThrdGlbl pTG, LPPCB lpPcb);


#endif // _PSSFRAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\protparm.h ===
#ifndef _PROTPARAMS_
#define _PROTPARAMS_


// initial defaults for all settings in braces at end

typedef struct
{
  USHORT uSize;	// size of this structure

  SHORT	IgnoreDIS;				// Num DISs to ignore (set to 1 on echoey satelite lines) [0]
  SHORT	TrainingErrorTolerance;	// 0 to 4 (0=infinite tolerance, 4=very picky) [2]
  SHORT	RecvG3ErrorTolerance;	// 0 to 4 (0=infinite tolerance, 4=very picky) [2]
  SHORT	PadRCP;					// T/F (Fill out RCP to full frame size. Affects G3 only) [0]

  SHORT	HighestSendSpeed; // 2400/4800/7200/9600/12000/14400 [0 == highest avail]
  SHORT	LowestSendSpeed;  // 2400/4800/7200/9600/12000/14400 [0 == lowest avail]
  SHORT	DisableSendECM;	  // T/F (affects ALL sends. Will disable At Work prot & MMR) [0]
  SHORT	Send64ByteECM;	  // T/F (use smaller frames on send) [0]

  SHORT	HighestRecvSpeed; // 2400/4800/7200/9600/12000/14400 [0 == highest avail]
  SHORT	DisableRecvECM;	  // (affects G3 and BFT--recv MMR & BFT are disabled) [0]
  SHORT	Recv64ByteECM;	  // T/F (use smaller frames on recv) [0]


  BOOL	fEnableV17Send;	  // enable V17 (12k/14k) send speeds [1]
  BOOL	fEnableV17Recv;	  // enable V17 (12k/14k) recv speeds [1]
  USHORT uMinScan;		  // determined by printer speed      [MINSCAN_0_0_0]

  SHORT SendT1Timer;	// T1 timer on send (in secs) [0==default]
  SHORT RecvT1Timer;	// T1 timer on recv (in secs) [0==default]

  SHORT RTNAction;		 // 0=dropspeed 1=samespeed 2=hangup [0==default]
  SHORT CTCAction;		 // 0=dropspeed 1=hangup	   2=TBD	[0==default]
  DWORD RTNNumOfRetries; // Count the number of retries of the same page (in case we get RTN)
                         // This value is set to zero per-page.


  USHORT EnableG3SendECM;		// enables ECM for MH & MR [0]
  USHORT CopyQualityCheckLevel;	// how strictly to check [0=off 2=default 4=strict]
}
PROTPARAMS, far* LPPROTPARAMS;


#define MIN_CALL_SEPERATION		10000L	 // to be added to the PROTPARMS struct
// #define RECOVERY_RECIPIENT		"System" // not needed anymore--dont add to SOS

    
#define MINSCAN_0_0_0		7
#define MINSCAN_5_5_5		1
#define MINSCAN_10_10_10	2
#define MINSCAN_20_20_20	0
#define MINSCAN_40_40_40	4

#define MINSCAN_40_20_20	5
#define MINSCAN_20_10_10	3
#define MINSCAN_10_5_5		6

// #define MINSCAN_0_0_?		15		// illegal
// #define MINSCAN_5_5_?		9		// illegal
#define MINSCAN_10_10_5			10
#define MINSCAN_20_20_10		8
#define MINSCAN_40_40_20		12

#define MINSCAN_40_20_10		13
#define MINSCAN_20_10_5			11
// #define MINSCAN_10_5_?		14		// illegal



#endif //_PROTPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\timeouts.h ===
#ifndef _TIMEOUTS_
#define _TIMEOUTS_

typedef struct tagTO {
        ULONG   ulStart;
        ULONG   ulTimeout;
        ULONG   ulEnd;
} TO, far* LPTO;


#endif //_TIMEOUTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\tipes.h ===
/***************************************************************************
	Name      :	TIPES.H
	Comment   :	Basic type definitions and universal manifest constants
			    for T30 driver and associated code.

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

	Revision Log
	Num   Date      Name     Description
	--- -------- ---------- -----------------------------------------------
	101	06/02/92	arulm	Changed all type names to upper case. Here and in code
***************************************************************************/



// #include <stdio.h>
// #include <stdlib.h>
// #include <time.h>
#include <string.h> 

// typedef signed char		BOOL;
// typedef unsigned char 	BYTE;
typedef unsigned short 	UWORD;
typedef signed short	SWORD;
// typedef unsigned long	ULONG;
typedef signed long		SLONG;

typedef BYTE far*		LPB;
typedef BYTE near*		NPB;
typedef BYTE near*		NPBYTE;

typedef BOOL far*		LPBOOL;

typedef UWORD far*		LPUWORD;
typedef UWORD near*		NPUWORD;

typedef SWORD far*		LPSWORD;

#define FALSE	0
#define TRUE	1

#ifndef WIN32
#define	MAKEWORD(l,h)	((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))
#endif



//-------------------// added NVRAM logging //---------------------//


#ifdef NVLOG
	void _export CDECL MyLogError1(WORD wProcId, WORD wModId, WORD wFile, WORD wLine);
	void _export CDECL MyLogError2(LPSTR szErr, ...);
#	define ERRMSG(m) (ERRORMSG(m), MyLogError1(0, MODID, FILEID, __LINE__), (MyLogError2 m))
#else //NVLOG
#	ifdef IFK
#		define ERRMSG(m) ERRORMSG(m)
#	else
#		define ERRMSG(m) DEBUGMSG(1, m)
#	endif
#endif //NVLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\resource.h ===
// resource header file

#define IDS_UNSUPPORTED_CHARACTER   0x01000003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\debug.h ===
/**--------------------------- Debugging ------------------------**/

#define SZMOD                   "T30: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;

#       define ZONE_T30                 ((1L << 0) & dpCurSettings.ulZoneMask)
#       define ZONE_ECM                 ((1L << 1) & dpCurSettings.ulZoneMask)
#       define ZONE_SWECM               ZONE_ECM
#       define ZONE_HD                  ((1L << 2) & dpCurSettings.ulZoneMask)
#       define ZONE_BG                  ((1L << 3) & dpCurSettings.ulZoneMask)
#       define ZONE_FRAMES              ((1L << 4) & dpCurSettings.ulZoneMask)
#       define ZONE_MAIN                ((1L << 5) & dpCurSettings.ulZoneMask)
#       define ZONE_BUFS                ((1L << 12) & dpCurSettings.ulZoneMask)
#       define ZONE_FIL                 ((1L << 13) & dpCurSettings.ulZoneMask)
#       define ZONE_TIMEOUT             ((1L << 14) & dpCurSettings.ulZoneMask)
#       define ZONE_TO                  ((1L << 15) & dpCurSettings.ulZoneMask)
#       define ZONE_IFP                 ((1L << 7) & dpCurSettings.ulZoneMask)
#endif

#ifdef DEBUG
#       define ST_FRAMES(x)     if(ZONE_FRAMES) { x; }
#else
#       define ST_FRAMES(x)     { }
#endif



#define MODID           MODID_AWT30

#define FILEID_ECM              1
#define FILEID_FILTER   2
#define FILEID_HDLC             3
#define FILEID_T30              4
#define FILEID_T30MAIN  5
#define FILEID_TIMEOUTS 6
#define FILEID_IFP              7
#define FILEID_SWECM    8


#ifdef PDUMP    // Protocol Dump
        void RestartDump(PThrdGlbl pTG);
        void DumpFrame(PThrdGlbl pTG, BOOL     fSend, IFR ifr, USHORT cbFIF, LPBYTE lpbFIF);
        void PrintDump(PThrdGlbl pTG);
#else
#       define RestartDump(PThrdGlbl pTG)
#       define DumpFrame(PThrdGlbl pTG, fSend, ifr, cbFIF, lpbFIF)
#       define PrintDump(PThrdGlbl pTG)
#endif

#ifdef DEBUG
        void D_PrintFrame(LPB lpb, UWORD cb);
#else
#       define  D_PrintFrame(lpb, cb)   {}
#endif

// errmsg for echo protection code
#define ECHOMSG(ifr)    RETAILMSG((SZMOD "WARNING: Ignoring ECHO of %s(%d)\r\n", (LPSTR)(rgFrameInfo[ifr].szName), ifr));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\t30ext.h ===
#ifndef _T30EXT_H_
#define _T30EXT_H_
#define GUID_T30_EXTENSION_DATA TEXT("{27692245-497C-47c3-9607-CD388AB2BE0A}")
//
// Unicode version required for T30 FSP itself which is compiled in ANSI
//
#define GUID_T30_EXTENSION_DATA_W L"{27692245-497C-47c3-9607-CD388AB2BE0A}"

typedef struct T30_EXTENSION_DATA_tag {
    BOOL bAdaptiveAnsweringEnabled;         // TRUE if adaptive answering should be enabled
                                            // for this device.
} T30_EXTENSION_DATA;
typedef T30_EXTENSION_DATA * LPT30_EXTENSION_DATA;
typedef const T30_EXTENSION_DATA * LPCT30_EXTENSION_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\psslog.h ===
/*++

Module Name:

    psslog.h
    
Abstract:

    Header of the fax service provider PSS log.

    note: in every file you wish to log from, after including this file, you should
    define a unique FILE_ID. example:
        #include "psslog.h"
        #define FILE_ID          FILE_ID_T30
    
Author:

    Jonathan Barner (t-jonb)  Feb, 2001

Revision History:

--*/

#ifndef _PSSLOG_H_
#define _PSSLOG_H_

#define REGVAL_LOGGINGENABLED                      TEXT("LoggingEnabled")
#define REGVAL_LOGGINGFOLDER                       TEXT("LoggingFolder")
#define REGVAL_LOGFILENUMBER                       TEXT("LogFileNumber")

#define DEFAULT_LOG_FOLDER                         TEXT("%temp%")

typedef enum {PSS_SEND, PSS_RECEIVE} PSS_JOB_TYPE;

void OpenPSSLogFile(PThrdGlbl pTG, LPSTR szDeviceName, PSS_JOB_TYPE eType);
void ClosePSSLogFile(PThrdGlbl pTG);

#define PSS_WRN     pTG, PSS_WRN_MSG, FILE_ID, __LINE__
#define PSS_ERR     pTG, PSS_ERR_MSG, FILE_ID, __LINE__
#define PSS_MSG     pTG, PSS_MSG_MSG, FILE_ID, __LINE__

typedef enum {
    PSS_MSG_MSG, PSS_WRN_MSG, PSS_ERR_MSG
} PSS_MESSAGE_TYPE;


// example: PSSLogEntry(PSS_MSG, 0, "This is message number %d", 1)
void PSSLogEntry(
    PThrdGlbl pTG,
    PSS_MESSAGE_TYPE const nMessageType,
    DWORD const dwFileID,
    DWORD const dwLine,
    DWORD dwIndentLevel,
    LPCTSTR pcszFormat,
    ... );

// example: PSSLogEntryHex(PSS_MSG, 1, myBuffer, dwMyBufferLen, "This is my buffer, %d bytes,", dwMyBufferLen);
// Output: [..]     This is my buffer, 2 bytes, 0f a5
void PSSLogEntryHex(
    PThrdGlbl pTG,
    PSS_MESSAGE_TYPE const nMessageType,
    DWORD const dwFileID,
    DWORD const dwLine,
    DWORD dwIndentLevel,

    LPB const lpb,
    DWORD const dwSize,

    LPCTSTR pcszFormat,
    ... );


// cl2and20
#define FILE_ID_CL2AND20        1
#define FILE_ID_CLASS2          2
#define FILE_ID_CLASS20         3
// class1
#define FILE_ID_CRC             4
#define FILE_ID_DDI             5
#define FILE_ID_DECODER         6
#define FILE_ID_ENCODER         7
#define FILE_ID_FRAMING         8
// comm
#define FILE_ID_FCOM            9
#define FILE_ID_FDEBUG          10
#define FILE_ID_FILTER          11
#define FILE_ID_IDENTIFY        12
#define FILE_ID_MODEM           13
#define FILE_ID_NCUPARMS        14
#define FILE_ID_TIMEOUTS        15
// main
#define FILE_ID_AWNSF           16
#define FILE_ID_DIS             17
#define FILE_ID_ECM             18
#define FILE_ID_ERRSTAT         19
#define FILE_ID_HDLC            20
#define FILE_ID_MEMUTIL         21
#define FILE_ID_NEGOT           22
#define FILE_ID_PROTAPI         23
#define FILE_ID_PSSLOG          24
#define FILE_ID_RECV            25
#define FILE_ID_RECVFR          26
#define FILE_ID_REGISTRY        27
#define FILE_ID_RX_THRD         28
#define FILE_ID_SEND            29
#define FILE_ID_SENDFR          30
#define FILE_ID_T30             31
#define FILE_ID_T30API          32
#define FILE_ID_T30MAIN         33
#define FILE_ID_T30U            34
#define FILE_ID_T30UTIL         35
#define FILE_ID_TX_THRD         36
#define FILE_ID_WHATNEXT        37

#define FILE_ID_PSSFRAME        38


#endif // _PSSLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\rendserv.h ===
/********************************************\
 * 
 *  File   : rendserv.h
 *  Author : Kevin Gallo
 *  Created: 9/22/93
 *
 *  Copyright (c) Microsoft Corp. 1993-1994
 *
 *  Overview:
 *
 *  Revision History:
 \********************************************/

#ifndef _RENDSERV_H
#define _RENDSERV_H

// System includes

#ifdef OLE2
#define INC_OLE2 1
#include <objbase.h>
#endif

#include "ifaxos.h"
#ifdef IFAX
#include "awfile.h"
#include "sosutil.h"
#include "device.h"
#endif
#include "render.h"

// Library Name
#ifdef WIN32
#define LIB_RENDSERV "RNDSRV32.DLL"
#else
#define LIB_RENDSERV "RENDSERV.DLL"
#endif

// =================================================================
// Errors - 
//     These occupy the lowest 6 bits of the error 
// =================================================================

#define RSMAKE_ERR(err) (ERR_FUNCTION_START+err)

#define RSERR_GP_FAULT       RSMAKE_ERR(0)  // GP Fault
#define RSERR_OPER_FAIL      RSMAKE_ERR(1)  // The desired operation failed.
#define RSERR_BAD_OPER       RSMAKE_ERR(2)  // User tried to do something invalid
#define RSERR_BAD_DATA       RSMAKE_ERR(3)  // Bad data was passed to a renderer.
#define RSERR_DEV_FAIL       RSMAKE_ERR(4)  // Device failed.
#define RSERR_PROP_FAIL      RSMAKE_ERR(5)  // Could not get a mapi property

// =================================================================
// Methods in subsystems
//     These occupy bits 6-11   -  64 values
// =================================================================

#define RSMAKE_METHOD(method) (method << 6) 

// =================================================================
// General methods
// =================================================================

#define RSMETHOD_UNKNOWN     RSMAKE_METHOD(0)
#define RSMETHOD_OPEN        RSMAKE_METHOD(1)
#define RSMETHOD_CLOSE       RSMAKE_METHOD(2)
#define RSMETHOD_INIT        RSMAKE_METHOD(3)
#define RSMETHOD_READ        RSMAKE_METHOD(4)
#define RSMETHOD_WRITE       RSMAKE_METHOD(5)
#define RSMETHOD_RENDER      RSMAKE_METHOD(6)
#define RSMETHOD_ALLOC       RSMAKE_METHOD(7)
#define RSMETHOD_WINPROC     RSMAKE_METHOD(8)
#define RSMETHOD_START       RSMAKE_METHOD(9)
#define RSMETHOD_ERRREC      RSMAKE_METHOD(10)

// =================================================================
//
// System specific - start at 32
//
// =================================================================

#define RSMETHOD_CUSTOM_START (32)

#define RSMETHOD_GETDEVICES  RSMAKE_METHOD(RSMETHOD_CUSTOM_START)

// =================================================================
//
// Systems
//     These occupy bits 12-15 of the low WORD - 16 values
//
// =================================================================

#define RSMAKE_SYS(sys) (sys << 12)

#define RSSYS_UNKNOWN        RSMAKE_SYS(0)   // Unknown
#define RSSYS_SOS            RSMAKE_SYS(1)   // SOS subsystem
#define RSSYS_FILESYS        RSMAKE_SYS(2)   // File System
#define RSSYS_NETWORK        RSMAKE_SYS(3)   // Network
#define RSSYS_RENDERER       RSMAKE_SYS(4)   // Renderers
#define RSSYS_RENDSERV       RSMAKE_SYS(5)   // Rendering Server
#define RSSYS_DEVICE         RSMAKE_SYS(6)   // Devices
#define RSSYS_THREAD         RSMAKE_SYS(7)   // Threads

// =================================================================
//
//  Error macros
//
// =================================================================

#define RSFormCustomError(sys,method,err) ((WORD) (sys | method | err))
#define RSFormIFError(sys,method,err) \
           (IFErrAssemble(PROCID_NONE,MODID_REND_SERVER,0,RSFormCustomError(sys,method,err)))

#define RSGetErrCode(err)     (err & 0x003f)
#define RSGetErrMethod(err)   (err & 0x0fc0)
#define RSGetErrSys(err)      (err & 0xf000)

// =================================================================

#ifdef __cplusplus
extern "C" {
#endif

typedef LPVOID LPRENDSERVER ;

typedef enum {
    RS_BEGINNING = 0,
    RS_CURRENT = 1,
    RS_END = 2,
} RSOrigin_t ;

#ifdef IFAX

typedef enum {
    RSD_NULL = ATTACH_BY_NULL,
    RSD_FILE = ATTACH_BY_REF_RESOLVESOS,
    RSD_AWFILE = ATTACH_BY_SAVED_SECFILE,
    RSD_PIPE = ATTACH_BY_PIPE,
    RSD_SCANNER_PIPE = ATTACH_BY_SCANNER_PIPE,
    RSD_PRINTER_PIPE = ATTACH_BY_PRINTER_PIPE,
    RSD_METAFILE_PIPE = ATTACH_BY_METAFILE_PIPE,
    RSD_TRANSPORT_PIPE = ATTACH_BY_TRANSPORT_PIPE,
    RSD_LINEARIZER = ATTACH_BY_LINEARIZER,
#ifdef OLE2
    RSD_OLESTREAM,
#endif
    RSD_DIRECT_COPY,
} RSDeviceType_t ;

#else

typedef enum {
    RSD_NULL,
    RSD_FILE,
    RSD_AWG3_HANDLE,
#ifdef OLE2
    RSD_OLESTREAM,
#endif
} RSDeviceType_t ;

#endif

// Define Job Context

typedef WORD HJC ;

//
// Macros for combining Device IDs
// Used to store ID in PR_ATTACH_DEVID property.
// (major is high word and minor is low word)

#define MAKE_DEVID(major,minor) MAKEWORD(minor,major)
#define GET_MINOR_DEVID(id) LOBYTE(id)
#define GET_MAJOR_DEVID(id) HIBYTE(id)

// Encoding structure for PR_ENCODING property
// For now use the encoded values not the real values (match caps structure)
// We may want to set width and height to be exact values

typedef
struct Encoding_t {
    WORD cbStruct ;      // Size of the structure
    DWORD Resolution ;   // The data resolution - see buffer.h for types (AWRES_xxx)
    DWORD Encoding ;     // The data encoding format - see buffer.h for types (xxx_DATA)
    DWORD PageSize  ;    // The page size - see buffer.h for types (AWPAPER_xxx)
    DWORD LengthLimit ;  // The page length - see buffer.h for types (AWLENGTH_xxx)
} Encoding_t , FAR * lpEncoding_t ;    
    

// This is the topology data structure

#ifdef IFAX

#pragma warning (disable: 4200)
typedef
struct TopNode {
    WORD cbSize ;                // Size of node
    char szRenderName[16] ;      // Renderers modules name (cannot be more than 12 characters)
    LPCSTR RenderInfoProc ;      // Must be the Ordinal Number of the getinfo call
    char RenderParam[] ;
} TopNode, FAR * lpTopNode ;

typedef
struct Topology {
    WORD cbSize ;                // Size of the struct itself without nodes (just the header)
    WORD cbTotalSize ;           // Total size of data in struct
    WORD nRenderers ;            // Number of renderers
    WORD uOffset[] ;             // Offsets into this struct where TopNode's are.  There are nRenderers
                                 // of these.
} Topology , FAR * lpTopology ;

#define GET_TOPNODE(Top,idx) ((lpTopNode) (((LPBYTE)Top) + Top->uOffset[idx]))

#pragma warning (default: 4200)

#else

//  A topology will be a linked list of TopNodes

typedef struct TopNode FAR * lpTopNode ;

#pragma warning (disable: 4200)

typedef struct TopNode {
    WORD cbSize ;                // Size of node
    LPTSTR szRenderName ;         // Renderers modules name - (this is the dll)
    LPCSTR RenderInfoProc ;      // Will be passed directly to getprocaddress (i.e. ordinal or name)
    lpTopNode lpNext ;           // Used to create linked list topology
    char RenderParam[] ;
} TopNode ;

#pragma warning (default: 4200)

typedef struct Topology {
    WORD nRenderers ;            // Number of renderers
    lpTopNode lpHead ;           // Pointer to first renderer
    lpTopNode lpTail ;           // Pointer to last renderer
} Topology , FAR * lpTopology ;

#endif

/****
	@doc    EXTERNAL    RENDSERV

	@types  RSProcessInfo_t  |   The Process Pipe information structure.

	@field  HSESSION |  hSession | Specifies the session handle for the device.

	@field  DEVICESTR  |  szDeviceName | Specifies the name of the device to use.

	@field  UCHAR    |  ucMajorDevId | Specifies the Major Id of the device.

	@field  UCHAR    |  ucMinorDevId | Specifies the Minor Id of the device.

	@field  LPVOID   |  lpMode | Specifies the mode structure to be passed to the device.

	@field  UINT     |  cbMode | Specifies the size of mode structure.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname RSProcessInfo_t
****/

#ifdef IFAX
typedef
struct RSProcessPipeInfo_t {
    HSESSION hSession ;
    DEVICESTR szDeviceName ;
    UCHAR ucMajorDevId ;
    UCHAR ucMinorDevId ;
    LPVOID lpMode ;
    UINT cbMode ;
} RSProcessPipeInfo_t , FAR * lpRSProcessPipeInfo_t ;
#endif

typedef 
struct RSDeviceInfo_t {
    RSDeviceType_t DevType ;
    Encoding_t Encoding ;
    union {
	LPTSTR lpszFileName ;
	HANDLE hFile ;
#ifdef OLE2
	LPSTREAM lpstream ;
#endif
#ifdef IFAX
	hSecureFile SecFileName ;
	HPIPE hpipe ;
	LPMESSAGESOS lpMessage ;
	RSProcessPipeInfo_t ProcInfo ;
#endif
    } ;
} RSDeviceInfo_t ;

typedef RSDeviceInfo_t FAR * lpRSDeviceInfo_t, FAR * FAR * lplpRSDeviceInfo_t ;
typedef const RSDeviceInfo_t FAR * lpCRSDeviceInfo_t, FAR * FAR * lplpCRSDeviceInfo_t ;

#ifdef IFAX

#pragma warning (disable: 4200)

typedef
struct SOSProcessPipeInfo_t {
    HSESSION hSession ;
    DEVICESTR szDeviceName ;
    UCHAR ucMajorDevId ;
    UCHAR ucMinorDevId ;
    UINT cbMode ;
    BYTE Mode[] ;
} SOSProcessPipeInfo_t , FAR * lpSOSProcessPipeInfo_t ;

typedef 
struct SOSDeviceInfo_t {
    UINT cbSize ;
    RSDeviceType_t DevType ;
    Encoding_t Encoding ;
    union {
	char lpszFileName[] ;
	hSecureFile SecFileName ;
	HPIPE hpipe ;
	LPMESSAGESOS lpMessage ;
	SOSProcessPipeInfo_t ProcInfo ;
    } ;
} SOSDeviceInfo_t , FAR * lpSOSDeviceInfo_t, FAR * FAR * lplpSOSDeviceInfo_t ;

#pragma warning (default: 4200)

#endif

typedef void (WINAPI *LPFNACKPROC) (LPRENDSERVER lprs,WORD PageNum,WORD wValue,LPVOID lpvData) ;
typedef void (WINAPI *LPFNSTATUSPROC) (LPRENDSERVER lprs,WORD PageNum,WORD kbytes,LPVOID lpvData) ;

/********
	@doc    EXTERNAL    RENDSERV

	@api    LPRENDSERVER    | RSAlloc   | Allocates a Render Server.

	@rdesc  Returns a pointer to the Rendering Server or NULL if there was not enough memory.
********/
	
EXPORT_DLL LPRENDSERVER WINAPI RSAlloc () ;
EXPORT_DLL void WINAPI RSFree (LPRENDSERVER lprs) ;
	
EXPORT_DLL BOOL WINAPI RSInit (LPRENDSERVER lprs,HJC hjc,HWND hwnd) ;

EXPORT_DLL BOOL WINAPI RSOpen (LPRENDSERVER lprs,
			       lpRSDeviceInfo_t lpSrcInfo,lpRSDeviceInfo_t lpTgtInfo,
			       lpTopology lpTop,LPJOBINFO lpJobInfo) ;
EXPORT_DLL BOOL WINAPI RSClose (LPRENDSERVER lprs) ;

// Returns false if we did not process it

EXPORT_DLL LRESULT WINAPI RSWndProc (LPRENDSERVER lprs,UINT msg,WPARAM wParam,LPARAM lParam) ;

EXPORT_DLL BOOL WINAPI RSRender (LPRENDSERVER lprs,UINT nIterations) ;
EXPORT_DLL BOOL WINAPI RSSetPage (LPRENDSERVER lprs,RSOrigin_t origin,int offset) ;

// These will be called once a page or job ack
// is received (indicating the target has confirmed them.
//
// The last page will call JobAck and not PageAck
//   - thus if these are 5 pages there will be 4 page acks and one job ack

EXPORT_DLL void WINAPI RSSetPageAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetJobAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetStatusCallback(LPRENDSERVER lprs,LPFNSTATUSPROC lpfnStatusProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetSrcJobAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;

EXPORT_DLL void WINAPI RSPause (LPRENDSERVER lprs) ;
EXPORT_DLL void WINAPI RSResume (LPRENDSERVER lprs) ;

EXPORT_DLL void WINAPI RSAbort (LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSSpool (LPRENDSERVER lprs) ;

EXPORT_DLL BOOL WINAPI RSIsBlocking(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsPaused(LPRENDSERVER lprs)  ;
EXPORT_DLL BOOL WINAPI RSIsDone(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsInit(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsOpen(LPRENDSERVER lprs) ;


// This will take the device structures and create a topology using format resolution
// If this succeeds it will render the entire topology calling yield where appropriate 
// and then returning when complete or an error occurs


// If this returns FALSE then this the function will fail and return FALSE

typedef BOOL (WINAPI *LPFNYIELDPROC) (LPVOID lpvData) ;

EXPORT_DLL BOOL WINAPI RSFormatAndRender (lpRSDeviceInfo_t lpSrcInfo,
					  lpRSDeviceInfo_t lpTgtInfo,
					  LPJOBINFO lpJobInfo,
					  LPFNYIELDPROC lpfnYieldProc,
					  LPVOID lpvData) ;

#define ORD_RSFormatAndRender MAKEINTRESOURCE(100) // "RSFormatAndRender"
typedef BOOL (* WINAPI LPFN_RSFormatAndRender)
	(lpRSDeviceInfo_t, lpRSDeviceInfo_t, LPJOBINFO, LPFNYIELDPROC, LPVOID);

	
#ifdef IFAX

typedef struct RSRInfo_t {
    DWORD dwIndex ;
    lpRSDeviceInfo_t lpSrcInfo ;
    lpRSDeviceInfo_t lpTgtInfo ;
    lpTopology lpTop ;
    LPJOBINFO lpJobInfo ;
} RSRInfo_t ;

/********
    @doc    EXTERNAL    RENDERSERV

    @types  RSReason_t  |   The callback function can be called for any of these reasons.

    @emem   RSREASON_NONE  |   No specific reason - simply a test.

    @emem   RSREASON_INIT  |   This is to initialize the structure.  The callback function
            is responsible for setting the following fields of the Render_t structure:

            lpSrcInfo: The source device information structure.
            lpTgtInfo: The target device information structure.
            lpTop    : The topology structure.
            lpJobInfo: The job information structure if required by renderers.
	    hjc      : The job context identifier.
	    hwnd     : The hwnd to have messages for pipe posted to.

    @emem   RSREASON_START  |   Indicates that the rendering will begin.

    @emem   RSREASON_DONE  |   Indicates that rendering is complete.

    @emem   RSREASON_DEINIT  |   Indicates the job information should be freed.  Anything 
            allocated in RSREASON_INIT should be freed.  This is guaranteed to be call if
            the callback returned TRUE from the RSREASON_INIT callback - even if an error
            occurs.

    @emem   RSREASON_STATUS  |   If the status flag was passed in the RSRender call then
            this contains status information.  Not defined yet!

    @emem   RSREASON_YIELD  |   If the yield flag was specified then this gives the callback 
            the opportunity to do other work - such as process the message queue.

    @emem   RSREASON_ERROR  |   Indicates an error has occurred and rendering will be terminated.

********/

typedef enum {
    RSREASON_NONE = 0,
    RSREASON_INIT,
    RSREASON_START,
    RSREASON_DONE,
    RSREASON_DEINIT,

    RSREASON_STATUS,
    RSREASON_YIELD,
    RSREASON_ERROR,
} RSReason_t ;

typedef struct Render_t FAR * LPRender_t ;

typedef BOOL (WINAPI *LPFNRENDSERVPROC) (LPVOID lpvData,DWORD fdwReason,LPRender_t lpRenderData) ;

#define RSR_ASYNC_MODE    0x00000001      // The call will be asyncronous
#define RSR_STATUS_MODE   0x00000002      // Callback will be done for status
#define RSR_YIELD_MODE    0x00000004      // In sync mode yield will be called

EXPORT_DLL BOOL WINAPI RSRenderData(DWORD fdwFlags,
				    LPFNRENDSERVPROC lpfnRSProc,
				    LPVOID lpvData) ;

typedef struct Render_t {
    DWORD fdwFlags ;
    LPFNRENDSERVPROC lpfnRSProc ;
    LPVOID lpvData ;
    
    DWORD dwIndex ;
    lpRSDeviceInfo_t lpSrcInfo ;
    lpRSDeviceInfo_t lpTgtInfo ;
    lpTopology lpTop ;
    LPJOBINFO lpJobInfo ;
    HJC hjc ;
    HWND hwnd ;
    
    WORD wPageNum ;
    WORD wkbytes ;

    DWORD dwError ;

    LPRENDSERVER lprs ;
} Render_t ;

//
// MAPI Specific calls
//

typedef LPVOID LPSOSREND ;

LPSOSREND WINAPI SRSAlloc () ;
void WINAPI SRSFree (LPSOSREND lprs) ;
	
BOOL WINAPI SRSInit (LPSOSREND lprs) ;
BOOL WINAPI SRSOpen (LPSOSREND lprs,ENTRYIDSOS src,ENTRYIDSOS tgt,HJC hjc,HWND hwnd) ;
BOOL WINAPI SRSClose (LPSOSREND lprs) ;
	
LRESULT WINAPI SRSWndProc (LPSOSREND lprs,UINT msg,WPARAM wParam,LPARAM lParam) ;

// This will open the attachment

BOOL WINAPI SRSSetCurAttachNum (LPSOSREND lprs,UINT num) ;

// This will automatically advance to next attachment if autoadvance is TRUE (default)
// If autoadvance is true - the job is done after the last attachent otherwise it
// will be set to true after the current attachment is completed.
//
// If SetCurAttachNum is called the done flag will be reset to FALSE

BOOL WINAPI SRSRender (LPSOSREND lprs,UINT nIterations) ;

LPBUFFER WINAPI SRSGetBuf (LPSOSREND lprs) ;
BOOL WINAPI SRSSetPage (LPSOSREND lprs,RSOrigin_t origin,int offset) ;

BOOL WINAPI SRSGetAutoAdvance (LPSOSREND lprs) ;
void WINAPI SRSSetAutoAdvance (LPSOSREND lprs,BOOL badv) ;

ULONG WINAPI SRSGetNumAttach (LPSOSREND lprs) ;
ULONG WINAPI SRSGetCurAttachNum (LPSOSREND lprs) ;

void WINAPI SRSPause (LPSOSREND lprs) ;
void WINAPI SRSResume (LPSOSREND lprs) ;

void WINAPI SRSAbort (LPSOSREND lprs) ;
BOOL WINAPI SRSSpool (LPSOSREND lprs) ;
BOOL WINAPI SRSPartSave (LPSOSREND lprs) ;

BOOL WINAPI SRSIsBlocking(LPSOSREND lprs) ;
BOOL WINAPI SRSIsPaused(LPSOSREND lprs)  ;
BOOL WINAPI SRSIsDone(LPSOSREND lprs) ;
BOOL WINAPI SRSIsInit(LPSOSREND lprs) ;
BOOL WINAPI SRSIsOpen(LPSOSREND lprs) ;

LPRENDSERVER WINAPI SRSGetRendServer(LPSOSREND lprs) ;

BOOL WINAPI RSRecoverMsg (LPMESSAGESOS lpMsg) ;
UINT WINAPI RSCalculatePageCount(lpRSDeviceInfo_t lpinfo) ;

#endif

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _RENDSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\t30fail.h ===
/***************************************************************************
 Name     : T30FAIL.H
 Comment  : T30 Failure codes moved to a common place, to avoid duplication
    and inconsistency

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 11/01/94  arulm created
***************************************************************************/



typedef int T30FAILURECODE; // The #define's below

// t30

#define T30FAIL_NULL        0  // unknown or not-applicable
#define T30FAILS_SUCCESS    1  // Send completed successfully 
#define T30FAILSE_SUCCESS   2  // Send ECM completed successfully 
#define T30FAILR_SUCCESS    3  // Recv completed successfully 
#define T30FAILRE_SUCCESS   4  // Recv ECM completed successfully 
#define T30FAIL_SUCCESS     5  // compare code <= this value to tell fail vs success

#define T30FAILS_T1            6  // Send T1 timeout (No NSF/DIS Recvd)
#define T30FAILS_TCF_DCN       7  // Recvd DCN after TCF (weird...)
#define T30FAILS_3TCFS_NOREPLY 8  // No reply to 3 attempts at training (TCF)
#define T30FAILS_3TCFS_DISDTC  9  // Remote does not see our TCFs for some reason
#define T30FAILS_TCF_UNKNOWN   10 // Got garbage response to TCF

#define T30FAILS_SENDMODE_PHASEC     11 // Modem Error/Timeout at start of page
#define T30FAILS_MODEMSEND_PHASEC    12 // Modem Error/Timeout within page
#define T30FAILS_FREEBUF_PHASEC      13 // Error in Freebuf (must be a bug)
#define T30FAILS_MODEMSEND_ENDPHASEC 14 // Modem Error/Timeout at end of page

#define T30FAILSE_SENDMODE_PHASEC     15 // Modem Error/Timeout at start of ECM page
#define T30FAILSE_PHASEC_RETX_EOF     16 // Unexpected EOF when trying to retransmit (bug)
#define T30FAILSE_MODEMSEND_PHASEC    17 // Modem Error/Timeout within ECM page 
#define T30FAILSE_FREEBUF_PHASEC      18 // Error in IFBufFree (muts be a bug)
#define T30FAILSE_MODEMSEND_ENDPHASEC 19 // Modem Error/Timeout at end of ECM page
#define T30FAILSE_BADPPR              20 // Bad PPR recvd from Recvr (bug on recvr)

#define T30FAILS_3POSTPAGE_NOREPLY    21 // No response after page: Probably Recvr hungup during page transmit
#define T30FAILS_POSTPAGE_DCN         22  // Recvd DCN after page. (weird...)

#define T30FAILSE_3POSTPAGE_NOREPLY   23 // No response after page: Probably Recvr hungup during page transmit
#define T30FAILSE_POSTPAGE_DCN        24 // Recvd DCN after ECM page. (weird...)
#define T30FAILSE_POSTPAGE_UNKNOWN    25 // Recvd garbage after ECM page. 

#define T30FAILSE_RR_T5       26 // Recvr was not ready for more than 60secs during ECM flow-control
#define T30FAILSE_RR_DCN      27 // Recvd DCN after RR during ECM flow-control(weird...)
#define T30FAILSE_RR_3xT4     28 // No response from Recvr during ECM flow-control
#define T30FAILSE_CTC_3xT4    29 // No response from Recvr after CTC (ECM baud-rate fallback)
#define T30FAILSE_CTC_UNKNOWN 30 // Garbage response from Recvr after CTC (ECM baud-rate fallback)

#define T30FAIL_BUG0   31
#define T30FAILS_BUG1  32
#define T30FAILSE_BUG2 33
#define T30FAILR_BUG2  34

#define T30FAILR_PHASEB_DCN  35 // Recvr: Sender decided we're incompatible
#define T30FAILR_T1          36 // Recvr: Caller is not a fax machine or hung up

#define T30FAILR_UNKNOWN_DCN1     37 // Recvr: Recvd DCN when command was expected(1)
#define T30FAILR_T2               38 // Recvr: No command was recvd for 7 seconds
#define T30FAILR_UNKNOWN_DCN2     39 // Recvr: Recvd DCN when command was expected(2)
#define T30FAILR_UNKNOWN_UNKNOWN2 40 // Recvr: Recvd grabge when command was expected 

#define T30FAILR_MODEMRECV_PHASEC  41 // Recvr: Page not received, modem error or timeout at start of page
#define T30FAILRE_MODEMRECV_PHASEC 42 // Recvr: Data not received, modem error or timeout during page

#define T30FAILRE_PPS_RNR_LOOP  43 // Recvr: Timeout during ECM flow control after PPS (bug)
#define T30FAILRE_EOR_RNR_LOOP  44 // Recvr: Timeout during ECM flow control after EOR (bug)

// et30prot

#define T30FAIL_NODEA_UNKNOWN    45 // Sender: Garbage frames instead of DIS/DTC
#define T30FAILS_NODEA_NOWORK    46 // Sender: No work to do!! (bug)
 
#define T30FAILS_POSTPAGE_UNKNOWN  47 // Sender: Unknown response after page
#define T30FAILS_POSTPAGE_OVER     48 // Sender: Success!
#define T30FAILSE_ECM_NOPAGES      49 // Sender: ECM Success!
#define T30FAILS_4PPR_ERRORS       50 // Sender: Too many line errors in ECM mode

#define T30FAILS_FTT_FALLBACK   51 // Sender: Recvr doesn't like our training at all speeds
#define T30FAILS_RTN_FALLBACK   52 // Sender: Too many line errors in non-ECM mode even at 2400
#define T30FAILS_4PPR_FALLBACK  53 // Sender: Too many line errors in ECM mode even at 2400

#define T30FAILS_BUG3   54
#define T30FAILSE_BUG4  55
#define T30FAIL_BUG5    56
#define T30FAIL_BUG6    57
#define T30FAIL_BUG7    58
#define T30FAILR_BUG8   59
#define T30FAIL_BUG9    60

///////// The ones below are not used on IFAXen, only on PC platforms /////////
#define T30FAIL_IFAX_LAST    60

//icomfile

#define T30FAILS_NOTINITED      61 // Transport not inited (efaxpump bug)
#define T30FAILS_CASSENDFILE    62 // Error from CASSendFile
#define T30FAILS_MG3_NOFILE     63 // Negot Failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***
#define T30FAILS_NEGOT_ENCODING 64 // Negot Failed: Encoding mismatch
#define T30FAILS_NEGOT_A5A6     65 // Negot Failed: A5/A6 paper sizes not supported (efaxpump bug)
#define T30FAILS_NEGOT_WIDTH    66 // Negot Failed: Send image too wide *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_LENGTH   67 // Negot Failed: Send image too long    *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_RES      68 // Negot Failed: Resolution mismatch *** Resolution Not Supported ***

#define T30FAILS_EFX_BADFILE    69  // Bad EFX file
#define T30FAILS_IFX_BADFILE    70  // Bad IFX file
#define T30FAILS_MG3_BADFILE    71  // Bad MG3 file
#define T30FAILS_FILEOPEN       72  // Send File Open failed
#define T30FAILS_READFHB        73  // Read FHB failed
#define T30FAILS_BADFHB         74  // Bad FHB

#define T30FAILS_SEEK_HEADER      75 // Seek-to-next-header failed
#define T30FAILS_SEEK_STARTPAGE   76 // Seek-to-page-data failed
#define T30FAILS_SEEK_STARTBLOCK  77 // Seek-to-next-block failed
#define T30FAILS_SEEK_RETX        78 // Seek to block to be retransmitted failed
#define T30FAILS_FILEREAD         79 // File read (for data) failed

#define T30FAILR_NOTINITED     80 // Transport not inited (efaxpump bug)
#define T30FAILR_UNIQFILENAME  81 // Spool directory too full-cannot find uniq name for recv
#define T30FAILR_FILECREATE    82 // Recv File Create failed
#define T30FAILR_FILEWRITE     83 // Recvd file write failed

#define T30FAILS_SEC_FAXCODEC_INIT  84 // Could not init FaxCodec
#define T30FAILS_SEC_FAXCODEC_ERR   85 // FaxCodec returned error
#define T30FAILR_NAMEARRAY_OVF      86 // Too many receives--recvname array overflow

#define T30FAIL_ABORT   87    // User abort

#define T30FAILS_BUG11  88
#define T30FAILR_BUG11  89

// fcom

#define T30FAIL_OTHERCOMM2   90
#define T30FAIL_OTHERCOMM1   91
#define T30FAIL_OTHERCOMM    92
#define T30FAIL_FRAMING2     93
#define T30FAIL_FRAMING1     94
#define T30FAIL_FRAMING      95
#define T30FAIL_BUFOVER2     96
#define T30FAIL_BUFOVER1     97
#define T30FAIL_BUFOVER      98
#define T30FAIL_OVER2        99
#define T30FAIL_OVER1        100
#define T30FAIL_OVER         101

// These should be done away with .. (use T30_DIAL/ANSWER_FAIL instead).
#define T30FAILS_NCUDIAL_ERROR        102
#define T30FAILS_NCUDIAL_OK           103 // Should not happen!!!
#define T30FAILS_NCUDIAL_BUSY         104
#define T30FAILS_NCUDIAL_NOANSWER     105
#define T30FAILS_NCUDIAL_NODIALTONE   106

#define T30FAILR_NCUANSWER_ERROR      107
#define T30FAILR_NCUANSWER_OK         108 // Should not happen!!!
#define T30FAILR_NCUANSWER_NORING     109

#define T30FAILS_SECURITY_NEGOT       110 // Negot Failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***

// following as documented in netfax interface....
#define     T30FAILS_NEGOT_POLLING          135
#define     T30FAILS_NEGOT_POLLBYNAME       136
#define     T30FAILS_NEGOT_POLLBYRECIP      137
#define     T30FAILS_NEGOT_FILEPOLL         138

#define T30FAIL_LAST 138
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\root.h ===
// headers\et30type.h is assumed to be included
// ET30ACTION, ET30EVENT

// headers\timeouts.h ... TO
// headers\fr.h       ... IFR


#define  MODEM_CLASS1     1
#define  MODEM_CLASS2     2
#define  MODEM_CLASS2_0   3

typedef ET30ACTION ( __cdecl FAR* LPWHATNEXTPROC)(LPVOID, ET30EVENT, ...);


typedef struct {
        LPWHATNEXTPROC  lpfnWhatNext;
        HMODEM                  hModem;         // Modem driver handle
        HLINE                   hLine;          // NCU driver handle
} ET30PARAMS;


#define MAXRECVFRAMES   20

typedef struct {
        LPFR    rglpfr[MAXRECVFRAMES];
        BYTE    b[];
} FRAMESPACE, far* LPFRAMESPACE;


typedef struct {
        LPFRAMESPACE    lpfs;           // ptr to storage for recvd frames
        UWORD           Nframes;        // Number of recvd frames

        IFR             ifrCommand,
                        ifrResp,
                        ifrSend;
        USHORT          uTrainCount;

        USHORT          uRecvTCFMod;    // for fastexit stuff
        // set this from the DCS and jump straight into RecvTCF

        // Used to decide whether to insert a 1 bit or not (T30 sec 5.3.6.1)
        BOOL            fReceivedDIS;
        BOOL            fReceivedDTC;
        BOOL            fReceivedEOM;
        BOOL            fAtEndOfRecvPage;
        LONG            sRecvBufSize;
        TO              toT1;                   // This is used in MainBody.

#ifdef IFK
        TO              toBuf;                  // This is used to wait for a free buffer
#endif

        // INI file settings related stuff
        USHORT  uSkippedDIS;

        // flag to know when we are doing send-after-send, and so should use
        // SendSilence instead of RecvSilence. If we dont do this, we take
        // too long & Ricoh's protocol tester complains. This is 7071, 7100
        BOOL    fSendAfterSend;

        // Some modems can't train at higher speeds (timeout or return
        // ERRROR on AT+FRM=xxx) with other specific devices, but are OK at lower
        // speeds. So we keep track of the number of times we try to get the TCF,
        // and after the 2nd failed attempt, send an FTT instead of going to
        // node F.
#       define CLEAR_MISSED_TCFS() (pTG->T30.uMissedTCFs=0)
#       define MAX_MISSED_TCFS_BEFORE_FTT 2
        USHORT uMissedTCFs;

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

} ET30T30;



typedef struct {
        DWORD   dwPageSize;     // Size of current page in bytes
        USHORT  uFrameSize;
        USHORT  SendPageCount,
                SendBlockCount,
                SendFrameCount;
        USHORT  FramesSent;
        USHORT  uPPRCount;
        BOOL    fEndOfPage;
        TO      toT5;                   // Used in RR_RNRLoop().

        // Used for suppressing ST_FLAG in first PhaseC following
        // a CTC/CTR (for V.17)
        BOOL    fSentCTC;
        BOOL    fRecvdCTC;

        // Used in Recv
        IFR     ifrPrevCommand;
        BOOL    fRecvEndOfPage;
        BYTE    bRecvBadFrameMask[32];
        BYTE    bPrevPPS[4];
        IFR     ifrPrevResponse;
} ET30ECM;



typedef enum { modeNONE=0, modeNONECM, modeECM, modeECMRETX } PHASECMODE;

typedef struct {
        IFR             ifrLastSent;
        PHASECMODE      modePrevRecv;
        BOOL            fGotWrongMode;
} ET30ECHOPROTECT;














//
// headers\awnsfint.h is assumed to be included
// force include to class1\*.c

#pragma pack(1)         // ensure packed structure

typedef struct {
        BYTE    G1stuff         :3;
        BYTE    G2stuff         :5;

        BYTE    G3Tx            :1; // In DIS indicates poll doc avail. Must be 0 in DCS.
        BYTE    G3Rx            :1;     // Must set to 1 in BOTH DCS/DTC
        BYTE    Baud            :4;
        BYTE    ResFine_200     :1;
        BYTE    MR_2D           :1;

        BYTE    PageWidth       :2;
        BYTE    PageLength      :2;
        BYTE    MinScanCode     :3;
        BYTE    Extend24        :1;

        BYTE    Hand2400        :1;
        BYTE    Uncompressed    :1;
        BYTE    ECM                             :1;
        BYTE    SmallFrame              :1;
        BYTE    ELM                             :1;
        BYTE    Reserved1               :1;
        BYTE    MMR                             :1;
        BYTE    Extend32                :1;

        BYTE    WidthInvalid    :1;
        BYTE    Width2                  :4;
        // 1 == WidthA5_1216
        // 2 == WidthA6_864
        // 4 == WidthA5_1728
        // 8 == WidthA6_1728
        BYTE    Reserved2               :2;
        BYTE    Extend40                :1;

        BYTE    Res8x15                 :1;
        BYTE    Res_300                 :1;
        BYTE    Res16x15_400    :1;
        BYTE    ResInchBased    :1;
        BYTE    ResMetricBased  :1;
        BYTE    MinScanSuperHalf:1;
        BYTE    SEPcap                  :1;
        BYTE    Extend48                :1;

        BYTE    SUBcap                  :1;
        BYTE    PWDcap                  :1;
        BYTE    CanEmitDataFile :1;
        BYTE    Reserved3               :1;
        BYTE    BFTcap                  :1;
        BYTE    DTMcap                  :1;
        BYTE    EDIcap                  :1;
        BYTE    Extend56                :1;

        BYTE    BTMcap                  :1;
        BYTE    Reserved4               :1;
        BYTE    CanEmitCharFile :1;
        BYTE    CharMode                :1;
        BYTE    Reserved5               :3;
        BYTE    Extend64                :1;

} DIS, far* LPDIS, near* NPDIS;

#pragma pack()


#define MAXFRAMES       10
#define MAXSPACE        512

typedef struct
{
        USHORT  uNumFrames;
        USHORT  uFreeSpaceOff;
        LPFR    rglpfr[MAXFRAMES];
        BYTE    b[MAXSPACE];
}
RFS, near* NPRFS;


#define IDFIFSIZE       20    // from protocol\protocol.h

typedef struct {
        BOOL    fInUse;

        ////////////////////////// Client BC parameters
        BCwithTEXT      RecvCaps;                       // ==> NSF/DIS recved
        DWORD           RecvCapsGuard;
        BCwithTEXT      RecvParams;                     // ==> NSS/DCS recvd
        DWORD           RecvParamsGuard;
        BCwithPOLL      RecvPollReq;            // ==> NSC/DTC recvd
        DWORD           RecvPollReqGuard;

        BCwithTEXT      SendCaps;                       // ==> NSF/DIS sent
        DWORD           SendCapsGuard;
        BCwithTEXT      SendParams;                     // ==> NSS/DCS sent
        DWORD           SendParamsGuard;
        BCwithPOLL      SendPollReq;            // ==> NSC/DTC sent
        DWORD           SendPollReqGuard;

        // LPBC lpbcSendCaps;                   // ==> NSF/DIS sent
        // LPBC lpbcSendParams;                 // ==> NSS/DCS sent
        // LPBC lpbcSendPollReq;                // ==> NSC/DTC sent

        BOOL    fRecvCapsGot;
        BOOL    fSendCapsInited;
        BOOL    fSendParamsInited;
        BOOL    fRecvParamsGot;
        BOOL    fRecvPollReqGot;
        BOOL    fSendPollReqInited;

        ////////////////////////// Hardware parameters
        LLPARAMS        llRecvCaps;             // DIS recvd
        LLPARAMS        llSendCaps;             // DIS sent---use uRecvSpeeds
        LLPARAMS        llSendParams;   // used to negotiate DCS--use uSendSpeeds
        LLPARAMS        llNegot;                // DCS sent
        LLPARAMS        llRecvParams;   // recvd DCS

        BOOL            fllRecvCapsGot;
        BOOL            fllSendCapsInited;
        BOOL            fllSendParamsInited;
        BOOL            fllNegotiated;
        BOOL            fllRecvParamsGot;

        BOOL    fHWCapsInited;

        USHORT  HighestSendSpeed;
        USHORT  LowestSendSpeed;

        ////////////////////////// Flags to make decisions with
        // BYTE NextSend;
        // BOOL fSendingECM;
        // BOOL fReceivingECM;
        BOOL    fPageOK;
        BOOL    fAbort;

        ////////////////////////// Current Send/Recv params (to return on ExtFunc)
        // USHORT       uCurRecvBaud;
        // USHORT       uMinBytesPerLine;
        // USHORT       uCurECMFrameSize;
        // USHORT       uRecvECMFrameSize;
        USHORT  uFramesInThisBlock;


        ///////////////////////// NSF/NSC/NSS Received Frames
        RFS             RecvdNS;

        ///////////////////////// CSI/TSI/CIG Received Frames
        BOOL    fRecvdID;
        BYTE    bRemoteID[IDFIFSIZE+1];

        ///////////////////////// DIS Received Frames
        DIS     RemoteDIS;
        USHORT  uRemoteDISlen;
        BOOL    fRecvdDIS;

        ///////////////////////// DIS Send Frames (We need so we can check the DIS we send as receiver against DCS)
        DIS     LocalDIS;
        USHORT  uLocalDISlen;
        BOOL    fLocalDIS;

        ///////////////////////// DTC Received Frames
        DIS     RemoteDTC;
        USHORT  uRemoteDTClen;
        BOOL    fRecvdDTC;

        ///////////////////////// DCS Received Frames
        DIS     RemoteDCS;
        USHORT  uRemoteDCSlen;
        BOOL    fRecvdDCS;

        ///////////////////////// ECM Received Frames
        BYTE    bRemotePPR[32];
        BOOL    fRecvdPPR;
        BYTE    bRemotePPS[4];  // only 3 bytes, but use 4 so we can cast to DWORD
        BOOL    fRecvdPPS;

        ///////////////////////// SUB (subaddress) Received Frames
        BOOL    fRecvdSUB;
        BYTE    bRecipSubAddr[IDFIFSIZE+1];

}
PROT, near* NPPROT;




//
// protapi.h  includes protparm.h
// which defines PROTPARAMS
//


typedef struct
{
        USHORT  uSize;
        SHORT   Class;
        SHORT   PreambleFlags,
                InterframeFlags,
                ClosingFlags;
}
MODEMPARAMS, far* LPMODEMPARAMS;









#define COMMANDBUFSIZE  40


typedef struct {
        // TO           toDialog, toZero;
        TO              toRecv;
        // BYTE bLastReply[REPLYBUFSIZE+1];

        BYTE    bCmdBuf[COMMANDBUFSIZE];
        USHORT  uCmdLen;
        BOOL    fHDLC;
        USHORT  CurMod;
        enum    {SEND, RECV, IDLE } DriverMode;
        enum    {COMMAND, FRH, FTH, FTM, FRM} ModemMode;
        BOOL    fRecvNotStarted;
        // SHORT        sRecvBufSize;

        HWND    hwndNotify;
        BOOL    fSendSWFraming;
        BOOL    fRecvSWFraming;

        enum {RECV_FCS_DUNNO=0, RECV_FCS_NO, RECV_FCS_CHK, RECV_FCS_NOCHK} eRecvFCS;
                // Whether this modem appends FCS on HDLC recv.
                // Modems with AT&T bug don't append FCS.
                // Currently we determine this at run time.

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

} CLASS1_MODEM;




typedef struct {
        // BYTE fModemInit              :1;             // Reset & synced up with modem
        // BYTE fOffHook                :1;             // Online (either dialled or answered)
        USHORT  ifrHint;                                // current hint
        // BOOL fNCUAbort;                              // When set, means Abort Dial/Answer
} CLASS1_STATUS;




typedef struct
{
        USHORT  uComPort;
        BOOL    fLineInUse;
        BOOL    fModemOpen;
        BOOL    fNCUModemLinked;
}
CLASS1_DDI;


















#define OVBUFSIZE 4096

typedef struct
{
        enum {eDEINIT, eFREE, eALLOC, eIO_PENDING} eState;
        OVERLAPPED ov;
        char rgby[OVBUFSIZE];   // Buffer associated with this overlapped struct.
        DWORD dwcb;                             // Current count of data in this buffer.
} OVREC;

typedef struct
{
        // Timeouts
        DWORD dwTOOutShortInactivity;
        DWORD dwTOOutLongInactivity;
        DWORD dwTOOutShortDeadComm;
        DWORD dwTOOutLongDeadComm;
        DWORD dwTOInOneChar;

} FCOMSETTINGS, FAR * LPFCOMSETTINGS;

typedef struct {
        LONG_PTR             nCid;           // _must_ be 32bits in WIN32 (has to hold a HANDLE) -- AJR 12/16/97, change to LONG_PTR for 64 bits
        int                 CommErr;        // _must_ be 32bits in WIN32
        UWORD   cbInSize;
        UWORD   cbOutSize;
        DCB             dcb;
#ifdef METAPORT
        DCB             dcbOrig;
        BOOL    fExternalHandle;
        BOOL    fStateChanged;
#endif
        COMSTAT comstat;
        BYTE    bDontYield;             // Was a BOOL, now a counter.
#ifdef NTF
        HWND    hwndNotify;             // can use this for timer msgs
#endif
#ifdef WFWBG
        BOOL    fBG;
#endif
        TO              toCommDead, toOnechar, toDrain;
        USHORT  uInterruptOverunCount;
        USHORT  uBufferOverflowCount;
        USHORT  uFramingBreakErrorCount;
        USHORT  uOtherErrorCount;
        BOOL    fCommOpen;

        FCOMSETTINGS CurSettings;

#ifdef WIN32

#       define NUM_OVS 2  // Need atleast 2 to get true overlaped I/O

        // We maintain a queue of overlapped structures, having upto
        // NUM_OVS overlapped writes pending. If NUM_OVS writes are pending,
        // we do a GetOverlappedResult(fWait=TRUE) on the earliest write, and
        // then reuse that structure...

        OVERLAPPED ovAux;       // For ReadFile and WriteFile(MyWriteComm only).

        OVREC rgovr[NUM_OVS]; // For WriteFile
        UINT uovFirst;
        UINT uovLast;
        UINT covAlloced;
        BOOL fDoOverlapped;
        BOOL fovInited;

        OVREC *lpovrCur;

#endif // WIN32

#ifdef ADAPTIVE_ANSWER
        BYTE fEnableHandoff:1;  // True if we are to enable adaptive answer
        BYTE fDataCall:1;               // True if a data call is active.
#endif // ADAPTIVE_ANSWER

} FCOM_COMM;







//
// NCUPARAMS is defined in headers\ncuparm.h, included by .\modemddi.h
// we will force define modemddi.h
//






#define REPLYBUFSIZE    400
#define MAXKEYSIZE              128



typedef struct {
        BYTE    fModemInit              :1;             // Reset & synced up with modem
        BYTE    fOffHook                :1;             // Online (either dialled or answered)
        BOOL    fInDial, fInAnswer, fInDialog;
} FCOM_STATUS;


typedef struct {
        DWORD dwDialCaps;       // One of the LINEDEVCAPSFLAGS_* defined in filet30.h
                                                // (and also in tapi.h)
} MODEMEXTCAPS, FAR *LPMODEMEXTCAPS;



typedef struct {
        BYTE    bLastReply[REPLYBUFSIZE+1];

#ifdef ADAPTIVE_ANSWER
        BYTE    bEntireReply[REPLYBUFSIZE+1]; // Used only for storing
#endif // ADAPTIVE_ANSWER

        TO              toDialog, toZero;
        CMDTAB          CurrCmdTab;
        MODEMCAPS       CurrMdmCaps;
        MODEMEXTCAPS CurrMdmExtCaps;

        // Following point to the location of the profile information.
#       define MAXKEYSIZE 128
        DWORD   dwProfileID;
        char    rgchKey[MAXKEYSIZE];
        char    rgchOEMKey[MAXKEYSIZE];


} FCOM_MODEM;




// Inst from fxrn\efaxrun.h

typedef enum { IDLE1, BEFORE_ANSWER, BEFORE_RECVCAPS, SENDDATA_PHASE,
                                SENDDATA_BETWEENPAGES, /** BEFORE_HANGUP, BEFORE_ACCEPT, **/
                                BEFORE_RECVPARAMS, RECVDATA_PHASE, RECVDATA_BETWEENPAGES,
                                SEND_PENDING } STATE;

#define MAXRECV                 50
#define FILENAMESIZE    15
#define PHONENUMSIZE    60
#define PATHSIZE                150
#define MAXUSERATCMDLEN 80
#define MAXSECTIONLENGTH 80

typedef struct
{
        USHORT  uNumPages;      // keep a running tally as we process the file
        USHORT  vMsgProtocol;
        USHORT  vSecurity;
        USHORT  Encoding;
#ifdef COMPRESS
        USHORT  vMsgCompress;
#endif
        DWORD   AwRes;
        USHORT  PageWidth;
        USHORT  PageLength;
        USHORT  fLin;
        USHORT  fLastPage;

        DWORD   lNextHeaderOffset;
        DWORD   lDataOffset;
        DWORD   lDataSize;

        enum    {
                                RFS_DEINIT=0,   // Either before WriteFileHeader or after WriteFileEnder
                                RFS_INIT,               // After file opened, but before first StartWritePage
                                RFS_INSIDE_PAGE,        // We've called StartWritePage but not EndWritePage
                                RFS_AFTER_PAGE  // After EndWritePage
                        } erfs; // Receive File State

        char    szID[MAXFHBIDLEN + 2];
}
AWFILEINFO, FAR* LPAWFI;

#define MAX_REMOTE_MACHINECAPS_SIZE 256
typedef struct {
        BOOL            fInited;
        BOOL            fAbort;
        BOOL            fExternalHandle; // TRUE iff the comm port handle was
                                                                 // supplied from outside.
        // BOOL         fDiskError;
        // BOOL         fInternalError;
        // BOOL         fRinging;
        STATE           state;
        HWND            hwndSend;
        HWND            hwndRecv;
        HWND            hwndListen;
        USHORT          uRingMessage; // message to post on RING
        HWND            hwndStatus;
        DWORD           dwLineID;
        USHORT          usLineIDType;
        USHORT          uModemClass;
        LONG            sSendBufSize;
        USHORT          uSendDataSize;
        BOOL            fSendPad;
        BYTE            szFaxDir[PATHSIZE + FILENAMESIZE + 1];  // add space to zap in file names
        USHORT          cbFaxDir;
        ATOM            aPhone;
        ATOM            aCapsPhone; // Phone number be used for storing capabilities..
                                                        // Typically in canonical form...
        char            szPath[PATHSIZE + FILENAMESIZE + 1];
        char            szFile[FILENAMESIZE];
        HFILE           hfileMG3, hfileEFX, hfileIFX;
        BOOL            fReceiving;
        BOOL            fSending;

#define MAXRECIPNAMELEN 128
#define MAXSUBJECTLEN   40
#define MAXSENDERLEN  40

        // default RecipName
        BYTE            szDefRecipName[MAXRECIPNAMELEN + 2];
        BYTE            szDefRecipAddr[MAXRECIPNAMELEN + 2];
        BYTE            szDefSubject[MAXSUBJECTLEN + 2];
        BYTE            szNamedSubject[MAXSUBJECTLEN + 2];
        BYTE            szDefSender[MAXSENDERLEN + 2];
        BYTE            szLocalID[MAXRECIPNAMELEN + 2];

        AWFILEINFO      awfi;

        long            cbPage;
        // long         cbPageStart;
        long            cbBlockStart;   // file ptr to start of block
        long            cbBlockSize;    // size of block so far
        HANDLE          hfile;

        BCwithTEXT      SendCaps;
        BCwithTEXT      RemoteRecvCaps;
        BCwithTEXT      SendParams;
        BCwithTEXT      RecvParams;
        //BC                      RemoteRecvCaps;
        //BC                      SendParams;
        //BC                      RecvParams;

        USHORT          uPageAcks;
        USHORT          HorizScaling, VertScaling;
        USHORT          HorizScaling300dpi, VertScaling300dpi;
        NCUPARAMS       NcuParams;
        MODEMPARAMS     ModemParams;    // added in the add-class0 hack
        // HMODEM               hModem;
        // HLINE                hLine;
        PROTPARAMS      ProtParams;
        DWORD           FixSerialSpeed;
        // replaced by ProtParams
        // USHORT               HighestSendSpeed, LowestSendSpeed;
        // BOOL         fEnableV17Send, fEnableV17Recv;
        // BOOL         fDisableECM;
        // BOOL         f64ByteECM;
        BOOL            fDisableG3ECM; // If TRUE, will disable *sending* of MMR
                                                           //   (so we don't use ECM when sending to
                                                           //    fax machines).
        BOOL            fDisableSECtoMR; // If TRUE, we won't try to translate
        BOOL            fDisableMRRecv; // If TRUE, we won't advertise ability
                                                                // to receive MR..
        USHORT          uCopyQualityCheckLevel;
        BYTE            szWindowsDir[PATHSIZE + FILENAMESIZE + 1];      // add space to zap in DLL names
        USHORT          cbWindowsDir;
        BOOL            fProtInited;    // for cleanups
#ifdef TSK
        ATOM            aFileMG3, aFileIFX,     aFileEFX;
#endif //TSK
        USHORT          uRecvPageAck;
        USHORT          uNumBadPages;
#ifdef CHK
        BOOL            fRecvChecking;
#endif //CHK
#ifdef SEC
        BOOL            fSendRecoding;
        LPBUFFER        lpbfPrev;
        BOOL            fPassedEOP;
#endif //SEC

// Failure Codes

        USHORT          uFirstFailureCode;
        USHORT          uLastFailureCode;
        BOOL            fLogFailureCode; // write failures to efaxtrans.log
        HFILE           hfileFailureLog;

// Prevent re-entry in FreeOrGetDll + ProcessANswerModeReturn loop
// Re-entry can only happen inside the dialog box so we don't need
// an atomic test-and-set. See bug#1181

        BOOL            fChangingAnswerMode;

// If PostMessage of vital messages (i.e. FILET30DONE only) fails
// (which can happen if the msg queue is full), then try to post
// it again later. See bug#1276

        MSG                     PostMsg;
        DWORD   dwProfileID;
        char    rgchSection[MAXSECTIONLENGTH];

        BOOL    fInPollReq;
#ifdef POLLREQ
        USHORT  PollType;
        BOOL    fPollNoSupportErr;
        char    szDocName[MAXTOTALIDLEN+3];
        char    szPassword[MAXTOTALIDLEN+3];
        BCwithPOLL      SendPollReq;
#endif

#ifdef COMPRESS
        BOOL            fDisableCmprsSend;  // If true, we don't create compressed fls.
        BOOL            fDisableCmprsRecv;  // If true, we don't say we support cmprs.
        HFILE           hfileEFXCmprs;          // Handle of internally generated compressed
                                                // file. This file is opened in  OpenSendFiles (fileio.c).
                                                // and closed  on error (ErrCleanup, init.c)
                                                // or when the call is complete (EndOfCall, init.c)
                                                // From both places, I call the function
                                                // DeleteCompressedFile, fileio.c
        BOOL            fCreatedEFXCmprs;       // True if we've created this file.
        char            szEFXCmprsFile[MAX_PATH]; // full path name
#endif

        BOOL fReinitClass2;                             // Set in FileT30Init, used and cleared
                                                                        // in bgt30.c (call to lpfnClass2Calle[er].

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

#ifdef USECAPI
        BYTE bRemoteMachineCapsData[MAX_REMOTE_MACHINECAPS_SIZE];
#else // !USECAPI
        BYTE            szTextCaps[TEXTCAPSSIZE];
#endif // !USECAPI
}
INSTDATA, *PINSTDATA;



//memory management
#define STATICBUFSIZE   (MY_BIGBUF_ACTUALSIZE * 2)
#define STATICBUFCOUNT  2




typedef struct {
        HANDLE  hComm;
        CHAR    szDeviceName[1];
} DEVICEID, FAR * LPDEVICEID;

// Device Setting Information BrianL 10/29/96
//
typedef struct  tagDEVCFGHDR  {
    DWORD       dwSize;
    DWORD       dwVersion;
    DWORD       fdwSettings;
}   DEVCFGHDR;


typedef struct  tagDEVCFG  {
    DEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
}   DEVCFG, *PDEVCFG, FAR* LPDEVCFG;



#define IDVARSTRINGSIZE    (sizeof(VARSTRING)+128)
#define ASYNC_TIMEOUT         120000L
#define ASYNC_SHORT_TIMEOUT    20000L
#define BAD_HANDLE(h) (!(h) || (h)==INVALID_HANDLE_VALUE)


// ASCII stuff

typedef struct _FAX_RECEIVE_A {
    DWORD   SizeOfStruct;
    LPSTR  FileName;
    LPSTR  ReceiverName;
    LPSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE_A, *PFAX_RECEIVE_A;


typedef struct _FAX_SEND_A {
    DWORD   SizeOfStruct;
    LPSTR  FileName;
    LPSTR  CallerName;
    LPSTR  CallerNumber;
    LPSTR  ReceiverName;
    LPSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_SEND_A, *PFAX_SEND_A;


typedef struct _COMM_CACHE {
    DWORD  dwMaxSize;
    DWORD  dwCurrentSize;
    DWORD  dwOffset;
    DWORD  fReuse;
    char   lpBuffer[4096];
}  COMM_CACHE;


typedef struct {
        // BYTE fStuffZERO              :1;     // not used. Just set cbLineMin instead
        UWORD   cbLineMin;

        // Output filtering (DLE stuffing and ZERO stuffing only)
        // All inited in FComOutFilterInit()
        LPB             lpbFilterBuf;
        UWORD   cbLineCount;                    // Has to be 16 bits
        BYTE    bLastOutByte;                   // Stuff: last byte of previous input buffer

        // Input filtering (DLE stripping) only.
        // All inited in FComInFilterInit()
        BYTE    fGotDLEETX              :1;
        BYTE    bPrevIn;                // Strip::last byte of prev buffer was DLE
        UWORD   cbPost;
#define POSTBUFSIZE     20
        BYTE    rgbPost[POSTBUFSIZE+1];

} FCOM_FILTER;


typedef struct {
        BYTE    carry;
        BYTE    dec_width;
        BYTE    len;
        enum    { NORMAL=0, FLAG=1, ABORT=2 } flagabort;
} DECODESTATE, far* LPDECODESTATE;


typedef struct {
        BYTE    carry;
        BYTE    enc_width;
        BYTE    len;
} ENCODESTATE, far* LPENCODESTATE;



typedef struct {
        // BOOL fFrameSend;
        // BOOL fFrameRecv;

        // Used by both encode and decode, so can't be
        // both on at the same time
        LPB                     lpbBuf;
        USHORT          cbBufSize;

        // Output framing
        // All inited in FramingSendSetup()
        ENCODESTATE EncodeState;

        // Input frame decoding
        // All inited in FramingRecvSetup()
        DECODESTATE DecodeState;
        USHORT          cbBufCount;             // data count in buf
        LPB                     lpbBufSrc;              // start of data in buf
        SWORD           swEOF;
} COMMODEM_FRAMING;


#define MAXDUMPFRAMES   100
#define MAXDUMPSPACE    400

typedef struct
{
        USHORT  uNumFrames;
        USHORT  uFreeSpaceOff;
        USHORT  uFrameOff[MAXDUMPFRAMES];       // arrays of offsets to frames
        BYTE    b[MAXDUMPSPACE];
} PROTDUMP, FAR* LPPROTDUMP;


typedef struct {
    DWORD      fAvail;
    DWORD      ThreadId;
    HANDLE     FaxHandle;
    LPVOID     pTG;
    HLINE      LineHandle;
    HCALL      CallHandle;
    DWORD      DeviceId;
    HANDLE     CompletionPortHandle;
    ULONG_PTR   CompletionKey;
    DWORD      TiffThreadId;
    DWORD      TimeStart;
    DWORD      TimeUpdated;
    DWORD      CkSum;
} T30_RECOVERY_GLOB;


typedef struct {
    DWORD dwContents;   // Set to 1 (indicates containing key)
    DWORD dwKeyOffset;  // Offset to key from start of this struct.
                        // (not from start of LINEDEVCAPS ).
                        //  8 in our case.
    BYTE rgby[1];       // place containing null-terminated
                        // registry key.
} MDM_DEVSPEC, FAR * LPMDM_DEVSPEC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\t30gl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30.h

Abstract:

    Globals for t30.dll

Author:

    Rafael Lisitsa (RafaelL) 12-Feb-1996


Revision History:

--*/

#ifndef _T30_GLOBALS_
#define _T30_GLOBALS_

#include <faxext.h>

#ifdef DEFINE_T30_GLOBALS
    #define DEFINE_T30_EXTERNAL
#else
    #define DEFINE_T30_EXTERNAL   extern
#endif



// DLL global data

#define STATUS_FAIL   0
#define STATUS_OK     1

typedef struct {
    HLINEAPP   LineAppHandle;
    HANDLE     HeapHandle;
    int        fInit;
    int        CntConnect;
    int        Status;
    int        DbgLevel;
    int        T4LogLevel;
    int        MaxErrorLinesPerPage;
    int        MaxConsecErrorLinesPerPage;
    char       TmpDirectory[_MAX_FNAME - 15];
    DWORD      dwLengthTmpDirectory;
} T30_DLL_GLOB;

DEFINE_T30_EXTERNAL  T30_DLL_GLOB  gT30;

DEFINE_T30_EXTERNAL  CRITICAL_SECTION  T30CritSection;
DEFINE_T30_EXTERNAL  BOOL              T30CritSectionInit;

// This struct define the behavior of re-transmittion in case of RTN (ReTrain-Negative)
typedef struct {
    DWORD RetriesBeforeDropSpeed; // Number of Re-transmittion retries before we start drop speed (recommendation: 1)
    DWORD RetriesBeforeDCN;       // Number of Re-transmittion retries before we do DCN (recommendation: 3)
} RTNRetries;

#define DEF_RetriesBeforeDropSpeed 1
#define DEF_RetriesBeforeDCN 3

DEFINE_T30_EXTERNAL RTNRetries gRTNRetries; // This struct will get values from the registry

// Per job/thread global data.
#define MAX_T30_CONNECT     100

typedef struct {
    LPVOID    pT30;
    int       fAvail;
} T30_TABLE;

DEFINE_T30_EXTERNAL  T30_TABLE  T30Inst[MAX_T30_CONNECT];


// T30 Recovery per job/thread global data.


DEFINE_T30_EXTERNAL  T30_RECOVERY_GLOB  T30Recovery[MAX_T30_CONNECT];

DEFINE_T30_EXTERNAL  CRITICAL_SECTION  T30RecoveryCritSection;
DEFINE_T30_EXTERNAL  BOOL              T30RecoveryCritSectionInit;

//
// Run-Time global flag controlling Exception Handling
//

DEFINE_T30_EXTERNAL DWORD glT30Safe;

//
// Extension configuration mechanism callbacks
//

DEFINE_T30_EXTERNAL PFAX_EXT_FREE_BUFFER g_pfFaxExtFreeBuffer;
DEFINE_T30_EXTERNAL PFAX_EXT_GET_DATA g_pfFaxGetExtensionData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\awnsf.c ===
/***************************************************************************
        Name      :     BCNSF.C
        Comment   :     Routines for encoding/encrypting and decoding/decrypting
                                NSF/NSC/NSS frames

         Copyright (c) 1993 Microsoft Corp.
         This source code is absolutely confidential, and cannot be viewed
         by anyone outside Microsoft (even under NDA) without specific
         written permission.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#ifdef PUREDATA
#include <memory.h>
#include <string.h>
#define PORTABLE
#define EXTERNAL
#define NOGETTICK
#endif

#ifndef PORTABLE
#       include "defs.h"
#       include <ifaxos.h>
#       include "tipes.h"
#       define MODID                    MODID_AWNSF
#       define FILEID                   1
#else
#ifdef DEBUG
#       include <assert.h>
#       include <string.h>
#endif
#       define  _export
#       define  FALSE                           0
#       define  TRUE                            1
#       define  min(a,b)            (((a) < (b)) ? (a) : (b))
#       define _fmemset         memset
#       define _fmemcpy         memcpy
#       define _fstrlen         strlen
#       define _fmemcmp         memcmp
#endif

#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"
#include "nsfmacro.h"
///RSL
#include "glbproto.h"

#ifdef NOCHALL
#define bChallResp              bPass
#define wChallRespLen           wPassLen
#endif

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/

/* #define DEBUG2 */
/* #define DEBUG3 */

typedef char FAR*       LPSTR;
typedef unsigned long   ULONG;

void DebugPrintBytes(LPSTR lpstr, LPBYTE lpb, USHORT cb, BOOL f);
LPBYTE Permute(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cb, BOOL fReverse);
USHORT ParseNSx(PThrdGlbl pTG, LPBYTE lpb, USHORT uLen, LPBC lpbcOut, USHORT uMaxSize);

BOOL EXPORTAWBC IsAtWorkNSx( LPBYTE lpb, WORD wSize)
{
    DEBUG_FUNCTION_NAME(_T("IsAtWorkNSx"));
    Assert((GRPSIZE_STD==sizeof(BCSTD)) &&
           (GRPSIZE_FAX==sizeof(BCFAX)) &&
           (GRPSIZE_NSS==sizeof(BCNSS)) &&
           (GRPSIZE_IMAGE==sizeof(BCIMAGE))    &&
           (GRPSIZE_POLLCAPS==sizeof(BCPOLLCAPS)));

        /* this should be tautological */
#ifdef DEBUG
#ifdef PORTABLE
    
    Assert(BC_SIZE == (sizeof(BCwithHUGE)-BCEXTRA_HUGE-4));
    DebugPrintEx(   DEBUG_MSG,
                    "BC_SIZE=%d  actual=%d\r",
                    BC_SIZE,
                    sizeof(BCwithHUGE)-BCEXTRA_HUGE-4);
#else

    Assert(BC_SIZE == sizeof(BC));
    DebugPrintEx(   DEBUG_MSG,
                    "BC_SIZE=%d sizeof(BC)=%d\r\n",
                    BC_SIZE, sizeof(BC));
#endif /* PORTABLE */
#endif /* DEBUG */

    if( (wSize > 3) && (wSize < MAXNSFFRAMESIZE) &&
            (lpb[0]==SIG_USA) &&
            (lpb[1]==SIG_ATWORK1) &&
            (lpb[2]==SIG_ATWORK2) )
    {
        return TRUE;
    }
    else
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Non-Microsoft At Work NSx l=%d (%02x %02x %02x)\r",
                        wSize, lpb[0], lpb[1], lpb[2]);
        return FALSE;
    }
}

WORD EXPORTBC NSxtoBC
(   PThrdGlbl pTG, 
    IFR ifr,
    LPLPFR rglpfr,
    WORD wNumFrame,
    LPBC lpbcOut, 
    WORD wBCSize
)
{
    BYTE    bSalt[3];
    BOOL    fGotSalt;
    WORD    wRet = AWERROR_NOTAWFRAME;
    USHORT  iFrame;
    BOOL       fStripFCS = TRUE;

    DEBUG_FUNCTION_NAME(_T("NSxtoBC"));

    Assert(ifr==ifrNSF || ifr==ifrNSS || ifr==ifrNSC);

tryagain:

    fGotSalt = FALSE;

    /* zero out BC, but _not_ header parts */
    _fmemset(&(lpbcOut->Std),
             0,
             BC_SIZE - (ULONG)(((LPBYTE)(&(lpbcOut->Std))) - ((LPBYTE)lpbcOut)));
    lpbcOut->wTotalSize = BC_SIZE;
    fGotSalt = FALSE;

    for(iFrame=0; iFrame<wNumFrame; iFrame++)
    {
        LPBYTE  lpbIn;
        USHORT  uLen;
        LPBYTE  lpbTemp;

        lpbIn = rglpfr[iFrame]->fif;
        if (fStripFCS)
        {
            if (rglpfr[iFrame]->cb >= 5 ) 
            {
                      uLen  = rglpfr[iFrame]->cb - 2;     /* Subtract 2 to lop off the FCS */
            }
            else
            {                                                         /* Must not have the FCS */
                fStripFCS = FALSE;
                DebugPrintEx(   DEBUG_WRN,
                                "NSx frame too short, trying again"
                                " without stripping FCS");
                goto tryagain;
            }
        }
        else
        {
            uLen  = rglpfr[iFrame]->cb;
        }

        if (!IsAtWorkNSx(lpbIn, uLen))
        {
            DebugPrintEx(DEBUG_WRN,"skipping non-MAW-NSx frame (%d)", iFrame);
            DebugPrintBytes("SkippedFrame", lpbIn, uLen, 0);
            goto skipframe;
        }
        else
        {
            USHORT  uRet1;

            DebugPrintBytes("BytesRecvd", lpbIn, uLen, 0);
            Assert(uLen > 3);
            uLen -= 3;
            lpbIn += 3;

            /** unswap salt/data bytes around (except the NSF signature) **/
            lpbTemp = Permute(pTG, lpbIn, uLen, TRUE);

            DebugPrintBytes("AfterPermute", lpbTemp, uLen, 0);

            if(!fGotSalt)
            {
                Assert(wRet == AWERROR_NOTAWFRAME);     /* not yet parsed a frame */
                /* Snowball can't handle NSF frames longer than 38 bytes */
                Assert((ifr==ifrNSF) ? (uLen <= (MAXFIRSTNSFSIZE-3)) : TRUE);

                if(uLen < 3)
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "skipping too-short MAW frame"
                                    " (%d) len=%d", iFrame, uLen);
                    goto skipframe;
                }
                _fmemcpy(bSalt, lpbTemp, 3);
                lpbTemp += 3;
                uLen -= 3;
                fGotSalt = TRUE;
            }

            DebugPrintBytes("AfterDecrypt", lpbTemp, uLen, 0);

            if((uRet1=ParseNSx(pTG, lpbTemp, uLen, lpbcOut, wBCSize))==0xFFFF)
            {
                /* Some modems don't send the FCS,*/
                /* so if we fail, try again without lopping off the FCS */
                if ((fStripFCS) && (iFrame==0)) 
                {
                   fStripFCS = FALSE;
                   DebugPrintEx(    DEBUG_WRN,
                                    "Failed to parse NSx frame, trying again"
                                    " without stripping FCS");
                   goto tryagain;
                }
                else 
                {
                   DebugPrintEx(    DEBUG_ERR,
                                    "Failed to parse NSx frame (%d)",
                                    iFrame);
                   goto skipframe;
                }
            }
            else
            {
                wRet = AWERROR_OK;
                DebugPrintEx(   DEBUG_MSG,
                                "Parsed NSx frame (%d) skipped %d",
                                iFrame, uRet1);
            }
        }
 skipframe:
                ;
    }
    return wRet;
}

        /** returns 0xFFFF on failure and 0 or +ve number == total number
                of bytes skipped in "not understood" or "no-space" groups. **/
USHORT ParseNSx(PThrdGlbl pTG, LPBYTE lpb, USHORT uLen, LPBC lpbcOut, USHORT uMaxSize)
{
        USHORT  uGroupLength;
        USHORT  uRet, uLenOriginal;

        DEBUG_FUNCTION_NAME(_T("ParseNSx"));

        Assert(uMaxSize >= BC_SIZE);

        /*** Don't zero BC here! This can be called multiple times to decode
                 multiple NSx frames into a single BC structure! **/

        uRet = 0;
        uLenOriginal = uLen;

        // RSL
        return (uRet);

        // I've deleted the whole bosy here, since it was never accessed (MoolyB 15/6/00)
}

USHORT AddGroupToFrame(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cbIn, LPBYTE lpbOut, USHORT cbOut)
{
    USHORT uGroupNum, uGroupLength, cbCopy;

    DEBUG_FUNCTION_NAME(_T("AddGroupToFrame"));

    Assert(cbIn>=2 && cbIn<64);
    Assert(cbOut >= 2);

    uGroupNum = GroupNum(lpbIn);
    uGroupLength = GroupLength(lpbIn);

    DebugPrintEx(   DEBUG_MSG,
                    "cbIn=%d cbOut=%d grplen=%d",
                    cbIn, cbOut, uGroupLength);

    if( uGroupNum >= GROUPNUM_FIRST &&
            uGroupNum <= GROUPNUM_LAST
            && uGroupLength && cbIn>=2 && cbIn<64 && cbOut>=2)
    {
        Assert(uGroupLength <= cbIn);
        cbIn = min(uGroupLength, cbIn);

        if(uGroupNum != GROUPNUM_MACHINEID && uGroupNum != GROUPNUM_POLLREQ)
        {
            /** find last non-zero byte **/
            for( ;cbIn>2 && lpbIn[cbIn-1]==0; cbIn--);

            Assert(cbIn==2 || lpbIn[cbIn-1]!=0);

            if(cbIn==2 && (lpbIn[1] == (lpbIn[1] & 0x07)))
            {
                DebugPrintEx(   DEBUG_MSG,
                                "Found Group (%d %d) only 11bits long."
                                " Not sending",
                                lpbIn[0], lpbIn[1]);
                return 0;
            }
        }
        Assert(cbIn>=2 && cbIn<=63);
        cbCopy = min(cbIn, cbOut);
        _fmemcpy(lpbOut, lpbIn, cbCopy);
        SetGroupLength(lpbOut, cbCopy);  /** set GroupLength correctly  **/
        DebugPrintEx(   DEBUG_MSG,
                        "Encoded grp=%d len=%d",
                        GroupNum(lpbOut), GroupLength(lpbOut));
        return cbCopy;
    }
    Assert(uGroupNum == 0);
    Assert(uGroupLength == 0);
    return 0;
}

USHORT AddIdGroupToFrame(PThrdGlbl pTG, USHORT uGroupNum, USHORT cbIn, USHORT uTextEncoding, LPBYTE lpbIn, LPBYTE lpbOut, USHORT cbOut)
{
    USHORT cbCopy;

    DEBUG_FUNCTION_NAME(_T("AddIdGroupToFrame"));
    /** if(!cbIn) cbIn = _fstrlen((LPSTR)lpbIn); **/

    Assert(cbIn>0);
    Assert(cbIn<=MAXTOTALIDLEN);
    Assert(cbOut >= 2);
    Assert(uGroupNum==GROUPNUM_TEXTID || uGroupNum==GROUPNUM_MACHINEID);

    if( (uGroupNum==GROUPNUM_TEXTID || uGroupNum==GROUPNUM_MACHINEID) &&
            cbIn>0 && cbIn<=MAXTOTALIDLEN && cbOut>=2)
    {
        cbCopy = min(cbIn, cbOut-2);
        _fmemcpy(lpbOut+2, lpbIn, cbCopy);
        SetupTextIdHdr(lpbOut, cbCopy+2, uGroupNum, uTextEncoding);
        DebugPrintEx(   DEBUG_MSG,
                        "Encoded grp=%d len=%d",
                        GroupNum(lpbOut), GroupLength(lpbOut));
        return cbCopy+2;
    }
    return 0;
}


WORD CreateNewFrame(PThrdGlbl pTG, IFR ifr, LPFR lpfr, WORD wMaxOut, BOOL fFirst)
{
    BYTE bSendSalt[4];

    if(wMaxOut <= (sizeof(FRBASE)+3 + (fFirst ? 3 : 0)))
        return 0;

    lpfr->ifr = ifr;
    lpfr->fif[0] = SIG_USA;
    lpfr->fif[1] = SIG_ATWORK1;
    lpfr->fif[2] = SIG_ATWORK2;
    lpfr->cb = 3;

    if(fFirst)
    {
        DWORD   lTemp;
        lTemp = 1;                              /* get random salt */
        _fmemcpy(bSendSalt, (LPBYTE)(&lTemp), 3); /* don't care if we get low 3 or high 3 */
        _fmemcpy(lpfr->fif+lpfr->cb, bSendSalt, 3);       /* only low 3  bytes of salt sent **/
        lpfr->cb += 3;
    }
    return lpfr->cb;
 }

/** Make sure lpilpfr always points to _current_ lpfr entry **/

BOOL AddToFrames
(
    PThrdGlbl pTG,
    IFR ifr, 
    LPLPFR rglpfr, 
    LPWORD lpilpfr, 
    LPBYTE lpbGrp, 
    WORD grpsize, 
    LPWORD lpwMaxOut, 
    BOOL fID, 
    WORD GrpNum, 
    WORD TextEncoding
)
{
    LPFR lpfr;
    USHORT uTemp;

    DEBUG_FUNCTION_NAME(_T("AddToFrames"));
redo:
    lpfr = rglpfr[*lpilpfr];
    Assert(lpfr);

    if (*lpwMaxOut < grpsize) 
        return FALSE;

    if (!fID)
    {
        uTemp = AddGroupToFrame(pTG, lpbGrp, grpsize, lpfr->fif+lpfr->cb, *lpwMaxOut);
    }
    else
    {
        uTemp = AddIdGroupToFrame(pTG, GrpNum, grpsize, TextEncoding, lpbGrp, lpfr->fif+lpfr->cb, *lpwMaxOut);
    }


    if((int)(lpfr->cb+uTemp) > (((*lpilpfr==0) && (ifr==ifrNSF)) ? MAXFIRSTNSFSIZE : MAXNEXTNSFSIZE))
    {
        WORD wTemp;

        if ((*lpilpfr)+1 >= MAXNSFFRAMES)
        {
            return FALSE;
        }
        lpfr = (LPFR) (((LPBYTE)(lpfr->fif))+lpfr->cb);
        if (!(wTemp = CreateNewFrame(pTG, ifr, lpfr, *lpwMaxOut, FALSE)))
        {
            return FALSE;
        }
        Assert(*lpwMaxOut >= wTemp);
        *lpwMaxOut -= wTemp;
        (*lpilpfr) += 1;
        rglpfr[*lpilpfr] = lpfr;                                                                                                \

        goto redo;
    }
    lpfr->cb += uTemp;
    *lpwMaxOut -= uTemp;
    return TRUE;
 }

// NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
WORD EXPORTBC BCtoNSx(PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                     LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame)
{
    LPLPFR  rglpfr;
    USHORT  ilpfr, i;
    LPFR    lpfr;
    WORD    wTemp;
    LPBYTE  lpbTemp;

    DEBUG_FUNCTION_NAME(_T("BCtoNSx"));

    Assert(ifr==ifrNSF || ifr==ifrNSS || ifr==ifrNSC);
    Assert(lpbcIn->wTotalSize >= BC_SIZE);
    Assert(lpbcIn->bctype==SEND_CAPS || lpbcIn->bctype==SEND_PARAMS ||
            lpbcIn->bctype==SEND_POLLREQ || lpbcIn->bctype==RECV_CAPS);
    /* server-->client cap reporting passes in a RECV_CAPS */

    DebugPrintBytes("SendBC", (LPBYTE)lpbcIn, lpbcIn->wTotalSize, 0);

    /* init return values */
    _fmemset(lpbOut, 0, wMaxOut);
    *lpwNumFrame = 0;

    /* set up array of LPFR pointers */
    if (wMaxOut <= (sizeof(LPFR) * MAXNSFFRAMES)) 
        goto nospace;

    rglpfr = (LPLPFR)lpbOut;
    ilpfr = 0;
    lpbOut += (sizeof(LPFR) * MAXNSFFRAMES);
    wMaxOut -= (sizeof(LPFR) * MAXNSFFRAMES);

    lpfr = (LPFR)lpbOut;
    if(!(wTemp = CreateNewFrame(pTG, ifr, lpfr, wMaxOut, TRUE)))
            goto nospace;

    Assert(wMaxOut >= wTemp);
    wMaxOut -= wTemp;
    rglpfr[ilpfr] = lpfr;

    if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->NSS)), GRPSIZE_NSS, &wMaxOut, 0,0,0))
            goto nospace;
    if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->Std)), GRPSIZE_STD, &wMaxOut, 0,0,0))
            goto nospace;
    if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->Image)), GRPSIZE_IMAGE, &wMaxOut, 0,0,0))
            goto nospace;
    if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->PollCaps)), GRPSIZE_POLLCAPS, &wMaxOut, 0,0,0))
            goto nospace;

#if !defined(EXTERNAL) || defined(TEST)
    if(lpbcIn->wszTextId)
    {
            Assert(lpbcIn->wszTextId < lpbcIn->wTotalSize);
            Assert(lpbcIn->wTextIdLen);
            if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (((LPBYTE)lpbcIn) + lpbcIn->wszTextId),
                    lpbcIn->wTextIdLen, &wMaxOut, TRUE, GROUPNUM_TEXTID, lpbcIn->wTextEncoding))
                            goto nospace;
    }

    if(lpbcIn->wrgbMachineId)
    {
            Assert(lpbcIn->wrgbMachineId < lpbcIn->wTotalSize);
            Assert(lpbcIn->wMachineIdLen);
            if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (((LPBYTE)lpbcIn) + lpbcIn->wrgbMachineId),
                    lpbcIn->wMachineIdLen, &wMaxOut, TRUE, GROUPNUM_MACHINEID, 0))
                            goto nospace;
    }

    for(i=0; i<lpbcIn->wNumPollReq; i++)
    {
            LPBYTE  lpGrp;
            USHORT  uGrpLen;

            lpGrp = (((LPBYTE)lpbcIn) + lpbcIn->rgwPollReq[i]);
            uGrpLen = GroupLength(lpGrp);
            if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, lpGrp, uGrpLen, &wMaxOut, 0,0,0))
                    goto nospace;
    }
#endif /* !EXTERNAL || TEST */


        /** done with last frame. Increment ilpfr **/
    ilpfr += 1;

    for(i=0; i<ilpfr; i++)
    {
        USHORT uMin;

        DebugPrintEx(   DEBUG_MSG,
                        "Frame %d of %d. Len=%d",
                        i, ilpfr, rglpfr[i]->cb);

        DebugPrintBytes("BeforeEncrypt", rglpfr[i]->fif, rglpfr[i]->cb, 0);

        uMin = (i ? 3 : 6);     /* first frame must have sig + salt = 3+3 */

        DebugPrintBytes("AfterEncrypt", rglpfr[i]->fif, rglpfr[i]->cb, 0);

        /** swap salt/data bytes around **/
        lpbTemp = Permute(pTG, rglpfr[i]->fif+3, (USHORT)(rglpfr[i]->cb-3), FALSE);
        _fmemcpy(rglpfr[i]->fif+3, lpbTemp, rglpfr[i]->cb-3);

        DebugPrintBytes("AfterPermute", rglpfr[i]->fif, rglpfr[i]->cb, 0);
    }

    Assert(wMaxOut >= 0);
    *lpwNumFrame = ilpfr;

    return 0;

 nospace:
    DebugPrintEx(DEBUG_ERR,"no space");
    /* zap return values so the bogus frame(s) dont get used */
    _fmemset(lpbOut, 0, wMaxOut);
    *lpwNumFrame = 0;
    return AWERROR_NOSPACE;
}
// end this is never executed

LPBYTE Permute(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cb, BOOL fReverse)
{
    USHORT v, n, i, choice;
    LPBYTE lpbOut=pTG->bOut;

    if(cb < 1 || cb > 255)
    {
        Assert(FALSE);
        return 0;
    }
    v = lpbOut[0] = lpbIn[0];       /** anchor **/
    lpbOut++, lpbIn++;      /** anchor **/
    cb--;

    for(i=0; i<MAXNSFFRAMESIZE; pTG->bRem[i]=(BYTE)i, i++);

    /** bOut[1] = bOut[2] = bOut[3] = bOut[4] = bOut[5] =' '; **/

    for(i=0, n=cb; n; n--, i++)
    {
        choice = v % n;
        if(!fReverse)
        {
            lpbOut[i] = lpbIn[pTG->bRem[choice]];
            v = (v / n) ^ lpbOut[i];
        }
        else
        {
            lpbOut[pTG->bRem[choice]] = lpbIn[i];
            v = (v / n) ^ lpbIn[i];
        }
        pTG->bRem[choice] = pTG->bRem[n-1];
        /** printf("%c%c%c%c%c%c\n\r",bOut[0],bOut[1],bOut[2],bOut[3],bOut[4],bOut[5]); **/
    }
    return lpbOut-1;
}

void DebugPrintBytes(LPSTR lpstr, LPBYTE lpb, USHORT cb, BOOL fAlways)
{
#ifdef DEBUG
    USHORT i;
    char szBuf[21] = {0};
    DWORD dwInd = 0;

    DEBUG_FUNCTION_NAME(_T("DebugPrintBytes"));
#ifndef DEBUG2
    if(fAlways)
#endif /** DEBUG2 **/
    {
        DebugPrintEx(DEBUG_MSG,"[%s]", (LPSTR)lpstr);
        dwInd = 0;
        for(i=0; i<cb; i++)
        {
                dwInd += _stprintf(&szBuf[dwInd],"%02x ", (USHORT)lpb[i]);
                if(((i+1) % 20) == 0)
                {
                    dwInd = 0;
                    DebugPrintEx(DEBUG_MSG, "print bytes %s",szBuf);
                }
        }
    }
#endif /** DEBUG **/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\nsfenc.h ===
/* Key must be 3 bytes of random key, datalen is the length of data */
void FAR PASCAL RC4ENC(BYTE FAR *key, WORD datalen, BYTE FAR *data);
DWORD FAR PASCAL RandDWord(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\dis.c ===
/***************************************************************************
 Name     :     DIS.C
 Comment  :     Collection if DIS/DCS/DTC and CSI/TSI/CIG mangling routines.
                        They manipulate the DIS struct whose members correspond to the bits
                        of the T30 DIS/DCS/DTC frames.

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include "protocol.h"

///RSL
#include "glbproto.h"


///////// switched from RES-->AWRES values. Table no longer valid /////////
//
//      #define fsim_ILLEGAL    255
//      // converts from RES_ #defines to
//      // DIS bits. Some values have no conversions
//      BYTE F24S_fsim[16] =
//      {
//      /* Converts RES_FINE, RES_200, RES_400, RES_SUPER_SUPER to
//       * ResFine_200, Res16x15_400, ResInchBased, ResMetricBased
//       */
//      /* F24S         fsim */
//      /* 0000 --> 0000 */             0,
//      /* 0001 --> 0101 */             5,
//      /* 0010 -->     0110 */         6,
//      /* 0011 -->     0111 */         7,
//      /* 0100 -->     1010 */         10,
//      /* 0101 -->     XXXX */         fsim_ILLEGAL,
//      /* 0110 -->     1110 */         14,
//      /* 0111 -->     XXXX */         fsim_ILLEGAL,
//      /* 1000 -->     1001 */         8,      /*9,*/          // vanilla Fine mode. No need for metric bit
//      /* 1001 --> 1101 */             13,
//      /* 1010 --> XXXX */             fsim_ILLEGAL,
//      /* 1011 --> XXXX */             fsim_ILLEGAL,
//      /* 1100 --> 1011 */             11,
//      /* 1101 --> XXXX */             fsim_ILLEGAL,
//      /* 1110 --> XXXX */             fsim_ILLEGAL,
//      /* 1111 --> 1111 */             15
//      };
//
///////////////////////////////////////////////////////////////////////

USHORT SetupDISorDCSorDTC
(
    PThrdGlbl pTG, 
    NPDIS npdis, 
    NPBCFAX npbcFax, 
    NPLLPARAMS npll, 
    BOOL fECM, 
    BOOL f64
)
{
    // return length of DIS

    USHORT  uLen;

    DEBUG_FUNCTION_NAME(_T("SetupDISorDCSorDTC"));

    DebugPrintEx(   DEBUG_MSG,
                    "baud=0x%02x min=0x%02x res=0x%02x code=0x%02x"
                    " wide=0x%02x len=0x%02x",
                    npll->Baud, npll->MinScan, 
                    (WORD)npbcFax->AwRes, npbcFax->Encoding, 
                    npbcFax->PageWidth, npbcFax->PageLength);

    BG_CHK(npdis);
    BG_CHK((npll->MinScan & ~MINSCAN_MASK) == 0);
    BG_CHK((npbcFax->AwRes & ~AWRES_ALLT30) == 0);
    BG_CHK((npbcFax->Encoding & ~(MH_DATA|MR_DATA|MMR_DATA)) == 0);
    BG_CHK((npbcFax->PageWidth & ~WIDTH_MASK) == 0);
    BG_CHK((npbcFax->PageLength & ~LENGTH_MASK) == 0);
    BG_CHK(npbcFax->fPublicPoll==0 || npbcFax->fPublicPoll==1);
    BG_CHK(fECM==0 || fECM==1);
    BG_CHK(f64==0 || f64==1);
    BG_CHK(!(fECM==0 && f64!=0));

    _fmemset(npdis, 0, sizeof(DIS));

    // npdis->G1stuff  = 0;
    // npdis->G2stuff = 0;
    npdis->G3Rx = 1;  // always ON for DIS & DCS. Indicates T.4 recv Cap/Mode
    npdis->G3Tx = (BYTE) (npbcFax->fPublicPoll);
    // This must be 0 for a DCS frame. The Omnifax G77 and GT choke on it!

    npdis->Baud = npll->Baud;

    npdis->MR_2D    = ((npbcFax->Encoding & MR_DATA) != 0);

    npdis->MMR      = ((npbcFax->Encoding & MMR_DATA) != 0);
    // npdis->MR_2D                 = 0;
    // npdis->MMR                   = 0;

    npdis->PageWidth                = (BYTE) (npbcFax->PageWidth);
    npdis->PageLength               = (BYTE) (npbcFax->PageLength);
    npdis->MinScanCode      = npll->MinScan;

    // npdis->Uncompressed = npdis->ELM = 0;

    npdis->ECM = fECM != FALSE;
    npdis->SmallFrame = f64 != FALSE;


    if (npbcFax->PageWidth > WIDTH_MAX)
    {
            npdis->WidthInvalid = TRUE;
            npdis->Width2 = (npbcFax->PageWidth>>WIDTH_SHIFT);
    }

    // doesn't hold for SendParams (why??)
    // BG_CHK(npbcFax->AwRes & AWRES_mm080_038);
    npdis->Res_300            = 0;  // RSL ((npbcFax->AwRes & AWRES_300_300) != 0);
    npdis->Res8x15            = ((npbcFax->AwRes & AWRES_mm080_154) != 0);


    if (! pTG->SrcHiRes) 
    {
        npdis->ResFine_200 = 0;
    }
    else 
    {
        npdis->ResFine_200      =  ((npbcFax->AwRes & (AWRES_mm080_077|AWRES_200_200)) != 0);
    }

    npdis->Res16x15_400     = ((npbcFax->AwRes & (AWRES_mm160_154|AWRES_400_400)) != 0);
    npdis->ResInchBased = ((npbcFax->AwRes & (AWRES_200_200|AWRES_400_400)) != 0);
    npdis->ResMetricBased = ((npbcFax->AwRes & AWRES_mm160_154) ||
                                                    ((npbcFax->AwRes & AWRES_mm080_077) && npdis->ResInchBased));

    npdis->MinScanSuperHalf = ((npll->MinScan & MINSCAN_SUPER_HALF) != 0);

    if(!fECM) goto done;    // can't have file transfer stuff w/o ECM

done:

    npdis->Extend24 = npdis->Extend32 = npdis->Extend40 = 0;
    uLen = 3;

    DebugPrintEx(DEBUG_MSG,"DIS len = %d", uLen);
    return uLen;
}



///////// switched from RES-->AWRES values. Table no longer valid /////////
//
//      #define F24S_ILLEGAL    255
//      // converts from DIS bits to RES_ #defines
//      Some values have no conversions
//      BYTE fsim_F24S[16] =
//      {
//      /* Converts ResFine_200, Res16x15_400, ResInchBased, ResMetricBased to
//       * AWRES_mm080_077, AWRES_200_200, AWRES_400_400, AWRES_mm160_154
//       */
//      /* fsim         F24S */
//      /* 0000 --> 0000 */             0,
//      /* 0001 -->     XXXX */         F24S_ILLEGAL,
//      /* 0010 -->     XXXX */         F24S_ILLEGAL,
//      /* 0011 --> XXXX */             F24S_ILLEGAL,
//      /* 0100 --> XXXX */             1,      /*F24S_ILLEGAL,*/        // try and make sense of it anyway
//      /* 0101 --> 0001 */             1,
//      /* 0110 --> 0010 */             2,
//      /* 0111 --> 0011 */             3,
//      /* 1000 --> 1000 */             8,
//      /* 1001 --> 1000 */             8,
//      /* 1010 --> 0100 */             4,
//      /* 1011 --> 1100 */             12,
//      /* 1100 --> XXXX */             9,      /*F24S_ILLEGAL,*/       // assume metric preferred
//      /* 1101 --> 1001 */             9,
//      /* 1110 --> 0110 */             6,
//      /* 1111 --> 1111 */             15
//      };
//
///////// switched from RES-->AWRES values. Table no longer valid /////////

void ParseDISorDCSorDTC
(
    PThrdGlbl pTG, 
    NPDIS npDIS, 
    NPBCFAX npbcFax, 
    NPLLPARAMS npll, 
    BOOL fParams
)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////

    // BYTE fsim, F24S;
    NPBYTE npb, npbLim;

    DEBUG_FUNCTION_NAME(_T("ParseDISorDCSorDTC"));
// first make sure DIS is clean. We may have picked up some trailing CRCs
// trailing-trash removed by reading the Extend bits

    npb = npbLim = (NPBYTE)npDIS;
    npbLim += sizeof(DIS);
    for(npb+=2; npb<npbLim && (*npb & 0x80); npb++);
    // exits when npb points past end of structure or
    // points to the first byte with the high bit NOT set
    // i.e. the last VALID byte

    for(npb++; npb<npbLim; npb++)
        *npb = 0;
        // starting with the byte AFTER the last valid byte, until end
        // of the structure, zap all bytes to zero

// parse high level params into NPI

    memset(npbcFax, 0, sizeof(BCFAX));

    npbcFax->AwRes = 0;
    npbcFax->Encoding = 0;

    // Resolution
    if(npDIS->Res8x15)
        npbcFax->AwRes |= AWRES_mm080_154;

    if(npDIS->Res_300)
        npbcFax->AwRes |= AWRES_300_300;

    if(npDIS->ResInchBased)
    {
        if(npDIS->ResFine_200)
            npbcFax->AwRes |= AWRES_200_200;

        if(npDIS->Res16x15_400)
            npbcFax->AwRes |= AWRES_400_400;
    }
    if(npDIS->ResMetricBased || !npDIS->ResInchBased)
    {
        if(npDIS->ResFine_200)
            npbcFax->AwRes |= AWRES_mm080_077;

        if(npDIS->Res16x15_400)
            npbcFax->AwRes |= AWRES_mm160_154;
    }

    // Encoding (MMR only if ECM also supported)
    if(npDIS->MR_2D)
        npbcFax->Encoding |= MR_DATA;

    if(npDIS->MMR && npDIS->ECM)
        npbcFax->Encoding |= MMR_DATA;

    if(!fParams)
    {
        // setting up capabilities -- add the "always present" caps
        npbcFax->AwRes |= AWRES_mm080_038;
        npbcFax->Encoding |= MH_DATA;
    }
    else
    {
        // setting up params -- set the defaults if none otehr specified
        if(!npbcFax->AwRes)
            npbcFax->AwRes = AWRES_mm080_038;

        if(!npbcFax->Encoding)
            npbcFax->Encoding = MH_DATA;

        // if both MR & MMR are set (this happens with Ricoh's fax simulator!)
        // then set just MMR. MH doesnt have an explicit bit, so we set MH
        // here only if nothing else is set. So the only multiple-setting case
        // (for encodings) that we can encounter is (MR|MMR). BUG#6950
        if(npbcFax->Encoding == (MR_DATA|MMR_DATA))
                npbcFax->Encoding = MMR_DATA;
    }

    // PageWidth and Length
    npbcFax->PageWidth      = npDIS->PageWidth;

    // IFAX Bug#8152: Hack for interpreting invalid value (1,1) as
    // A3, because some fax machines do that. This is
    // as per Note 7 of Table 2/T.30 of ITU-T.30 (1992, page 40).
#define WIDTH_ILLEGAL_A3 0x3
    if (!fParams && npbcFax->PageWidth==WIDTH_ILLEGAL_A3)
    {
        npbcFax->PageWidth=WIDTH_A3;
    }
    npbcFax->PageLength     = npDIS->PageLength;

    // has G3 file available for polling
    npbcFax->fPublicPoll = npDIS->G3Tx;
    // This must be 0 for DCS frames! However if it's not let it pass anyway
    BG_CHK(fParams ? (npDIS->G3Tx==0) : TRUE);


/**** Can't deal with narrow widths yet. Just pretend they're 1728 ****
        if(npDIS->PageWidthInvalid)
                npbcFax->PageWidth = (npdis->PageWidth2 << WIDTH_SHIFT);
***********************************************************************/


// Now low level params LLPARAMS
// Baudrate, ECM, ECM frame size, and MinScan. That's it!

    npll->Baud = npDIS->Baud;
    npll->fECM = npDIS->ECM;
    npll->fECM64 = npDIS->SmallFrame;
    npll->MinScan = npDIS->MinScanCode;
    if(npDIS->MinScanSuperHalf)
            npll->MinScan |= MINSCAN_SUPER_HALF;

    if(!npll->fECM) goto done;      // can't have file transfer stuff w/o ECM

/***
        npll->fNonEfaxSUB = npdis->SUBcap;
        npll->fNonEfaxSEP = npdis->SEPcap;
        npll->fNonEfaxPWD = npdis->PWDcap;
        npll->fNonEfaxBFT = npdis->BFTcap;
        npll->fNonEfaxDTM = npdis->DTMcap;
        npll->fNonEfaxEDI = npdis->EDIcap;
        npll->fNonEfaxCharMode = npdis->CharMode;
***/

done:
        DebugPrintEx(   DEBUG_MSG,
                        "baud=0x%02x min=0x%02x res=0x%02x code=0x%02x"
                        " wide=0x%02x len=0x%02x",
                        npll->Baud, npll->MinScan, 
                        (WORD)npbcFax->AwRes, npbcFax->Encoding, 
                        npbcFax->PageWidth, npbcFax->PageLength);
        ;
}


/* Converts the code for a speed to the speed in BPS */

UWORD CodeToBPS[16] =
{
/* V27_2400     0 */    2400,
/* V29_9600     1 */    9600,
/* V27_4800     2 */    4800,
/* V29_7200     3 */    7200,
/* V33_14400    4 */    14400,
                        0,
/* V33_12000    6 */    12000,
                        0,
/* V17_14400    8 */    14400,
/* V17_9600     9 */    9600,
/* V17_12000    10 */   12000,
/* V17_7200     11 */   7200,
                        0,
                        0,
                        0,
                        0
};


#define msBAD   255

/* Converts a DCS min-scan field code into millisecs */
BYTE msPerLine[8] = { 20, 5, 10, msBAD, 40, msBAD, msBAD, 0 };


USHORT MinScanToBytesPerLine(PThrdGlbl pTG, BYTE MinScan, BYTE Baud)
{
    USHORT uStuff;
    BYTE ms;

    uStuff = CodeToBPS[Baud];
    BG_CHK(uStuff);
    ms = msPerLine[MinScan];
    BG_CHK(ms != msBAD);
    uStuff /= 100;          // StuffBytes = (BPS * ms)/8000
    uStuff *= ms;           // take care not to use longs
    uStuff /= 80;           // or overflow WORD or lose precision
    uStuff += 1;            // Rough fix for truncation problems

    return uStuff;
}

#define ms40    4
#define ms20    0
#define ms10    2
#define ms5     1
#define ms0     7

/* first index is a DIS min-scan capability. 2nd is 0 for normal
 * 1 for fine (1/2) and 2 for super-fine (if 1/2 yet again).
 * Output is the Code to stick in the DCS.
 */

BYTE MinScanTab[8][3] =
{
        ms20,   ms20,   ms10,
        ms5,    ms5,    ms5,
        ms10,   ms10,   ms5,
        ms20,   ms10,   ms5,
        ms40,   ms40,   ms20,
        ms40,   ms20,   ms10,
        ms10,   ms5,    ms5,
        ms0,    ms0,    ms0
};


#define V_ILLEGAL       255

#define V27_2400        0
#define V27_4800        2
#define V29_9600        1
#define V29_7200        3
#define V33_14400       4
#define V33_12000       6
#define V17_14400       8
#define V17_12000       10
#define V17_9600        9
#define V17_7200        11

#define V27_SLOW                        0
#define V27_ONLY                        2
#define V29_ONLY                        1
#define V33_ONLY                        4
#define V17_ONLY                        8
#define V27_V29                         3
#define V27_V29_V33                     7
#define V27_V29_V33_V17         11
#define V_ALL                           15

/* Converts a capability into the best speed it offers.
 * index will usually be the & of both DIS's Baud rate fields
 * (both having first been "adjusted", i.e. 11 changed to 15)
 * Output is the Code to stick in the DCS.
 */

BYTE BaudNegTab[16] =
{
/* V27_SLOW                     0 --> 0 */      V27_2400,
/* V29_ONLY                     1 --> 1 */      V29_9600,
/* V27_ONLY                     2 --> 2 */      V27_4800,
/* V27_V29                      3 --> 1 */      V29_9600,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
/* V27_V29_V33                  7 --> 4 */      V33_14400,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
/* V27_V29_V33_V17              11 --> 8 */     V17_14400,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
                                                V_ILLEGAL,
/* V_ALL                        15 --> 8 */     V17_14400
};

/***************************************************************************
        Name      :     NegotiateLowLevelParams
        Purpose   :     Takes a received DIS and optionally MS NSF,
                                our HW caps and

                                picks highest common baud rate, ECM is picked if both have it
                                ECM frame size is 256 unless remote DIS has that bit set to 1
                                or we want small frames (compiled-in option).

                                The MinScan time is set to the max.
                                                        (i.e. highest/slowest) of both.

                                Fill results in Negot section of npProt

        CalledFrom:     NegotiateLowLevelParams is called by the sender when a DIS
                                and/or NSF is received.
***************************************************************************/


void NegotiateLowLevelParams
(
    PThrdGlbl pTG, 
    NPLLPARAMS npllRecv, 
    NPLLPARAMS npllSend,
    DWORD AwRes, 
    USHORT uEnc, 
    NPLLPARAMS npllNegot
)
{
    USHORT  Baud, Baud1, Baud2;
    USHORT  MinScanCode, col;

    DEBUG_FUNCTION_NAME(_T("NegotiateLowLevelParams"));
    ////// negotiate Baudrate, ECM, ECM frame size, and MinScan. That's it!

    Baud1 = npllRecv->Baud;
    Baud2 = npllSend->Baud;
    if(Baud1 == 11) 
        Baud1=15;

    if(Baud2 == 11)
        Baud2=15;

    Baud = Baud1 & Baud2;
    npllNegot->Baud = BaudNegTab[Baud];
    BG_CHK(npllNegot->Baud != V_ILLEGAL);
    if (npllNegot->Baud == V_ILLEGAL)
    {
        // this is a case in which the remote side sent us an invalid param
        // as the input supported baud rate and modulation.
        // since we haven't sent out the DCS yet, we'll try to go with V.29 9600
        // and send this DCS, if the remote side does not support this
        // let it disconnect, anyways it violated the protocol.
        npllNegot->Baud = V29_9600;
        DebugPrintEx(DEBUG_ERR,"Remote side violates protocol (%d), default to V.29 9600",npllRecv->Baud);
    }
    // there is always some common baud rate (i.e. at least 2400 mandatory)

    // ECM. On if both have it. Frame size is small if either
    // party want it so. (though using this bit in the DIS is
    // contrary to the T.30 spec). But we will come to no harm
    // treating it so

    if((uEnc==MH_DATA || uEnc==MR_DATA) && (pTG->ProtParams.EnableG3SendECM==0))
    {
        npllNegot->fECM = 0;
        npllNegot->fECM64 = 0;
    }
    else
    {
        // gotta be TRUE otherwise we've negotiated
        // ourselves into a hole here....
        BG_CHK(npllRecv->fECM && npllSend->fECM);

        npllNegot->fECM   = 0; // RSL (npllRecv->fECM && npllSend->fECM);

        // 64 bytes if receiver request it & we support it
        // npllNegot->fECM64 = (npllRecv->fECM64 && npllSend->fECM64);
        // Exercise sender's prerogative--64 bytes if we have that selected
        // npllNegot->fECM64 = npllSend->fECM64;
        // Use if either want it (i.e. sender selected it or receiver prefers it)
        npllNegot->fECM64 = 0; // RSL (npllRecv->fECM64 || npllSend->fECM64);
    }


    /* Minimum Scan line times. Only Receiver's pref matters.
     * Use teh table above to convert from Receiver's DIS to the
     * required DCS. Col 1 is used if vertical res. is normal (100dpi)
     * Col2 if VR is 200 or 300dpi, (OR if VR is 400dpi, but Bit 46
     * is not set), and Col3 is used if VR is 400dpi *and* Bit 46
     * (MinScanSuperHalf) is set
     */

    if(npllNegot->fECM)
    {
        npllNegot->MinScan = ms0;
    }
    else
    {
        MinScanCode = (npllRecv->MinScan & 0x07);       // low 3 bits

        if(AwRes & (AWRES_mm080_154|AWRES_mm160_154|AWRES_400_400))
        {
            if(npllRecv->MinScan & MINSCAN_SUPER_HALF)
                    col = 2;
            else
                    col = 1;
        }
        // T30 says scan time for 300dpi & 200dpi is the same
        else if(AwRes & (AWRES_300_300|AWRES_mm080_077|AWRES_200_200))
            col = 1;
        else
            col = 0;

        npllNegot->MinScan = MinScanTab[MinScanCode][col];
    }

    DebugPrintEx(   DEBUG_MSG,
                    "baud=0x%02x min=0x%02x ECM=%d small=%d",
                    npllNegot->Baud, npllNegot->MinScan, 
                    npllNegot->fECM, npllNegot->fECM64);
}


USHORT GetStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2)
{
    /** Both args always 20 bytes long. Throws away leading & trailing
            blanks, then copies what's left *reversed* into lpstr[].
            Terminates with 0.
    **/

    int i, j, k;

    DEBUG_FUNCTION_NAME(_T("GetStupidReversedFIFs"));
    BG_CHK(lpstr2 && lpstr1);

    // (MyDebugPrint(pTG,  LOG_ALL,  "In GetReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr2=%20s\r\n",
    //                      (LPSTR)lpstr1, lpstr2, lpstr2));

    for(k=0; k<IDFIFSIZE && lpstr2[k]==' '; k++);    // k==first nonblank or 20
            
    for(j=IDFIFSIZE-1; j>=k && lpstr2[j]==' '; j--); // j==last nonblank or -1
                
    i = 0;

    for( ; i<IDFIFSIZE && j>=k; i++, j--)
            lpstr1[i] = lpstr2[j];

    lpstr1[i] = 0;

    DebugPrintEx(   DEBUG_MSG,
                    "Got<%s> produced<%s>",
                    (LPSTR)lpstr2, (LPSTR)lpstr1);

    return (USHORT)i;
}

void CreateStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2)
{
    /** Both args always 20 bytes long. Copies LPSTR *reversed* into
            the end of lpstr1[], then pads rest with blank.
            Terminates with a 0
    **/

    int i, j;

    BG_CHK(lpstr2 && lpstr1);

    // (MyDebugPrint(pTG,  LOG_ALL,  "In CreateReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr2=%20s\r\n",
    //                      lpstr1, lpstr2, lpstr2));

    for(i=0, j=IDFIFSIZE-1; lpstr2[i] && j>=0; i++, j--)
            lpstr1[j] = lpstr2[i];

    if(j>=0)
        _fmemset(lpstr1, ' ', j+1);

    lpstr1[IDFIFSIZE] = 0;

}


/* Converts a the code for a speed to the code fro the next
 * best (lower) speed. order is
   (V17: 144-120-96-72-V27_2400) (V33: 144 120 V29: 96 72 V27: 48 24)
 */
// NOTE: FRANCE defines the fallback sequence to go from V17_7200 to V27_4800




BYTE DropBaudTab[16] =
{
/* V27_2400     --> X           0 --> X */      V_ILLEGAL,
/* V29_9600     --> V29_7200    1 --> 3 */      V29_7200,
/* V27_4800     --> V27_2400    2 --> 0 */      V27_2400,
/* V29_7200     --> V27_4800    3 --> 2 */      V27_4800,
/* V33_14400 -> V33_12000       4 --> 6 */      V33_12000,
                                                V_ILLEGAL,
/* V33_12000 -> V29_9600        6 --> 1 */      V29_9600,
                                                V_ILLEGAL,
/* V17_14400 -> V17_12000       8 -> 10 */      V17_12000,
/* V17_9600 --> V17_7200        9 -> 11 */      V17_7200,
/* V17_12000 -> V17_9600        10 -> 9 */      V17_9600,
/* V17_7200 --> V29_9600        11 -> 1
                         or V29_7200    11 -> 3
USE THIS---> or V27_4800        11 -> 2
                         or V27_2400    11 -> 0 */      V27_4800,
                                                        V_ILLEGAL,
                                                        V_ILLEGAL,
                                                        V_ILLEGAL,
                                                        V_ILLEGAL
};

BOOL DropSendSpeed(PThrdGlbl pTG)
{
    USHORT  uSpeed;
    UWORD   uBps;

    DEBUG_FUNCTION_NAME(_T("DropSendSpeed"));
    BG_CHK(pTG->ProtInst.fllNegotiated);

    if ((pTG->ProtInst.llNegot.Baud==V_ILLEGAL) || (pTG->ProtInst.llNegot.Baud>15))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Illegal input speed to DropSendSpeed %d",
                        pTG->ProtInst.llNegot.Baud);
        return FALSE;
    }

    uSpeed = DropBaudTab[pTG->ProtInst.llNegot.Baud];
    uBps = CodeToBPS[uSpeed];
    // enforce LowestSendSpeed
    if  (   (uSpeed == V_ILLEGAL) ||
            (   (pTG->ProtInst.LowestSendSpeed <= 14400) &&
                (uBps < pTG->ProtInst.LowestSendSpeed)
            ) 
        )
    {
        BG_CHK(pTG->ProtInst.llNegot.Baud==V27_2400 ||
                 CodeToBPS[pTG->ProtInst.llNegot.Baud]==pTG->ProtInst.LowestSendSpeed);

        DebugPrintEx(   DEBUG_MSG,
                        "Can't drop (0x%02x)",
                        pTG->ProtInst.llNegot.Baud);
        return FALSE;
        // speed remains same as before if lowest speed
        // return FALSE to hangup
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"Now at 0x%02x", uSpeed);
        pTG->ProtInst.llNegot.Baud = (BYTE) uSpeed;
        return TRUE;
    }
}

void EnforceMaxSpeed(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("EnforceMaxSpeed"));

    // enforce HighestSendSpeed setting
    BG_CHK(!pTG->ProtInst.HighestSendSpeed || (pTG->ProtInst.HighestSendSpeed>=2400 &&
                    pTG->ProtInst.HighestSendSpeed >= pTG->ProtInst.LowestSendSpeed));

    if( pTG->ProtInst.HighestSendSpeed && pTG->ProtInst.HighestSendSpeed >= 2400 &&
            pTG->ProtInst.HighestSendSpeed >= pTG->ProtInst.LowestSendSpeed)
    {
        DebugPrintEx(   DEBUG_MSG,
                        "MaxSend=%d. Baud=%x BPS=%d, dropping",
                        pTG->ProtInst.HighestSendSpeed, 
                        pTG->ProtInst.llNegot.Baud, 
                        CodeToBPS[pTG->ProtInst.llNegot.Baud]);

        while(CodeToBPS[pTG->ProtInst.llNegot.Baud] > pTG->ProtInst.HighestSendSpeed)
        {
            if(!DropSendSpeed(pTG))
            {
                BG_CHK(FALSE);
                break;
            }
        }
        DebugPrintEx(   DEBUG_MSG,
                        "MaxSend=%d. Baud=%x BPS=%d",
                        pTG->ProtInst.HighestSendSpeed, 
                        pTG->ProtInst.llNegot.Baud, 
                        CodeToBPS[pTG->ProtInst.llNegot.Baud]);
    }
}

USHORT CopyFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr, USHORT uSize)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////
    USHORT uDstLen;

    uDstLen = min(uSize, lpfr->cb);
    _fmemset(lpbDst, 0, uSize);
    _fmemcpy(lpbDst, lpfr->fif, uDstLen);
    return uDstLen;
}

void CopyRevIDFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////

    USHORT  uDstLen;
    char    szTemp[IDFIFSIZE+2];

    DEBUG_FUNCTION_NAME(_T("CopyRevIDFrame"));

    uDstLen = min(IDFIFSIZE, lpfr->cb);
    _fmemset(szTemp, ' ', IDFIFSIZE);       // fill spaces (reqd by GetReverse)
    _fmemcpy(szTemp, lpfr->fif, uDstLen);
    szTemp[IDFIFSIZE] = 0;  // zero-terminate

    GetStupidReversedFIFs(pTG, lpbDst, szTemp);

    if(uDstLen!=IDFIFSIZE)
        DebugPrintEx(DEBUG_ERR, "Bad ID frame" );
}

// This function check whether the parameters in recvdDCS are valids by checking the 
// DCS we got given the DIS we send to transmitter
BOOL AreDCSParametersOKforDIS(LPDIS sendDIS, LPDIS recvdDCS)
{
    // FYI: The DCS is save in pTG->ProtInst->RemoteDCS
    // While we save our DIS in pTG->ProtInst->LocalDIS
    // This will solve bug #4677: "Fax: T.30: service does not receive simple 1 page fax, using ECM"
    if (sendDIS->ECM != recvdDCS->ECM)
    {
        return FALSE;
    }
    switch(sendDIS->PageWidth)
    {
        case 0: // This means: ONLY 1728 dots
                if (recvdDCS->PageWidth != 0) 
                {
                    return FALSE;
                }
                break;
        case 1: // This means: 1728 or 2048
                if ((recvdDCS->PageWidth != 0) && (recvdDCS->PageWidth != 1))
                {
                    return FALSE;
                }
                break;
                

        case 2: // This means: 1728 or 2048 or 2432
        case 3: // This is wrong but we interpret it like 2: All the standard widths
                BG_CHK((recvdDCS->PageWidth >= 0) && (recvdDCS->PageWidth <= 3));
                break;

        default:// There is no other option (PageWidth is two only bits)
                BG_CHK(FALSE);
                return FALSE;
    }
    return TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\hdlc.h ===
/*************************************************************************
        hdlc.h

        Contains stuff pertaining to sending and recieving HDLC frames
        that are defined in the T30 spec.
*************************************************************************/

// On PCs we should pause before ALL frames _except_ CFR & FTT (because
// those are too time critical). In IFAX we look for silence always.
// This is handled in HDLC.C

// On PCs we use TwiddleThumbs() (FTS and FRS are dangerous)
// In IFAX we must use RecvSilence (safe in IFAX) to avoid collisions
// This is handled inside the Modem driver. AWT30 always call RecvSilence
// (in HDLC.C), and the Class1 modem driver uses TwiddleThumbs()
// not FRS or FTS, while teh IFAX driver looks for real silence


// In WFW don't pause before CFR/FTT. Delay may get too long!!
#define SendCFR(pTG)       (SendSingleFrame(pTG,ifrCFR,0,0,1))
#define SendFTT(pTG)       (SendSingleFrame(pTG,ifrFTT,0,0,1))

// must pause before MCF/RTN always
#define SendMCF(pTG)       (SendSingleFrame(pTG,ifrMCF,0,0,1))
#define SendRTN(pTG)       (SendSingleFrame(pTG,ifrRTN,0,0,1))

/*** never send RTP
#define SendRTP()       (SendSingleFrame(ifrRTP,0,0))
***/

// no harm in pausing before DCN.
#define SendDCN(pTG)       (SendSingleFrame(pTG,ifrDCN,0,0,1))

// we've eliminated the post-page pause, so we need to pause before these
// frames. In any case, that's all handled inside the modem driver.
// We make a single call to ModemRecSilence()
#define SendEOM(pTG)                       (SendSingleFrame(pTG,ifrEOM,0,0,1))
#define SendMPS(pTG)                       (SendSingleFrame(pTG,ifrMPS,0,0,1))
#define SendEOP(pTG)                       (SendSingleFrame(pTG,ifrEOP,0,0,1))
#define SendPRI_EOM(pTG)           (SendSingleFrame(pTG,ifrPRI_EOM,0,0,1))
#define SendPRI_MPS(pTG)           (SendSingleFrame(pTG,ifrPRI_MPS,0,0,1))
#define SendPRI_EOP(pTG)           (SendSingleFrame(pTG,ifrPRI_EOP,0,0,1))
#define SendPIP(pTG)                       (SendSingleFrame(pTG,ifrPIP,0,0.1))
#define SendPIN(pTG)                       (SendSingleFrame(pTG,ifrPIN,0,0,1))

// do we need a pause before RR/CTC/ERR/CTR etc?
// in RR & CTC we have all teh time in the world, so must pause
// ERR & CTR I dunno, so I'm pausing anyway
#define SendRR(pTG)                (SendSingleFrame(pTG,ifrRR,0,0,1))
#define SendCTC(pTG,fif)    (SendSingleFrame(pTG,ifrCTC,fif,2,1))
#define SendERR(pTG)               (SendSingleFrame(pTG,ifrERR,0,0,1))
#define SendCTR(pTG)               (SendSingleFrame(pTG,ifrCTR,0,0,1))

// PPR/RNR sent in same logical spot as MCF so use delay
#define SendPPR(pTG,fif)    (SendSingleFrame(pTG,ifrPPR,fif,32,1))
#define SendRNR(pTG)               (SendSingleFrame(pTG,ifrRNR,0,0,1))

// add this...
#define SendEOR_EOP(pTG)           (SendSingleFrame(pTG,ifrEOR_EOP, 0, 0, 1))

#define TEXTBASED

typedef struct {
        BYTE    bFCF1;
        BYTE    bFCF2;
        BYTE    fInsertDISBit;
        BYTE    wFIFLength;             // required FIF length, 0 if none, FF if variable
        char*   szName;
} FRAME;

typedef FRAME TEXTBASED *CBPFRAME;

// CBPFRAME is a based pointer to a FRAME structure, with the base as
// the current Code segment. It will only be used to access
// the frame table which is a CODESEG based constant table.


// This is everything you never wanted to know about T30 frames....
#define         ifrMAX          48
extern FRAME TEXTBASED rgFrameInfo[ifrMAX];





/****************** begin prototypes from hdlc.c *****************/
BOOL SendSingleFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fSleep);
BOOL SendManyFrames(PThrdGlbl pTG, LPLPFR lplpfr, USHORT uNumFrames);
BOOL SendZeros(PThrdGlbl pTG, USHORT uCount, BOOL fFinal);
BOOL SendTCF(PThrdGlbl pTG);
BOOL SendRTC(PThrdGlbl pTG, BOOL);
SWORD GetTCF(PThrdGlbl pTG);
/***************** end of prototypes from hdlc.c *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\hdlc.c ===
/////// Global #defines that would've gone on the Cmd line //////
/////////////////////////////////////////////////////////////////

/***************************************************************************
        Name      :     HDLC.C
        Comment   :     Contains miscellenous HDLC framing T30 frame recognition and
                                generation routines. Mostly called from the main T30 skeleton
                                in T30.C

        Revision Log

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "t30.h"
#include "hdlc.h"
#include "debug.h"

///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_HDLC

// CBPFR is a code-based pointer to an FR structure, with the base as
// the current Code segment. It will only be used to access
// the table below which is a CODESEG based constant table.

#define         ifrMAX          48

// This table better match the #defines in et30API.H !!!!
// This is everything you never wanted to know about T30 frames....

FRAME TEXTBASED rgFrameInfo[ifrMAX] = {
#define ifrNULL         0   
                            { 0x00, 0, 0, 0,    "ifrNULL!!!"},
#define ifrDIS          1   
                            { 0x80, 0, 0, 0xFF, "DIS"       },
#define ifrCSI          2   
                            { 0x40, 0, 0, 0xFF, "CSI"       },
#define ifrNSF          3   
                            { 0x20, 0, 0, 0xFF, "NSF"       },
#define ifrDTC          4   
                            { 0x81, 0, 0, 0xFF, "DTC"       },
#define ifrCIG          5   
                            { 0x41, 0, 0, 0xFF, "CIG"       },
#define ifrNSC          6   
                            { 0x21, 0, 0, 0xFF, "NSC"       },
#define ifrDCS          7   
                            { 0x82, 0, 1, 0xFF, "DCS"       },
#define ifrTSI          8   
                            { 0x42, 0, 1, 0xFF, "TSI"       },
#define ifrNSS          9   
                            { 0x22, 0, 1, 0xFF, "NSS"       },
#define ifrCFR          10  
                            { 0x84, 0, 1, 0,    "CFR"       },
#define ifrFTT          11  
                            { 0x44, 0, 1, 0,    "FTT"       },
#define ifrMPS          12  
                            { 0x4E, 0, 1, 0,    "MPS"       },
#define ifrEOM          13  
                            { 0x8E, 0, 1, 0,    "EOM"       },
#define ifrEOP          14  
                            { 0x2E, 0, 1, 0,    "EOP"       },
#define ifrPWD          15  
                            { 0xC1, 0, 0, 0xFF, "PWD"       },
#define ifrSEP          16  
                            { 0xA1, 0, 0, 0xFF, "SEP"       },
#define ifrSUB          17  
                            { 0xC2, 0, 1, 0xFF, "SUB"       },
#define ifrMCF          18  
                            { 0x8C, 0, 1, 0,    "MCF"       },
#define ifrRTP          19  
                            { 0xCC, 0, 1, 0,    "RTP"       },
#define ifrRTN          20  
                            { 0x4C, 0, 1, 0,    "RTN"       },
#define ifrPIP          21  
                            { 0xAC, 0, 1, 0,    "PIP"       },
#define ifrPIN          22  
                            { 0x2C, 0, 1, 0,    "PIN"       },
#define ifrDCN          23  
                            { 0xFA, 0, 1, 0,    "DCN"       },
#define ifrCRP          24  
                            { 0x1A, 0, 1, 0,    "CRP"       },
#define ifrPRI_MPS      25  
                            { 0x5E, 0, 1, 0,    "PRI_MPS"   },
#define ifrPRI_EOM      26  
                            { 0x9E, 0, 1, 0,    "PRI_EOM"   },
#define ifrPRI_EOP      27  
                            { 0x3E, 0, 1, 0,    "PRI_EOP"   },

        /********* ECM stuff starts here. T.30 section A.4 ******/

#define ifrCTC          28  
                            { 0x12, 0,      1, 2, "CTC"         },
#define ifrCTR          29  
                            { 0xC4, 0,      1, 0, "CTR"         },
#define ifrRR           30  
                            { 0x6E, 0,      1, 0, "RR"          },
#define ifrPPR          31  
                            { 0xBC, 0,      1, 32,"PPR"         },
#define ifrRNR          32
                            { 0xEC, 0,      1, 0, "RNR"         },
#define ifrERR          33  
                            { 0x1C, 0,      1, 0, "ERR"         },
#define ifrPPS_NULL     34  
                            { 0xBE, 0x00+1, 1, 3, "PPS-NULL"    },
#define ifrPPS_MPS      35  
                            { 0xBE, 0x4F+1, 1, 3, "PPS-MPS"     },
#define ifrPPS_EOM      36  
                            { 0xBE, 0x8F+1, 1, 3, "PPS-EOM"     },
#define ifrPPS_EOP      37  
                            { 0xBE, 0x2F+1, 1, 3, "PPS-EOP"     },
#define ifrPPS_PRI_MPS  38  
                            { 0xBE, 0x5F+1, 1, 3, "PPS-PRI-MPS" },
#define ifrPPS_PRI_EOM  39  
                            { 0xBE, 0x9F+1, 1, 3, "PPS-PRI-EOM" },
#define ifrPPS_PRI_EOP  40  
                            { 0xBE, 0x3F+1, 1, 3, "PPS-PRI-EOP" },
#define ifrEOR_NULL     41  
                            { 0xCE, 0x00+1, 1, 0, "EOR-NULL"    },
#define ifrEOR_MPS      42  
                            { 0xCE, 0x4F+1, 1, 0, "EOR-MPS"     },
#define ifrEOR_EOM      43  
                            { 0xCE, 0x8F+1, 1, 0, "EOR-EOM"     },
#define ifrEOR_EOP      44  
                            { 0xCE, 0x2F+1, 1, 0, "EOR-EOP"     },
#define ifrEOR_PRI_MPS  45  
                            { 0xCE, 0x5F+1, 1, 0, "EOR-PRI-MPS" },
#define ifrEOR_PRI_EOM  46  
                            { 0xCE, 0x9F+1, 1, 0, "EOR-PRI-EOM" },
#define ifrEOR_PRI_EOP  47  
                            { 0xCE, 0x3F+1, 1, 0, "EOR-PRI-EOP" }
#define ifrMAX          48
};

#define EOX_FIRST      ifrMPS
#define EOX_LAST       ifrEOP
#define PRI_EOX_FIRST  ifrPRI_MPS
#define PRI_EOX_LAST   ifrPRI_EOP
#define PPS_X_FIRST    ifrPPS_NULL
#define PPS_X_LAST     ifrPPS_PRI_EOP

#ifdef DLEHERE
#       define          DLE             0x10
#       define          ETX             0x03
#endif //DLEHERE

/* Converts a the T30 code for a speed to the Class1 code
 * Generates V.17 with Long Training.
 * Add 1 to V.17 codes to get teh Short-train version
 */


/***************************************************************************
        Name      :     CreateFrame()
        Purpose   :     Create an HDLC frame
        Parameters:     IFR     ifr             == ifr number (index into rgfrFrameInfo),
                                                                        of frame to be generated.
                                LPB             lpbFIF  == pointer to FIF BYTEs
                                UWORD   uwFIFLen== length of the pbFIF array
                                BOOL    fFinal  == whether Final frame (to set bit 5 of BYTE 2)
                                NPB             npbOut  == pointer to space for frame
        Returns   : TRUE on success, FALSE if bogus params.
        CalledFrom: By the protocol module (external to the DLL) in addition
                                to internal use.
        Returns   :     Composes frame in lpframe->rgb[]
                                sets lpframe->cb to total length of frame.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

UWORD CreateFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fFinal, LPB lpbOut)
{
    CBPFRAME        cbpframe;       // need to worry about NEAR/FAR here...
                                                    // bpfr is a CODESEG based pointer
    LPB             lpbCurr;
    // UWORD           uw;

    BG_CHK(lpbOut && (uFIFLen>0 || !lpbFIF) && ifr>ifrNULL && ifr<ifrMAX);

    cbpframe                = &rgFrameInfo[ifr];
    lpbCurr         = lpbOut;
    *lpbCurr++      = 0xFF;                                                 // HDLC address field Sec 5.3.4
    *lpbCurr++      = (BYTE)(fFinal ? 0x13 : 0x03); // HDLC control field Sec 5.3.5

    if(pTG->T30.fReceivedDIS && cbpframe->fInsertDISBit)
    {
        *lpbCurr++ = (BYTE)(cbpframe->bFCF1 | 0x01);
    }
    else
    {
        *lpbCurr++ = cbpframe->bFCF1;
    }

        // we're not stuffing here, because we're sure FCF is never 0x10, but
        // use an assert() to make sure
#ifdef DLEHERE
        BG_CHK(*(lpbCurr-1) != DLE);
#endif //DLEHERE

    if(cbpframe->bFCF2)                                             // for ECM frames
        *lpbCurr++ = cbpframe->bFCF2-1;

#ifdef DLEHERE
        BG_CHK(*(lpbCurr-1) != DLE);
#endif //DLEHERE

    if(cbpframe->wFIFLength)        // check if FIF is reqd
    {
        BG_CHK(uFIFLen);

        // Cant stuff with DLEs here, because DLE stuffing has
        // to come *after* SW HDLC framing if any.
        // we _never_ do SW HDLC for negotiation frames (the only
        // ones that come thru here & we need the cycles, so do
        // teh stuffing here again).

        _fmemcpy(lpbCurr, lpbFIF, uFIFLen);
        lpbCurr += uFIFLen;

#ifdef DLEHERE
        for(uw=0; uw<uFIFLen; uw++)
        {
            if((*lpbCurr++ = lpbFIF[uw]) == DLE)
                    *lpbCurr++ = DLE;                               // stuff DLE
        }
#endif //DLEHERE

    }
    else
    {
        BG_CHK(uFIFLen == 0);
    }

#ifdef DLEHERE
    *lpbCurr++ = DLE;
    *lpbCurr++ = ETX;
    // *lpbCurr++ = '\r';   // RC224ATF sends this along with the frame!
                                                        // now if anyone *needs* it, we're hosed
#endif //DLEHERE

    *lpbCurr = 0;                   // for debugging printouts

    return (UWORD)(lpbCurr-lpbOut);
}


/***************************************************************************
        Name      :     SendFrame
        Purpose   :     Creates & sends HDLC frame & does some logging
        Parameters:     IFR     ifr             == Frame index
                                LPB             lpbFIF  == pointer to FIF data
                                UWORD   uwLen   == length of FIF data
                                BOOL    fFinal  == Set Final bit ON or not. Also
                                                                        whether to wait for OK or CONNECT
                                                                        after sending frame
        Returns   :     TRUE on success, FALSE on failure
        Calls     :     CreateFrame & WriteFrame
        CalledFrom:

        Comment   :     This routine is called from one quadrillion macros
                                defined in HDLC.H, one for each frame.
                                e g. SendCFR() macros to SendHDLC(ifrCFR, NULL, 0, TRUE)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define SF_LASTFR               (SEND_ENDFRAME|SEND_FINAL)
#define SF_NOTLASTFR    (SEND_ENDFRAME)


BOOL SendSingleFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fSleep)
{
    UWORD   cb;
    BYTE    bSend[MAXFRAMESIZE];

    DEBUG_FUNCTION_NAME(_T("SendSingleFrame"));
    // has to hold addr+control+FCF+possibly FCF2+FIF+(maybe DLE+ETX+CR+NULL)
    // == FIFlen + 8. Therefore bSend[] better be big enough.
    BG_CHK(uFIFLen+8<sizeof(bSend));

    // on IFAX, we really do want to wait for silence, otherwise we could
    // end up colliding with the other guy & wasting our time. SO give it a
    // very long (3sec?) timeout.
    // Here we always call RecvSilence. The IFAX driver looks for silence
    // to avoid collisions. The Class1 modem driver just uses TwiddleThumbs()
    // not FRS or FTS because they are dangerous and slow.

    // On PCs we should pause before ALL frames _except_ CFR & FTT (because
    // those are too time critical). On IFAX we pause always.

    if(ifr!=ifrCFR && ifr!=ifrFTT)
    {
        {
            if (fSleep) 
            {
                if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_LOWSPEED_PAUSE, LONG_RECVSILENCE_TIMEOUT))
                {
                    DebugPrintEx(   DEBUG_ERR,  
                                    "V21-Single RecvSilence(%d, %d) FAILED!!!",
                                    RECV_LOWSPEED_PAUSE, 
                                    LONG_RECVSILENCE_TIMEOUT);
                }
            }
        }
    }
    pTG->T30.fSendAfterSend=FALSE;

    if(!ModemSendMode(pTG, pTG->Params.hModem, V21_300, TRUE, ifr))
    {
        DebugPrintEx(DEBUG_ERR,"ModemSendMode failed in SendSingleFrame");
        return FALSE;
    }

    cb = CreateFrame(pTG,  ifr, lpbFIF, uFIFLen, TRUE, bSend);
    BG_CHK(cb >= uFIFLen+3);
    // BG_CHK(cb >= uFIFLen+5);

    D_PrintFrame(bSend, cb);

    //Protocol Dump
    DumpFrame(pTG, TRUE, ifr, uFIFLen, lpbFIF);

    PSSLogEntryHex(PSS_MSG, 2, bSend, cb, "send: %s, %d bytes,", rgFrameInfo[ifr].szName, cb);
    if(!ModemSendMem(pTG,  pTG->Params.hModem, bSend, cb, SF_LASTFR))
    {
        DebugPrintEx(DEBUG_ERR,"ModemSendMem failed in SendSingleFrame");
        return FALSE;
    }

    return TRUE;
}

BOOL SendManyFrames(PThrdGlbl pTG, LPLPFR lplpfr, USHORT uNumFrames)
{
    USHORT i;
    UWORD   cb;
    BYTE    bSend[MAXFRAMESIZE];
    ULONG   ulTimeout;
    IFR             ifrHint;

    DEBUG_FUNCTION_NAME(_T("SendManyFrames"));
    // ifrHint == last one
    ifrHint = lplpfr[uNumFrames-1]->ifr;

    // when sending DIS, DCS or DTC we may collide with DCS, DIS or DIS
    // coming from the other side. This can be really long
    // (preamble+2NSFs+CSI+DIS > 5secs) so wait for upto 10 secs!

    if(ifrHint==ifrDIS || ifrHint==ifrDCS || ifrHint==ifrDTC ||
       ifrHint==ifrNSS || ifrHint==ifrNSF || ifrHint==ifrNSC)
    {
        ulTimeout = REALLY_LONG_RECVSILENCE_TIMEOUT;    // 10secs
    }
    else
    {
        ulTimeout = LONG_RECVSILENCE_TIMEOUT;                   // 3secs
    }

    // on IFAX, we really do want to wait for silence, otherwise we could
    // end up colliding with the other guy & wasting our time. SO give it a
    // very long (3sec?) timeout.
    // Here we always call RecvSilence. The IFAX driver looks for silence
    // to avoid collisions. The Class1 modem driver just uses TwiddleThumbs()
    // not FRS or FTS because they are dangerous and slow.

    // We always pause before multi-frame sets
    if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_LOWSPEED_PAUSE, ulTimeout))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "V21-Multi RecvSilence(%d, %d) FAILED!!!",
                        RECV_LOWSPEED_PAUSE, 
                        ulTimeout);
    }
    pTG->T30.fSendAfterSend=FALSE;

    if(!ModemSendMode(pTG, pTG->Params.hModem, V21_300, TRUE, ifrHint))
    {
        DebugPrintEx(DEBUG_ERR,"ModemSendMode failed in SendManyFrames");
        return FALSE;
    }

    for(i=0; i<uNumFrames; i++)
    {
        // has to hold addr+control+FCF+possibly FCF2+FIF+(maybe DLE+ETX+CR+NULL)
        // == FIFlen + 8. Therefore bSend[] better be big enough.
        BG_CHK(lplpfr[i]->cb+8<sizeof(bSend));

        cb = CreateFrame(pTG, lplpfr[i]->ifr, lplpfr[i]->fif, lplpfr[i]->cb, (USHORT)(i==(uNumFrames-1)), bSend);

        D_PrintFrame(bSend, cb);

        //Protocol Dump
        DumpFrame(pTG, TRUE, lplpfr[i]->ifr, lplpfr[i]->cb, lplpfr[i]->fif);

        PSSLogEntryHex(PSS_MSG, 2, bSend, cb, "send: %s, %d bytes,", rgFrameInfo[lplpfr[i]->ifr].szName, cb);

        if(!ModemSendMem(pTG, pTG->Params.hModem, bSend, (USHORT)cb,
                        (USHORT)((i==(USHORT)(uNumFrames-1)) ? SF_LASTFR : SF_NOTLASTFR)))
        {
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************
        Name      :     SendTCF
        Purpose   :     Send a TCF signal. Waits until OK response from modem at end.
        Parameters:
        Returns   :     TRUE/FALSE

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

#define min(x,y)        (((x) < (y)) ? (x) : (y))
#define TCF_BUFSIZE     256

BOOL SendZeros(PThrdGlbl pTG, USHORT uCount, BOOL fFinal)
{
    BYTE    bZero[TCF_BUFSIZE];
    int             i;              // must be signed

    _fmemset(bZero, 0, TCF_BUFSIZE);

    PSSLogEntry(PSS_MSG, 2, "send: %d zeroes", uCount);
    
    for(i=uCount; i>0; i -= TCF_BUFSIZE)
    {
        if(i <= TCF_BUFSIZE)
        {
            // no need to stuff. They're all zeros!
            if(!ModemSendMem(pTG, pTG->Params.hModem, bZero, (USHORT)i, (USHORT)(fFinal?SEND_FINAL:0)))
               return FALSE;
        }
        else
        {
            // no need to stuff. They're all zeros!
            if(!ModemSendMem(pTG, pTG->Params.hModem, bZero, (USHORT)TCF_BUFSIZE, (USHORT) 0))
               return FALSE;
        }
    }
    return TRUE;
}

// length of TCF = 1.5 * bpscode * 100 / 8 == 75 * bpscode / 4


BOOL SendTCF(PThrdGlbl pTG)
{
    USHORT  uCount;
    USHORT  uCurMod;

    DEBUG_FUNCTION_NAME(_T("SendTCF"));

    uCurMod = ProtGetSendMod(pTG);
    // *Don't* add ST_FLAG. Need long train for TCF
    BG_CHK((uCurMod & (~0x0F)) == 0);

#ifndef MDDI2
    // length of TCF = 1.5 * bps / 8
    uCount = TCFLen[uCurMod & 0x0F];        // kill the ST_FLAG first

    // FTT testing!!
    // uCount = 450;
#endif

#if (PAGE_PREA